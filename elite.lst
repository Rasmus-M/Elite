XAS99 CROSS-ASSEMBLER   VERSION 3.6.5
     **** ****     > main.a99
0001                      copy "equates.a99"
     **** ****     > equates.a99
0001               **
0002               * Memory mapped addresses
0003               *
0004               vdpwd:                                 ; VDP write data
0005                      equ  >8c00
0006               vdpwa:                                 ; VDP set read/write address
0007                      equ  >8c02
0008               vdprd:                                 ; VDP read data
0009                      equ  >8800
0010               vdpsta:                                ; VDP status
0011                      equ  >8802
0012               sound:                                 ; Sound
0013                      equ  >8400
0014               spchwt:
0015                      equ  >9400
0016               spchrd:
0017                      equ  >9000
0018               
0019               workspace:
0020                      equ  >8300
0021               
0022               **
0023               * VDP memory map
0024               *
0025               pattern_table:                         ; Pattern table
0026                      equ  >0000
0027               sprite_pattern_table:                  ; Sprite pattern table
0028                      equ  >1800
0029               name_table:                            ; Name table
0030                      equ  >3800
0031               sprite_attr_table:                     ; Sprite attribute table
0032                      equ  >3b00
0033               color_table:                           ; Color table
0034                      equ  >2000
0035               
0036               **
0037               * Register map
0038               *
0039               rtmp:
0040      0000            requ 0
0041               rtmplb:
0042                      equ workspace + 1
0043               rtmp2:
0044      0000            requ 1
0045               rtmp3:
0046      0000            requ 2
0047               rtmp4:
0048      0000            requ 3
0049               rarg1:
0050      0000            requ 4
0051               rarg2:
0052      0000            requ 5
0053               rzero:
0054      0000            requ 6
0055               rone:
0056      0000            requ 7
0057               rmone:
0058      0000            requ 8
0059               rvdpwd:
0060      0000            requ 9
0061               rsp:
0062      0000            requ 10
0063               rsplb:
0064                      equ workspace + 21
0065               ra:
0066      0000            requ 13
0067               rx:
0068      0000            requ 14
0069               ry:
0070      0000            requ 15
0071               
0072               **
0073               * Constants
0074               *
0075               _MAX_COMMANDER:
0076                      equ  0
0077               _REMOVE_CHECKSUMS:
0078                      equ  1
0079               ZERO_PAGE.:
0080                      equ >0000
0081               STACK.:
0082                      equ >0100
0083               T.:
0084                      equ >0300
0085               CODE_WORDS.:
0086                      equ >0400
0087               K.:
0088                      equ >0900
0089               WP.:
0090                      equ >0D40
0091               CODE.:
0092                      equ >0F40
0093               CODE_UPPER.:
0094                      equ >A000
0095               CODE_PYTHON.:
0096                      equ >F200
0097               
0098               scr_buffer:
0099                      equ >6000
                   < main.a99
0002                      copy "macros.a99"
     **** ****     > macros.a99
0001               **
0002               * Macros
0003               *
0008               
0013               
0019               
0025               
0032               
0039               
0052               
0059               
0066               
0072               
0083               
0093               
0099               
0105               
0114               
0123               
0128               
0133               
0141               
0147               
0152               
0159               
0165               
0171               
0175               
0179               
0187               
0207               
                   < main.a99
0003                      copy "elite.a99"
     **** ****     > elite.a99
0001               * ******************************************************************************
0002               *
0003               * ELITE GAME SOURCE
0004               *
0005               * Elite was written by Ian Bell and David Braben and is copyright Acornsoft 1984
0006               *
0007               * The code on this site is identical to the source discs released on Ian Bell's
0008               * personal website at http://www.elitehomepage.org/ (it's just been reformatted
0009               * to be more readable)
0010               *
0011               * The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
0012               * in the documentation are entirely my fault
0013               *
0014               * The terminology and notations used in this commentary are explained at
0015               * https://elite.bbcelite.com/terminology
0016               *
0017               * The deep dive articles referred to in this commentary can be found at
0018               * https://elite.bbcelite.com/deep_dives
0019               *
0020               * ------------------------------------------------------------------------------
0021               *
0022               * This source file produces the following binary files:
0023               *
0024               * * ELTA.bin
0025               * * ELTB.bin
0026               * * ELTC.bin
0027               * * ELTD.bin
0028               * * ELTE.bin
0029               * * ELTF.bin
0030               * * ELTG.bin
0031               * * PYTHON.bin
0032               * * SHIPS.bin
0033               * * WORDS9.bin
0034               *
0035               * ******************************************************************************
0036               
0037                      ; INCLUDE "1-source-files/main-sources/elite-build-options.asm"
0038               
0039               _SOURCE_DISC:                                              ; (_VARIANT = 1)
0040                      equ 0
0041               _TEXT_SOURCES:                                             ; (_VARIANT = 2)
0042                      equ 0
0043               _STH_CASSETTE:                                             ; (_VARIANT = 3)
0044                      equ 1
0045               
0046                      ; GUARD &6000                                       ; Guard against assembling over screen memory
0047               
0048               * ******************************************************************************
0049               *
0050               * Configuration variables
0051               *
0052               * ******************************************************************************
0053               
0054               * ZERO_PAGE% = &0000
0055               
0056               * STACK% = &0100
0057               
0058               * CODE% = &0F40         \ The address where the code will be run
0059               
0060               LOAD.:                                                     ; The address where the code will be loaded
0061                      equ >1128
0062               
0063               * T% = &0300            \ Current commander data and stardust data blocks
0064               
0065               * CODE_WORDS% = &0400   \ The address where the text data will be run
0066               
0067               LOAD_WORDS.:                                               ; The address where the text data will be loaded
0068                      equ >1100
0069               
0070               * K% = &0900
0071               
0072               * WP% = &0D40
0073               
0074               * CODE_PYTHON% = &7F00
0075               
0076               Q.:                                                        ; Set Q% to TRUE to max out the default commander, FALSE
0077                      equ _MAX_COMMANDER
0078                                                                          ; for the standard default commander
0079               
0080               NOST:                                                      ; The number of stardust particles in normal space (this
0081                      equ 18
0082                                                                          ; goes down to 3 in witchspace)
0083               
0084               NOSH:                                                      ; The maximum number of ships in our local bubble of
0085                      equ 12
0086                                                                          ; universe
0087               
0088               NTY:                                                       ; The number of different ship types
0089                      equ 13
0090               
0091               COPS:                                                      ; Ship type for a Viper
0092                      equ 2
0093               
0094               THG:                                                       ; Ship type for a Thargoid
0095                      equ 6
0096               
0097               CYL:                                                       ; Ship type for a Cobra Mk III (trader)
0098                      equ 7
0099               
0100               SST:                                                       ; Ship type for the space station
0101                      equ 8
0102               
0103               MSL:                                                       ; Ship type for a missile
0104                      equ 9
0105               
0106               AST:                                                       ; Ship type for an asteroid
0107                      equ 10
0108               
0109               OIL:                                                       ; Ship type for a cargo canister
0110                      equ 11
0111               
0112               TGL:                                                       ; Ship type for a Thargon
0113                      equ 12
0114               
0115               ESC:                                                       ; Ship type for an escape pod
0116                      equ 13
0117               
0118               POW:                                                       ; Pulse laser power
0119                      equ 15
0120               
0121               NI.:                                                       ; The number of bytes in each ship's data block (as
0122                      equ 36
0123                                                                          ; stored in INWK and K%)
0124               
0125               VSCAN:                                                     ; Defines the split position in the split-screen mode
0126                      equ 57
0127               
0128               X:                                                         ; The centre x-coordinate of the 256 x 192 space view
0129                      equ 128
0130               
0131               Y:                                                         ; The centre y-coordinate of the 256 x 192 space view
0132                      equ 96
0133               
0134               f0_:                                                       ; Internal key number for red key f0 (Launch, Front)
0135                      equ >20
0136               
0137               f1_:                                                       ; Internal key number for red key f1 (Buy Cargo, Rear)
0138                      equ >71
0139               
0140               f2_:                                                       ; Internal key number for red key f2 (Sell Cargo, Left)
0141                      equ >72
0142               
0143               f3_:                                                       ; Internal key number for red key f3 (Equip Ship, Right)
0144                      equ >73
0145               
0146               f4_:                                                       ; Internal key number for red key f4 (Long-range Chart)
0147                      equ >14
0148               
0149               f5_:                                                       ; Internal key number for red key f5 (Short-range Chart)
0150                      equ >74
0151               
0152               f6_:                                                       ; Internal key number for red key f6 (Data on System)
0153                      equ >75
0154               
0155               f7_:                                                       ; Internal key number for red key f7 (Market Price)
0156                      equ >16
0157               
0158               f8_:                                                       ; Internal key number for red key f8 (Status Mode)
0159                      equ >76
0160               
0161               f9_:                                                       ; Internal key number for red key f9 (Inventory)
0162                      equ >77
0163               
0164               RE:                                                        ; The obfuscation byte used to hide the recursive tokens
0165                      equ >23
0166                                                                          ; table from crackers viewing the binary code
0167               
0168               VIA:                                                       ; Memory-mapped space for accessing internal hardware,
0169                      equ >FE00
0170                                                                          ; such as the video ULA, 6845 CRTC and 6522 VIAs (also
0171                                                                          ; known as SHEILA)
0172               
0173               * OSBYTE = &FFF4        \ The address for the OSBYTE routine, which is used
0174                                                                          ; three times in the main game code
0175               
0176               * OSWORD = &FFF1        \ The address for the OSWORD routine, which is used
0177                                                                          ; twice in the main game code
0178               
0179               * OSFILE = &FFDD        \ The address for the OSFILE routine, which is used
0180                                                                          ; once in the main game code
0181               
0182               * ******************************************************************************
0183               *
0184               * Name: ZP
0185               * Type: Workspace
0186               * Address: &0000 to &00B0
0187               * Category: Workspaces
0188               * Summary: Lots of important variables are stored in the zero page workspace
0189               * as it is quicker and more space-efficient to access memory here
0190               *
0191               * ******************************************************************************
0192               
0193                      aorg ZERO_PAGE.
0194               
0195               ZP:
0196 0000                 bss 0                                               ; The start of the zero page workspace
0197               
0198               RAND:
0199 0000                 bss 4                                               ; Four 8-bit seeds for the random number generation
0200                                                                          ; system implemented in the DORND routine
0201               
0202               TRTB.:
0203 0004                 bss 2                                               ; Contains the address of the keyboard translation
0204                                                                          ; table, which is used to translate internal key
0205                                                                          ; numbers to ASCII
0206               
0207               T1:
0208 0006                 bss 1                                               ; Temporary storage, used in a number of places
0209               
0210               SC:
0211 0007                 bss 1                                               ; Screen address (low byte)
0212                                                                          ;
0213                                                                          ; Elite draws on-screen by poking bytes directly into
0214                                                                          ; screen memory, and SC(1 0) is typically set to the
0215                                                                          ; address of the character block containing the pixel
0216                                                                          ; we want to draw (see the deep dives on "Drawing
0217                                                                          ; monochrome pixels in mode 4" and "Drawing colour
0218                                                                          ; pixels in mode 5" for more details)
0219               
0220               SCH:
0221 0008                 bss 1                                               ; Screen address (high byte)
0222               
0223               XX16:
0224 0009                 bss 18                                              ; Temporary storage for a block of values, used in a
0225                                                                          ; number of places
0226               
0227               P:
0228 001B                 bss 3                                               ; Temporary storage, used in a number of places
0229               
0230               XX0:
0231 001E                 bss 2                                               ; Temporary storage, used to store the address of a ship
0232                                                                          ; blueprint. For example, it is used when we add a new
0233                                                                          ; ship to the local bubble in routine NWSHP, and it
0234                                                                          ; contains the address of the current ship's blueprint
0235                                                                          ; as we loop through all the nearby ships in the main
0236                                                                          ; flight loop
0237               
0238               INF:
0239 0020                 bss 2                                               ; Temporary storage, typically used for storing the
0240                                                                          ; address of a ship's data block, so it can be copied
0241                                                                          ; to and from the internal workspace at INWK
0242               
0243               V:
0244 0022                 bss 2                                               ; Temporary storage, typically used for storing an
0245                                                                          ; address pointer
0246               
0247               XX:
0248 0024                 bss 2                                               ; Temporary storage, typically used for storing a 16-bit
0249                                                                          ; x-coordinate
0250               
0251               YY:
0252 0026                 bss 2                                               ; Temporary storage, typically used for storing a 16-bit
0253                                                                          ; y-coordinate
0254               
0255               SUNX:
0256 0028                 bss 2                                               ; The 16-bit x-coordinate of the vertical centre axis
0257                                                                          ; of the sun (which might be off-screen)
0258               
0259               BETA:
0260 002A                 bss 1                                               ; The current pitch angle beta, which is reduced from
0261                                                                          ; JSTY to a sign-magnitude value between -8 and +8
0262                                                                          ;
0263                                                                          ; This describes how fast we are pitching our ship, and
0264                                                                          ; determines how fast the universe pitches around us
0265                                                                          ;
0266                                                                          ; The sign bit is also stored in BET2, while the
0267                                                                          ; opposite sign is stored in BET2+1
0268               
0269               BET1:
0270 002B                 bss 1                                               ; The magnitude of the pitch angle beta, i.e. |beta|,
0271                                                                          ; which is a positive value between 0 and 8
0272               
0273               XC:
0274 002C                 bss 1                                               ; The x-coordinate of the text cursor (i.e. the text
0275                                                                          ; column), which can be from 0 to 32
0276                                                                          ;
0277                                                                          ; A value of 0 denotes the leftmost column and 32 the
0278                                                                          ; rightmost column, but because the top part of the
0279                                                                          ; screen (the space view) has a white border that
0280                                                                          ; clashes with columns 0 and 32, text is only shown
0281                                                                          ; in columns 1-31
0282               
0283               YC:
0284 002D                 bss 1                                               ; The y-coordinate of the text cursor (i.e. the text
0285                                                                          ; row), which can be from 0 to 23
0286                                                                          ;
0287                                                                          ; The screen actually has 31 character rows if you
0288                                                                          ; include the dashboard, but the text printing routines
0289                                                                          ; only work on the top part (the space view), so the
0290                                                                          ; text cursor only goes up to a maximum of 23, the row
0291                                                                          ; just before the screen splits
0292                                                                          ;
0293                                                                          ; A value of 0 denotes the top row, but because the
0294                                                                          ; top part of the screen has a white border that clashes
0295                                                                          ; with row 0, text is always shown at row 1 or greater
0296               
0297               QQ22:
0298 002E                 bss 2                                               ; The two hyperspace countdown counters
0299                                                                          ;
0300                                                                          ; Before a hyperspace jump, both QQ22 and QQ22+1 are
0301                                                                          ; set to 15
0302                                                                          ;
0303                                                                          ; QQ22 is an internal counter that counts down by 1
0304                                                                          ; each time TT102 is called, which happens every
0305                                                                          ; iteration of the main game loop. When it reaches
0306                                                                          ; zero, the on-screen counter in QQ22+1 gets
0307                                                                          ; decremented, and QQ22 gets set to 5 and the countdown
0308                                                                          ; continues (so the first tick of the hyperspace counter
0309                                                                          ; takes 15 iterations to happen, but subsequent ticks
0310                                                                          ; take 5 iterations each)
0311                                                                          ;
0312                                                                          ; QQ22+1 contains the number that's shown on-screen
0313                                                                          ; during the countdown. It counts down from 15 to 1, and
0314                                                                          ; when it hits 0, the hyperspace engines kick in
0315               
0316               ECMA:
0317 0030                 bss 1                                               ; The E.C.M. countdown timer, which determines whether
0318                                                                          ; an E.C.M. system is currently operating:
0319                                                                          ;
0320                                                                          ; * 0 = E.C.M. is off
0321                                                                          ;
0322                                                                          ; * Non-zero = E.C.M. is on and is counting down
0323                                                                          ;
0324                                                                          ; The counter starts at 32 when an E.C.M. is activated,
0325                                                                          ; either by us or by an opponent, and it decreases by 1
0326                                                                          ; in each iteration of the main flight loop until it
0327                                                                          ; reaches zero, at which point the E.C.M. switches off.
0328                                                                          ; Only one E.C.M. can be active at any one time, so
0329                                                                          ; there is only one counter
0330               
0331               XX15:
0332 0031                 bss 0                                               ; Temporary storage, typically used for storing screen
0333                                                                          ; coordinates in line-drawing routines
0334                                                                          ;
0335                                                                          ; There are six bytes of storage, from XX15 TO XX15+5.
0336                                                                          ; The first four bytes have the following aliases:
0337                                                                          ;
0338                                                                          ; X1 = XX15
0339                                                                          ; Y1 = XX15+1
0340                                                                          ; X2 = XX15+2
0341                                                                          ; Y2 = XX15+3
0342                                                                          ;
0343                                                                          ; These are typically used for describing lines in terms
0344                                                                          ; of screen coordinates, i.e. (X1, Y1) to (X2, Y2)
0345                                                                          ;
0346                                                                          ; The last two bytes of XX15 do not have aliases
0347               
0348               X1:
0349 0031                 bss 1                                               ; Temporary storage, typically used for x-coordinates in
0350                                                                          ; line-drawing routines
0351               
0352               Y1:
0353 0032                 bss 1                                               ; Temporary storage, typically used for y-coordinates in
0354                                                                          ; line-drawing routines
0355               
0356               X2:
0357 0033                 bss 1                                               ; Temporary storage, typically used for x-coordinates in
0358                                                                          ; line-drawing routines
0359               
0360               Y2:
0361 0034                 bss 1                                               ; Temporary storage, typically used for y-coordinates in
0362                                                                          ; line-drawing routines
0363               
0364 0035                 bss 2                                               ; The last two bytes of the XX15 block
0365               
0366               XX12:
0367 0037                 bss 6                                               ; Temporary storage for a block of values, used in a
0368                                                                          ; number of places
0369               
0370               K:
0371 003D                 bss 4                                               ; Temporary storage, used in a number of places
0372               
0373               KL:
0374 0041                 bss 1                                               ; The following bytes implement a key logger that
0375                                                                          ; enables Elite to scan for concurrent key presses of
0376                                                                          ; the primary flight keys, plus a secondary flight key
0377                                                                          ;
0378                                                                          ; See the deep dive on "The key logger" for more details
0379                                                                          ;
0380                                                                          ; If a key is being pressed that is not in the keyboard
0381                                                                          ; table at KYTB, it can be stored here (as seen in
0382                                                                          ; routine DK4, for example)
0383               
0384               KY1:
0385 0042                 bss 1                                               ; "?" is being pressed
0386                                                                          ;
0387                                                                          ; * 0 = no
0388                                                                          ;
0389                                                                          ; * Non-zero = yes
0390               
0391               KY2:
0392 0043                 bss 1                                               ; Space is being pressed
0393                                                                          ;
0394                                                                          ; * 0 = no
0395                                                                          ;
0396                                                                          ; * Non-zero = yes
0397               
0398               KY3:
0399 0044                 bss 1                                               ; "<" is being pressed
0400                                                                          ;
0401                                                                          ; * 0 = no
0402                                                                          ;
0403                                                                          ; * Non-zero = yes
0404               
0405               KY4:
0406 0045                 bss 1                                               ; ">" is being pressed
0407                                                                          ;
0408                                                                          ; * 0 = no
0409                                                                          ;
0410                                                                          ; * Non-zero = yes
0411               
0412               KY5:
0413 0046                 bss 1                                               ; "X" is being pressed
0414                                                                          ;
0415                                                                          ; * 0 = no
0416                                                                          ;
0417                                                                          ; * Non-zero = yes
0418               
0419               KY6:
0420 0047                 bss 1                                               ; "S" is being pressed
0421                                                                          ;
0422                                                                          ; * 0 = no
0423                                                                          ;
0424                                                                          ; * Non-zero = yes
0425               
0426               KY7:
0427 0048                 bss 1                                               ; "A" is being pressed
0428                                                                          ;
0429                                                                          ; * 0 = no
0430                                                                          ;
0431                                                                          ; * Non-zero = yes
0432                                                                          ;
0433                                                                          ; This is also set when the joystick fire button has
0434                                                                          ; been pressed
0435               
0436               KY12:
0437 0049                 bss 1                                               ; TAB is being pressed
0438                                                                          ;
0439                                                                          ; * 0 = no
0440                                                                          ;
0441                                                                          ; * Non-zero = yes
0442               
0443               KY13:
0444 004A                 bss 1                                               ; ESCAPE is being pressed
0445                                                                          ;
0446                                                                          ; * 0 = no
0447                                                                          ;
0448                                                                          ; * Non-zero = yes
0449               
0450               KY14:
0451 004B                 bss 1                                               ; "T" is being pressed
0452                                                                          ;
0453                                                                          ; * 0 = no
0454                                                                          ;
0455                                                                          ; * Non-zero = yes
0456               
0457               KY15:
0458 004C                 bss 1                                               ; "U" is being pressed
0459                                                                          ;
0460                                                                          ; * 0 = no
0461                                                                          ;
0462                                                                          ; * Non-zero = yes
0463               
0464               KY16:
0465 004D                 bss 1                                               ; "M" is being pressed
0466                                                                          ;
0467                                                                          ; * 0 = no
0468                                                                          ;
0469                                                                          ; * Non-zero = yes
0470               
0471               KY17:
0472 004E                 bss 1                                               ; "E" is being pressed
0473                                                                          ;
0474                                                                          ; * 0 = no
0475                                                                          ;
0476                                                                          ; * Non-zero = yes
0477               
0478               KY18:
0479 004F                 bss 1                                               ; "J" is being pressed
0480                                                                          ;
0481                                                                          ; * 0 = no
0482                                                                          ;
0483                                                                          ; * Non-zero = yes
0484               
0485               KY19:
0486 0050                 bss 1                                               ; "C" is being pressed
0487                                                                          ;
0488                                                                          ; * 0 = no
0489                                                                          ;
0490                                                                          ; * Non-zero = yes
0491               
0492               LAS:
0493 0051                 bss 1                                               ; Contains the laser power of the laser fitted to the
0494                                                                          ; current space view (or 0 if there is no laser fitted
0495                                                                          ; to the current view)
0496                                                                          ;
0497                                                                          ; This gets set to bits 0-6 of the laser power byte from
0498                                                                          ; the commander data block, which contains the laser's
0499                                                                          ; power (bit 7 doesn't denote laser power, just whether
0500                                                                          ; or not the laser pulses, so that is not stored here)
0501               
0502               MSTG:
0503 0052                 bss 1                                               ; The current missile lock target
0504                                                                          ;
0505                                                                          ; * &FF = no target
0506                                                                          ;
0507                                                                          ; * 1-12 = the slot number of the ship that our
0508                                                                          ; missile is locked onto
0509               
0510               XX1:
0511 0053                 bss 0                                               ; This is an alias for INWK that is used in the main
0512                                                                          ; ship-drawing routine at LL9
0513               
0514               INWK:
0515 0053                 bss 33                                              ; The zero-page internal workspace for the current ship
0516                                                                          ; data block
0517                                                                          ;
0518                                                                          ; As operations on zero page locations are faster and
0519                                                                          ; have smaller opcodes than operations on the rest of
0520                                                                          ; the addressable memory, Elite tends to store oft-used
0521                                                                          ; data here. A lot of the routines in Elite need to
0522                                                                          ; access and manipulate ship data, so to make this an
0523                                                                          ; efficient exercise, the ship data is first copied from
0524                                                                          ; the ship data blocks at K% into INWK (or, when new
0525                                                                          ; ships are spawned, from the blueprints at XX21). See
0526                                                                          ; the deep dive on "Ship data blocks" for details of
0527                                                                          ; what each of the bytes in the INWK data block
0528                                                                          ; represents
0529               
0530               XX19:
0531 0074                 bss NI. - 33                                        ; XX19(1 0) shares its location with INWK(34 33), which
0532                                                                          ; contains the address of the ship line heap
0533               
0534               LSP:
0535 0077                 bss 1                                               ; The ball line heap pointer, which contains the number
0536                                                                          ; of the first free byte after the end of the LSX2 and
0537                                                                          ; LSY2 heaps (see the deep dive on "The ball line heap"
0538                                                                          ; for details)
0539               
0540               QQ15:
0541 0078                 bss 6                                               ; The three 16-bit seeds for the selected system, i.e.
0542                                                                          ; the one in the crosshairs in the Short-range Chart
0543                                                                          ;
0544                                                                          ; See the deep dives on "Galaxy and system seeds" and
0545                                                                          ; "Twisting the system seeds" for more details
0546               
0547               K5:
0548 007E                 bss 0                                               ; Temporary storage used to store segment coordinates
0549                                                                          ; across successive calls to BLINE, the ball line
0550                                                                          ; routine
0551               
0552               XX18:
0553 007E                 bss 0                                               ; Temporary storage used to store coordinates in the
0554                                                                          ; LL9 ship-drawing routine
0555               
0556               QQ17:
0557 007E                 bss 1                                               ; Contains a number of flags that affect how text tokens
0558                                                                          ; are printed, particularly capitalisation:
0559                                                                          ;
0560                                                                          ; * If all bits are set (255) then text printing is
0561                                                                          ; disabled
0562                                                                          ;
0563                                                                          ; * Bit 7: 0 = ALL CAPS
0564                                                                          ; 1 = Sentence Case, bit 6 determines the
0565                                                                          ; case of the next letter to print
0566                                                                          ;
0567                                                                          ; * Bit 6: 0 = print the next letter in upper case
0568                                                                          ; 1 = print the next letter in lower case
0569                                                                          ;
0570                                                                          ; * Bits 0-5: If any of bits 0-5 are set, print in
0571                                                                          ; lower case
0572                                                                          ;
0573                                                                          ; So:
0574                                                                          ;
0575                                                                          ; * QQ17 = 0 means case is set to ALL CAPS
0576                                                                          ;
0577                                                                          ; * QQ17 = %10000000 means Sentence Case, currently
0578                                                                          ; printing upper case
0579                                                                          ;
0580                                                                          ; * QQ17 = %11000000 means Sentence Case, currently
0581                                                                          ; printing lower case
0582                                                                          ;
0583                                                                          ; * QQ17 = %11111111 means printing is disabled
0584               
0585               QQ19:
0586 007F                 bss 3                                               ; Temporary storage, used in a number of places
0587               
0588               K6:
0589 0082                 bss 5                                               ; Temporary storage, typically used for storing
0590                                                                          ; coordinates during vector calculations
0591               
0592               ALP1:
0593 0087                 bss 1                                               ; Magnitude of the roll angle alpha, i.e. |alpha|,
0594                                                                          ; which is a positive value between 0 and 31
0595               
0596               ALP2:
0597 0088                 bss 2                                               ; Bit 7 of ALP2 = sign of the roll angle in ALPHA
0598                                                                          ;
0599                                                                          ; Bit 7 of ALP2+1 = opposite sign to ALP2 and ALPHA
0600               
0601               BET2:
0602 008A                 bss 2                                               ; Bit 7 of BET2 = sign of the pitch angle in BETA
0603                                                                          ;
0604                                                                          ; Bit 7 of BET2+1 = opposite sign to BET2 and BETA
0605               
0606               DELTA:
0607 008C                 bss 1                                               ; Our current speed, in the range 1-40
0608               
0609               DELT4:
0610 008D                 bss 2                                               ; Our current speed * 64 as a 16-bit value
0611                                                                          ;
0612                                                                          ; This is stored as DELT4(1 0), so the high byte in
0613                                                                          ; DELT4+1 therefore contains our current speed / 4
0614               
0615               U:
0616 008F                 bss 1                                               ; Temporary storage, used in a number of places
0617               
0618               Q:
0619 0090                 bss 1                                               ; Temporary storage, used in a number of places
0620               
0621               R:
0622 0091                 bss 1                                               ; Temporary storage, used in a number of places
0623               
0624               S:
0625 0092                 bss 1                                               ; Temporary storage, used in a number of places
0626               
0627               XSAV:
0628 0093                 bss 1                                               ; Temporary storage for saving the value of the X
0629                                                                          ; register, used in a number of places
0630               
0631               YSAV:
0632 0094                 bss 1                                               ; Temporary storage for saving the value of the Y
0633                                                                          ; register, used in a number of places
0634               
0635               XX17:
0636 0095                 bss 1                                               ; Temporary storage, used in BPRNT to store the number
0637                                                                          ; of characters to print, and as the edge counter in the
0638                                                                          ; main ship-drawing routine
0639               
0640               QQ11:
0641 0096                 bss 1                                               ; The type of the current view:
0642                                                                          ;
0643                                                                          ; 0   = Space view
0644                                                                          ; 1   = Title screen
0645                                                                          ; Get commander name ("@", save/load commander)
0646                                                                          ; In-system jump just arrived ("J")
0647                                                                          ; Data on System screen (red key f6)
0648                                                                          ; Buy Cargo screen (red key f1)
0649                                                                          ; Mis-jump just arrived (witchspace)
0650                                                                          ; 4   = Sell Cargo screen (red key f2)
0651                                                                          ; 6   = Death screen
0652                                                                          ; 8   = Status Mode screen (red key f8)
0653                                                                          ; Inventory screen (red key f9)
0654                                                                          ; 16  = Market Price screen (red key f7)
0655                                                                          ; 32  = Equip Ship screen (red key f3)
0656                                                                          ; 64  = Long-range Chart (red key f4)
0657                                                                          ; 128 = Short-range Chart (red key f5)
0658                                                                          ;
0659                                                                          ; This value is typically set by calling routine TT66
0660               
0661               ZZ:
0662 0097                 bss 1                                               ; Temporary storage, typically used for distance values
0663               
0664               XX13:
0665 0098                 bss 1                                               ; Temporary storage, typically used in the line-drawing
0666                                                                          ; routines
0667               
0668               MCNT:
0669 0099                 bss 1                                               ; The main loop counter
0670                                                                          ;
0671                                                                          ; This counter determines how often certain actions are
0672                                                                          ; performed within the main loop. See the deep dive on
0673                                                                          ; "Scheduling tasks with the main loop counter" for more
0674                                                                          ; details
0675               
0676               DL:
0677 009A                 bss 1                                               ; Vertical sync flag
0678                                                                          ;
0679                                                                          ; DL gets set to 30 every time we reach vertical sync on
0680                                                                          ; the video system, which happens 50 times a second
0681                                                                          ; (50Hz). The WSCAN routine uses this to pause until the
0682                                                                          ; vertical sync, by setting DL to 0 and then monitoring
0683                                                                          ; its value until it changes to 30
0684               
0685               TYPE:
0686 009B                 bss 1                                               ; The current ship type
0687                                                                          ;
0688                                                                          ; This is where we store the current ship type for when
0689                                                                          ; we are iterating through the ships in the local bubble
0690                                                                          ; as part of the main flight loop. See the table at XX21
0691                                                                          ; for information about ship types
0692               
0693               JSTX:
0694 009C                 bss 1                                               ; Our current roll rate
0695                                                                          ;
0696                                                                          ; This value is shown in the dashboard's RL indicator,
0697                                                                          ; and determines the rate at which we are rolling
0698                                                                          ;
0699                                                                          ; The value ranges from 1 to 255 with 128 as the centre
0700                                                                          ; point, so 1 means roll is decreasing at the maximum
0701                                                                          ; rate, 128 means roll is not changing, and 255 means
0702                                                                          ; roll is increasing at the maximum rate
0703                                                                          ;
0704                                                                          ; This value is updated by "<" and ">" key presses, or
0705                                                                          ; if joysticks are enabled, from the joystick. If
0706                                                                          ; keyboard damping is enabled (which it is by default),
0707                                                                          ; the value is slowly moved towards the centre value of
0708                                                                          ; 128 (no roll) if there are no key presses or joystick
0709                                                                          ; movement
0710               
0711               JSTY:
0712 009D                 bss 1                                               ; Our current pitch rate
0713                                                                          ;
0714                                                                          ; This value is shown in the dashboard's DC indicator,
0715                                                                          ; and determines the rate at which we are pitching
0716                                                                          ;
0717                                                                          ; The value ranges from 1 to 255 with 128 as the centre
0718                                                                          ; point, so 1 means pitch is decreasing at the maximum
0719                                                                          ; rate, 128 means pitch is not changing, and 255 means
0720                                                                          ; pitch is increasing at the maximum rate
0721                                                                          ;
0722                                                                          ; This value is updated by "S" and "X" key presses, or
0723                                                                          ; if joysticks are enabled, from the joystick. If
0724                                                                          ; keyboard damping is enabled (which it is by default),
0725                                                                          ; the value is slowly moved towards the centre value of
0726                                                                          ; 128 (no pitch) if there are no key presses or joystick
0727                                                                          ; movement
0728               
0729               ALPHA:
0730 009E                 bss 1                                               ; The current roll angle alpha, which is reduced from
0731                                                                          ; JSTX to a sign-magnitude value between -31 and +31
0732                                                                          ;
0733                                                                          ; This describes how fast we are rolling our ship, and
0734                                                                          ; determines how fast the universe rolls around us
0735                                                                          ;
0736                                                                          ; The sign bit is also stored in ALP2, while the
0737                                                                          ; opposite sign is stored in ALP2+1
0738               
0739               QQ12:
0740 009F                 bss 1                                               ; Our "docked" status
0741                                                                          ;
0742                                                                          ; * 0 = we are not docked
0743                                                                          ;
0744                                                                          ; * &FF = we are docked
0745               
0746               TGT:
0747 00A0                 bss 1                                               ; Temporary storage, typically used as a target value
0748                                                                          ; for counters when drawing explosion clouds and partial
0749                                                                          ; circles
0750               
0751               SWAP:
0752 00A1                 bss 1                                               ; Temporary storage, used to store a flag that records
0753                                                                          ; whether or not we had to swap a line's start and end
0754                                                                          ; coordinates around when clipping the line in routine
0755                                                                          ; LL145 (the flag is used in places like BLINE to swap
0756                                                                          ; them back)
0757               
0758               COL:
0759 00A2                 bss 1                                               ; Temporary storage, used to store colour information
0760                                                                          ; when drawing pixels in the dashboard
0761               
0762               FLAG:
0763 00A3                 bss 1                                               ; A flag that's used to define whether this is the first
0764                                                                          ; call to the ball line routine in BLINE, so it knows
0765                                                                          ; whether to wait for the second call before storing
0766                                                                          ; segment data in the ball line heap
0767               
0768               CNT:
0769 00A4                 bss 1                                               ; Temporary storage, typically used for storing the
0770                                                                          ; number of iterations required when looping
0771               
0772               CNT2:
0773 00A5                 bss 1                                               ; Temporary storage, used in the planet-drawing routine
0774                                                                          ; to store the segment number where the arc of a partial
0775                                                                          ; circle should start
0776               
0777               STP:
0778 00A6                 bss 1                                               ; The step size for drawing circles
0779                                                                          ;
0780                                                                          ; Circles in Elite are split up into 64 points, and the
0781                                                                          ; step size determines how many points to skip with each
0782                                                                          ; straight-line segment, so the smaller the step size,
0783                                                                          ; the smoother the circle. The values used are:
0784                                                                          ;
0785                                                                          ; * 2 for big planets and the circles on the charts
0786                                                                          ; * 4 for medium planets and the launch tunnel
0787                                                                          ; * 8 for small planets and the hyperspace tunnel
0788                                                                          ;
0789                                                                          ; As the step size increases we move from smoother
0790                                                                          ; circles at the top to more polygonal at the bottom.
0791                                                                          ; See the CIRCLE2 routine for more details
0792               
0793               XX4:
0794 00A7                 bss 1                                               ; Temporary storage, used in a number of places
0795               
0796               XX20:
0797 00A8                 bss 1                                               ; Temporary storage, used in a number of places
0798               
0799               XX14:
0800 00A9                 bss 1                                               ; This byte appears to be unused
0801               
0802               RAT:
0803 00AA                 bss 1                                               ; Used to store different signs depending on the current
0804                                                                          ; space view, for use in calculating stardust movement
0805               
0806               RAT2:
0807 00AB                 bss 1                                               ; Temporary storage, used to store the pitch and roll
0808                                                                          ; signs when moving objects and stardust
0809               
0810               K2:
0811 00AC                 bss 4                                               ; Temporary storage, used in a number of places
0812               
0813               * RM: At &00B0 = 176
0814               
0815                      aorg ZERO_PAGE.+>00D1
0816               
0817               T:
0818 00D1                 bss 1                                               ; Temporary storage, used in a number of places
0819               
0820               K3:
0821 00D2                 bss 0                                               ; Temporary storage, used in a number of places
0822               
0823               XX2:
0824 00D2                 bss 14                                              ; Temporary storage, used to store the visibility of the
0825                                                                          ; ship's faces during the ship-drawing routine at LL9
0826               
0827               K4:
0828 00E0                 bss 2                                               ; Temporary storage, used in a number of places
0829               
0830                      ; PRINT "Zero page variables from ", ~ZP, " to ", ~P%
0831               
0832               * ******************************************************************************
0833               *
0834               * Name: XX3
0835               * Type: Workspace
0836               * Address: &0100 to the top of the descending stack
0837               * Category: Workspaces
0838               * Summary: Temporary storage space for complex calculations
0839               *
0840               * ------------------------------------------------------------------------------
0841               *
0842               * Used as heap space for storing temporary data during calculations. Shared with
0843               * the descending 6502 stack, which works down from &01FF.
0844               *
0845               * ******************************************************************************
0846               
0847                      aorg STACK.
0848               
0849               XX3:
0850 0100                 bss 256                                             ; Temporary storage, typically used for storing tables
0851                                                                          ; of values such as screen coordinates or ship data
0852               
0853               * ******************************************************************************
0854               *
0855               * Name: T%
0856               * Type: Workspace
0857               * Address: &0300 to &035F
0858               * Category: Workspaces
0859               * Summary: Current commander data and stardust data blocks
0860               *
0861               * ------------------------------------------------------------------------------
0862               *
0863               * Contains the current commander data (NT% bytes at location TP), and the
0864               * stardust data blocks (NOST bytes at location SX)
0865               *
0866               * ******************************************************************************
0867               
0868                      aorg T.
0869               
0870 0300                 bss 0                                               ; The start of the T% workspace
0871               
0872               TP:
0873 0300                 bss 1                                               ; The current mission status, which is always 0 for the
0874                                                                          ; cassette version of Elite as there are no missions
0875               
0876               QQ0:
0877 0301                 bss 1                                               ; The current system's galactic x-coordinate (0-256)
0878               
0879               QQ1:
0880 0302                 bss 1                                               ; The current system's galactic y-coordinate (0-256)
0881               
0882               QQ21:
0883 0303                 bss 6                                               ; The three 16-bit seeds for the current galaxy
0884                                                                          ;
0885                                                                          ; These seeds define system 0 in the current galaxy, so
0886                                                                          ; they can be used as a starting point to generate all
0887                                                                          ; 256 systems in the galaxy
0888                                                                          ;
0889                                                                          ; Using a galactic hyperdrive rotates each byte to the
0890                                                                          ; left (rolling each byte within itself) to get the
0891                                                                          ; seeds for the next galaxy, so after eight galactic
0892                                                                          ; jumps, the seeds roll around to the first galaxy again
0893                                                                          ;
0894                                                                          ; See the deep dives on "Galaxy and system seeds" and
0895                                                                          ; "Twisting the system seeds" for more details
0896               
0897               CASH:
0898 0309                 bss 4                                               ; Our current cash pot
0899                                                                          ;
0900                                                                          ; The cash stash is stored as a 32-bit unsigned integer,
0901                                                                          ; with the most significant byte in CASH and the least
0902                                                                          ; significant in CASH+3. This is big-endian, which is
0903                                                                          ; the opposite way round to most of the numbers used in
0904                                                                          ; Elite - to use our notation for multi-byte numbers,
0905                                                                          ; the amount of cash is CASH(0 1 2 3)
0906               
0907               QQ14:
0908 030D                 bss 1                                               ; Our current fuel level (0-70)
0909                                                                          ;
0910                                                                          ; The fuel level is stored as the number of light years
0911                                                                          ; multiplied by 10, so QQ14 = 1 represents 0.1 light
0912                                                                          ; years, and the maximum possible value is 70, for 7.0
0913                                                                          ; light years
0914               
0915               COK:
0916 030E                 bss 1                                               ; Flags used to generate the competition code
0917                                                                          ;
0918                                                                          ; See the deep dive on "The competition code" for
0919                                                                          ; details of these flags and how they are used in
0920                                                                          ; generating and decoding the competition code
0921               
0922               GCNT:
0923 030F                 bss 1                                               ; The number of the current galaxy (0-7)
0924                                                                          ;
0925                                                                          ; When this is displayed in-game, 1 is added to the
0926                                                                          ; number, so we start in galaxy 1 in-game, but it's
0927                                                                          ; stored as galaxy 0 internally
0928                                                                          ;
0929                                                                          ; The galaxy number increases by one every time a
0930                                                                          ; galactic hyperdrive is used, and wraps back around to
0931                                                                          ; the start after eight galaxies
0932               
0933               LASER:
0934 0310                 bss 4                                               ; The specifications of the lasers fitted to each of the
0935                                                                          ; four space views:
0936                                                                          ;
0937                                                                          ; * Byte #0 = front view
0938                                                                          ; * Byte #1 = rear view
0939                                                                          ; * Byte #2 = left view
0940                                                                          ; * Byte #3 = right view
0941                                                                          ;
0942                                                                          ; For each of the views:
0943                                                                          ;
0944                                                                          ; * 0 = no laser is fitted to this view
0945                                                                          ;
0946                                                                          ; * Non-zero = a laser is fitted to this view, with
0947                                                                          ; the following specification:
0948                                                                          ;
0949                                                                          ; * Bits 0-6 contain the laser's power
0950                                                                          ;
0951                                                                          ; * Bit 7 determines whether or not the laser pulses
0952                                                                          ; (0 = pulse laser) or is always on (1 = beam
0953                                                                          ; laser)
0954               
0955 0314                 bss 2                                               ; These bytes appear to be unused (they were originally
0956                                                                          ; used for up/down lasers, but they were dropped)
0957               
0958               CRGO:
0959 0316                 bss 1                                               ; Our ship's cargo capacity
0960                                                                          ;
0961                                                                          ; * 22 = standard cargo bay of 20 tonnes
0962                                                                          ;
0963                                                                          ; * 37 = large cargo bay of 35 tonnes
0964                                                                          ;
0965                                                                          ; The value is two greater than the actual capacity to
0966                                                                          ; make the maths in tnpr slightly more efficient
0967               
0968               QQ20:
0969 0317                 bss 17                                              ; The contents of our cargo hold
0970                                                                          ;
0971                                                                          ; The amount of market item X that we have in our hold
0972                                                                          ; can be found in the X-th byte of QQ20. For example:
0973                                                                          ;
0974                                                                          ; * QQ20 contains the amount of food (item 0)
0975                                                                          ;
0976                                                                          ; * QQ20+7 contains the amount of computers (item 7)
0977                                                                          ;
0978                                                                          ; See QQ23 for a list of market item numbers and their
0979                                                                          ; storage units
0980               
0981               ECM:
0982 0328                 bss 1                                               ; E.C.M. system
0983                                                                          ;
0984                                                                          ; * 0 = not fitted
0985                                                                          ;
0986                                                                          ; * &FF = fitted
0987               
0988               BST:
0989 0329                 bss 1                                               ; Fuel scoops (BST stands for "barrel status")
0990                                                                          ;
0991                                                                          ; * 0 = not fitted
0992                                                                          ;
0993                                                                          ; * &FF = fitted
0994               
0995               BOMB:
0996 032A                 bss 1                                               ; Energy bomb
0997                                                                          ;
0998                                                                          ; * 0 = not fitted
0999                                                                          ;
1000                                                                          ; * &7F = fitted
1001               
1002               ENGY:
1003 032B                 bss 1                                               ; Energy unit
1004                                                                          ;
1005                                                                          ; * 0 = not fitted
1006                                                                          ;
1007                                                                          ; * Non-zero = fitted
1008                                                                          ;
1009                                                                          ; The actual value determines the refresh rate of our
1010                                                                          ; energy banks, as they refresh by ENGY+1 each time (so
1011                                                                          ; our ship's energy level goes up by 2 each time if we
1012                                                                          ; have an energy unit fitted, otherwise it goes up by 1)
1013               
1014               DKCMP:
1015 032C                 bss 1                                               ; Docking computer
1016                                                                          ;
1017                                                                          ; * 0 = not fitted
1018                                                                          ;
1019                                                                          ; * &FF = fitted
1020               
1021               GHYP:
1022 032D                 bss 1                                               ; Galactic hyperdrive
1023                                                                          ;
1024                                                                          ; * 0 = not fitted
1025                                                                          ;
1026                                                                          ; * &FF = fitted
1027               
1028               ESCP:
1029 032E                 bss 1                                               ; Escape pod
1030                                                                          ;
1031                                                                          ; * 0 = not fitted
1032                                                                          ;
1033                                                                          ; * &FF = fitted
1034               
1035 032F                 bss 4                                               ; These bytes appear to be unused
1036               
1037               NOMSL:
1038 0333                 bss 1                                               ; The number of missiles we have fitted (0-4)
1039               
1040               FIST:
1041 0334                 bss 1                                               ; Our legal status (FIST stands for "fugitive/innocent
1042                                                                          ; status"):
1043                                                                          ;
1044                                                                          ; * 0 = Clean
1045                                                                          ;
1046                                                                          ; * 1-49 = Offender
1047                                                                          ;
1048                                                                          ; * 50+ = Fugitive
1049                                                                          ;
1050                                                                          ; You get 64 points if you kill a cop, so that's a fast
1051                                                                          ; ticket to fugitive status
1052               
1053               AVL:
1054 0335                 bss 17                                              ; Market availability in the current system
1055                                                                          ;
1056                                                                          ; The available amount of market item X is stored in
1057                                                                          ; the X-th byte of AVL, so for example:
1058                                                                          ;
1059                                                                          ; * AVL contains the amount of food (item 0)
1060                                                                          ;
1061                                                                          ; * AVL+7 contains the amount of computers (item 7)
1062                                                                          ;
1063                                                                          ; See QQ23 for a list of market item numbers and their
1064                                                                          ; storage units, and the deep dive on "Market item
1065                                                                          ; prices and availability" for details of the algorithm
1066                                                                          ; used for calculating each item's availability
1067               
1068               QQ26:
1069 0346                 bss 1                                               ; A random value used to randomise market data
1070                                                                          ;
1071                                                                          ; This value is set to a new random number for each
1072                                                                          ; change of system, so we can add a random factor into
1073                                                                          ; the calculations for market prices (for details of how
1074                                                                          ; this is used, see the deep dive on "Market prices")
1075               
1076               TALLY:
1077 0347                 bss 2                                               ; Our combat rank
1078                                                                          ;
1079                                                                          ; The combat rank is stored as the number of kills, in a
1080                                                                          ; 16-bit number TALLY(1 0) - so the high byte is in
1081                                                                          ; TALLY+1 and the low byte in TALLY
1082                                                                          ;
1083                                                                          ; If the high byte in TALLY+1 is 0 then we have between
1084                                                                          ; 0 and 255 kills, so our rank is Harmless, Mostly
1085                                                                          ; Harmless, Poor, Average or Above Average, according to
1086                                                                          ; the value of the low byte in TALLY:
1087                                                                          ;
1088                                                                          ; Harmless        = %00000000 to %00000011 = 0 to 3
1089                                                                          ; Mostly Harmless = %00000100 to %00000111 = 4 to 7
1090                                                                          ; Poor            = %00001000 to %00001111 = 8 to 15
1091                                                                          ; Average         = %00010000 to %00011111 = 16 to 31
1092                                                                          ; Above Average   = %00100000 to %11111111 = 32 to 255
1093                                                                          ;
1094                                                                          ; If the high byte in TALLY+1 is non-zero then we are
1095                                                                          ; Competent, Dangerous, Deadly or Elite, according to
1096                                                                          ; the high byte in TALLY+1:
1097                                                                          ;
1098                                                                          ; Competent       = 1           = 256 to 511 kills
1099                                                                          ; Dangerous       = 2 to 9      = 512 to 2559 kills
1100                                                                          ; Deadly          = 10 to 24    = 2560 to 6399 kills
1101                                                                          ; Elite           = 25 and up   = 6400 kills and up
1102                                                                          ;
1103                                                                          ; You can see the rating calculation in the STATUS
1104                                                                          ; subroutine
1105               
1106               SVC:
1107 0349                 bss 1                                               ; The save count
1108                                                                          ;
1109                                                                          ; When a new commander is created, the save count gets
1110                                                                          ; set to 128. This value gets halved each time the
1111                                                                          ; commander file is saved, but it is otherwise unused.
1112                                                                          ; It is presumably part of the security system for the
1113                                                                          ; competition, possibly another flag to catch out
1114                                                                          ; entries with manually altered commander files
1115               
1116 034A                 bss 2                                               ; The commander file checksum
1117                                                                          ;
1118                                                                          ; These two bytes are reserved for the commander file
1119                                                                          ; checksum, so when the current commander block is
1120                                                                          ; copied from here to the last saved commander block at
1121                                                                          ; NA%, CHK and CHK2 get overwritten
1122               
1123               NT.:                                                       ; This sets the variable NT% to the size of the current
1124                      equ SVC + 2 - TP
1125                                                                          ; commander data block, which starts at TP and ends at
1126                                                                          ; SVC+2 (inclusive)
1127               
1128               SX:
1129 034C                 bss NOST + 1                                        ; This is where we store the x_hi coordinates for all
1130                                                                          ; the stardust particles
1131               
1132               SXL:
1133 035F                 bss NOST + 1                                        ; This is where we store the x_lo coordinates for all
1134                                                                          ; the stardust particles
1135               
1136                      ; PRINT "T% workspace from  ", ~T%, " to ", ~P%
1137               
1138               * ******************************************************************************
1139               *
1140               * ELITE RECURSIVE TEXT TOKEN FILE
1141               *
1142               * Produces the binary file WORDS9.bin that gets loaded by elite-loader.asm.
1143               *
1144               * The recursive token table is loaded at &1100 and is moved down to &0400 as
1145               * part of elite-loader.asm, so it ends up at &0400 to &07FF.
1146               *
1147               * ******************************************************************************
1148               
1149                      aorg CODE_WORDS.
1150               
1151               * ******************************************************************************
1152               *
1153               * Name: CHAR
1154               * Type: Macro
1155               * Category: Text
1156               * Summary: Macro definition for characters in the recursive token table
1157               * Deep dive: Printing text tokens
1158               *
1159               * ------------------------------------------------------------------------------
1160               *
1161               * The following macro is used when building the recursive token table:
1162               *
1163               * CHAR 'x'            Insert ASCII character "x"
1164               *
1165               * To include an apostrophe, use a backtick character, as in CHAR '`'.
1166               *
1167               * See the deep dive on "Printing text tokens" for details on how characters are
1168               * stored in the recursive token table.
1169               *
1170               * ------------------------------------------------------------------------------
1171               *
1172               * Arguments:
1173               *
1174               * 'x'                 The character to insert into the table
1175               *
1176               * ******************************************************************************
1177               
1178                      ; MACRO CHAR x
1179               
1180                      ; IF x = '`'                    ;
1181                      ; EQUB 39 EOR RE                ;
1182                      ; ELSE                          ;
1183                      ; EQUB x EOR RE                 ;
1184                      ; ENDIF                         ;
1185               
1186                      ; ENDMACRO
1187               
1188               * ******************************************************************************
1189               *
1190               * Name: TWOK
1191               * Type: Macro
1192               * Category: Text
1193               * Summary: Macro definition for two-letter tokens in the token table
1194               * Deep dive: Printing text tokens
1195               *
1196               * ------------------------------------------------------------------------------
1197               *
1198               * The following macro is used when building the recursive token table:
1199               *
1200               * TWOK 'x', 'y'       Insert two-letter token "xy"
1201               *
1202               * See the deep dive on "Printing text tokens" for details on how two-letter
1203               * tokens are stored in the recursive token table.
1204               *
1205               * ------------------------------------------------------------------------------
1206               *
1207               * Arguments:
1208               *
1209               * 'x'                 The first letter of the two-letter token to insert into
1210               * the table
1211               *
1212               * 'y'                 The second letter of the two-letter token to insert into
1213               * the table
1214               *
1215               * ******************************************************************************
1216               
1217                      ; MACRO TWOK t, k
1218               
1219                      ; IF t = 'A' AND k = 'L' : EQUB 128 EOR RE : ENDIF ;
1220                      ; IF t = 'L' AND k = 'E' : EQUB 129 EOR RE : ENDIF ;
1221                      ; IF t = 'X' AND k = 'E' : EQUB 130 EOR RE : ENDIF ;
1222                      ; IF t = 'G' AND k = 'E' : EQUB 131 EOR RE : ENDIF ;
1223                      ; IF t = 'Z' AND k = 'A' : EQUB 132 EOR RE : ENDIF ;
1224                      ; IF t = 'C' AND k = 'E' : EQUB 133 EOR RE : ENDIF ;
1225                      ; IF t = 'B' AND k = 'I' : EQUB 134 EOR RE : ENDIF ;
1226                      ; IF t = 'S' AND k = 'O' : EQUB 135 EOR RE : ENDIF ;
1227                      ; IF t = 'U' AND k = 'S' : EQUB 136 EOR RE : ENDIF ;
1228                      ; IF t = 'E' AND k = 'S' : EQUB 137 EOR RE : ENDIF ;
1229                      ; IF t = 'A' AND k = 'R' : EQUB 138 EOR RE : ENDIF ;
1230                      ; IF t = 'M' AND k = 'A' : EQUB 139 EOR RE : ENDIF ;
1231                      ; IF t = 'I' AND k = 'N' : EQUB 140 EOR RE : ENDIF ;
1232                      ; IF t = 'D' AND k = 'I' : EQUB 141 EOR RE : ENDIF ;
1233                      ; IF t = 'R' AND k = 'E' : EQUB 142 EOR RE : ENDIF ;
1234                      ; IF t = 'A' AND k = '?' : EQUB 143 EOR RE : ENDIF ;
1235                      ; IF t = 'E' AND k = 'R' : EQUB 144 EOR RE : ENDIF ;
1236                      ; IF t = 'A' AND k = 'T' : EQUB 145 EOR RE : ENDIF ;
1237                      ; IF t = 'E' AND k = 'N' : EQUB 146 EOR RE : ENDIF ;
1238                      ; IF t = 'B' AND k = 'E' : EQUB 147 EOR RE : ENDIF ;
1239                      ; IF t = 'R' AND k = 'A' : EQUB 148 EOR RE : ENDIF ;
1240                      ; IF t = 'L' AND k = 'A' : EQUB 149 EOR RE : ENDIF ;
1241                      ; IF t = 'V' AND k = 'E' : EQUB 150 EOR RE : ENDIF ;
1242                      ; IF t = 'T' AND k = 'I' : EQUB 151 EOR RE : ENDIF ;
1243                      ; IF t = 'E' AND k = 'D' : EQUB 152 EOR RE : ENDIF ;
1244                      ; IF t = 'O' AND k = 'R' : EQUB 153 EOR RE : ENDIF ;
1245                      ; IF t = 'Q' AND k = 'U' : EQUB 154 EOR RE : ENDIF ;
1246                      ; IF t = 'A' AND k = 'N' : EQUB 155 EOR RE : ENDIF ;
1247                      ; IF t = 'T' AND k = 'E' : EQUB 156 EOR RE : ENDIF ;
1248                      ; IF t = 'I' AND k = 'S' : EQUB 157 EOR RE : ENDIF ;
1249                      ; IF t = 'R' AND k = 'I' : EQUB 158 EOR RE : ENDIF ;
1250                      ; IF t = 'O' AND k = 'N' : EQUB 159 EOR RE : ENDIF ;
1251               
1252                      ; ENDMACRO
1253               
1254               * ******************************************************************************
1255               *
1256               * Name: CONT
1257               * Type: Macro
1258               * Category: Text
1259               * Summary: Macro definition for control codes in the recursive token table
1260               * Deep dive: Printing text tokens
1261               *
1262               * ------------------------------------------------------------------------------
1263               *
1264               * The following macro is used when building the recursive token table:
1265               *
1266               * CONT n              Insert control code token {n}
1267               *
1268               * See the deep dive on "Printing text tokens" for details on how characters are
1269               * stored in the recursive token table.
1270               *
1271               * ------------------------------------------------------------------------------
1272               *
1273               * Arguments:
1274               *
1275               * n                   The control code to insert into the table
1276               *
1277               * ******************************************************************************
1278               
1279                      ; MACRO CONT n
1280               
1281                      ; EQUB n EOR RE                 ;
1282               
1283                      ; ENDMACRO
1284               
1285               * ******************************************************************************
1286               *
1287               * Name: RTOK
1288               * Type: Macro
1289               * Category: Text
1290               * Summary: Macro definition for recursive tokens in the recursive token table
1291               * Deep dive: Printing text tokens
1292               *
1293               * ------------------------------------------------------------------------------
1294               *
1295               * The following macro is used when building the recursive token table:
1296               *
1297               * RTOK n              Insert recursive token [n]
1298               *
1299               * * Tokens 0-95 get stored as n + 160
1300               *
1301               * * Tokens 128-145 get stored as n - 114
1302               *
1303               * * Tokens 96-127 get stored as n
1304               *
1305               * See the deep dive on "Printing text tokens" for details on how recursive
1306               * tokens are stored in the recursive token table.
1307               *
1308               * ------------------------------------------------------------------------------
1309               *
1310               * Arguments:
1311               *
1312               * n                   The number of the recursive token to insert into the
1313               * table, in the range 0 to 145
1314               *
1315               * ******************************************************************************
1316               
1317                      ; MACRO RTOK n
1318               
1319                      ; IF n >= 0 AND n <= 95         ;
1320                      ; t = n + 160                   ;
1321                      ; ELIF n >= 128                 ;
1322                      ; t = n - 114                   ;
1323                      ; ELSE                          ;
1324                      ; t = n                         ;
1325                      ; ENDIF                         ;
1326               
1327                      ; EQUB t EOR RE                 ;
1328               
1329                      ; ENDMACRO
1330               
1331               * ******************************************************************************
1332               *
1333               * Name: QQ18
1334               * Type: Variable
1335               * Category: Text
1336               * Summary: The recursive token table for tokens 0-148
1337               * Deep dive: Printing text tokens
1338               *
1339               * ******************************************************************************
1340               
1341               QQ18:
1342                      .rtok 111                                           ; Token 0:      "FUEL SCOOPS ON {beep}"
     **** ****     > RTOK
0008 0400 4C              byte 111 ^ RE
                   < elite.a99
1343                      .rtok 131                                           ;
     **** ****     > RTOK
0006 0401   32            byte (131 - 114) ^ RE
                   < elite.a99
1344                      .cont 7                                             ; Encoded as:   "[111][131]{7}"
     **** ****     > CONT
0001 0402 24              byte 7 ^ RE
                   < elite.a99
1345 0403   00            byte >00
1346               
1347                      .char ' '                                           ; Token 1:      " CHART"
     **** ****     > CHAR
0004 0404 03              byte ' ' ^ RE
                   < elite.a99
1348                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0405   60            byte 'C' ^ RE
                   < elite.a99
1349                      .char 'H'                                           ; Encoded as:   " CH<138>T"
     **** ****     > CHAR
0004 0406 6B              byte 'H' ^ RE
                   < elite.a99
1350 0407   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1351                      .char 'T'
     **** ****     > CHAR
0004 0408 77              byte 'T' ^ RE
                   < elite.a99
1352 0409   00            byte >00
1353               
1354                      .char 'G'                                           ; Token 2:      "GOVERNMENT"
     **** ****     > CHAR
0004 040A 64              byte 'G' ^ RE
                   < elite.a99
1355                      .char 'O'                                           ;
     **** ****     > CHAR
0004 040B   6C            byte 'O' ^ RE
                   < elite.a99
1356 040C B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' Encoded as:   "GO<150>RNM<146>T"
1357                      .char 'R'
     **** ****     > CHAR
0004 040D   71            byte 'R' ^ RE
                   < elite.a99
1358                      .char 'N'
     **** ****     > CHAR
0004 040E 6D              byte 'N' ^ RE
                   < elite.a99
1359                      .char 'M'
     **** ****     > CHAR
0004 040F   6E            byte 'M' ^ RE
                   < elite.a99
1360 0410 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
1361                      .char 'T'
     **** ****     > CHAR
0004 0411   77            byte 'T' ^ RE
                   < elite.a99
1362 0412 00              byte >00
1363               
1364                      .char 'D'                                           ; Token 3:      "DATA ON {selected system name}"
     **** ****     > CHAR
0004 0413   67            byte 'D' ^ RE
                   < elite.a99
1365 0414 B2              byte 145 ^ RE                                       ; TWOK 'A', 'T'
1366                      .char 'A'                                           ; Encoded as:   "D<145>A[131]{3}"
     **** ****     > CHAR
0004 0415   62            byte 'A' ^ RE
                   < elite.a99
1367                      .rtok 131
     **** ****     > RTOK
0006 0416 32              byte (131 - 114) ^ RE
                   < elite.a99
1368                      .cont 3
     **** ****     > CONT
0001 0417   20            byte 3 ^ RE
                   < elite.a99
1369 0418 00              byte >00
1370               
1371 0419   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 4:      "INVENTORY{crlf}
1372 041A B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' "
1373                      .char 'N'                                           ;
     **** ****     > CHAR
0004 041B   6D            byte 'N' ^ RE
                   < elite.a99
1374                      .char 'T'                                           ; Encoded as:   "<140><150>NT<153>Y{13}"
     **** ****     > CHAR
0004 041C 77              byte 'T' ^ RE
                   < elite.a99
1375 041D   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1376                      .char 'Y'
     **** ****     > CHAR
0004 041E 7A              byte 'Y' ^ RE
                   < elite.a99
1377                      .cont 13
     **** ****     > CONT
0001 041F   2E            byte 13 ^ RE
                   < elite.a99
1378 0420 00              byte >00
1379               
1380                      .char 'S'                                           ; Token 5:      "SYSTEM"
     **** ****     > CHAR
0004 0421   70            byte 'S' ^ RE
                   < elite.a99
1381                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 0422 7A              byte 'Y' ^ RE
                   < elite.a99
1382                      .char 'S'                                           ; Encoded as:   "SYS<156>M"
     **** ****     > CHAR
0004 0423   70            byte 'S' ^ RE
                   < elite.a99
1383 0424 BF              byte 156 ^ RE                                       ; TWOK 'T', 'E' null
1384                      .char 'M'
     **** ****     > CHAR
0004 0425   6E            byte 'M' ^ RE
                   < elite.a99
1385 0426 00              byte >00
1386               
1387                      .char 'P'                                           ; Token 6:      "PRICE"
     **** ****     > CHAR
0004 0427   73            byte 'P' ^ RE
                   < elite.a99
1388 0428 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I'
1389 0429   A6            byte 133 ^ RE                                       ; TWOK 'C', 'E' Encoded as:   "P<158><133>"
1390 042A 00              byte >00
1391               
1392                      .cont 2                                             ; Token 7:      "{current system name} MARKET PRICES"
     **** ****     > CONT
0001 042B   21            byte 2 ^ RE
                   < elite.a99
1393                      .char ' '                                           ;
     **** ****     > CHAR
0004 042C 03              byte ' ' ^ RE
                   < elite.a99
1394 042D   A8            byte 139 ^ RE                                       ; TWOK 'M', 'A' Encoded as:   "{2} <139>RKET [6]S"
1395                      .char 'R'
     **** ****     > CHAR
0004 042E 71              byte 'R' ^ RE
                   < elite.a99
1396                      .char 'K'
     **** ****     > CHAR
0004 042F   68            byte 'K' ^ RE
                   < elite.a99
1397                      .char 'E'
     **** ****     > CHAR
0004 0430 66              byte 'E' ^ RE
                   < elite.a99
1398                      .char 'T'
     **** ****     > CHAR
0004 0431   77            byte 'T' ^ RE
                   < elite.a99
1399                      .char ' '
     **** ****     > CHAR
0004 0432 03              byte ' ' ^ RE
                   < elite.a99
1400                      .rtok 6
     **** ****     > RTOK
0003 0433   85            byte (6 + 160) ^ RE
                   < elite.a99
1401                      .char 'S'
     **** ****     > CHAR
0004 0434 70              byte 'S' ^ RE
                   < elite.a99
1402 0435   00            byte >00
1403               
1404 0436 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 8:      "INDUSTRIAL"
1405                      .char 'D'                                           ;
     **** ****     > CHAR
0004 0437   67            byte 'D' ^ RE
                   < elite.a99
1406 0438 AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' Encoded as:   "<140>D<136>T<158><128>"
1407                      .char 'T'
     **** ****     > CHAR
0004 0439   77            byte 'T' ^ RE
                   < elite.a99
1408 043A BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' null
1409 043B   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1410 043C 00              byte >00
1411               
1412                      .char 'A'                                           ; Token 9:      "AGRICULTURAL"
     **** ****     > CHAR
0004 043D   62            byte 'A' ^ RE
                   < elite.a99
1413                      .char 'G'                                           ;
     **** ****     > CHAR
0004 043E 64              byte 'G' ^ RE
                   < elite.a99
1414 043F   BD            byte 158 ^ RE                                       ; TWOK 'R', 'I' Encoded as:   "AG<158>CULTU<148>L"
1415                      .char 'C'
     **** ****     > CHAR
0004 0440 60              byte 'C' ^ RE
                   < elite.a99
1416                      .char 'U'
     **** ****     > CHAR
0004 0441   76            byte 'U' ^ RE
                   < elite.a99
1417                      .char 'L'
     **** ****     > CHAR
0004 0442 6F              byte 'L' ^ RE
                   < elite.a99
1418                      .char 'T'
     **** ****     > CHAR
0004 0443   77            byte 'T' ^ RE
                   < elite.a99
1419                      .char 'U'
     **** ****     > CHAR
0004 0444 76              byte 'U' ^ RE
                   < elite.a99
1420 0445   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' null
1421                      .char 'L'
     **** ****     > CHAR
0004 0446 6F              byte 'L' ^ RE
                   < elite.a99
1422 0447   00            byte >00
1423               
1424 0448 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' Token 10:     "RICH "
1425                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0449   60            byte 'C' ^ RE
                   < elite.a99
1426                      .char 'H'                                           ; Encoded as:   "<158>CH "
     **** ****     > CHAR
0004 044A 6B              byte 'H' ^ RE
                   < elite.a99
1427                      .char ' '
     **** ****     > CHAR
0004 044B   03            byte ' ' ^ RE
                   < elite.a99
1428 044C 00              byte >00
1429               
1430                      .char 'A'                                           ; Token 11:     "AVERAGE "
     **** ****     > CHAR
0004 044D   62            byte 'A' ^ RE
                   < elite.a99
1431 044E B5              byte 150 ^ RE                                       ; TWOK 'V', 'E'
1432 044F   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Encoded as:   "A<150><148><131> "
1433 0450 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' null
1434                      .char ' '
     **** ****     > CHAR
0004 0451   03            byte ' ' ^ RE
                   < elite.a99
1435 0452 00              byte >00
1436               
1437                      .char 'P'                                           ; Token 12:     "POOR "
     **** ****     > CHAR
0004 0453   73            byte 'P' ^ RE
                   < elite.a99
1438                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0454 6C              byte 'O' ^ RE
                   < elite.a99
1439 0455   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' Encoded as:   "PO<153> "
1440                      .char ' '
     **** ****     > CHAR
0004 0456 03              byte ' ' ^ RE
                   < elite.a99
1441 0457   00            byte >00
1442               
1443 0458 A8              byte 139 ^ RE                                       ; TWOK 'M', 'A' Token 13:     "MAINLY "
1444 0459   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
1445                      .char 'L'                                           ; Encoded as:   "<139><140>LY "
     **** ****     > CHAR
0004 045A 6F              byte 'L' ^ RE
                   < elite.a99
1446                      .char 'Y'
     **** ****     > CHAR
0004 045B   7A            byte 'Y' ^ RE
                   < elite.a99
1447                      .char ' '
     **** ****     > CHAR
0004 045C 03              byte ' ' ^ RE
                   < elite.a99
1448 045D   00            byte >00
1449               
1450                      .char 'U'                                           ; Token 14:     "UNIT"
     **** ****     > CHAR
0004 045E 76              byte 'U' ^ RE
                   < elite.a99
1451                      .char 'N'                                           ;
     **** ****     > CHAR
0004 045F   6D            byte 'N' ^ RE
                   < elite.a99
1452                      .char 'I'                                           ; Encoded as:   "UNIT"
     **** ****     > CHAR
0004 0460 6A              byte 'I' ^ RE
                   < elite.a99
1453                      .char 'T'
     **** ****     > CHAR
0004 0461   77            byte 'T' ^ RE
                   < elite.a99
1454 0462 00              byte >00
1455               
1456                      .char 'V'                                           ; Token 15:     "VIEW "
     **** ****     > CHAR
0004 0463   75            byte 'V' ^ RE
                   < elite.a99
1457                      .char 'I'                                           ;
     **** ****     > CHAR
0004 0464 6A              byte 'I' ^ RE
                   < elite.a99
1458                      .char 'E'                                           ; Encoded as:   "VIEW "
     **** ****     > CHAR
0004 0465   66            byte 'E' ^ RE
                   < elite.a99
1459                      .char 'W'
     **** ****     > CHAR
0004 0466 74              byte 'W' ^ RE
                   < elite.a99
1460                      .char ' '
     **** ****     > CHAR
0004 0467   03            byte ' ' ^ RE
                   < elite.a99
1461 0468 00              byte >00
1462               
1463 0469   B9            byte 154 ^ RE                                       ; TWOK 'Q', 'U' Token 16:     "QUANTITY"
1464 046A B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
1465 046B   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' Encoded as:   "<154><155><151>TY"
1466                      .char 'T'
     **** ****     > CHAR
0004 046C 77              byte 'T' ^ RE
                   < elite.a99
1467                      .char 'Y'
     **** ****     > CHAR
0004 046D   7A            byte 'Y' ^ RE
                   < elite.a99
1468 046E 00              byte >00
1469               
1470 046F   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Token 17:     "ANARCHY"
1471 0470 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1472                      .char 'C'                                           ; Encoded as:   "<155><138>CHY"
     **** ****     > CHAR
0004 0471   60            byte 'C' ^ RE
                   < elite.a99
1473                      .char 'H'
     **** ****     > CHAR
0004 0472 6B              byte 'H' ^ RE
                   < elite.a99
1474                      .char 'Y'
     **** ****     > CHAR
0004 0473   7A            byte 'Y' ^ RE
                   < elite.a99
1475 0474 00              byte >00
1476               
1477                      .char 'F'                                           ; Token 18:     "FEUDAL"
     **** ****     > CHAR
0004 0475   65            byte 'F' ^ RE
                   < elite.a99
1478                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0476 66              byte 'E' ^ RE
                   < elite.a99
1479                      .char 'U'                                           ; Encoded as:   "FEUD<128>"
     **** ****     > CHAR
0004 0477   76            byte 'U' ^ RE
                   < elite.a99
1480                      .char 'D'
     **** ****     > CHAR
0004 0478 67              byte 'D' ^ RE
                   < elite.a99
1481 0479   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1482 047A 00              byte >00
1483               
1484                      .char 'M'                                           ; Token 19:     "MULTI-GOVERNMENT"
     **** ****     > CHAR
0004 047B   6E            byte 'M' ^ RE
                   < elite.a99
1485                      .char 'U'                                           ;
     **** ****     > CHAR
0004 047C 76              byte 'U' ^ RE
                   < elite.a99
1486                      .char 'L'                                           ; Encoded as:   "MUL<151>-[2]"
     **** ****     > CHAR
0004 047D   6F            byte 'L' ^ RE
                   < elite.a99
1487 047E B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1488                      .char '-'
     **** ****     > CHAR
0004 047F   0E            byte '-' ^ RE
                   < elite.a99
1489                      .rtok 2
     **** ****     > RTOK
0003 0480 81              byte (2 + 160) ^ RE
                   < elite.a99
1490 0481   00            byte >00
1491               
1492 0482 AE              byte 141 ^ RE                                       ; TWOK 'D', 'I' Token 20:     "DICTATORSHIP"
1493                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0483   60            byte 'C' ^ RE
                   < elite.a99
1494                      .char 'T'                                           ; Encoded as:   "<141>CT<145><153>[25]"
     **** ****     > CHAR
0004 0484 77              byte 'T' ^ RE
                   < elite.a99
1495 0485   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1496 0486 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1497                      .rtok 25
     **** ****     > RTOK
0003 0487   9A            byte (25 + 160) ^ RE
                   < elite.a99
1498 0488 00              byte >00
1499               
1500                      .rtok 91                                            ; Token 21:     "COMMUNIST"
     **** ****     > RTOK
0003 0489   D8            byte (91 + 160) ^ RE
                   < elite.a99
1501                      .char 'M'                                           ;
     **** ****     > CHAR
0004 048A 6E              byte 'M' ^ RE
                   < elite.a99
1502                      .char 'U'                                           ; Encoded as:   "[91]MUN<157>T"
     **** ****     > CHAR
0004 048B   76            byte 'U' ^ RE
                   < elite.a99
1503                      .char 'N'
     **** ****     > CHAR
0004 048C 6D              byte 'N' ^ RE
                   < elite.a99
1504 048D   BE            byte 157 ^ RE                                       ; TWOK 'I', 'S' null
1505                      .char 'T'
     **** ****     > CHAR
0004 048E 77              byte 'T' ^ RE
                   < elite.a99
1506 048F   00            byte >00
1507               
1508                      .char 'C'                                           ; Token 22:     "CONFEDERACY"
     **** ****     > CHAR
0004 0490 60              byte 'C' ^ RE
                   < elite.a99
1509 0491   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N'
1510                      .char 'F'                                           ; Encoded as:   "C<159>F<152><144>ACY"
     **** ****     > CHAR
0004 0492 65              byte 'F' ^ RE
                   < elite.a99
1511 0493   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1512 0494 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1513                      .char 'A'
     **** ****     > CHAR
0004 0495   62            byte 'A' ^ RE
                   < elite.a99
1514                      .char 'C'
     **** ****     > CHAR
0004 0496 60              byte 'C' ^ RE
                   < elite.a99
1515                      .char 'Y'
     **** ****     > CHAR
0004 0497   7A            byte 'Y' ^ RE
                   < elite.a99
1516 0498 00              byte >00
1517               
1518                      .char 'D'                                           ; Token 23:     "DEMOCRACY"
     **** ****     > CHAR
0004 0499   67            byte 'D' ^ RE
                   < elite.a99
1519                      .char 'E'                                           ;
     **** ****     > CHAR
0004 049A 66              byte 'E' ^ RE
                   < elite.a99
1520                      .char 'M'                                           ; Encoded as:   "DEMOC<148>CY"
     **** ****     > CHAR
0004 049B   6E            byte 'M' ^ RE
                   < elite.a99
1521                      .char 'O'
     **** ****     > CHAR
0004 049C 6C              byte 'O' ^ RE
                   < elite.a99
1522                      .char 'C'
     **** ****     > CHAR
0004 049D   60            byte 'C' ^ RE
                   < elite.a99
1523 049E B7              byte 148 ^ RE                                       ; TWOK 'R', 'A' null
1524                      .char 'C'
     **** ****     > CHAR
0004 049F   60            byte 'C' ^ RE
                   < elite.a99
1525                      .char 'Y'
     **** ****     > CHAR
0004 04A0 7A              byte 'Y' ^ RE
                   < elite.a99
1526 04A1   00            byte >00
1527               
1528                      .char 'C'                                           ; Token 24:     "CORPORATE STATE"
     **** ****     > CHAR
0004 04A2 60              byte 'C' ^ RE
                   < elite.a99
1529 04A3   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R'
1530                      .char 'P'                                           ; Encoded as:   "C<153>P<153><145>E [43]<145>E"
     **** ****     > CHAR
0004 04A4 73              byte 'P' ^ RE
                   < elite.a99
1531 04A5   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1532 04A6 B2              byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1533                      .char 'E'
     **** ****     > CHAR
0004 04A7   66            byte 'E' ^ RE
                   < elite.a99
1534                      .char ' '
     **** ****     > CHAR
0004 04A8 03              byte ' ' ^ RE
                   < elite.a99
1535                      .rtok 43
     **** ****     > RTOK
0003 04A9   E8            byte (43 + 160) ^ RE
                   < elite.a99
1536 04AA B2              byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1537                      .char 'E'
     **** ****     > CHAR
0004 04AB   66            byte 'E' ^ RE
                   < elite.a99
1538 04AC 00              byte >00
1539               
1540                      .char 'S'                                           ; Token 25:     "SHIP"
     **** ****     > CHAR
0004 04AD   70            byte 'S' ^ RE
                   < elite.a99
1541                      .char 'H'                                           ;
     **** ****     > CHAR
0004 04AE 6B              byte 'H' ^ RE
                   < elite.a99
1542                      .char 'I'                                           ; Encoded as:   "SHIP"
     **** ****     > CHAR
0004 04AF   6A            byte 'I' ^ RE
                   < elite.a99
1543                      .char 'P'
     **** ****     > CHAR
0004 04B0 73              byte 'P' ^ RE
                   < elite.a99
1544 04B1   00            byte >00
1545               
1546                      .char 'P'                                           ; Token 26:     "PRODUCT"
     **** ****     > CHAR
0004 04B2 73              byte 'P' ^ RE
                   < elite.a99
1547                      .char 'R'                                           ;
     **** ****     > CHAR
0004 04B3   71            byte 'R' ^ RE
                   < elite.a99
1548                      .char 'O'                                           ; Encoded as:   "PRODUCT"
     **** ****     > CHAR
0004 04B4 6C              byte 'O' ^ RE
                   < elite.a99
1549                      .char 'D'
     **** ****     > CHAR
0004 04B5   67            byte 'D' ^ RE
                   < elite.a99
1550                      .char 'U'
     **** ****     > CHAR
0004 04B6 76              byte 'U' ^ RE
                   < elite.a99
1551                      .char 'C'
     **** ****     > CHAR
0004 04B7   60            byte 'C' ^ RE
                   < elite.a99
1552                      .char 'T'
     **** ****     > CHAR
0004 04B8 77              byte 'T' ^ RE
                   < elite.a99
1553 04B9   00            byte >00
1554               
1555                      .char ' '                                           ; Token 27:     " LASER"
     **** ****     > CHAR
0004 04BA 03              byte ' ' ^ RE
                   < elite.a99
1556 04BB   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1557                      .char 'S'                                           ; Encoded as:   " <149>S<144>"
     **** ****     > CHAR
0004 04BC 70              byte 'S' ^ RE
                   < elite.a99
1558 04BD   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1559 04BE 00              byte >00
1560               
1561                      .char 'H'                                           ; Token 28:     "HUMAN COLONIAL"
     **** ****     > CHAR
0004 04BF   6B            byte 'H' ^ RE
                   < elite.a99
1562                      .char 'U'                                           ;
     **** ****     > CHAR
0004 04C0 76              byte 'U' ^ RE
                   < elite.a99
1563                      .char 'M'                                           ; Encoded as:   "HUM<155> COL<159>I<128>"
     **** ****     > CHAR
0004 04C1   6E            byte 'M' ^ RE
                   < elite.a99
1564 04C2 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N' null
1565                      .char ' '
     **** ****     > CHAR
0004 04C3   03            byte ' ' ^ RE
                   < elite.a99
1566                      .char 'C'
     **** ****     > CHAR
0004 04C4 60              byte 'C' ^ RE
                   < elite.a99
1567                      .char 'O'
     **** ****     > CHAR
0004 04C5   6C            byte 'O' ^ RE
                   < elite.a99
1568                      .char 'L'
     **** ****     > CHAR
0004 04C6 6F              byte 'L' ^ RE
                   < elite.a99
1569 04C7   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1570                      .char 'I'
     **** ****     > CHAR
0004 04C8 6A              byte 'I' ^ RE
                   < elite.a99
1571 04C9   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1572 04CA 00              byte >00
1573               
1574                      .char 'H'                                           ; Token 29:     "HYPERSPACE "
     **** ****     > CHAR
0004 04CB   6B            byte 'H' ^ RE
                   < elite.a99
1575                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 04CC 7A              byte 'Y' ^ RE
                   < elite.a99
1576                      .char 'P'                                           ; Encoded as:   "HYP<144>SPA<133> "
     **** ****     > CHAR
0004 04CD   73            byte 'P' ^ RE
                   < elite.a99
1577 04CE B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1578                      .char 'S'
     **** ****     > CHAR
0004 04CF   70            byte 'S' ^ RE
                   < elite.a99
1579                      .char 'P'
     **** ****     > CHAR
0004 04D0 73              byte 'P' ^ RE
                   < elite.a99
1580                      .char 'A'
     **** ****     > CHAR
0004 04D1   62            byte 'A' ^ RE
                   < elite.a99
1581 04D2 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1582                      .char ' '
     **** ****     > CHAR
0004 04D3   03            byte ' ' ^ RE
                   < elite.a99
1583 04D4 00              byte >00
1584               
1585                      .char 'S'                                           ; Token 30:     "SHORT RANGE CHART"
     **** ****     > CHAR
0004 04D5   70            byte 'S' ^ RE
                   < elite.a99
1586                      .char 'H'                                           ;
     **** ****     > CHAR
0004 04D6 6B              byte 'H' ^ RE
                   < elite.a99
1587 04D7   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' Encoded as:   "SH<153>T [42][1]"
1588                      .char 'T'
     **** ****     > CHAR
0004 04D8 77              byte 'T' ^ RE
                   < elite.a99
1589                      .char ' '
     **** ****     > CHAR
0004 04D9   03            byte ' ' ^ RE
                   < elite.a99
1590                      .rtok 42
     **** ****     > RTOK
0003 04DA E9              byte (42 + 160) ^ RE
                   < elite.a99
1591                      .rtok 1
     **** ****     > RTOK
0003 04DB   82            byte (1 + 160) ^ RE
                   < elite.a99
1592 04DC 00              byte >00
1593               
1594 04DD   AE            byte 141 ^ RE                                       ; TWOK 'D', 'I' Token 31:     "DISTANCE"
1595                      .rtok 43                                            ;
     **** ****     > RTOK
0003 04DE E8              byte (43 + 160) ^ RE
                   < elite.a99
1596 04DF   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "<141>[43]<155><133>"
1597 04E0 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1598 04E1   00            byte >00
1599               
1600                      .char 'P'                                           ; Token 32:     "POPULATION"
     **** ****     > CHAR
0004 04E2 73              byte 'P' ^ RE
                   < elite.a99
1601                      .char 'O'                                           ;
     **** ****     > CHAR
0004 04E3   6C            byte 'O' ^ RE
                   < elite.a99
1602                      .char 'P'                                           ; Encoded as:   "POPUL<145>I<159>"
     **** ****     > CHAR
0004 04E4 73              byte 'P' ^ RE
                   < elite.a99
1603                      .char 'U'
     **** ****     > CHAR
0004 04E5   76            byte 'U' ^ RE
                   < elite.a99
1604                      .char 'L'
     **** ****     > CHAR
0004 04E6 6F              byte 'L' ^ RE
                   < elite.a99
1605 04E7   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1606                      .char 'I'
     **** ****     > CHAR
0004 04E8 6A              byte 'I' ^ RE
                   < elite.a99
1607 04E9   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1608 04EA 00              byte >00
1609               
1610                      .char 'G'                                           ; Token 33:     "GROSS PRODUCTIVITY"
     **** ****     > CHAR
0004 04EB   64            byte 'G' ^ RE
                   < elite.a99
1611                      .char 'R'                                           ;
     **** ****     > CHAR
0004 04EC 71              byte 'R' ^ RE
                   < elite.a99
1612                      .char 'O'                                           ; Encoded as:   "GROSS [26]IVITY"
     **** ****     > CHAR
0004 04ED   6C            byte 'O' ^ RE
                   < elite.a99
1613                      .char 'S'
     **** ****     > CHAR
0004 04EE 70              byte 'S' ^ RE
                   < elite.a99
1614                      .char 'S'
     **** ****     > CHAR
0004 04EF   70            byte 'S' ^ RE
                   < elite.a99
1615                      .char ' '
     **** ****     > CHAR
0004 04F0 03              byte ' ' ^ RE
                   < elite.a99
1616                      .rtok 26
     **** ****     > RTOK
0003 04F1   99            byte (26 + 160) ^ RE
                   < elite.a99
1617                      .char 'I'
     **** ****     > CHAR
0004 04F2 6A              byte 'I' ^ RE
                   < elite.a99
1618                      .char 'V'
     **** ****     > CHAR
0004 04F3   75            byte 'V' ^ RE
                   < elite.a99
1619                      .char 'I'
     **** ****     > CHAR
0004 04F4 6A              byte 'I' ^ RE
                   < elite.a99
1620                      .char 'T'
     **** ****     > CHAR
0004 04F5   77            byte 'T' ^ RE
                   < elite.a99
1621                      .char 'Y'
     **** ****     > CHAR
0004 04F6 7A              byte 'Y' ^ RE
                   < elite.a99
1622 04F7   00            byte >00
1623               
1624                      .char 'E'                                           ; Token 34:     "ECONOMY"
     **** ****     > CHAR
0004 04F8 66              byte 'E' ^ RE
                   < elite.a99
1625                      .char 'C'                                           ;
     **** ****     > CHAR
0004 04F9   60            byte 'C' ^ RE
                   < elite.a99
1626 04FA BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' Encoded as:   "EC<159>OMY"
1627                      .char 'O'
     **** ****     > CHAR
0004 04FB   6C            byte 'O' ^ RE
                   < elite.a99
1628                      .char 'M'
     **** ****     > CHAR
0004 04FC 6E              byte 'M' ^ RE
                   < elite.a99
1629                      .char 'Y'
     **** ****     > CHAR
0004 04FD   7A            byte 'Y' ^ RE
                   < elite.a99
1630 04FE 00              byte >00
1631               
1632                      .char ' '                                           ; Token 35:     " LIGHT YEARS"
     **** ****     > CHAR
0004 04FF   03            byte ' ' ^ RE
                   < elite.a99
1633                      .char 'L'                                           ;
     **** ****     > CHAR
0004 0500 6F              byte 'L' ^ RE
                   < elite.a99
1634                      .char 'I'                                           ; Encoded as:   " LIGHT YE<138>S"
     **** ****     > CHAR
0004 0501   6A            byte 'I' ^ RE
                   < elite.a99
1635                      .char 'G'
     **** ****     > CHAR
0004 0502 64              byte 'G' ^ RE
                   < elite.a99
1636                      .char 'H'
     **** ****     > CHAR
0004 0503   6B            byte 'H' ^ RE
                   < elite.a99
1637                      .char 'T'
     **** ****     > CHAR
0004 0504 77              byte 'T' ^ RE
                   < elite.a99
1638                      .char ' '
     **** ****     > CHAR
0004 0505   03            byte ' ' ^ RE
                   < elite.a99
1639                      .char 'Y'
     **** ****     > CHAR
0004 0506 7A              byte 'Y' ^ RE
                   < elite.a99
1640                      .char 'E'
     **** ****     > CHAR
0004 0507   66            byte 'E' ^ RE
                   < elite.a99
1641 0508 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1642                      .char 'S'
     **** ****     > CHAR
0004 0509   70            byte 'S' ^ RE
                   < elite.a99
1643 050A 00              byte >00
1644               
1645 050B   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E' Token 36:     "TECH.LEVEL"
1646                      .char 'C'                                           ;
     **** ****     > CHAR
0004 050C 60              byte 'C' ^ RE
                   < elite.a99
1647                      .char 'H'                                           ; Encoded as:   "<156>CH.<129><150>L"
     **** ****     > CHAR
0004 050D   6B            byte 'H' ^ RE
                   < elite.a99
1648                      .char '.'
     **** ****     > CHAR
0004 050E 0D              byte '.' ^ RE
                   < elite.a99
1649 050F   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
1650 0510 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
1651                      .char 'L'
     **** ****     > CHAR
0004 0511   6F            byte 'L' ^ RE
                   < elite.a99
1652 0512 00              byte >00
1653               
1654                      .char 'C'                                           ; Token 37:     "CASH"
     **** ****     > CHAR
0004 0513   60            byte 'C' ^ RE
                   < elite.a99
1655                      .char 'A'                                           ;
     **** ****     > CHAR
0004 0514 62              byte 'A' ^ RE
                   < elite.a99
1656                      .char 'S'                                           ; Encoded as:   "CASH"
     **** ****     > CHAR
0004 0515   70            byte 'S' ^ RE
                   < elite.a99
1657                      .char 'H'
     **** ****     > CHAR
0004 0516 6B              byte 'H' ^ RE
                   < elite.a99
1658 0517   00            byte >00
1659               
1660                      .char ' '                                           ; Token 38:     " BILLION"
     **** ****     > CHAR
0004 0518 03              byte ' ' ^ RE
                   < elite.a99
1661 0519   A5            byte 134 ^ RE                                       ; TWOK 'B', 'I'
1662                      .rtok 118                                           ; Encoded as:   " <134>[118]I<159>"
     **** ****     > RTOK
0008 051A 55              byte 118 ^ RE
                   < elite.a99
1663                      .char 'I'
     **** ****     > CHAR
0004 051B   6A            byte 'I' ^ RE
                   < elite.a99
1664 051C BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1665 051D   00            byte >00
1666               
1667                      .rtok 122                                           ; Token 39:     "GALACTIC CHART{galaxy number}"
     **** ****     > RTOK
0008 051E 59              byte 122 ^ RE
                   < elite.a99
1668                      .rtok 1                                             ;
     **** ****     > RTOK
0003 051F   82            byte (1 + 160) ^ RE
                   < elite.a99
1669                      .cont 1                                             ; Encoded as:   "[122][1]{1}"
     **** ****     > CONT
0001 0520 22              byte 1 ^ RE
                   < elite.a99
1670 0521   00            byte >00
1671               
1672                      .char 'T'                                           ; Token 40:     "TARGET LOST"
     **** ****     > CHAR
0004 0522 77              byte 'T' ^ RE
                   < elite.a99
1673 0523   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R'
1674 0524 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "T<138><131>T LO[43]"
1675                      .char 'T'
     **** ****     > CHAR
0004 0525   77            byte 'T' ^ RE
                   < elite.a99
1676                      .char ' '
     **** ****     > CHAR
0004 0526 03              byte ' ' ^ RE
                   < elite.a99
1677                      .char 'L'
     **** ****     > CHAR
0004 0527   6F            byte 'L' ^ RE
                   < elite.a99
1678                      .char 'O'
     **** ****     > CHAR
0004 0528 6C              byte 'O' ^ RE
                   < elite.a99
1679                      .rtok 43
     **** ****     > RTOK
0003 0529   E8            byte (43 + 160) ^ RE
                   < elite.a99
1680 052A 00              byte >00
1681               
1682                      .rtok 106                                           ; Token 41:     "MISSILE JAMMED"
     **** ****     > RTOK
0008 052B   49            byte 106 ^ RE
                   < elite.a99
1683                      .char ' '                                           ;
     **** ****     > CHAR
0004 052C 03              byte ' ' ^ RE
                   < elite.a99
1684                      .char 'J'                                           ; Encoded as:   "[106] JAMM<152>"
     **** ****     > CHAR
0004 052D   69            byte 'J' ^ RE
                   < elite.a99
1685                      .char 'A'
     **** ****     > CHAR
0004 052E 62              byte 'A' ^ RE
                   < elite.a99
1686                      .char 'M'
     **** ****     > CHAR
0004 052F   6E            byte 'M' ^ RE
                   < elite.a99
1687                      .char 'M'
     **** ****     > CHAR
0004 0530 6E              byte 'M' ^ RE
                   < elite.a99
1688 0531   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1689 0532 00              byte >00
1690               
1691                      .char 'R'                                           ; Token 42:     "RANGE"
     **** ****     > CHAR
0004 0533   71            byte 'R' ^ RE
                   < elite.a99
1692 0534 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
1693 0535   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "R<155><131>"
1694 0536 00              byte >00
1695               
1696                      .char 'S'                                           ; Token 43:     "ST"
     **** ****     > CHAR
0004 0537   70            byte 'S' ^ RE
                   < elite.a99
1697                      .char 'T'                                           ;
     **** ****     > CHAR
0004 0538 77              byte 'T' ^ RE
                   < elite.a99
1698 0539   00            byte >00                                            ; Encoded as:   "ST"
1699               
1700                      .rtok 16                                            ; Token 44:     "QUANTITY OF "
     **** ****     > RTOK
0003 053A 93              byte (16 + 160) ^ RE
                   < elite.a99
1701                      .char ' '                                           ;
     **** ****     > CHAR
0004 053B   03            byte ' ' ^ RE
                   < elite.a99
1702                      .char 'O'                                           ; Encoded as:   "[16] OF "
     **** ****     > CHAR
0004 053C 6C              byte 'O' ^ RE
                   < elite.a99
1703                      .char 'F'
     **** ****     > CHAR
0004 053D   65            byte 'F' ^ RE
                   < elite.a99
1704                      .char ' '
     **** ****     > CHAR
0004 053E 03              byte ' ' ^ RE
                   < elite.a99
1705 053F   00            byte >00
1706               
1707                      .char 'S'                                           ; Token 45:     "SELL"
     **** ****     > CHAR
0004 0540 70              byte 'S' ^ RE
                   < elite.a99
1708                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0541   66            byte 'E' ^ RE
                   < elite.a99
1709                      .rtok 118                                           ; Encoded as:   "SE[118]"
     **** ****     > RTOK
0008 0542 55              byte 118 ^ RE
                   < elite.a99
1710 0543   00            byte >00
1711               
1712                      .char ' '                                           ; Token 46:     " CARGO{sentence case}"
     **** ****     > CHAR
0004 0544 03              byte ' ' ^ RE
                   < elite.a99
1713                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0545   60            byte 'C' ^ RE
                   < elite.a99
1714 0546 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R' Encoded as:   " C<138>GO{6}"
1715                      .char 'G'
     **** ****     > CHAR
0004 0547   64            byte 'G' ^ RE
                   < elite.a99
1716                      .char 'O'
     **** ****     > CHAR
0004 0548 6C              byte 'O' ^ RE
                   < elite.a99
1717                      .cont 6
     **** ****     > CONT
0001 0549   25            byte 6 ^ RE
                   < elite.a99
1718 054A 00              byte >00
1719               
1720                      .char 'E'                                           ; Token 47:     "EQUIP"
     **** ****     > CHAR
0004 054B   66            byte 'E' ^ RE
                   < elite.a99
1721 054C B9              byte 154 ^ RE                                       ; TWOK 'Q', 'U'
1722                      .char 'I'                                           ; Encoded as:   "E<154>IP"
     **** ****     > CHAR
0004 054D   6A            byte 'I' ^ RE
                   < elite.a99
1723                      .char 'P'
     **** ****     > CHAR
0004 054E 73              byte 'P' ^ RE
                   < elite.a99
1724 054F   00            byte >00
1725               
1726                      .char 'F'                                           ; Token 48:     "FOOD"
     **** ****     > CHAR
0004 0550 65              byte 'F' ^ RE
                   < elite.a99
1727                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0551   6C            byte 'O' ^ RE
                   < elite.a99
1728                      .char 'O'                                           ; Encoded as:   "FOOD"
     **** ****     > CHAR
0004 0552 6C              byte 'O' ^ RE
                   < elite.a99
1729                      .char 'D'
     **** ****     > CHAR
0004 0553   67            byte 'D' ^ RE
                   < elite.a99
1730 0554 00              byte >00
1731               
1732 0555   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E' Token 49:     "TEXTILES"
1733                      .char 'X'                                           ;
     **** ****     > CHAR
0004 0556 7B              byte 'X' ^ RE
                   < elite.a99
1734 0557   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' Encoded as:   "<156>X<151>L<137>"
1735                      .char 'L'
     **** ****     > CHAR
0004 0558 6F              byte 'L' ^ RE
                   < elite.a99
1736 0559   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1737 055A 00              byte >00
1738               
1739 055B   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Token 50:     "RADIOACTIVES"
1740 055C AE              byte 141 ^ RE                                       ; TWOK 'D', 'I'
1741                      .char 'O'                                           ; Encoded as:   "<148><141>OAC<151><150>S"
     **** ****     > CHAR
0004 055D   6C            byte 'O' ^ RE
                   < elite.a99
1742                      .char 'A'
     **** ****     > CHAR
0004 055E 62              byte 'A' ^ RE
                   < elite.a99
1743                      .char 'C'
     **** ****     > CHAR
0004 055F   60            byte 'C' ^ RE
                   < elite.a99
1744 0560 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1745 0561   B5            byte 150 ^ RE                                       ; TWOK 'V', 'E' null
1746                      .char 'S'
     **** ****     > CHAR
0004 0562 70              byte 'S' ^ RE
                   < elite.a99
1747 0563   00            byte >00
1748               
1749                      .char 'S'                                           ; Token 51:     "SLAVES"
     **** ****     > CHAR
0004 0564 70              byte 'S' ^ RE
                   < elite.a99
1750 0565   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1751 0566 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' Encoded as:   "S<149><150>S"
1752                      .char 'S'
     **** ****     > CHAR
0004 0567   70            byte 'S' ^ RE
                   < elite.a99
1753 0568 00              byte >00
1754               
1755                      .char 'L'                                           ; Token 52:     "LIQUOR/WINES"
     **** ****     > CHAR
0004 0569   6F            byte 'L' ^ RE
                   < elite.a99
1756                      .char 'I'                                           ;
     **** ****     > CHAR
0004 056A 6A              byte 'I' ^ RE
                   < elite.a99
1757 056B   B9            byte 154 ^ RE                                       ; TWOK 'Q', 'U' Encoded as:   "LI<154><153>/W<140><137>"
1758 056C BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1759                      .char '/'
     **** ****     > CHAR
0004 056D   0C            byte '/' ^ RE
                   < elite.a99
1760                      .char 'W'
     **** ****     > CHAR
0004 056E 74              byte 'W' ^ RE
                   < elite.a99
1761 056F   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1762 0570 AA              byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1763 0571   00            byte >00
1764               
1765                      .char 'L'                                           ; Token 53:     "LUXURIES"
     **** ****     > CHAR
0004 0572 6F              byte 'L' ^ RE
                   < elite.a99
1766                      .char 'U'                                           ;
     **** ****     > CHAR
0004 0573   76            byte 'U' ^ RE
                   < elite.a99
1767                      .char 'X'                                           ; Encoded as:   "LUXU<158><137>"
     **** ****     > CHAR
0004 0574 7B              byte 'X' ^ RE
                   < elite.a99
1768                      .char 'U'
     **** ****     > CHAR
0004 0575   76            byte 'U' ^ RE
                   < elite.a99
1769 0576 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' null
1770 0577   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1771 0578 00              byte >00
1772               
1773                      .char 'N'                                           ; Token 54:     "NARCOTICS"
     **** ****     > CHAR
0004 0579   6D            byte 'N' ^ RE
                   < elite.a99
1774 057A A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1775                      .char 'C'                                           ; Encoded as:   "N<138>CO<151>CS"
     **** ****     > CHAR
0004 057B   60            byte 'C' ^ RE
                   < elite.a99
1776                      .char 'O'
     **** ****     > CHAR
0004 057C 6C              byte 'O' ^ RE
                   < elite.a99
1777 057D   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1778                      .char 'C'
     **** ****     > CHAR
0004 057E 60              byte 'C' ^ RE
                   < elite.a99
1779                      .char 'S'
     **** ****     > CHAR
0004 057F   70            byte 'S' ^ RE
                   < elite.a99
1780 0580 00              byte >00
1781               
1782                      .rtok 91                                            ; Token 55:     "COMPUTERS"
     **** ****     > RTOK
0003 0581   D8            byte (91 + 160) ^ RE
                   < elite.a99
1783                      .char 'P'                                           ;
     **** ****     > CHAR
0004 0582 73              byte 'P' ^ RE
                   < elite.a99
1784                      .char 'U'                                           ; Encoded as:   "[91]PUT<144>S"
     **** ****     > CHAR
0004 0583   76            byte 'U' ^ RE
                   < elite.a99
1785                      .char 'T'
     **** ****     > CHAR
0004 0584 77              byte 'T' ^ RE
                   < elite.a99
1786 0585   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1787                      .char 'S'
     **** ****     > CHAR
0004 0586 70              byte 'S' ^ RE
                   < elite.a99
1788 0587   00            byte >00
1789               
1790 0588 A8              byte 139 ^ RE                                       ; TWOK 'M', 'A' Token 56:     "MACHINERY"
1791                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0589   60            byte 'C' ^ RE
                   < elite.a99
1792                      .char 'H'                                           ; Encoded as:   "<139>CH<140><144>Y"
     **** ****     > CHAR
0004 058A 6B              byte 'H' ^ RE
                   < elite.a99
1793 058B   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1794 058C B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1795                      .char 'Y'
     **** ****     > CHAR
0004 058D   7A            byte 'Y' ^ RE
                   < elite.a99
1796 058E 00              byte >00
1797               
1798                      .rtok 117                                           ; Token 57:     "ALLOYS"
     **** ****     > RTOK
0008 058F   56            byte 117 ^ RE
                   < elite.a99
1799                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0590 6C              byte 'O' ^ RE
                   < elite.a99
1800                      .char 'Y'                                           ; Encoded as:   "[117]OYS"
     **** ****     > CHAR
0004 0591   7A            byte 'Y' ^ RE
                   < elite.a99
1801                      .char 'S'
     **** ****     > CHAR
0004 0592 70              byte 'S' ^ RE
                   < elite.a99
1802 0593   00            byte >00
1803               
1804                      .char 'F'                                           ; Token 58:     "FIREARMS"
     **** ****     > CHAR
0004 0594 65              byte 'F' ^ RE
                   < elite.a99
1805                      .char 'I'                                           ;
     **** ****     > CHAR
0004 0595   6A            byte 'I' ^ RE
                   < elite.a99
1806 0596 AD              byte 142 ^ RE                                       ; TWOK 'R', 'E' Encoded as:   "FI<142><138>MS"
1807 0597   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1808                      .char 'M'
     **** ****     > CHAR
0004 0598 6E              byte 'M' ^ RE
                   < elite.a99
1809                      .char 'S'
     **** ****     > CHAR
0004 0599   70            byte 'S' ^ RE
                   < elite.a99
1810 059A 00              byte >00
1811               
1812                      .char 'F'                                           ; Token 59:     "FURS"
     **** ****     > CHAR
0004 059B   65            byte 'F' ^ RE
                   < elite.a99
1813                      .char 'U'                                           ;
     **** ****     > CHAR
0004 059C 76              byte 'U' ^ RE
                   < elite.a99
1814                      .char 'R'                                           ; Encoded as:   "FURS"
     **** ****     > CHAR
0004 059D   71            byte 'R' ^ RE
                   < elite.a99
1815                      .char 'S'
     **** ****     > CHAR
0004 059E 70              byte 'S' ^ RE
                   < elite.a99
1816 059F   00            byte >00
1817               
1818                      .char 'M'                                           ; Token 60:     "MINERALS"
     **** ****     > CHAR
0004 05A0 6E              byte 'M' ^ RE
                   < elite.a99
1819 05A1   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
1820 05A2 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' Encoded as:   "M<140><144><128>S"
1821 05A3   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1822                      .char 'S'
     **** ****     > CHAR
0004 05A4 70              byte 'S' ^ RE
                   < elite.a99
1823 05A5   00            byte >00
1824               
1825                      .char 'G'                                           ; Token 61:     "GOLD"
     **** ****     > CHAR
0004 05A6 64              byte 'G' ^ RE
                   < elite.a99
1826                      .char 'O'                                           ;
     **** ****     > CHAR
0004 05A7   6C            byte 'O' ^ RE
                   < elite.a99
1827                      .char 'L'                                           ; Encoded as:   "GOLD"
     **** ****     > CHAR
0004 05A8 6F              byte 'L' ^ RE
                   < elite.a99
1828                      .char 'D'
     **** ****     > CHAR
0004 05A9   67            byte 'D' ^ RE
                   < elite.a99
1829 05AA 00              byte >00
1830               
1831                      .char 'P'                                           ; Token 62:     "PLATINUM"
     **** ****     > CHAR
0004 05AB   73            byte 'P' ^ RE
                   < elite.a99
1832                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05AC 6F              byte 'L' ^ RE
                   < elite.a99
1833 05AD   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' Encoded as:   "PL<145><140>UM"
1834 05AE AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1835                      .char 'U'
     **** ****     > CHAR
0004 05AF   76            byte 'U' ^ RE
                   < elite.a99
1836                      .char 'M'
     **** ****     > CHAR
0004 05B0 6E              byte 'M' ^ RE
                   < elite.a99
1837 05B1   00            byte >00
1838               
1839 05B2 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' Token 63:     "GEM-STONES"
1840                      .char 'M'                                           ;
     **** ****     > CHAR
0004 05B3   6E            byte 'M' ^ RE
                   < elite.a99
1841                      .char '-'                                           ; Encoded as:   "<131>M-[43]<159><137>"
     **** ****     > CHAR
0004 05B4 0E              byte '-' ^ RE
                   < elite.a99
1842                      .rtok 43
     **** ****     > RTOK
0003 05B5   E8            byte (43 + 160) ^ RE
                   < elite.a99
1843 05B6 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1844 05B7   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1845 05B8 00              byte >00
1846               
1847 05B9   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' Token 64:     "ALIEN ITEMS"
1848                      .char 'I'                                           ;
     **** ****     > CHAR
0004 05BA 6A              byte 'I' ^ RE
                   < elite.a99
1849 05BB   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' Encoded as:   "<128>I<146> [127]S"
1850                      .char ' '
     **** ****     > CHAR
0004 05BC 03              byte ' ' ^ RE
                   < elite.a99
1851                      .rtok 127
     **** ****     > RTOK
0008 05BD   5C            byte 127 ^ RE
                   < elite.a99
1852                      .char 'S'
     **** ****     > CHAR
0004 05BE 70              byte 'S' ^ RE
                   < elite.a99
1853 05BF   00            byte >00
1854               
1855                      .char '('                                           ; Token 65:     "(Y/N)?"
     **** ****     > CHAR
0004 05C0 0B              byte '(' ^ RE
                   < elite.a99
1856                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 05C1   7A            byte 'Y' ^ RE
                   < elite.a99
1857                      .char '/'                                           ; Encoded as:   "(Y/N)?"
     **** ****     > CHAR
0004 05C2 0C              byte '/' ^ RE
                   < elite.a99
1858                      .char 'N'
     **** ****     > CHAR
0004 05C3   6D            byte 'N' ^ RE
                   < elite.a99
1859                      .char ')'
     **** ****     > CHAR
0004 05C4 0A              byte ')' ^ RE
                   < elite.a99
1860                      .char '?'
     **** ****     > CHAR
0004 05C5   1C            byte '?' ^ RE
                   < elite.a99
1861 05C6 00              byte >00
1862               
1863                      .char ' '                                           ; Token 66:     " CR"
     **** ****     > CHAR
0004 05C7   03            byte ' ' ^ RE
                   < elite.a99
1864                      .char 'C'                                           ;
     **** ****     > CHAR
0004 05C8 60              byte 'C' ^ RE
                   < elite.a99
1865                      .char 'R'                                           ; Encoded as:   " CR"
     **** ****     > CHAR
0004 05C9   71            byte 'R' ^ RE
                   < elite.a99
1866 05CA 00              byte >00
1867               
1868                      .char 'L'                                           ; Token 67:     "LARGE"
     **** ****     > CHAR
0004 05CB   6F            byte 'L' ^ RE
                   < elite.a99
1869 05CC A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1870 05CD   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "L<138><131>"
1871 05CE 00              byte >00
1872               
1873                      .char 'F'                                           ; Token 68:     "FIERCE"
     **** ****     > CHAR
0004 05CF   65            byte 'F' ^ RE
                   < elite.a99
1874                      .char 'I'                                           ;
     **** ****     > CHAR
0004 05D0 6A              byte 'I' ^ RE
                   < elite.a99
1875 05D1   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' Encoded as:   "FI<144><133>"
1876 05D2 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1877 05D3   00            byte >00
1878               
1879                      .char 'S'                                           ; Token 69:     "SMALL"
     **** ****     > CHAR
0004 05D4 70              byte 'S' ^ RE
                   < elite.a99
1880 05D5   A8            byte 139 ^ RE                                       ; TWOK 'M', 'A'
1881                      .rtok 118                                           ; Encoded as:   "S<139>[118]"
     **** ****     > RTOK
0008 05D6 55              byte 118 ^ RE
                   < elite.a99
1882 05D7   00            byte >00
1883               
1884                      .char 'G'                                           ; Token 70:     "GREEN"
     **** ****     > CHAR
0004 05D8 64              byte 'G' ^ RE
                   < elite.a99
1885 05D9   AD            byte 142 ^ RE                                       ; TWOK 'R', 'E'
1886 05DA B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' Encoded as:   "G<142><146>"
1887 05DB   00            byte >00
1888               
1889                      .char 'R'                                           ; Token 71:     "RED"
     **** ****     > CHAR
0004 05DC 71              byte 'R' ^ RE
                   < elite.a99
1890 05DD   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D'
1891 05DE 00              byte >00                                            ; Encoded as:   "R<152>"
1892               
1893                      .char 'Y'                                           ; Token 72:     "YELLOW"
     **** ****     > CHAR
0004 05DF   7A            byte 'Y' ^ RE
                   < elite.a99
1894                      .char 'E'                                           ;
     **** ****     > CHAR
0004 05E0 66              byte 'E' ^ RE
                   < elite.a99
1895                      .rtok 118                                           ; Encoded as:   "YE[118]OW"
     **** ****     > RTOK
0008 05E1   55            byte 118 ^ RE
                   < elite.a99
1896                      .char 'O'
     **** ****     > CHAR
0004 05E2 6C              byte 'O' ^ RE
                   < elite.a99
1897                      .char 'W'
     **** ****     > CHAR
0004 05E3   74            byte 'W' ^ RE
                   < elite.a99
1898 05E4 00              byte >00
1899               
1900                      .char 'B'                                           ; Token 73:     "BLUE"
     **** ****     > CHAR
0004 05E5   61            byte 'B' ^ RE
                   < elite.a99
1901                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05E6 6F              byte 'L' ^ RE
                   < elite.a99
1902                      .char 'U'                                           ; Encoded as:   "BLUE"
     **** ****     > CHAR
0004 05E7   76            byte 'U' ^ RE
                   < elite.a99
1903                      .char 'E'
     **** ****     > CHAR
0004 05E8 66              byte 'E' ^ RE
                   < elite.a99
1904 05E9   00            byte >00
1905               
1906                      .char 'B'                                           ; Token 74:     "BLACK"
     **** ****     > CHAR
0004 05EA 61              byte 'B' ^ RE
                   < elite.a99
1907 05EB   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1908                      .char 'C'                                           ; Encoded as:   "B<149>CK"
     **** ****     > CHAR
0004 05EC 60              byte 'C' ^ RE
                   < elite.a99
1909                      .char 'K'
     **** ****     > CHAR
0004 05ED   68            byte 'K' ^ RE
                   < elite.a99
1910 05EE 00              byte >00
1911               
1912                      .rtok 136                                           ; Token 75:     "HARMLESS"
     **** ****     > RTOK
0006 05EF   35            byte (136 - 114) ^ RE
                   < elite.a99
1913 05F0 00              byte >00                                            ;
1914                                                                          ; Encoded as:   "[136]"
1915               
1916                      .char 'S'                                           ; Token 76:     "SLIMY"
     **** ****     > CHAR
0004 05F1   70            byte 'S' ^ RE
                   < elite.a99
1917                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05F2 6F              byte 'L' ^ RE
                   < elite.a99
1918                      .char 'I'                                           ; Encoded as:   "SLIMY"
     **** ****     > CHAR
0004 05F3   6A            byte 'I' ^ RE
                   < elite.a99
1919                      .char 'M'
     **** ****     > CHAR
0004 05F4 6E              byte 'M' ^ RE
                   < elite.a99
1920                      .char 'Y'
     **** ****     > CHAR
0004 05F5   7A            byte 'Y' ^ RE
                   < elite.a99
1921 05F6 00              byte >00
1922               
1923                      .char 'B'                                           ; Token 77:     "BUG-EYED"
     **** ****     > CHAR
0004 05F7   61            byte 'B' ^ RE
                   < elite.a99
1924                      .char 'U'                                           ;
     **** ****     > CHAR
0004 05F8 76              byte 'U' ^ RE
                   < elite.a99
1925                      .char 'G'                                           ; Encoded as:   "BUG-EY<152>"
     **** ****     > CHAR
0004 05F9   64            byte 'G' ^ RE
                   < elite.a99
1926                      .char '-'
     **** ****     > CHAR
0004 05FA 0E              byte '-' ^ RE
                   < elite.a99
1927                      .char 'E'
     **** ****     > CHAR
0004 05FB   66            byte 'E' ^ RE
                   < elite.a99
1928                      .char 'Y'
     **** ****     > CHAR
0004 05FC 7A              byte 'Y' ^ RE
                   < elite.a99
1929 05FD   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1930 05FE 00              byte >00
1931               
1932                      .char 'H'                                           ; Token 78:     "HORNED"
     **** ****     > CHAR
0004 05FF   6B            byte 'H' ^ RE
                   < elite.a99
1933 0600 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R'
1934                      .char 'N'                                           ; Encoded as:   "H<153>N<152>"
     **** ****     > CHAR
0004 0601   6D            byte 'N' ^ RE
                   < elite.a99
1935 0602 BB              byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1936 0603   00            byte >00
1937               
1938                      .char 'B'                                           ; Token 79:     "BONY"
     **** ****     > CHAR
0004 0604 61              byte 'B' ^ RE
                   < elite.a99
1939 0605   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N'
1940                      .char 'Y'                                           ; Encoded as:   "B<159>Y"
     **** ****     > CHAR
0004 0606 7A              byte 'Y' ^ RE
                   < elite.a99
1941 0607   00            byte >00
1942               
1943                      .char 'F'                                           ; Token 80:     "FAT"
     **** ****     > CHAR
0004 0608 65              byte 'F' ^ RE
                   < elite.a99
1944 0609   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T'
1945 060A 00              byte >00                                            ; Encoded as:   "F<145>"
1946               
1947                      .char 'F'                                           ; Token 81:     "FURRY"
     **** ****     > CHAR
0004 060B   65            byte 'F' ^ RE
                   < elite.a99
1948                      .char 'U'                                           ;
     **** ****     > CHAR
0004 060C 76              byte 'U' ^ RE
                   < elite.a99
1949                      .char 'R'                                           ; Encoded as:   "FURRY"
     **** ****     > CHAR
0004 060D   71            byte 'R' ^ RE
                   < elite.a99
1950                      .char 'R'
     **** ****     > CHAR
0004 060E 71              byte 'R' ^ RE
                   < elite.a99
1951                      .char 'Y'
     **** ****     > CHAR
0004 060F   7A            byte 'Y' ^ RE
                   < elite.a99
1952 0610 00              byte >00
1953               
1954                      .char 'R'                                           ; Token 82:     "RODENT"
     **** ****     > CHAR
0004 0611   71            byte 'R' ^ RE
                   < elite.a99
1955                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0612 6C              byte 'O' ^ RE
                   < elite.a99
1956                      .char 'D'                                           ; Encoded as:   "ROD<146>T"
     **** ****     > CHAR
0004 0613   67            byte 'D' ^ RE
                   < elite.a99
1957 0614 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
1958                      .char 'T'
     **** ****     > CHAR
0004 0615   77            byte 'T' ^ RE
                   < elite.a99
1959 0616 00              byte >00
1960               
1961                      .char 'F'                                           ; Token 83:     "FROG"
     **** ****     > CHAR
0004 0617   65            byte 'F' ^ RE
                   < elite.a99
1962                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0618 71              byte 'R' ^ RE
                   < elite.a99
1963                      .char 'O'                                           ; Encoded as:   "FROG"
     **** ****     > CHAR
0004 0619   6C            byte 'O' ^ RE
                   < elite.a99
1964                      .char 'G'
     **** ****     > CHAR
0004 061A 64              byte 'G' ^ RE
                   < elite.a99
1965 061B   00            byte >00
1966               
1967                      .char 'L'                                           ; Token 84:     "LIZARD"
     **** ****     > CHAR
0004 061C 6F              byte 'L' ^ RE
                   < elite.a99
1968                      .char 'I'                                           ;
     **** ****     > CHAR
0004 061D   6A            byte 'I' ^ RE
                   < elite.a99
1969 061E A7              byte 132 ^ RE                                       ; TWOK 'Z', 'A' Encoded as:   "LI<132>RD"
1970                      .char 'R'
     **** ****     > CHAR
0004 061F   71            byte 'R' ^ RE
                   < elite.a99
1971                      .char 'D'
     **** ****     > CHAR
0004 0620 67              byte 'D' ^ RE
                   < elite.a99
1972 0621   00            byte >00
1973               
1974                      .char 'L'                                           ; Token 85:     "LOBSTER"
     **** ****     > CHAR
0004 0622 6F              byte 'L' ^ RE
                   < elite.a99
1975                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0623   6C            byte 'O' ^ RE
                   < elite.a99
1976                      .char 'B'                                           ; Encoded as:   "LOB[43]<144>"
     **** ****     > CHAR
0004 0624 61              byte 'B' ^ RE
                   < elite.a99
1977                      .rtok 43
     **** ****     > RTOK
0003 0625   E8            byte (43 + 160) ^ RE
                   < elite.a99
1978 0626 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1979 0627   00            byte >00
1980               
1981 0628 A5              byte 134 ^ RE                                       ; TWOK 'B', 'I' Token 86:     "BIRD"
1982                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0629   71            byte 'R' ^ RE
                   < elite.a99
1983                      .char 'D'                                           ; Encoded as:   "<134>RD"
     **** ****     > CHAR
0004 062A 67              byte 'D' ^ RE
                   < elite.a99
1984 062B   00            byte >00
1985               
1986                      .char 'H'                                           ; Token 87:     "HUMANOID"
     **** ****     > CHAR
0004 062C 6B              byte 'H' ^ RE
                   < elite.a99
1987                      .char 'U'                                           ;
     **** ****     > CHAR
0004 062D   76            byte 'U' ^ RE
                   < elite.a99
1988                      .char 'M'                                           ; Encoded as:   "HUM<155>OID"
     **** ****     > CHAR
0004 062E 6E              byte 'M' ^ RE
                   < elite.a99
1989 062F   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' null
1990                      .char 'O'
     **** ****     > CHAR
0004 0630 6C              byte 'O' ^ RE
                   < elite.a99
1991                      .char 'I'
     **** ****     > CHAR
0004 0631   6A            byte 'I' ^ RE
                   < elite.a99
1992                      .char 'D'
     **** ****     > CHAR
0004 0632 67              byte 'D' ^ RE
                   < elite.a99
1993 0633   00            byte >00
1994               
1995                      .char 'F'                                           ; Token 88:     "FELINE"
     **** ****     > CHAR
0004 0634 65              byte 'F' ^ RE
                   < elite.a99
1996                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0635   66            byte 'E' ^ RE
                   < elite.a99
1997                      .char 'L'                                           ; Encoded as:   "FEL<140>E"
     **** ****     > CHAR
0004 0636 6F              byte 'L' ^ RE
                   < elite.a99
1998 0637   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1999                      .char 'E'
     **** ****     > CHAR
0004 0638 66              byte 'E' ^ RE
                   < elite.a99
2000 0639   00            byte >00
2001               
2002 063A AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 89:     "INSECT"
2003                      .char 'S'                                           ;
     **** ****     > CHAR
0004 063B   70            byte 'S' ^ RE
                   < elite.a99
2004                      .char 'E'                                           ; Encoded as:   "<140>SECT"
     **** ****     > CHAR
0004 063C 66              byte 'E' ^ RE
                   < elite.a99
2005                      .char 'C'
     **** ****     > CHAR
0004 063D   60            byte 'C' ^ RE
                   < elite.a99
2006                      .char 'T'
     **** ****     > CHAR
0004 063E 77              byte 'T' ^ RE
                   < elite.a99
2007 063F   00            byte >00
2008               
2009                      .rtok 11                                            ; Token 90:     "AVERAGE RADIUS"
     **** ****     > RTOK
0003 0640 88              byte (11 + 160) ^ RE
                   < elite.a99
2010 0641   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A'
2011 0642 AE              byte 141 ^ RE                                       ; TWOK 'D', 'I' Encoded as:   "[11]<148><141><136>"
2012 0643   AB            byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2013 0644 00              byte >00
2014               
2015                      .char 'C'                                           ; Token 91:     "COM"
     **** ****     > CHAR
0004 0645   60            byte 'C' ^ RE
                   < elite.a99
2016                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0646 6C              byte 'O' ^ RE
                   < elite.a99
2017                      .char 'M'                                           ; Encoded as:   "COM"
     **** ****     > CHAR
0004 0647   6E            byte 'M' ^ RE
                   < elite.a99
2018 0648 00              byte >00
2019               
2020                      .rtok 91                                            ; Token 92:     "COMMANDER"
     **** ****     > RTOK
0003 0649   D8            byte (91 + 160) ^ RE
                   < elite.a99
2021                      .char 'M'                                           ;
     **** ****     > CHAR
0004 064A 6E              byte 'M' ^ RE
                   < elite.a99
2022 064B   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "[91]M<155>D<144>"
2023                      .char 'D'
     **** ****     > CHAR
0004 064C 67              byte 'D' ^ RE
                   < elite.a99
2024 064D   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
2025 064E 00              byte >00
2026               
2027                      .char ' '                                           ; Token 93:     " DESTROYED"
     **** ****     > CHAR
0004 064F   03            byte ' ' ^ RE
                   < elite.a99
2028                      .char 'D'                                           ;
     **** ****     > CHAR
0004 0650 67              byte 'D' ^ RE
                   < elite.a99
2029 0651   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' Encoded as:   " D<137>TROY<152>"
2030                      .char 'T'
     **** ****     > CHAR
0004 0652 77              byte 'T' ^ RE
                   < elite.a99
2031                      .char 'R'
     **** ****     > CHAR
0004 0653   71            byte 'R' ^ RE
                   < elite.a99
2032                      .char 'O'
     **** ****     > CHAR
0004 0654 6C              byte 'O' ^ RE
                   < elite.a99
2033                      .char 'Y'
     **** ****     > CHAR
0004 0655   7A            byte 'Y' ^ RE
                   < elite.a99
2034 0656 BB              byte 152 ^ RE                                       ; TWOK 'E', 'D' null
2035 0657   00            byte >00
2036               
2037                      .char 'B'                                           ; Token 94:     "BY D.BRABEN & I.BELL"
     **** ****     > CHAR
0004 0658 61              byte 'B' ^ RE
                   < elite.a99
2038                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 0659   7A            byte 'Y' ^ RE
                   < elite.a99
2039                      .char ' '                                           ; Encoded as:   "BY D.B<148><147>N & I.<147>[118]"
     **** ****     > CHAR
0004 065A 03              byte ' ' ^ RE
                   < elite.a99
2040                      .char 'D'
     **** ****     > CHAR
0004 065B   67            byte 'D' ^ RE
                   < elite.a99
2041                      .char '.'
     **** ****     > CHAR
0004 065C 0D              byte '.' ^ RE
                   < elite.a99
2042                      .char 'B'
     **** ****     > CHAR
0004 065D   61            byte 'B' ^ RE
                   < elite.a99
2043 065E B7              byte 148 ^ RE                                       ; TWOK 'R', 'A' null
2044 065F   B0            byte 147 ^ RE                                       ; TWOK 'B', 'E' null
2045                      .char 'N'
     **** ****     > CHAR
0004 0660 6D              byte 'N' ^ RE
                   < elite.a99
2046                      .char ' '
     **** ****     > CHAR
0004 0661   03            byte ' ' ^ RE
                   < elite.a99
2047                      .char '&'
     **** ****     > CHAR
0004 0662 05              byte '&' ^ RE
                   < elite.a99
2048                      .char ' '
     **** ****     > CHAR
0004 0663   03            byte ' ' ^ RE
                   < elite.a99
2049                      .char 'I'
     **** ****     > CHAR
0004 0664 6A              byte 'I' ^ RE
                   < elite.a99
2050                      .char '.'
     **** ****     > CHAR
0004 0665   0D            byte '.' ^ RE
                   < elite.a99
2051 0666 B0              byte 147 ^ RE                                       ; TWOK 'B', 'E' null
2052                      .rtok 118
     **** ****     > RTOK
0008 0667   55            byte 118 ^ RE
                   < elite.a99
2053 0668 00              byte >00
2054               
2055                      .rtok 14                                            ; Token 95:     "UNIT  QUANTITY{crlf}
     **** ****     > RTOK
0003 0669   8D            byte (14 + 160) ^ RE
                   < elite.a99
2056                      .char ' '                                           ; PRODUCT   UNIT PRICE FOR SALE{crlf}
     **** ****     > CHAR
0004 066A 03              byte ' ' ^ RE
                   < elite.a99
2057                      .char ' '                                           ; {lf}"
     **** ****     > CHAR
0004 066B   03            byte ' ' ^ RE
                   < elite.a99
2058                      .rtok 16                                            ;
     **** ****     > RTOK
0003 066C 93              byte (16 + 160) ^ RE
                   < elite.a99
2059                      .cont 13                                            ; Encoded as:   "[14]  [16]{13} [26]   [14] [6] F<153>
     **** ****     > CONT
0001 066D   2E            byte 13 ^ RE
                   < elite.a99
2060                      .char ' '                                           ; SA<129>{13}{10}"
     **** ****     > CHAR
0004 066E 03              byte ' ' ^ RE
                   < elite.a99
2061                      .rtok 26
     **** ****     > RTOK
0003 066F   99            byte (26 + 160) ^ RE
                   < elite.a99
2062                      .char ' '
     **** ****     > CHAR
0004 0670 03              byte ' ' ^ RE
                   < elite.a99
2063                      .char ' '
     **** ****     > CHAR
0004 0671   03            byte ' ' ^ RE
                   < elite.a99
2064                      .char ' '
     **** ****     > CHAR
0004 0672 03              byte ' ' ^ RE
                   < elite.a99
2065                      .rtok 14
     **** ****     > RTOK
0003 0673   8D            byte (14 + 160) ^ RE
                   < elite.a99
2066                      .char ' '
     **** ****     > CHAR
0004 0674 03              byte ' ' ^ RE
                   < elite.a99
2067                      .rtok 6
     **** ****     > RTOK
0003 0675   85            byte (6 + 160) ^ RE
                   < elite.a99
2068                      .char ' '
     **** ****     > CHAR
0004 0676 03              byte ' ' ^ RE
                   < elite.a99
2069                      .char 'F'
     **** ****     > CHAR
0004 0677   65            byte 'F' ^ RE
                   < elite.a99
2070 0678 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2071                      .char ' '
     **** ****     > CHAR
0004 0679   03            byte ' ' ^ RE
                   < elite.a99
2072                      .char 'S'
     **** ****     > CHAR
0004 067A 70              byte 'S' ^ RE
                   < elite.a99
2073                      .char 'A'
     **** ****     > CHAR
0004 067B   62            byte 'A' ^ RE
                   < elite.a99
2074 067C A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2075                      .cont 13
     **** ****     > CONT
0001 067D   2E            byte 13 ^ RE
                   < elite.a99
2076                      .cont 10
     **** ****     > CONT
0001 067E 29              byte 10 ^ RE
                   < elite.a99
2077 067F   00            byte >00
2078               
2079                      .char 'F'                                           ; Token 96:     "FRONT"
     **** ****     > CHAR
0004 0680 65              byte 'F' ^ RE
                   < elite.a99
2080                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0681   71            byte 'R' ^ RE
                   < elite.a99
2081 0682 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' Encoded as:   "FR<159>T"
2082                      .char 'T'
     **** ****     > CHAR
0004 0683   77            byte 'T' ^ RE
                   < elite.a99
2083 0684 00              byte >00
2084               
2085 0685   AD            byte 142 ^ RE                                       ; TWOK 'R', 'E' Token 97:     "REAR"
2086 0686 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
2087 0687   00            byte >00                                            ; Encoded as:   "<142><138>"
2088               
2089 0688 A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' Token 98:     "LEFT"
2090                      .char 'F'                                           ;
     **** ****     > CHAR
0004 0689   65            byte 'F' ^ RE
                   < elite.a99
2091                      .char 'T'                                           ; Encoded as:   "<129>FT"
     **** ****     > CHAR
0004 068A 77              byte 'T' ^ RE
                   < elite.a99
2092 068B   00            byte >00
2093               
2094 068C BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' Token 99:     "RIGHT"
2095                      .char 'G'                                           ;
     **** ****     > CHAR
0004 068D   64            byte 'G' ^ RE
                   < elite.a99
2096                      .char 'H'                                           ; Encoded as:   "<158>GHT"
     **** ****     > CHAR
0004 068E 6B              byte 'H' ^ RE
                   < elite.a99
2097                      .char 'T'
     **** ****     > CHAR
0004 068F   77            byte 'T' ^ RE
                   < elite.a99
2098 0690 00              byte >00
2099               
2100                      .rtok 121                                           ; Token 100:    "ENERGY LOW{beep}"
     **** ****     > RTOK
0008 0691   5A            byte 121 ^ RE
                   < elite.a99
2101                      .char 'L'                                           ;
     **** ****     > CHAR
0004 0692 6F              byte 'L' ^ RE
                   < elite.a99
2102                      .char 'O'                                           ; Encoded as:   "[121]LOW{7}"
     **** ****     > CHAR
0004 0693   6C            byte 'O' ^ RE
                   < elite.a99
2103                      .char 'W'
     **** ****     > CHAR
0004 0694 74              byte 'W' ^ RE
                   < elite.a99
2104                      .cont 7
     **** ****     > CONT
0001 0695   24            byte 7 ^ RE
                   < elite.a99
2105 0696 00              byte >00
2106               
2107                      .rtok 99                                            ; Token 101:    "RIGHT ON COMMANDER!"
     **** ****     > RTOK
0008 0697   40            byte 99 ^ RE
                   < elite.a99
2108                      .rtok 131                                           ;
     **** ****     > RTOK
0006 0698 32              byte (131 - 114) ^ RE
                   < elite.a99
2109                      .rtok 92                                            ; Encoded as:   "[99][131][92]!"
     **** ****     > RTOK
0003 0699   DF            byte (92 + 160) ^ RE
                   < elite.a99
2110                      .char '!'
     **** ****     > CHAR
0004 069A 02              byte '!' ^ RE
                   < elite.a99
2111 069B   00            byte >00
2112               
2113                      .char 'E'                                           ; Token 102:    "EXTRA "
     **** ****     > CHAR
0004 069C 66              byte 'E' ^ RE
                   < elite.a99
2114                      .char 'X'                                           ;
     **** ****     > CHAR
0004 069D   7B            byte 'X' ^ RE
                   < elite.a99
2115                      .char 'T'                                           ; Encoded as:   "EXT<148> "
     **** ****     > CHAR
0004 069E 77              byte 'T' ^ RE
                   < elite.a99
2116 069F   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' null
2117                      .char ' '
     **** ****     > CHAR
0004 06A0 03              byte ' ' ^ RE
                   < elite.a99
2118 06A1   00            byte >00
2119               
2120                      .char 'P'                                           ; Token 103:    "PULSE LASER"
     **** ****     > CHAR
0004 06A2 73              byte 'P' ^ RE
                   < elite.a99
2121                      .char 'U'                                           ;
     **** ****     > CHAR
0004 06A3   76            byte 'U' ^ RE
                   < elite.a99
2122                      .char 'L'                                           ; Encoded as:   "PULSE[27]"
     **** ****     > CHAR
0004 06A4 6F              byte 'L' ^ RE
                   < elite.a99
2123                      .char 'S'
     **** ****     > CHAR
0004 06A5   70            byte 'S' ^ RE
                   < elite.a99
2124                      .char 'E'
     **** ****     > CHAR
0004 06A6 66              byte 'E' ^ RE
                   < elite.a99
2125                      .rtok 27
     **** ****     > RTOK
0003 06A7   98            byte (27 + 160) ^ RE
                   < elite.a99
2126 06A8 00              byte >00
2127               
2128 06A9   B0            byte 147 ^ RE                                       ; TWOK 'B', 'E' Token 104:    "BEAM LASER"
2129                      .char 'A'                                           ;
     **** ****     > CHAR
0004 06AA 62              byte 'A' ^ RE
                   < elite.a99
2130                      .char 'M'                                           ; Encoded as:   "<147>AM[27]"
     **** ****     > CHAR
0004 06AB   6E            byte 'M' ^ RE
                   < elite.a99
2131                      .rtok 27
     **** ****     > RTOK
0003 06AC 98              byte (27 + 160) ^ RE
                   < elite.a99
2132 06AD   00            byte >00
2133               
2134                      .char 'F'                                           ; Token 105:    "FUEL"
     **** ****     > CHAR
0004 06AE 65              byte 'F' ^ RE
                   < elite.a99
2135                      .char 'U'                                           ;
     **** ****     > CHAR
0004 06AF   76            byte 'U' ^ RE
                   < elite.a99
2136                      .char 'E'                                           ; Encoded as:   "FUEL"
     **** ****     > CHAR
0004 06B0 66              byte 'E' ^ RE
                   < elite.a99
2137                      .char 'L'
     **** ****     > CHAR
0004 06B1   6F            byte 'L' ^ RE
                   < elite.a99
2138 06B2 00              byte >00
2139               
2140                      .char 'M'                                           ; Token 106:    "MISSILE"
     **** ****     > CHAR
0004 06B3   6E            byte 'M' ^ RE
                   < elite.a99
2141 06B4 BE              byte 157 ^ RE                                       ; TWOK 'I', 'S'
2142                      .char 'S'                                           ; Encoded as:   "M<157>SI<129>"
     **** ****     > CHAR
0004 06B5   70            byte 'S' ^ RE
                   < elite.a99
2143                      .char 'I'
     **** ****     > CHAR
0004 06B6 6A              byte 'I' ^ RE
                   < elite.a99
2144 06B7   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2145 06B8 00              byte >00
2146               
2147                      .rtok 67                                            ; Token 107:    "LARGE CARGO{sentence case} BAY"
     **** ****     > RTOK
0003 06B9   C0            byte (67 + 160) ^ RE
                   < elite.a99
2148                      .rtok 46                                            ;
     **** ****     > RTOK
0003 06BA ED              byte (46 + 160) ^ RE
                   < elite.a99
2149                      .char ' '                                           ; Encoded as:   "[67][46] BAY"
     **** ****     > CHAR
0004 06BB   03            byte ' ' ^ RE
                   < elite.a99
2150                      .char 'B'
     **** ****     > CHAR
0004 06BC 61              byte 'B' ^ RE
                   < elite.a99
2151                      .char 'A'
     **** ****     > CHAR
0004 06BD   62            byte 'A' ^ RE
                   < elite.a99
2152                      .char 'Y'
     **** ****     > CHAR
0004 06BE 7A              byte 'Y' ^ RE
                   < elite.a99
2153 06BF   00            byte >00
2154               
2155                      .char 'E'                                           ; Token 108:    "E.C.M.SYSTEM"
     **** ****     > CHAR
0004 06C0 66              byte 'E' ^ RE
                   < elite.a99
2156                      .char '.'                                           ;
     **** ****     > CHAR
0004 06C1   0D            byte '.' ^ RE
                   < elite.a99
2157                      .char 'C'                                           ; Encoded as:   "E.C.M.[5]"
     **** ****     > CHAR
0004 06C2 60              byte 'C' ^ RE
                   < elite.a99
2158                      .char '.'
     **** ****     > CHAR
0004 06C3   0D            byte '.' ^ RE
                   < elite.a99
2159                      .char 'M'
     **** ****     > CHAR
0004 06C4 6E              byte 'M' ^ RE
                   < elite.a99
2160                      .char '.'
     **** ****     > CHAR
0004 06C5   0D            byte '.' ^ RE
                   < elite.a99
2161                      .rtok 5
     **** ****     > RTOK
0003 06C6 86              byte (5 + 160) ^ RE
                   < elite.a99
2162 06C7   00            byte >00
2163               
2164                      .rtok 102                                           ; Token 109:    "EXTRA PULSE LASERS"
     **** ****     > RTOK
0008 06C8 45              byte 102 ^ RE
                   < elite.a99
2165                      .rtok 103                                           ;
     **** ****     > RTOK
0008 06C9   44            byte 103 ^ RE
                   < elite.a99
2166                      .char 'S'                                           ; Encoded as:   "[102][103]S"
     **** ****     > CHAR
0004 06CA 70              byte 'S' ^ RE
                   < elite.a99
2167 06CB   00            byte >00
2168               
2169                      .rtok 102                                           ; Token 110:    "EXTRA BEAM LASERS"
     **** ****     > RTOK
0008 06CC 45              byte 102 ^ RE
                   < elite.a99
2170                      .rtok 104                                           ;
     **** ****     > RTOK
0008 06CD   4B            byte 104 ^ RE
                   < elite.a99
2171                      .char 'S'                                           ; Encoded as:   "[102][104]S"
     **** ****     > CHAR
0004 06CE 70              byte 'S' ^ RE
                   < elite.a99
2172 06CF   00            byte >00
2173               
2174                      .rtok 105                                           ; Token 111:    "FUEL SCOOPS"
     **** ****     > RTOK
0008 06D0 4A              byte 105 ^ RE
                   < elite.a99
2175                      .char ' '                                           ;
     **** ****     > CHAR
0004 06D1   03            byte ' ' ^ RE
                   < elite.a99
2176                      .char 'S'                                           ; Encoded as:   "[105] SCOOPS"
     **** ****     > CHAR
0004 06D2 70              byte 'S' ^ RE
                   < elite.a99
2177                      .char 'C'
     **** ****     > CHAR
0004 06D3   60            byte 'C' ^ RE
                   < elite.a99
2178                      .char 'O'
     **** ****     > CHAR
0004 06D4 6C              byte 'O' ^ RE
                   < elite.a99
2179                      .char 'O'
     **** ****     > CHAR
0004 06D5   6C            byte 'O' ^ RE
                   < elite.a99
2180                      .char 'P'
     **** ****     > CHAR
0004 06D6 73              byte 'P' ^ RE
                   < elite.a99
2181                      .char 'S'
     **** ****     > CHAR
0004 06D7   70            byte 'S' ^ RE
                   < elite.a99
2182 06D8 00              byte >00
2183               
2184 06D9   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' Token 112:    "ESCAPE POD"
2185                      .char 'C'                                           ;
     **** ****     > CHAR
0004 06DA 60              byte 'C' ^ RE
                   < elite.a99
2186                      .char 'A'                                           ; Encoded as:   "<137>CAPE POD"
     **** ****     > CHAR
0004 06DB   62            byte 'A' ^ RE
                   < elite.a99
2187                      .char 'P'
     **** ****     > CHAR
0004 06DC 73              byte 'P' ^ RE
                   < elite.a99
2188                      .char 'E'
     **** ****     > CHAR
0004 06DD   66            byte 'E' ^ RE
                   < elite.a99
2189                      .char ' '
     **** ****     > CHAR
0004 06DE 03              byte ' ' ^ RE
                   < elite.a99
2190                      .char 'P'
     **** ****     > CHAR
0004 06DF   73            byte 'P' ^ RE
                   < elite.a99
2191                      .char 'O'
     **** ****     > CHAR
0004 06E0 6C              byte 'O' ^ RE
                   < elite.a99
2192                      .char 'D'
     **** ****     > CHAR
0004 06E1   67            byte 'D' ^ RE
                   < elite.a99
2193 06E2 00              byte >00
2194               
2195                      .rtok 121                                           ; Token 113:    "ENERGY BOMB"
     **** ****     > RTOK
0008 06E3   5A            byte 121 ^ RE
                   < elite.a99
2196                      .char 'B'                                           ;
     **** ****     > CHAR
0004 06E4 61              byte 'B' ^ RE
                   < elite.a99
2197                      .char 'O'                                           ; Encoded as:   "[121]BOMB"
     **** ****     > CHAR
0004 06E5   6C            byte 'O' ^ RE
                   < elite.a99
2198                      .char 'M'
     **** ****     > CHAR
0004 06E6 6E              byte 'M' ^ RE
                   < elite.a99
2199                      .char 'B'
     **** ****     > CHAR
0004 06E7   61            byte 'B' ^ RE
                   < elite.a99
2200 06E8 00              byte >00
2201               
2202                      .rtok 121                                           ; Token 114:    "ENERGY UNIT"
     **** ****     > RTOK
0008 06E9   5A            byte 121 ^ RE
                   < elite.a99
2203                      .rtok 14                                            ;
     **** ****     > RTOK
0003 06EA 8D              byte (14 + 160) ^ RE
                   < elite.a99
2204 06EB   00            byte >00                                            ; Encoded as:   "[121][14]"
2205               
2206                      .rtok 124                                           ; Token 115:    "DOCKING COMPUTERS"
     **** ****     > RTOK
0008 06EC 5F              byte 124 ^ RE
                   < elite.a99
2207 06ED   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
2208                      .char 'G'                                           ; Encoded as:   "[124]<140>G [55]"
     **** ****     > CHAR
0004 06EE 64              byte 'G' ^ RE
                   < elite.a99
2209                      .char ' '
     **** ****     > CHAR
0004 06EF   03            byte ' ' ^ RE
                   < elite.a99
2210                      .rtok 55
     **** ****     > RTOK
0003 06F0 F4              byte (55 + 160) ^ RE
                   < elite.a99
2211 06F1   00            byte >00
2212               
2213                      .rtok 122                                           ; Token 116:    "GALACTIC HYPERSPACE "
     **** ****     > RTOK
0008 06F2 59              byte 122 ^ RE
                   < elite.a99
2214                      .char ' '                                           ;
     **** ****     > CHAR
0004 06F3   03            byte ' ' ^ RE
                   < elite.a99
2215                      .rtok 29                                            ; Encoded as:   "[122] [29]"
     **** ****     > RTOK
0003 06F4 9E              byte (29 + 160) ^ RE
                   < elite.a99
2216 06F5   00            byte >00
2217               
2218                      .char 'A'                                           ; Token 117:    "ALL"
     **** ****     > CHAR
0004 06F6 62              byte 'A' ^ RE
                   < elite.a99
2219                      .rtok 118                                           ;
     **** ****     > RTOK
0008 06F7   55            byte 118 ^ RE
                   < elite.a99
2220 06F8 00              byte >00                                            ; Encoded as:   "A[118]"
2221               
2222                      .char 'L'                                           ; Token 118:    "LL"
     **** ****     > CHAR
0004 06F9   6F            byte 'L' ^ RE
                   < elite.a99
2223                      .char 'L'                                           ;
     **** ****     > CHAR
0004 06FA 6F              byte 'L' ^ RE
                   < elite.a99
2224 06FB   00            byte >00                                            ; Encoded as:   "LL"
2225               
2226                      .rtok 37                                            ; Token 119:    "CASH:{cash} CR{crlf}
     **** ****     > RTOK
0003 06FC E6              byte (37 + 160) ^ RE
                   < elite.a99
2227                      .char ':'                                           ; "
     **** ****     > CHAR
0004 06FD   19            byte ':' ^ RE
                   < elite.a99
2228                      .cont 0                                             ;
     **** ****     > CONT
0001 06FE 23              byte 0 ^ RE
                   < elite.a99
2229 06FF   00            byte >00                                            ; Encoded as:   "[37]:{0}"
2230               
2231 0700 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 120:    "INCOMING MISSILE"
2232                      .rtok 91                                            ;
     **** ****     > RTOK
0003 0701   D8            byte (91 + 160) ^ RE
                   < elite.a99
2233 0702 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Encoded as:   "<140>[91]<140>G [106]"
2234                      .char 'G'
     **** ****     > CHAR
0004 0703   64            byte 'G' ^ RE
                   < elite.a99
2235                      .char ' '
     **** ****     > CHAR
0004 0704 03              byte ' ' ^ RE
                   < elite.a99
2236                      .rtok 106
     **** ****     > RTOK
0008 0705   49            byte 106 ^ RE
                   < elite.a99
2237 0706 00              byte >00
2238               
2239 0707   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' Token 121:    "ENERGY "
2240 0708 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R'
2241                      .char 'G'                                           ; Encoded as:   "<146><144>GY "
     **** ****     > CHAR
0004 0709   64            byte 'G' ^ RE
                   < elite.a99
2242                      .char 'Y'
     **** ****     > CHAR
0004 070A 7A              byte 'Y' ^ RE
                   < elite.a99
2243                      .char ' '
     **** ****     > CHAR
0004 070B   03            byte ' ' ^ RE
                   < elite.a99
2244 070C 00              byte >00
2245               
2246                      .char 'G'                                           ; Token 122:    "GALACTIC"
     **** ****     > CHAR
0004 070D   64            byte 'G' ^ RE
                   < elite.a99
2247                      .char 'A'                                           ;
     **** ****     > CHAR
0004 070E 62              byte 'A' ^ RE
                   < elite.a99
2248 070F   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A' Encoded as:   "GA<149>C<151>C"
2249                      .char 'C'
     **** ****     > CHAR
0004 0710 60              byte 'C' ^ RE
                   < elite.a99
2250 0711   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2251                      .char 'C'
     **** ****     > CHAR
0004 0712 60              byte 'C' ^ RE
                   < elite.a99
2252 0713   00            byte >00
2253               
2254                      .cont 13                                            ; Token 123:    "{crlf}
     **** ****     > CONT
0001 0714 2E              byte 13 ^ RE
                   < elite.a99
2255                      .rtok 92                                            ; COMMANDER'S NAME? "
     **** ****     > RTOK
0003 0715   DF            byte (92 + 160) ^ RE
                   < elite.a99
2256                      .char '`'                                           ;
     **** ****     > CHAR
0002 0716 04              byte 39 ^ RE
                   < elite.a99
2257                      .char 'S'                                           ; Encoded as:   "{13}[92]'S NAME? "
     **** ****     > CHAR
0004 0717   70            byte 'S' ^ RE
                   < elite.a99
2258                      .char ' '
     **** ****     > CHAR
0004 0718 03              byte ' ' ^ RE
                   < elite.a99
2259                      .char 'N'
     **** ****     > CHAR
0004 0719   6D            byte 'N' ^ RE
                   < elite.a99
2260                      .char 'A'
     **** ****     > CHAR
0004 071A 62              byte 'A' ^ RE
                   < elite.a99
2261                      .char 'M'
     **** ****     > CHAR
0004 071B   6E            byte 'M' ^ RE
                   < elite.a99
2262                      .char 'E'
     **** ****     > CHAR
0004 071C 66              byte 'E' ^ RE
                   < elite.a99
2263                      .char '?'
     **** ****     > CHAR
0004 071D   1C            byte '?' ^ RE
                   < elite.a99
2264                      .char ' '
     **** ****     > CHAR
0004 071E 03              byte ' ' ^ RE
                   < elite.a99
2265 071F   00            byte >00
2266               
2267                      .char 'D'                                           ; Token 124:    "DOCK"
     **** ****     > CHAR
0004 0720 67              byte 'D' ^ RE
                   < elite.a99
2268                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0721   6C            byte 'O' ^ RE
                   < elite.a99
2269                      .char 'C'                                           ; Encoded as:   "DOCK"
     **** ****     > CHAR
0004 0722 60              byte 'C' ^ RE
                   < elite.a99
2270                      .char 'K'
     **** ****     > CHAR
0004 0723   68            byte 'K' ^ RE
                   < elite.a99
2271 0724 00              byte >00
2272               
2273                      .cont 5                                             ; Token 125:    "FUEL: {fuel level} LIGHT YEARS{crlf}
     **** ****     > CONT
0001 0725   26            byte 5 ^ RE
                   < elite.a99
2274 0726 A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' CASH:{cash} CR{crlf}
2275                      .char 'G'                                           ; LEGAL STATUS:"
     **** ****     > CHAR
0004 0727   64            byte 'G' ^ RE
                   < elite.a99
2276 0728 A3              byte 128 ^ RE                                       ; TWOK 'A', 'L'
2277                      .char ' '                                           ; Encoded as:   "{5}<129>G<128> [43]<145><136>:"
     **** ****     > CHAR
0004 0729   03            byte ' ' ^ RE
                   < elite.a99
2278                      .rtok 43
     **** ****     > RTOK
0003 072A E8              byte (43 + 160) ^ RE
                   < elite.a99
2279 072B   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
2280 072C AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2281                      .char ':'
     **** ****     > CHAR
0004 072D   19            byte ':' ^ RE
                   < elite.a99
2282 072E 00              byte >00
2283               
2284                      .rtok 92                                            ; Token 126:    "COMMANDER {commander name}{crlf}
     **** ****     > RTOK
0003 072F   DF            byte (92 + 160) ^ RE
                   < elite.a99
2285                      .char ' '                                           ; {crlf}
     **** ****     > CHAR
0004 0730 03              byte ' ' ^ RE
                   < elite.a99
2286                      .cont 4                                             ; {crlf}
     **** ****     > CONT
0001 0731   27            byte 4 ^ RE
                   < elite.a99
2287                      .cont 13                                            ; {sentence case}PRESENT SYSTEM{tab to
     **** ****     > CONT
0001 0732 2E              byte 13 ^ RE
                   < elite.a99
2288                      .cont 13                                            ; column 21}:{current system name}{crlf}
     **** ****     > CONT
0001 0733   2E            byte 13 ^ RE
                   < elite.a99
2289                      .cont 13                                            ; HYPERSPACE SYSTEM{tab to column 21}:
     **** ****     > CONT
0001 0734 2E              byte 13 ^ RE
                   < elite.a99
2290                      .cont 6                                             ; {selected system name}{crlf}
     **** ****     > CONT
0001 0735   25            byte 6 ^ RE
                   < elite.a99
2291                      .rtok 145                                           ; CONDITION{tab to column 21}:"
     **** ****     > RTOK
0006 0736 3C              byte (145 - 114) ^ RE
                   < elite.a99
2292                      .char ' '                                           ;
     **** ****     > CHAR
0004 0737   03            byte ' ' ^ RE
                   < elite.a99
2293                      .rtok 5                                             ; Encoded as:   "[92] {4}{13}{13}{13}{6}[145] [5]{9}{2}
     **** ****     > RTOK
0003 0738 86              byte (5 + 160) ^ RE
                   < elite.a99
2294                      .cont 9                                             ; {13}[29][5]{9}{3}{13}C<159><141><151>
     **** ****     > CONT
0001 0739   2A            byte 9 ^ RE
                   < elite.a99
2295                      .cont 2                                             ; <159>{9}"
     **** ****     > CONT
0001 073A 21              byte 2 ^ RE
                   < elite.a99
2296                      .cont 13
     **** ****     > CONT
0001 073B   2E            byte 13 ^ RE
                   < elite.a99
2297                      .rtok 29
     **** ****     > RTOK
0003 073C 9E              byte (29 + 160) ^ RE
                   < elite.a99
2298                      .rtok 5
     **** ****     > RTOK
0003 073D   86            byte (5 + 160) ^ RE
                   < elite.a99
2299                      .cont 9
     **** ****     > CONT
0001 073E 2A              byte 9 ^ RE
                   < elite.a99
2300                      .cont 3
     **** ****     > CONT
0001 073F   20            byte 3 ^ RE
                   < elite.a99
2301                      .cont 13
     **** ****     > CONT
0001 0740 2E              byte 13 ^ RE
                   < elite.a99
2302                      .char 'C'
     **** ****     > CHAR
0004 0741   60            byte 'C' ^ RE
                   < elite.a99
2303 0742 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
2304 0743   AE            byte 141 ^ RE                                       ; TWOK 'D', 'I' null
2305 0744 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2306 0745   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
2307                      .cont 9
     **** ****     > CONT
0001 0746 2A              byte 9 ^ RE
                   < elite.a99
2308 0747   00            byte >00
2309               
2310                      .char 'I'                                           ; Token 127:    "ITEM"
     **** ****     > CHAR
0004 0748 6A              byte 'I' ^ RE
                   < elite.a99
2311 0749   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E'
2312                      .char 'M'                                           ; Encoded as:   "I<156>M"
     **** ****     > CHAR
0004 074A 6E              byte 'M' ^ RE
                   < elite.a99
2313 074B   00            byte >00
2314               
2315                      .char ' '                                           ; Token 128:    "  LOAD NEW COMMANDER (Y/N)?{crlf}
     **** ****     > CHAR
0004 074C 03              byte ' ' ^ RE
                   < elite.a99
2316                      .char ' '                                           ; {crlf}
     **** ****     > CHAR
0004 074D   03            byte ' ' ^ RE
                   < elite.a99
2317                      .char 'L'                                           ; "
     **** ****     > CHAR
0004 074E 6F              byte 'L' ^ RE
                   < elite.a99
2318                      .char 'O'                                           ;
     **** ****     > CHAR
0004 074F   6C            byte 'O' ^ RE
                   < elite.a99
2319                      .char 'A'                                           ; Encoded as:   "  LOAD NEW [92] [65]{13}{13}"
     **** ****     > CHAR
0004 0750 62              byte 'A' ^ RE
                   < elite.a99
2320                      .char 'D'
     **** ****     > CHAR
0004 0751   67            byte 'D' ^ RE
                   < elite.a99
2321                      .char ' '
     **** ****     > CHAR
0004 0752 03              byte ' ' ^ RE
                   < elite.a99
2322                      .char 'N'
     **** ****     > CHAR
0004 0753   6D            byte 'N' ^ RE
                   < elite.a99
2323                      .char 'E'
     **** ****     > CHAR
0004 0754 66              byte 'E' ^ RE
                   < elite.a99
2324                      .char 'W'
     **** ****     > CHAR
0004 0755   74            byte 'W' ^ RE
                   < elite.a99
2325                      .char ' '
     **** ****     > CHAR
0004 0756 03              byte ' ' ^ RE
                   < elite.a99
2326                      .rtok 92
     **** ****     > RTOK
0003 0757   DF            byte (92 + 160) ^ RE
                   < elite.a99
2327                      .char ' '
     **** ****     > CHAR
0004 0758 03              byte ' ' ^ RE
                   < elite.a99
2328                      .rtok 65
     **** ****     > RTOK
0003 0759   C2            byte (65 + 160) ^ RE
                   < elite.a99
2329                      .cont 13
     **** ****     > CONT
0001 075A 2E              byte 13 ^ RE
                   < elite.a99
2330                      .cont 13
     **** ****     > CONT
0001 075B   2E            byte 13 ^ RE
                   < elite.a99
2331 075C 00              byte >00
2332               
2333                      .cont 6                                             ; Token 129:    "{sentence case}DOCKED"
     **** ****     > CONT
0001 075D   25            byte 6 ^ RE
                   < elite.a99
2334                      .rtok 124                                           ;
     **** ****     > RTOK
0008 075E 5F              byte 124 ^ RE
                   < elite.a99
2335 075F   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' Encoded as:   "{6}[124]<152>"
2336 0760 00              byte >00
2337               
2338 0761   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Token 130:    "RATING:"
2339 0762 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I'
2340                      .char 'N'                                           ; Encoded as:   "<148><151>NG:"
     **** ****     > CHAR
0004 0763   6D            byte 'N' ^ RE
                   < elite.a99
2341                      .char 'G'
     **** ****     > CHAR
0004 0764 64              byte 'G' ^ RE
                   < elite.a99
2342                      .char ':'
     **** ****     > CHAR
0004 0765   19            byte ':' ^ RE
                   < elite.a99
2343 0766 00              byte >00
2344               
2345                      .char ' '                                           ; Token 131:    " ON "
     **** ****     > CHAR
0004 0767   03            byte ' ' ^ RE
                   < elite.a99
2346 0768 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N'
2347                      .char ' '                                           ; Encoded as:   " <159> "
     **** ****     > CHAR
0004 0769   03            byte ' ' ^ RE
                   < elite.a99
2348 076A 00              byte >00
2349               
2350                      .cont 13                                            ; Token 132:    "{crlf}
     **** ****     > CONT
0001 076B   2E            byte 13 ^ RE
                   < elite.a99
2351                      .cont 8                                             ; {all caps}EQUIPMENT: {sentence case}"
     **** ****     > CONT
0001 076C 2B              byte 8 ^ RE
                   < elite.a99
2352                      .rtok 47                                            ;
     **** ****     > RTOK
0003 076D   EC            byte (47 + 160) ^ RE
                   < elite.a99
2353                      .char 'M'                                           ; Encoded as:   "{13}{8}[47]M<146>T:{6}"
     **** ****     > CHAR
0004 076E 6E              byte 'M' ^ RE
                   < elite.a99
2354 076F   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2355                      .char 'T'
     **** ****     > CHAR
0004 0770 77              byte 'T' ^ RE
                   < elite.a99
2356                      .char ':'
     **** ****     > CHAR
0004 0771   19            byte ':' ^ RE
                   < elite.a99
2357                      .cont 6
     **** ****     > CONT
0001 0772 25              byte 6 ^ RE
                   < elite.a99
2358 0773   00            byte >00
2359               
2360                      .char 'C'                                           ; Token 133:    "CLEAN"
     **** ****     > CHAR
0004 0774 60              byte 'C' ^ RE
                   < elite.a99
2361 0775   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E'
2362 0776 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "C<129><155>"
2363 0777   00            byte >00
2364               
2365                      .char 'O'                                           ; Token 134:    "OFFENDER"
     **** ****     > CHAR
0004 0778 6C              byte 'O' ^ RE
                   < elite.a99
2366                      .char 'F'                                           ;
     **** ****     > CHAR
0004 0779   65            byte 'F' ^ RE
                   < elite.a99
2367                      .char 'F'                                           ; Encoded as:   "OFF<146>D<144>"
     **** ****     > CHAR
0004 077A 65              byte 'F' ^ RE
                   < elite.a99
2368 077B   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2369                      .char 'D'
     **** ****     > CHAR
0004 077C 67              byte 'D' ^ RE
                   < elite.a99
2370 077D   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
2371 077E 00              byte >00
2372               
2373                      .char 'F'                                           ; Token 135:    "FUGITIVE"
     **** ****     > CHAR
0004 077F   65            byte 'F' ^ RE
                   < elite.a99
2374                      .char 'U'                                           ;
     **** ****     > CHAR
0004 0780 76              byte 'U' ^ RE
                   < elite.a99
2375                      .char 'G'                                           ; Encoded as:   "FUGI<151><150>"
     **** ****     > CHAR
0004 0781   64            byte 'G' ^ RE
                   < elite.a99
2376                      .char 'I'
     **** ****     > CHAR
0004 0782 6A              byte 'I' ^ RE
                   < elite.a99
2377 0783   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2378 0784 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2379 0785   00            byte >00
2380               
2381                      .char 'H'                                           ; Token 136:    "HARMLESS"
     **** ****     > CHAR
0004 0786 6B              byte 'H' ^ RE
                   < elite.a99
2382 0787   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R'
2383                      .char 'M'                                           ; Encoded as:   "H<138>M<129>SS"
     **** ****     > CHAR
0004 0788 6E              byte 'M' ^ RE
                   < elite.a99
2384 0789   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2385                      .char 'S'
     **** ****     > CHAR
0004 078A 70              byte 'S' ^ RE
                   < elite.a99
2386                      .char 'S'
     **** ****     > CHAR
0004 078B   70            byte 'S' ^ RE
                   < elite.a99
2387 078C 00              byte >00
2388               
2389                      .char 'M'                                           ; Token 137:    "MOSTLY HARMLESS"
     **** ****     > CHAR
0004 078D   6E            byte 'M' ^ RE
                   < elite.a99
2390                      .char 'O'                                           ;
     **** ****     > CHAR
0004 078E 6C              byte 'O' ^ RE
                   < elite.a99
2391                      .rtok 43                                            ; Encoded as:   "MO[43]LY [136]"
     **** ****     > RTOK
0003 078F   E8            byte (43 + 160) ^ RE
                   < elite.a99
2392                      .char 'L'
     **** ****     > CHAR
0004 0790 6F              byte 'L' ^ RE
                   < elite.a99
2393                      .char 'Y'
     **** ****     > CHAR
0004 0791   7A            byte 'Y' ^ RE
                   < elite.a99
2394                      .char ' '
     **** ****     > CHAR
0004 0792 03              byte ' ' ^ RE
                   < elite.a99
2395                      .rtok 136
     **** ****     > RTOK
0006 0793   35            byte (136 - 114) ^ RE
                   < elite.a99
2396 0794 00              byte >00
2397               
2398                      .rtok 12                                            ; Token 138:    "POOR "
     **** ****     > RTOK
0003 0795   8F            byte (12 + 160) ^ RE
                   < elite.a99
2399 0796 00              byte >00                                            ;
2400                                                                          ; Encoded as:   "[12]"
2401               
2402                      .rtok 11                                            ; Token 139:    "AVERAGE "
     **** ****     > RTOK
0003 0797   88            byte (11 + 160) ^ RE
                   < elite.a99
2403 0798 00              byte >00                                            ;
2404                                                                          ; Encoded as:   "[11]"
2405               
2406                      .char 'A'                                           ; Token 140:    "ABOVE AVERAGE "
     **** ****     > CHAR
0004 0799   62            byte 'A' ^ RE
                   < elite.a99
2407                      .char 'B'                                           ;
     **** ****     > CHAR
0004 079A 61              byte 'B' ^ RE
                   < elite.a99
2408                      .char 'O'                                           ; Encoded as:   "ABO<150> [11]"
     **** ****     > CHAR
0004 079B   6C            byte 'O' ^ RE
                   < elite.a99
2409 079C B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2410                      .char ' '
     **** ****     > CHAR
0004 079D   03            byte ' ' ^ RE
                   < elite.a99
2411                      .rtok 11
     **** ****     > RTOK
0003 079E 88              byte (11 + 160) ^ RE
                   < elite.a99
2412 079F   00            byte >00
2413               
2414                      .rtok 91                                            ; Token 141:    "COMPETENT"
     **** ****     > RTOK
0003 07A0 D8              byte (91 + 160) ^ RE
                   < elite.a99
2415                      .char 'P'                                           ;
     **** ****     > CHAR
0004 07A1   73            byte 'P' ^ RE
                   < elite.a99
2416                      .char 'E'                                           ; Encoded as:   "[91]PET<146>T"
     **** ****     > CHAR
0004 07A2 66              byte 'E' ^ RE
                   < elite.a99
2417                      .char 'T'
     **** ****     > CHAR
0004 07A3   77            byte 'T' ^ RE
                   < elite.a99
2418 07A4 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2419                      .char 'T'
     **** ****     > CHAR
0004 07A5   77            byte 'T' ^ RE
                   < elite.a99
2420 07A6 00              byte >00
2421               
2422                      .char 'D'                                           ; Token 142:    "DANGEROUS"
     **** ****     > CHAR
0004 07A7   67            byte 'D' ^ RE
                   < elite.a99
2423 07A8 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
2424 07A9   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "D<155><131>RO<136>"
2425                      .char 'R'
     **** ****     > CHAR
0004 07AA 71              byte 'R' ^ RE
                   < elite.a99
2426                      .char 'O'
     **** ****     > CHAR
0004 07AB   6C            byte 'O' ^ RE
                   < elite.a99
2427 07AC AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2428 07AD   00            byte >00
2429               
2430                      .char 'D'                                           ; Token 143:    "DEADLY"
     **** ****     > CHAR
0004 07AE 67              byte 'D' ^ RE
                   < elite.a99
2431                      .char 'E'                                           ;
     **** ****     > CHAR
0004 07AF   66            byte 'E' ^ RE
                   < elite.a99
2432                      .char 'A'                                           ; Encoded as:   "DEADLY"
     **** ****     > CHAR
0004 07B0 62              byte 'A' ^ RE
                   < elite.a99
2433                      .char 'D'
     **** ****     > CHAR
0004 07B1   67            byte 'D' ^ RE
                   < elite.a99
2434                      .char 'L'
     **** ****     > CHAR
0004 07B2 6F              byte 'L' ^ RE
                   < elite.a99
2435                      .char 'Y'
     **** ****     > CHAR
0004 07B3   7A            byte 'Y' ^ RE
                   < elite.a99
2436 07B4 00              byte >00
2437               
2438                      .char '-'                                           ; Token 144:    "---- E L I T E ----"
     **** ****     > CHAR
0004 07B5   0E            byte '-' ^ RE
                   < elite.a99
2439                      .char '-'                                           ;
     **** ****     > CHAR
0004 07B6 0E              byte '-' ^ RE
                   < elite.a99
2440                      .char '-'                                           ; Encoded as:   "---- E L I T E ----"
     **** ****     > CHAR
0004 07B7   0E            byte '-' ^ RE
                   < elite.a99
2441                      .char '-'
     **** ****     > CHAR
0004 07B8 0E              byte '-' ^ RE
                   < elite.a99
2442                      .char ' '
     **** ****     > CHAR
0004 07B9   03            byte ' ' ^ RE
                   < elite.a99
2443                      .char 'E'
     **** ****     > CHAR
0004 07BA 66              byte 'E' ^ RE
                   < elite.a99
2444                      .char ' '
     **** ****     > CHAR
0004 07BB   03            byte ' ' ^ RE
                   < elite.a99
2445                      .char 'L'
     **** ****     > CHAR
0004 07BC 6F              byte 'L' ^ RE
                   < elite.a99
2446                      .char ' '
     **** ****     > CHAR
0004 07BD   03            byte ' ' ^ RE
                   < elite.a99
2447                      .char 'I'
     **** ****     > CHAR
0004 07BE 6A              byte 'I' ^ RE
                   < elite.a99
2448                      .char ' '
     **** ****     > CHAR
0004 07BF   03            byte ' ' ^ RE
                   < elite.a99
2449                      .char 'T'
     **** ****     > CHAR
0004 07C0 77              byte 'T' ^ RE
                   < elite.a99
2450                      .char ' '
     **** ****     > CHAR
0004 07C1   03            byte ' ' ^ RE
                   < elite.a99
2451                      .char 'E'
     **** ****     > CHAR
0004 07C2 66              byte 'E' ^ RE
                   < elite.a99
2452                      .char ' '
     **** ****     > CHAR
0004 07C3   03            byte ' ' ^ RE
                   < elite.a99
2453                      .char '-'
     **** ****     > CHAR
0004 07C4 0E              byte '-' ^ RE
                   < elite.a99
2454                      .char '-'
     **** ****     > CHAR
0004 07C5   0E            byte '-' ^ RE
                   < elite.a99
2455                      .char '-'
     **** ****     > CHAR
0004 07C6 0E              byte '-' ^ RE
                   < elite.a99
2456                      .char '-'
     **** ****     > CHAR
0004 07C7   0E            byte '-' ^ RE
                   < elite.a99
2457 07C8 00              byte >00
2458               
2459                      .char 'P'                                           ; Token 145:    "PRESENT"
     **** ****     > CHAR
0004 07C9   73            byte 'P' ^ RE
                   < elite.a99
2460 07CA AD              byte 142 ^ RE                                       ; TWOK 'R', 'E'
2461                      .char 'S'                                           ; Encoded as:   "P<142>S<146>T"
     **** ****     > CHAR
0004 07CB   70            byte 'S' ^ RE
                   < elite.a99
2462 07CC B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2463                      .char 'T'
     **** ****     > CHAR
0004 07CD   77            byte 'T' ^ RE
                   < elite.a99
2464 07CE 00              byte >00
2465               
2466                      .cont 8                                             ; Token 146:    "{all caps}GAME OVER"
     **** ****     > CONT
0001 07CF   2B            byte 8 ^ RE
                   < elite.a99
2467                      .char 'G'                                           ;
     **** ****     > CHAR
0004 07D0 64              byte 'G' ^ RE
                   < elite.a99
2468                      .char 'A'                                           ; Encoded as:   "{8}GAME O<150>R"
     **** ****     > CHAR
0004 07D1   62            byte 'A' ^ RE
                   < elite.a99
2469                      .char 'M'
     **** ****     > CHAR
0004 07D2 6E              byte 'M' ^ RE
                   < elite.a99
2470                      .char 'E'
     **** ****     > CHAR
0004 07D3   66            byte 'E' ^ RE
                   < elite.a99
2471                      .char ' '
     **** ****     > CHAR
0004 07D4 03              byte ' ' ^ RE
                   < elite.a99
2472                      .char 'O'
     **** ****     > CHAR
0004 07D5   6C            byte 'O' ^ RE
                   < elite.a99
2473 07D6 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2474                      .char 'R'
     **** ****     > CHAR
0004 07D7   71            byte 'R' ^ RE
                   < elite.a99
2475 07D8 00              byte >00
2476               
2477                      .char 'P'                                           ; Token 147:    "PRESS FIRE OR SPACE,COMMANDER.{crlf}
     **** ****     > CHAR
0004 07D9   73            byte 'P' ^ RE
                   < elite.a99
2478                      .char 'R'                                           ; {crlf}
     **** ****     > CHAR
0004 07DA 71              byte 'R' ^ RE
                   < elite.a99
2479 07DB   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' "
2480                      .char 'S'                                           ;
     **** ****     > CHAR
0004 07DC 70              byte 'S' ^ RE
                   < elite.a99
2481                      .char ' '                                           ; Encoded as:   "PR<137>S FI<142> <153> SPA<133>,[92].
     **** ****     > CHAR
0004 07DD   03            byte ' ' ^ RE
                   < elite.a99
2482                      .char 'F'                                           ; {13}{13}"
     **** ****     > CHAR
0004 07DE 65              byte 'F' ^ RE
                   < elite.a99
2483                      .char 'I'
     **** ****     > CHAR
0004 07DF   6A            byte 'I' ^ RE
                   < elite.a99
2484 07E0 AD              byte 142 ^ RE                                       ; TWOK 'R', 'E' null
2485                      .char ' '
     **** ****     > CHAR
0004 07E1   03            byte ' ' ^ RE
                   < elite.a99
2486 07E2 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2487                      .char ' '
     **** ****     > CHAR
0004 07E3   03            byte ' ' ^ RE
                   < elite.a99
2488                      .char 'S'
     **** ****     > CHAR
0004 07E4 70              byte 'S' ^ RE
                   < elite.a99
2489                      .char 'P'
     **** ****     > CHAR
0004 07E5   73            byte 'P' ^ RE
                   < elite.a99
2490                      .char 'A'
     **** ****     > CHAR
0004 07E6 62              byte 'A' ^ RE
                   < elite.a99
2491 07E7   A6            byte 133 ^ RE                                       ; TWOK 'C', 'E' null
2492                      .char ','
     **** ****     > CHAR
0004 07E8 0F              byte ',' ^ RE
                   < elite.a99
2493                      .rtok 92
     **** ****     > RTOK
0003 07E9   DF            byte (92 + 160) ^ RE
                   < elite.a99
2494                      .char '.'
     **** ****     > CHAR
0004 07EA 0D              byte '.' ^ RE
                   < elite.a99
2495                      .cont 13
     **** ****     > CONT
0001 07EB   2E            byte 13 ^ RE
                   < elite.a99
2496                      .cont 13
     **** ****     > CONT
0001 07EC 2E              byte 13 ^ RE
                   < elite.a99
2497 07ED   00            byte >00
2498               
2499                      .char '('                                           ; Token 148:    "(C) ACORNSOFT 1984"
     **** ****     > CHAR
0004 07EE 0B              byte '(' ^ RE
                   < elite.a99
2500                      .char 'C'                                           ;
     **** ****     > CHAR
0004 07EF   60            byte 'C' ^ RE
                   < elite.a99
2501                      .char ')'                                           ; Encoded as:   "(C) AC<153>N<135>FT 1984"
     **** ****     > CHAR
0004 07F0 0A              byte ')' ^ RE
                   < elite.a99
2502                      .char ' '
     **** ****     > CHAR
0004 07F1   03            byte ' ' ^ RE
                   < elite.a99
2503                      .char 'A'
     **** ****     > CHAR
0004 07F2 62              byte 'A' ^ RE
                   < elite.a99
2504                      .char 'C'
     **** ****     > CHAR
0004 07F3   60            byte 'C' ^ RE
                   < elite.a99
2505 07F4 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2506                      .char 'N'
     **** ****     > CHAR
0004 07F5   6D            byte 'N' ^ RE
                   < elite.a99
2507 07F6 A4              byte 135 ^ RE                                       ; TWOK 'S', 'O' null
2508                      .char 'F'
     **** ****     > CHAR
0004 07F7   65            byte 'F' ^ RE
                   < elite.a99
2509                      .char 'T'
     **** ****     > CHAR
0004 07F8 77              byte 'T' ^ RE
                   < elite.a99
2510                      .char ' '
     **** ****     > CHAR
0004 07F9   03            byte ' ' ^ RE
                   < elite.a99
2511                      .char '1'
     **** ****     > CHAR
0004 07FA 12              byte '1' ^ RE
                   < elite.a99
2512                      .char '9'
     **** ****     > CHAR
0004 07FB   1A            byte '9' ^ RE
                   < elite.a99
2513                      .char '8'
     **** ****     > CHAR
0004 07FC 1B              byte '8' ^ RE
                   < elite.a99
2514                      .char '4'
     **** ****     > CHAR
0004 07FD   17            byte '4' ^ RE
                   < elite.a99
2515 07FE 00              byte >00
2516               
2517               * ******************************************************************************
2518               *
2519               * Save WORDS9.bin
2520               *
2521               * ******************************************************************************
2522               
2523                      ; PRINT "WORDS9"
2524                      ; PRINT "Assembled at ", ~CODE_WORDS%
2525                      ; PRINT "Ends at ", ~P%
2526                      ; PRINT "Code size is ", ~(P% - CODE_WORDS%)
2527                      ; PRINT "Execute at ", ~LOAD_WORDS%
2528                      ; PRINT "Reload at ", ~LOAD_WORDS%
2529               
2530                      ; PRINT "S.WORDS9 ",~CODE_WORDS%," ",~P%," ",~LOAD_WORDS%," ",~LOAD_WORDS%
2531                      ; SAVE "3-assembled-output/WORDS9.bin", CODE_WORDS%, P%, LOAD_WORDS%
2532               
2533               * ******************************************************************************
2534               *
2535               * Name: K%
2536               * Type: Workspace
2537               * Address: &0900 to &0AAF
2538               * Category: Workspaces
2539               * Summary: Ship data blocks and ship line heaps
2540               * Deep dive: Ship data blocks
2541               * The local bubble of universe
2542               *
2543               * ------------------------------------------------------------------------------
2544               *
2545               * Contains ship data for all the ships, planets, suns and space stations in our
2546               * local bubble of universe, along with their corresponding ship line heaps.
2547               *
2548               * The blocks are pointed to by the lookup table at location UNIV. The first 432
2549               * bytes of the K% workspace hold ship data on up to 12 ships, with 36 (NI%)
2550               * bytes per ship, and the ship line heap grows downwards from WP at the end of
2551               * the K% workspace.
2552               *
2553               * See the deep dive on "Ship data blocks" for details on ship data blocks, and
2554               * the deep dive on "The local bubble of universe" for details of how Elite
2555               * stores the local universe in K%, FRIN and UNIV.
2556               *
2557               * ******************************************************************************
2558               
2559                      aorg K.
2560               
2561 0900                 bss NOSH * NI.                                      ; Ship data blocks and ship line heap
2562               
2563               * ******************************************************************************
2564               *
2565               * Name: WP
2566               * Type: Workspace
2567               * Address: &0D40 to &0F33
2568               * Category: Workspaces
2569               * Summary: Ship slots, variables
2570               *
2571               * ******************************************************************************
2572               
2573                      aorg WP.
2574               
2575 0D40                 bss 0                                               ; The start of the WP workspace
2576               
2577               FRIN:
2578 0D40                 bss NOSH + 1                                        ; Slots for the ships in the local bubble of universe
2579                                                                          ;
2580                                                                          ; There are #NOSH + 1 slots, but the ship-spawning
2581                                                                          ; routine at NWSHP only populates #NOSH of them, so
2582                                                                          ; there are 13 slots but only 12 are used for ships
2583                                                                          ; (the last slot is effectively used as a null
2584                                                                          ; terminator when shuffling the slots down in the
2585                                                                          ; KILLSHP routine)
2586                                                                          ;
2587                                                                          ; See the deep dive on "The local bubble of universe"
2588                                                                          ; for details of how Elite stores the local universe in
2589                                                                          ; FRIN, UNIV and K%
2590               
2591               CABTMP:
2592 0D4D                 bss 0                                               ; Cabin temperature
2593                                                                          ;
2594                                                                          ; The ambient cabin temperature in deep space is 30,
2595                                                                          ; which is displayed as one notch on the dashboard bar
2596                                                                          ;
2597                                                                          ; We get higher temperatures closer to the sun
2598                                                                          ;
2599                                                                          ; CABTMP shares a location with MANY, but that's OK as
2600                                                                          ; MANY+0 would contain the number of ships of type 0,
2601                                                                          ; and as there is no ship type 0 (they start at 1), the
2602                                                                          ; byte at MANY+0 is not used for storing a ship type
2603                                                                          ; and can be used for the cabin temperature instead
2604               
2605               MANY:
2606 0D4D                 bss SST                                             ; The number of ships of each type in the local bubble
2607                                                                          ; of universe
2608                                                                          ;
2609                                                                          ; The number of ships of type X in the local bubble is
2610                                                                          ; stored at MANY+X
2611                                                                          ;
2612                                                                          ; See the deep dive on "Ship blueprints" for a list of
2613                                                                          ; ship types
2614               
2615               SSPR:
2616 0D55                 bss NTY + 1 - SST                                   ; "Space station present" flag
2617                                                                          ;
2618                                                                          ; * Non-zero if we are inside the space station's safe
2619                                                                          ; zone
2620                                                                          ;
2621                                                                          ; * 0 if we aren't (in which case we can show the sun)
2622                                                                          ;
2623                                                                          ; This flag is at MANY+SST, which is no coincidence, as
2624                                                                          ; MANY+SST is a count of how many space stations there
2625                                                                          ; are in our local bubble, which is the same as saying
2626                                                                          ; "space station present"
2627               
2628               ECMP:
2629 0D5B                 bss 1                                               ; Our E.C.M. status
2630                                                                          ;
2631                                                                          ; * 0 = E.C.M. is off
2632                                                                          ;
2633                                                                          ; * Non-zero = E.C.M. is on
2634               
2635               MJ:
2636 0D5C                 bss 1                                               ; Are we in witchspace (i.e. have we mis-jumped)?
2637                                                                          ;
2638                                                                          ; * 0 = no, we are in normal space
2639                                                                          ;
2640                                                                          ; * &FF = yes, we are in witchspace
2641               
2642               LAS2:
2643 0D5D                 bss 1                                               ; Laser power for the current laser
2644                                                                          ;
2645                                                                          ; * Bits 0-6 contain the laser power of the current
2646                                                                          ; space view
2647                                                                          ;
2648                                                                          ; * Bit 7 denotes whether or not the laser pulses:
2649                                                                          ;
2650                                                                          ; * 0 = pulsing laser
2651                                                                          ;
2652                                                                          ; * 1 = beam laser (i.e. always on)
2653               
2654               MSAR:
2655 0D5E                 bss 1                                               ; The targeting state of our leftmost missile
2656                                                                          ;
2657                                                                          ; * 0 = missile is not looking for a target, or it
2658                                                                          ; already has a target lock (indicator is not
2659                                                                          ; yellow/white)
2660                                                                          ;
2661                                                                          ; * Non-zero = missile is currently looking for a
2662                                                                          ; target (indicator is yellow/white)
2663               
2664               VIEW:
2665 0D5F                 bss 1                                               ; The number of the current space view
2666                                                                          ;
2667                                                                          ; * 0 = front
2668                                                                          ; * 1 = rear
2669                                                                          ; * 2 = left
2670                                                                          ; * 3 = right
2671               
2672               LASCT:
2673 0D60                 bss 1                                               ; The laser pulse count for the current laser
2674                                                                          ;
2675                                                                          ; This is a counter that defines the gap between the
2676                                                                          ; pulses of a pulse laser. It is set as follows:
2677                                                                          ;
2678                                                                          ; * 0 for a beam laser
2679                                                                          ;
2680                                                                          ; * 10 for a pulse laser
2681                                                                          ;
2682                                                                          ; It gets decremented every vertical sync (in the LINSCN
2683                                                                          ; routine, which is called 50 times a second) and is set
2684                                                                          ; to a non-zero value for pulse lasers only
2685                                                                          ;
2686                                                                          ; The laser only fires when the value of LASCT hits
2687                                                                          ; zero, so for pulse lasers with a value of 10, that
2688                                                                          ; means the laser fires once every 10 vertical syncs (or
2689                                                                          ; 5 times a second)
2690                                                                          ;
2691                                                                          ; In comparison, beam lasers fire continuously as the
2692                                                                          ; value of LASCT is always 0
2693               
2694               GNTMP:
2695 0D61                 bss 1                                               ; Laser temperature (or "gun temperature")
2696                                                                          ;
2697                                                                          ; If the laser temperature exceeds 242 then the laser
2698                                                                          ; overheats and cannot be fired again until it has
2699                                                                          ; cooled down
2700               
2701               HFX:
2702 0D62                 bss 1                                               ; A flag that toggles the hyperspace colour effect
2703                                                                          ;
2704                                                                          ; * 0 = no colour effect
2705                                                                          ;
2706                                                                          ; * Non-zero = hyperspace colour effect enabled
2707                                                                          ;
2708                                                                          ; When HFX is set to 1, the mode 4 screen that makes
2709                                                                          ; up the top part of the display is temporarily switched
2710                                                                          ; to mode 5 (the same screen mode as the dashboard),
2711                                                                          ; which has the effect of blurring and colouring the
2712                                                                          ; hyperspace rings in the top part of the screen. The
2713                                                                          ; code to do this is in the LINSCN routine, which is
2714                                                                          ; called as part of the screen mode routine at IRQ1.
2715                                                                          ; It's in LINSCN that HFX is checked, and if it is
2716                                                                          ; non-zero, the top part of the screen is not switched
2717                                                                          ; to mode 4, thus leaving the top part of the screen in
2718                                                                          ; the more colourful mode 5
2719               
2720               EV:
2721 0D63                 bss 1                                               ; The "extra vessels" spawning counter
2722                                                                          ;
2723                                                                          ; This counter is set to 0 on arrival in a system and
2724                                                                          ; following an in-system jump, and is bumped up when we
2725                                                                          ; spawn bounty hunters or pirates (i.e. "extra vessels")
2726                                                                          ;
2727                                                                          ; It decreases by 1 each time we consider spawning more
2728                                                                          ; "extra vessels" in part 4 of the main game loop, so
2729                                                                          ; increasing the value of EV has the effect of delaying
2730                                                                          ; the spawning of more vessels
2731                                                                          ;
2732                                                                          ; In other words, this counter stops bounty hunters and
2733                                                                          ; pirates from continually appearing, and ensures that
2734                                                                          ; there's a delay between spawnings
2735               
2736               DLY:
2737 0D64                 bss 1                                               ; In-flight message delay
2738                                                                          ;
2739                                                                          ; This counter is used to keep an in-flight message up
2740                                                                          ; for a specified time before it gets removed. The value
2741                                                                          ; in DLY is decremented each time we start another
2742                                                                          ; iteration of the main game loop at TT100
2743               
2744               de_:
2745 0D65                 bss 1                                               ; Equipment destruction flag
2746                                                                          ;
2747                                                                          ; * Bit 1 denotes whether or not the in-flight message
2748                                                                          ; about to be shown by the MESS routine is about
2749                                                                          ; destroyed equipment:
2750                                                                          ;
2751                                                                          ; * 0 = the message is shown normally
2752                                                                          ;
2753                                                                          ; * 1 = the string " DESTROYED" gets added to the
2754                                                                          ; end of the message
2755               
2756               LSX:
2757 0D66                 bss 0                                               ; LSX is an alias that points to the first byte of the
2758                                                                          ; sun line heap at LSO
2759                                                                          ;
2760                                                                          ; * &FF indicates the sun line heap is empty
2761                                                                          ;
2762                                                                          ; * Otherwise the LSO heap contains the line data for
2763                                                                          ; the sun
2764               
2765               LSO:
2766 0D66                 bss 192                                             ; The ship line heap for the space station (see NWSPS)
2767                                                                          ; and the sun line heap (see SUN)
2768                                                                          ;
2769                                                                          ; The spaces can be shared as our local bubble of
2770                                                                          ; universe can support either the sun or a space
2771                                                                          ; station, but not both
2772               
2773               LSX2:
2774 0E26                 bss 78                                              ; The ball line heap for storing x-coordinates (see the
2775                                                                          ; deep dive on "The ball line heap" for details)
2776               
2777               LSY2:
2778 0E74                 bss 78                                              ; The ball line heap for storing y-coordinates (see the
2779                                                                          ; deep dive on "The ball line heap" for details)
2780               
2781               SY:
2782 0EC2                 bss NOST + 1                                        ; This is where we store the y_hi coordinates for all
2783                                                                          ; the stardust particles
2784               
2785               SYL:
2786 0ED5                 bss NOST + 1                                        ; This is where we store the y_lo coordinates for all
2787                                                                          ; the stardust particles
2788               
2789               SZ:
2790 0EE8                 bss NOST + 1                                        ; This is where we store the z_hi coordinates for all
2791                                                                          ; the stardust particles
2792               
2793               SZL:
2794 0EFB                 bss NOST + 1                                        ; This is where we store the z_lo coordinates for all
2795                                                                          ; the stardust particles
2796               
2797               XSAV2:
2798 0F0E                 bss 1                                               ; Temporary storage, used for storing the value of the X
2799                                                                          ; register in the TT26 routine
2800               
2801               YSAV2:
2802 0F0F                 bss 1                                               ; Temporary storage, used for storing the value of the Y
2803                                                                          ; register in the TT26 routine
2804               
2805               MCH:
2806 0F10                 bss 1                                               ; The text token number of the in-flight message that is
2807                                                                          ; currently being shown, and which will be removed by
2808                                                                          ; the me2 routine when the counter in DLY reaches zero
2809               
2810               FSH:
2811 0F11                 bss 1                                               ; Forward shield status
2812                                                                          ;
2813                                                                          ; * 0 = empty
2814                                                                          ;
2815                                                                          ; * &FF = full
2816               
2817               ASH:
2818 0F12                 bss 1                                               ; Aft shield status
2819                                                                          ;
2820                                                                          ; * 0 = empty
2821                                                                          ;
2822                                                                          ; * &FF = full
2823               
2824               ENERGY:
2825 0F13                 bss 1                                               ; Energy bank status
2826                                                                          ;
2827                                                                          ; * 0 = empty
2828                                                                          ;
2829                                                                          ; * &FF = full
2830               
2831               LASX:
2832 0F14                 bss 1                                               ; The x-coordinate of the tip of the laser line
2833               
2834               LASY:
2835 0F15                 bss 1                                               ; The y-coordinate of the tip of the laser line
2836               
2837               COMX:
2838 0F16                 bss 1                                               ; The x-coordinate of the compass dot
2839               
2840               COMY:
2841 0F17                 bss 1                                               ; The y-coordinate of the compass dot
2842               
2843               QQ24:
2844 0F18                 bss 1                                               ; Temporary storage, used to store the current market
2845                                                                          ; item's price in routine TT151
2846               
2847               QQ25:
2848 0F19                 bss 1                                               ; Temporary storage, used to store the current market
2849                                                                          ; item's availability in routine TT151
2850               
2851               QQ28:
2852 0F1A                 bss 1                                               ; The current system's economy (0-7)
2853                                                                          ;
2854                                                                          ; * 0 = Rich Industrial
2855                                                                          ; * 1 = Average Industrial
2856                                                                          ; * 2 = Poor Industrial
2857                                                                          ; * 3 = Mainly Industrial
2858                                                                          ; * 4 = Mainly Agricultural
2859                                                                          ; * 5 = Rich Agricultural
2860                                                                          ; * 6 = Average Agricultural
2861                                                                          ; * 7 = Poor Agricultural
2862                                                                          ;
2863                                                                          ; See the deep dive on "Generating system data" for more
2864                                                                          ; information on economies
2865               
2866               QQ29:
2867 0F1B                 bss 1                                               ; Temporary storage, used in a number of places
2868               
2869               gov_:
2870 0F1C                 bss 1                                               ; The current system's government type (0-7)
2871                                                                          ;
2872                                                                          ; See the deep dive on "Generating system data" for
2873                                                                          ; details of the various government types
2874               
2875               tek_:
2876 0F1D                 bss 1                                               ; The current system's tech level (0-14)
2877                                                                          ;
2878                                                                          ; See the deep dive on "Generating system data" for more
2879                                                                          ; information on tech levels
2880               
2881               SLSP:
2882 0F1E                 bss 2                                               ; The address of the bottom of the ship line heap
2883                                                                          ;
2884                                                                          ; The ship line heap is a descending block of memory
2885                                                                          ; that starts at WP and descends down to SLSP. It can be
2886                                                                          ; extended downwards by the NWSHP routine when adding
2887                                                                          ; new ships (and their associated ship line heaps), in
2888                                                                          ; which case SLSP is lowered to provide more heap space,
2889                                                                          ; assuming there is enough free memory to do so
2890               
2891               XX24:
2892 0F20                 bss 1                                               ; This byte appears to be unused
2893               
2894               ALTIT:
2895 0F21                 bss 1                                               ; Our altitude above the surface of the planet or sun
2896                                                                          ;
2897                                                                          ; * 255 = we are a long way above the surface
2898                                                                          ;
2899                                                                          ; * 1-254 = our altitude as the square root of:
2900                                                                          ;
2901                                                                          ; x_hi^2 + y_hi^2 + z_hi^2 - 6^2
2902                                                                          ;
2903                                                                          ; where our ship is at the origin, the centre of the
2904                                                                          ; planet/sun is at (x_hi, y_hi, z_hi), and the
2905                                                                          ; radius of the planet/sun is 6
2906                                                                          ;
2907                                                                          ; * 0 = we have crashed into the surface
2908               
2909               QQ2:
2910 0F22                 bss 6                                               ; The three 16-bit seeds for the current system, i.e.
2911                                                                          ; the one we are currently in
2912                                                                          ;
2913                                                                          ; See the deep dives on "Galaxy and system seeds" and
2914                                                                          ; "Twisting the system seeds" for more details
2915               
2916               QQ3:
2917 0F28                 bss 1                                               ; The selected system's economy (0-7)
2918                                                                          ;
2919                                                                          ; * 0 = Rich Industrial
2920                                                                          ; * 1 = Average Industrial
2921                                                                          ; * 2 = Poor Industrial
2922                                                                          ; * 3 = Mainly Industrial
2923                                                                          ; * 4 = Mainly Agricultural
2924                                                                          ; * 5 = Rich Agricultural
2925                                                                          ; * 6 = Average Agricultural
2926                                                                          ; * 7 = Poor Agricultural
2927                                                                          ;
2928                                                                          ; See the deep dive on "Generating system data" for more
2929                                                                          ; information on economies
2930               
2931               QQ4:
2932 0F29                 bss 1                                               ; The selected system's government (0-7)
2933                                                                          ;
2934                                                                          ; See the deep dive on "Generating system data" for more
2935                                                                          ; details of the various government types
2936               
2937               QQ5:
2938 0F2A                 bss 1                                               ; The selected system's tech level (0-14)
2939                                                                          ;
2940                                                                          ; See the deep dive on "Generating system data" for more
2941                                                                          ; information on tech levels
2942               
2943               QQ6:
2944 0F2B                 bss 2                                               ; The selected system's population in billions * 10
2945                                                                          ; (1-71), so the maximum population is 7.1 billion
2946                                                                          ;
2947                                                                          ; See the deep dive on "Generating system data" for more
2948                                                                          ; details on population levels
2949               
2950               QQ7:
2951 0F2D                 bss 2                                               ; The selected system's productivity in M CR (96-62480)
2952                                                                          ;
2953                                                                          ; See the deep dive on "Generating system data" for more
2954                                                                          ; details about productivity levels
2955               
2956               QQ8:
2957 0F2F                 bss 2                                               ; The distance from the current system to the selected
2958                                                                          ; system in light years * 10, stored as a 16-bit number
2959                                                                          ;
2960                                                                          ; The distance will be 0 if the selected system is the
2961                                                                          ; current system
2962                                                                          ;
2963                                                                          ; The galaxy chart is 102.4 light years wide and 51.2
2964                                                                          ; light years tall (see the intra-system distance
2965                                                                          ; calculations in routine TT111 for details), which
2966                                                                          ; equates to 1024 x 512 in terms of QQ8
2967               
2968               QQ9:
2969 0F31                 bss 1                                               ; The galactic x-coordinate of the crosshairs in the
2970                                                                          ; galaxy chart (and, most of the time, the selected
2971                                                                          ; system's galactic x-coordinate)
2972               
2973               QQ10:
2974 0F32                 bss 1                                               ; The galactic y-coordinate of the crosshairs in the
2975                                                                          ; galaxy chart (and, most of the time, the selected
2976                                                                          ; system's galactic y-coordinate)
2977               
2978               NOSTM:
2979 0F33                 bss 1                                               ; The number of stardust particles shown on screen,
2980                                                                          ; which is 18 (#NOST) for normal space, and 3 for
2981                                                                          ; witchspace
2982               
2983                      ; PRINT "WP workspace from  ", ~WP," to ", ~P%
2984               
2985               * ******************************************************************************
2986               *
2987               * ELITE A FILE
2988               *
2989               * Produces the binary file ELTA.bin that gets loaded by elite-bcfs.asm.
2990               *
2991               * The main game code (ELITE A through G, plus the ship data) is loaded at &1128
2992               * and is moved down to &0F40 as part of elite-loader.asm.
2993               *
2994               * ******************************************************************************
2995               
2996                      aorg CODE.
2997               
2998               LOAD_A.:
2999                      equ LOAD.
3000               
3001               * ******************************************************************************
3002               *
3003               * Name: S%
3004               * Type: Workspace
3005               * Address: &0F40 to &0F50
3006               * Category: Workspaces
3007               * Summary: Vector addresses, compass colour and configuration settings
3008               *
3009               * ------------------------------------------------------------------------------
3010               *
3011               * Contains addresses that are used by the loader to set up vectors, the current
3012               * compass colour, and the game's configuration settings.
3013               *
3014               * ******************************************************************************
3015               
3016               S.:
3017 0F40 C64C            data TT170                                          ; The entry point for the main game; once the main code
3018                                                                          ; has been loaded, decrypted and moved to the right
3019                                                                          ; place by elite-loader.asm, the game is started by a
3020                                                                          ; JMP (S%) instruction, which jumps to the main entry
3021                                                                          ; point at TT170 via this location
3022               
3023 0F42 31C2            data TT26                                           ; WRCHV is set to point here by elite-loader.asm
3024               
3025 0F44 365E            data IRQ1                                           ; IRQ1V is set to point here by elite-loader.asm
3026               
3027 0F46 C654            data BR1                                            ; BRKV is set to point here by elite-loader.asm
3028               
3029               COMC:
3030 0F48                 bss 1                                               ; The colour of the dot on the compass
3031                                                                          ;
3032                                                                          ; * &F0 = the object in the compass is in front of us,
3033                                                                          ; so the dot is yellow/white
3034                                                                          ;
3035                                                                          ; * &FF = the object in the compass is behind us, so
3036                                                                          ; the dot is green/cyan
3037               
3038               DNOIZ:
3039 0F49                 bss 1                                               ; Sound on/off configuration setting
3040                                                                          ;
3041                                                                          ; * 0 = sound is on (default)
3042                                                                          ;
3043                                                                          ; * Non-zero = sound is off
3044                                                                          ;
3045                                                                          ; Toggled by pressing "S" when paused, see the DK4
3046                                                                          ; routine for details
3047               
3048               DAMP:
3049 0F4A                 bss 1                                               ; Keyboard damping configuration setting
3050                                                                          ;
3051                                                                          ; * 0 = damping is enabled (default)
3052                                                                          ;
3053                                                                          ; * &FF = damping is disabled
3054                                                                          ;
3055                                                                          ; Toggled by pressing CAPS LOCK when paused, see the
3056                                                                          ; DKS3 routine for details
3057               
3058               DJD:
3059 0F4B                 bss 1                                               ; Keyboard auto-recentre configuration setting
3060                                                                          ;
3061                                                                          ; * 0 = auto-recentre is enabled (default)
3062                                                                          ;
3063                                                                          ; * &FF = auto-recentre is disabled
3064                                                                          ;
3065                                                                          ; Toggled by pressing "A" when paused, see the DKS3
3066                                                                          ; routine for details
3067               
3068               PATG:
3069 0F4C                 bss 1                                               ; Configuration setting to show the author names on the
3070                                                                          ; start-up screen and enable manual hyperspace mis-jumps
3071                                                                          ;
3072                                                                          ; * 0 = no author names or manual mis-jumps (default)
3073                                                                          ;
3074                                                                          ; * &FF = show author names and allow manual mis-jumps
3075                                                                          ;
3076                                                                          ; Toggled by pressing "X" when paused, see the DKS3
3077                                                                          ; routine for details
3078                                                                          ;
3079                                                                          ; This needs to be turned on for manual mis-jumps to be
3080                                                                          ; possible. To do a manual mis-jump, first toggle the
3081                                                                          ; author display by pausing the game (COPY) and pressing
3082                                                                          ; "X", and during the next hyperspace, hold down CTRL to
3083                                                                          ; force a mis-jump. See routine ee5 for the "AND PATG"
3084                                                                          ; instruction that implements this logic
3085               
3086               FLH:
3087 0F4D                 bss 1                                               ; Flashing console bars configuration setting
3088                                                                          ;
3089                                                                          ; * 0 = static bars (default)
3090                                                                          ;
3091                                                                          ; * &FF = flashing bars
3092                                                                          ;
3093                                                                          ; Toggled by pressing "F" when paused, see the DKS3
3094                                                                          ; routine for details
3095               
3096               JSTGY:
3097 0F4E                 bss 1                                               ; Reverse joystick Y-channel configuration setting
3098                                                                          ;
3099                                                                          ; * 0 = standard Y-channel (default)
3100                                                                          ;
3101                                                                          ; * &FF = reversed Y-channel
3102                                                                          ;
3103                                                                          ; Toggled by pressing "Y" when paused, see the DKS3
3104                                                                          ; routine for details
3105               
3106               JSTE:
3107 0F4F                 bss 1                                               ; Reverse both joystick channels configuration setting
3108                                                                          ;
3109                                                                          ; * 0 = standard channels (default)
3110                                                                          ;
3111                                                                          ; * &FF = reversed channels
3112                                                                          ;
3113                                                                          ; Toggled by pressing "J" when paused, see the DKS3
3114                                                                          ; routine for details
3115               
3116               JSTK:
3117 0F50                 bss 1                                               ; Keyboard or joystick configuration setting
3118                                                                          ;
3119                                                                          ; * 0 = keyboard (default)
3120                                                                          ;
3121                                                                          ; * &FF = joystick
3122                                                                          ;
3123                                                                          ; Toggled by pressing "K" when paused, see the DKS3
3124                                                                          ; routine for details
3125               
3126               * ******************************************************************************
3127               *
3128               * Name: Main flight loop (Part 1 of 16)
3129               * Type: Subroutine
3130               * Category: Main loop
3131               * Summary: Seed the random number generator
3132               * Deep dive: Program flow of the main game loop
3133               * Generating random numbers
3134               *
3135               * ------------------------------------------------------------------------------
3136               *
3137               * The main flight loop covers most of the flight-specific aspects of Elite. This
3138               * section covers the following:
3139               *
3140               * * Seed the random number generator
3141               *
3142               * ------------------------------------------------------------------------------
3143               *
3144               * Other entry points:
3145               *
3146               * M%                  The entry point for the main flight loop
3147               *
3148               * ******************************************************************************
3149               
3150               M.:
3151 0F52 D360  22        movb @K.,ra                     ; LDA K%            ; We want to seed the random number generator with a
     0F54 0900     
3152                                                                          ; pretty random number, so fetch the contents of K%,
3153                                                                          ; which is the x_lo coordinate of the planet. This value
3154                                                                          ; will be fairly unpredictable, so it's a pretty good
3155                                                                          ; candidate
3156               
3157 0F56 D80D  22        movb ra,@RAND                   ; STA RAND          ; Store the seed in the first byte of the four-byte
     0F58 0000     
3158                                                                          ; random number seed that's stored in RAND
3159               
3160               * ******************************************************************************
3161               *
3162               * Name: Main flight loop (Part 2 of 16)
3163               * Type: Subroutine
3164               * Category: Main loop
3165               * Summary: Calculate the alpha and beta angles from the current pitch and
3166               * roll of our ship
3167               * Deep dive: Program flow of the main game loop
3168               * Pitching and rolling
3169               *
3170               * ------------------------------------------------------------------------------
3171               *
3172               * The main flight loop covers most of the flight-specific aspects of Elite. This
3173               * section covers the following:
3174               *
3175               * * Calculate the alpha and beta angles from the current pitch and roll
3176               *
3177               * Here we take the current rate of pitch and roll, as set by the joystick or
3178               * keyboard, and convert them into alpha and beta angles that we can use in the
3179               * matrix functions to rotate space around our ship. The alpha angle covers
3180               * roll, while the beta angle covers pitch (there is no yaw in this version of
3181               * Elite). The angles are in radians, which allows us to use the small angle
3182               * approximation when moving objects in the sky (see the MVEIT routine for more
3183               * on this). Also, the signs of the two angles are stored separately, in both
3184               * the sign and the flipped sign, as this makes calculations easier.
3185               *
3186               * ******************************************************************************
3187               
3188 0F5A D3A0  22        movb @JSTX,rx                   ; LDX JSTX          ; Set X to the current rate of roll in JSTX
     0F5C 009C     
3189               
3190 0F5E 0200  12        li   rtmp,cntr_                 ; JSR cntr          ; Apply keyboard damping twice (if enabled) so the roll
     0F60 47C8     
3191 0F62 06A0  24        bl   @jsr                       ;
     0F64 FE28     
3192 0F66 0200  12        li   rtmp,cntr_                 ; JSR cntr          ; rate in X creeps towards the centre by 2
     0F68 47C8     
3193 0F6A 06A0  24        bl   @jsr                       ;
     0F6C FE28     
3194               
3195                                                                          ; The roll rate in JSTX increases if we press ">" (and
3196                                                                          ; the RL indicator on the dashboard goes to the right)
3197                                                                          ;
3198                                                                          ; This rolls our ship to the right (clockwise), but we
3199                                                                          ; actually implement this by rolling everything else
3200                                                                          ; to the left (anti-clockwise), so a positive roll rate
3201                                                                          ; in JSTX translates to a negative roll angle alpha
3202               
3203 0F6E D34E  14        movb rx,ra                      ; TXA               ; Set A and Y to the roll rate but with the sign bit
3204                      .eoi (>80*256)                  ; EOR #%10000000    ; flipped (i.e. set them to the sign we want for alpha)
     **** ****     > EOI
0001 0F70 0200  12        li   rtmp,(>80*256)
     0F72 8000     
0002 0F74 2B40  14        xor  rtmp,ra
                   < elite.a99
3205 0F76 D3CD  14        movb ra,ry                      ; TAY
3206               
3207 0F78 024D  14        andi ra,>80*256                 ; AND #%10000000    ; Extract the flipped sign of the roll rate and store
     0F7A 8000     
3208 0F7C D80D  22        movb ra,@ALP2                   ; STA ALP2          ; in ALP2 (so ALP2 contains the sign of the roll angle
     0F7E 0088     
3209                                                                          ; alpha)
3210               
3211 0F80 D80E  22        movb rx,@JSTX                   ; STX JSTX          ; Update JSTX with the damped value that's still in X
     0F82 009C     
3212               
3213                      .eoi (>80*256)                  ; EOR #%10000000    ; Extract the correct sign of the roll rate and store
     **** ****     > EOI
0001 0F84 0200  12        li   rtmp,(>80*256)
     0F86 8000     
0002 0F88 2B40  14        xor  rtmp,ra
                   < elite.a99
3214 0F8A D80D  22        movb ra,@ALP2+1                 ; STA ALP2+1        ; in ALP2+1 (so ALP2+1 contains the flipped sign of the
     0F8C 0089     
3215                                                                          ; roll angle alpha)
3216               
3217 0F8E D34F  14        movb ry,ra                      ; TYA               ; Set A to the roll rate but with the sign bit flipped
3218               
3219 0F90 1508  10        jgt  B01                        ; BPL B01           ; If the value of A is positive, skip the following
3220                                                                          ; three instructions
3221               
3222                      .eoi (>ff*256)                  ; EOR #%11111111    ; A is negative, so change the sign of A using two's
     **** ****     > EOI
0001 0F92 0200  12        li   rtmp,(>FF*256)
     0F94 FF00     
0002 0F96 2B40  14        xor  rtmp,ra
                   < elite.a99
3223                      .clc                            ; CLC               ; complement so that A is now positive and contains
     **** ****     > CLC
0001 0F98 0A16  14        sla  rzero,1
                   < elite.a99
3224                      .adi (>01*256)                  ; ADC #1            ; the absolute value of the roll rate, i.e. |JSTX|
     **** ****     > ADI
0001 0F9A 1701  10        jnc  !
0002 0F9C B347  14        ab   rone,ra
0003               !:
0004 0F9E 022D  14        ai   ra,(>01*256)
     0FA0 0100     
                   < elite.a99
3225               
3226               B01:
3227 0FA2 091D  14        srl  ra,1                       ; LSR A             ; Divide the (positive) roll rate in A by 4
3228 0FA4 091D  14        srl  ra,1                       ; LSR A
3229               
3230 0FA6 028D  14        ci   ra,>08*256                 ; CMP #8            ; If A >= 8, skip the following two instructions
     0FA8 0800     
3231 0FAA 1802  10        joc  B02                        ; BCS B02
3232               
3233 0FAC 091D  14        srl  ra,1                       ; LSR A             ; A < 8, so halve A again
3234               
3235                      .clc                            ; CLC               ; This instruction has no effect, as we only get here
     **** ****     > CLC
0001 0FAE 0A16  14        sla  rzero,1
                   < elite.a99
3236                                                                          ; if the C flag is clear (if it is set, we skip this
3237                                                                          ; instruction)
3238               B02:
3239 0FB0 D80D  22        movb ra,@ALP1                   ; STA ALP1          ; Store A in ALP1, so we now have:
     0FB2 0087     
3240                                                                          ;
3241                                                                          ; ALP1 = |JSTX| / 8    if |JSTX| < 32
3242                                                                          ;
3243                                                                          ; ALP1 = |JSTX| / 4    if |JSTX| >= 32
3244                                                                          ;
3245                                                                          ; This means that at lower roll rates, the roll angle is
3246                                                                          ; reduced closer to zero than at higher roll rates,
3247                                                                          ; which gives us finer control over the ship's roll at
3248                                                                          ; lower roll rates
3249                                                                          ;
3250                                                                          ; Because JSTX is in the range -127 to +127, ALP1 is
3251                                                                          ; in the range 0 to 31
3252               
3253 0FB4 F360  22        socb @ALP2,ra                   ; ORA ALP2          ; Store A in ALPHA, but with the sign set to ALP2 (so
     0FB6 0088     
3254 0FB8 D80D  22        movb ra,@ALPHA                  ; STA ALPHA         ; ALPHA has a different sign to the actual roll rate)
     0FBA 009E     
3255               
3256 0FBC D3A0  22        movb @JSTY,rx                   ; LDX JSTY          ; Set X to the current rate of pitch in JSTY
     0FBE 009D     
3257               
3258 0FC0 0200  12        li   rtmp,cntr_                 ; JSR cntr          ; Apply keyboard damping so the pitch rate in X creeps
     0FC2 47C8     
3259 0FC4 06A0  24        bl   @jsr                       ;
     0FC6 FE28     
3260                                                                          ; towards the centre by 1
3261               
3262 0FC8 D34E  14        movb rx,ra                      ; TXA               ; Set A and Y to the pitch rate but with the sign bit
3263                      .eoi (>80*256)                  ; EOR #%10000000    ; flipped
     **** ****     > EOI
0001 0FCA 0200  12        li   rtmp,(>80*256)
     0FCC 8000     
0002 0FCE 2B40  14        xor  rtmp,ra
                   < elite.a99
3264 0FD0 D3CD  14        movb ra,ry                      ; TAY
3265               
3266 0FD2 024D  14        andi ra,>80*256                 ; AND #%10000000    ; Extract the flipped sign of the pitch rate into A
     0FD4 8000     
3267               
3268 0FD6 D80E  22        movb rx,@JSTY                   ; STX JSTY          ; Update JSTY with the damped value that's still in X
     0FD8 009D     
3269               
3270 0FDA D80D  22        movb ra,@BET2+1                 ; STA BET2+1        ; Store the flipped sign of the pitch rate in BET2+1
     0FDC 008B     
3271               
3272                      .eoi (>80*256)                  ; EOR #%10000000    ; Extract the correct sign of the pitch rate and store
     **** ****     > EOI
0001 0FDE 0200  12        li   rtmp,(>80*256)
     0FE0 8000     
0002 0FE2 2B40  14        xor  rtmp,ra
                   < elite.a99
3273 0FE4 D80D  22        movb ra,@BET2                   ; STA BET2          ; it in BET2
     0FE6 008A     
3274               
3275 0FE8 D34F  14        movb ry,ra                      ; TYA               ; Set A to the pitch rate but with the sign bit flipped
3276               
3277 0FEA 1503  10        jgt  B03                        ; BPL B03           ; If the value of A is positive, skip the following
3278                                                                          ; instruction
3279               
3280                      .eoi (>ff*256)                  ; EOR #%11111111    ; A is negative, so flip the bits
     **** ****     > EOI
0001 0FEC 0200  12        li   rtmp,(>FF*256)
     0FEE FF00     
0002 0FF0 2B40  14        xor  rtmp,ra
                   < elite.a99
3281               
3282               B03:
3283                      .adi (>04*256)                  ; ADC #4            ; Add 4 to the (positive) pitch rate, so the maximum
     **** ****     > ADI
0001 0FF2 1701  10        jnc  !
0002 0FF4 B347  14        ab   rone,ra
0003               !:
0004 0FF6 022D  14        ai   ra,(>04*256)
     0FF8 0400     
                   < elite.a99
3284                                                                          ; value is now up to 131 (rather than 127)
3285               
3286 0FFA 091D  14        srl  ra,1                       ; LSR A             ; Divide the (positive) pitch rate in A by 16
3287 0FFC 091D  14        srl  ra,1                       ; LSR A
3288 0FFE 091D  14        srl  ra,1                       ; LSR A
3289 1000 091D  14        srl  ra,1                       ; LSR A
3290               
3291 1002 028D  14        ci   ra,>03*256                 ; CMP #3            ; If A >= 3, skip the following instruction
     1004 0300     
3292 1006 1801  10        joc  B04                        ; BCS B04
3293               
3294 1008 091D  14        srl  ra,1                       ; LSR A             ; A < 3, so halve A again
3295               
3296               B04:
3297 100A D80D  22        movb ra,@BET1                   ; STA BET1          ; Store A in BET1, so we now have:
     100C 002B     
3298                                                                          ;
3299                                                                          ; BET1 = |JSTY| / 32    if |JSTY| < 48
3300                                                                          ;
3301                                                                          ; BET1 = |JSTY| / 16    if |JSTY| >= 48
3302                                                                          ;
3303                                                                          ; This means that at lower pitch rates, the pitch angle
3304                                                                          ; is reduced closer to zero than at higher pitch rates,
3305                                                                          ; which gives us finer control over the ship's pitch at
3306                                                                          ; lower pitch rates
3307                                                                          ;
3308                                                                          ; Because JSTY is in the range -131 to +131, BET1 is in
3309                                                                          ; the range 0 to 8
3310               
3311 100E F360  22        socb @BET2,ra                   ; ORA BET2          ; Store A in BETA, but with the sign set to BET2 (so
     1010 008A     
3312 1012 D80D  22        movb ra,@BETA                   ; STA BETA          ; BETA has the same sign as the actual pitch rate)
     1014 002A     
3313               
3314               * ******************************************************************************
3315               *
3316               * Name: Main flight loop (Part 3 of 16)
3317               * Type: Subroutine
3318               * Category: Main loop
3319               * Summary: Scan for flight keys and process the results
3320               * Deep dive: Program flow of the main game loop
3321               * The key logger
3322               *
3323               * ------------------------------------------------------------------------------
3324               *
3325               * The main flight loop covers most of the flight-specific aspects of Elite. This
3326               * section covers the following:
3327               *
3328               * * Scan for flight keys and process the results
3329               *
3330               * Flight keys are logged in the key logger at location KY1 onwards, with a
3331               * non-zero value in the relevant location indicating a key press. See the deep
3332               * dive on "The key logger" for more details.
3333               *
3334               * The key presses that are processed are as follows:
3335               *
3336               * * Space and "?" to speed up and slow down
3337               * * "U", "T" and "M" to disarm, arm and fire missiles
3338               * * TAB to fire an energy bomb
3339               * * ESCAPE to launch an escape pod
3340               * * "J" to initiate an in-system jump
3341               * * "E" to deploy E.C.M. anti-missile countermeasures
3342               * * "C" to use the docking computer
3343               * * "A" to fire lasers
3344               *
3345               * ******************************************************************************
3346               
3347 1016 D360  22        movb @KY2,ra                    ; LDA KY2           ; If Space is being pressed, keep going, otherwise jump
     1018 0043     
3348 101A 1306  10        jeq  MA17                       ; BEQ MA17          ; down to MA17 to skip the following
3349               
3350 101C D360  22        movb @DELTA,ra                  ; LDA DELTA         ; The "go faster" key is being pressed, so first we
     101E 008C     
3351 1020 028D  14        ci   ra,>28*256                 ; CMP #40           ; fetch the current speed from DELTA into A, and if
     1022 2800     
3352 1024 1801  10        joc  MA17                       ; BCS MA17          ; A >= 40, we are already going at full pelt, so jump
3353                                                                          ; down to MA17 to skip the following
3354               
3355 1026 B347  14        ab   rone,ra                    ; INC DELTA         ; We can go a bit faster, so increment the speed in
3356                                                                          ; location DELTA
3357               
3358               MA17:
3359 1028 D360  22        movb @KY1,ra                    ; LDA KY1           ; If "?" is being pressed, keep going, otherwise jump
     102A 0042     
3360 102C 1303  10        jeq  MA4                        ; BEQ MA4           ; down to MA4 to skip the following
3361               
3362 102E 7347  14        sb   rone,ra                    ; DEC DELTA         ; The "slow down" key is being pressed, so we decrement
3363                                                                          ; the current ship speed in DELTA
3364               
3365 1030 1601  10        jne  MA4                        ; BNE MA4           ; If the speed is still greater than zero, jump to MA4
3366               
3367 1032 B347  14        ab   rone,ra                    ; INC DELTA         ; Otherwise we just braked a little too hard, so bump
3368                                                                          ; the speed back up to the minimum value of 1
3369               
3370               MA4:
3371 1034 D360  22        movb @KY15,ra                   ; LDA KY15          ; If "U" is being pressed and the number of missiles
     1036 004C     
3372                      .and @NOMSL                     ; AND NOMSL         ; in NOMSL is non-zero, keep going, otherwise jump down
     **** ****     > AND
0001 1038 D020  22        movb @NOMSL,rtmp
     103A 0333     
0002 103C 0540  10        inv  rtmp
0003 103E 5340  14        szcb rtmp,ra
                   < elite.a99
3373 1040 1310  10        jeq  MA20                       ; BEQ MA20          ; to MA20 to skip the following
3374               
3375 1042 020F  12        li   ry,>ee*256                 ; LDY #&EE          ; The "disarm missiles" key is being pressed, so call
     1044 EE00     
3376 1046 0200  12        li   rtmp,ABORT                 ; JSR ABORT         ; ABORT to disarm the missile and update the missile
     1048 B0FE     
3377 104A 06A0  24        bl   @jsr                       ;
     104C FE28     
3378                                                                          ; indicators on the dashboard to green/cyan (Y = &EE)
3379               
3380 104E 020D  12        li   ra,>28*256                 ; LDA #40           ; Call the NOISE routine with A = 40 to make a low,
     1050 2800     
3381 1052 0200  12        li   rtmp,NOISE                 ; JSR NOISE         ; long beep to indicate the missile is now disarmed
     1054 CC5C     
3382 1056 06A0  24        bl   @jsr                       ;
     1058 FE28     
3383               
3384               MA31:
3385 105A 020D  12        li   ra,>00*256                 ; LDA #0            ; Set MSAR to 0 to indicate that no missiles are
     105C 0000     
3386 105E D80D  22        movb ra,@MSAR                   ; STA MSAR          ; currently armed
     1060 0D5E     
3387               
3388               MA20:
3389 1062 D360  22        movb @MSTG,ra                   ; LDA MSTG          ; If MSTG is positive (i.e. it does not have bit 7 set),
     1064 0052     
3390 1066 150E  10        jgt  MA25                       ; BPL MA25          ; then it indicates we already have a missile locked on
3391                                                                          ; a target (in which case MSTG contains the ship number
3392                                                                          ; of the target), so jump to MA25 to skip targeting. Or
3393                                                                          ; to put it another way, if MSTG = &FF, which means
3394                                                                          ; there is no current target lock, keep going
3395               
3396 1068 D360  22        movb @KY14,ra                   ; LDA KY14          ; If "T" is being pressed, keep going, otherwise jump
     106A 004B     
3397 106C 130B  10        jeq  MA25                       ; BEQ MA25          ; down to MA25 to skip the following
3398               
3399 106E D3A0  22        movb @NOMSL,rx                  ; LDX NOMSL         ; If the number of missiles in NOMSL is zero, jump down
     1070 0333     
3400 1072 1308  10        jeq  MA25                       ; BEQ MA25          ; to MA25 to skip the following
3401               
3402 1074 D80D  22        movb ra,@MSAR                   ; STA MSAR          ; The "target missile" key is being pressed and we have
     1076 0D5E     
3403                                                                          ; at least one missile, so set MSAR = &FF to denote that
3404                                                                          ; our missile is currently armed (we know A has the
3405                                                                          ; value &FF, as we just loaded it from MSTG and checked
3406                                                                          ; that it was negative)
3407               
3408 1078 020F  12        li   ry,>e0*256                 ; LDY #&E0          ; Change the leftmost missile indicator to yellow/white
     107A E000     
3409 107C 0200  12        li   rtmp,MSBAR                 ; JSR MSBAR         ; on the missile bar (this call changes the leftmost
     107E B16A     
3410 1080 06A0  24        bl   @jsr                       ;
     1082 FE28     
3411                                                                          ; indicator because we set X to the number of missiles
3412                                                                          ; in NOMSL above, and the indicators are numbered from
3413                                                                          ; right to left, so X is the number of the leftmost
3414                                                                          ; indicator)
3415               
3416               MA25:
3417 1084 D360  22        movb @KY16,ra                   ; LDA KY16          ; If "M" is being pressed, keep going, otherwise jump
     1086 004D     
3418 1088 1307  10        jeq  MA24                       ; BEQ MA24          ; down to MA24 to skip the following
3419               
3420 108A D360  22        movb @MSTG,ra                   ; LDA MSTG          ; If MSTG = &FF then there is no target lock, so jump to
     108C 0052     
3421 108E 112D  10        jlt  MA64                       ; BMI MA64          ; MA64 to skip the following (also skipping the checks
3422                                                                          ; for TAB, ESCAPE, "J" and "E")
3423               
3424 1090 0200  12        li   rtmp,FRMIS                 ; JSR FRMIS         ; The "fire missile" key is being pressed and we have
     1092 3CCA     
3425 1094 06A0  24        bl   @jsr                       ;
     1096 FE28     
3426                                                                          ; a missile lock, so call the FRMIS routine to fire
3427                                                                          ; the missile
3428               
3429               MA24:
3430 1098 D360  22        movb @KY12,ra                   ; LDA KY12          ; If TAB is being pressed, keep going, otherwise jump
     109A 0049     
3431 109C 1307  10        jeq  MA76                       ; BEQ MA76          ; down to MA76 to skip the following
3432               
3433                      .asl @BOMB                      ; ASL BOMB          ; The "energy bomb" key is being pressed, so double
     **** ****     > ASL
0001 109E D020  22        movb @BOMB,rtmp
     10A0 032A     
0002 10A2 0240  14        andi rtmp,>ff00
     10A4 FF00     
0003 10A6 0A10  14        sla  rtmp,1
0004 10A8 D800  22        movb rtmp,@BOMB
     10AA 032A     
                   < elite.a99
3434                                                                          ; the value in BOMB. If we have an energy bomb fitted,
3435                                                                          ; BOMB will contain &7F (%01111111) before this shift
3436                                                                          ; and will contain &FE (%11111110) after the shift; if
3437                                                                          ; we don't have an energy bomb fitted, BOMB will still
3438                                                                          ; contain 0. The bomb explosion is dealt with in the
3439                                                                          ; MAL1 routine below - this just registers the fact that
3440                                                                          ; we've set the bomb ticking
3441               
3442               MA76:
3443 10AC D360  22        movb @KY13,ra                   ; LDA KY13          ; If ESCAPE is being pressed and we have an escape pod
     10AE 004A     
3444                      .and @ESCP                      ; AND ESCP          ; fitted, keep going, otherwise skip the next
     **** ****     > AND
0001 10B0 D020  22        movb @ESCP,rtmp
     10B2 032E     
0002 10B4 0540  10        inv  rtmp
0003 10B6 5340  14        szcb rtmp,ra
                   < elite.a99
3445 10B8 1302  10        jeq  B05                        ; BEQ B05           ; instruction
3446               
3447 10BA 0460  20        b    @ESCAPE                    ; JMP ESCAPE        ; The button is being pressed to launch an escape pod
     10BC 36BA     
3448                                                                          ; and we have an escape pod fitted, so jump to ESCAPE to
3449                                                                          ; launch it, and exit the main flight loop using a tail
3450                                                                          ; call
3451               
3452               B05:
3453 10BE D360  22        movb @KY18,ra                   ; LDA KY18          ; If "J" is being pressed, keep going, otherwise skip
     10C0 004F     
3454 10C2 1304  10        jeq  B06                        ; BEQ B06           ; the next instruction
3455               
3456 10C4 0200  12        li   rtmp,WARP                  ; JSR WARP          ; Call the WARP routine to do an in-system jump
     10C6 48EC     
3457 10C8 06A0  24        bl   @jsr                       ;
     10CA FE28     
3458               
3459               B06:
3460 10CC D360  22        movb @KY17,ra                   ; LDA KY17          ; If "E" is being pressed and we have an E.C.M. fitted,
     10CE 004E     
3461                      .and @ECM                       ; AND ECM           ; keep going, otherwise jump down to MA64 to skip the
     **** ****     > AND
0001 10D0 D020  22        movb @ECM,rtmp
     10D2 0328     
0002 10D4 0540  10        inv  rtmp
0003 10D6 5340  14        szcb rtmp,ra
                   < elite.a99
3462 10D8 1308  10        jeq  MA64                       ; BEQ MA64          ; following
3463               
3464 10DA D360  22        movb @ECMA,ra                   ; LDA ECMA          ; If ECMA is non-zero, that means an E.C.M. is already
     10DC 0030     
3465 10DE 1605  10        jne  MA64                       ; BNE MA64          ; operating and is counting down (this can be either
3466                                                                          ; our E.C.M. or an opponent's), so jump down to MA64 to
3467                                                                          ; skip the following (as we can't have two E.C.M.
3468                                                                          ; systems operating at the same time)
3469               
3470 10E0 7347  14        sb   rone,ra                    ; DEC ECMP          ; The E.C.M. button is being pressed and nobody else
3471                                                                          ; is operating their E.C.M., so decrease the value of
3472                                                                          ; ECMP to make it non-zero, to denote that our E.C.M.
3473                                                                          ; is now on
3474               
3475 10E2 0200  12        li   rtmp,ECBLB2                ; JSR ECBLB2        ; Call ECBLB2 to light up the E.C.M. indicator bulb on
     10E4 B11A     
3476 10E6 06A0  24        bl   @jsr                       ;
     10E8 FE28     
3477                                                                          ; the dashboard, set the E.C.M. countdown timer to 32,
3478                                                                          ; and start making the E.C.M. sound
3479               
3480               MA64:
3481 10EA D360  22        movb @KY19,ra                   ; LDA KY19          ; If "C" is being pressed, and we have a docking
     10EC 0050     
3482                      .and @DKCMP                     ; AND DKCMP         ; computer fitted, and we are inside the space station's
     **** ****     > AND
0001 10EE D020  22        movb @DKCMP,rtmp
     10F0 032C     
0002 10F2 0540  10        inv  rtmp
0003 10F4 5340  14        szcb rtmp,ra
                   < elite.a99
3483                      .and @SSPR                      ; AND SSPR          ; safe zone, keep going, otherwise jump down to MA68 to
     **** ****     > AND
0001 10F6 D020  22        movb @SSPR,rtmp
     10F8 0D55     
0002 10FA 0540  10        inv  rtmp
0003 10FC 5340  14        szcb rtmp,ra
                   < elite.a99
3484 10FE 1305  10        jeq  MA68                       ; BEQ MA68          ; skip the following
3485               
3486 1100 D360  22        movb @K.+NI.+32,ra              ; LDA K%+NI%+32     ; Fetch the AI counter (byte #32) of the second ship
     1102 0944     
3487 1104 1102  10        jlt  MA68                       ; BMI MA68          ; from the ship data workspace at K%, which is reserved
3488                                                                          ; for the sun or the space station (in this case it's
3489                                                                          ; the latter as we are in the safe zone). If byte #32 is
3490                                                                          ; negative, meaning the station is hostile, then jump
3491                                                                          ; down to MA68 to skip the following (so we can't use
3492                                                                          ; the docking computer to dock at a station that has
3493                                                                          ; turned against us)
3494               
3495 1106 0460  16        b    @GOIN                      ; JMP GOIN          ; The Docking Computer button has been pressed and
     1108 1312     
3496                                                                          ; we are allowed to dock at the station, so jump to
3497                                                                          ; GOIN to dock (or "go in"), and exit the main flight
3498                                                                          ; loop using a tail call
3499               
3500               MA68:
3501 110A 020D  12        li   ra,>00*256                 ; LDA #0            ; Set LAS = 0, to switch the laser off while we do the
     110C 0000     
3502 110E D80D  22        movb ra,@LAS                    ; STA LAS           ; following logic
     1110 0051     
3503               
3504 1112 D80D  22        movb ra,@DELT4                  ; STA DELT4         ; Take the 16-bit value (DELTA 0) - i.e. a two-byte
     1114 008D     
3505 1116 D360  22        movb @DELTA,ra                  ; LDA DELTA         ; number with DELTA as the high byte and 0 as the low
     1118 008C     
3506 111A 091D  14        srl  ra,1                       ; LSR A             ; byte - and divide it by 4, storing the 16-bit result
3507 111C 0204  12        li   rarg1,DELT4                ; ROR DELT4         ; in DELT4(1 0). This has the effect of storing the
     111E 008D     
3508 1120 06A0  24        bl   @ror                       ;
     1122 FE7A     
3509 1124 091D  14        srl  ra,1                       ; LSR A             ; current speed * 64 in the 16-bit location DELT4(1 0)
3510 1126 0204  12        li   rarg1,DELT4                ; ROR DELT4
     1128 008D     
3511 112A 06A0  24        bl   @ror                       ;
     112C FE7A     
3512 112E D80D  22        movb ra,@DELT4+1                ; STA DELT4+1
     1130 008E     
3513               
3514 1132 D360  22        movb @LASCT,ra                  ; LDA LASCT         ; If LASCT is zero, keep going, otherwise the laser is
     1134 0D60     
3515 1136 1628  10        jne  MA3                        ; BNE MA3           ; a pulse laser that is between pulses, so jump down to
3516                                                                          ; MA3 to skip the following
3517               
3518 1138 D360  22        movb @KY7,ra                    ; LDA KY7           ; If "A" is being pressed, keep going, otherwise jump
     113A 0048     
3519 113C 1325  10        jeq  MA3                        ; BEQ MA3           ; down to MA3 to skip the following
3520               
3521 113E D360  22        movb @GNTMP,ra                  ; LDA GNTMP         ; If the laser temperature >= 242 then the laser has
     1140 0D61     
3522 1142 028D  14        ci   ra,>f2*256                 ; CMP #242          ; overheated, so jump down to MA3 to skip the following
     1144 F200     
3523 1146 1820  10        joc  MA3                        ; BCS MA3
3524               
3525 1148 D3A0  22        movb @VIEW,rx                   ; LDX VIEW          ; If the current space view has a laser fitted (i.e. the
     114A 0D5F     
3526 114C D36E  26        movb @LASER(rx),ra              ; LDA LASER,X       ; laser power for this view is greater than zero), then
     114E 0310     
3527 1150 131B  10        jeq  MA3                        ; BEQ MA3           ; keep going, otherwise jump down to MA3 to skip the
3528                                                                          ; following
3529               
3530                                                                          ; If we get here, then the "fire" button is being
3531                                                                          ; pressed, our laser hasn't overheated and isn't already
3532                                                                          ; being fired, and we actually have a laser fitted to
3533                                                                          ; the current space view, so it's time to hit me with
3534                                                                          ; those laser beams
3535               
3536                      .pha                            ; PHA               ; Store the current view's laser power on the stack
     **** ****     > PHA
0001 1152 D68D  26        movb ra,*rsp
0002 1154 060A  10        dec  rsp
                   < elite.a99
3537               
3538 1156 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Set LAS and LAS2 to bits 0-6 of the laser power
     1158 7F00     
3539 115A D80D  22        movb ra,@LAS                    ; STA LAS
     115C 0051     
3540 115E D80D  22        movb ra,@LAS2                   ; STA LAS2
     1160 0D5D     
3541               
3542 1162 020D  12        li   ra,>00*256                 ; LDA #0            ; Call the NOISE routine with A = 0 to make the sound
     1164 0000     
3543 1166 0200  12        li   rtmp,NOISE                 ; JSR NOISE         ; of our laser firing
     1168 CC5C     
3544 116A 06A0  24        bl   @jsr                       ;
     116C FE28     
3545               
3546 116E 0200  12        li   rtmp,LASLI                 ; JSR LASLI         ; Call LASLI to draw the laser lines
     1170 498E     
3547 1172 06A0  24        bl   @jsr                       ;
     1174 FE28     
3548               
3549                      .pla                            ; PLA               ; Restore the current view's laser power into A
     **** ****     > PLA
0001 1176 058A  10        inc  rsp
0002 1178 D35A  22        movb *rsp,ra
                   < elite.a99
3550               
3551 117A 1502  10        jgt  ma1_                       ; BPL ma1           ; If the laser power has bit 7 set, then it's an "always
3552                                                                          ; on" laser rather than a pulsing laser, so keep going,
3553                                                                          ; otherwise jump down to ma1 to skip the following
3554                                                                          ; instruction
3555               
3556 117C 020D  12        li   ra,>00*256                 ; LDA #0            ; This is an "always on" laser (i.e. a beam laser,
     117E 0000     
3557                                                                          ; as this version of Elite doesn't have military
3558                                                                          ; lasers), so set A = 0, which will be stored in LASCT
3559                                                                          ; to denote that this is not a pulsing laser
3560               
3561               ma1_:
3562 1180 024D  14        andi ra,>fa*256                 ; AND #%11111010    ; LASCT will be set to 0 for beam lasers, and to the
     1182 FA00     
3563 1184 D80D  22        movb ra,@LASCT                  ; STA LASCT         ; laser power AND %11111010 for pulse lasers, which
     1186 0D60     
3564                                                                          ; comes to 10 (as pulse lasers have a power of 15). See
3565                                                                          ; MA23 below for more on laser pulsing and LASCT
3566               
3567               * ******************************************************************************
3568               *
3569               * Name: Main flight loop (Part 4 of 16)
3570               * Type: Subroutine
3571               * Category: Main loop
3572               * Summary: For each nearby ship: Copy the ship's data block from K% to the
3573               * zero-page workspace at INWK
3574               * Deep dive: Program flow of the main game loop
3575               * Ship data blocks
3576               *
3577               * ------------------------------------------------------------------------------
3578               *
3579               * The main flight loop covers most of the flight-specific aspects of Elite. This
3580               * section covers the following:
3581               *
3582               * * Start looping through all the ships in the local bubble, and for each
3583               * one:
3584               *
3585               * * Copy the ship's data block from K% to INWK
3586               *
3587               * * Set XX0 to point to the ship's blueprint (if this is a ship)
3588               *
3589               * ------------------------------------------------------------------------------
3590               *
3591               * Other entry points:
3592               *
3593               * MAL1                Marks the beginning of the ship analysis loop, so we
3594               * can jump back here from part 12 of the main flight loop
3595               * to work our way through each ship in the local bubble.
3596               * We also jump back here when a ship is removed from the
3597               * bubble, so we can continue processing from the next ship
3598               *
3599               * ******************************************************************************
3600               
3601               MA3:
3602 1188 020E  12        li   rx,>00*256                 ; LDX #0            ; We're about to work our way through all the ships in
     118A 0000     
3603                                                                          ; our local bubble of universe, so set a counter in X,
3604                                                                          ; starting from 0, to refer to each ship slot in turn
3605               
3606               MAL1:
3607 118C D80E  22        movb rx,@XSAV                   ; STX XSAV          ; Store the current slot number in XSAV
     118E 0093     
3608               
3609 1190 D36E  26        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the contents of this slot into A. If it is 0
     1192 0D40     
3610 1194 1602  10        jne  B07                        ; BNE B07           ; then this slot is empty and we have no more ships to
3611 1196 0460  16        b    @MA18                      ; JMP MA18          ; process, so jump to MA18 below, otherwise A contains
     1198 1532     
3612                                                                          ; the type of ship that's in this slot, so skip over the
3613                                                                          ; JMP MA18 instruction and keep going
3614               
3615               B07:
3616 119A D80D  22        movb ra,@TYPE                   ; STA TYPE          ; Store the ship type in TYPE
     119C 009B     
3617               
3618 119E 0200  12        li   rtmp,GINF                  ; JSR GINF          ; Call GINF to fetch the address of the ship data block
     11A0 AF58     
3619 11A2 06A0  24        bl   @jsr                       ;
     11A4 FE28     
3620                                                                          ; for the ship in slot X and store it in INF. The data
3621                                                                          ; block is in the K% workspace, which is where all the
3622                                                                          ; ship data blocks are stored
3623               
3624                                                                          ; Next we want to copy the ship data block from INF to
3625                                                                          ; the zero-page workspace at INWK, so we can process it
3626                                                                          ; more efficiently
3627               
3628 11A6 020F  12        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; There are NI% bytes in each ship data block (and in
     11A8 2300     
3629                                                                          ; the INWK workspace, so we set a counter in Y so we can
3630                                                                          ; loop through them
3631               
3632               MAL2:
3633                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Load the Y-th byte of INF and store it in the Y-th
     **** ****     > LD_IND_Y_IDX
0001 11AA D820  30        movb @INF,@rtmplb
     11AC 0020     
     11AE 8301     
0002 11B0 D020  22        movb @INF+1,rtmp
     11B2 0021     
0003 11B4 06CF  10        swpb ry
0004 11B6 A00F  14        a    ry,rtmp
0005 11B8 06CF  10        swpb ry
0006 11BA D350  22        movb *rtmp,RA
                   < elite.a99
3634 11BC DBCD  30        movb ra,@INWK(ry)               ; STA INWK,Y        ; byte of INWK
     11BE 0053     
3635               
3636 11C0 73C7  14        sb   rone,ry                    ; DEY               ; Decrement the loop counter
3637               
3638 11C2 15F3  10        jgt  MAL2                       ; BPL MAL2          ; Loop back for the next byte until we have copied the
3639                                                                          ; last byte from INF to INWK
3640               
3641 11C4 D360  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is negative then this indicates a
     11C6 009B     
3642 11C8 1121  10        jlt  MA21                       ; BMI MA21          ; planet or sun, so jump down to MA21, as the next bit
3643                                                                          ; sets up a pointer to the ship blueprint, and then
3644                                                                          ; checks for energy bomb damage, and neither of these
3645                                                                          ; apply to planets and suns
3646               
3647                      .asla                           ; ASL A             ; Set Y = ship type * 2
     **** ****     > ASLA
0001 11CA 024D  14        andi ra,>ff00
     11CC FF00     
0002 11CE 0A1D  14        sla  ra,1
                   < elite.a99
3648 11D0 D3CD  14        movb ra,ry                      ; TAY
3649               
3650 11D2 D36F  26        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; The ship blueprints at XX21 start with a lookup
     11D4 E95C     
3651 11D6 D80D  22        movb ra,@XX0                    ; STA XX0           ; table that points to the individual ship blueprints,
     11D8 001E     
3652                                                                          ; so this fetches the low byte of this particular ship
3653                                                                          ; type's blueprint and stores it in XX0
3654               
3655 11DA D36F  26        movb @XX21-1(ry),ra             ; LDA XX21-1,Y      ; Fetch the high byte of this particular ship type's
     11DC E95D     
3656 11DE D80D  22        movb ra,@XX0+1                  ; STA XX0+1         ; blueprint and store it in XX0+1
     11E0 001F     
3657               
3658               * ******************************************************************************
3659               *
3660               * Name: Main flight loop (Part 5 of 16)
3661               * Type: Subroutine
3662               * Category: Main loop
3663               * Summary: For each nearby ship: If an energy bomb has been set off,
3664               * potentially kill this ship
3665               * Deep dive: Program flow of the main game loop
3666               *
3667               * ------------------------------------------------------------------------------
3668               *
3669               * The main flight loop covers most of the flight-specific aspects of Elite. This
3670               * section covers the following:
3671               *
3672               * * Continue looping through all the ships in the local bubble, and for each
3673               * one:
3674               *
3675               * * If an energy bomb has been set off and this ship can be killed, kill it
3676               * and increase the kill tally
3677               *
3678               * ******************************************************************************
3679               
3680 11E2 D360  22        movb @BOMB,ra                   ; LDA BOMB          ; If we set off our energy bomb (see MA24 above), then
     11E4 032A     
3681 11E6 1512  10        jgt  MA21                       ; BPL MA21          ; BOMB is now negative, so this skips to MA21 if our
3682                                                                          ; energy bomb is not going off
3683               
3684 11E8 028F  14        ci   ry,(2*SST)*256             ; CPY #2*SST        ; If the ship in Y is the space station, jump to BA21
     11EA 1000     
3685 11EC 130F  10        jeq  MA21                       ; BEQ MA21          ; as energy bombs are useless against space stations
3686               
3687 11EE D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; If the ship we are checking has bit 5 set in its ship
     11F0 0072     
3688 11F2 024D  14        andi ra,>20*256                 ; AND #%00100000    ; byte #31, then it is already exploding, so jump to
     11F4 2000     
3689 11F6 160A  10        jne  MA21                       ; BNE MA21          ; BA21 as ships can't explode more than once
3690               
3691 11F8 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; The energy bomb is killing this ship, so set bit 7 of
     11FA 0072     
3692 11FC 026D  14        ori  ra,>80*256                 ; ORA #%10000000    ; the ship byte #31 to indicate that it has now been
     11FE 8000     
3693 1200 D80D  22        movb ra,@INWK+31                ; STA INWK+31       ; killed
     1202 0072     
3694               
3695 1204 0200  12        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     1206 CC0C     
3696 1208 06A0  24        bl   @jsr                       ;
     120A FE28     
3697                                                                          ; ship (so increase the kill tally, make an explosion
3698                                                                          ; sound and possibly display "RIGHT ON COMMANDER!")
3699               
3700               * ******************************************************************************
3701               *
3702               * Name: Main flight loop (Part 6 of 16)
3703               * Type: Subroutine
3704               * Category: Main loop
3705               * Summary: For each nearby ship: Move the ship in space and copy the updated
3706               * INWK data block back to K%
3707               * Deep dive: Program flow of the main game loop
3708               * Program flow of the ship-moving routine
3709               * Ship data blocks
3710               *
3711               * ------------------------------------------------------------------------------
3712               *
3713               * The main flight loop covers most of the flight-specific aspects of Elite. This
3714               * section covers the following:
3715               *
3716               * * Continue looping through all the ships in the local bubble, and for each
3717               * one:
3718               *
3719               * * Move the ship in space
3720               *
3721               * * Copy the updated ship's data block from INWK back to K%
3722               *
3723               * ******************************************************************************
3724               
3725               MA21:
3726 120C 0200  12        li   rtmp,MVEIT                 ; JSR MVEIT         ; Call MVEIT to move the ship we are processing in space
     120E 17FE     
3727 1210 06A0  24        bl   @jsr                       ;
     1212 FE28     
3728               
3729                                                                          ; Now that we are done processing this ship, we need to
3730                                                                          ; copy the ship data back from INWK to the correct place
3731                                                                          ; in the K% workspace. We already set INF in part 4 to
3732                                                                          ; point to the ship's data block in K%, so we can simply
3733                                                                          ; do the reverse of the copy we did before, this time
3734                                                                          ; copying from INWK to INF
3735               
3736 1214 020F  12        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; Set a counter in Y so we can loop through the NI%
     1216 2300     
3737                                                                          ; bytes in the ship data block
3738               
3739               MAL3:
3740 1218 D36F  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Load the Y-th byte of INWK and store it in the Y-th
     121A 0053     
3741                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; byte of INF
     **** ****     > ST_IND_Y_IDX
0001 121C D820  30        movb @INF,@rtmplb
     121E 0020     
     1220 8301     
0002 1222 D020  22        movb @INF+1,rtmp
     1224 0021     
0003 1226 06CF  10        swpb ry
0004 1228 A00F  14        a    ry,rtmp
0005 122A 06CF  10        swpb ry
0006 122C D40D  26        movb RA,*rtmp
                   < elite.a99
3742               
3743 122E 73C7  14        sb   rone,ry                    ; DEY               ; Decrement the loop counter
3744               
3745 1230 15F3  10        jgt  MAL3                       ; BPL MAL3          ; Loop back for the next byte, until we have copied the
3746                                                                          ; last byte from INWK back to INF
3747               
3748               * ******************************************************************************
3749               *
3750               * Name: Main flight loop (Part 7 of 16)
3751               * Type: Subroutine
3752               * Category: Main loop
3753               * Summary: For each nearby ship: Check whether we are docking, scooping or
3754               * colliding with it
3755               * Deep dive: Program flow of the main game loop
3756               *
3757               * ------------------------------------------------------------------------------
3758               *
3759               * The main flight loop covers most of the flight-specific aspects of Elite. This
3760               * section covers the following:
3761               *
3762               * * Continue looping through all the ships in the local bubble, and for each
3763               * one:
3764               *
3765               * * Check how close we are to this ship and work out if we are docking,
3766               * scooping or colliding with it
3767               *
3768               * ******************************************************************************
3769               
3770 1232 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the status of this ship from bits 5 (is ship
     1234 0072     
3771 1236 024D  14        andi ra,>a0*256                 ; AND #%10100000    ; exploding?) and bit 7 (has ship been killed?) from
     1238 A000     
3772                                                                          ; ship byte #31 into A
3773               
3774 123A 0200  12        li   rtmp,MAS4                  ; JSR MAS4          ; Or this value with x_hi, y_hi and z_hi
     123C C512     
3775 123E 06A0  24        bl   @jsr                       ;
     1240 FE28     
3776               
3777 1242 164C  10        jne  MA65                       ; BNE MA65          ; If this value is non-zero, then either the ship is
3778                                                                          ; far away (i.e. has a non-zero high byte in at least
3779                                                                          ; one of the three axes), or it is already exploding,
3780                                                                          ; or has been flagged as being killed - in which case
3781                                                                          ; jump to MA65 to skip the following, as we can't dock
3782                                                                          ; scoop or collide with it
3783               
3784 1244 D360  22        movb @INWK,ra                   ; LDA INWK          ; Set A = (x_lo OR y_lo OR z_lo), and if bit 7 of the
     1246 0053     
3785 1248 F360  22        socb @INWK+3,ra                 ; ORA INWK+3        ; result is set, the ship is still a fair distance
     124A 0056     
3786 124C F360  22        socb @INWK+6,ra                 ; ORA INWK+6        ; away (further than 127 in at least one axis), so jump
     124E 0059     
3787 1250 1145  10        jlt  MA65                       ; BMI MA65          ; to MA65 to skip the following, as it's too far away to
3788                                                                          ; dock, scoop or collide with
3789               
3790 1252 D3A0  22        movb @TYPE,rx                   ; LDX TYPE          ; If the current ship type is negative then it's either
     1254 009B     
3791 1256 1142  10        jlt  MA65                       ; BMI MA65          ; a planet or a sun, so jump down to MA65 to skip the
3792                                                                          ; following, as we can't dock with it or scoop it
3793               
3794 1258 028E  14        ci   rx,(SST)*256               ; CPX #SST          ; If this ship is the space station, jump to ISDK to
     125A 0800     
3795 125C 1341  10        jeq  ISDK                       ; BEQ ISDK          ; check whether we are docking with it
3796               
3797 125E 024D  14        andi ra,>c0*256                 ; AND #%11000000    ; If bit 6 of (x_lo OR y_lo OR z_lo) is set, then the
     1260 C000     
3798 1262 163C  10        jne  MA65                       ; BNE MA65          ; ship is still a reasonable distance away (further than
3799                                                                          ; 63 in at least one axis), so jump to MA65 to skip the
3800                                                                          ; following, as it's too far away to dock, scoop or
3801                                                                          ; collide with
3802               
3803 1264 028E  14        ci   rx,(MSL)*256               ; CPX #MSL          ; If this ship is a missile, jump down to MA65 to skip
     1266 0900     
3804 1268 1339  10        jeq  MA65                       ; BEQ MA65          ; the following, as we can't scoop or dock with a
3805                                                                          ; missile, and it has its own dedicated collision
3806                                                                          ; checks in the TACTICS routine
3807               
3808 126A 028E  14        ci   rx,(OIL)*256               ; CPX #OIL          ; If ship type >= OIL (i.e. it's a cargo canister,
     126C 0B00     
3809 126E 1802  10        joc  B08                        ; BCS B08           ; Thargon or escape pod), skip the JMP instruction and
3810 1270 0460  16        b    @MA58                      ; JMP MA58          ; continue on, otherwise jump to MA58 to process a
     1272 1370     
3811                                                                          ; potential collision
3812               
3813               B08:
3814 1274 D360  22        movb @BST,ra                    ; LDA BST           ; If we have fuel scoops fitted then BST will be &FF,
     1276 0329     
3815                                                                          ; otherwise it will be 0
3816               
3817                      .and @INWK+5                    ; AND INWK+5        ; Ship byte #5 contains the y_sign of this ship, so a
     **** ****     > AND
0001 1278 D020  22        movb @INWK+5,rtmp
     127A 0058     
0002 127C 0540  10        inv  rtmp
0003 127E 5340  14        szcb rtmp,ra
                   < elite.a99
3818                                                                          ; negative value here means the canister is below us,
3819                                                                          ; which means the result of the AND will be negative if
3820                                                                          ; the canister is below us and we have a fuel scoop
3821                                                                          ; fitted
3822               
3823 1280 1577  10        jgt  MA58                       ; BPL MA58          ; If the result is positive, then we either have no
3824                                                                          ; scoop or the canister is above us, and in both cases
3825                                                                          ; this means we can't scoop the item, so jump to MA58
3826                                                                          ; to process a collision
3827               
3828               * ******************************************************************************
3829               *
3830               * Name: Main flight loop (Part 8 of 16)
3831               * Type: Subroutine
3832               * Category: Main loop
3833               * Summary: For each nearby ship: Process us potentially scooping this item
3834               * Deep dive: Program flow of the main game loop
3835               *
3836               * ------------------------------------------------------------------------------
3837               *
3838               * The main flight loop covers most of the flight-specific aspects of Elite. This
3839               * section covers the following:
3840               *
3841               * * Continue looping through all the ships in the local bubble, and for each
3842               * one:
3843               *
3844               * * Process us potentially scooping this item
3845               *
3846               * ******************************************************************************
3847               
3848 1282 020D  12        li   ra,>03*256                 ; LDA #3            ; Set A to 3 to denote we may be scooping an escape pod
     1284 0300     
3849               
3850 1286 028E  14        ci   rx,(TGL)*256               ; CPX #TGL          ; If ship type < Thargon, i.e. it's a canister, jump
     1288 0C00     
3851 128A 1704  10        jnc  oily_                      ; BCC oily          ; to oily to randomly decide the canister's contents
3852               
3853 128C 1609  10        jne  slvy2_                     ; BNE slvy2         ; If ship type <> Thargon, i.e. it's an escape pod,
3854                                                                          ; jump to slvy2 with A set to 3, so we scoop up the
3855                                                                          ; escape pod as slaves
3856               
3857 128E 020D  12        li   ra,>10*256                 ; LDA #16           ; Otherwise this is a Thargon, so jump to slvy2 with
     1290 1000     
3858 1292 1606  10        jne  slvy2_                     ; BNE slvy2         ; A set to 16, so we scoop up the Thargon as alien items
3859                                                                          ; (this BNE is effectively a JMP as A will never be
3860                                                                          ; zero)
3861               
3862               oily_:
3863 1294 0200  12        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers and reduce A to a
     1296 C120     
3864 1298 06A0  24        bl   @jsr                       ;
     129A FE28     
3865 129C 024D  14        andi ra,>07*256                 ; AND #7            ; random number in the range 0-7
     129E 0700     
3866               
3867               slvy2_:
3868                                                                          ; By the time we get here, we are scooping, and A
3869                                                                          ; contains the type of item we are scooping (a random
3870                                                                          ; number 0-7 if we are scooping a cargo canister, 3 if
3871                                                                          ; we are scooping an escape pod, or 16 if we are
3872                                                                          ; scooping a Thargon). These numbers correspond to the
3873                                                                          ; relevant market items (see QQ23 for a list), so a
3874                                                                          ; cargo canister can contain anything from food to
3875                                                                          ; computers, while escape pods contain slaves, and
3876                                                                          ; Thargons become alien items when scooped
3877 12A0 D80D  22        movb ra,@QQ29                   ; STA QQ29          ; Call tnpr with the scooped cargo type stored in QQ29
     12A2 0F1B     
3878 12A4 020D  12        li   ra,>01*256                 ; LDA #1            ; and A set to 1, to work out whether we have room in
     12A6 0100     
3879 12A8 0200  12        li   rtmp,tnpr_                 ; JSR tnpr          ; the hold for the scooped item (A is preserved by this
     12AA 4EB4     
3880 12AC 06A0  24        bl   @jsr                       ;
     12AE FE28     
3881                                                                          ; call, and the C flag contains the result)
3882               
3883 12B0 020F  12        li   ry,>4e*256                 ; LDY #78           ; This instruction has no effect, so presumably it used
     12B2 4E00     
3884                                                                          ; to do something, but didn't get removed
3885               
3886 12B4 1845  10        joc  MA59                       ; BCS MA59          ; If the C flag is set then we have no room in the hold
3887                                                                          ; for the scooped item, so jump down to MA59 make a
3888                                                                          ; sound to indicate failure, before destroying the
3889                                                                          ; canister
3890               
3891 12B6 D3E0  22        movb @QQ29,ry                   ; LDY QQ29          ; Scooping was successful, so set Y to the type of
     12B8 0F1B     
3892                                                                          ; item we just scooped, which we stored in QQ29 above
3893               
3894                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; Add A (which we set to 1 above) to the number of items
     **** ****     > ADC
0001 12BA 1701  10        jnc  !
0002 12BC B347  14        ab   rone,ra
0003               !:
0004 12BE B36F  26        ab   @QQ20(RY),ra
     12C0 0317     
                   < elite.a99
3895 12C2 DBCD  30        movb ra,@QQ20(ry)               ; STA QQ20,Y        ; of type Y in the cargo hold, as we just successfully
     12C4 0317     
3896                                                                          ; scooped one canister of type Y
3897               
3898 12C6 D34F  14        movb ry,ra                      ; TYA               ; Print recursive token 48 + Y as an in-flight token,
3899                      .adi (>d0*256)                  ; ADC #208          ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
     **** ****     > ADI
0001 12C8 1701  10        jnc  !
0002 12CA B347  14        ab   rone,ra
0003               !:
0004 12CC 022D  14        ai   ra,(>D0*256)
     12CE D000     
                   < elite.a99
3900 12D0 0200  12        li   rtmp,MESS                  ; JSR MESS          ; ITEMS"), so this prints the scooped item's name
     12D2 CF0E     
3901 12D4 06A0  24        bl   @jsr                       ;
     12D6 FE28     
3902               
3903 12D8 0460  16        b    @MA60                      ; JMP MA60          ; We are done scooping, so jump down to MA60 to set the
     12DA 1348     
3904                                                                          ; kill flag on the canister, as it no longer exists in
3905                                                                          ; the local bubble
3906               
3907               MA65:
3908 12DC 0460  16        b    @MA26                      ; JMP MA26          ; If we get here, then the ship we are processing was
     12DE 13A2     
3909                                                                          ; too far away to be scooped, docked or collided with,
3910                                                                          ; so jump to MA26 to skip over the collision routines
3911                                                                          ; and move on to missile targeting
3912               
3913               * ******************************************************************************
3914               *
3915               * Name: Main flight loop (Part 9 of 16)
3916               * Type: Subroutine
3917               * Category: Main loop
3918               * Summary: For each nearby ship: If it is a space station, check whether we
3919               * are successfully docking with it
3920               * Deep dive: Program flow of the main game loop
3921               * Docking checks
3922               *
3923               * ------------------------------------------------------------------------------
3924               *
3925               * The main flight loop covers most of the flight-specific aspects of Elite. This
3926               * section covers the following:
3927               *
3928               * * Process docking with a space station
3929               *
3930               * For details on the various docking checks in this routine, see the deep dive
3931               * on "Docking checks".
3932               *
3933               * ------------------------------------------------------------------------------
3934               *
3935               * Other entry points:
3936               *
3937               * GOIN                We jump here from part 3 of the main flight loop if the
3938               * docking computer is activated by pressing "C"
3939               *
3940               * ******************************************************************************
3941               
3942               ISDK:
3943 12E0 D360  22        movb @K.+NI.+32,ra              ; LDA K%+NI%+32     ; 1. Fetch the AI counter (byte #32) of the second ship
     12E2 0944     
3944 12E4 1126  10        jlt  MA62                       ; BMI MA62          ; in the ship data workspace at K%, which is reserved
3945                                                                          ; for the sun or the space station (in this case it's
3946                                                                          ; the latter), and if it's negative, i.e. bit 7 is set,
3947                                                                          ; meaning the station is hostile, jump down to MA62 to
3948                                                                          ; fail docking (so trying to dock at a station that we
3949                                                                          ; have annoyed does not end well)
3950               
3951 12E6 D360  22        movb @INWK+14,ra                ; LDA INWK+14       ; 2. If nosev_z_hi < 214, jump down to MA62 to fail
     12E8 0061     
3952 12EA 028D  14        ci   ra,>d6*256                 ; CMP #214          ; docking, as the angle of approach is greater than 26
     12EC D600     
3953 12EE 1721  10        jnc  MA62                       ; BCC MA62          ; degrees
3954               
3955 12F0 0200  12        li   rtmp,SPS4                  ; JSR SPS4          ; Call SPS4 to get the vector to the space station
     12F2 AD98     
3956 12F4 06A0  24        bl   @jsr                       ;
     12F6 FE28     
3957                                                                          ; into XX15
3958               
3959 12F8 D360  22        movb @XX15+2,ra                 ; LDA XX15+2        ; 3. Check the sign of the z-axis (bit 7 of XX15+2) and
     12FA 0033     
3960 12FC 111A  10        jlt  MA62                       ; BMI MA62          ; if it is negative, we are facing away from the
3961                                                                          ; station, so jump to MA62 to fail docking
3962               
3963 12FE 028D  14        ci   ra,>59*256                 ; CMP #89           ; 4. If z-axis < 89, jump to MA62 to fail docking, as
     1300 5900     
3964 1302 1717  10        jnc  MA62                       ; BCC MA62          ; we are not in the 22.0 degree safe cone of approach
3965               
3966 1304 D360  22        movb @INWK+16,ra                ; LDA INWK+16       ; 5. If |roofv_x_hi| < 80, jump to MA62 to fail docking,
     1306 0063     
3967 1308 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; as the slot is more than 36.6 degrees from horizontal
     130A 7F00     
3968 130C 028D  14        ci   ra,>50*256                 ; CMP #80
     130E 5000     
3969 1310 1710  10        jnc  MA62                       ; BCC MA62
3970               
3971               GOIN:
3972                                                                          ; If we arrive here, either the docking computer has
3973                                                                          ; been activated, or we just docked successfully
3974 1312 020D  12        li   ra,>00*256                 ; LDA #0            ; Set the on-screen hyperspace counter to 0
     1314 0000     
3975 1316 D80D  22        movb ra,@QQ22+1                 ; STA QQ22+1
     1318 002F     
3976               
3977 131A 020D  12        li   ra,>08*256                 ; LDA #8            ; This instruction has no effect, so presumably it used
     131C 0800     
3978                                                                          ; to do something, and didn't get removed
3979               
3980 131E 0200  12        li   rtmp,LAUN                  ; JSR LAUN          ; Show the space station launch tunnel
     1320 3F16     
3981 1322 06A0  24        bl   @jsr                       ;
     1324 FE28     
3982               
3983 1326 0200  12        li   rtmp,RES4                  ; JSR RES4          ; Reset the shields and energy banks, stardust and INWK
     1328 BFC6     
3984 132A 06A0  24        bl   @jsr                       ;
     132C FE28     
3985                                                                          ; workspace
3986               
3987 132E 0460  20        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     1330 C704     
3988                                                                          ; screen)
3989               
3990               MA62:
3991                                                                          ; If we arrive here, docking has just failed
3992 1332 D360  22        movb @DELTA,ra                  ; LDA DELTA         ; If the ship's speed is < 5, jump to MA67 to register
     1334 008C     
3993 1336 028D  14        ci   ra,>05*256                 ; CMP #5            ; some damage, but not a huge amount
     1338 0500     
3994 133A 1713  10        jnc  MA67                       ; BCC MA67
3995               
3996 133C 0460  20        b    @DEATH                     ; JMP DEATH         ; Otherwise we have just crashed into the station, so
     133E C522     
3997                                                                          ; process our death
3998               
3999               * ******************************************************************************
4000               *
4001               * Name: Main flight loop (Part 10 of 16)
4002               * Type: Subroutine
4003               * Category: Main loop
4004               * Summary: For each nearby ship: Remove if scooped, or process collisions
4005               * Deep dive: Program flow of the main game loop
4006               *
4007               * ------------------------------------------------------------------------------
4008               *
4009               * The main flight loop covers most of the flight-specific aspects of Elite. This
4010               * section covers the following:
4011               *
4012               * * Continue looping through all the ships in the local bubble, and for each
4013               * one:
4014               *
4015               * * Remove scooped item after both successful and failed scooping attempts
4016               *
4017               * * Process collisions
4018               *
4019               * ******************************************************************************
4020               
4021               MA59:
4022                                                                          ; If we get here then scooping failed
4023 1340 0200  12        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of the cargo canister being destroyed
     1342 CBDA     
4024 1344 06A0  24        bl   @jsr                       ;
     1346 FE28     
4025                                                                          ; and fall through into MA60 to remove the canister
4026                                                                          ; from our local bubble
4027               
4028               MA60:
4029                                                                          ; If we get here then scooping was successful
4030                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the scooped or destroyed item, to denote
     **** ****     > ASL
0001 1348 D020  22        movb @INWK+31,rtmp
     134A 0072     
0002 134C 0240  14        andi rtmp,>ff00
     134E FF00     
0003 1350 0A10  14        sla  rtmp,1
0004 1352 D800  22        movb rtmp,@INWK+31
     1354 0072     
                   < elite.a99
4031                      .sec                            ; SEC               ; that it has been killed and should be removed from
     **** ****     > SEC
0001 1356 0A18  14        sla  rmone,1
                   < elite.a99
4032 1358 0204  12        li   rarg1,INWK+31              ; ROR INWK+31       ; the local bubble
     135A 0072     
4033 135C 06A0  24        bl   @ror                       ;
     135E FE7A     
4034               
4035               MA61:
4036 1360 1620  10        jne  MA26                       ; BNE MA26          ; Jump to MA26 to skip over the collision routines and
4037                                                                          ; to move on to missile targeting (this BNE is
4038                                                                          ; effectively a JMP as A will never be zero)
4039               
4040               MA67:
4041                                                                          ; If we get here then we have collided with something,
4042                                                                          ; but not fatally
4043 1362 020D  12        li   ra,>01*256                 ; LDA #1            ; Set the speed in DELTA to 1 (i.e. a sudden stop)
     1364 0100     
4044 1366 D80D  22        movb ra,@DELTA                  ; STA DELTA
     1368 008C     
4045               
4046 136A 020D  12        li   ra,>05*256                 ; LDA #5            ; Set the amount of damage in A to 5 (a small dent) and
     136C 0500     
4047 136E 1611  10        jne  MA63                       ; BNE MA63          ; jump down to MA63 to process the damage (this BNE is
4048                                                                          ; effectively a JMP as A will never be zero)
4049               
4050               MA58:
4051                                                                          ; If we get here, we have collided with something in a
4052                                                                          ; potentially fatal way
4053                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the ship we just collided with, to
     **** ****     > ASL
0001 1370 D020  22        movb @INWK+31,rtmp
     1372 0072     
0002 1374 0240  14        andi rtmp,>ff00
     1376 FF00     
0003 1378 0A10  14        sla  rtmp,1
0004 137A D800  22        movb rtmp,@INWK+31
     137C 0072     
                   < elite.a99
4054                      .sec                            ; SEC               ; denote that it has been killed and should be removed
     **** ****     > SEC
0001 137E 0A18  14        sla  rmone,1
                   < elite.a99
4055 1380 0204  12        li   rarg1,INWK+31              ; ROR INWK+31       ; from the local bubble
     1382 0072     
4056 1384 06A0  24        bl   @ror                       ;
     1386 FE7A     
4057               
4058 1388 D360  22        movb @INWK+35,ra                ; LDA INWK+35       ; Load A with the energy level of the ship we just hit
     138A 0076     
4059               
4060                      .sec                            ; SEC               ; Set the amount of damage in A to 128 + A / 2, so
     **** ****     > SEC
0001 138C 0A18  14        sla  rmone,1
                   < elite.a99
4061 138E 06A0  24        bl   @rora                      ; ROR A             ; this is quite a big dent, and colliding with higher
     1390 FE62     
4062                                                                          ; energy ships will cause more damage
4063               
4064               MA63:
4065 1392 0200  12        li   rtmp,OOPS                  ; JSR OOPS          ; The amount of damage is in A, so call OOPS to reduce
     1394 AEBE     
4066 1396 06A0  24        bl   @jsr                       ;
     1398 FE28     
4067                                                                          ; our shields, and if the shields are gone, there's a
4068                                                                          ; chance of cargo loss or even death
4069               
4070 139A 0200  12        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of colliding with the other ship and
     139C CBDA     
4071 139E 06A0  24        bl   @jsr                       ;
     13A0 FE28     
4072                                                                          ; fall through into MA26 to try targeting a missile
4073               
4074               * ******************************************************************************
4075               *
4076               * Name: Main flight loop (Part 11 of 16)
4077               * Type: Subroutine
4078               * Category: Main loop
4079               * Summary: For each nearby ship: Process missile lock and firing our laser
4080               * Deep dive: Program flow of the main game loop
4081               * Flipping axes between space views
4082               *
4083               * ------------------------------------------------------------------------------
4084               *
4085               * The main flight loop covers most of the flight-specific aspects of Elite. This
4086               * section covers the following:
4087               *
4088               * * Continue looping through all the ships in the local bubble, and for each
4089               * one:
4090               *
4091               * * If this is not the front space view, flip the axes of the ship's
4092               * coordinates in INWK
4093               *
4094               * * Process missile lock
4095               *
4096               * * Process our laser firing
4097               *
4098               * ******************************************************************************
4099               
4100               MA26:
4101 13A2 D360  22        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to MA15 to skip
     13A4 0096     
4102 13A6 1664  10        jne  MA15                       ; BNE MA15          ; missile and laser locking
4103               
4104 13A8 0200  12        li   rtmp,PLUT                  ; JSR PLUT          ; Call PLUT to update the geometric axes in INWK to
     13AA 4A38     
4105 13AC 06A0  24        bl   @jsr                       ;
     13AE FE28     
4106                                                                          ; match the view (front, rear, left, right)
4107               
4108 13B0 0200  12        li   rtmp,HITCH                 ; JSR HITCH         ; Call HITCH to see if this ship is in the crosshairs,
     13B2 3BD6     
4109 13B4 06A0  24        bl   @jsr                       ;
     13B6 FE28     
4110 13B8 1757  10        jnc  MA8                        ; BCC MA8           ; in which case the C flag will be set (so if there is
4111                                                                          ; no missile or laser lock, we jump to MA8 to skip the
4112                                                                          ; following)
4113               
4114 13BA D360  22        movb @MSAR,ra                   ; LDA MSAR          ; We have missile lock, so check whether the leftmost
     13BC 0D5E     
4115 13BE 130C  10        jeq  MA47                       ; BEQ MA47          ; missile is currently armed, and if not, jump to MA47
4116                                                                          ; to process laser fire, as we can't lock an unarmed
4117                                                                          ; missile
4118               
4119 13C0 0200  12        li   rtmp,BEEP                  ; JSR BEEP          ; We have missile lock and an armed missile, so call
     13C2 CC58     
4120 13C4 06A0  24        bl   @jsr                       ;
     13C6 FE28     
4121                                                                          ; the BEEP subroutine to make a short, high beep
4122               
4123 13C8 D3A0  22        movb @XSAV,rx                   ; LDX XSAV          ; Call ABORT2 to store the details of this missile
     13CA 0093     
4124 13CC 020F  12        li   ry,>0e*256                 ; LDY #&0E          ; lock, with the targeted ship's slot number in X
     13CE 0E00     
4125 13D0 0200  12        li   rtmp,ABORT2                ; JSR ABORT2        ; (which we stored in XSAV at the start of this ship's
     13D2 B102     
4126 13D4 06A0  24        bl   @jsr                       ;
     13D6 FE28     
4127                                                                          ; loop at MAL1), and set the colour of the missile
4128                                                                          ; indicator to the colour in Y (red = &0E)
4129               
4130               MA47:
4131                                                                          ; If we get here then the ship is in our sights, but
4132                                                                          ; we didn't lock a missile, so let's see if we're
4133                                                                          ; firing the laser
4134 13D8 D360  22        movb @LAS,ra                    ; LDA LAS           ; If we are firing the laser then LAS will contain the
     13DA 0051     
4135 13DC 1345  10        jeq  MA8                        ; BEQ MA8           ; laser power (which we set in MA68 above), so if this
4136                                                                          ; is zero, jump down to MA8 to skip the following
4137               
4138 13DE 020E  12        li   rx,>0f*256                 ; LDX #15           ; We are firing our laser and the ship in INWK is in
     13E0 0F00     
4139 13E2 0200  12        li   rtmp,EXNO                  ; JSR EXNO          ; the crosshairs, so call EXNO to make the sound of
     13E4 CC22     
4140 13E6 06A0  24        bl   @jsr                       ;
     13E8 FE28     
4141                                                                          ; us making a laser strike on another ship
4142               
4143 13EA D360  22        movb @INWK+35,ra                ; LDA INWK+35       ; Fetch the hit ship's energy from byte #35 and subtract
     13EC 0076     
4144                      .sec                            ; SEC               ; our current laser power, and if the result is greater
     **** ****     > SEC
0001 13EE 0A18  14        sla  rmone,1
                   < elite.a99
4145                      .sbc @LAS,ra                    ; SBC LAS           ; than zero, the other ship has survived the hit, so
     **** ****     > SBC
0001 13F0 1801  10        joc  !
0002 13F2 7347  14        sb   rone,ra
0003               !:
0004 13F4 7360  22        sb   @LAS,ra
     13F6 0051     
                   < elite.a99
4146 13F8 182F  10        joc  MA14                       ; BCS MA14          ; jump down to MA14 to make it angry
4147               
4148 13FA D360  22        movb @TYPE,ra                   ; LDA TYPE          ; Did we just hit the space station? If so, jump to
     13FC 009B     
4149 13FE 028D  14        ci   ra,(SST)*256               ; CMP #SST          ; MA14+2 to make the station hostile, skipping the
     1400 0800     
4150 1402 132B  10        jeq  MA14+2                     ; BEQ MA14+2        ; following as we can't destroy a space station
4151               
4152 1404 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 7 of the enemy ship's byte #31, to indicate
     1406 0072     
4153 1408 026D  14        ori  ra,>80*256                 ; ORA #%10000000    ; that it has been killed
     140A 8000     
4154 140C D80D  22        movb ra,@INWK+31                ; STA INWK+31
     140E 0072     
4155               
4156 1410 182B  10        joc  MA8                        ; BCS MA8           ; If the enemy ship type is >= SST (i.e. missile,
4157                                                                          ; asteroid, canister, Thargon or escape pod) then
4158                                                                          ; jump down to MA8
4159               
4160 1412 0200  12        li   rtmp,DORND                 ; JSR DORND         ; Fetch a random number, and jump to oh if it is
     1414 C120     
4161 1416 06A0  24        bl   @jsr                       ;
     1418 FE28     
4162 141A 151A  10        jgt  oh_                        ; BPL oh            ; positive (50% chance)
4163               
4164 141C 020F  12        li   ry,>00*256                 ; LDY #0            ; Fetch the first byte of the hit ship's blueprint,
     141E 0000     
4165                      .and_ind_y_idx @XX0,ra          ; AND (XX0),Y       ; which determines the maximum number of bits of
     **** ****     > AND_IND_Y_IDX
0001 1420 D820  30        movb @XX0,@rtmplb
     1422 001E     
     1424 8301     
0002 1426 D020  22        movb @XX0+1,rtmp
     1428 001F     
0003 142A 06CF  10        swpb ry
0004 142C A00F  14        a    ry,rtmp
0005 142E 06CF  10        swpb ry
0006 1430 D010  22        movb *rtmp,rtmp
0007 1432 0540  10        inv  rtmp
0008 1434 5340  14        szcb rtmp,RA
                   < elite.a99
4166                                                                          ; debris shown when the ship is destroyed, and AND
4167                                                                          ; with the random number we just fetched
4168               
4169 1436 D80D  22        movb ra,@CNT                    ; STA CNT           ; Store the result in CNT, so CNT contains a random
     1438 00A4     
4170                                                                          ; number between 0 and the maximum number of bits of
4171                                                                          ; debris that this ship will release when destroyed
4172               
4173               um_:
4174 143A 130A  10        jeq  oh_                        ; BEQ oh            ; We're going to go round a loop using CNT as a counter
4175                                                                          ; so this checks whether the counter is zero and jumps
4176                                                                          ; to oh when it gets there (which might be straight
4177                                                                          ; away)
4178               
4179 143C 020E  12        li   rx,(OIL)*256               ; LDX #OIL          ; Call SFS1 to spawn a cargo canister from the now
     143E 0B00     
4180 1440 020D  12        li   ra,>00*256                 ; LDA #0            ; deceased parent ship, giving the spawned canister an
     1442 0000     
4181 1444 0200  12        li   rtmp,SFS1                  ; JSR SFS1          ; AI flag of 0 (no AI, no E.C.M., non-hostile)
     1446 3DB2     
4182 1448 06A0  24        bl   @jsr                       ;
     144A FE28     
4183               
4184 144C 7347  14        sb   rone,ra                    ; DEC CNT           ; Decrease the loop counter
4185               
4186 144E 15F5  10        jgt  um_                        ; BPL um            ; Jump back up to um (this BPL is effectively a JMP as
4187                                                                          ; CNT will never be negative)
4188               
4189               oh_:
4190 1450 0200  12        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     1452 CC0C     
4191 1454 06A0  24        bl   @jsr                       ;
     1456 FE28     
4192                                                                          ; ship (so increase the kill tally, make an explosion
4193                                                                          ; sound and so on)
4194               
4195               MA14:
4196 1458 D80D  22        movb ra,@INWK+35                ; STA INWK+35       ; Store the hit ship's updated energy in ship byte #35
     145A 0076     
4197               
4198 145C D360  22        movb @TYPE,ra                   ; LDA TYPE          ; Call ANGRY to make this ship hostile, now that we
     145E 009B     
4199 1460 0200  12        li   rtmp,ANGRY                 ; JSR ANGRY         ; have hit it
     1462 3D06     
4200 1464 06A0  24        bl   @jsr                       ;
     1466 FE28     
4201               
4202               * ******************************************************************************
4203               *
4204               * Name: Main flight loop (Part 12 of 16)
4205               * Type: Subroutine
4206               * Category: Main loop
4207               * Summary: For each nearby ship: Draw the ship, remove if killed, loop back
4208               * Deep dive: Program flow of the main game loop
4209               * Drawing ships
4210               *
4211               * ------------------------------------------------------------------------------
4212               *
4213               * The main flight loop covers most of the flight-specific aspects of Elite. This
4214               * section covers the following:
4215               *
4216               * * Continue looping through all the ships in the local bubble, and for each
4217               * one:
4218               *
4219               * * Draw the ship
4220               *
4221               * * Process removal of killed ships
4222               *
4223               * * Loop back up to MAL1 to move onto the next ship in the local bubble
4224               *
4225               * ******************************************************************************
4226               
4227               MA8:
4228 1468 0200  12        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to draw the ship we're processing on-screen
     146A D574     
4229 146C 06A0  24        bl   @jsr                       ;
     146E FE28     
4230               
4231               MA15:
4232 1470 020F  12        li   ry,>23*256                 ; LDY #35           ; Fetch the ship's energy from byte #35 and copy it to
     1472 2300     
4233 1474 D360  22        movb @INWK+35,ra                ; LDA INWK+35       ; byte #35 in INF (so the ship's data in K% gets
     1476 0076     
4234                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; updated)
     **** ****     > ST_IND_Y_IDX
0001 1478 D820  30        movb @INF,@rtmplb
     147A 0020     
     147C 8301     
0002 147E D020  22        movb @INF+1,rtmp
     1480 0021     
0003 1482 06CF  10        swpb ry
0004 1484 A00F  14        a    ry,rtmp
0005 1486 06CF  10        swpb ry
0006 1488 D40D  26        movb RA,*rtmp
                   < elite.a99
4235               
4236 148A D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; If bit 7 of the ship's byte #31 is clear, then the
     148C 0072     
4237 148E 1537  10        jgt  MAC1                       ; BPL MAC1          ; ship hasn't been killed by energy bomb, collision or
4238                                                                          ; laser fire, so jump to MAC1 to skip the following
4239               
4240 1490 024D  14        andi ra,>20*256                 ; AND #%00100000    ; If bit 5 of the ship's byte #31 is clear then the
     1492 2000     
4241 1494 1334  10        jeq  NBOUN                      ; BEQ NBOUN         ; ship is no longer exploding, so jump to NBOUN to skip
4242                                                                          ; the following
4243               
4244 1496 D360  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship we just destroyed was a cop, keep going,
     1498 009B     
4245 149A 028D  14        ci   ra,(COPS)*256              ; CMP #COPS         ; otherwise jump to q2 to skip the following
     149C 0200     
4246 149E 1606  10        jne  q2_                        ; BNE q2
4247               
4248 14A0 D360  22        movb @FIST,ra                   ; LDA FIST          ; We shot the sheriff, so update our FIST flag
     14A2 0334     
4249 14A4 026D  14        ori  ra,>40*256                 ; ORA #64           ; ("fugitive/innocent status") to at least 64, which
     14A6 4000     
4250 14A8 D80D  22        movb ra,@FIST                   ; STA FIST          ; will instantly make us a fugitive
     14AA 0334     
4251               
4252               q2_:
4253 14AC D360  22        movb @DLY,ra                    ; LDA DLY           ; If we already have an in-flight message on-screen (in
     14AE 0D64     
4254 14B0 F360  22        socb @MJ,ra                     ; ORA MJ            ; which case DLY > 0), or we are in witchspace (in
     14B2 0D5C     
4255 14B4 1622  10        jne  KS1S                       ; BNE KS1S          ; which case MJ > 0), jump to KS1S to skip showing an
4256                                                                          ; on-screen bounty for this kill
4257               
4258 14B6 020F  12        li   ry,>0a*256                 ; LDY #10           ; Fetch byte #10 of the ship's blueprint, which is the
     14B8 0A00     
4259                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; low byte of the bounty awarded when this ship is
     **** ****     > LD_IND_Y_IDX
0001 14BA D820  30        movb @XX0,@rtmplb
     14BC 001E     
     14BE 8301     
0002 14C0 D020  22        movb @XX0+1,rtmp
     14C2 001F     
0003 14C4 06CF  10        swpb ry
0004 14C6 A00F  14        a    ry,rtmp
0005 14C8 06CF  10        swpb ry
0006 14CA D350  22        movb *rtmp,RA
                   < elite.a99
4260 14CC 1316  10        jeq  KS1S                       ; BEQ KS1S          ; killed (in Cr * 10), and if it's zero jump to KS1S as
4261                                                                          ; there is no on-screen bounty to display
4262               
4263 14CE D38D  14        movb ra,rx                      ; TAX               ; Put the low byte of the bounty into X
4264               
4265 14D0 B3C7  14        ab   rone,ry                    ; INY               ; Fetch byte #11 of the ship's blueprint, which is the
4266                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; high byte of the bounty awarded (in Cr * 10), and put
     **** ****     > LD_IND_Y_IDX
0001 14D2 D820  30        movb @XX0,@rtmplb
     14D4 001E     
     14D6 8301     
0002 14D8 D020  22        movb @XX0+1,rtmp
     14DA 001F     
0003 14DC 06CF  10        swpb ry
0004 14DE A00F  14        a    ry,rtmp
0005 14E0 06CF  10        swpb ry
0006 14E2 D350  22        movb *rtmp,RA
                   < elite.a99
4267 14E4 D3CD  14        movb ra,ry                      ; TAY               ; it into Y
4268               
4269 14E6 0200  12        li   rtmp,MCASH                 ; JSR MCASH         ; Call MCASH to add (Y X) to the cash pot
     14E8 A1BE     
4270 14EA 06A0  24        bl   @jsr                       ;
     14EC FE28     
4271               
4272 14EE 020D  12        li   ra,>00*256                 ; LDA #0            ; Print control code 0 (current cash, right-aligned to
     14F0 0000     
4273 14F2 0200  12        li   rtmp,MESS                  ; JSR MESS          ; width 9, then " CR", newline) as an in-flight message
     14F4 CF0E     
4274 14F6 06A0  24        bl   @jsr                       ;
     14F8 FE28     
4275               
4276               KS1S:
4277 14FA 0460  20        b    @KS1                       ; JMP KS1           ; Process the killing of this ship (which removes this
     14FC BCB4     
4278                                                                          ; ship from its slot and shuffles all the other ships
4279                                                                          ; down to close up the gap)
4280               
4281               NBOUN:
4282                      equ  $
4283               MAC1:
4284 14FE D360  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship we are processing is a planet or sun,
     1500 009B     
4285 1502 1105  10        jlt  MA27                       ; BMI MA27          ; jump to MA27 to skip the following two instructions
4286               
4287 1504 0200  12        li   rtmp,FAROF                 ; JSR FAROF         ; If the ship we are processing is a long way away (its
     1506 C4FA     
4288 1508 06A0  24        bl   @jsr                       ;
     150A FE28     
4289 150C 17F6  10        jnc  KS1S                       ; BCC KS1S          ; distance in any one direction is > 224, jump to KS1S
4290                                                                          ; to remove the ship from our local bubble, as it's just
4291                                                                          ; left the building
4292               
4293               MA27:
4294 150E 020F  12        li   ry,>1f*256                 ; LDY #31           ; Fetch the ship's explosion/killed state from byte #31
     1510 1F00     
4295 1512 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; and copy it to byte #31 in INF (so the ship's data in
     1514 0072     
4296                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; K% gets updated)
     **** ****     > ST_IND_Y_IDX
0001 1516 D820  30        movb @INF,@rtmplb
     1518 0020     
     151A 8301     
0002 151C D020  22        movb @INF+1,rtmp
     151E 0021     
0003 1520 06CF  10        swpb ry
0004 1522 A00F  14        a    ry,rtmp
0005 1524 06CF  10        swpb ry
0006 1526 D40D  26        movb RA,*rtmp
                   < elite.a99
4297               
4298 1528 D3A0  22        movb @XSAV,rx                   ; LDX XSAV          ; We're done processing this ship, so fetch the ship's
     152A 0093     
4299                                                                          ; slot number, which we saved in XSAV back at the start
4300                                                                          ; of the loop
4301               
4302 152C B387  14        ab   rone,rx                    ; INX               ; Increment the slot number to move on to the next slot
4303               
4304 152E 0460  16        b    @MAL1                      ; JMP MAL1          ; And jump back up to the beginning of the loop to get
     1530 118C     
4305                                                                          ; the next ship in the local bubble for processing
4306               
4307               * ******************************************************************************
4308               *
4309               * Name: Main flight loop (Part 13 of 16)
4310               * Type: Subroutine
4311               * Category: Main loop
4312               * Summary: Show energy bomb effect, charge shields and energy banks
4313               * Deep dive: Program flow of the main game loop
4314               * Scheduling tasks with the main loop counter
4315               *
4316               * ------------------------------------------------------------------------------
4317               *
4318               * The main flight loop covers most of the flight-specific aspects of Elite. This
4319               * section covers the following:
4320               *
4321               * * Show energy bomb effect (if applicable)
4322               *
4323               * * Charge shields and energy banks (every 7 iterations of the main loop)
4324               *
4325               * ******************************************************************************
4326               
4327               MA18:
4328 1532 D360  22        movb @BOMB,ra                   ; LDA BOMB          ; If we set off our energy bomb (see MA24 above), then
     1534 032A     
4329 1536 150F  10        jgt  MA77                       ; BPL MA77          ; BOMB is now negative, so this skips to MA21 if our
4330                                                                          ; energy bomb is not going off
4331               
4332                      .asl @BOMB                      ; ASL BOMB          ; We set off our energy bomb, so rotate BOMB to the
     **** ****     > ASL
0001 1538 D020  22        movb @BOMB,rtmp
     153A 032A     
0002 153C 0240  14        andi rtmp,>ff00
     153E FF00     
0003 1540 0A10  14        sla  rtmp,1
0004 1542 D800  22        movb rtmp,@BOMB
     1544 032A     
                   < elite.a99
4333                                                                          ; left by one place. BOMB was rotated left once already
4334                                                                          ; during this iteration of the main loop, back at MA24,
4335                                                                          ; so if this is the first pass it will already be
4336                                                                          ; %11111110, and this will shift it to %11111100 - so
4337                                                                          ; if we set off an energy bomb, it stays activated
4338                                                                          ; (BOMB > 0) for four iterations of the main loop
4339               
4340 1546 0200  12        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     1548 4EA2     
4341 154A 06A0  24        bl   @jsr                       ;
     154C FE28     
4342                                                                          ; screen gets drawn and the following palette change
4343                                                                          ; won't kick in while the screen is still refreshing
4344               
4345 154E 020D  12        li   ra,>30*256                 ; LDA #%00110000    ; Set the palette byte at SHEILA &21 to map logical
     1550 3000     
4346 1552 D80D  30        movb ra,@VIA+>21                ; STA VIA+&21       ; colour 0 to physical colour 7 (white), but with only
     1554 FE21     
4347                                                                          ; one mapping (rather than the 7 mappings required to
4348                                                                          ; do the mapping properly). This makes the space screen
4349                                                                          ; flash with black and white stripes. See p.382 of the
4350                                                                          ; Advanced User Guide for details of why this single
4351                                                                          ; palette change creates a special effect
4352               
4353               MA77:
4354 1556 D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 7,
     1558 0099     
4355 155A 024D  14        andi ra,>07*256                 ; AND #7            ; jumping to MA22 if it is non-zero (so the following
     155C 0700     
4356 155E 1664  10        jne  MA22                       ; BNE MA22          ; code only runs every 8 iterations of the main loop)
4357               
4358 1560 D3A0  22        movb @ENERGY,rx                 ; LDX ENERGY        ; Fetch our ship's energy levels and skip to b if bit 7
     1562 0F13     
4359 1564 1510  10        jgt  b_                         ; BPL b             ; is not set, i.e. only charge the shields from the
4360                                                                          ; energy banks if they are at more than 50% charge
4361               
4362 1566 D3A0  22        movb @ASH,rx                    ; LDX ASH           ; Call SHD to recharge our aft shield and update the
     1568 0F12     
4363 156A 0200  12        li   rtmp,SHD                   ; JSR SHD           ; shield status in ASH
     156C AD1E     
4364 156E 06A0  24        bl   @jsr                       ;
     1570 FE28     
4365 1572 D80E  22        movb rx,@ASH                    ; STX ASH
     1574 0F12     
4366               
4367 1576 D3A0  22        movb @FSH,rx                    ; LDX FSH           ; Call SHD to recharge our forward shield and update
     1578 0F11     
4368 157A 0200  12        li   rtmp,SHD                   ; JSR SHD           ; the shield status in FSH
     157C AD1E     
4369 157E 06A0  24        bl   @jsr                       ;
     1580 FE28     
4370 1582 D80E  22        movb rx,@FSH                    ; STX FSH
     1584 0F11     
4371               
4372               b_:
4373                      .sec                            ; SEC               ; Set A = ENERGY + ENGY + 1, so our ship's energy
     **** ****     > SEC
0001 1586 0A18  14        sla  rmone,1
                   < elite.a99
4374 1588 D360  22        movb @ENGY,ra                   ; LDA ENGY          ; level goes up by 2 if we have an energy unit fitted,
     158A 032B     
4375                      .adc @ENERGY,ra                 ; ADC ENERGY        ; otherwise it goes up by 1
     **** ****     > ADC
0001 158C 1701  10        jnc  !
0002 158E B347  14        ab   rone,ra
0003               !:
0004 1590 B360  22        ab   @ENERGY,ra
     1592 0F13     
                   < elite.a99
4376               
4377 1594 1802  10        joc  B09                        ; BCS B09           ; If the value of A did not overflow (the maximum
4378 1596 D80D  22        movb ra,@ENERGY                 ; STA ENERGY        ; energy level is &FF), then store A in ENERGY
     1598 0F13     
4379               
4380               * ******************************************************************************
4381               *
4382               * Name: Main flight loop (Part 14 of 16)
4383               * Type: Subroutine
4384               * Category: Main loop
4385               * Summary: Spawn a space station if we are close enough to the planet
4386               * Deep dive: Program flow of the main game loop
4387               * Scheduling tasks with the main loop counter
4388               * Ship data blocks
4389               * The space station safe zone
4390               *
4391               * ------------------------------------------------------------------------------
4392               *
4393               * The main flight loop covers most of the flight-specific aspects of Elite. This
4394               * section covers the following:
4395               *
4396               * * Spawn a space station if we are close enough to the planet (every 32
4397               * iterations of the main loop)
4398               *
4399               * ******************************************************************************
4400               
4401               B09:
4402 159A D360  22        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace, jump down to MA23S to skip
     159C 0D5C     
4403 159E 1642  10        jne  MA23S                      ; BNE MA23S         ; the following, as there are no space stations in
4404                                                                          ; witchspace
4405               
4406 15A0 D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 32,
     15A2 0099     
4407 15A4 024D  14        andi ra,>1f*256                 ; AND #31           ; jumping to MA93 if it is on-zero (so the following
     15A6 1F00     
4408 15A8 1646  10        jne  MA93                       ; BNE MA93          ; code only runs every 32 iterations of the main loop)
4409               
4410 15AA D360  22        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     15AC 0D55     
4411 15AE 163A  10        jne  MA23S                      ; BNE MA23S         ; MA23S to skip the following, as we already have a
4412                                                                          ; space station and don't need another
4413               
4414 15B0 D3CD  14        movb ra,ry                      ; TAY               ; Set Y = A = 0 (A is 0 as we didn't branch with the
4415                                                                          ; previous BNE instruction)
4416               
4417 15B2 0200  12        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to calculate the largest distance to the
     15B4 17A2     
4418 15B6 06A0  24        bl   @jsr                       ;
     15B8 FE28     
4419 15BA 1634  10        jne  MA23S                      ; BNE MA23S         ; planet in any of the three axes, and if it's
4420                                                                          ; non-zero, jump to MA23S to skip the following, as we
4421                                                                          ; are too far from the planet to bump into a space
4422                                                                          ; station
4423               
4424                                                                          ; We now want to spawn a space station, so first we
4425                                                                          ; need to set up a ship data block for the station in
4426                                                                          ; INWK that we can then pass to NWSPS to add a new
4427                                                                          ; station to our bubble of universe. We do this by
4428                                                                          ; copying the planet data block from K% to INWK so we
4429                                                                          ; can work on it, but we only need the first 29 bytes,
4430                                                                          ; as we don't need to worry about bytes #29 to #35
4431                                                                          ; for planets (as they don't have rotation counters,
4432                                                                          ; AI, explosions, missiles, a ship line heap or energy
4433                                                                          ; levels)
4434               
4435 15BC 020E  12        li   rx,>1c*256                 ; LDX #28           ; So we set a counter in X to copy 29 bytes from K%+0
     15BE 1C00     
4436                                                                          ; to K%+28
4437               
4438               MAL4:
4439 15C0 D36E  26        movb @K.(rx),ra                 ; LDA K%,X          ; Load the X-th byte of K% and store in the X-th byte
     15C2 0900     
4440 15C4 DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X        ; of the INWK workspace
     15C6 0053     
4441               
4442 15C8 7387  14        sb   rone,rx                    ; DEX               ; Decrement the loop counter
4443               
4444 15CA 15FA  10        jgt  MAL4                       ; BPL MAL4          ; Loop back for the next byte until we have copied the
4445                                                                          ; first 28 bytes of K% to INWK
4446               
4447                                                                          ; We now check the distance from our ship (at the
4448                                                                          ; origin) towards the point where we will spawn the
4449                                                                          ; space station if we are close enough
4450                                                                          ;
4451                                                                          ; This point is calculated by starting at the planet's
4452                                                                          ; centre and adding 2 * nosev, which takes us to a point
4453                                                                          ; above the planet's surface, at an altitude that
4454                                                                          ; matches the planet's radius
4455                                                                          ;
4456                                                                          ; This point pitches and rolls around the planet as the
4457                                                                          ; nosev vector rotates with the planet, and if our ship
4458                                                                          ; is within a distance of (192 0) from this point in all
4459                                                                          ; three axes, then we spawn the space station at this
4460                                                                          ; point, with the station's slot facing towards the
4461                                                                          ; planet, along the nosev vector
4462                                                                          ;
4463                                                                          ; This works because in the following, we calculate the
4464                                                                          ; station's coordinates one axis at a time, and store
4465                                                                          ; the results in the INWK block, so by the time we have
4466                                                                          ; calculated and checked all three, the ship data block
4467                                                                          ; is set up with the correct spawning coordinates
4468               
4469 15CC B387  14        ab   rone,rx                    ; INX               ; Set X = 0 (as we ended the above loop with X as &FF)
4470               
4471 15CE 020F  12        li   ry,>09*256                 ; LDY #9            ; Call MAS1 with X = 0, Y = 9 to do the following:
     15D0 0900     
4472 15D2 0200  12        li   rtmp,MAS1                  ; JSR MAS1          ;
     15D4 1754     
4473 15D6 06A0  24        bl   @jsr                       ;
     15D8 FE28     
4474                                                                          ; (x_sign x_hi x_lo) += (nosev_x_hi nosev_x_lo) * 2
4475                                                                          ;
4476                                                                          ; A = |x_sign|
4477               
4478 15DA 1624  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4479                                                                          ; are too far from the planet in the x-direction to
4480                                                                          ; bump into a space station
4481               
4482 15DC 020E  12        li   rx,>03*256                 ; LDX #3            ; Call MAS1 with X = 3, Y = 11 to do the following:
     15DE 0300     
4483 15E0 020F  12        li   ry,>0b*256                 ; LDY #11           ;
     15E2 0B00     
4484 15E4 0200  12        li   rtmp,MAS1                  ; JSR MAS1          ; (y_sign y_hi y_lo) += (nosev_y_hi nosev_y_lo) * 2
     15E6 1754     
4485 15E8 06A0  24        bl   @jsr                       ;
     15EA FE28     
4486                                                                          ;
4487                                                                          ; A = |y_sign|
4488               
4489 15EC 161B  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4490                                                                          ; are too far from the planet in the y-direction to
4491                                                                          ; bump into a space station
4492               
4493 15EE 020E  12        li   rx,>06*256                 ; LDX #6            ; Call MAS1 with X = 6, Y = 13 to do the following:
     15F0 0600     
4494 15F2 020F  12        li   ry,>0d*256                 ; LDY #13           ;
     15F4 0D00     
4495 15F6 0200  12        li   rtmp,MAS1                  ; JSR MAS1          ; (z_sign z_hi z_lo) += (nosev_z_hi nosev_z_lo) * 2
     15F8 1754     
4496 15FA 06A0  24        bl   @jsr                       ;
     15FC FE28     
4497                                                                          ;
4498                                                                          ; A = |z_sign|
4499               
4500 15FE 1612  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4501                                                                          ; are too far from the planet in the z-direction to
4502                                                                          ; bump into a space station
4503               
4504 1600 020D  12        li   ra,>c0*256                 ; LDA #192          ; Call FAROF2 to compare x_hi, y_hi and z_hi with 192,
     1602 C000     
4505 1604 0200  12        li   rtmp,FAROF2                ; JSR FAROF2        ; which will set the C flag if all three are < 192, or
     1606 C4FE     
4506 1608 06A0  24        bl   @jsr                       ;
     160A FE28     
4507                                                                          ; clear the C flag if any of them are >= 192
4508               
4509 160C 170B  10        jnc  MA23S                      ; BCC MA23S         ; Jump to MA23S if any one of x_hi, y_hi or z_hi are
4510                                                                          ; >= 192 (i.e. they must all be < 192 for us to be near
4511                                                                          ; enough to the planet to bump into a space station)
4512               
4513 160E D360  22        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is not a space view, skip the
     1610 0096     
4514 1612 1604  10        jne  B10                        ; BNE B10           ; following instruction (so we only remove the sun from
4515                                                                          ; the screen if we are potentially looking at it)
4516               
4517 1614 0200  12        li   rtmp,WPLS                  ; JSR WPLS          ; Call WPLS to remove the sun from the screen, as we
     1616 B9DC     
4518 1618 06A0  24        bl   @jsr                       ;
     161A FE28     
4519                                                                          ; can't have both the sun and the space station at the
4520                                                                          ; same time
4521               
4522               B10:
4523 161C 0200  12        li   rtmp,NWSPS                 ; JSR NWSPS         ; Add a new space station to our local bubble of
     161E AF76     
4524 1620 06A0  24        bl   @jsr                       ;
     1622 FE28     
4525                                                                          ; universe
4526               
4527               MA23S:
4528 1624 0460  16        b    @MA23                      ; JMP MA23          ; Jump to MA23 to skip the following planet and sun
     1626 1708     
4529                                                                          ; altitude checks
4530               
4531               * ******************************************************************************
4532               *
4533               * Name: Main flight loop (Part 15 of 16)
4534               * Type: Subroutine
4535               * Category: Main loop
4536               * Summary: Perform altitude checks with the planet and sun and process fuel
4537               * scooping if appropriate
4538               * Deep dive: Program flow of the main game loop
4539               * Scheduling tasks with the main loop counter
4540               *
4541               * ------------------------------------------------------------------------------
4542               *
4543               * The main flight loop covers most of the flight-specific aspects of Elite. This
4544               * section covers the following:
4545               *
4546               * * Perform an altitude check with the planet (every 32 iterations of the main
4547               * loop, on iteration 10 of each 32)
4548               *
4549               * * Perform an altitude check with the sun and process fuel scooping (every
4550               * 32 iterations of the main loop, on iteration 20 of each 32)
4551               *
4552               * ******************************************************************************
4553               
4554               MA22:
4555 1628 D360  22        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace, jump down to MA23 to skip
     162A 0D5C     
4556 162C 166D  10        jne  MA23                       ; BNE MA23          ; the following, as there are no planets or suns to
4557                                                                          ; bump into in witchspace
4558               
4559 162E D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 32,
     1630 0099     
4560 1632 024D  14        andi ra,>1f*256                 ; AND #31           ; which tells us the position of this loop in each block
     1634 1F00     
4561                                                                          ; of 32 iterations
4562               
4563               MA93:
4564 1636 028D  14        ci   ra,>0a*256                 ; CMP #10           ; If this is the tenth iteration in this block of 32,
     1638 0A00     
4565 163A 162D  10        jne  MA29                       ; BNE MA29          ; do the following, otherwise jump to MA29 to skip the
4566                                                                          ; planet altitude check and move on to the sun distance
4567                                                                          ; check
4568               
4569 163C 020D  12        li   ra,>32*256                 ; LDA #50           ; If our energy bank status in ENERGY is >= 50, skip
     163E 3200     
4570 1640 9360  22        cb   @ENERGY,ra                 ; CMP ENERGY        ; printing the following message (so the message is
     1642 0F13     
4571 1644 1707  10        jnc  B11                        ; BCC B11           ; only shown if our energy is low)
4572               
4573                      .asla                           ; ASL A             ; Print recursive token 100 ("ENERGY LOW{beep}") as an
     **** ****     > ASLA
0001 1646 024D  14        andi ra,>ff00
     1648 FF00     
0002 164A 0A1D  14        sla  ra,1
                   < elite.a99
4574 164C 0200  12        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     164E CF0E     
4575 1650 06A0  24        bl   @jsr                       ;
     1652 FE28     
4576               
4577               B11:
4578 1654 020F  12        li   ry,>ff*256                 ; LDY #&FF          ; Set our altitude in ALTIT to &FF, the maximum
     1656 FF00     
4579 1658 D80F  22        movb ry,@ALTIT                  ; STY ALTIT
     165A 0F21     
4580               
4581 165C B3C7  14        ab   rone,ry                    ; INY               ; Set Y = 0
4582               
4583 165E 0200  12        li   rtmp,m_                    ; JSR m             ; Call m to calculate the maximum distance to the
     1660 179E     
4584 1662 06A0  24        bl   @jsr                       ;
     1664 FE28     
4585                                                                          ; planet in any of the three axes, returned in A
4586               
4587 1666 1650  10        jne  MA23                       ; BNE MA23          ; If A > 0 then we are a fair distance away from the
4588                                                                          ; planet in at least one axis, so jump to MA23 to skip
4589                                                                          ; the rest of the altitude check
4590               
4591 1668 0200  12        li   rtmp,MAS3                  ; JSR MAS3          ; Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
     166A 17B6     
4592 166C 06A0  24        bl   @jsr                       ;
     166E FE28     
4593                                                                          ; we now know that A now contains the square of the
4594                                                                          ; distance between our ship (at the origin) and the
4595                                                                          ; centre of the planet at (x_hi, y_hi, z_hi)
4596               
4597 1670 184B  10        joc  MA23                       ; BCS MA23          ; If the C flag was set by MAS3, then the result
4598                                                                          ; overflowed (was greater than &FF) and we are still a
4599                                                                          ; fair distance from the planet, so jump to MA23 as we
4600                                                                          ; haven't crashed into the planet
4601               
4602                      .sbi (>24*256)                  ; SBC #36           ; Subtract 36 from x_hi^2 + y_hi^2 + z_hi^2
     **** ****     > SBI
0001 1672 1801  10        joc  !
0002 1674 7347  14        sb   rone,ra
0003               !:
0004 1676 022D  14        ai   ra,-(>24*256)
     1678 DC00     
                   < elite.a99
4603                                                                          ;
4604                                                                          ; When we do the 3D Pythagoras calculation, we only use
4605                                                                          ; the high bytes of the coordinates, so that's x_hi,
4606                                                                          ; y_hi and z_hi and
4607                                                                          ;
4608                                                                          ; The planet radius is (0 96 0), as defined in the
4609                                                                          ; PLANET routine, so the high byte is 96
4610                                                                          ;
4611                                                                          ; When we square the coordinates above and add them,
4612                                                                          ; the result gets divided by 256 (otherwise the result
4613                                                                          ; wouldn't fit into one byte), so if we do the same for
4614                                                                          ; the planet's radius, we get:
4615                                                                          ;
4616                                                                          ; 96 * 96 / 256 = 36
4617                                                                          ;
4618                                                                          ; So for the planet, the equivalent figure to test the
4619                                                                          ; sum of the _hi bytes against is 36, so A now contains
4620                                                                          ; the high byte of our altitude above the planet
4621                                                                          ; surface, squared
4622               
4623 167A 170B  10        jnc  MA28                       ; BCC MA28          ; If A < 0 then jump to MA28 as we have crashed into
4624                                                                          ; the planet
4625               
4626 167C D80D  22        movb ra,@R                      ; STA R             ; We are getting close to the planet, so we need to
     167E 0091     
4627 1680 0200  12        li   rtmp,LL5                   ; JSR LL5           ; work out how close. We know from the above that A
     1682 D376     
4628 1684 06A0  24        bl   @jsr                       ;
     1686 FE28     
4629                                                                          ; contains our altitude squared, so we store A in R
4630                                                                          ; and call LL5 to calculate:
4631                                                                          ;
4632                                                                          ; Q = SQRT(R Q) = SQRT(A Q)
4633                                                                          ;
4634                                                                          ; Interestingly, Q doesn't appear to be set to 0 for
4635                                                                          ; this calculation, so presumably this doesn't make a
4636                                                                          ; difference
4637               
4638 1688 D360  22        movb @Q,ra                      ; LDA Q             ; Store the result in ALTIT, our altitude
     168A 0090     
4639 168C D80D  22        movb ra,@ALTIT                  ; STA ALTIT
     168E 0F21     
4640               
4641 1690 163B  10        jne  MA23                       ; BNE MA23          ; If our altitude is non-zero then we haven't crashed,
4642                                                                          ; so jump to MA23 to skip to the next section
4643               
4644               MA28:
4645 1692 0460  20        b    @DEATH                     ; JMP DEATH         ; If we get here then we just crashed into the planet
     1694 C522     
4646                                                                          ; or got too close to the sun, so jump to DEATH to start
4647                                                                          ; the funeral preparations and return from the main
4648                                                                          ; flight loop using a tail call
4649               
4650               MA29:
4651 1696 028D  14        ci   ra,>14*256                 ; CMP #20           ; If this is the 20th iteration in this block of 32,
     1698 1400     
4652 169A 1636  10        jne  MA23                       ; BNE MA23          ; do the following, otherwise jump to MA23 to skip the
4653                                                                          ; sun altitude check
4654               
4655 169C 020D  12        li   ra,>1e*256                 ; LDA #30           ; Set CABTMP to 30, the cabin temperature in deep space
     169E 1E00     
4656 16A0 D80D  22        movb ra,@CABTMP                 ; STA CABTMP        ; (i.e. one notch on the dashboard bar)
     16A2 0D4D     
4657               
4658 16A4 D360  22        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     16A6 0D55     
4659 16A8 162F  10        jne  MA23                       ; BNE MA23          ; MA23 to skip the following, as we can't have both the
4660                                                                          ; sun and space station at the same time, so we clearly
4661                                                                          ; can't be flying near the sun
4662               
4663 16AA 020F  12        li   ry,(NI.)*256               ; LDY #NI%          ; Set Y to NI%, which is the offset in K% for the sun's
     16AC 2400     
4664                                                                          ; data block, as the second block at K% is reserved for
4665                                                                          ; the sun (or space station)
4666               
4667 16AE 0200  12        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to calculate the largest distance to the
     16B0 17A2     
4668 16B2 06A0  24        bl   @jsr                       ;
     16B4 FE28     
4669 16B6 1628  10        jne  MA23                       ; BNE MA23          ; sun in any of the three axes, and if it's non-zero,
4670                                                                          ; jump to MA23 to skip the following, as we are too far
4671                                                                          ; from the sun for scooping or temperature changes
4672               
4673 16B8 0200  12        li   rtmp,MAS3                  ; JSR MAS3          ; Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
     16BA 17B6     
4674 16BC 06A0  24        bl   @jsr                       ;
     16BE FE28     
4675                                                                          ; we now know that A now contains the square of the
4676                                                                          ; distance between our ship (at the origin) and the
4677                                                                          ; heart of the sun at (x_hi, y_hi, z_hi)
4678               
4679                      .eoi (>ff*256)                  ; EOR #%11111111    ; Invert A, so A is now small if we are far from the
     **** ****     > EOI
0001 16C0 0200  12        li   rtmp,(>FF*256)
     16C2 FF00     
0002 16C4 2B40  14        xor  rtmp,ra
                   < elite.a99
4680                                                                          ; sun and large if we are close to the sun, in the
4681                                                                          ; range 0 = far away to &FF = extremely close, ouch,
4682                                                                          ; hot, hot, hot!
4683               
4684                      .adi (>1e*256)                  ; ADC #30           ; Add the minimum cabin temperature of 30, so we get
     **** ****     > ADI
0001 16C6 1701  10        jnc  !
0002 16C8 B347  14        ab   rone,ra
0003               !:
0004 16CA 022D  14        ai   ra,(>1E*256)
     16CC 1E00     
                   < elite.a99
4685                                                                          ; one of the following:
4686                                                                          ;
4687                                                                          ; * If the C flag is clear, A contains the cabin
4688                                                                          ; temperature, ranging from 30 to 255, that's hotter
4689                                                                          ; the closer we are to the sun
4690                                                                          ;
4691                                                                          ; * If the C flag is set, the addition has rolled over
4692                                                                          ; and the cabin temperature is over 255
4693               
4694 16CE D80D  22        movb ra,@CABTMP                 ; STA CABTMP        ; Store the updated cabin temperature
     16D0 0D4D     
4695               
4696 16D2 18DF  10        joc  MA28                       ; BCS MA28          ; If the C flag is set then jump to MA28 to die, as
4697                                                                          ; our temperature is off the scale
4698               
4699 16D4 028D  14        ci   ra,>e0*256                 ; CMP #224          ; If the cabin temperature < 224 then jump to MA23 to
     16D6 E000     
4700 16D8 1717  10        jnc  MA23                       ; BCC MA23          ; skip fuel scooping, as we aren't close enough
4701               
4702 16DA D360  22        movb @BST,ra                    ; LDA BST           ; If we don't have fuel scoops fitted, jump to BA23 to
     16DC 0329     
4703 16DE 1314  10        jeq  MA23                       ; BEQ MA23          ; skip fuel scooping, as we can't scoop without fuel
4704                                                                          ; scoops
4705               
4706 16E0 D360  22        movb @DELT4+1,ra                ; LDA DELT4+1       ; We are now successfully fuel scooping, so it's time
     16E2 008E     
4707 16E4 091D  14        srl  ra,1                       ; LSR A             ; to work out how much fuel we're scooping. Fetch the
4708                                                                          ; high byte of DELT4, which contains our current speed
4709                                                                          ; divided by 4, and halve it to get our current speed
4710                                                                          ; divided by 8 (so it's now a value between 1 and 5, as
4711                                                                          ; our speed is normally between 1 and 40). This gives
4712                                                                          ; us the amount of fuel that's being scooped in A, so
4713                                                                          ; the faster we go, the more fuel we scoop, and because
4714                                                                          ; the fuel levels are stored as 10 * the fuel in light
4715                                                                          ; years, that means we just scooped between 0.1 and 0.5
4716                                                                          ; light years of free fuel
4717               
4718                      .adc @QQ14,ra                   ; ADC QQ14          ; Set A = A + the current fuel level * 10 (from QQ14)
     **** ****     > ADC
0001 16E6 1701  10        jnc  !
0002 16E8 B347  14        ab   rone,ra
0003               !:
0004 16EA B360  22        ab   @QQ14,ra
     16EC 030D     
                   < elite.a99
4719               
4720 16EE 028D  14        ci   ra,>46*256                 ; CMP #70           ; If A > 70 then set A = 70 (as 70 is the maximum fuel
     16F0 4600     
4721 16F2 1702  10        jnc  B12                        ; BCC B12           ; level, or 7.0 light years)
4722 16F4 020D  12        li   ra,>46*256                 ; LDA #70
     16F6 4600     
4723               
4724               B12:
4725 16F8 D80D  22        movb ra,@QQ14                   ; STA QQ14          ; Store the updated fuel level in QQ14
     16FA 030D     
4726               
4727 16FC 020D  12        li   ra,>a0*256                 ; LDA #160          ; Print recursive token 0 ("FUEL SCOOPS ON") as an
     16FE A000     
4728 1700 0200  12        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     1702 CF0E     
4729 1704 06A0  24        bl   @jsr                       ;
     1706 FE28     
4730               
4731               * ******************************************************************************
4732               *
4733               * Name: Main flight loop (Part 16 of 16)
4734               * Type: Subroutine
4735               * Category: Main loop
4736               * Summary: Process laser pulsing, E.C.M. energy drain, call stardust routine
4737               * Deep dive: Program flow of the main game loop
4738               *
4739               * ------------------------------------------------------------------------------
4740               *
4741               * The main flight loop covers most of the flight-specific aspects of Elite. This
4742               * section covers the following:
4743               *
4744               * * Process laser pulsing
4745               *
4746               * * Process E.C.M. energy drain
4747               *
4748               * * Jump to the stardust routine if we are in a space view
4749               *
4750               * * Return from the main flight loop
4751               *
4752               * ******************************************************************************
4753               
4754               MA23:
4755 1708 D360  22        movb @LAS2,ra                   ; LDA LAS2          ; If the current view has no laser, jump to MA16 to skip
     170A 0D5D     
4756 170C 130D  10        jeq  MA16                       ; BEQ MA16          ; the following
4757               
4758 170E D360  22        movb @LASCT,ra                  ; LDA LASCT         ; If LASCT >= 8, jump to MA16 to skip the following, so
     1710 0D60     
4759 1712 028D  14        ci   ra,>08*256                 ; CMP #8            ; for a pulse laser with a LASCT between 8 and 10, the
     1714 0800     
4760 1716 1808  10        joc  MA16                       ; BCS MA16          ; laser stays on, but for a LASCT of 7 or less it gets
4761                                                                          ; turned off and stays off until LASCT reaches zero and
4762                                                                          ; the next pulse can start (if the fire button is still
4763                                                                          ; being pressed)
4764                                                                          ;
4765                                                                          ; For pulse lasers, LASCT gets set to 10 in ma1 above,
4766                                                                          ; and it decrements every vertical sync (50 times a
4767                                                                          ; second), so this means it pulses five times a second,
4768                                                                          ; with the laser being on for the first 3/10 of each
4769                                                                          ; pulse and off for the rest of the pulse
4770                                                                          ;
4771                                                                          ; If this is a beam laser, LASCT is 0 so we always keep
4772                                                                          ; going here. This means the laser doesn't pulse, but it
4773                                                                          ; does get drawn and removed every cycle, in a slightly
4774                                                                          ; different place each time, so the beams still flicker
4775                                                                          ; around the screen
4776               
4777 1718 0200  12        li   rtmp,LASLI2                ; JSR LASLI2        ; Redraw the existing laser lines, which has the effect
     171A 49D6     
4778 171C 06A0  24        bl   @jsr                       ;
     171E FE28     
4779                                                                          ; of removing them from the screen
4780               
4781 1720 020D  12        li   ra,>00*256                 ; LDA #0            ; Set LAS2 to 0 so if this is a pulse laser, it will
     1722 0000     
4782 1724 D80D  22        movb ra,@LAS2                   ; STA LAS2          ; skip over the above until the next pulse (this has no
     1726 0D5D     
4783                                                                          ; effect if this is a beam laser)
4784               
4785               MA16:
4786 1728 D360  22        movb @ECMP,ra                   ; LDA ECMP          ; If our E.C.M is not on, skip to MA69, otherwise keep
     172A 0D5B     
4787 172C 1305  10        jeq  MA69                       ; BEQ MA69          ; going to drain some energy
4788               
4789 172E 0200  12        li   rtmp,DENGY                 ; JSR DENGY         ; Call DENGY to deplete our energy banks by 1
     1730 AD22     
4790 1732 06A0  24        bl   @jsr                       ;
     1734 FE28     
4791               
4792 1736 1305  10        jeq  MA70                       ; BEQ MA70          ; If we have no energy left, jump to MA70 to turn our
4793                                                                          ; E.C.M. off
4794               
4795               MA69:
4796 1738 D360  22        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M is going off (ours or an opponent's) then
     173A 0030     
4797 173C 1306  10        jeq  MA66                       ; BEQ MA66          ; keep going, otherwise skip to MA66
4798               
4799 173E 7347  14        sb   rone,ra                    ; DEC ECMA          ; Decrement the E.C.M. countdown timer, and if it has
4800 1740 1604  10        jne  MA66                       ; BNE MA66          ; reached zero, keep going, otherwise skip to MA66
4801               
4802               MA70:
4803 1742 0200  12        li   rtmp,ECMOF                 ; JSR ECMOF         ; If we get here then either we have either run out of
     1744 CBC0     
4804 1746 06A0  24        bl   @jsr                       ;
     1748 FE28     
4805                                                                          ; energy, or the E.C.M. timer has run down, so switch
4806                                                                          ; off the E.C.M.
4807               
4808               MA66:
4809 174A D360  22        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view (i.e. QQ11 is non-zero)
     174C 0096     
4810 174E 1625  10        jne  MA9                        ; BNE MA9           ; then jump to MA9 to return from the main flight loop
4811                                                                          ; (as MA9 is an RTS)
4812               
4813 1750 0460  20        b    @STARS                     ; JMP STARS         ; This is a space view, so jump to the STARS routine to
     1752 29EA     
4814                                                                          ; process the stardust, and return from the main flight
4815                                                                          ; loop using a tail call
4816               
4817               * ******************************************************************************
4818               *
4819               * Name: MAS1
4820               * Type: Subroutine
4821               * Category: Maths (Geometry)
4822               * Summary: Add an orientation vector coordinate to an INWK coordinate
4823               * Deep dive: The space station safe zone
4824               *
4825               * ------------------------------------------------------------------------------
4826               *
4827               * Add a doubled nosev vector coordinate, e.g. (nosev_y_hi nosev_y_lo) * 2, to
4828               * an INWK coordinate, e.g. (x_sign x_hi x_lo), storing the result in the INWK
4829               * coordinate. The axes used in each side of the addition are specified by the
4830               * arguments X and Y.
4831               *
4832               * In the comments below, we document the routine as if we are doing the
4833               * following, i.e. if X = 0 and Y = 11:
4834               *
4835               * (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (nosev_y_hi nosev_y_lo) * 2
4836               *
4837               * as that way the variable names in the comments contain "x" and "y" to match
4838               * the registers that specify the vector axis to use.
4839               *
4840               * ------------------------------------------------------------------------------
4841               *
4842               * Arguments:
4843               *
4844               * X                   The coordinate to add, as follows:
4845               *
4846               * * If X = 0, add (x_sign x_hi x_lo)
4847               * * If X = 3, add (y_sign y_hi y_lo)
4848               * * If X = 6, add (z_sign z_hi z_lo)
4849               *
4850               * Y                   The vector to add, as follows:
4851               *
4852               * * If Y = 9,  add (nosev_x_hi nosev_x_lo)
4853               * * If Y = 11, add (nosev_y_hi nosev_y_lo)
4854               * * If Y = 13, add (nosev_z_hi nosev_z_lo)
4855               *
4856               * ------------------------------------------------------------------------------
4857               *
4858               * Returns:
4859               *
4860               * A                   The highest byte of the result with the sign cleared
4861               * (e.g. |x_sign| when X = 0, etc.)
4862               *
4863               * ------------------------------------------------------------------------------
4864               *
4865               * Other entry points:
4866               *
4867               * MA9                 Contains an RTS
4868               *
4869               * ******************************************************************************
4870               
4871               MAS1:
4872 1754 D36F  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Set K(2 1) = (nosev_y_hi nosev_y_lo) * 2
     1756 0053     
4873                      .asla                           ; ASL A
     **** ****     > ASLA
0001 1758 024D  14        andi ra,>ff00
     175A FF00     
0002 175C 0A1D  14        sla  ra,1
                   < elite.a99
4874 175E D80D  22        movb ra,@K+1                    ; STA K+1
     1760 003E     
4875 1762 D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y
     1764 0054     
4876 1766 06A0  24        bl   @rola                      ; ROL A
     1768 FE3E     
4877 176A D80D  22        movb ra,@K+2                    ; STA K+2
     176C 003F     
4878               
4879 176E 020D  12        li   ra,>00*256                 ; LDA #0            ; Set K+3 bit 7 to the C flag, so the sign bit of the
     1770 0000     
4880 1772 06A0  24        bl   @rora                      ; ROR A             ; above result goes into K+3
     1774 FE62     
4881 1776 D80D  22        movb ra,@K+3                    ; STA K+3
     1778 0040     
4882               
4883 177A 0200  12        li   rtmp,MVT3                  ; JSR MVT3          ; Add (x_sign x_hi x_lo) to K(3 2 1)
     177C 1CAC     
4884 177E 06A0  24        bl   @jsr                       ;
     1780 FE28     
4885               
4886 1782 DB8D  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X      ; Store the sign of the result in x_sign
     1784 0055     
4887               
4888 1786 D3E0  22        movb @K+1,ry                    ; LDY K+1           ; Store K(2 1) in (x_hi x_lo)
     1788 003E     
4889 178A DB8F  30        movb ry,@INWK(rx)               ; STY INWK,X
     178C 0053     
4890 178E D3E0  22        movb @K+2,ry                    ; LDY K+2
     1790 003F     
4891 1792 DB8F  30        movb ry,@INWK+1(rx)             ; STY INWK+1,X
     1794 0054     
4892               
4893 1796 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Set A to the sign byte with the sign cleared,
     1798 7F00     
4894                                                                          ; i.e. |x_sign| when X = 0
4895               
4896               MA9:
4897 179A 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     179C FE34     
4898               
4899               * ******************************************************************************
4900               *
4901               * Name: MAS2
4902               * Type: Subroutine
4903               * Category: Maths (Geometry)
4904               * Summary: Calculate a cap on the maximum distance to the planet or sun
4905               *
4906               * ------------------------------------------------------------------------------
4907               *
4908               * Given a value in Y that points to the start of a ship data block as an offset
4909               * from K%, calculate the following:
4910               *
4911               * A = A OR x_sign OR y_sign OR z_sign
4912               *
4913               * and clear the sign bit of the result. The K% workspace contains the ship data
4914               * blocks, so the offset in Y must be 0 or a multiple of NI% (as each block in
4915               * K% contains NI% bytes).
4916               *
4917               * The result effectively contains a maximum cap of the three values (though it
4918               * might not be one of the three input values - it's just guaranteed to be
4919               * larger than all of them).
4920               *
4921               * If Y = 0 and A = 0, then this calculates the maximum cap of the highest byte
4922               * containing the distance to the planet, as K%+2 = x_sign, K%+5 = y_sign and
4923               * K%+8 = z_sign (the first slot in the K% workspace represents the planet).
4924               *
4925               * ------------------------------------------------------------------------------
4926               *
4927               * Arguments:
4928               *
4929               * Y                   The offset from K% for the start of the ship data block
4930               * to use
4931               *
4932               * ------------------------------------------------------------------------------
4933               *
4934               * Returns:
4935               *
4936               * A                   A OR K%+2+Y OR K%+5+Y OR K%+8+Y, with bit 7 cleared
4937               *
4938               * ------------------------------------------------------------------------------
4939               *
4940               * Other entry points:
4941               *
4942               * m                   Do not include A in the calculation
4943               *
4944               * ******************************************************************************
4945               
4946               m_:
4947 179E 020D  12        li   ra,>00*256                 ; LDA #0            ; Set A = 0 and fall through into MAS2 to calculate the
     17A0 0000     
4948                                                                          ; OR of the three bytes at K%+2+Y, K%+5+Y and K%+8+Y
4949               
4950               MAS2:
4951 17A2 F36F  26        socb @K.+2(ry),ra               ; ORA K%+2,Y        ; Set A = A OR x_sign OR y_sign OR z_sign
     17A4 0902     
4952 17A6 F36F  26        socb @K.+5(ry),ra               ; ORA K%+5,Y
     17A8 0905     
4953 17AA F36F  26        socb @K.+8(ry),ra               ; ORA K%+8,Y
     17AC 0908     
4954               
4955 17AE 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Clear bit 7 in A
     17B0 7F00     
4956               
4957 17B2 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     17B4 FE34     
4958               
4959               * ******************************************************************************
4960               *
4961               * Name: MAS3
4962               * Type: Subroutine
4963               * Category: Maths (Arithmetic)
4964               * Summary: Calculate A = x_hi^2 + y_hi^2 + z_hi^2 in the K% block
4965               *
4966               * ------------------------------------------------------------------------------
4967               *
4968               * Given a value in Y that points to the start of a ship data block as an offset
4969               * from K%, calculate the following:
4970               *
4971               * A = x_hi^2 + y_hi^2 + z_hi^2
4972               *
4973               * returning A = &FF if the calculation overflows a one-byte result. The K%
4974               * workspace contains the ship data blocks, so the offset in Y must be 0 or a
4975               * multiple of NI% (as each block in K% contains NI% bytes).
4976               *
4977               * ------------------------------------------------------------------------------
4978               *
4979               * Arguments:
4980               *
4981               * Y                   The offset from K% for the start of the ship data block
4982               * to use
4983               *
4984               * Returns
4985               *
4986               * A                   A = x_hi^2 + y_hi^2 + z_hi^2
4987               *
4988               * A = &FF if the calculation overflows a one-byte result
4989               *
4990               * ******************************************************************************
4991               
4992               MAS3:
4993 17B6 D36F  26        movb @K.+1(ry),ra               ; LDA K%+1,Y        ; Set (A P) = x_hi * x_hi
     17B8 0901     
4994 17BA 0200  12        li   rtmp,SQUA2                 ; JSR SQUA2
     17BC 436E     
4995 17BE 06A0  24        bl   @jsr                       ;
     17C0 FE28     
4996               
4997 17C2 D80D  22        movb ra,@R                      ; STA R             ; Store A (high byte of result) in R
     17C4 0091     
4998               
4999 17C6 D36F  26        movb @K.+4(ry),ra               ; LDA K%+4,Y        ; Set (A P) = y_hi * y_hi
     17C8 0904     
5000 17CA 0200  12        li   rtmp,SQUA2                 ; JSR SQUA2
     17CC 436E     
5001 17CE 06A0  24        bl   @jsr                       ;
     17D0 FE28     
5002               
5003                      .adc @R,ra                      ; ADC R             ; Add A (high byte of second result) to R
     **** ****     > ADC
0001 17D2 1701  10        jnc  !
0002 17D4 B347  14        ab   rone,ra
0003               !:
0004 17D6 B360  22        ab   @R,ra
     17D8 0091     
                   < elite.a99
5004               
5005 17DA 180D  10        joc  MA30                       ; BCS MA30          ; If the addition of the two high bytes caused a carry
5006                                                                          ; (i.e. they overflowed), jump to MA30 to return A = &FF
5007               
5008 17DC D80D  22        movb ra,@R                      ; STA R             ; Store A (sum of the two high bytes) in R
     17DE 0091     
5009               
5010 17E0 D36F  26        movb @K.+7(ry),ra               ; LDA K%+7,Y        ; Set (A P) = z_hi * z_hi
     17E2 0907     
5011 17E4 0200  12        li   rtmp,SQUA2                 ; JSR SQUA2
     17E6 436E     
5012 17E8 06A0  24        bl   @jsr                       ;
     17EA FE28     
5013               
5014                      .adc @R,ra                      ; ADC R             ; Add A (high byte of third result) to R, so R now
     **** ****     > ADC
0001 17EC 1701  10        jnc  !
0002 17EE B347  14        ab   rone,ra
0003               !:
0004 17F0 B360  22        ab   @R,ra
     17F2 0091     
                   < elite.a99
5015                                                                          ; contains the sum of x_hi^2 + y_hi^2 + z_hi^2
5016               
5017 17F4 1702  10        jnc  B13                        ; BCC B13           ; If there is no carry, skip the following instruction
5018                                                                          ; to return straight from the subroutine
5019               
5020               MA30:
5021 17F6 020D  12        li   ra,>ff*256                 ; LDA #&FF          ; The calculation has overflowed, so set A = &FF
     17F8 FF00     
5022               
5023               B13:
5024 17FA 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     17FC FE34     
5025               
5026               * ******************************************************************************
5027               *
5028               * Name: MVEIT (Part 1 of 9)
5029               * Type: Subroutine
5030               * Category: Moving
5031               * Summary: Move current ship: Tidy the orientation vectors
5032               * Deep dive: Program flow of the ship-moving routine
5033               * Scheduling tasks with the main loop counter
5034               *
5035               * ------------------------------------------------------------------------------
5036               *
5037               * This routine has multiple stages. This stage does the following:
5038               *
5039               * * Tidy the orientation vectors for one of the ship slots
5040               *
5041               * ------------------------------------------------------------------------------
5042               *
5043               * Arguments:
5044               *
5045               * INWK                The current ship/planet/sun's data block
5046               *
5047               * XSAV                The slot number of the current ship/planet/sun
5048               *
5049               * TYPE                The type of the current ship/planet/sun
5050               *
5051               * ******************************************************************************
5052               
5053               MVEIT:
5054 17FE D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; If bits 5 or 7 of ship byte #31 are set, jump to MV30
     1800 0072     
5055 1802 024D  14        andi ra,>a0*256                 ; AND #%10100000    ; as the ship is either exploding or has been killed, so
     1804 A000     
5056 1806 1623  10        jne  MV30                       ; BNE MV30          ; we don't need to tidy its orientation vectors or apply
5057                                                                          ; tactics
5058               
5059 1808 D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter
     180A 0099     
5060               
5061                      .eor @XSAV                      ; EOR XSAV          ; Fetch the slot number of the ship we are moving, EOR
     **** ****     > EOR
0001 180C D020  22        movb @XSAV,rtmp
     180E 0093     
0002 1810 2B40  14        xor  rtmp,ra
                   < elite.a99
5062 1812 024D  14        andi ra,>0f*256                 ; AND #15           ; with the loop counter and apply mod 15 to the result.
     1814 0F00     
5063 1816 1604  10        jne  MV3                        ; BNE MV3           ; The result will be zero when "counter mod 15" matches
5064                                                                          ; the slot number, so this makes sure we call TIDY 12
5065                                                                          ; times every 16 main loop iterations, like this:
5066                                                                          ;
5067                                                                          ; Iteration 0, tidy the ship in slot 0
5068                                                                          ; Iteration 1, tidy the ship in slot 1
5069                                                                          ; Iteration 2, tidy the ship in slot 2
5070                                                                          ; ...
5071                                                                          ; Iteration 11, tidy the ship in slot 11
5072                                                                          ; Iteration 12, do nothing
5073                                                                          ; Iteration 13, do nothing
5074                                                                          ; Iteration 14, do nothing
5075                                                                          ; Iteration 15, do nothing
5076                                                                          ; Iteration 16, tidy the ship in slot 0
5077                                                                          ; ...
5078                                                                          ;
5079                                                                          ; and so on
5080               
5081 1818 0200  12        li   rtmp,TIDY                  ; JSR TIDY          ; Call TIDY to tidy up the orientation vectors, to
     181A D058     
5082 181C 06A0  24        bl   @jsr                       ;
     181E FE28     
5083                                                                          ; prevent the ship from getting elongated and out of
5084                                                                          ; shape due to the imprecise nature of trigonometry
5085                                                                          ; in assembly language
5086               
5087               * ******************************************************************************
5088               *
5089               * Name: MVEIT (Part 2 of 9)
5090               * Type: Subroutine
5091               * Category: Moving
5092               * Summary: Move current ship: Call tactics routine, remove ship from scanner
5093               * Deep dive: Scheduling tasks with the main loop counter
5094               *
5095               * ------------------------------------------------------------------------------
5096               *
5097               * This routine has multiple stages. This stage does the following:
5098               *
5099               * * Apply tactics to ships with AI enabled (by calling the TACTICS routine)
5100               *
5101               * * Remove the ship from the scanner, so we can move it
5102               *
5103               * ******************************************************************************
5104               
5105               MV3:
5106 1820 D3A0  22        movb @TYPE,rx                   ; LDX TYPE          ; If the type of the ship we are moving is positive,
     1822 009B     
5107 1824 1502  10        jgt  B14                        ; BPL B14           ; i.e. it is not a planet (types 128 and 130) or sun
5108                                                                          ; (type 129), then skip the following instruction
5109               
5110 1826 0460  20        b    @MV40                      ; JMP MV40          ; This item is the planet or sun, so jump to MV40 to
     1828 2026     
5111                                                                          ; move it, which ends by jumping back into this routine
5112                                                                          ; at MV45 (after all the rotation, tactics and scanner
5113                                                                          ; code, which we don't need to apply to planets or suns)
5114               
5115               B14:
5116 182A D360  22        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the ship's byte #32 (AI flag) into A
     182C 0073     
5117               
5118 182E 150F  10        jgt  MV30                       ; BPL MV30          ; If bit 7 of the AI flag is clear, then if this is a
5119                                                                          ; ship or missile it is dumb and has no AI, and if this
5120                                                                          ; is the space station it is not hostile, so in both
5121                                                                          ; cases skip the following as it has no tactics
5122               
5123 1830 028E  14        ci   rx,(MSL)*256               ; CPX #MSL          ; If the ship is a missile, skip straight to MV26 to
     1832 0900     
5124 1834 1308  10        jeq  MV26                       ; BEQ MV26          ; call the TACTICS routine, as we do this every
5125                                                                          ; iteration of the main loop for missiles only
5126               
5127 1836 D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter
     1838 0099     
5128               
5129                      .eor @XSAV                      ; EOR XSAV          ; Fetch the slot number of the ship we are moving, EOR
     **** ****     > EOR
0001 183A D020  22        movb @XSAV,rtmp
     183C 0093     
0002 183E 2B40  14        xor  rtmp,ra
                   < elite.a99
5130 1840 024D  14        andi ra,>07*256                 ; AND #7            ; with the loop counter and apply mod 8 to the result.
     1842 0700     
5131 1844 1604  10        jne  MV30                       ; BNE MV30          ; The result will be zero when "counter mod 8" matches
5132                                                                          ; the slot number mod 8, so this makes sure we call
5133                                                                          ; TACTICS 12 times every 8 main loop iterations, like
5134                                                                          ; this:
5135                                                                          ;
5136                                                                          ; Iteration 0, apply tactics to slots 0 and 8
5137                                                                          ; Iteration 1, apply tactics to slots 1 and 9
5138                                                                          ; Iteration 2, apply tactics to slots 2 and 10
5139                                                                          ; Iteration 3, apply tactics to slots 3 and 11
5140                                                                          ; Iteration 4, apply tactics to slot 4
5141                                                                          ; Iteration 5, apply tactics to slot 5
5142                                                                          ; Iteration 6, apply tactics to slot 6
5143                                                                          ; Iteration 7, apply tactics to slot 7
5144                                                                          ; Iteration 8, apply tactics to slots 0 and 8
5145                                                                          ; ...
5146                                                                          ;
5147                                                                          ; and so on
5148               
5149               MV26:
5150 1846 0200  12        li   rtmp,TACTICS               ; JSR TACTICS       ; Call TACTICS to apply AI tactics to this ship
     1848 387C     
5151 184A 06A0  24        bl   @jsr                       ;
     184C FE28     
5152               
5153               MV30:
5154 184E 0200  12        li   rtmp,SCAN                  ; JSR SCAN          ; Draw the ship on the scanner, which has the effect of
     1850 4D3E     
5155 1852 06A0  24        bl   @jsr                       ;
     1854 FE28     
5156                                                                          ; removing it, as it's already at this point and hasn't
5157                                                                          ; yet moved
5158               
5159               * ******************************************************************************
5160               *
5161               * Name: MVEIT (Part 3 of 9)
5162               * Type: Subroutine
5163               * Category: Moving
5164               * Summary: Move current ship: Move ship forward according to its speed
5165               *
5166               * ------------------------------------------------------------------------------
5167               *
5168               * This routine has multiple stages. This stage does the following:
5169               *
5170               * * Move the ship forward (along the vector pointing in the direction of
5171               * travel) according to its speed:
5172               *
5173               * (x, y, z) += nosev_hi * speed / 64
5174               *
5175               * ******************************************************************************
5176               
5177 1856 D360  22        movb @INWK+27,ra                ; LDA INWK+27       ; Set Q = the ship's speed byte #27 * 4
     1858 006E     
5178                      .asla                           ; ASL A
     **** ****     > ASLA
0001 185A 024D  14        andi ra,>ff00
     185C FF00     
0002 185E 0A1D  14        sla  ra,1
                   < elite.a99
5179                      .asla                           ; ASL A
     **** ****     > ASLA
0001 1860 024D  14        andi ra,>ff00
     1862 FF00     
0002 1864 0A1D  14        sla  ra,1
                   < elite.a99
5180 1866 D80D  22        movb ra,@Q                      ; STA Q
     1868 0090     
5181               
5182 186A D360  22        movb @INWK+10,ra                ; LDA INWK+10       ; Set A = |nosev_x_hi|
     186C 005D     
5183 186E 024D  14        andi ra,>7f*256                 ; AND #%01111111
     1870 7F00     
5184               
5185 1872 0200  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     1874 43EC     
5186 1876 06A0  24        bl   @jsr                       ;
     1878 FE28     
5187 187A D80D  22        movb ra,@R                      ; STA R             ; = |nosev_x_hi| * speed / 64
     187C 0091     
5188               
5189 187E D360  22        movb @INWK+10,ra                ; LDA INWK+10       ; If nosev_x_hi is positive, then:
     1880 005D     
5190 1882 020E  12        li   rx,>00*256                 ; LDX #0            ;
     1884 0000     
5191 1886 0200  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + R
     1888 1BCC     
5192 188A 06A0  24        bl   @jsr                       ;
     188C FE28     
5193                                                                          ;
5194                                                                          ; If nosev_x_hi is negative, then:
5195                                                                          ;
5196                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - R
5197                                                                          ;
5198                                                                          ; So in effect, this does:
5199                                                                          ;
5200                                                                          ; (x_sign x_hi x_lo) += nosev_x_hi * speed / 64
5201               
5202 188E D360  22        movb @INWK+12,ra                ; LDA INWK+12       ; Set A = |nosev_y_hi|
     1890 005F     
5203 1892 024D  14        andi ra,>7f*256                 ; AND #%01111111
     1894 7F00     
5204               
5205 1896 0200  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     1898 43EC     
5206 189A 06A0  24        bl   @jsr                       ;
     189C FE28     
5207 189E D80D  22        movb ra,@R                      ; STA R             ; = |nosev_y_hi| * speed / 64
     18A0 0091     
5208               
5209 18A2 D360  22        movb @INWK+12,ra                ; LDA INWK+12       ; If nosev_y_hi is positive, then:
     18A4 005F     
5210 18A6 020E  12        li   rx,>03*256                 ; LDX #3            ;
     18A8 0300     
5211 18AA 0200  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (y_sign y_hi y_lo) = (y_sign y_hi y_lo) + R
     18AC 1BCC     
5212 18AE 06A0  24        bl   @jsr                       ;
     18B0 FE28     
5213                                                                          ;
5214                                                                          ; If nosev_y_hi is negative, then:
5215                                                                          ;
5216                                                                          ; (y_sign y_hi y_lo) = (y_sign y_hi y_lo) - R
5217                                                                          ;
5218                                                                          ; So in effect, this does:
5219                                                                          ;
5220                                                                          ; (y_sign y_hi y_lo) += nosev_y_hi * speed / 64
5221               
5222 18B2 D360  22        movb @INWK+14,ra                ; LDA INWK+14       ; Set A = |nosev_z_hi|
     18B4 0061     
5223 18B6 024D  14        andi ra,>7f*256                 ; AND #%01111111
     18B8 7F00     
5224               
5225 18BA 0200  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     18BC 43EC     
5226 18BE 06A0  24        bl   @jsr                       ;
     18C0 FE28     
5227 18C2 D80D  22        movb ra,@R                      ; STA R             ; = |nosev_z_hi| * speed / 64
     18C4 0091     
5228               
5229 18C6 D360  22        movb @INWK+14,ra                ; LDA INWK+14       ; If nosev_y_hi is positive, then:
     18C8 0061     
5230 18CA 020E  12        li   rx,>06*256                 ; LDX #6            ;
     18CC 0600     
5231 18CE 0200  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + R
     18D0 1BCC     
5232 18D2 06A0  24        bl   @jsr                       ;
     18D4 FE28     
5233                                                                          ;
5234                                                                          ; If nosev_z_hi is negative, then:
5235                                                                          ;
5236                                                                          ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) - R
5237                                                                          ;
5238                                                                          ; So in effect, this does:
5239                                                                          ;
5240                                                                          ; (z_sign z_hi z_lo) += nosev_z_hi * speed / 64
5241               
5242               * ******************************************************************************
5243               *
5244               * Name: MVEIT (Part 4 of 9)
5245               * Type: Subroutine
5246               * Category: Moving
5247               * Summary: Move current ship: Apply acceleration to ship's speed as a one-off
5248               *
5249               * ------------------------------------------------------------------------------
5250               *
5251               * This routine has multiple stages. This stage does the following:
5252               *
5253               * * Apply acceleration to the ship's speed (if acceleration is non-zero),
5254               * and then zero the acceleration as it's a one-off change
5255               *
5256               * ******************************************************************************
5257               
5258 18D6 D360  22        movb @INWK+27,ra                ; LDA INWK+27       ; Set A = the ship's speed in byte #24 + the ship's
     18D8 006E     
5259                      .clc                            ; CLC               ; acceleration in byte #28
     **** ****     > CLC
0001 18DA 0A16  14        sla  rzero,1
                   < elite.a99
5260                      .adc @INWK+28,ra                ; ADC INWK+28
     **** ****     > ADC
0001 18DC 1701  10        jnc  !
0002 18DE B347  14        ab   rone,ra
0003               !:
0004 18E0 B360  22        ab   @INWK+28,ra
     18E2 006F     
                   < elite.a99
5261               
5262 18E4 1502  10        jgt  B15                        ; BPL B15           ; If the result is positive, skip the following
5263                                                                          ; instruction
5264               
5265 18E6 020D  12        li   ra,>00*256                 ; LDA #0            ; Set A to 0 to stop the speed from going negative
     18E8 0000     
5266               
5267               B15:
5268 18EA 020F  12        li   ry,>0f*256                 ; LDY #15           ; We now fetch byte #15 from the ship's blueprint, which
     18EC 0F00     
5269                                                                          ; contains the ship's maximum speed, so set Y = 15 to
5270                                                                          ; use as an index
5271               
5272                      .cmp_ind_y_idx @XX0,ra          ; CMP (XX0),Y       ; If A < the ship's maximum speed, skip the following
     **** ****     > CMP_IND_Y_IDX
0001 18EE D820  30        movb @XX0,@rtmplb
     18F0 001E     
     18F2 8301     
0002 18F4 D020  22        movb @XX0+1,rtmp
     18F6 001F     
0003 18F8 06CF  10        swpb ry
0004 18FA A00F  14        a    ry,rtmp
0005 18FC 06CF  10        swpb ry
0006 18FE D010  22        movb *rtmp,rtmp
0007 1900 900D  14        cb   ra,rtmp
                   < elite.a99
5273 1902 1709  10        jnc  B16                        ; BCC B16           ; instruction
5274               
5275                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; Set A to the ship's maximum speed
     **** ****     > LD_IND_Y_IDX
0001 1904 D820  30        movb @XX0,@rtmplb
     1906 001E     
     1908 8301     
0002 190A D020  22        movb @XX0+1,rtmp
     190C 001F     
0003 190E 06CF  10        swpb ry
0004 1910 A00F  14        a    ry,rtmp
0005 1912 06CF  10        swpb ry
0006 1914 D350  22        movb *rtmp,RA
                   < elite.a99
5276               
5277               B16:
5278 1916 D80D  22        movb ra,@INWK+27                ; STA INWK+27       ; We have now calculated the new ship's speed after
     1918 006E     
5279                                                                          ; accelerating and keeping the speed within the ship's
5280                                                                          ; limits, so store the updated speed in byte #27
5281               
5282 191A 020D  12        li   ra,>00*256                 ; LDA #0            ; We have added the ship's acceleration, so we now set
     191C 0000     
5283 191E D80D  22        movb ra,@INWK+28                ; STA INWK+28       ; it back to 0 in byte #28, as it's a one-off change
     1920 006F     
5284               
5285               * ******************************************************************************
5286               *
5287               * Name: MVEIT (Part 5 of 9)
5288               * Type: Subroutine
5289               * Category: Moving
5290               * Summary: Move current ship: Rotate ship's location by our pitch and roll
5291               * Deep dive: Rotating the universe
5292               *
5293               * ------------------------------------------------------------------------------
5294               *
5295               * This routine has multiple stages. This stage does the following:
5296               *
5297               * * Rotate the ship's location in space by the amount of pitch and roll of
5298               * our ship. See below for a deeper explanation of this routine
5299               *
5300               * ******************************************************************************
5301               
5302 1922 D3A0  22        movb @ALP1,rx                   ; LDX ALP1          ; Fetch the magnitude of the current roll into X, so
     1924 0087     
5303                                                                          ; if the roll angle is alpha, X contains |alpha|
5304               
5305 1926 D360  22        movb @INWK,ra                   ; LDA INWK          ; Set P = ~x_lo (i.e. with all its bits flipped) so that
     1928 0053     
5306                      .eoi (>ff*256)                  ; EOR #%11111111    ; we can pass x_lo to MLTU2 below)
     **** ****     > EOI
0001 192A 0200  12        li   rtmp,(>FF*256)
     192C FF00     
0002 192E 2B40  14        xor  rtmp,ra
                   < elite.a99
5307 1930 D80D  22        movb ra,@P                      ; STA P
     1932 001B     
5308               
5309 1934 D360  22        movb @INWK+1,ra                 ; LDA INWK+1        ; Set A = x_hi
     1936 0054     
5310               
5311 1938 0200  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     193A 4432     
5312 193C 06A0  24        bl   @jsr                       ;
     193E FE28     
5313                                                                          ; = (x_hi x_lo) * alpha
5314               
5315 1940 D80D  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     1942 001D     
5316                                                                          ; have:
5317                                                                          ;
5318                                                                          ; P(2 1 0) = (x_hi x_lo) * alpha
5319               
5320 1944 D360  22        movb @ALP2+1,ra                 ; LDA ALP2+1        ; Fetch the flipped sign of the current roll angle alpha
     1946 0089     
5321                      .eor @INWK+2                    ; EOR INWK+2        ; from ALP2+1 and EOR with byte #2 (x_sign), so if the
     **** ****     > EOR
0001 1948 D020  22        movb @INWK+2,rtmp
     194A 0055     
0002 194C 2B40  14        xor  rtmp,ra
                   < elite.a99
5322                                                                          ; flipped roll angle and x_sign have the same sign, A
5323                                                                          ; will be positive, else it will be negative. So A will
5324                                                                          ; contain the sign bit of x_sign * flipped alpha sign,
5325                                                                          ; which is the opposite to the sign of the above result,
5326                                                                          ; so we now have:
5327                                                                          ;
5328                                                                          ; (A P+2 P+1) = - (x_sign x_hi x_lo) * alpha / 256
5329               
5330 194E 020E  12        li   rx,>03*256                 ; LDX #3            ; Set (A P+2 P+1) = (y_sign y_hi y_lo) + (A P+2 P+1)
     1950 0300     
5331 1952 0200  12        li   rtmp,MVT6                  ; JSR MVT6          ; = y - x * alpha / 256
     1954 1F9E     
5332 1956 06A0  24        bl   @jsr                       ;
     1958 FE28     
5333               
5334 195A D80D  22        movb ra,@K2+3                   ; STA K2+3          ; Set K2(3) = A = the sign of the result
     195C 00AF     
5335               
5336 195E D360  22        movb @P+1,ra                    ; LDA P+1           ; Set K2(1) = P+1, the low byte of the result
     1960 001C     
5337 1962 D80D  22        movb ra,@K2+1                   ; STA K2+1
     1964 00AD     
5338               
5339                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set P = ~K2+1 (i.e. with all its bits flipped) so
     **** ****     > EOI
0001 1966 0200  12        li   rtmp,(>FF*256)
     1968 FF00     
0002 196A 2B40  14        xor  rtmp,ra
                   < elite.a99
5340 196C D80D  22        movb ra,@P                      ; STA P             ; that we can pass K2+1 to MLTU2 below)
     196E 001B     
5341               
5342 1970 D360  22        movb @P+2,ra                    ; LDA P+2           ; Set K2(2) = A = P+2
     1972 001D     
5343 1974 D80D  22        movb ra,@K2+2                   ; STA K2+2
     1976 00AE     
5344               
5345                                                                          ; So we now have result 1 above:
5346                                                                          ;
5347                                                                          ; K2(3 2 1) = (A P+2 P+1)
5348                                                                          ; = y - x * alpha / 256
5349               
5350 1978 D3A0  22        movb @BET1,rx                   ; LDX BET1          ; Fetch the magnitude of the current pitch into X, so
     197A 002B     
5351                                                                          ; if the pitch angle is beta, X contains |beta|
5352               
5353 197C 0200  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     197E 4432     
5354 1980 06A0  24        bl   @jsr                       ;
     1982 FE28     
5355                                                                          ; = K2(2 1) * beta
5356               
5357 1984 D80D  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     1986 001D     
5358                                                                          ; have:
5359                                                                          ;
5360                                                                          ; P(2 1 0) = K2(2 1) * beta
5361               
5362 1988 D360  22        movb @K2+3,ra                   ; LDA K2+3          ; Fetch the sign of the above result in K(3 2 1) from
     198A 00AF     
5363                      .eor @BET2                      ; EOR BET2          ; K2+3 and EOR with BET2, the sign of the current pitch
     **** ****     > EOR
0001 198C D020  22        movb @BET2,rtmp
     198E 008A     
0002 1990 2B40  14        xor  rtmp,ra
                   < elite.a99
5364                                                                          ; rate, so if the pitch and K(3 2 1) have the same sign,
5365                                                                          ; A will be positive, else it will be negative. So A
5366                                                                          ; will contain the sign bit of K(3 2 1) * beta, which is
5367                                                                          ; the same as the sign of the above result, so we now
5368                                                                          ; have:
5369                                                                          ;
5370                                                                          ; (A P+2 P+1) = K2(3 2 1) * beta / 256
5371               
5372 1992 020E  12        li   rx,>06*256                 ; LDX #6            ; Set (A P+2 P+1) = (z_sign z_hi z_lo) + (A P+2 P+1)
     1994 0600     
5373 1996 0200  12        li   rtmp,MVT6                  ; JSR MVT6          ; = z + K2 * beta / 256
     1998 1F9E     
5374 199A 06A0  24        bl   @jsr                       ;
     199C FE28     
5375               
5376 199E D80D  22        movb ra,@INWK+8                 ; STA INWK+8        ; Set z_sign = A = the sign of the result
     19A0 005B     
5377               
5378 19A2 D360  22        movb @P+1,ra                    ; LDA P+1           ; Set z_lo = P+1, the low byte of the result
     19A4 001C     
5379 19A6 D80D  22        movb ra,@INWK+6                 ; STA INWK+6
     19A8 0059     
5380               
5381                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set P = ~z_lo (i.e. with all its bits flipped) so that
     **** ****     > EOI
0001 19AA 0200  12        li   rtmp,(>FF*256)
     19AC FF00     
0002 19AE 2B40  14        xor  rtmp,ra
                   < elite.a99
5382 19B0 D80D  22        movb ra,@P                      ; STA P             ; we can pass z_lo to MLTU2 below)
     19B2 001B     
5383               
5384 19B4 D360  22        movb @P+2,ra                    ; LDA P+2           ; Set z_hi = P+2
     19B6 001D     
5385 19B8 D80D  22        movb ra,@INWK+7                 ; STA INWK+7
     19BA 005A     
5386               
5387                                                                          ; So we now have result 2 above:
5388                                                                          ;
5389                                                                          ; (z_sign z_hi z_lo) = (A P+2 P+1)
5390                                                                          ; = z + K2 * beta / 256
5391               
5392 19BC 0200  12        li   rtmp,MLTU2                 ; JSR MLTU2         ; MLTU2 doesn't change Q, and Q was set to beta in
     19BE 4434     
5393 19C0 06A0  24        bl   @jsr                       ;
     19C2 FE28     
5394                                                                          ; the previous call to MLTU2, so this call does:
5395                                                                          ;
5396                                                                          ; (A P+1 P) = (A ~P) * Q
5397                                                                          ; = (z_hi z_lo) * beta
5398               
5399 19C4 D80D  22        movb ra,@P+2                    ; STA P+2           ; Set P+2 = A = the high byte of the result, so we
     19C6 001D     
5400                                                                          ; now have:
5401                                                                          ;
5402                                                                          ; P(2 1 0) = (z_hi z_lo) * beta
5403               
5404 19C8 D360  22        movb @K2+3,ra                   ; LDA K2+3          ; Set y_sign = K2+3
     19CA 00AF     
5405 19CC D80D  22        movb ra,@INWK+5                 ; STA INWK+5
     19CE 0058     
5406               
5407                      .eor @BET2                      ; EOR BET2          ; EOR y_sign with BET2, the sign of the current pitch
     **** ****     > EOR
0001 19D0 D020  22        movb @BET2,rtmp
     19D2 008A     
0002 19D4 2B40  14        xor  rtmp,ra
                   < elite.a99
5408                      .eor @INWK+8                    ; EOR INWK+8        ; rate, and z_sign. If the result is positive jump to
     **** ****     > EOR
0001 19D6 D020  22        movb @INWK+8,rtmp
     19D8 005B     
0002 19DA 2B40  14        xor  rtmp,ra
                   < elite.a99
5409 19DC 1512  10        jgt  MV43                       ; BPL MV43          ; MV43, otherwise this means beta * z and y have
5410                                                                          ; different signs, i.e. P(2 1) and K2(3 2 1) have
5411                                                                          ; different signs, so we need to add them in order to
5412                                                                          ; calculate K2(2 1) - P(2 1)
5413               
5414 19DE D360  22        movb @P+1,ra                    ; LDA P+1           ; Set (y_hi y_lo) = K2(2 1) + P(2 1)
     19E0 001C     
5415                      .adc @K2+1,ra                   ; ADC K2+1
     **** ****     > ADC
0001 19E2 1701  10        jnc  !
0002 19E4 B347  14        ab   rone,ra
0003               !:
0004 19E6 B360  22        ab   @K2+1,ra
     19E8 00AD     
                   < elite.a99
5416 19EA D80D  22        movb ra,@INWK+3                 ; STA INWK+3
     19EC 0056     
5417 19EE D360  22        movb @P+2,ra                    ; LDA P+2
     19F0 001D     
5418                      .adc @K2+2,ra                   ; ADC K2+2
     **** ****     > ADC
0001 19F2 1701  10        jnc  !
0002 19F4 B347  14        ab   rone,ra
0003               !:
0004 19F6 B360  22        ab   @K2+2,ra
     19F8 00AE     
                   < elite.a99
5419 19FA D80D  22        movb ra,@INWK+4                 ; STA INWK+4
     19FC 0057     
5420               
5421 19FE 0460  16        b    @MV44                      ; JMP MV44          ; Jump to MV44 to continue the calculation
     1A00 1A52     
5422               
5423               MV43:
5424 1A02 D360  22        movb @K2+1,ra                   ; LDA K2+1          ; Reversing the logic above, we need to subtract P(2 1)
     1A04 00AD     
5425                      .sbc @P+1,ra                    ; SBC P+1           ; and K2(3 2 1) to calculate K2(2 1) - P(2 1), so this
     **** ****     > SBC
0001 1A06 1801  10        joc  !
0002 1A08 7347  14        sb   rone,ra
0003               !:
0004 1A0A 7360  22        sb   @P+1,ra
     1A0C 001C     
                   < elite.a99
5426 1A0E D80D  22        movb ra,@INWK+3                 ; STA INWK+3        ; sets (y_hi y_lo) = K2(2 1) - P(2 1)
     1A10 0056     
5427 1A12 D360  22        movb @K2+2,ra                   ; LDA K2+2
     1A14 00AE     
5428                      .sbc @P+2,ra                    ; SBC P+2
     **** ****     > SBC
0001 1A16 1801  10        joc  !
0002 1A18 7347  14        sb   rone,ra
0003               !:
0004 1A1A 7360  22        sb   @P+2,ra
     1A1C 001D     
                   < elite.a99
5429 1A1E D80D  22        movb ra,@INWK+4                 ; STA INWK+4
     1A20 0057     
5430               
5431 1A22 1817  10        joc  MV44                       ; BCS MV44          ; If the above subtraction did not underflow, then
5432                                                                          ; jump to MV44, otherwise we need to negate the result
5433               
5434 1A24 020D  12        li   ra,>01*256                 ; LDA #1            ; Negate (y_sign y_hi y_lo) using two's complement,
     1A26 0100     
5435                      .sbc @INWK+3,ra                 ; SBC INWK+3        ; first doing the low bytes:
     **** ****     > SBC
0001 1A28 1801  10        joc  !
0002 1A2A 7347  14        sb   rone,ra
0003               !:
0004 1A2C 7360  22        sb   @INWK+3,ra
     1A2E 0056     
                   < elite.a99
5436 1A30 D80D  22        movb ra,@INWK+3                 ; STA INWK+3        ;
     1A32 0056     
5437                                                                          ; y_lo = 1 - y_lo
5438               
5439 1A34 020D  12        li   ra,>00*256                 ; LDA #0            ; Then the high bytes:
     1A36 0000     
5440                      .sbc @INWK+4,ra                 ; SBC INWK+4        ;
     **** ****     > SBC
0001 1A38 1801  10        joc  !
0002 1A3A 7347  14        sb   rone,ra
0003               !:
0004 1A3C 7360  22        sb   @INWK+4,ra
     1A3E 0057     
                   < elite.a99
5441 1A40 D80D  22        movb ra,@INWK+4                 ; STA INWK+4        ; y_hi = 0 - y_hi
     1A42 0057     
5442               
5443 1A44 D360  22        movb @INWK+5,ra                 ; LDA INWK+5        ; And finally flip the sign in y_sign
     1A46 0058     
5444                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1A48 0200  12        li   rtmp,(>80*256)
     1A4A 8000     
0002 1A4C 2B40  14        xor  rtmp,ra
                   < elite.a99
5445 1A4E D80D  22        movb ra,@INWK+5                 ; STA INWK+5
     1A50 0058     
5446               
5447               MV44:
5448                                                                          ; So we now have result 3 above:
5449                                                                          ;
5450                                                                          ; (y_sign y_hi y_lo) = K2(2 1) - P(2 1)
5451                                                                          ; = K2 - beta * z
5452 1A52 D3A0  22        movb @ALP1,rx                   ; LDX ALP1          ; Fetch the magnitude of the current roll into X, so
     1A54 0087     
5453                                                                          ; if the roll angle is alpha, X contains |alpha|
5454               
5455 1A56 D360  22        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P = ~y_lo (i.e. with all its bits flipped) so that
     1A58 0056     
5456                      .eoi (>ff*256)                  ; EOR #&FF          ; we can pass y_lo to MLTU2 below)
     **** ****     > EOI
0001 1A5A 0200  12        li   rtmp,(>FF*256)
     1A5C FF00     
0002 1A5E 2B40  14        xor  rtmp,ra
                   < elite.a99
5457 1A60 D80D  22        movb ra,@P                      ; STA P
     1A62 001B     
5458               
5459 1A64 D360  22        movb @INWK+4,ra                 ; LDA INWK+4        ; Set A = y_hi
     1A66 0057     
5460               
5461 1A68 0200  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     1A6A 4432     
5462 1A6C 06A0  24        bl   @jsr                       ;
     1A6E FE28     
5463                                                                          ; = (y_hi y_lo) * alpha
5464               
5465 1A70 D80D  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     1A72 001D     
5466                                                                          ; have:
5467                                                                          ;
5468                                                                          ; P(2 1 0) = (y_hi y_lo) * alpha
5469               
5470 1A74 D360  22        movb @ALP2,ra                   ; LDA ALP2          ; Fetch the correct sign of the current roll angle alpha
     1A76 0088     
5471                      .eor @INWK+5                    ; EOR INWK+5        ; from ALP2 and EOR with byte #5 (y_sign), so if the
     **** ****     > EOR
0001 1A78 D020  22        movb @INWK+5,rtmp
     1A7A 0058     
0002 1A7C 2B40  14        xor  rtmp,ra
                   < elite.a99
5472                                                                          ; correct roll angle and y_sign have the same sign, A
5473                                                                          ; will be positive, else it will be negative. So A will
5474                                                                          ; contain the sign bit of x_sign * correct alpha sign,
5475                                                                          ; which is the same as the sign of the above result,
5476                                                                          ; so we now have:
5477                                                                          ;
5478                                                                          ; (A P+2 P+1) = (y_sign y_hi y_lo) * alpha / 256
5479               
5480 1A7E 020E  12        li   rx,>00*256                 ; LDX #0            ; Set (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
     1A80 0000     
5481 1A82 0200  12        li   rtmp,MVT6                  ; JSR MVT6          ; = x + y * alpha / 256
     1A84 1F9E     
5482 1A86 06A0  24        bl   @jsr                       ;
     1A88 FE28     
5483               
5484 1A8A D80D  22        movb ra,@INWK+2                 ; STA INWK+2        ; Set x_sign = A = the sign of the result
     1A8C 0055     
5485               
5486 1A8E D360  22        movb @P+2,ra                    ; LDA P+2           ; Set x_hi = P+2, the high byte of the result
     1A90 001D     
5487 1A92 D80D  22        movb ra,@INWK+1                 ; STA INWK+1
     1A94 0054     
5488               
5489 1A96 D360  22        movb @P+1,ra                    ; LDA P+1           ; Set x_lo = P+1, the low byte of the result
     1A98 001C     
5490 1A9A D80D  22        movb ra,@INWK                   ; STA INWK
     1A9C 0053     
5491               
5492                                                                          ; So we now have result 4 above:
5493                                                                          ;
5494                                                                          ; x = x + alpha * y
5495                                                                          ;
5496                                                                          ; and the rotation of (x, y, z) is done
5497               
5498               * ******************************************************************************
5499               *
5500               * Name: MVEIT (Part 6 of 9)
5501               * Type: Subroutine
5502               * Category: Moving
5503               * Summary: Move current ship: Move the ship in space according to our speed
5504               *
5505               * ------------------------------------------------------------------------------
5506               *
5507               * This routine has multiple stages. This stage does the following:
5508               *
5509               * * Move the ship in space according to our speed (we already moved it
5510               * according to its own speed in part 3).
5511               *
5512               * We do this by subtracting our speed (i.e. the distance we travel in this
5513               * iteration of the loop) from the other ship's z-coordinate. We subtract because
5514               * they appear to be "moving" in the opposite direction to us, and the whole
5515               * MVEIT routine is about moving the other ships rather than us (even though we
5516               * are the one doing the moving).
5517               *
5518               * ------------------------------------------------------------------------------
5519               *
5520               * Other entry points:
5521               *
5522               * MV45                Rejoin the MVEIT routine after the rotation, tactics and
5523               * scanner code
5524               *
5525               * ******************************************************************************
5526               
5527               MV45:
5528 1A9E D360  22        movb @DELTA,ra                  ; LDA DELTA         ; Set R to our speed in DELTA
     1AA0 008C     
5529 1AA2 D80D  22        movb ra,@R                      ; STA R
     1AA4 0091     
5530               
5531 1AA6 020D  12        li   ra,>80*256                 ; LDA #%10000000    ; Set A to zeroes but with bit 7 set, so that (A R) is
     1AA8 8000     
5532                                                                          ; a 16-bit number containing -R, or -speed
5533               
5534 1AAA 020E  12        li   rx,>06*256                 ; LDX #6            ; Set X to the z-axis so the call to MVT1 does this:
     1AAC 0600     
5535 1AAE 0200  12        li   rtmp,MVT1                  ; JSR MVT1          ;
     1AB0 1BCE     
5536 1AB2 06A0  24        bl   @jsr                       ;
     1AB4 FE28     
5537                                                                          ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + (A R)
5538                                                                          ; = (z_sign z_hi z_lo) - speed
5539               
5540 1AB6 D360  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is not the sun (129) then skip the
     1AB8 009B     
5541 1ABA 024D  14        andi ra,>81*256                 ; AND #%10000001    ; next instruction, otherwise return from the subroutine
     1ABC 8100     
5542 1ABE 028D  14        ci   ra,>81*256                 ; CMP #129          ; as we don't need to rotate the sun around its origin.
     1AC0 8100     
5543 1AC2 1602  10        jne  B17                        ; BNE B17           ; Having both the AND and the CMP is a little odd, as
5544                                                                          ; the sun is the only ship type with bits 0 and 7 set,
5545                                                                          ; so the AND has no effect and could be removed
5546               
5547 1AC4 0460  20        b    @rts                       ; RTS               ; Return from the subroutine, as the ship we are moving
     1AC6 FE34     
5548                                                                          ; is the sun and doesn't need any of the following
5549               
5550               * ******************************************************************************
5551               *
5552               * Name: MVEIT (Part 7 of 9)
5553               * Type: Subroutine
5554               * Category: Moving
5555               * Summary: Move current ship: Rotate ship's orientation vectors by pitch/roll
5556               * Deep dive: Orientation vectors
5557               * Pitching and rolling
5558               *
5559               * ------------------------------------------------------------------------------
5560               *
5561               * This routine has multiple stages. This stage does the following:
5562               *
5563               * * Rotate the ship's orientation vectors according to our pitch and roll
5564               *
5565               * As with the previous step, this is all about moving the other ships rather
5566               * than us (even though we are the one doing the moving). So we rotate the
5567               * current ship's orientation vectors (which defines its orientation in space),
5568               * by the angles we are "moving" the rest of the sky through (alpha and beta, our
5569               * roll and pitch), so the ship appears to us to be stationary while we rotate.
5570               *
5571               * ******************************************************************************
5572               
5573               B17:
5574 1AC8 020F  12        li   ry,>09*256                 ; LDY #9            ; Apply our pitch and roll rotations to the current
     1ACA 0900     
5575 1ACC 0200  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's nosev vector
     1ACE 1D8C     
5576 1AD0 06A0  24        bl   @jsr                       ;
     1AD2 FE28     
5577               
5578 1AD4 020F  12        li   ry,>0f*256                 ; LDY #15           ; Apply our pitch and roll rotations to the current
     1AD6 0F00     
5579 1AD8 0200  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's roofv vector
     1ADA 1D8C     
5580 1ADC 06A0  24        bl   @jsr                       ;
     1ADE FE28     
5581               
5582 1AE0 020F  12        li   ry,>15*256                 ; LDY #21           ; Apply our pitch and roll rotations to the current
     1AE2 1500     
5583 1AE4 0200  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's sidev vector
     1AE6 1D8C     
5584 1AE8 06A0  24        bl   @jsr                       ;
     1AEA FE28     
5585               
5586               * ******************************************************************************
5587               *
5588               * Name: MVEIT (Part 8 of 9)
5589               * Type: Subroutine
5590               * Category: Moving
5591               * Summary: Move current ship: Rotate ship about itself by its own pitch/roll
5592               * Deep dive: Orientation vectors
5593               * Pitching and rolling by a fixed angle
5594               *
5595               * ------------------------------------------------------------------------------
5596               *
5597               * This routine has multiple stages. This stage does the following:
5598               *
5599               * * If the ship we are processing is rolling or pitching itself, rotate it and
5600               * apply damping if required
5601               *
5602               * ******************************************************************************
5603               
5604 1AEC D360  22        movb @INWK+30,ra                ; LDA INWK+30       ; Fetch the ship's pitch counter and extract the sign
     1AEE 0071     
5605 1AF0 024D  14        andi ra,>80*256                 ; AND #%10000000    ; into RAT2
     1AF2 8000     
5606 1AF4 D80D  22        movb ra,@RAT2                   ; STA RAT2
     1AF6 00AB     
5607               
5608 1AF8 D360  22        movb @INWK+30,ra                ; LDA INWK+30       ; Fetch the ship's pitch counter and extract the value
     1AFA 0071     
5609 1AFC 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; without the sign bit into A
     1AFE 7F00     
5610               
5611 1B00 1322  10        jeq  MV8                        ; BEQ MV8           ; If the pitch counter is 0, then jump to MV8 to skip
5612                                                                          ; the following, as the ship is not pitching
5613               
5614 1B02 028D  14        ci   ra,>7f*256                 ; CMP #%01111111    ; If bits 0-6 are set in the pitch counter (i.e. the
     1B04 7F00     
5615                                                                          ; ship's pitch is not damping down), then the C flag
5616                                                                          ; will be set by this instruction
5617               
5618                      .sbi (>00*256)                  ; SBC #0            ; Set A = A - 0 - (1 - C), so if we are damping then we
     **** ****     > SBI
0001 1B06 1801  10        joc  !
0002 1B08 7347  14        sb   rone,ra
0003               !:
0004 1B0A 022D  14        ai   ra,-(>00*256)
     1B0C 0000     
                   < elite.a99
5619                                                                          ; reduce A by 1, otherwise it is unchanged
5620               
5621 1B0E F360  22        socb @RAT2,ra                   ; ORA RAT2          ; Change bit 7 of A to the sign we saved in RAT2, so
     1B10 00AB     
5622                                                                          ; the updated pitch counter in A retains its sign
5623               
5624 1B12 D80D  22        movb ra,@INWK+30                ; STA INWK+30       ; Store the updated pitch counter in byte #30
     1B14 0071     
5625               
5626 1B16 020E  12        li   rx,>0f*256                 ; LDX #15           ; Rotate (roofv_x, nosev_x) by a small angle (pitch)
     1B18 0F00     
5627 1B1A 020F  12        li   ry,>09*256                 ; LDY #9
     1B1C 0900     
5628 1B1E 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B20 1E58     
5629 1B22 06A0  24        bl   @jsr                       ;
     1B24 FE28     
5630               
5631 1B26 020E  12        li   rx,>11*256                 ; LDX #17           ; Rotate (roofv_y, nosev_y) by a small angle (pitch)
     1B28 1100     
5632 1B2A 020F  12        li   ry,>0b*256                 ; LDY #11
     1B2C 0B00     
5633 1B2E 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B30 1E58     
5634 1B32 06A0  24        bl   @jsr                       ;
     1B34 FE28     
5635               
5636 1B36 020E  12        li   rx,>13*256                 ; LDX #19           ; Rotate (roofv_z, nosev_z) by a small angle (pitch)
     1B38 1300     
5637 1B3A 020F  12        li   ry,>0d*256                 ; LDY #13
     1B3C 0D00     
5638 1B3E 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B40 1E58     
5639 1B42 06A0  24        bl   @jsr                       ;
     1B44 FE28     
5640               
5641               MV8:
5642 1B46 D360  22        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the ship's roll counter and extract the sign
     1B48 0070     
5643 1B4A 024D  14        andi ra,>80*256                 ; AND #%10000000    ; into RAT2
     1B4C 8000     
5644 1B4E D80D  22        movb ra,@RAT2                   ; STA RAT2
     1B50 00AB     
5645               
5646 1B52 D360  22        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the ship's roll counter and extract the value
     1B54 0070     
5647 1B56 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; without the sign bit into A
     1B58 7F00     
5648               
5649 1B5A 1322  10        jeq  MV5                        ; BEQ MV5           ; If the roll counter is 0, then jump to MV5 to skip the
5650                                                                          ; following, as the ship is not rolling
5651               
5652 1B5C 028D  14        ci   ra,>7f*256                 ; CMP #%01111111    ; If bits 0-6 are set in the roll counter (i.e. the
     1B5E 7F00     
5653                                                                          ; ship's roll is not damping down), then the C flag
5654                                                                          ; will be set by this instruction
5655               
5656                      .sbi (>00*256)                  ; SBC #0            ; Set A = A - 0 - (1 - C), so if we are damping then we
     **** ****     > SBI
0001 1B60 1801  10        joc  !
0002 1B62 7347  14        sb   rone,ra
0003               !:
0004 1B64 022D  14        ai   ra,-(>00*256)
     1B66 0000     
                   < elite.a99
5657                                                                          ; reduce A by 1, otherwise it is unchanged
5658               
5659 1B68 F360  22        socb @RAT2,ra                   ; ORA RAT2          ; Change bit 7 of A to the sign we saved in RAT2, so
     1B6A 00AB     
5660                                                                          ; the updated roll counter in A retains its sign
5661               
5662 1B6C D80D  22        movb ra,@INWK+29                ; STA INWK+29       ; Store the updated pitch counter in byte #29
     1B6E 0070     
5663               
5664 1B70 020E  12        li   rx,>0f*256                 ; LDX #15           ; Rotate (roofv_x, sidev_x) by a small angle (roll)
     1B72 0F00     
5665 1B74 020F  12        li   ry,>15*256                 ; LDY #21
     1B76 1500     
5666 1B78 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B7A 1E58     
5667 1B7C 06A0  24        bl   @jsr                       ;
     1B7E FE28     
5668               
5669 1B80 020E  12        li   rx,>11*256                 ; LDX #17           ; Rotate (roofv_y, sidev_y) by a small angle (roll)
     1B82 1100     
5670 1B84 020F  12        li   ry,>17*256                 ; LDY #23
     1B86 1700     
5671 1B88 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B8A 1E58     
5672 1B8C 06A0  24        bl   @jsr                       ;
     1B8E FE28     
5673               
5674 1B90 020E  12        li   rx,>13*256                 ; LDX #19           ; Rotate (roofv_z, sidev_z) by a small angle (roll)
     1B92 1300     
5675 1B94 020F  12        li   ry,>19*256                 ; LDY #25
     1B96 1900     
5676 1B98 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B9A 1E58     
5677 1B9C 06A0  24        bl   @jsr                       ;
     1B9E FE28     
5678               
5679               * ******************************************************************************
5680               *
5681               * Name: MVEIT (Part 9 of 9)
5682               * Type: Subroutine
5683               * Category: Moving
5684               * Summary: Move current ship: Redraw on scanner, if it hasn't been destroyed
5685               *
5686               * ------------------------------------------------------------------------------
5687               *
5688               * This routine has multiple stages. This stage does the following:
5689               *
5690               * * If the ship is exploding or being removed, hide it on the scanner
5691               *
5692               * * Otherwise redraw the ship on the scanner, now that it's been moved
5693               *
5694               * ******************************************************************************
5695               
5696               MV5:
5697 1BA0 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the ship's exploding/killed state from byte #31
     1BA2 0072     
5698               
5699 1BA4 024D  14        andi ra,>a0*256                 ; AND #%10100000    ; If we are exploding or removing this ship then jump to
     1BA6 A000     
5700 1BA8 1608  10        jne  MVD1                       ; BNE MVD1          ; MVD1 to remove it from the scanner permanently
5701               
5702 1BAA D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 4 to keep the ship visible on the scanner
     1BAC 0072     
5703 1BAE 026D  14        ori  ra,>10*256                 ; ORA #%00010000
     1BB0 1000     
5704 1BB2 D80D  22        movb ra,@INWK+31                ; STA INWK+31
     1BB4 0072     
5705               
5706 1BB6 0460  20        b    @SCAN                      ; JMP SCAN          ; Display the ship on the scanner, returning from the
     1BB8 4D3E     
5707                                                                          ; subroutine using a tail call
5708               
5709               MVD1:
5710 1BBA D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Clear bit 4 to hide the ship on the scanner
     1BBC 0072     
5711 1BBE 024D  14        andi ra,>ef*256                 ; AND #%11101111
     1BC0 EF00     
5712 1BC2 D80D  22        movb ra,@INWK+31                ; STA INWK+31
     1BC4 0072     
5713               
5714 1BC6 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1BC8 FE34     
5715               
5716               * ******************************************************************************
5717               *
5718               * Name: MVT1
5719               * Type: Subroutine
5720               * Category: Moving
5721               * Summary: Calculate (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
5722               *
5723               * ------------------------------------------------------------------------------
5724               *
5725               * Add the signed delta (A R) to a ship's coordinate, along the axis given in X.
5726               * Mathematically speaking, this routine translates the ship along a single axis
5727               * by a signed delta. Taking the example of X = 0, the x-axis, it does the
5728               * following:
5729               *
5730               * (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
5731               *
5732               * (In practice, MVT1 is only ever called directly with A = 0 or 128, otherwise
5733               * it is always called via MVT-2, which clears A apart from the sign bit. The
5734               * routine is written to cope with a non-zero delta_hi, so it supports a full
5735               * 16-bit delta, but it appears that delta_hi is only ever used to hold the
5736               * sign of the delta.)
5737               *
5738               * The comments below assume we are adding delta to the x-axis, though the axis
5739               * is determined by the value of X.
5740               *
5741               * ------------------------------------------------------------------------------
5742               *
5743               * Arguments:
5744               *
5745               * (A R)               The signed delta, so A = delta_hi and R = delta_lo
5746               *
5747               * X                   Determines which coordinate axis of INWK to change:
5748               *
5749               * * X = 0 adds the delta to (x_lo, x_hi, x_sign)
5750               *
5751               * * X = 3 adds the delta to (y_lo, y_hi, y_sign)
5752               *
5753               * * X = 6 adds the delta to (z_lo, z_hi, z_sign)
5754               *
5755               * ------------------------------------------------------------------------------
5756               *
5757               * Other entry points:
5758               *
5759               * MVT1-2              Clear bits 0-6 of A before entering MVT1
5760               *
5761               * ******************************************************************************
5762               
5763 1BCA 024D  14        andi ra,>80*256                 ; AND #%10000000    ; Clear bits 0-6 of A
     1BCC 8000     
5764               
5765               MVT1:
5766                      .asla                           ; ASL A             ; Set the C flag to the sign bit of the delta, leaving
     **** ****     > ASLA
0001 1BCE 024D  14        andi ra,>ff00
     1BD0 FF00     
0002 1BD2 0A1D  14        sla  ra,1
                   < elite.a99
5767                                                                          ; delta_hi << 1 in A
5768               
5769 1BD4 D80D  22        movb ra,@S                      ; STA S             ; Set S = delta_hi << 1
     1BD6 0092     
5770                                                                          ;
5771                                                                          ; This also clears bit 0 of S
5772               
5773 1BD8 020D  12        li   ra,>00*256                 ; LDA #0            ; Set T = just the sign bit of delta (in bit 7)
     1BDA 0000     
5774 1BDC 06A0  24        bl   @rora                      ; ROR A
     1BDE FE62     
5775 1BE0 D80D  22        movb ra,@T                      ; STA T
     1BE2 00D1     
5776               
5777                      .lsr @S                         ; LSR S             ; Set S = delta_hi >> 1
     **** ****     > LSR
0001 1BE4 D020  22        movb @S,rtmp
     1BE6 0092     
0002 1BE8 0910  14        srl  rtmp,1
0003 1BEA D800  22        movb rtmp,@S
     1BEC 0092     
                   < elite.a99
5778                                                                          ; = |delta_hi|
5779                                                                          ;
5780                                                                          ; This also clear the C flag, as we know that bit 0 of
5781                                                                          ; S was clear before the LSR
5782               
5783                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; If T EOR x_sign has bit 7 set, then x_sign and delta
     **** ****     > EOR
0001 1BEE D02E  26        movb @INWK+2(RX),rtmp
     1BF0 0055     
0002 1BF2 2B40  14        xor  rtmp,ra
                   < elite.a99
5784 1BF4 111C  10        jlt  MV10                       ; BMI MV10          ; have different signs, so jump to MV10
5785               
5786                                                                          ; At this point, we know x_sign and delta have the same
5787                                                                          ; sign, that sign is in T, and S contains |delta_hi|,
5788                                                                          ; so now we want to do:
5789                                                                          ;
5790                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (S R)
5791                                                                          ;
5792                                                                          ; and then set the sign of the result to the same sign
5793                                                                          ; as x_sign and delta
5794               
5795 1BF6 D360  22        movb @R,ra                      ; LDA R             ; First we add the low bytes, so:
     1BF8 0091     
5796                      .adc @INWK(rx),ra               ; ADC INWK,X        ;
     **** ****     > ADC
0001 1BFA 1701  10        jnc  !
0002 1BFC B347  14        ab   rone,ra
0003               !:
0004 1BFE B36E  26        ab   @INWK(RX),ra
     1C00 0053     
                   < elite.a99
5797 1C02 DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X        ; x_lo = x_lo + R
     1C04 0053     
5798               
5799 1C06 D360  22        movb @S,ra                      ; LDA S             ; Then we add the high bytes:
     1C08 0092     
5800                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X      ;
     **** ****     > ADC
0001 1C0A 1701  10        jnc  !
0002 1C0C B347  14        ab   rone,ra
0003               !:
0004 1C0E B36E  26        ab   @INWK+1(RX),ra
     1C10 0054     
                   < elite.a99
5801 1C12 DB8D  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = x_hi + S
     1C14 0054     
5802               
5803 1C16 D36E  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally we add any carry into x_sign, and if the
     1C18 0055     
5804                      .adi (>00*256)                  ; ADC #0            ; sign of x_sign and delta in T is negative, make sure
     **** ****     > ADI
0001 1C1A 1701  10        jnc  !
0002 1C1C B347  14        ab   rone,ra
0003               !:
0004 1C1E 022D  14        ai   ra,(>00*256)
     1C20 0000     
                   < elite.a99
5805 1C22 F360  22        socb @T,ra                      ; ORA T             ; the result is negative (by OR'ing with T)
     1C24 00D1     
5806 1C26 DB8D  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X
     1C28 0055     
5807               
5808 1C2A 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1C2C FE34     
5809               
5810               MV10:
5811                                                                          ; If we get here, we know x_sign and delta have
5812                                                                          ; different signs, with delta's sign in T, and
5813                                                                          ; |delta_hi| in S, so now we want to do:
5814                                                                          ;
5815                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - (S R)
5816                                                                          ;
5817                                                                          ; and then set the sign of the result according to
5818                                                                          ; the signs of x_sign and delta
5819 1C2E D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; First we subtract the low bytes, so:
     1C30 0053     
5820                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1C32 0A18  14        sla  rmone,1
                   < elite.a99
5821                      .sbc @R,ra                      ; SBC R             ; x_lo = x_lo - R
     **** ****     > SBC
0001 1C34 1801  10        joc  !
0002 1C36 7347  14        sb   rone,ra
0003               !:
0004 1C38 7360  22        sb   @R,ra
     1C3A 0091     
                   < elite.a99
5822 1C3C DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X
     1C3E 0053     
5823               
5824 1C40 D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Then we subtract the high bytes:
     1C42 0054     
5825                      .sbc @S,ra                      ; SBC S             ;
     **** ****     > SBC
0001 1C44 1801  10        joc  !
0002 1C46 7347  14        sb   rone,ra
0003               !:
0004 1C48 7360  22        sb   @S,ra
     1C4A 0092     
                   < elite.a99
5826 1C4C DB8D  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = x_hi - S
     1C4E 0054     
5827               
5828 1C50 D36E  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally we subtract any borrow from bits 0-6 of
     1C52 0055     
5829 1C54 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; x_sign, and give the result the opposite sign bit to T
     1C56 7F00     
5830                      .sbi (>00*256)                  ; SBC #0            ; (i.e. give it the sign of the original x_sign)
     **** ****     > SBI
0001 1C58 1801  10        joc  !
0002 1C5A 7347  14        sb   rone,ra
0003               !:
0004 1C5C 022D  14        ai   ra,-(>00*256)
     1C5E 0000     
                   < elite.a99
5831 1C60 026D  14        ori  ra,>80*256                 ; ORA #%10000000
     1C62 8000     
5832                      .eor @T                         ; EOR T
     **** ****     > EOR
0001 1C64 D020  22        movb @T,rtmp
     1C66 00D1     
0002 1C68 2B40  14        xor  rtmp,ra
                   < elite.a99
5833 1C6A DB8D  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X
     1C6C 0055     
5834               
5835 1C6E 181C  10        joc  MV11                       ; BCS MV11          ; If the C flag is set by the above SBC, then our sum
5836                                                                          ; above didn't underflow and is correct - to put it
5837                                                                          ; another way, (x_sign x_hi x_lo) >= (S R) so the result
5838                                                                          ; should indeed have the same sign as x_sign, so jump to
5839                                                                          ; MV11 to return from the subroutine
5840               
5841                                                                          ; Otherwise our subtraction underflowed because
5842                                                                          ; (x_sign x_hi x_lo) < (S R), so we now need to flip the
5843                                                                          ; subtraction around by using two's complement to this:
5844                                                                          ;
5845                                                                          ; (S R) - (x_sign x_hi x_lo)
5846                                                                          ;
5847                                                                          ; and then we need to give the result the same sign as
5848                                                                          ; (S R), the delta, as that's the dominant figure in the
5849                                                                          ; sum
5850               
5851 1C70 020D  12        li   ra,>01*256                 ; LDA #1            ; First we subtract the low bytes, so:
     1C72 0100     
5852                      .sbc @INWK(rx),ra               ; SBC INWK,X        ;
     **** ****     > SBC
0001 1C74 1801  10        joc  !
0002 1C76 7347  14        sb   rone,ra
0003               !:
0004 1C78 736E  26        sb   @INWK(RX),ra
     1C7A 0053     
                   < elite.a99
5853 1C7C DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X        ; x_lo = 1 - x_lo
     1C7E 0053     
5854               
5855 1C80 020D  12        li   ra,>00*256                 ; LDA #0            ; Then we subtract the high bytes:
     1C82 0000     
5856                      .sbc @INWK+1(rx),ra             ; SBC INWK+1,X      ;
     **** ****     > SBC
0001 1C84 1801  10        joc  !
0002 1C86 7347  14        sb   rone,ra
0003               !:
0004 1C88 736E  26        sb   @INWK+1(RX),ra
     1C8A 0054     
                   < elite.a99
5857 1C8C DB8D  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = 0 - x_hi
     1C8E 0054     
5858               
5859 1C90 020D  12        li   ra,>00*256                 ; LDA #0            ; And then we subtract the sign bytes:
     1C92 0000     
5860                      .sbc @INWK+2(rx),ra             ; SBC INWK+2,X      ;
     **** ****     > SBC
0001 1C94 1801  10        joc  !
0002 1C96 7347  14        sb   rone,ra
0003               !:
0004 1C98 736E  26        sb   @INWK+2(RX),ra
     1C9A 0055     
                   < elite.a99
5861                                                                          ; x_sign = 0 - x_sign
5862               
5863 1C9C 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Finally, we set the sign bit to the sign in T, the
     1C9E 7F00     
5864 1CA0 F360  22        socb @T,ra                      ; ORA T             ; sign of the original delta, as the delta is the
     1CA2 00D1     
5865 1CA4 DB8D  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X      ; dominant figure in the sum
     1CA6 0055     
5866               
5867               MV11:
5868 1CA8 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1CAA FE34     
5869               
5870               * ******************************************************************************
5871               *
5872               * Name: MVT3
5873               * Type: Subroutine
5874               * Category: Moving
5875               * Summary: Calculate K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
5876               *
5877               * ------------------------------------------------------------------------------
5878               *
5879               * Add an INWK position coordinate - i.e. x, y or z - to K(3 2 1), like this:
5880               *
5881               * K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
5882               *
5883               * The INWK coordinate to add to K(3 2 1) is specified by X.
5884               *
5885               * ------------------------------------------------------------------------------
5886               *
5887               * Arguments:
5888               *
5889               * X                   The coordinate to add to K(3 2 1), as follows:
5890               *
5891               * * If X = 0, add (x_sign x_hi x_lo)
5892               *
5893               * * If X = 3, add (y_sign y_hi y_lo)
5894               *
5895               * * If X = 6, add (z_sign z_hi z_lo)
5896               *
5897               * ------------------------------------------------------------------------------
5898               *
5899               * Returns:
5900               *
5901               * A                   Contains a copy of the high byte of the result, K+3
5902               *
5903               * X                   X is preserved
5904               *
5905               * ******************************************************************************
5906               
5907               MVT3:
5908 1CAC D360  22        movb @K+3,ra                    ; LDA K+3           ; Set S = K+3
     1CAE 0040     
5909 1CB0 D80D  22        movb ra,@S                      ; STA S
     1CB2 0092     
5910               
5911 1CB4 024D  14        andi ra,>80*256                 ; AND #%10000000    ; Set T = sign bit of K(3 2 1)
     1CB6 8000     
5912 1CB8 D80D  22        movb ra,@T                      ; STA T
     1CBA 00D1     
5913               
5914                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; If x_sign has a different sign to K(3 2 1), jump to
     **** ****     > EOR
0001 1CBC D02E  26        movb @INWK+2(RX),rtmp
     1CBE 0055     
0002 1CC0 2B40  14        xor  rtmp,ra
                   < elite.a99
5915 1CC2 111F  10        jlt  MV13                       ; BMI MV13          ; MV13 to process the addition as a subtraction
5916               
5917 1CC4 D360  22        movb @K+1,ra                    ; LDA K+1           ; Set K(3 2 1) = K(3 2 1) + (x_sign x_hi x_lo)
     1CC6 003E     
5918                      .clc                            ; CLC               ; starting with the low bytes
     **** ****     > CLC
0001 1CC8 0A16  14        sla  rzero,1
                   < elite.a99
5919                      .adc @INWK(rx),ra               ; ADC INWK,X
     **** ****     > ADC
0001 1CCA 1701  10        jnc  !
0002 1CCC B347  14        ab   rone,ra
0003               !:
0004 1CCE B36E  26        ab   @INWK(RX),ra
     1CD0 0053     
                   < elite.a99
5920 1CD2 D80D  22        movb ra,@K+1                    ; STA K+1
     1CD4 003E     
5921               
5922 1CD6 D360  22        movb @K+2,ra                    ; LDA K+2           ; Then the middle bytes
     1CD8 003F     
5923                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X
     **** ****     > ADC
0001 1CDA 1701  10        jnc  !
0002 1CDC B347  14        ab   rone,ra
0003               !:
0004 1CDE B36E  26        ab   @INWK+1(RX),ra
     1CE0 0054     
                   < elite.a99
5924 1CE2 D80D  22        movb ra,@K+2                    ; STA K+2
     1CE4 003F     
5925               
5926 1CE6 D360  22        movb @K+3,ra                    ; LDA K+3           ; And finally the high bytes
     1CE8 0040     
5927                      .adc @INWK+2(rx),ra             ; ADC INWK+2,X
     **** ****     > ADC
0001 1CEA 1701  10        jnc  !
0002 1CEC B347  14        ab   rone,ra
0003               !:
0004 1CEE B36E  26        ab   @INWK+2(RX),ra
     1CF0 0055     
                   < elite.a99
5928               
5929 1CF2 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Setting the sign bit of K+3 to T, the original sign
     1CF4 7F00     
5930 1CF6 F360  22        socb @T,ra                      ; ORA T             ; of K(3 2 1)
     1CF8 00D1     
5931 1CFA D80D  22        movb ra,@K+3                    ; STA K+3
     1CFC 0040     
5932               
5933 1CFE 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1D00 FE34     
5934               
5935               MV13:
5936 1D02 D360  22        movb @S,ra                      ; LDA S             ; Set S = |K+3| (i.e. K+3 with the sign bit cleared)
     1D04 0092     
5937 1D06 024D  14        andi ra,>7f*256                 ; AND #%01111111
     1D08 7F00     
5938 1D0A D80D  22        movb ra,@S                      ; STA S
     1D0C 0092     
5939               
5940 1D0E D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Set K(3 2 1) = (x_sign x_hi x_lo) - K(3 2 1)
     1D10 0053     
5941                      .sec                            ; SEC               ; starting with the low bytes
     **** ****     > SEC
0001 1D12 0A18  14        sla  rmone,1
                   < elite.a99
5942                      .sbc @K+1,ra                    ; SBC K+1
     **** ****     > SBC
0001 1D14 1801  10        joc  !
0002 1D16 7347  14        sb   rone,ra
0003               !:
0004 1D18 7360  22        sb   @K+1,ra
     1D1A 003E     
                   < elite.a99
5943 1D1C D80D  22        movb ra,@K+1                    ; STA K+1
     1D1E 003E     
5944               
5945 1D20 D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Then the middle bytes
     1D22 0054     
5946                      .sbc @K+2,ra                    ; SBC K+2
     **** ****     > SBC
0001 1D24 1801  10        joc  !
0002 1D26 7347  14        sb   rone,ra
0003               !:
0004 1D28 7360  22        sb   @K+2,ra
     1D2A 003F     
                   < elite.a99
5947 1D2C D80D  22        movb ra,@K+2                    ; STA K+2
     1D2E 003F     
5948               
5949 1D30 D36E  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally the high bytes, doing A = |x_sign| - |K+3|
     1D32 0055     
5950 1D34 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; and setting the C flag for testing below
     1D36 7F00     
5951                      .sbc @S,ra                      ; SBC S
     **** ****     > SBC
0001 1D38 1801  10        joc  !
0002 1D3A 7347  14        sb   rone,ra
0003               !:
0004 1D3C 7360  22        sb   @S,ra
     1D3E 0092     
                   < elite.a99
5952               
5953 1D40 026D  14        ori  ra,>80*256                 ; ORA #%10000000    ; Set the sign bit of K+3 to the opposite sign of T,
     1D42 8000     
5954                      .eor @T                         ; EOR T             ; i.e. the opposite sign to the original K(3 2 1)
     **** ****     > EOR
0001 1D44 D020  22        movb @T,rtmp
     1D46 00D1     
0002 1D48 2B40  14        xor  rtmp,ra
                   < elite.a99
5955 1D4A D80D  22        movb ra,@K+3                    ; STA K+3
     1D4C 0040     
5956               
5957 1D4E 181C  10        joc  MV14                       ; BCS MV14          ; If the C flag is set, i.e. |x_sign| >= |K+3|, then
5958                                                                          ; the sign of K(3 2 1). In this case, we want the
5959                                                                          ; result to have the same sign as the largest argument,
5960                                                                          ; which is (x_sign x_hi x_lo), which we know has the
5961                                                                          ; opposite sign to K(3 2 1), and that's what we just set
5962                                                                          ; the sign of K(3 2 1) to... so we can jump to MV14 to
5963                                                                          ; return from the subroutine
5964               
5965 1D50 020D  12        li   ra,>01*256                 ; LDA #1            ; We need to swap the sign of the result in K(3 2 1),
     1D52 0100     
5966                      .sbc @K+1,ra                    ; SBC K+1           ; which we do by calculating 0 - K(3 2 1), which we can
     **** ****     > SBC
0001 1D54 1801  10        joc  !
0002 1D56 7347  14        sb   rone,ra
0003               !:
0004 1D58 7360  22        sb   @K+1,ra
     1D5A 003E     
                   < elite.a99
5967 1D5C D80D  22        movb ra,@K+1                    ; STA K+1           ; do with 1 - C - K(3 2 1), as we know the C flag is
     1D5E 003E     
5968                                                                          ; clear. We start with the low bytes
5969               
5970 1D60 020D  12        li   ra,>00*256                 ; LDA #0            ; Then the middle bytes
     1D62 0000     
5971                      .sbc @K+2,ra                    ; SBC K+2
     **** ****     > SBC
0001 1D64 1801  10        joc  !
0002 1D66 7347  14        sb   rone,ra
0003               !:
0004 1D68 7360  22        sb   @K+2,ra
     1D6A 003F     
                   < elite.a99
5972 1D6C D80D  22        movb ra,@K+2                    ; STA K+2
     1D6E 003F     
5973               
5974 1D70 020D  12        li   ra,>00*256                 ; LDA #0            ; And finally the high bytes
     1D72 0000     
5975                      .sbc @K+3,ra                    ; SBC K+3
     **** ****     > SBC
0001 1D74 1801  10        joc  !
0002 1D76 7347  14        sb   rone,ra
0003               !:
0004 1D78 7360  22        sb   @K+3,ra
     1D7A 0040     
                   < elite.a99
5976               
5977 1D7C 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Set the sign bit of K+3 to the same sign as T,
     1D7E 7F00     
5978 1D80 F360  22        socb @T,ra                      ; ORA T             ; i.e. the same sign as the original K(3 2 1), as
     1D82 00D1     
5979 1D84 D80D  22        movb ra,@K+3                    ; STA K+3           ; that's the largest argument
     1D86 0040     
5980               
5981               MV14:
5982 1D88 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1D8A FE34     
5983               
5984               * ******************************************************************************
5985               *
5986               * Name: MVS4
5987               * Type: Subroutine
5988               * Category: Moving
5989               * Summary: Apply pitch and roll to an orientation vector
5990               * Deep dive: Orientation vectors
5991               * Pitching and rolling
5992               *
5993               * ------------------------------------------------------------------------------
5994               *
5995               * Apply pitch and roll angles alpha and beta to the orientation vector in Y.
5996               *
5997               * Specifically, this routine rotates a point (x, y, z) around the origin by
5998               * pitch alpha and roll beta, using the small angle approximation to make the
5999               * maths easier, and incorporating the Minsky circle algorithm to make the
6000               * rotation more stable (though more elliptic).
6001               *
6002               * If that paragraph makes sense to you, then you should probably be writing
6003               * this commentary! For the rest of us, there's a detailed explanation of all
6004               * this in the deep dive on "Pitching and rolling".
6005               *
6006               * ------------------------------------------------------------------------------
6007               *
6008               * Arguments:
6009               *
6010               * Y                   Determines which of the INWK orientation vectors to
6011               * transform:
6012               *
6013               * * Y = 9 rotates nosev: (nosev_x, nosev_y, nosev_z)
6014               *
6015               * * Y = 15 rotates roofv: (roofv_x, roofv_y, roofv_z)
6016               *
6017               * * Y = 21 rotates sidev: (sidev_x, sidev_y, sidev_z)
6018               *
6019               * ******************************************************************************
6020               
6021               MVS4:
6022 1D8C D360  22        movb @ALPHA,ra                  ; LDA ALPHA         ; Set Q = alpha (the roll angle to rotate through)
     1D8E 009E     
6023 1D90 D80D  22        movb ra,@Q                      ; STA Q
     1D92 0090     
6024               
6025 1D94 D3AF  26        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set (S R) = nosev_y
     1D96 0055     
6026 1D98 D80E  22        movb rx,@R                      ; STX R
     1D9A 0091     
6027 1D9C D3AF  26        movb @INWK+3(ry),rx             ; LDX INWK+3,Y
     1D9E 0056     
6028 1DA0 D80E  22        movb rx,@S                      ; STX S
     1DA2 0092     
6029               
6030 1DA4 D3AF  26        movb @INWK(ry),rx               ; LDX INWK,Y        ; These instructions have no effect as MAD overwrites
     1DA6 0053     
6031 1DA8 D80E  22        movb rx,@P                      ; STX P             ; X and P when called, but they set X = P = nosev_x_lo
     1DAA 001B     
6032               
6033 1DAC D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Set A = -nosev_x_hi
     1DAE 0054     
6034                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1DB0 0200  12        li   rtmp,(>80*256)
     1DB2 8000     
0002 1DB4 2B40  14        xor  rtmp,ra
                   < elite.a99
6035               
6036 1DB6 0200  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1DB8 4566     
6037 1DBA 06A0  24        bl   @jsr                       ;
     1DBC FE28     
6038 1DBE DBCD  30        movb ra,@INWK+3(ry)             ; STA INWK+3,Y      ; = alpha * -nosev_x_hi + nosev_y
     1DC0 0056     
6039 1DC2 DBCE  30        movb rx,@INWK+2(ry)             ; STX INWK+2,Y      ;
     1DC4 0055     
6040                                                                          ; and store (A X) in nosev_y, so this does:
6041                                                                          ;
6042                                                                          ; nosev_y = nosev_y - alpha * nosev_x_hi
6043               
6044 1DC6 D80E  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1DC8 001B     
6045                                                                          ; but it sets P = nosev_y_lo
6046               
6047 1DCA D3AF  26        movb @INWK(ry),rx               ; LDX INWK,Y        ; Set (S R) = nosev_x
     1DCC 0053     
6048 1DCE D80E  22        movb rx,@R                      ; STX R
     1DD0 0091     
6049 1DD2 D3AF  26        movb @INWK+1(ry),rx             ; LDX INWK+1,Y
     1DD4 0054     
6050 1DD6 D80E  22        movb rx,@S                      ; STX S
     1DD8 0092     
6051               
6052 1DDA D36F  26        movb @INWK+3(ry),ra             ; LDA INWK+3,Y      ; Set A = nosev_y_hi
     1DDC 0056     
6053               
6054 1DDE 0200  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1DE0 4566     
6055 1DE2 06A0  24        bl   @jsr                       ;
     1DE4 FE28     
6056 1DE6 DBCD  30        movb ra,@INWK+1(ry)             ; STA INWK+1,Y      ; = alpha * nosev_y_hi + nosev_x
     1DE8 0054     
6057 1DEA DBCE  30        movb rx,@INWK(ry)               ; STX INWK,Y        ;
     1DEC 0053     
6058                                                                          ; and store (A X) in nosev_x, so this does:
6059                                                                          ;
6060                                                                          ; nosev_x = nosev_x + alpha * nosev_y_hi
6061               
6062 1DEE D80E  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1DF0 001B     
6063                                                                          ; but it sets P = nosev_x_lo
6064               
6065 1DF2 D360  22        movb @BETA,ra                   ; LDA BETA          ; Set Q = beta (the pitch angle to rotate through)
     1DF4 002A     
6066 1DF6 D80D  22        movb ra,@Q                      ; STA Q
     1DF8 0090     
6067               
6068 1DFA D3AF  26        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set (S R) = nosev_y
     1DFC 0055     
6069 1DFE D80E  22        movb rx,@R                      ; STX R
     1E00 0091     
6070 1E02 D3AF  26        movb @INWK+3(ry),rx             ; LDX INWK+3,Y
     1E04 0056     
6071 1E06 D80E  22        movb rx,@S                      ; STX S
     1E08 0092     
6072 1E0A D3AF  26        movb @INWK+4(ry),rx             ; LDX INWK+4,Y
     1E0C 0057     
6073               
6074 1E0E D80E  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1E10 001B     
6075                                                                          ; but it sets P = nosev_y
6076               
6077 1E12 D36F  26        movb @INWK+5(ry),ra             ; LDA INWK+5,Y      ; Set A = -nosev_z_hi
     1E14 0058     
6078                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1E16 0200  12        li   rtmp,(>80*256)
     1E18 8000     
0002 1E1A 2B40  14        xor  rtmp,ra
                   < elite.a99
6079               
6080 1E1C 0200  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1E1E 4566     
6081 1E20 06A0  24        bl   @jsr                       ;
     1E22 FE28     
6082 1E24 DBCD  30        movb ra,@INWK+3(ry)             ; STA INWK+3,Y      ; = beta * -nosev_z_hi + nosev_y
     1E26 0056     
6083 1E28 DBCE  30        movb rx,@INWK+2(ry)             ; STX INWK+2,Y      ;
     1E2A 0055     
6084                                                                          ; and store (A X) in nosev_y, so this does:
6085                                                                          ;
6086                                                                          ; nosev_y = nosev_y - beta * nosev_z_hi
6087               
6088 1E2C D80E  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1E2E 001B     
6089                                                                          ; but it sets P = nosev_y_lo
6090               
6091 1E30 D3AF  26        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; Set (S R) = nosev_z
     1E32 0057     
6092 1E34 D80E  22        movb rx,@R                      ; STX R
     1E36 0091     
6093 1E38 D3AF  26        movb @INWK+5(ry),rx             ; LDX INWK+5,Y
     1E3A 0058     
6094 1E3C D80E  22        movb rx,@S                      ; STX S
     1E3E 0092     
6095               
6096 1E40 D36F  26        movb @INWK+3(ry),ra             ; LDA INWK+3,Y      ; Set A = nosev_y_hi
     1E42 0056     
6097               
6098 1E44 0200  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1E46 4566     
6099 1E48 06A0  24        bl   @jsr                       ;
     1E4A FE28     
6100 1E4C DBCD  30        movb ra,@INWK+5(ry)             ; STA INWK+5,Y      ; = beta * nosev_y_hi + nosev_z
     1E4E 0058     
6101 1E50 DBCE  30        movb rx,@INWK+4(ry)             ; STX INWK+4,Y      ;
     1E52 0057     
6102                                                                          ; and store (A X) in nosev_z, so this does:
6103                                                                          ;
6104                                                                          ; nosev_z = nosev_z + beta * nosev_y_hi
6105               
6106 1E54 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1E56 FE34     
6107               
6108               * ******************************************************************************
6109               *
6110               * Name: MVS5
6111               * Type: Subroutine
6112               * Category: Moving
6113               * Summary: Apply a 3.6 degree pitch or roll to an orientation vector
6114               * Deep dive: Orientation vectors
6115               * Pitching and rolling by a fixed angle
6116               *
6117               * ------------------------------------------------------------------------------
6118               *
6119               * Pitch or roll a ship by a small, fixed amount (1/16 radians, or 3.6 degrees),
6120               * in a specified direction, by rotating the orientation vectors. The vectors to
6121               * rotate are given in X and Y, and the direction of the rotation is given in
6122               * RAT2. The calculation is as follows:
6123               *
6124               * * If the direction is positive:
6125               *
6126               * X = X * (1 - 1/512) + Y / 16
6127               * Y = Y * (1 - 1/512) - X / 16
6128               *
6129               * * If the direction is negative:
6130               *
6131               * X = X * (1 - 1/512) - Y / 16
6132               * Y = Y * (1 - 1/512) + X / 16
6133               *
6134               * So if X = 15 (roofv_x), Y = 21 (sidev_x) and RAT2 is positive, it does this:
6135               *
6136               * roofv_x = roofv_x * (1 - 1/512)  + sidev_x / 16
6137               * sidev_x = sidev_x * (1 - 1/512)  - roofv_x / 16
6138               *
6139               * ------------------------------------------------------------------------------
6140               *
6141               * Arguments:
6142               *
6143               * X                   The first vector to rotate:
6144               *
6145               * * If X = 15, rotate roofv_x
6146               *
6147               * * If X = 17, rotate roofv_y
6148               *
6149               * * If X = 19, rotate roofv_z
6150               *
6151               * * If X = 21, rotate sidev_x
6152               *
6153               * * If X = 23, rotate sidev_y
6154               *
6155               * * If X = 25, rotate sidev_z
6156               *
6157               * Y                   The second vector to rotate:
6158               *
6159               * * If Y = 9,  rotate nosev_x
6160               *
6161               * * If Y = 11, rotate nosev_y
6162               *
6163               * * If Y = 13, rotate nosev_z
6164               *
6165               * * If Y = 21, rotate sidev_x
6166               *
6167               * * If Y = 23, rotate sidev_y
6168               *
6169               * * If Y = 25, rotate sidev_z
6170               *
6171               * RAT2                The direction of the pitch or roll to perform, positive
6172               * or negative (i.e. the sign of the roll or pitch counter
6173               * in bit 7)
6174               *
6175               * ******************************************************************************
6176               
6177               MVS5:
6178 1E58 D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch roofv_x_hi, clear the sign bit, divide by 2 and
     1E5A 0054     
6179 1E5C 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; store in T, so:
     1E5E 7F00     
6180 1E60 091D  14        srl  ra,1                       ; LSR A             ;
6181 1E62 D80D  22        movb ra,@T                      ; STA T             ; T = |roofv_x_hi| / 2
     1E64 00D1     
6182                                                                          ; = |roofv_x| / 512
6183                                                                          ;
6184                                                                          ; The above is true because:
6185                                                                          ;
6186                                                                          ; |roofv_x| = |roofv_x_hi| * 256 + roofv_x_lo
6187                                                                          ;
6188                                                                          ; so:
6189                                                                          ;
6190                                                                          ; |roofv_x| / 512 = |roofv_x_hi| * 256 / 512
6191                                                                          ; + roofv_x_lo / 512
6192                                                                          ; = |roofv_x_hi| / 2
6193               
6194 1E66 D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Now we do the following subtraction:
     1E68 0053     
6195                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1E6A 0A18  14        sla  rmone,1
                   < elite.a99
6196                      .sbc @T,ra                      ; SBC T             ; (S R) = (roofv_x_hi roofv_x_lo) - |roofv_x| / 512
     **** ****     > SBC
0001 1E6C 1801  10        joc  !
0002 1E6E 7347  14        sb   rone,ra
0003               !:
0004 1E70 7360  22        sb   @T,ra
     1E72 00D1     
                   < elite.a99
6197 1E74 D80D  22        movb ra,@R                      ; STA R             ; = (1 - 1/512) * roofv_x
     1E76 0091     
6198                                                                          ;
6199                                                                          ; by doing the low bytes first
6200               
6201 1E78 D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; And then the high bytes (the high byte of the right
     1E7A 0054     
6202                      .sbi (>00*256)                  ; SBC #0            ; side of the subtraction being 0)
     **** ****     > SBI
0001 1E7C 1801  10        joc  !
0002 1E7E 7347  14        sb   rone,ra
0003               !:
0004 1E80 022D  14        ai   ra,-(>00*256)
     1E82 0000     
                   < elite.a99
6203 1E84 D80D  22        movb ra,@S                      ; STA S
     1E86 0092     
6204               
6205 1E88 D36F  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Set P = nosev_x_lo
     1E8A 0053     
6206 1E8C D80D  22        movb ra,@P                      ; STA P
     1E8E 001B     
6207               
6208 1E90 D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch the sign of nosev_x_hi (bit 7) and store in T
     1E92 0054     
6209 1E94 024D  14        andi ra,>80*256                 ; AND #%10000000
     1E96 8000     
6210 1E98 D80D  22        movb ra,@T                      ; STA T
     1E9A 00D1     
6211               
6212 1E9C D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch nosev_x_hi into A and clear the sign bit, so
     1E9E 0054     
6213 1EA0 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; A = |nosev_x_hi|
     1EA2 7F00     
6214               
6215 1EA4 091D  14        srl  ra,1                       ; LSR A             ; Set (A P) = (A P) / 16
6216 1EA6 0204  12        li   rarg1,P                    ; ROR P             ; = |nosev_x_hi nosev_x_lo| / 16
     1EA8 001B     
6217 1EAA 06A0  24        bl   @ror                       ;
     1EAC FE7A     
6218 1EAE 091D  14        srl  ra,1                       ; LSR A             ; = |nosev_x| / 16
6219 1EB0 0204  12        li   rarg1,P                    ; ROR P
     1EB2 001B     
6220 1EB4 06A0  24        bl   @ror                       ;
     1EB6 FE7A     
6221 1EB8 091D  14        srl  ra,1                       ; LSR A
6222 1EBA 0204  12        li   rarg1,P                    ; ROR P
     1EBC 001B     
6223 1EBE 06A0  24        bl   @ror                       ;
     1EC0 FE7A     
6224 1EC2 091D  14        srl  ra,1                       ; LSR A
6225 1EC4 0204  12        li   rarg1,P                    ; ROR P
     1EC6 001B     
6226 1EC8 06A0  24        bl   @ror                       ;
     1ECA FE7A     
6227               
6228 1ECC F360  22        socb @T,ra                      ; ORA T             ; Set the sign of A to the sign in T (i.e. the sign of
     1ECE 00D1     
6229                                                                          ; the original nosev_x), so now:
6230                                                                          ;
6231                                                                          ; (A P) = nosev_x / 16
6232               
6233                      .eor @RAT2                      ; EOR RAT2          ; Give it the sign as if we multiplied by the direction
     **** ****     > EOR
0001 1ED0 D020  22        movb @RAT2,rtmp
     1ED2 00AB     
0002 1ED4 2B40  14        xor  rtmp,ra
                   < elite.a99
6234                                                                          ; by the pitch or roll direction
6235               
6236 1ED6 D80E  22        movb rx,@Q                      ; STX Q             ; Store the value of X so it can be restored after the
     1ED8 0090     
6237                                                                          ; call to ADD
6238               
6239 1EDA 0200  12        li   rtmp,ADD                   ; JSR ADD           ; (A X) = (A P) + (S R)
     1EDC 456E     
6240 1EDE 06A0  24        bl   @jsr                       ;
     1EE0 FE28     
6241                                                                          ; = +/-nosev_x / 16 + (1 - 1/512) * roofv_x
6242               
6243 1EE2 D80D  22        movb ra,@K+1                    ; STA K+1           ; Set K(1 0) = (1 - 1/512) * roofv_x +/- nosev_x / 16
     1EE4 003E     
6244 1EE6 D80E  22        movb rx,@K                      ; STX K
     1EE8 003D     
6245               
6246 1EEA D3A0  22        movb @Q,rx                      ; LDX Q             ; Restore the value of X from before the call to ADD
     1EEC 0090     
6247               
6248 1EEE D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch nosev_x_hi, clear the sign bit, divide by 2 and
     1EF0 0054     
6249 1EF2 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; store in T, so:
     1EF4 7F00     
6250 1EF6 091D  14        srl  ra,1                       ; LSR A             ;
6251 1EF8 D80D  22        movb ra,@T                      ; STA T             ; T = |nosev_x_hi| / 2
     1EFA 00D1     
6252                                                                          ; = |nosev_x| / 512
6253               
6254 1EFC D36F  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Now we do the following subtraction:
     1EFE 0053     
6255                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1F00 0A18  14        sla  rmone,1
                   < elite.a99
6256                      .sbc @T,ra                      ; SBC T             ; (S R) = (nosev_x_hi nosev_x_lo) - |nosev_x| / 512
     **** ****     > SBC
0001 1F02 1801  10        joc  !
0002 1F04 7347  14        sb   rone,ra
0003               !:
0004 1F06 7360  22        sb   @T,ra
     1F08 00D1     
                   < elite.a99
6257 1F0A D80D  22        movb ra,@R                      ; STA R             ; = (1 - 1/512) * nosev_x
     1F0C 0091     
6258                                                                          ;
6259                                                                          ; by doing the low bytes first
6260               
6261 1F0E D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; And then the high bytes (the high byte of the right
     1F10 0054     
6262                      .sbi (>00*256)                  ; SBC #0            ; side of the subtraction being 0)
     **** ****     > SBI
0001 1F12 1801  10        joc  !
0002 1F14 7347  14        sb   rone,ra
0003               !:
0004 1F16 022D  14        ai   ra,-(>00*256)
     1F18 0000     
                   < elite.a99
6263 1F1A D80D  22        movb ra,@S                      ; STA S
     1F1C 0092     
6264               
6265 1F1E D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Set P = roofv_x_lo
     1F20 0053     
6266 1F22 D80D  22        movb ra,@P                      ; STA P
     1F24 001B     
6267               
6268 1F26 D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch the sign of roofv_x_hi (bit 7) and store in T
     1F28 0054     
6269 1F2A 024D  14        andi ra,>80*256                 ; AND #%10000000
     1F2C 8000     
6270 1F2E D80D  22        movb ra,@T                      ; STA T
     1F30 00D1     
6271               
6272 1F32 D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch roofv_x_hi into A and clear the sign bit, so
     1F34 0054     
6273 1F36 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; A = |roofv_x_hi|
     1F38 7F00     
6274               
6275 1F3A 091D  14        srl  ra,1                       ; LSR A             ; Set (A P) = (A P) / 16
6276 1F3C 0204  12        li   rarg1,P                    ; ROR P             ; = |roofv_x_hi roofv_x_lo| / 16
     1F3E 001B     
6277 1F40 06A0  24        bl   @ror                       ;
     1F42 FE7A     
6278 1F44 091D  14        srl  ra,1                       ; LSR A             ; = |roofv_x| / 16
6279 1F46 0204  12        li   rarg1,P                    ; ROR P
     1F48 001B     
6280 1F4A 06A0  24        bl   @ror                       ;
     1F4C FE7A     
6281 1F4E 091D  14        srl  ra,1                       ; LSR A
6282 1F50 0204  12        li   rarg1,P                    ; ROR P
     1F52 001B     
6283 1F54 06A0  24        bl   @ror                       ;
     1F56 FE7A     
6284 1F58 091D  14        srl  ra,1                       ; LSR A
6285 1F5A 0204  12        li   rarg1,P                    ; ROR P
     1F5C 001B     
6286 1F5E 06A0  24        bl   @ror                       ;
     1F60 FE7A     
6287               
6288 1F62 F360  22        socb @T,ra                      ; ORA T             ; Set the sign of A to the opposite sign to T (i.e. the
     1F64 00D1     
6289                      .eoi (>80*256)                  ; EOR #%10000000    ; sign of the original -roofv_x), so now:
     **** ****     > EOI
0001 1F66 0200  12        li   rtmp,(>80*256)
     1F68 8000     
0002 1F6A 2B40  14        xor  rtmp,ra
                   < elite.a99
6290                                                                          ;
6291                                                                          ; (A P) = -roofv_x / 16
6292               
6293                      .eor @RAT2                      ; EOR RAT2          ; Give it the sign as if we multiplied by the direction
     **** ****     > EOR
0001 1F6C D020  22        movb @RAT2,rtmp
     1F6E 00AB     
0002 1F70 2B40  14        xor  rtmp,ra
                   < elite.a99
6294                                                                          ; by the pitch or roll direction
6295               
6296 1F72 D80E  22        movb rx,@Q                      ; STX Q             ; Store the value of X so it can be restored after the
     1F74 0090     
6297                                                                          ; call to ADD
6298               
6299 1F76 0200  12        li   rtmp,ADD                   ; JSR ADD           ; (A X) = (A P) + (S R)
     1F78 456E     
6300 1F7A 06A0  24        bl   @jsr                       ;
     1F7C FE28     
6301                                                                          ; = -/+roofv_x / 16 + (1 - 1/512) * nosev_x
6302               
6303 1F7E DBCD  30        movb ra,@INWK+1(ry)             ; STA INWK+1,Y      ; Set nosev_x = (1-1/512) * nosev_x -/+ roofv_x / 16
     1F80 0054     
6304 1F82 DBCE  30        movb rx,@INWK(ry)               ; STX INWK,Y
     1F84 0053     
6305               
6306 1F86 D3A0  22        movb @Q,rx                      ; LDX Q             ; Restore the value of X from before the call to ADD
     1F88 0090     
6307               
6308 1F8A D360  22        movb @K,ra                      ; LDA K             ; Set roofv_x = K(1 0)
     1F8C 003D     
6309 1F8E DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X        ; = (1-1/512) * roofv_x +/- nosev_x / 16
     1F90 0053     
6310 1F92 D360  22        movb @K+1,ra                    ; LDA K+1
     1F94 003E     
6311 1F96 DB8D  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X
     1F98 0054     
6312               
6313 1F9A 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1F9C FE34     
6314               
6315               * ******************************************************************************
6316               *
6317               * Name: MVT6
6318               * Type: Subroutine
6319               * Category: Moving
6320               * Summary: Calculate (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
6321               *
6322               * ------------------------------------------------------------------------------
6323               *
6324               * Do the following calculation, for the coordinate given by X (so this is what
6325               * it does for the x-coordinate):
6326               *
6327               * (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
6328               *
6329               * A is a sign bit and is not included in the calculation, but bits 0-6 of A are
6330               * preserved. Bit 7 is set to the sign of the result.
6331               *
6332               * ------------------------------------------------------------------------------
6333               *
6334               * Arguments:
6335               *
6336               * A                   The sign of P(2 1) in bit 7
6337               *
6338               * P(2 1)              The 16-bit value we want to add the coordinate to
6339               *
6340               * X                   The coordinate to add, as follows:
6341               *
6342               * * If X = 0, add to (x_sign x_hi x_lo)
6343               *
6344               * * If X = 3, add to (y_sign y_hi y_lo)
6345               *
6346               * * If X = 6, add to (z_sign z_hi z_lo)
6347               *
6348               * ------------------------------------------------------------------------------
6349               *
6350               * Returns:
6351               *
6352               * A                   The sign of the result (in bit 7)
6353               *
6354               * ******************************************************************************
6355               
6356               MVT6:
6357 1F9E D3CD  14        movb ra,ry                      ; TAY               ; Store argument A into Y, for later use
6358               
6359                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; Set A = A EOR x_sign
     **** ****     > EOR
0001 1FA0 D02E  26        movb @INWK+2(RX),rtmp
     1FA2 0055     
0002 1FA4 2B40  14        xor  rtmp,ra
                   < elite.a99
6360               
6361 1FA6 1114  10        jlt  MV50                       ; BMI MV50          ; If the sign is negative, i.e. A and x_sign have
6362                                                                          ; different signs, jump to MV50
6363               
6364                                                                          ; The signs are the same, so we can add the two
6365                                                                          ; arguments and keep the sign to get the result
6366               
6367 1FA8 D360  22        movb @P+1,ra                    ; LDA P+1           ; First we add the low bytes:
     1FAA 001C     
6368                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 1FAC 0A16  14        sla  rzero,1
                   < elite.a99
6369                      .adc @INWK(rx),ra               ; ADC INWK,X        ; P+1 = P+1 + x_lo
     **** ****     > ADC
0001 1FAE 1701  10        jnc  !
0002 1FB0 B347  14        ab   rone,ra
0003               !:
0004 1FB2 B36E  26        ab   @INWK(RX),ra
     1FB4 0053     
                   < elite.a99
6370 1FB6 D80D  22        movb ra,@P+1                    ; STA P+1
     1FB8 001C     
6371               
6372 1FBA D360  22        movb @P+2,ra                    ; LDA P+2           ; And then the high bytes:
     1FBC 001D     
6373                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X      ;
     **** ****     > ADC
0001 1FBE 1701  10        jnc  !
0002 1FC0 B347  14        ab   rone,ra
0003               !:
0004 1FC2 B36E  26        ab   @INWK+1(RX),ra
     1FC4 0054     
                   < elite.a99
6374 1FC6 D80D  22        movb ra,@P+2                    ; STA P+2           ; P+2 = P+2 + x_hi
     1FC8 001D     
6375               
6376 1FCA D34F  14        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6377                                                                          ; so that we keep the original sign
6378               
6379 1FCC 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1FCE FE34     
6380               
6381               MV50:
6382 1FD0 D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; First we subtract the low bytes:
     1FD2 0053     
6383                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1FD4 0A18  14        sla  rmone,1
                   < elite.a99
6384                      .sbc @P+1,ra                    ; SBC P+1           ; P+1 = x_lo - P+1
     **** ****     > SBC
0001 1FD6 1801  10        joc  !
0002 1FD8 7347  14        sb   rone,ra
0003               !:
0004 1FDA 7360  22        sb   @P+1,ra
     1FDC 001C     
                   < elite.a99
6385 1FDE D80D  22        movb ra,@P+1                    ; STA P+1
     1FE0 001C     
6386               
6387 1FE2 D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; And then the high bytes:
     1FE4 0054     
6388                      .sbc @P+2,ra                    ; SBC P+2           ;
     **** ****     > SBC
0001 1FE6 1801  10        joc  !
0002 1FE8 7347  14        sb   rone,ra
0003               !:
0004 1FEA 7360  22        sb   @P+2,ra
     1FEC 001D     
                   < elite.a99
6389 1FEE D80D  22        movb ra,@P+2                    ; STA P+2           ; P+2 = x_hi - P+2
     1FF0 001D     
6390               
6391 1FF2 1706  10        jnc  MV51                       ; BCC MV51          ; If the last subtraction underflowed, then the C flag
6392                                                                          ; will be clear and x_hi < P+2, so jump to MV51 to
6393                                                                          ; negate the result
6394               
6395 1FF4 D34F  14        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6396                      .eoi (>80*256)                  ; EOR #%10000000    ; but flip bit 7, which flips the sign. We do this
     **** ****     > EOI
0001 1FF6 0200  12        li   rtmp,(>80*256)
     1FF8 8000     
0002 1FFA 2B40  14        xor  rtmp,ra
                   < elite.a99
6397                                                                          ; because x_hi >= P+2 so we want the result to have the
6398                                                                          ; same sign as x_hi (as it's the dominant side in this
6399                                                                          ; calculation). The sign of x_hi is x_sign, and x_sign
6400                                                                          ; has the opposite sign to A, so we flip the sign in A
6401                                                                          ; to return the correct result
6402               
6403 1FFC 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1FFE FE34     
6404               
6405               MV51:
6406 2000 020D  20        li   ra,>01*256                 ; LDA #1            ; Our subtraction underflowed, so we negate the result
     2002 0100     
6407                      .sbc @P+1,ra                    ; SBC P+1           ; using two's complement, first with the low byte:
     **** ****     > SBC
0001 2004 1801  14        joc  !
0002 2006 7347  18        sb   rone,ra
0003               !:
0004 2008 7360  30        sb   @P+1,ra
     200A 001C     
                   < elite.a99
6408 200C D80D  30        movb ra,@P+1                    ; STA P+1           ;
     200E 001C     
6409                                                                          ; P+1 = 1 - P+1
6410               
6411 2010 020D  20        li   ra,>00*256                 ; LDA #0            ; And then the high byte:
     2012 0000     
6412                      .sbc @P+2,ra                    ; SBC P+2           ;
     **** ****     > SBC
0001 2014 1801  14        joc  !
0002 2016 7347  18        sb   rone,ra
0003               !:
0004 2018 7360  30        sb   @P+2,ra
     201A 001D     
                   < elite.a99
6413 201C D80D  30        movb ra,@P+2                    ; STA P+2           ; P+2 = 0 - P+2
     201E 001D     
6414               
6415 2020 D34F  18        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6416                                                                          ; as this is the correct sign for the result. This is
6417                                                                          ; because x_hi < P+2, so we want to return the same sign
6418                                                                          ; as P+2, the dominant side
6419               
6420 2022 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2024 FE34     
6421               
6422               * ******************************************************************************
6423               *
6424               * Name: MV40
6425               * Type: Subroutine
6426               * Category: Moving
6427               * Summary: Rotate the planet or sun's location in space by the amount of
6428               * pitch and roll of our ship
6429               * Deep dive: Rotating the universe
6430               *
6431               * ------------------------------------------------------------------------------
6432               *
6433               * We implement this using the same equations as in part 5 of MVEIT, where we
6434               * rotated the current ship's location by our pitch and roll. Specifically, the
6435               * calculation is as follows:
6436               *
6437               * 1. K2 = y - alpha * x
6438               * 2. z = z + beta * K2
6439               * 3. y = K2 - beta * z
6440               * 4. x = x + alpha * y
6441               *
6442               * See the deep dive on "Rotating the universe" for more details on the above.
6443               *
6444               * ******************************************************************************
6445               
6446               MV40:
6447 2026 D360  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set Q = -ALPHA, so Q contains the angle we want to
     2028 009E     
6448                      .eoi (>80*256)                  ; EOR #%10000000    ; roll the planet through (i.e. in the opposite
     **** ****     > EOI
0001 202A 0200  20        li   rtmp,(>80*256)
     202C 8000     
0002 202E 2B40  18        xor  rtmp,ra
                   < elite.a99
6449 2030 D80D  30        movb ra,@Q                      ; STA Q             ; direction to our ship's roll angle alpha)
     2032 0090     
6450               
6451 2034 D360  30        movb @INWK,ra                   ; LDA INWK          ; Set P(1 0) = (x_hi x_lo)
     2036 0053     
6452 2038 D80D  30        movb ra,@P                      ; STA P
     203A 001B     
6453 203C D360  30        movb @INWK+1,ra                 ; LDA INWK+1
     203E 0054     
6454 2040 D80D  30        movb ra,@P+1                    ; STA P+1
     2042 001C     
6455               
6456 2044 D360  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Set A = x_sign
     2046 0055     
6457               
6458 2048 0200  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     204A 41FC     
6459 204C 06A0  32        bl   @jsr                       ;
     204E FE28     
6460                                                                          ;
6461                                                                          ; which also means:
6462                                                                          ;
6463                                                                          ; K(3 2 1) = (A P+1 P) * Q / 256
6464                                                                          ; = x * -alpha / 256
6465                                                                          ; = - alpha * x / 256
6466               
6467 2050 020E  20        li   rx,>03*256                 ; LDX #3            ; Set K(3 2 1) = (y_sign y_hi y_lo) + K(3 2 1)
     2052 0300     
6468 2054 0200  20        li   rtmp,MVT3                  ; JSR MVT3          ; = y - alpha * x / 256
     2056 1CAC     
6469 2058 06A0  32        bl   @jsr                       ;
     205A FE28     
6470               
6471 205C D360  30        movb @K+1,ra                    ; LDA K+1           ; Set K2(2 1) = P(1 0) = K(2 1)
     205E 003E     
6472 2060 D80D  30        movb ra,@K2+1                   ; STA K2+1
     2062 00AD     
6473 2064 D80D  30        movb ra,@P                      ; STA P
     2066 001B     
6474               
6475 2068 D360  30        movb @K+2,ra                    ; LDA K+2           ; Set K2+2 = K+2
     206A 003F     
6476 206C D80D  30        movb ra,@K2+2                   ; STA K2+2
     206E 00AE     
6477               
6478 2070 D80D  30        movb ra,@P+1                    ; STA P+1           ; Set P+1 = K+2
     2072 001C     
6479               
6480 2074 D360  30        movb @BETA,ra                   ; LDA BETA          ; Set Q = beta, the pitch angle of our ship
     2076 002A     
6481 2078 D80D  30        movb ra,@Q                      ; STA Q
     207A 0090     
6482               
6483 207C D360  30        movb @K+3,ra                    ; LDA K+3           ; Set K+3 to K2+3, so now we have result 1 above:
     207E 0040     
6484 2080 D80D  30        movb ra,@K2+3                   ; STA K2+3          ;
     2082 00AF     
6485                                                                          ; K2(3 2 1) = K(3 2 1)
6486                                                                          ; = y - alpha * x / 256
6487               
6488                                                                          ; We also have:
6489                                                                          ;
6490                                                                          ; A = K+3
6491                                                                          ;
6492                                                                          ; P(1 0) = K(2 1)
6493                                                                          ;
6494                                                                          ; so combined, these mean:
6495                                                                          ;
6496                                                                          ; (A P+1 P) = K(3 2 1)
6497                                                                          ; = K2(3 2 1)
6498               
6499 2084 0200  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     2086 41FC     
6500 2088 06A0  32        bl   @jsr                       ;
     208A FE28     
6501                                                                          ;
6502                                                                          ; which also means:
6503                                                                          ;
6504                                                                          ; K(3 2 1) = (A P+1 P) * Q / 256
6505                                                                          ; = K2(3 2 1) * beta / 256
6506                                                                          ; = beta * K2 / 256
6507               
6508 208C 020E  20        li   rx,>06*256                 ; LDX #6            ; K(3 2 1) = (z_sign z_hi z_lo) + K(3 2 1)
     208E 0600     
6509 2090 0200  20        li   rtmp,MVT3                  ; JSR MVT3          ; = z + beta * K2 / 256
     2092 1CAC     
6510 2094 06A0  32        bl   @jsr                       ;
     2096 FE28     
6511               
6512 2098 D360  30        movb @K+1,ra                    ; LDA K+1           ; Set P = K+1
     209A 003E     
6513 209C D80D  30        movb ra,@P                      ; STA P
     209E 001B     
6514               
6515 20A0 D80D  30        movb ra,@INWK+6                 ; STA INWK+6        ; Set z_lo = K+1
     20A2 0059     
6516               
6517 20A4 D360  30        movb @K+2,ra                    ; LDA K+2           ; Set P+1 = K+2
     20A6 003F     
6518 20A8 D80D  30        movb ra,@P+1                    ; STA P+1
     20AA 001C     
6519               
6520 20AC D80D  30        movb ra,@INWK+7                 ; STA INWK+7        ; Set z_hi = K+2
     20AE 005A     
6521               
6522 20B0 D360  30        movb @K+3,ra                    ; LDA K+3           ; Set A = z_sign = K+3, so now we have:
     20B2 0040     
6523 20B4 D80D  30        movb ra,@INWK+8                 ; STA INWK+8        ;
     20B6 005B     
6524                                                                          ; (z_sign z_hi z_lo) = K(3 2 1)
6525                                                                          ; = z + beta * K2 / 256
6526               
6527                                                                          ; So we now have result 2 above:
6528                                                                          ;
6529                                                                          ; z = z + beta * K2
6530               
6531                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign bit of A to give A = -z_sign
     **** ****     > EOI
0001 20B8 0200  20        li   rtmp,(>80*256)
     20BA 8000     
0002 20BC 2B40  18        xor  rtmp,ra
                   < elite.a99
6532               
6533 20BE 0200  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     20C0 41FC     
6534 20C2 06A0  32        bl   @jsr                       ;
     20C4 FE28     
6535                                                                          ; = (-z_sign z_hi z_lo) * beta
6536                                                                          ; = -z * beta
6537               
6538 20C6 D360  30        movb @K+3,ra                    ; LDA K+3           ; Set T to the sign bit of K(3 2 1 0), i.e. to the sign
     20C8 0040     
6539 20CA 024D  22        andi ra,>80*256                 ; AND #%10000000    ; bit of -z * beta
     20CC 8000     
6540 20CE D80D  30        movb ra,@T                      ; STA T
     20D0 00D1     
6541               
6542                      .eor @K2+3                      ; EOR K2+3          ; If K2(3 2 1 0) has a different sign to K(3 2 1 0),
     **** ****     > EOR
0001 20D2 D020  30        movb @K2+3,rtmp
     20D4 00AF     
0002 20D6 2B40  18        xor  rtmp,ra
                   < elite.a99
6543 20D8 111E  14        jlt  MV1                        ; BMI MV1           ; then EOR'ing them will produce a 1 in bit 7, so jump
6544                                                                          ; to MV1 to take this into account
6545               
6546                                                                          ; If we get here, K and K2 have the same sign, so we can
6547                                                                          ; add them together to get the result we're after, and
6548                                                                          ; then set the sign afterwards
6549               
6550 20DA D360  30        movb @K,ra                      ; LDA K             ; We now do the following sum:
     20DC 003D     
6551               * CLC                    \
6552                      .adc @K2,ra                     ; ADC K2            ; (A y_hi y_lo -) = K(3 2 1 0) + K2(3 2 1 0)
     **** ****     > ADC
0001 20DE 1701  14        jnc  !
0002 20E0 B347  18        ab   rone,ra
0003               !:
0004 20E2 B360  30        ab   @K2,ra
     20E4 00AC     
                   < elite.a99
6553                                                                          ;
6554                                                                          ; starting with the low bytes (which we don't keep)
6555                                                                          ;
6556                                                                          ; The CLC instruction is commented out in the original
6557                                                                          ; source. It isn't needed because MULT3 clears the C
6558                                                                          ; flag, so this is an example of the authors finding
6559                                                                          ; one more precious byte to save
6560               
6561 20E6 D360  30        movb @K+1,ra                    ; LDA K+1           ; We then do the middle bytes, which go into y_lo
     20E8 003E     
6562                      .adc @K2+1,ra                   ; ADC K2+1
     **** ****     > ADC
0001 20EA 1701  14        jnc  !
0002 20EC B347  18        ab   rone,ra
0003               !:
0004 20EE B360  30        ab   @K2+1,ra
     20F0 00AD     
                   < elite.a99
6563 20F2 D80D  30        movb ra,@INWK+3                 ; STA INWK+3
     20F4 0056     
6564               
6565 20F6 D360  30        movb @K+2,ra                    ; LDA K+2           ; And then the high bytes, which go into y_hi
     20F8 003F     
6566                      .adc @K2+2,ra                   ; ADC K2+2
     **** ****     > ADC
0001 20FA 1701  14        jnc  !
0002 20FC B347  18        ab   rone,ra
0003               !:
0004 20FE B360  30        ab   @K2+2,ra
     2100 00AE     
                   < elite.a99
6567 2102 D80D  30        movb ra,@INWK+4                 ; STA INWK+4
     2104 0057     
6568               
6569 2106 D360  30        movb @K+3,ra                    ; LDA K+3           ; And then the sign bytes into A, so overall we have the
     2108 0040     
6570                      .adc @K2+3,ra                   ; ADC K2+3          ; following, if we drop the low bytes from the result:
     **** ****     > ADC
0001 210A 1701  14        jnc  !
0002 210C B347  18        ab   rone,ra
0003               !:
0004 210E B360  30        ab   @K2+3,ra
     2110 00AF     
                   < elite.a99
6571                                                                          ;
6572                                                                          ; (A y_hi y_lo) = (K + K2) / 256
6573               
6574 2112 0460  28        b    @MV2                       ; JMP MV2           ; Jump to MV2 to skip the calculation for when K and K2
     2114 2196     
6575                                                                          ; have different signs
6576               
6577               MV1:
6578 2116 D360  30        movb @K,ra                      ; LDA K             ; If we get here then K2 and K have different signs, so
     2118 003D     
6579                      .sec                            ; SEC               ; instead of adding, we need to subtract to get the
     **** ****     > SEC
0001 211A 0A18  18        sla  rmone,1
                   < elite.a99
6580                      .sbc @K2,ra                     ; SBC K2            ; result we want, like this:
     **** ****     > SBC
0001 211C 1801  14        joc  !
0002 211E 7347  18        sb   rone,ra
0003               !:
0004 2120 7360  30        sb   @K2,ra
     2122 00AC     
                   < elite.a99
6581                                                                          ;
6582                                                                          ; (A y_hi y_lo -) = K(3 2 1 0) - K2(3 2 1 0)
6583                                                                          ;
6584                                                                          ; starting with the low bytes (which we don't keep)
6585               
6586 2124 D360  30        movb @K+1,ra                    ; LDA K+1           ; We then do the middle bytes, which go into y_lo
     2126 003E     
6587                      .sbc @K2+1,ra                   ; SBC K2+1
     **** ****     > SBC
0001 2128 1801  14        joc  !
0002 212A 7347  18        sb   rone,ra
0003               !:
0004 212C 7360  30        sb   @K2+1,ra
     212E 00AD     
                   < elite.a99
6588 2130 D80D  30        movb ra,@INWK+3                 ; STA INWK+3
     2132 0056     
6589               
6590 2134 D360  30        movb @K+2,ra                    ; LDA K+2           ; And then the high bytes, which go into y_hi
     2136 003F     
6591                      .sbc @K2+2,ra                   ; SBC K2+2
     **** ****     > SBC
0001 2138 1801  14        joc  !
0002 213A 7347  18        sb   rone,ra
0003               !:
0004 213C 7360  30        sb   @K2+2,ra
     213E 00AE     
                   < elite.a99
6592 2140 D80D  30        movb ra,@INWK+4                 ; STA INWK+4
     2142 0057     
6593               
6594 2144 D360  30        movb @K2+3,ra                   ; LDA K2+3          ; Now for the sign bytes, so first we extract the sign
     2146 00AF     
6595 2148 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; byte from K2 without the sign bit, so P = |K2+3|
     214A 7F00     
6596 214C D80D  30        movb ra,@P                      ; STA P
     214E 001B     
6597               
6598 2150 D360  30        movb @K+3,ra                    ; LDA K+3           ; And then we extract the sign byte from K without the
     2152 0040     
6599 2154 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; sign bit, so A = |K+3|
     2156 7F00     
6600               
6601                      .sbc @P,ra                      ; SBC P             ; And finally we subtract the sign bytes, so P = A - P
     **** ****     > SBC
0001 2158 1801  14        joc  !
0002 215A 7347  18        sb   rone,ra
0003               !:
0004 215C 7360  30        sb   @P,ra
     215E 001B     
                   < elite.a99
6602 2160 D80D  30        movb ra,@P                      ; STA P
     2162 001B     
6603               
6604                                                                          ; By now we have the following, if we drop the low bytes
6605                                                                          ; from the result:
6606                                                                          ;
6607                                                                          ; (A y_hi y_lo) = (K - K2) / 256
6608                                                                          ;
6609                                                                          ; so now we just need to make sure the sign of the
6610                                                                          ; result is correct
6611               
6612 2164 1818  14        joc  MV2                        ; BCS MV2           ; If the C flag is set, then the last subtraction above
6613                                                                          ; didn't underflow and the result is correct, so jump to
6614                                                                          ; MV2 as we are done with this particular stage
6615               
6616 2166 020D  20        li   ra,>01*256                 ; LDA #1            ; Otherwise the subtraction above underflowed, as K2 is
     2168 0100     
6617                      .sbc @INWK+3,ra                 ; SBC INWK+3        ; the dominant part of the subtraction, so we need to
     **** ****     > SBC
0001 216A 1801  14        joc  !
0002 216C 7347  18        sb   rone,ra
0003               !:
0004 216E 7360  30        sb   @INWK+3,ra
     2170 0056     
                   < elite.a99
6618 2172 D80D  30        movb ra,@INWK+3                 ; STA INWK+3        ; negate the result using two's complement, starting
     2174 0056     
6619                                                                          ; with the low bytes:
6620                                                                          ;
6621                                                                          ; y_lo = 1 - y_lo
6622               
6623 2176 020D  20        li   ra,>00*256                 ; LDA #0            ; And then the high bytes:
     2178 0000     
6624                      .sbc @INWK+4,ra                 ; SBC INWK+4        ;
     **** ****     > SBC
0001 217A 1801  14        joc  !
0002 217C 7347  18        sb   rone,ra
0003               !:
0004 217E 7360  30        sb   @INWK+4,ra
     2180 0057     
                   < elite.a99
6625 2182 D80D  30        movb ra,@INWK+4                 ; STA INWK+4        ; y_hi = 0 - y_hi
     2184 0057     
6626               
6627 2186 020D  20        li   ra,>00*256                 ; LDA #0            ; And finally the sign bytes:
     2188 0000     
6628                      .sbc @P,ra                      ; SBC P             ;
     **** ****     > SBC
0001 218A 1801  14        joc  !
0002 218C 7347  18        sb   rone,ra
0003               !:
0004 218E 7360  30        sb   @P,ra
     2190 001B     
                   < elite.a99
6629                                                                          ; A = 0 - P
6630               
6631 2192 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now force the sign bit to be negative, so that the
     2194 8000     
6632                                                                          ; final result below gets the opposite sign to K, which
6633                                                                          ; we want as K2 is the dominant part of the sum
6634               
6635               MV2:
6636                      .eor @T                         ; EOR T             ; T contains the sign bit of K, so if K is negative,
     **** ****     > EOR
0001 2196 D020  30        movb @T,rtmp
     2198 00D1     
0002 219A 2B40  18        xor  rtmp,ra
                   < elite.a99
6637                                                                          ; this flips the sign of A
6638               
6639 219C D80D  30        movb ra,@INWK+5                 ; STA INWK+5        ; Store A in y_sign
     219E 0058     
6640               
6641                                                                          ; So we now have result 3 above:
6642                                                                          ;
6643                                                                          ; y = K2 + K
6644                                                                          ; = K2 - beta * z
6645               
6646 21A0 D360  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set A = alpha
     21A2 009E     
6647 21A4 D80D  30        movb ra,@Q                      ; STA Q
     21A6 0090     
6648               
6649 21A8 D360  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P(1 0) = (y_hi y_lo)
     21AA 0056     
6650 21AC D80D  30        movb ra,@P                      ; STA P
     21AE 001B     
6651 21B0 D360  30        movb @INWK+4,ra                 ; LDA INWK+4
     21B2 0057     
6652 21B4 D80D  30        movb ra,@P+1                    ; STA P+1
     21B6 001C     
6653               
6654 21B8 D360  30        movb @INWK+5,ra                 ; LDA INWK+5        ; Set A = y_sign
     21BA 0058     
6655               
6656 21BC 0200  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     21BE 41FC     
6657 21C0 06A0  32        bl   @jsr                       ;
     21C2 FE28     
6658                                                                          ; = (y_sign y_hi y_lo) * alpha
6659                                                                          ; = y * alpha
6660               
6661 21C4 020E  20        li   rx,>00*256                 ; LDX #0            ; Set K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
     21C6 0000     
6662 21C8 0200  20        li   rtmp,MVT3                  ; JSR MVT3          ; = x + y * alpha / 256
     21CA 1CAC     
6663 21CC 06A0  32        bl   @jsr                       ;
     21CE FE28     
6664               
6665 21D0 D360  30        movb @K+1,ra                    ; LDA K+1           ; Set (x_sign x_hi x_lo) = K(3 2 1)
     21D2 003E     
6666 21D4 D80D  30        movb ra,@INWK                   ; STA INWK          ; = x + y * alpha / 256
     21D6 0053     
6667 21D8 D360  30        movb @K+2,ra                    ; LDA K+2
     21DA 003F     
6668 21DC D80D  30        movb ra,@INWK+1                 ; STA INWK+1
     21DE 0054     
6669 21E0 D360  30        movb @K+3,ra                    ; LDA K+3
     21E2 0040     
6670 21E4 D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     21E6 0055     
6671               
6672                                                                          ; So we now have result 4 above:
6673                                                                          ;
6674                                                                          ; x = x + y * alpha
6675               
6676 21E8 0460  24        b    @MV45                      ; JMP MV45          ; We have now finished rotating the planet or sun by
     21EA 1A9E     
6677                                                                          ; our pitch and roll, so jump back into the MVEIT
6678                                                                          ; routine at MV45 to apply all the other movements
6679               
6680               * ******************************************************************************
6681               *
6682               * Save ELTA.bin
6683               *
6684               * ******************************************************************************
6685               
6686                      ; PRINT "ELITE A"
6687                      ; PRINT "Assembled at ", ~CODE%
6688                      ; PRINT "Ends at ", ~P%
6689                      ; PRINT "Code size is ", ~(P% - CODE%)
6690                      ; PRINT "Execute at ", ~LOAD%
6691                      ; PRINT "Reload at ", ~LOAD_A%
6692               
6693                      ; PRINT "S.ELTA ", ~CODE%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_A%
6694                      ; SAVE "3-assembled-output/ELTA.bin", CODE%, P%, LOAD%
6695               
6696               * ******************************************************************************
6697               *
6698               * ELITE B FILE
6699               *
6700               * Produces the binary file ELTB.bin that gets loaded by elite-bcfs.asm.
6701               *
6702               * ******************************************************************************
6703               
6704               CODE_B.:
6705                      equ $
6706               
6707               LOAD_B.:
6708                      equ LOAD. + $ - CODE.
6709               
6710               * ******************************************************************************
6711               *
6712               * Name: NA%
6713               * Type: Variable
6714               * Category: Save and load
6715               * Summary: The data block for the last saved commander
6716               * Deep dive: Commander save files
6717               * The competition code
6718               *
6719               * ------------------------------------------------------------------------------
6720               *
6721               * Contains the last saved commander data, with the name at NA% and the data at
6722               * NA%+8 onwards. The size of the data block is given in NT% (which also includes
6723               * the two checksum bytes that follow this block). This block is initially set up
6724               * with the default commander, which can be maxed out for testing purposes by
6725               * setting Q% to TRUE.
6726               *
6727               * The commander's name is stored at NA%, and can be up to 7 characters long
6728               * (the DFS filename limit). It is terminated with a carriage return character,
6729               * ASCII 13.
6730               *
6731               * The offset of each byte within a saved commander file is also shown as #0, #1
6732               * and so on, so the kill tally, for example, is in bytes #71 and #72 of the
6733               * saved file. The related variable name from the current commander block is
6734               * also shown.
6735               *
6736               * ******************************************************************************
6737               
6738               NA.:
6739 21EC 4A41            text 'JAMESON'                                      ; The current commander name, which defaults to JAMESON
     21EE 4D45     
     21F0 534F     
     21F2 4E       
6740 21F3   0D            byte >0d                                            ;
6741                                                                          ; The commander name can be up to 7 characters (the DFS
6742                                                                          ; limit for filenames), and is terminated by a carriage
6743                                                                          ; return
6744               
6745                                                                          ; NA%+8 is the start of the commander data block
6746                                                                          ;
6747                                                                          ; This block contains the last saved commander data
6748                                                                          ; block. As the game is played it uses an identical
6749                                                                          ; block at location TP to store the current commander
6750                                                                          ; state, and that block is copied here when the game is
6751                                                                          ; saved. Conversely, when the game starts up, the block
6752                                                                          ; here is copied to TP, which restores the last saved
6753                                                                          ; commander when we die
6754                                                                          ;
6755                                                                          ; The initial state of this block defines the default
6756                                                                          ; commander. Q% can be set to TRUE to give the default
6757                                                                          ; commander lots of credits and equipment
6758               
6759 21F4 00              byte >00                                            ; TP = Mission status, #0
6760               
6761 21F5   14            byte >14                                            ; QQ0 = Current system X-coordinate (Lave), #1
6762 21F6 AD              byte >ad                                            ; QQ1 = Current system Y-coordinate (Lave), #2
6763               
6764 21F8 4A5A            data >4a5a                                          ; QQ21 = Seed s0 for system 0, galaxy 0 (Tibedied), #3-4
6765 21FA 4802            data >4802                                          ; QQ21 = Seed s1 for system 0, galaxy 0 (Tibedied), #5-6
6766 21FC 53B7            data >53b7                                          ; QQ21 = Seed s2 for system 0, galaxy 0 (Tibedied), #7-8
6767               
6771 21FE 0000            data >0000, >0000                                   ; CASH = Amount of cash (100 Cr), #9-12
     2200 0000     
6773               
6774 2202 46              byte >46                                            ; QQ14 = Fuel level, #13
6775               
6776 2203   00            byte >00                                            ; COK = Competition flags, #14
6777               
6778 2204 00              byte >00                                            ; GCNT = Galaxy number, 0-7, #15
6779               
6780 2205   0F            byte POW+(128 & Q.)                                 ; LASER = Front laser, #16
6781               
6782 2206 00              byte (POW+128) & Q.                                 ; LASER+1 = Rear laser, #17
6783               
6784 2207   00            byte >00                                            ; LASER+2 = Left laser, #18
6785               
6786 2208 00              byte >00                                            ; LASER+3 = Right laser, #19
6787               
6788 220A 0000            data >0000                                          ; These bytes appear to be unused (they were originally
6789                                                                          ; used for up/down lasers, but they were dropped),
6790                                                                          ; #20-21
6791               
6792 220C 16              byte 22 + (15 & Q.)                                 ; CRGO = Cargo capacity, #22
6793               
6794 220D   00            byte >00                                            ; QQ20+0  = Amount of food in cargo hold, #23
6795 220E 00              byte >00                                            ; QQ20+1  = Amount of textiles in cargo hold, #24
6796 220F   00            byte >00                                            ; QQ20+2  = Amount of radioactives in cargo hold, #25
6797 2210 00              byte >00                                            ; QQ20+3  = Amount of slaves in cargo hold, #26
6798 2211   00            byte >00                                            ; QQ20+4  = Amount of liquor/Wines in cargo hold, #27
6799 2212 00              byte >00                                            ; QQ20+5  = Amount of luxuries in cargo hold, #28
6800 2213   00            byte >00                                            ; QQ20+6  = Amount of narcotics in cargo hold, #29
6801 2214 00              byte >00                                            ; QQ20+7  = Amount of computers in cargo hold, #30
6802 2215   00            byte >00                                            ; QQ20+8  = Amount of machinery in cargo hold, #31
6803 2216 00              byte >00                                            ; QQ20+9  = Amount of alloys in cargo hold, #32
6804 2217   00            byte >00                                            ; QQ20+10 = Amount of firearms in cargo hold, #33
6805 2218 00              byte >00                                            ; QQ20+11 = Amount of furs in cargo hold, #34
6806 2219   00            byte >00                                            ; QQ20+12 = Amount of minerals in cargo hold, #35
6807 221A 00              byte >00                                            ; QQ20+13 = Amount of gold in cargo hold, #36
6808 221B   00            byte >00                                            ; QQ20+14 = Amount of platinum in cargo hold, #37
6809 221C 00              byte >00                                            ; QQ20+15 = Amount of gem-stones in cargo hold, #38
6810 221D   00            byte >00                                            ; QQ20+16 = Amount of alien items in cargo hold, #39
6811               
6812 221E 00              byte Q.                                             ; ECM = E.C.M. system, #40
6813               
6814 221F   00            byte Q.                                             ; BST = Fuel scoops ("barrel status"), #41
6815               
6816 2220 00              byte Q. & 127                                       ; BOMB = Energy bomb, #42
6817               
6818 2221   00            byte Q. & 1                                         ; ENGY = Energy/shield level, #43
6819               
6820 2222 00              byte Q.                                             ; DKCMP = Docking computer, #44
6821               
6822 2223   00            byte Q.                                             ; GHYP = Galactic hyperdrive, #45
6823               
6824 2224 00              byte Q.                                             ; ESCP = Escape pod, #46
6825               
6826 2226 0000            data >0000, >0000                                   ; These four bytes appear to be unused, #47-50
     2228 0000     
6827               
6828 222A 03              byte 3 + (Q. & 1)                                   ; NOMSL = Number of missiles, #51
6829               
6830 222B   00            byte >00                                            ; FIST = Legal status ("fugitive/innocent status"), #52
6831               
6832 222C 10              byte >10                                            ; AVL+0  = Market availability of food, #53
6833 222D   0F            byte >0f                                            ; AVL+1  = Market availability of textiles, #54
6834 222E 11              byte >11                                            ; AVL+2  = Market availability of radioactives, #55
6835 222F   00            byte >00                                            ; AVL+3  = Market availability of slaves, #56
6836 2230 03              byte >03                                            ; AVL+4  = Market availability of liquor/Wines, #57
6837 2231   1C            byte >1c                                            ; AVL+5  = Market availability of luxuries, #58
6838 2232 0E              byte >0e                                            ; AVL+6  = Market availability of narcotics, #59
6839 2233   00            byte >00                                            ; AVL+7  = Market availability of computers, #60
6840 2234 00              byte >00                                            ; AVL+8  = Market availability of machinery, #61
6841 2235   0A            byte >0a                                            ; AVL+9  = Market availability of alloys, #62
6842 2236 00              byte >00                                            ; AVL+10 = Market availability of firearms, #63
6843 2237   11            byte >11                                            ; AVL+11 = Market availability of furs, #64
6844 2238 3A              byte >3a                                            ; AVL+12 = Market availability of minerals, #65
6845 2239   07            byte >07                                            ; AVL+13 = Market availability of gold, #66
6846 223A 09              byte >09                                            ; AVL+14 = Market availability of platinum, #67
6847 223B   08            byte >08                                            ; AVL+15 = Market availability of gem-stones, #68
6848 223C 00              byte >00                                            ; AVL+16 = Market availability of alien items, #69
6849               
6850 223D   00            byte >00                                            ; QQ26 = Random byte that changes for each visit to a
6851                                                                          ; system, for randomising market prices, #70
6852               
6853 223E 0000            data >0000                                          ; TALLY = Number of kills, #71-72
6854               
6855 2240 80              byte >80                                            ; SVC = Save count, #73
6856               
6857               * ******************************************************************************
6858               *
6859               * Name: CHK2
6860               * Type: Variable
6861               * Category: Save and load
6862               * Summary: Second checksum byte for the saved commander data file
6863               * Deep dive: Commander save files
6864               * The competition code
6865               *
6866               * ------------------------------------------------------------------------------
6867               *
6868               * Second commander checksum byte. If the default commander is changed, a new
6869               * checksum will be calculated and inserted by the elite-checksum.py script.
6870               *
6871               * The offset of this byte within a saved commander file is also shown (it's at
6872               * byte #74).
6873               *
6874               * ******************************************************************************
6875               
6876               CHK2:
6877 2241   AA            byte >03 ^ >A9                                      ; The checksum value for the default commander, EOR'd
6878                                                                          ; with &A9 to make it harder to tamper with the checksum
6879                                                                          ; byte, #74
6880               
6881               * ******************************************************************************
6882               *
6883               * Name: CHK
6884               * Type: Variable
6885               * Category: Save and load
6886               * Summary: First checksum byte for the saved commander data file
6887               * Deep dive: Commander save files
6888               * The competition code
6889               *
6890               * ------------------------------------------------------------------------------
6891               *
6892               * Commander checksum byte. If the default commander is changed, a new checksum
6893               * will be calculated and inserted by the elite-checksum.py script.
6894               *
6895               * The offset of this byte within a saved commander file is also shown (it's at
6896               * byte #75).
6897               *
6898               * ******************************************************************************
6899               
6900               CHK:
6901 2242 03              byte >03                                            ; The checksum value for the default commander, #75
6902               
6903               * ******************************************************************************
6904               *
6905               * Name: UNIV
6906               * Type: Variable
6907               * Category: Universe
6908               * Summary: Table of pointers to the local universe's ship data blocks
6909               * Deep dive: The local bubble of universe
6910               *
6911               * ------------------------------------------------------------------------------
6912               *
6913               * See the deep dive on "Ship data blocks" for details on ship data blocks, and
6914               * the deep dive on "The local bubble of universe" for details of how Elite
6915               * stores the local universe in K%, FRIN and UNIV.
6916               *
6917               * ******************************************************************************
6918               
6919               UNIV:
6920                      ; FOR I%, 0, NOSH
6921               
6922                      ; EQUW K% + I% * NI%            ;                   ; Address of block no. I%, of size NI%, in workspace K%
6923               
6924                      ; NEXT
6925               
6926 2243   00            byte (K. + 0 * NI.) % 256, (K. + 0 * NI.) / 256
     2244 44       
6927 2245   24            byte (K. + 1 * NI.) % 256, (K. + 1 * NI.) / 256
     2246 44       
6928 2247   48            byte (K. + 2 * NI.) % 256, (K. + 2 * NI.) / 256
     2248 44       
6929 2249   6C            byte (K. + 3 * NI.) % 256, (K. + 3 * NI.) / 256
     224A 44       
6930 224B   90            byte (K. + 4 * NI.) % 256, (K. + 4 * NI.) / 256
     224C 44       
6931 224D   B4            byte (K. + 5 * NI.) % 256, (K. + 5 * NI.) / 256
     224E 44       
6932 224F   D8            byte (K. + 6 * NI.) % 256, (K. + 6 * NI.) / 256
     2250 44       
6933 2251   FC            byte (K. + 7 * NI.) % 256, (K. + 7 * NI.) / 256
     2252 44       
6934 2253   20            byte (K. + 8 * NI.) % 256, (K. + 8 * NI.) / 256
     2254 45       
6935 2255   44            byte (K. + 9 * NI.) % 256, (K. + 9 * NI.) / 256
     2256 45       
6936 2257   68            byte (K. + 10 * NI.) % 256, (K. + 10 * NI.) / 256
     2258 45       
6937 2259   8C            byte (K. + 11 * NI.) % 256, (K. + 11 * NI.) / 256
     225A 45       
6938 225B   B0            byte (K. + 12 * NI.) % 256, (K. + 12 * NI.) / 256
     225C 45       
6939               
6940               * ******************************************************************************
6941               *
6942               * Name: TWOS
6943               * Type: Variable
6944               * Category: Drawing pixels
6945               * Summary: Ready-made single-pixel character row bytes for mode 4
6946               * Deep dive: Drawing monochrome pixels in mode 4
6947               *
6948               * ------------------------------------------------------------------------------
6949               *
6950               * Ready-made bytes for plotting one-pixel points in mode 4 (the top part of the
6951               * split screen). See the PIXEL routine for details.
6952               *
6953               * ******************************************************************************
6954               
6955               TWOS:
6956 225D   80            byte >80
6957 225E 40              byte >40
6958 225F   20            byte >20
6959 2260 10              byte >10
6960 2261   08            byte >08
6961 2262 04              byte >04
6962 2263   02            byte >02
6963 2264 01              byte >01
6964               
6965               * ******************************************************************************
6966               *
6967               * Name: TWOS2
6968               * Type: Variable
6969               * Category: Drawing pixels
6970               * Summary: Ready-made double-pixel character row bytes for mode 4
6971               * Deep dive: Drawing monochrome pixels in mode 4
6972               *
6973               * ------------------------------------------------------------------------------
6974               *
6975               * Ready-made bytes for plotting two-pixel dashes in mode 4 (the top part of the
6976               * split screen). See the PIXEL routine for details.
6977               *
6978               * ******************************************************************************
6979               
6980               TWOS2:
6981 2265   C0            byte >c0
6982 2266 60              byte >60
6983 2267   30            byte >30
6984 2268 18              byte >18
6985 2269   0C            byte >0c
6986 226A 06              byte >06
6987 226B   03            byte >03
6988 226C 03              byte >03
6989               
6990               * ******************************************************************************
6991               *
6992               * Name: CTWOS
6993               * Type: Variable
6994               * Category: Drawing pixels
6995               * Summary: Ready-made single-pixel character row bytes for mode 5
6996               * Deep dive: Drawing colour pixels in mode 5
6997               *
6998               * ------------------------------------------------------------------------------
6999               *
7000               * Ready-made bytes for plotting one-pixel points in mode 5 (the bottom part of
7001               * the split screen). See the dashboard routines SCAN, DIL2 and CPIX2 for
7002               * details.
7003               *
7004               * There is one extra row to support the use of CTWOS+1,X indexing in the CPIX2
7005               * routine. The extra row is a repeat of the first row, and saves us from having
7006               * to work out whether CTWOS+1+X needs to be wrapped around when drawing a
7007               * two-pixel dash that crosses from one character block into another. See CPIX2
7008               * for more details.
7009               *
7010               * ******************************************************************************
7011               
7012               CTWOS:
7013 226D   88            byte >88
7014 226E 44              byte >44
7015 226F   22            byte >22
7016 2270 11              byte >11
7017 2271   88            byte >88
7018               
7019               * ******************************************************************************
7020               *
7021               * Name: LOIN (Part 1 of 7)
7022               * Type: Subroutine
7023               * Category: Drawing lines
7024               * Summary: Draw a line: Calculate the line gradient in the form of deltas
7025               * Deep dive: Bresenham's line algorithm
7026               *
7027               * ------------------------------------------------------------------------------
7028               *
7029               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7030               * This stage calculates the line deltas.
7031               *
7032               * ------------------------------------------------------------------------------
7033               *
7034               * Arguments:
7035               *
7036               * X1                  The screen x-coordinate of the start of the line
7037               *
7038               * Y1                  The screen y-coordinate of the start of the line
7039               *
7040               * X2                  The screen x-coordinate of the end of the line
7041               *
7042               * Y2                  The screen y-coordinate of the end of the line
7043               *
7044               * ------------------------------------------------------------------------------
7045               *
7046               * Returns:
7047               *
7048               * Y                   Y is preserved
7049               *
7050               * ------------------------------------------------------------------------------
7051               *
7052               * Other entry points:
7053               *
7054               * LL30                LL30 is a synonym for LOIN and draws a line from
7055               * (X1, Y1) to (X2, Y2)
7056               *
7057               * ******************************************************************************
7058               
7059               LL30:
7060 2272                 bss 0                                               ; LL30 is a synonym for LOIN
7061                                                                          ;
7062                                                                          ; In the cassette and disc versions of Elite, LL30 and
7063                                                                          ; LOIN are synonyms for the same routine, presumably
7064                                                                          ; because the two developers each had their own line
7065                                                                          ; routines to start with, and then chose one of them for
7066                                                                          ; the final game
7067               
7068               LOIN:
7069 2272 D80F  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y into YSAV, so we can preserve it across the
     2274 0094     
7070                                                                          ; call to this subroutine
7071               
7072 2276 020D  20        li   ra,>80*256                 ; LDA #128          ; Set S = 128, which is the starting point for the
     2278 8000     
7073 227A D80D  30        movb ra,@S                      ; STA S             ; slope error (representing half a pixel)
     227C 0092     
7074               
7075                      .asla                           ; ASL A             ; Set SWAP = 0, as %10000000 << 1 = 0
     **** ****     > ASLA
0001 227E 024D  22        andi ra,>ff00
     2280 FF00     
0002 2282 0A1D  18        sla  ra,1
                   < elite.a99
7076 2284 D80D  30        movb ra,@SWAP                   ; STA SWAP
     2286 00A1     
7077               
7078 2288 D360  30        movb @X2,ra                     ; LDA X2            ; Set A = X2 - X1
     228A 0033     
7079                      .sbc @X1,ra                     ; SBC X1            ; = delta_x
     **** ****     > SBC
0001 228C 1801  14        joc  !
0002 228E 7347  18        sb   rone,ra
0003               !:
0004 2290 7360  30        sb   @X1,ra
     2292 0031     
                   < elite.a99
7080                                                                          ;
7081                                                                          ; This subtraction works as the ASL A above sets the C
7082                                                                          ; flag
7083               
7084 2294 1808  14        joc  LI1                        ; BCS LI1           ; If X2 > X1 then A is already positive and we can skip
7085                                                                          ; the next three instructions
7086               
7087                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A by flipping all the bits and
     **** ****     > EOI
0001 2296 0200  20        li   rtmp,(>FF*256)
     2298 FF00     
0002 229A 2B40  18        xor  rtmp,ra
                   < elite.a99
7088                      .adi (>01*256)                  ; ADC #1            ; adding 1, i.e. using two's complement to make it
     **** ****     > ADI
0001 229C 1701  14        jnc  !
0002 229E B347  18        ab   rone,ra
0003               !:
0004 22A0 022D  22        ai   ra,(>01*256)
     22A2 0100     
                   < elite.a99
7089                                                                          ; positive
7090               
7091                      .sec                            ; SEC               ; Set the C flag, ready for the subtraction below
     **** ****     > SEC
0001 22A4 0A18  18        sla  rmone,1
                   < elite.a99
7092               
7093               LI1:
7094 22A6 D80D  30        movb ra,@P                      ; STA P             ; Store A in P, so P = |X2 - X1|, or |delta_x|
     22A8 001B     
7095               
7096 22AA D360  30        movb @Y2,ra                     ; LDA Y2            ; Set A = Y2 - Y1
     22AC 0034     
7097                      .sbc @Y1,ra                     ; SBC Y1            ; = delta_y
     **** ****     > SBC
0001 22AE 1801  14        joc  !
0002 22B0 7347  18        sb   rone,ra
0003               !:
0004 22B2 7360  30        sb   @Y1,ra
     22B4 0032     
                   < elite.a99
7098                                                                          ;
7099                                                                          ; This subtraction works as we either set the C flag
7100                                                                          ; above, or we skipped that SEC instruction with a BCS
7101               
7102 22B6 1807  14        joc  LI2                        ; BCS LI2           ; If Y2 > Y1 then A is already positive and we can skip
7103                                                                          ; the next two instructions
7104               
7105                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A by flipping all the bits and
     **** ****     > EOI
0001 22B8 0200  20        li   rtmp,(>FF*256)
     22BA FF00     
0002 22BC 2B40  18        xor  rtmp,ra
                   < elite.a99
7106                      .adi (>01*256)                  ; ADC #1            ; adding 1, i.e. using two's complement to make it
     **** ****     > ADI
0001 22BE 1701  14        jnc  !
0002 22C0 B347  18        ab   rone,ra
0003               !:
0004 22C2 022D  22        ai   ra,(>01*256)
     22C4 0100     
                   < elite.a99
7107                                                                          ; positive
7108               
7109               LI2:
7110 22C6 D80D  30        movb ra,@Q                      ; STA Q             ; Store A in Q, so Q = |Y2 - Y1|, or |delta_y|
     22C8 0090     
7111               
7112 22CA 9360  30        cb   @P,ra                      ; CMP P             ; If Q < P, jump to STPX to step along the x-axis, as
     22CC 001B     
7113 22CE 1702  14        jnc  STPX                       ; BCC STPX          ; the line is closer to being horizontal than vertical
7114               
7115 22D0 0460  28        b    @STPY                      ; JMP STPY          ; Otherwise Q >= P so jump to STPY to step along the
     22D2 245A     
7116                                                                          ; y-axis, as the line is closer to being vertical than
7117                                                                          ; horizontal
7118               
7119               * ******************************************************************************
7120               *
7121               * Name: LOIN (Part 2 of 7)
7122               * Type: Subroutine
7123               * Category: Drawing lines
7124               * Summary: Draw a line: Line has a shallow gradient, step right along x-axis
7125               * Deep dive: Bresenham's line algorithm
7126               *
7127               * ------------------------------------------------------------------------------
7128               *
7129               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7130               * If we get here, then:
7131               *
7132               * * |delta_y| < |delta_x|
7133               *
7134               * * The line is closer to being horizontal than vertical
7135               *
7136               * * We are going to step right along the x-axis
7137               *
7138               * * We potentially swap coordinates to make sure X1 < X2
7139               *
7140               * ******************************************************************************
7141               
7142               STPX:
7143 22D4 D3A0  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     22D6 0031     
7144               
7145 22D8 93A0  30        cb   @X2,rx                     ; CPX X2            ; If X1 < X2, jump down to LI3, as the coordinates are
     22DA 0033     
7146 22DC 1710  14        jnc  LI3                        ; BCC LI3           ; already in the order that we want
7147               
7148 22DE 7347  18        sb   rone,ra                    ; DEC SWAP          ; Otherwise decrement SWAP from 0 to &FF, to denote that
7149                                                                          ; we are swapping the coordinates around
7150               
7151 22E0 D360  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2
     22E2 0033     
7152 22E4 D80D  30        movb ra,@X1                     ; STA X1
     22E6 0031     
7153 22E8 D80E  30        movb rx,@X2                     ; STX X2
     22EA 0033     
7154               
7155 22EC D38D  18        movb ra,rx                      ; TAX               ; Set X = X1
7156               
7157 22EE D360  30        movb @Y2,ra                     ; LDA Y2            ; Swap the values of Y1 and Y2
     22F0 0034     
7158 22F2 D3E0  30        movb @Y1,ry                     ; LDY Y1
     22F4 0032     
7159 22F6 D80D  30        movb ra,@Y1                     ; STA Y1
     22F8 0032     
7160 22FA D80F  30        movb ry,@Y2                     ; STY Y2
     22FC 0034     
7161               
7162               LI3:
7163                                                                          ; By this point we know the line is horizontal-ish and
7164                                                                          ; X1 < X2, so we're going from left to right as we go
7165                                                                          ; from X1 to X2
7166 22FE D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 / 8, so A now contains the character row
     2300 0032     
7167 2302 091D  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7168 2304 091D  18        srl  ra,1                       ; LSR A
7169 2306 091D  18        srl  ra,1                       ; LSR A
7170               
7171 2308 026D  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     230A 6000     
7172                                                                          ; us the screen address of the character row (as each
7173                                                                          ; character row takes up 256 bytes, and the first
7174                                                                          ; character row is at screen address &6000, or page &60)
7175               
7176 230C D80D  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     230E 0008     
7177                                                                          ; the high byte of SC is set correctly for drawing the
7178                                                                          ; start of our line
7179               
7180 2310 D360  30        movb @Y1,ra                     ; LDA Y1            ; Set Y = Y1 mod 8, which is the pixel row within the
     2312 0032     
7181 2314 024D  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw the start of
     2316 0700     
7182 2318 D3CD  18        movb ra,ry                      ; TAY               ; our line (as each character block has 8 rows)
7183               
7184 231A D34E  18        movb rx,ra                      ; TXA               ; Set A = bits 3-7 of X1
7185 231C 024D  22        andi ra,>f8*256                 ; AND #%11111000
     231E F800     
7186               
7187 2320 D80D  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     2322 0007     
7188                                                                          ; screen address of the far left end (x-coordinate = 0)
7189                                                                          ; of the horizontal pixel row that we want to draw the
7190                                                                          ; start of our line on
7191               
7192 2324 D34E  18        movb rx,ra                      ; TXA               ; Set X = X1 mod 8, which is the horizontal pixel number
7193 2326 024D  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     2328 0700     
7194 232A D38D  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
7195                                                                          ; wide)
7196               
7197 232C D36E  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS where pixel X is set,
     232E 225D     
7198 2330 D80D  30        movb ra,@R                      ; STA R             ; and store it in R
     2332 0091     
7199               
7200                                                                          ; The following calculates:
7201                                                                          ;
7202                                                                          ; Q = Q / P
7203                                                                          ; = |delta_y| / |delta_x|
7204                                                                          ;
7205                                                                          ; using the same shift-and-subtract algorithm that's
7206                                                                          ; documented in TIS2
7207               
7208 2334 D360  30        movb @Q,ra                      ; LDA Q             ; Set A = |delta_y|
     2336 0090     
7209               
7210 2338 020E  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set Q to have bits 1-7 set, so we can rotate through 7
     233A FE00     
7211 233C D80E  30        movb rx,@Q                      ; STX Q             ; loop iterations, getting a 1 each time, and then
     233E 0090     
7212                                                                          ; getting a 0 on the 8th iteration... and we can also
7213                                                                          ; use Q to catch our result bits into bit 0 each time
7214               
7215               LIL1:
7216                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 2340 024D  22        andi ra,>ff00
     2342 FF00     
0002 2344 0A1D  18        sla  ra,1
                   < elite.a99
7217               
7218 2346 1803  14        joc  LI4                        ; BCS LI4           ; If bit 7 of A was set, then jump straight to the
7219                                                                          ; subtraction
7220               
7221 2348 9360  30        cb   @P,ra                      ; CMP P             ; If A < P, skip the following subtraction
     234A 001B     
7222 234C 1705  14        jnc  LI5                        ; BCC LI5
7223               
7224               LI4:
7225                      .sbc @P,ra                      ; SBC P             ; A >= P, so set A = A - P
     **** ****     > SBC
0001 234E 1801  14        joc  !
0002 2350 7347  18        sb   rone,ra
0003               !:
0004 2352 7360  30        sb   @P,ra
     2354 001B     
                   < elite.a99
7226               
7227                      .sec                            ; SEC               ; Set the C flag to rotate into the result in Q
     **** ****     > SEC
0001 2356 0A18  18        sla  rmone,1
                   < elite.a99
7228               
7229               LI5:
7230 2358 0204  20        li   rarg1,Q                    ; ROL Q             ; Rotate the counter in Q to the left, and catch the
     235A 0090     
7231 235C 06A0  32        bl   @rol                       ;
     235E FE4E     
7232                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
7233                                                                          ; do the subtraction, or 1 if we did)
7234               
7235 2360 18EF  14        joc  LIL1                       ; BCS LIL1          ; If we still have set bits in Q, loop back to TIL2 to
7236                                                                          ; do the next iteration of 7
7237               
7238                                                                          ; We now have:
7239                                                                          ;
7240                                                                          ; Q = A / P
7241                                                                          ; = |delta_y| / |delta_x|
7242                                                                          ;
7243                                                                          ; and the C flag is clear
7244               
7245 2362 D3A0  30        movb @P,rx                      ; LDX P             ; Set X = P + 1
     2364 001B     
7246 2366 B387  18        ab   rone,rx                    ; INX               ; = |delta_x| + 1
7247                                                                          ;
7248                                                                          ; We add 1 so we can skip the first pixel plot if the
7249                                                                          ; line is being drawn with swapped coordinates
7250               
7251 2368 D360  30        movb @Y2,ra                     ; LDA Y2            ; Set A = Y2 - Y1 - 1 (as the C flag is clear following
     236A 0034     
7252                      .sbc @Y1,ra                     ; SBC Y1            ; the above division)
     **** ****     > SBC
0001 236C 1801  14        joc  !
0002 236E 7347  18        sb   rone,ra
0003               !:
0004 2370 7360  30        sb   @Y1,ra
     2372 0032     
                   < elite.a99
7253               
7254 2374 1838  14        joc  DOWN                       ; BCS DOWN          ; If Y2 >= Y1 - 1 then jump to DOWN, as we need to draw
7255                                                                          ; the line to the right and down
7256               
7257               * ******************************************************************************
7258               *
7259               * Name: LOIN (Part 3 of 7)
7260               * Type: Subroutine
7261               * Category: Drawing lines
7262               * Summary: Draw a shallow line going right and up or left and down
7263               * Deep dive: Bresenham's line algorithm
7264               *
7265               * ------------------------------------------------------------------------------
7266               *
7267               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7268               * If we get here, then:
7269               *
7270               * * The line is going right and up (no swap) or left and down (swap)
7271               *
7272               * * X1 < X2 and Y1-1 > Y2
7273               *
7274               * * Draw from (X1, Y1) at bottom left to (X2, Y2) at top right, omitting the
7275               * first pixel
7276               *
7277               * ******************************************************************************
7278               
7279 2376 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP > 0 then we swapped the coordinates above, so
     2378 00A1     
7280 237A 160F  14        jne  LI6                        ; BNE LI6           ; jump down to LI6 to skip plotting the first pixel
7281                                                                          ;
7282                                                                          ; This appears to be a bug that omits the last pixel
7283                                                                          ; of this type of shallow line, rather than the first
7284                                                                          ; pixel, which makes the treatment of this kind of line
7285                                                                          ; different to the other kinds of slope (they all have a
7286                                                                          ; BEQ instruction at this point, rather than a BNE)
7287                                                                          ;
7288                                                                          ; The result is a rather messy line join when a shallow
7289                                                                          ; line that goes right and up or left and down joins a
7290                                                                          ; line with any of the other three types of slope
7291                                                                          ;
7292                                                                          ; This bug was fixed in the advanced versions of Elite,
7293                                                                          ; where the BNE is replaced by a BEQ to bring it in line
7294                                                                          ; with the other three slopes
7295               
7296 237C 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7297                                                                          ; the first pixel
7298               
7299               LIL2:
7300                                                                          ; We now loop along the line from left to right, using X
7301                                                                          ; as a decreasing counter, and at each count we plot a
7302                                                                          ; single pixel using the pixel mask in R
7303 237E D360  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     2380 0091     
7304               
7305                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 2382 D020  30        movb @SC,rtmp
     2384 0007     
0002 2386 2B40  18        xor  rtmp,ra
                   < elite.a99
7306                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 2388 D820  42        movb @SC,@rtmplb
     238A 0007     
     238C 8301     
0002 238E D020  30        movb @SC+1,rtmp
     2390 0008     
0003 2392 06CF  14        swpb ry
0004 2394 A00F  18        a    ry,rtmp
0005 2396 06CF  14        swpb ry
0006 2398 D40D  30        movb RA,*rtmp
                   < elite.a99
7307               
7308               LI6:
7309                      .lsr @R                         ; LSR R             ; Shift the single pixel in R to the right to step along
     **** ****     > LSR
0001 239A D020  30        movb @R,rtmp
     239C 0091     
0002 239E 0910  18        srl  rtmp,1
0003 23A0 D800  30        movb rtmp,@R
     23A2 0091     
                   < elite.a99
7310                                                                          ; the x-axis, so the next pixel we plot will be at the
7311                                                                          ; next x-coordinate along
7312               
7313 23A4 170C  14        jnc  LI7                        ; BCC LI7           ; If the pixel didn't fall out of the right end of R
7314                                                                          ; into the C flag, then jump to LI7
7315               
7316 23A6 0204  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     23A8 0091     
7317 23AA 06A0  32        bl   @ror                       ;
     23AC FE7A     
7318                                                                          ; block, so first rotate R right so the set C flag goes
7319                                                                          ; back into the left end, giving %10000000
7320               
7321 23AE D360  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     23B0 0007     
7322                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 23B2 1701  14        jnc  !
0002 23B4 B347  18        ab   rone,ra
0003               !:
0004 23B6 022D  22        ai   ra,(>08*256)
     23B8 0800     
                   < elite.a99
7323 23BA D80D  30        movb ra,@SC                     ; STA SC
     23BC 0007     
7324               
7325               LI7:
7326 23BE D360  30        movb @S,ra                      ; LDA S             ; Set S = S + Q to update the slope error
     23C0 0092     
7327                      .adc @Q,ra                      ; ADC Q
     **** ****     > ADC
0001 23C2 1701  14        jnc  !
0002 23C4 B347  18        ab   rone,ra
0003               !:
0004 23C6 B360  30        ab   @Q,ra
     23C8 0090     
                   < elite.a99
7328 23CA D80D  30        movb ra,@S                      ; STA S
     23CC 0092     
7329               
7330 23CE 1705  14        jnc  LIC2                       ; BCC LIC2          ; If the addition didn't overflow, jump to LIC2
7331               
7332 23D0 73C7  18        sb   rone,ry                    ; DEY               ; Otherwise we just overflowed, so decrement Y to move
7333                                                                          ; to the pixel line above
7334               
7335 23D2 1503  14        jgt  LIC2                       ; BPL LIC2          ; If Y is positive we are still within the same
7336                                                                          ; character block, so skip to LIC2
7337               
7338 23D4 7347  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7339 23D6 020F  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     23D8 0700     
7340                                                                          ; address and set the pixel line to the last line in
7341                                                                          ; that character block
7342               
7343               LIC2:
7344 23DA 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7345               
7346 23DC 16D0  14        jne  LIL2                       ; BNE LIL2          ; If we haven't yet reached the right end of the line,
7347                                                                          ; loop back to LIL2 to plot the next pixel along
7348               
7349 23DE D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     23E0 0094     
7350               
7351 23E2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     23E4 FE34     
7352               
7353               * ******************************************************************************
7354               *
7355               * Name: LOIN (Part 4 of 7)
7356               * Type: Subroutine
7357               * Category: Drawing lines
7358               * Summary: Draw a shallow line going right and down or left and up
7359               * Deep dive: Bresenham's line algorithm
7360               *
7361               * ------------------------------------------------------------------------------
7362               *
7363               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7364               * If we get here, then:
7365               *
7366               * * The line is going right and down (no swap) or left and up (swap)
7367               *
7368               * * X1 < X2 and Y1-1 <= Y2
7369               *
7370               * * Draw from (X1, Y1) at top left to (X2, Y2) at bottom right, omitting the
7371               * first pixel
7372               *
7373               * ******************************************************************************
7374               
7375               DOWN:
7376 23E6 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     23E8 00A1     
7377 23EA 130F  14        jeq  LI9                        ; BEQ LI9           ; so jump down to LI9 to skip plotting the first pixel
7378               
7379 23EC 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7380                                                                          ; the first pixel
7381               
7382               LIL3:
7383                                                                          ; We now loop along the line from left to right, using X
7384                                                                          ; as a decreasing counter, and at each count we plot a
7385                                                                          ; single pixel using the pixel mask in R
7386 23EE D360  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     23F0 0091     
7387               
7388                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 23F2 D020  30        movb @SC,rtmp
     23F4 0007     
0002 23F6 2B40  18        xor  rtmp,ra
                   < elite.a99
7389                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 23F8 D820  42        movb @SC,@rtmplb
     23FA 0007     
     23FC 8301     
0002 23FE D020  30        movb @SC+1,rtmp
     2400 0008     
0003 2402 06CF  14        swpb ry
0004 2404 A00F  18        a    ry,rtmp
0005 2406 06CF  14        swpb ry
0006 2408 D40D  30        movb RA,*rtmp
                   < elite.a99
7390               
7391               LI9:
7392                      .lsr @R                         ; LSR R             ; Shift the single pixel in R to the right to step along
     **** ****     > LSR
0001 240A D020  30        movb @R,rtmp
     240C 0091     
0002 240E 0910  18        srl  rtmp,1
0003 2410 D800  30        movb rtmp,@R
     2412 0091     
                   < elite.a99
7393                                                                          ; the x-axis, so the next pixel we plot will be at the
7394                                                                          ; next x-coordinate along
7395               
7396 2414 170C  14        jnc  LI10                       ; BCC LI10          ; If the pixel didn't fall out of the right end of R
7397                                                                          ; into the C flag, then jump to LI10
7398               
7399 2416 0204  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     2418 0091     
7400 241A 06A0  32        bl   @ror                       ;
     241C FE7A     
7401                                                                          ; block, so first rotate R right so the set C flag goes
7402                                                                          ; back into the left end, giving %10000000
7403               
7404 241E D360  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     2420 0007     
7405                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 2422 1701  14        jnc  !
0002 2424 B347  18        ab   rone,ra
0003               !:
0004 2426 022D  22        ai   ra,(>08*256)
     2428 0800     
                   < elite.a99
7406 242A D80D  30        movb ra,@SC                     ; STA SC
     242C 0007     
7407               
7408               LI10:
7409 242E D360  30        movb @S,ra                      ; LDA S             ; Set S = S + Q to update the slope error
     2430 0092     
7410                      .adc @Q,ra                      ; ADC Q
     **** ****     > ADC
0001 2432 1701  14        jnc  !
0002 2434 B347  18        ab   rone,ra
0003               !:
0004 2436 B360  30        ab   @Q,ra
     2438 0090     
                   < elite.a99
7411 243A D80D  30        movb ra,@S                      ; STA S
     243C 0092     
7412               
7413 243E 1707  14        jnc  LIC3                       ; BCC LIC3          ; If the addition didn't overflow, jump to LIC3
7414               
7415 2440 B3C7  18        ab   rone,ry                    ; INY               ; Otherwise we just overflowed, so increment Y to move
7416                                                                          ; to the pixel line below
7417               
7418 2442 028F  22        ci   ry,>08*256                 ; CPY #8            ; If Y < 8 we are still within the same character block,
     2444 0800     
7419 2446 1603  14        jne  LIC3                       ; BNE LIC3          ; so skip to LIC3
7420               
7421 2448 B347  18        ab   rone,ra                    ; INC SCH           ; Otherwise we need to move down into the character
7422 244A 020F  20        li   ry,>00*256                 ; LDY #0            ; block below, so increment the high byte of the screen
     244C 0000     
7423                                                                          ; address and set the pixel line to the first line in
7424                                                                          ; that character block
7425               
7426               LIC3:
7427 244E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7428               
7429 2450 16CE  14        jne  LIL3                       ; BNE LIL3          ; If we haven't yet reached the right end of the line,
7430                                                                          ; loop back to LIL3 to plot the next pixel along
7431               
7432 2452 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2454 0094     
7433               
7434 2456 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2458 FE34     
7435               
7436               * ******************************************************************************
7437               *
7438               * Name: LOIN (Part 5 of 7)
7439               * Type: Subroutine
7440               * Category: Drawing lines
7441               * Summary: Draw a line: Line has a steep gradient, step up along y-axis
7442               * Deep dive: Bresenham's line algorithm
7443               *
7444               * ------------------------------------------------------------------------------
7445               *
7446               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7447               * If we get here, then:
7448               *
7449               * * |delta_y| >= |delta_x|
7450               *
7451               * * The line is closer to being vertical than horizontal
7452               *
7453               * * We are going to step up along the y-axis
7454               *
7455               * * We potentially swap coordinates to make sure Y1 >= Y2
7456               *
7457               * ******************************************************************************
7458               
7459               STPY:
7460 245A D3E0  30        movb @Y1,ry                     ; LDY Y1            ; Set A = Y = Y1
     245C 0032     
7461 245E D34F  18        movb ry,ra                      ; TYA
7462               
7463 2460 D3A0  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     2462 0031     
7464               
7465 2464 93E0  30        cb   @Y2,ry                     ; CPY Y2            ; If Y1 >= Y2, jump down to LI15, as the coordinates are
     2466 0034     
7466 2468 180F  14        joc  LI15                       ; BCS LI15          ; already in the order that we want
7467               
7468 246A 7347  18        sb   rone,ra                    ; DEC SWAP          ; Otherwise decrement SWAP from 0 to &FF, to denote that
7469                                                                          ; we are swapping the coordinates around
7470               
7471 246C D360  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2
     246E 0033     
7472 2470 D80D  30        movb ra,@X1                     ; STA X1
     2472 0031     
7473 2474 D80E  30        movb rx,@X2                     ; STX X2
     2476 0033     
7474               
7475 2478 D38D  18        movb ra,rx                      ; TAX               ; Set X = X1
7476               
7477 247A D360  30        movb @Y2,ra                     ; LDA Y2            ; Swap the values of Y1 and Y2
     247C 0034     
7478 247E D80D  30        movb ra,@Y1                     ; STA Y1
     2480 0032     
7479 2482 D80F  30        movb ry,@Y2                     ; STY Y2
     2484 0034     
7480               
7481 2486 D3CD  18        movb ra,ry                      ; TAY               ; Set Y = A = Y1
7482               
7483               LI15:
7484                                                                          ; By this point we know the line is vertical-ish and
7485                                                                          ; Y1 >= Y2, so we're going from top to bottom as we go
7486                                                                          ; from Y1 to Y2
7487 2488 091D  18        srl  ra,1                       ; LSR A             ; Set A = Y1 / 8, so A now contains the character row
7488 248A 091D  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7489 248C 091D  18        srl  ra,1                       ; LSR A
7490               
7491 248E 026D  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     2490 6000     
7492                                                                          ; us the screen address of the character row (as each
7493                                                                          ; character row takes up 256 bytes, and the first
7494                                                                          ; character row is at screen address &6000, or page &60)
7495               
7496 2492 D80D  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     2494 0008     
7497                                                                          ; the high byte of SC is set correctly for drawing the
7498                                                                          ; start of our line
7499               
7500 2496 D34E  18        movb rx,ra                      ; TXA               ; Set A = bits 3-7 of X1
7501 2498 024D  22        andi ra,>f8*256                 ; AND #%11111000
     249A F800     
7502               
7503 249C D80D  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     249E 0007     
7504                                                                          ; screen address of the far left end (x-coordinate = 0)
7505                                                                          ; of the horizontal pixel row that we want to draw the
7506                                                                          ; start of our line on
7507               
7508 24A0 D34E  18        movb rx,ra                      ; TXA               ; Set X = X1 mod 8, which is the horizontal pixel number
7509 24A2 024D  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     24A4 0700     
7510 24A6 D38D  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
7511                                                                          ; wide)
7512               
7513 24A8 D36E  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS where pixel X is set,
     24AA 225D     
7514 24AC D80D  30        movb ra,@R                      ; STA R             ; and store it in R
     24AE 0091     
7515               
7516 24B0 D360  30        movb @Y1,ra                     ; LDA Y1            ; Set Y = Y1 mod 8, which is the pixel row within the
     24B2 0032     
7517 24B4 024D  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw the start of
     24B6 0700     
7518 24B8 D3CD  18        movb ra,ry                      ; TAY               ; our line (as each character block has 8 rows)
7519               
7520                                                                          ; The following calculates:
7521                                                                          ;
7522                                                                          ; P = P / Q
7523                                                                          ; = |delta_x| / |delta_y|
7524                                                                          ;
7525                                                                          ; using the same shift-and-subtract algorithm
7526                                                                          ; documented in TIS2
7527               
7528 24BA D360  30        movb @P,ra                      ; LDA P             ; Set A = |delta_x|
     24BC 001B     
7529               
7530 24BE 020E  20        li   rx,>01*256                 ; LDX #1            ; Set Q to have bits 1-7 clear, so we can rotate through
     24C0 0100     
7531 24C2 D80E  30        movb rx,@P                      ; STX P             ; 7 loop iterations, getting a 1 each time, and then
     24C4 001B     
7532                                                                          ; getting a 1 on the 8th iteration... and we can also
7533                                                                          ; use P to catch our result bits into bit 0 each time
7534               
7535               LIL4:
7536                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 24C6 024D  22        andi ra,>ff00
     24C8 FF00     
0002 24CA 0A1D  18        sla  ra,1
                   < elite.a99
7537               
7538 24CC 1803  14        joc  LI13                       ; BCS LI13          ; If bit 7 of A was set, then jump straight to the
7539                                                                          ; subtraction
7540               
7541 24CE 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q, skip the following subtraction
     24D0 0090     
7542 24D2 1705  14        jnc  LI14                       ; BCC LI14
7543               
7544               LI13:
7545                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 24D4 1801  14        joc  !
0002 24D6 7347  18        sb   rone,ra
0003               !:
0004 24D8 7360  30        sb   @Q,ra
     24DA 0090     
                   < elite.a99
7546               
7547                      .sec                            ; SEC               ; Set the C flag to rotate into the result in Q
     **** ****     > SEC
0001 24DC 0A18  18        sla  rmone,1
                   < elite.a99
7548               
7549               LI14:
7550 24DE 0204  20        li   rarg1,P                    ; ROL P             ; Rotate the counter in P to the left, and catch the
     24E0 001B     
7551 24E2 06A0  32        bl   @rol                       ;
     24E4 FE4E     
7552                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
7553                                                                          ; do the subtraction, or 1 if we did)
7554               
7555 24E6 17EF  14        jnc  LIL4                       ; BCC LIL4          ; If we still have set bits in P, loop back to TIL2 to
7556                                                                          ; do the next iteration of 7
7557               
7558                                                                          ; We now have:
7559                                                                          ;
7560                                                                          ; P = A / Q
7561                                                                          ; = |delta_x| / |delta_y|
7562                                                                          ;
7563                                                                          ; and the C flag is set
7564               
7565 24E8 D3A0  30        movb @Q,rx                      ; LDX Q             ; Set X = Q + 1
     24EA 0090     
7566 24EC B387  18        ab   rone,rx                    ; INX               ; = |delta_y| + 1
7567                                                                          ;
7568                                                                          ; We add 1 so we can skip the first pixel plot if the
7569                                                                          ; line is being drawn with swapped coordinates
7570               
7571 24EE D360  30        movb @X2,ra                     ; LDA X2            ; Set A = X2 - X1 (the C flag is set as we didn't take
     24F0 0033     
7572                      .sbc @X1,ra                     ; SBC X1            ; the above BCC)
     **** ****     > SBC
0001 24F2 1801  14        joc  !
0002 24F4 7347  18        sb   rone,ra
0003               !:
0004 24F6 7360  30        sb   @X1,ra
     24F8 0031     
                   < elite.a99
7573               
7574 24FA 1739  14        jnc  LFT                        ; BCC LFT           ; If X2 < X1 then jump to LFT, as we need to draw the
7575                                                                          ; line to the left and down
7576               
7577               * ******************************************************************************
7578               *
7579               * Name: LOIN (Part 6 of 7)
7580               * Type: Subroutine
7581               * Category: Drawing lines
7582               * Summary: Draw a steep line going up and left or down and right
7583               * Deep dive: Bresenham's line algorithm
7584               *
7585               * ------------------------------------------------------------------------------
7586               *
7587               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7588               * If we get here, then:
7589               *
7590               * * The line is going up and left (no swap) or down and right (swap)
7591               *
7592               * * X1 < X2 and Y1 >= Y2
7593               *
7594               * * Draw from (X1, Y1) at top left to (X2, Y2) at bottom right, omitting the
7595               * first pixel
7596               *
7597               * ******************************************************************************
7598               
7599                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 24FC 0A16  18        sla  rzero,1
                   < elite.a99
7600               
7601 24FE D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     2500 00A1     
7602 2502 130F  14        jeq  LI17                       ; BEQ LI17          ; so jump down to LI17 to skip plotting the first pixel
7603               
7604 2504 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7605                                                                          ; the first pixel
7606               
7607               LIL5:
7608                                                                          ; We now loop along the line from left to right, using X
7609                                                                          ; as a decreasing counter, and at each count we plot a
7610                                                                          ; single pixel using the pixel mask in R
7611 2506 D360  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     2508 0091     
7612               
7613                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 250A D020  30        movb @SC,rtmp
     250C 0007     
0002 250E 2B40  18        xor  rtmp,ra
                   < elite.a99
7614                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 2510 D820  42        movb @SC,@rtmplb
     2512 0007     
     2514 8301     
0002 2516 D020  30        movb @SC+1,rtmp
     2518 0008     
0003 251A 06CF  14        swpb ry
0004 251C A00F  18        a    ry,rtmp
0005 251E 06CF  14        swpb ry
0006 2520 D40D  30        movb RA,*rtmp
                   < elite.a99
7615               
7616               LI17:
7617 2522 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to step up along the y-axis
7618               
7619 2524 1503  14        jgt  LI16                       ; BPL LI16          ; If Y is positive we are still within the same
7620                                                                          ; character block, so skip to LI16
7621               
7622 2526 7347  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7623 2528 020F  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     252A 0700     
7624                                                                          ; address and set the pixel line to the last line in
7625                                                                          ; that character block
7626               
7627               LI16:
7628 252C D360  30        movb @S,ra                      ; LDA S             ; Set S = S + P to update the slope error
     252E 0092     
7629                      .adc @P,ra                      ; ADC P
     **** ****     > ADC
0001 2530 1701  14        jnc  !
0002 2532 B347  18        ab   rone,ra
0003               !:
0004 2534 B360  30        ab   @P,ra
     2536 001B     
                   < elite.a99
7630 2538 D80D  30        movb ra,@S                      ; STA S
     253A 0092     
7631               
7632 253C 1712  14        jnc  LIC5                       ; BCC LIC5          ; If the addition didn't overflow, jump to LIC5
7633               
7634                      .lsr @R                         ; LSR R             ; Otherwise we just overflowed, so shift the single
     **** ****     > LSR
0001 253E D020  30        movb @R,rtmp
     2540 0091     
0002 2542 0910  18        srl  rtmp,1
0003 2544 D800  30        movb rtmp,@R
     2546 0091     
                   < elite.a99
7635                                                                          ; pixel in R to the right, so the next pixel we plot
7636                                                                          ; will be at the next x-coordinate along
7637               
7638 2548 170C  14        jnc  LIC5                       ; BCC LIC5          ; If the pixel didn't fall out of the right end of R
7639                                                                          ; into the C flag, then jump to LIC5
7640               
7641 254A 0204  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     254C 0091     
7642 254E 06A0  32        bl   @ror                       ;
     2550 FE7A     
7643                                                                          ; block, so first rotate R right so the set C flag goes
7644                                                                          ; back into the left end, giving %10000000
7645               
7646 2552 D360  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     2554 0007     
7647                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 2556 1701  14        jnc  !
0002 2558 B347  18        ab   rone,ra
0003               !:
0004 255A 022D  22        ai   ra,(>08*256)
     255C 0800     
                   < elite.a99
7648 255E D80D  30        movb ra,@SC                     ; STA SC
     2560 0007     
7649               
7650               LIC5:
7651 2562 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7652               
7653 2564 16D0  14        jne  LIL5                       ; BNE LIL5          ; If we haven't yet reached the right end of the line,
7654                                                                          ; loop back to LIL5 to plot the next pixel along
7655               
7656 2566 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2568 0094     
7657               
7658 256A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     256C FE34     
7659               
7660               * ******************************************************************************
7661               *
7662               * Name: LOIN (Part 7 of 7)
7663               * Type: Subroutine
7664               * Category: Drawing lines
7665               * Summary: Draw a steep line going up and right or down and left
7666               * Deep dive: Bresenham's line algorithm
7667               *
7668               * ------------------------------------------------------------------------------
7669               *
7670               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7671               * If we get here, then:
7672               *
7673               * * The line is going up and right (no swap) or down and left (swap)
7674               *
7675               * * X1 >= X2 and Y1 >= Y2
7676               *
7677               * * Draw from (X1, Y1) at bottom left to (X2, Y2) at top right, omitting the
7678               * first pixel
7679               *
7680               * ------------------------------------------------------------------------------
7681               *
7682               * Other entry points:
7683               *
7684               * HL6                 Contains an RTS
7685               *
7686               * ******************************************************************************
7687               
7688               LFT:
7689 256E D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     2570 00A1     
7690 2572 130F  14        jeq  LI18                       ; BEQ LI18          ; so jump down to LI18 to skip plotting the first pixel
7691               
7692 2574 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7693                                                                          ; the first pixel
7694               
7695               LIL6:
7696 2576 D360  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     2578 0091     
7697               
7698                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 257A D020  30        movb @SC,rtmp
     257C 0007     
0002 257E 2B40  18        xor  rtmp,ra
                   < elite.a99
7699                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 2580 D820  42        movb @SC,@rtmplb
     2582 0007     
     2584 8301     
0002 2586 D020  30        movb @SC+1,rtmp
     2588 0008     
0003 258A 06CF  14        swpb ry
0004 258C A00F  18        a    ry,rtmp
0005 258E 06CF  14        swpb ry
0006 2590 D40D  30        movb RA,*rtmp
                   < elite.a99
7700               
7701               LI18:
7702 2592 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to step up along the y-axis
7703               
7704 2594 1503  14        jgt  LI19                       ; BPL LI19          ; If Y is positive we are still within the same
7705                                                                          ; character block, so skip to LI19
7706               
7707 2596 7347  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7708 2598 020F  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     259A 0700     
7709                                                                          ; address and set the pixel line to the last line in
7710                                                                          ; that character block
7711               
7712               LI19:
7713 259C D360  30        movb @S,ra                      ; LDA S             ; Set S = S + P to update the slope error
     259E 0092     
7714                      .adc @P,ra                      ; ADC P
     **** ****     > ADC
0001 25A0 1701  14        jnc  !
0002 25A2 B347  18        ab   rone,ra
0003               !:
0004 25A4 B360  30        ab   @P,ra
     25A6 001B     
                   < elite.a99
7715 25A8 D80D  30        movb ra,@S                      ; STA S
     25AA 0092     
7716               
7717 25AC 1715  14        jnc  LIC6                       ; BCC LIC6          ; If the addition didn't overflow, jump to LIC6
7718               
7719                      .asl @R                         ; ASL R             ; Otherwise we just overflowed, so shift the single
     **** ****     > ASL
0001 25AE D020  30        movb @R,rtmp
     25B0 0091     
0002 25B2 0240  22        andi rtmp,>ff00
     25B4 FF00     
0003 25B6 0A10  18        sla  rtmp,1
0004 25B8 D800  30        movb rtmp,@R
     25BA 0091     
                   < elite.a99
7720                                                                          ; pixel in R to the left, so the next pixel we plot
7721                                                                          ; will be at the previous x-coordinate
7722               
7723 25BC 170D  14        jnc  LIC6                       ; BCC LIC6          ; If the pixel didn't fall out of the left end of R
7724                                                                          ; into the C flag, then jump to LIC6
7725               
7726 25BE 0204  20        li   rarg1,R                    ; ROL R             ; Otherwise we need to move over to the next character
     25C0 0091     
7727 25C2 06A0  32        bl   @rol                       ;
     25C4 FE4E     
7728                                                                          ; block, so first rotate R left so the set C flag goes
7729                                                                          ; back into the right end, giving %0000001
7730               
7731 25C6 D360  30        movb @SC,ra                     ; LDA SC            ; Subtract 7 from SC, so SC(1 0) now points to the
     25C8 0007     
7732                      .sbi (>07*256)                  ; SBC #7            ; previous character along to the left
     **** ****     > SBI
0001 25CA 1801  14        joc  !
0002 25CC 7347  18        sb   rone,ra
0003               !:
0004 25CE 022D  22        ai   ra,-(>07*256)
     25D0 F900     
                   < elite.a99
7733 25D2 D80D  30        movb ra,@SC                     ; STA SC
     25D4 0007     
7734               
7735                      .clc                            ; CLC               ; Clear the C flag so it doesn't affect the additions
     **** ****     > CLC
0001 25D6 0A16  18        sla  rzero,1
                   < elite.a99
7736                                                                          ; below
7737               
7738               LIC6:
7739 25D8 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7740               
7741 25DA 16CD  14        jne  LIL6                       ; BNE LIL6          ; If we haven't yet reached the left end of the line,
7742                                                                          ; loop back to LIL6 to plot the next pixel along
7743               
7744 25DC D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     25DE 0094     
7745               
7746               HL6:
7747 25E0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     25E2 FE34     
7748               
7749               * ******************************************************************************
7750               *
7751               * Name: NLIN3
7752               * Type: Subroutine
7753               * Category: Drawing lines
7754               * Summary: Print a title and draw a horizontal line at row 19 to box it in
7755               *
7756               * ------------------------------------------------------------------------------
7757               *
7758               * This routine print a text token at the cursor position and draws a horizontal
7759               * line at pixel row 19. It is used for the Status Mode screen, the Short-range
7760               * Chart, the Market Price screen and the Equip Ship screen.
7761               *
7762               * ******************************************************************************
7763               
7764               NLIN3:
7765 25E4 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     25E6 A6E8     
7766 25E8 06A0  32        bl   @jsr                       ;
     25EA FE28     
7767               
7768                                                                          ; Fall through into NLIN4 to draw a horizontal line at
7769                                                                          ; pixel row 19
7770               
7771               * ******************************************************************************
7772               *
7773               * Name: NLIN4
7774               * Type: Subroutine
7775               * Category: Drawing lines
7776               * Summary: Draw a horizontal line at pixel row 19 to box in a title
7777               *
7778               * ------------------------------------------------------------------------------
7779               *
7780               * This routine is used on the Inventory screen to draw a horizontal line at
7781               * pixel row 19 to box in the title.
7782               *
7783               * ******************************************************************************
7784               
7785               NLIN4:
7786 25EC 020D  20        li   ra,>13*256                 ; LDA #19           ; Jump to NLIN2 to draw a horizontal line at pixel row
     25EE 1300     
7787 25F0 1603  14        jne  NLIN2                      ; BNE NLIN2         ; 19, returning from the subroutine with using a tail
7788                                                                          ; call (this BNE is effectively a JMP as A will never
7789                                                                          ; be zero)
7790               
7791               * ******************************************************************************
7792               *
7793               * Name: NLIN
7794               * Type: Subroutine
7795               * Category: Drawing lines
7796               * Summary: Draw a horizontal line at pixel row 23 to box in a title
7797               *
7798               * ------------------------------------------------------------------------------
7799               *
7800               * Draw a horizontal line at pixel row 23 and move the text cursor down one
7801               * line.
7802               *
7803               * ******************************************************************************
7804               
7805               NLIN:
7806 25F2 020D  20        li   ra,>17*256                 ; LDA #23           ; Set A = 23 so NLIN2 below draws a horizontal line at
     25F4 1700     
7807                                                                          ; pixel row 23
7808               
7809 25F6 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
7810               
7811                                                                          ; Fall through into NLIN2 to draw the horizontal line
7812                                                                          ; at row 23
7813               
7814               * ******************************************************************************
7815               *
7816               * Name: NLIN2
7817               * Type: Subroutine
7818               * Category: Drawing lines
7819               * Summary: Draw a screen-wide horizontal line at the pixel row in A
7820               *
7821               * ------------------------------------------------------------------------------
7822               *
7823               * This draws a line from (2, A) to (254, A), which is almost screen-wide and
7824               * fits in nicely between the white borders without clashing with it.
7825               *
7826               * ------------------------------------------------------------------------------
7827               *
7828               * Arguments:
7829               *
7830               * A                   The pixel row on which to draw the horizontal line
7831               *
7832               * ******************************************************************************
7833               
7834               NLIN2:
7835 25F8 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 = A
     25FA 0032     
7836               
7837 25FC 020E  20        li   rx,>02*256                 ; LDX #2            ; Set X1 = 2, so (X1, Y1) = (2, A)
     25FE 0200     
7838 2600 D80E  30        movb rx,@X1                     ; STX X1
     2602 0031     
7839               
7840 2604 020E  20        li   rx,>fe*256                 ; LDX #254          ; Set X2 = 254, so (X2, Y2) = (254, A)
     2606 FE00     
7841 2608 D80E  30        movb rx,@X2                     ; STX X2
     260A 0033     
7842               
7843 260C 160A  14        jne  HLOIN                      ; BNE HLOIN         ; Call HLOIN to draw a horizontal line from (2, A) to
7844                                                                          ; (254, A) and return from the subroutine (this BNE is
7845                                                                          ; effectively a JMP as A will never be zero)
7846               
7847               * ******************************************************************************
7848               *
7849               * Name: HLOIN2
7850               * Type: Subroutine
7851               * Category: Drawing lines
7852               * Summary: Remove a line from the sun line heap and draw it on-screen
7853               *
7854               * ------------------------------------------------------------------------------
7855               *
7856               * Specifically, this does the following:
7857               *
7858               * * Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
7859               * centre YY(1 0) and length A to the left and right
7860               *
7861               * * Set the Y-th byte of the LSO block to 0 (i.e. remove this line from the
7862               * sun line heap)
7863               *
7864               * * Draw a horizontal line from (X1, Y) to (X2, Y)
7865               *
7866               * ------------------------------------------------------------------------------
7867               *
7868               * Arguments:
7869               *
7870               * YY(1 0)             The x-coordinate of the centre point of the line
7871               *
7872               * A                   The half-width of the line, i.e. the contents of the
7873               * Y-th byte of the sun line heap
7874               *
7875               * Y                   The number of the entry in the sun line heap (which is
7876               * also the y-coordinate of the line)
7877               *
7878               * ------------------------------------------------------------------------------
7879               *
7880               * Returns:
7881               *
7882               * Y                   Y is preserved
7883               *
7884               * ******************************************************************************
7885               
7886               HLOIN2:
7887 260E 0200  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     2610 BA12     
7888 2612 06A0  32        bl   @jsr                       ;
     2614 FE28     
7889                                                                          ; line centred on YY(1 0) and with half-width A
7890               
7891 2616 D80F  30        movb ry,@Y1                     ; STY Y1            ; Set Y1 = Y
     2618 0032     
7892               
7893 261A 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the Y-th byte of the LSO block to 0
     261C 0000     
7894 261E DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y
     2620 0D66     
7895               
7896                                                                          ; Fall through into HLOIN to draw a horizontal line from
7897                                                                          ; (X1, Y) to (X2, Y)
7898               
7899               * ******************************************************************************
7900               *
7901               * Name: HLOIN
7902               * Type: Subroutine
7903               * Category: Drawing lines
7904               * Summary: Draw a horizontal line from (X1, Y1) to (X2, Y1)
7905               * Deep dive: Drawing monochrome pixels in mode 4
7906               *
7907               * ------------------------------------------------------------------------------
7908               *
7909               * We do not draw a pixel at the right end of the line.
7910               *
7911               * To understand how this routine works, you might find it helpful to read the
7912               * deep dive on "Drawing monochrome pixels in mode 4".
7913               *
7914               * ------------------------------------------------------------------------------
7915               *
7916               * Returns:
7917               *
7918               * Y                   Y is preserved
7919               *
7920               * ******************************************************************************
7921               
7922               HLOIN:
7923 2622 D80F  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y into YSAV, so we can preserve it across the
     2624 0094     
7924                                                                          ; call to this subroutine
7925               
7926 2626 D3A0  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     2628 0031     
7927               
7928 262A 93A0  30        cb   @X2,rx                     ; CPX X2            ; If X1 = X2 then the start and end points are the same,
     262C 0033     
7929 262E 13D8  14        jeq  HL6                        ; BEQ HL6           ; so return from the subroutine (as HL6 contains an RTS)
7930               
7931 2630 1707  14        jnc  HL5                        ; BCC HL5           ; If X1 < X2, jump to HL5 to skip the following code, as
7932                                                                          ; (X1, Y1) is already the left point
7933               
7934 2632 D360  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2, so we know that (X1, Y1)
     2634 0033     
7935 2636 D80D  30        movb ra,@X1                     ; STA X1            ; is on the left and (X2, Y1) is on the right
     2638 0031     
7936 263A D80E  30        movb rx,@X2                     ; STX X2
     263C 0033     
7937               
7938 263E D38D  18        movb ra,rx                      ; TAX               ; Set X = X1
7939               
7940               HL5:
7941 2640 7347  18        sb   rone,ra                    ; DEC X2            ; Decrement X2 so we do not draw a pixel at the end
7942                                                                          ; point
7943               
7944 2642 D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 / 8, so A now contains the character row
     2644 0032     
7945 2646 091D  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7946 2648 091D  18        srl  ra,1                       ; LSR A
7947 264A 091D  18        srl  ra,1                       ; LSR A
7948               
7949 264C 026D  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     264E 6000     
7950                                                                          ; us the screen address of the character row (as each
7951                                                                          ; character row takes up 256 bytes, and the first
7952                                                                          ; character row is at screen address &6000, or page &60)
7953               
7954 2650 D80D  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     2652 0008     
7955                                                                          ; the high byte of SC is set correctly for drawing our
7956                                                                          ; line
7957               
7958 2654 D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 mod 8, which is the pixel row within the
     2656 0032     
7959 2658 024D  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw our line (as
     265A 0700     
7960                                                                          ; each character block has 8 rows)
7961               
7962 265C D80D  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     265E 0007     
7963                                                                          ; screen address of the far left end (x-coordinate = 0)
7964                                                                          ; of the horizontal pixel row that we want to draw our
7965                                                                          ; horizontal line on
7966               
7967 2660 D34E  18        movb rx,ra                      ; TXA               ; Set Y = bits 3-7 of X1
7968 2662 024D  22        andi ra,>f8*256                 ; AND #%11111000
     2664 F800     
7969 2666 D3CD  18        movb ra,ry                      ; TAY
7970               
7971               HL1:
7972 2668 D34E  18        movb rx,ra                      ; TXA               ; Set T = bits 3-7 of X1, which will contain the
7973 266A 024D  22        andi ra,>f8*256                 ; AND #%11111000    ; character number of the start of the line * 8
     266C F800     
7974 266E D80D  30        movb ra,@T                      ; STA T
     2670 00D1     
7975               
7976 2672 D360  30        movb @X2,ra                     ; LDA X2            ; Set A = bits 3-7 of X2, which will contain the
     2674 0033     
7977 2676 024D  22        andi ra,>f8*256                 ; AND #%11111000    ; character number of the end of the line * 8
     2678 F800     
7978               
7979                      .sec                            ; SEC               ; Set A = A - T, which will contain the number of
     **** ****     > SEC
0001 267A 0A18  18        sla  rmone,1
                   < elite.a99
7980                      .sbc @T,ra                      ; SBC T             ; character blocks we need to fill - 1 * 8
     **** ****     > SBC
0001 267C 1801  14        joc  !
0002 267E 7347  18        sb   rone,ra
0003               !:
0004 2680 7360  30        sb   @T,ra
     2682 00D1     
                   < elite.a99
7981               
7982 2684 1350  14        jeq  HL2                        ; BEQ HL2           ; If A = 0 then the start and end character blocks are
7983                                                                          ; the same, so the whole line fits within one block, so
7984                                                                          ; jump down to HL2 to draw the line
7985               
7986                                                                          ; Otherwise the line spans multiple characters, so we
7987                                                                          ; start with the left character, then do any characters
7988                                                                          ; in the middle, and finish with the right character
7989               
7990 2686 091D  18        srl  ra,1                       ; LSR A             ; Set R = A / 8, so R now contains the number of
7991 2688 091D  18        srl  ra,1                       ; LSR A             ; character blocks we need to fill - 1
7992 268A 091D  18        srl  ra,1                       ; LSR A
7993 268C D80D  30        movb ra,@R                      ; STA R
     268E 0091     
7994               
7995 2690 D360  30        movb @X1,ra                     ; LDA X1            ; Set X = X1 mod 8, which is the horizontal pixel number
     2692 0031     
7996 2694 024D  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     2696 0700     
7997 2698 D38D  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
7998                                                                          ; wide)
7999               
8000 269A D36E  34        movb @TWFR(rx),ra               ; LDA TWFR,X        ; Fetch a ready-made byte with X pixels filled in at the
     269C 2775     
8001                                                                          ; right end of the byte (so the filled pixels start at
8002                                                                          ; point X and go all the way to the end of the byte),
8003                                                                          ; which is the shape we want for the left end of the
8004                                                                          ; line
8005               
8006                      .eor @SC                        ; EOR (SC),Y        ; Store this into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 269E D020  30        movb @SC,rtmp
     26A0 0007     
0002 26A2 2B40  18        xor  rtmp,ra
                   < elite.a99
8007                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen,
     **** ****     > ST_IND_Y_IDX
0001 26A4 D820  42        movb @SC,@rtmplb
     26A6 0007     
     26A8 8301     
0002 26AA D020  30        movb @SC+1,rtmp
     26AC 0008     
0003 26AE 06CF  14        swpb ry
0004 26B0 A00F  18        a    ry,rtmp
0005 26B2 06CF  14        swpb ry
0006 26B4 D40D  30        movb RA,*rtmp
                   < elite.a99
8008                                                                          ; so we have now drawn the line's left cap
8009               
8010 26B6 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y + 8 so (SC),Y points to the next character
8011                      .adi (>08*256)                  ; ADC #8            ; block along, on the same pixel row as before
     **** ****     > ADI
0001 26B8 1701  14        jnc  !
0002 26BA B347  18        ab   rone,ra
0003               !:
0004 26BC 022D  22        ai   ra,(>08*256)
     26BE 0800     
                   < elite.a99
8012 26C0 D3CD  18        movb ra,ry                      ; TAY
8013               
8014 26C2 D3A0  30        movb @R,rx                      ; LDX R             ; Fetch the number of character blocks we need to fill
     26C4 0091     
8015                                                                          ; from R
8016               
8017 26C6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the number of character blocks in X
8018               
8019 26C8 1317  14        jeq  HL3                        ; BEQ HL3           ; If X = 0 then we only have the last block to do (i.e.
8020                                                                          ; the right cap), so jump down to HL3 to draw it
8021               
8022                      .clc                            ; CLC               ; Otherwise clear the C flag so we can do some additions
     **** ****     > CLC
0001 26CA 0A16  18        sla  rzero,1
                   < elite.a99
8023                                                                          ; while we draw the character blocks with full-width
8024                                                                          ; lines in them
8025               
8026               HLL1:
8027 26CC 020D  20        li   ra,>ff*256                 ; LDA #%11111111    ; Store a full-width 8-pixel horizontal line in SC(1 0)
     26CE FF00     
8028                      .eor @SC                        ; EOR (SC),Y        ; so that it draws the line on-screen, using EOR logic
     **** ****     > EOR
0001 26D0 D020  30        movb @SC,rtmp
     26D2 0007     
0002 26D4 2B40  18        xor  rtmp,ra
                   < elite.a99
8029                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 26D6 D820  42        movb @SC,@rtmplb
     26D8 0007     
     26DA 8301     
0002 26DC D020  30        movb @SC+1,rtmp
     26DE 0008     
0003 26E0 06CF  14        swpb ry
0004 26E2 A00F  18        a    ry,rtmp
0005 26E4 06CF  14        swpb ry
0006 26E6 D40D  30        movb RA,*rtmp
                   < elite.a99
8030               
8031 26E8 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y + 8 so (SC),Y points to the next character
8032                      .adi (>08*256)                  ; ADC #8            ; block along, on the same pixel row as before
     **** ****     > ADI
0001 26EA 1701  14        jnc  !
0002 26EC B347  18        ab   rone,ra
0003               !:
0004 26EE 022D  22        ai   ra,(>08*256)
     26F0 0800     
                   < elite.a99
8033 26F2 D3CD  18        movb ra,ry                      ; TAY
8034               
8035 26F4 7387  18        sb   rone,rx                    ; DEX               ; Decrement the number of character blocks in X
8036               
8037 26F6 16EA  14        jne  HLL1                       ; BNE HLL1          ; Loop back to draw more full-width lines, if we have
8038                                                                          ; any more to draw
8039               
8040               HL3:
8041 26F8 D360  30        movb @X2,ra                     ; LDA X2            ; Now to draw the last character block at the right end
     26FA 0033     
8042 26FC 024D  22        andi ra,>07*256                 ; AND #7            ; of the line, so set X = X2 mod 8, which is the
     26FE 0700     
8043 2700 D38D  18        movb ra,rx                      ; TAX               ; horizontal pixel number where the line ends
8044               
8045 2702 D36E  34        movb @TWFL(rx),ra               ; LDA TWFL,X        ; Fetch a ready-made byte with X pixels filled in at the
     2704 276E     
8046                                                                          ; left end of the byte (so the filled pixels start at
8047                                                                          ; the left edge and go up to point X), which is the
8048                                                                          ; shape we want for the right end of the line
8049               
8050                      .eor @SC                        ; EOR (SC),Y        ; Store this into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 2706 D020  30        movb @SC,rtmp
     2708 0007     
0002 270A 2B40  18        xor  rtmp,ra
                   < elite.a99
8051                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen,
     **** ****     > ST_IND_Y_IDX
0001 270C D820  42        movb @SC,@rtmplb
     270E 0007     
     2710 8301     
0002 2712 D020  30        movb @SC+1,rtmp
     2714 0008     
0003 2716 06CF  14        swpb ry
0004 2718 A00F  18        a    ry,rtmp
0005 271A 06CF  14        swpb ry
0006 271C D40D  30        movb RA,*rtmp
                   < elite.a99
8052                                                                          ; so we have now drawn the line's right cap
8053               
8054 271E D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved across the
     2720 0094     
8055                                                                          ; call to this subroutine
8056               
8057 2722 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2724 FE34     
8058               
8059               HL2:
8060                                                                          ; If we get here then the entire horizontal line fits
8061                                                                          ; into one character block
8062 2726 D360  30        movb @X1,ra                     ; LDA X1            ; Set X = X1 mod 8, which is the horizontal pixel number
     2728 0031     
8063 272A 024D  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     272C 0700     
8064 272E D38D  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
8065                                                                          ; wide)
8066               
8067 2730 D36E  34        movb @TWFR(rx),ra               ; LDA TWFR,X        ; Fetch a ready-made byte with X pixels filled in at the
     2732 2775     
8068 2734 D80D  30        movb ra,@T                      ; STA T             ; right end of the byte (so the filled pixels start at
     2736 00D1     
8069                                                                          ; point X and go all the way to the end of the byte)
8070               
8071 2738 D360  30        movb @X2,ra                     ; LDA X2            ; Set X = X2 mod 8, which is the horizontal pixel number
     273A 0033     
8072 273C 024D  22        andi ra,>07*256                 ; AND #7            ; where the line ends
     273E 0700     
8073 2740 D38D  18        movb ra,rx                      ; TAX
8074               
8075 2742 D36E  34        movb @TWFL(rx),ra               ; LDA TWFL,X        ; Fetch a ready-made byte with X pixels filled in at the
     2744 276E     
8076                                                                          ; left end of the byte (so the filled pixels start at
8077                                                                          ; the left edge and go up to point X)
8078               
8079                      .and @T                         ; AND T             ; We now have two bytes, one (T) containing pixels from
     **** ****     > AND
0001 2746 D020  30        movb @T,rtmp
     2748 00D1     
0002 274A 0540  14        inv  rtmp
0003 274C 5340  18        szcb rtmp,ra
                   < elite.a99
8080                                                                          ; the starting point X1 onwards, and the other (A)
8081                                                                          ; containing pixels up to the end point at X2, so we can
8082                                                                          ; get the actual line we want to draw by AND'ing them
8083                                                                          ; together. For example, if we want to draw a line from
8084                                                                          ; point 2 to point 5 (within the row of 8 pixels
8085                                                                          ; numbered from 0 to 7), we would have this:
8086                                                                          ;
8087                                                                          ; T       = %00111111
8088                                                                          ; A       = %11111100
8089                                                                          ; T AND A = %00111100
8090                                                                          ;
8091                                                                          ; So we can stick T AND A in screen memory to get the
8092                                                                          ; line we want, which is what we do here by setting
8093                                                                          ; A = A AND T
8094               
8095                      .eor @SC                        ; EOR (SC),Y        ; Store our horizontal line byte into screen memory at
     **** ****     > EOR
0001 274E D020  30        movb @SC,rtmp
     2750 0007     
0002 2752 2B40  18        xor  rtmp,ra
                   < elite.a99
8096                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; SC(1 0), using EOR logic so it merges with whatever is
     **** ****     > ST_IND_Y_IDX
0001 2754 D820  42        movb @SC,@rtmplb
     2756 0007     
     2758 8301     
0002 275A D020  30        movb @SC+1,rtmp
     275C 0008     
0003 275E 06CF  14        swpb ry
0004 2760 A00F  18        a    ry,rtmp
0005 2762 06CF  14        swpb ry
0006 2764 D40D  30        movb RA,*rtmp
                   < elite.a99
8097                                                                          ; already on-screen
8098               
8099 2766 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2768 0094     
8100               
8101 276A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     276C FE34     
8102               
8103               * ******************************************************************************
8104               *
8105               * Name: TWFL
8106               * Type: Variable
8107               * Category: Drawing lines
8108               * Summary: Ready-made character rows for the left end of a horizontal line in
8109               * mode 4
8110               *
8111               * ------------------------------------------------------------------------------
8112               *
8113               * Ready-made bytes for plotting horizontal line end caps in mode 4 (the top part
8114               * of the split screen). This table provides a byte with pixels at the left end,
8115               * which is used for the right end of the line.
8116               *
8117               * See the HLOIN routine for details.
8118               *
8119               * ******************************************************************************
8120               
8121               TWFL:
8122 276E 80              byte >80
8123 276F   C0            byte >c0
8124 2770 E0              byte >e0
8125 2771   F0            byte >f0
8126 2772 F8              byte >f8
8127 2773   FC            byte >fc
8128 2774 FE              byte >fe
8129               
8130               * ******************************************************************************
8131               *
8132               * Name: TWFR
8133               * Type: Variable
8134               * Category: Drawing lines
8135               * Summary: Ready-made character rows for the right end of a horizontal line
8136               * in mode 4
8137               *
8138               * ------------------------------------------------------------------------------
8139               *
8140               * Ready-made bytes for plotting horizontal line end caps in mode 4 (the top part
8141               * of the split screen). This table provides a byte with pixels at the right end,
8142               * which is used for the left end of the line.
8143               *
8144               * See the HLOIN routine for details.
8145               *
8146               * ******************************************************************************
8147               
8148               TWFR:
8149 2775   FF            byte >ff
8150 2776 7F              byte >7f
8151 2777   3F            byte >3f
8152 2778 1F              byte >1f
8153 2779   0F            byte >0f
8154 277A 07              byte >07
8155 277B   03            byte >03
8156 277C 01              byte >01
8157               
8158               * ******************************************************************************
8159               *
8160               * Name: PX3
8161               * Type: Subroutine
8162               * Category: Drawing pixels
8163               * Summary: Plot a single pixel at (X, Y) within a character block
8164               *
8165               * ------------------------------------------------------------------------------
8166               *
8167               * This routine is called from PIXEL to set 1 pixel within a character block for
8168               * a distant point (i.e. where the distance ZZ >= &90). See the PIXEL routine for
8169               * details, as this routine is effectively part of PIXEL.
8170               *
8171               * ------------------------------------------------------------------------------
8172               *
8173               * Arguments:
8174               *
8175               * X                   The x-coordinate of the pixel within the character block
8176               *
8177               * Y                   The y-coordinate of the pixel within the character block
8178               *
8179               * SC(1 0)             The screen address of the character block
8180               *
8181               * T1                  The value of Y to restore on exit, so Y is preserved by
8182               * the call to PIXEL
8183               *
8184               * ******************************************************************************
8185               
8186               PX3:
8187 277E D36E  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS and EOR it into SC+Y
     2780 225D     
8188                      .eor @SC                        ; EOR (SC),Y
     **** ****     > EOR
0001 2782 D020  30        movb @SC,rtmp
     2784 0007     
0002 2786 2B40  18        xor  rtmp,ra
                   < elite.a99
8189                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 2788 D820  42        movb @SC,@rtmplb
     278A 0007     
     278C 8301     
0002 278E D020  30        movb @SC+1,rtmp
     2790 0008     
0003 2792 06CF  14        swpb ry
0004 2794 A00F  18        a    ry,rtmp
0005 2796 06CF  14        swpb ry
0006 2798 D40D  30        movb RA,*rtmp
                   < elite.a99
8190               
8191 279A D3E0  30        movb @T1,ry                     ; LDY T1            ; Restore Y from T1, so Y is preserved by the routine
     279C 0006     
8192               
8193 279E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     27A0 FE34     
8194               
8195               * ******************************************************************************
8196               *
8197               * Name: PIX1
8198               * Type: Subroutine
8199               * Category: Maths (Arithmetic)
8200               * Summary: Calculate (YY+1 SYL+Y) = (A P) + (S R) and draw stardust particle
8201               *
8202               * ------------------------------------------------------------------------------
8203               *
8204               * Calculate the following:
8205               *
8206               * (YY+1 SYL+Y) = (A P) + (S R)
8207               *
8208               * and draw a stardust particle at (X1,Y1) with distance ZZ.
8209               *
8210               * ------------------------------------------------------------------------------
8211               *
8212               * Arguments:
8213               *
8214               * (A P)               A is the angle ALPHA or BETA, P is always 0
8215               *
8216               * (S R)               YY(1 0) or YY(1 0) + Q * A
8217               *
8218               * Y                   Stardust particle number
8219               *
8220               * X1                  The x-coordinate offset
8221               *
8222               * Y1                  The y-coordinate offset
8223               *
8224               * ZZ                  The distance of the point (further away = smaller point)
8225               *
8226               * ******************************************************************************
8227               
8228               PIX1:
8229 27A2 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     27A4 456E     
8230 27A6 06A0  32        bl   @jsr                       ;
     27A8 FE28     
8231               
8232 27AA D80D  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY+1 to A, the high byte of the result
     27AC 0027     
8233               
8234 27AE D34E  18        movb rx,ra                      ; TXA               ; Set SYL+Y to X, the low byte of the result
8235 27B0 DBCD  38        movb ra,@SYL(ry)                ; STA SYL,Y
     27B2 0ED5     
8236               
8237                                                                          ; Fall through into PIX1 to draw the stardust particle
8238                                                                          ; at (X1,Y1)
8239               
8240               * ******************************************************************************
8241               *
8242               * Name: PIXEL2
8243               * Type: Subroutine
8244               * Category: Drawing pixels
8245               * Summary: Draw a stardust particle relative to the screen centre
8246               *
8247               * ------------------------------------------------------------------------------
8248               *
8249               * Draw a point (X1, Y1) from the middle of the screen with a size determined by
8250               * a distance value. Used to draw stardust particles.
8251               *
8252               * ------------------------------------------------------------------------------
8253               *
8254               * Arguments:
8255               *
8256               * X1                  The x-coordinate offset
8257               *
8258               * Y1                  The y-coordinate offset (positive means up the screen
8259               * from the centre, negative means down the screen)
8260               *
8261               * ZZ                  The distance of the point (further away = smaller point)
8262               *
8263               * ******************************************************************************
8264               
8265               PIXEL2:
8266 27B4 D360  30        movb @X1,ra                     ; LDA X1            ; Fetch the x-coordinate offset into A
     27B6 0031     
8267               
8268 27B8 1508  14        jgt  PX1                        ; BPL PX1           ; If the x-coordinate offset is positive, jump to PX1
8269                                                                          ; to skip the following negation
8270               
8271                      .eoi (>7f*256)                  ; EOR #%01111111    ; The x-coordinate offset is negative, so flip all the
     **** ****     > EOI
0001 27BA 0200  20        li   rtmp,(>7F*256)
     27BC 7F00     
0002 27BE 2B40  18        xor  rtmp,ra
                   < elite.a99
8272                      .clc                            ; CLC               ; bits apart from the sign bit and add 1, to convert it
     **** ****     > CLC
0001 27C0 0A16  18        sla  rzero,1
                   < elite.a99
8273                      .adi (>01*256)                  ; ADC #1            ; from a sign-magnitude number to a signed number
     **** ****     > ADI
0001 27C2 1701  14        jnc  !
0002 27C4 B347  18        ab   rone,ra
0003               !:
0004 27C6 022D  22        ai   ra,(>01*256)
     27C8 0100     
                   < elite.a99
8274               
8275               PX1:
8276                      .eoi (>80*256)                  ; EOR #%10000000    ; Set X = X1 + 128
     **** ****     > EOI
0001 27CA 0200  20        li   rtmp,(>80*256)
     27CC 8000     
0002 27CE 2B40  18        xor  rtmp,ra
                   < elite.a99
8277 27D0 D38D  18        movb ra,rx                      ; TAX               ;
8278                                                                          ; So X is now the offset converted to an x-coordinate,
8279                                                                          ; centred on x-coordinate 128
8280               
8281 27D2 D360  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate offset into A and clear the
     27D4 0032     
8282 27D6 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; sign bit, so A = |Y1|
     27D8 7F00     
8283               
8284 27DA 028D  22        ci   ra,>60*256                 ; CMP #96           ; If |Y1| >= 96 then it's off the screen (as 96 is half
     27DC 6000     
8285 27DE 1855  14        joc  PX4                        ; BCS PX4           ; the screen height), so return from the subroutine (as
8286                                                                          ; PX4 contains an RTS)
8287               
8288 27E0 D360  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate offset into A
     27E2 0032     
8289               
8290 27E4 1507  14        jgt  PX2                        ; BPL PX2           ; If the y-coordinate offset is positive, jump to PX2
8291                                                                          ; to skip the following negation
8292               
8293                      .eoi (>7f*256)                  ; EOR #%01111111    ; The y-coordinate offset is negative, so flip all the
     **** ****     > EOI
0001 27E6 0200  20        li   rtmp,(>7F*256)
     27E8 7F00     
0002 27EA 2B40  18        xor  rtmp,ra
                   < elite.a99
8294                      .adi (>01*256)                  ; ADC #1            ; bits apart from the sign bit and subtract 1, to negate
     **** ****     > ADI
0001 27EC 1701  14        jnc  !
0002 27EE B347  18        ab   rone,ra
0003               !:
0004 27F0 022D  22        ai   ra,(>01*256)
     27F2 0100     
                   < elite.a99
8295                                                                          ; it to a positive number, i.e. A is now |Y1|
8296               
8297               PX2:
8298 27F4 D80D  30        movb ra,@T                      ; STA T             ; Set A = 97 - Y1
     27F6 00D1     
8299 27F8 020D  20        li   ra,>61*256                 ; LDA #97           ;
     27FA 6100     
8300                      .sbc @T,ra                      ; SBC T             ; So if Y is positive we display the point up from the
     **** ****     > SBC
0001 27FC 1801  14        joc  !
0002 27FE 7347  18        sb   rone,ra
0003               !:
0004 2800 7360  30        sb   @T,ra
     2802 00D1     
                   < elite.a99
8301                                                                          ; centre at y-coordinate 97, while a negative Y means
8302                                                                          ; down from the centre
8303               
8304                                                                          ; Fall through into PIXEL to draw the stardust at the
8305                                                                          ; screen coordinates in (X, A)
8306               
8307               * ******************************************************************************
8308               *
8309               * Name: PIXEL
8310               * Type: Subroutine
8311               * Category: Drawing pixels
8312               * Summary: Draw a 1-pixel dot, 2-pixel dash or 4-pixel square
8313               * Deep dive: Drawing monochrome pixels in mode 4
8314               *
8315               * ------------------------------------------------------------------------------
8316               *
8317               * Draw a point at screen coordinate (X, A) with the point size determined by the
8318               * distance in ZZ. This applies to the top part of the screen (the monochrome
8319               * mode 4 portion).
8320               *
8321               * ------------------------------------------------------------------------------
8322               *
8323               * Arguments:
8324               *
8325               * X                   The screen x-coordinate of the point to draw
8326               *
8327               * A                   The screen y-coordinate of the point to draw
8328               *
8329               * ZZ                  The distance of the point (further away = smaller point)
8330               *
8331               * ------------------------------------------------------------------------------
8332               *
8333               * Returns:
8334               *
8335               * Y                   Y is preserved
8336               *
8337               * ------------------------------------------------------------------------------
8338               *
8339               * Other entry points:
8340               *
8341               * PX4                 Contains an RTS
8342               *
8343               * ******************************************************************************
8344               
8345               PIXEL:
8346 2804 D80F  30        movb ry,@T1                     ; STY T1            ; Store Y in T1
     2806 0006     
8347               
8348 2808 D3CD  18        movb ra,ry                      ; TAY               ; Copy A into Y, for use later
8349               
8350 280A 091D  18        srl  ra,1                       ; LSR A             ; Set SCH = &60 + A >> 3
8351 280C 091D  18        srl  ra,1                       ; LSR A
8352 280E 091D  18        srl  ra,1                       ; LSR A
8353 2810 026D  22        ori  ra,>60*256                 ; ORA #&60
     2812 6000     
8354 2814 D80D  30        movb ra,@SCH                    ; STA SCH
     2816 0008     
8355               
8356 2818 D34E  18        movb rx,ra                      ; TXA               ; Set SC = (X >> 3) * 8
8357 281A 024D  22        andi ra,>f8*256                 ; AND #%11111000
     281C F800     
8358 281E D80D  30        movb ra,@SC                     ; STA SC
     2820 0007     
8359               
8360 2822 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y AND %111
8361 2824 024D  22        andi ra,>07*256                 ; AND #%00000111
     2826 0700     
8362 2828 D3CD  18        movb ra,ry                      ; TAY
8363               
8364 282A D34E  18        movb rx,ra                      ; TXA               ; Set X = X AND %111
8365 282C 024D  22        andi ra,>07*256                 ; AND #%00000111
     282E 0700     
8366 2830 D38D  18        movb ra,rx                      ; TAX
8367               
8368 2832 D360  30        movb @ZZ,ra                     ; LDA ZZ            ; If distance in ZZ >= 144, then this point is a very
     2834 0097     
8369 2836 028D  22        ci   ra,>90*256                 ; CMP #144          ; long way away, so jump to PX3 to fetch a 1-pixel point
     2838 9000     
8370 283A 18A1  14        joc  PX3                        ; BCS PX3           ; from TWOS and EOR it into SC+Y
8371               
8372 283C D36E  34        movb @TWOS2(rx),ra              ; LDA TWOS2,X       ; Otherwise fetch a 2-pixel dash from TWOS2 and EOR it
     283E 2265     
8373                      .eor @SC                        ; EOR (SC),Y        ; into SC+Y
     **** ****     > EOR
0001 2840 D020  30        movb @SC,rtmp
     2842 0007     
0002 2844 2B40  18        xor  rtmp,ra
                   < elite.a99
8374                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 2846 D820  42        movb @SC,@rtmplb
     2848 0007     
     284A 8301     
0002 284C D020  30        movb @SC+1,rtmp
     284E 0008     
0003 2850 06CF  14        swpb ry
0004 2852 A00F  18        a    ry,rtmp
0005 2854 06CF  14        swpb ry
0006 2856 D40D  30        movb RA,*rtmp
                   < elite.a99
8375               
8376 2858 D360  30        movb @ZZ,ra                     ; LDA ZZ            ; If distance in ZZ >= 80, then this point is a medium
     285A 0097     
8377 285C 028D  22        ci   ra,>50*256                 ; CMP #80           ; distance away, so jump to PX13 to stop drawing, as a
     285E 5000     
8378 2860 1812  14        joc  PX13                       ; BCS PX13          ; 2-pixel dash is enough
8379               
8380                                                                          ; Otherwise we keep going to draw another 2 pixel point
8381                                                                          ; either above or below the one we just drew, to make a
8382                                                                          ; 4-pixel square
8383               
8384 2862 73C7  18        sb   rone,ry                    ; DEY               ; Reduce Y by 1 to point to the pixel row above the one
8385 2864 1502  14        jgt  PX14                       ; BPL PX14          ; we just plotted, and if it is still positive, jump to
8386                                                                          ; PX14 to draw our second 2-pixel dash
8387               
8388 2866 020F  20        li   ry,>01*256                 ; LDY #1            ; Reducing Y by 1 made it negative, which means Y was
     2868 0100     
8389                                                                          ; 0 before we did the DEY above, so set Y to 1 to point
8390                                                                          ; to the pixel row after the one we just plotted
8391               
8392               PX14:
8393 286A D36E  34        movb @TWOS2(rx),ra              ; LDA TWOS2,X       ; Fetch a 2-pixel dash from TWOS2 and EOR it into this
     286C 2265     
8394                      .eor @SC                        ; EOR (SC),Y        ; second row to make a 4-pixel square
     **** ****     > EOR
0001 286E D020  30        movb @SC,rtmp
     2870 0007     
0002 2872 2B40  18        xor  rtmp,ra
                   < elite.a99
8395                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 2874 D820  42        movb @SC,@rtmplb
     2876 0007     
     2878 8301     
0002 287A D020  30        movb @SC+1,rtmp
     287C 0008     
0003 287E 06CF  14        swpb ry
0004 2880 A00F  18        a    ry,rtmp
0005 2882 06CF  14        swpb ry
0006 2884 D40D  30        movb RA,*rtmp
                   < elite.a99
8396               
8397               PX13:
8398 2886 D3E0  30        movb @T1,ry                     ; LDY T1            ; Restore Y from T1, so Y is preserved by the routine
     2888 0006     
8399               
8400               PX4:
8401 288A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     288C FE34     
8402               
8403               * ******************************************************************************
8404               *
8405               * Name: BLINE
8406               * Type: Subroutine
8407               * Category: Drawing circles
8408               * Summary: Draw a circle segment and add it to the ball line heap
8409               * Deep dive: The ball line heap
8410               * Drawing circles
8411               *
8412               * ------------------------------------------------------------------------------
8413               *
8414               * Draw a single segment of a circle, adding the point to the ball line heap.
8415               *
8416               * ------------------------------------------------------------------------------
8417               *
8418               * Arguments:
8419               *
8420               * CNT                 The number of this segment
8421               *
8422               * STP                 The step size for the circle
8423               *
8424               * K6(1 0)             The x-coordinate of the new point on the circle, as
8425               * a screen coordinate
8426               *
8427               * (T X)               The y-coordinate of the new point on the circle, as
8428               * an offset from the centre of the circle
8429               *
8430               * FLAG                Set to &FF for the first call, so it sets up the first
8431               * point in the heap but waits until the second call before
8432               * drawing anything (as we need two points, i.e. two calls,
8433               * before we can draw a line)
8434               *
8435               * K4(1 0)             Pixel y-coordinate of the centre of the circle
8436               *
8437               * K5(1 0)             Screen x-coordinate of the previous point added to the
8438               * ball line heap (if this is not the first point)
8439               *
8440               * K5(3 2)             Screen y-coordinate of the previous point added to the
8441               * ball line heap (if this is not the first point)
8442               *
8443               * ------------------------------------------------------------------------------
8444               *
8445               * Returns:
8446               *
8447               * CNT                 CNT is updated to CNT + STP
8448               *
8449               * A                   The new value of CNT
8450               *
8451               * K5(1 0)             Screen x-coordinate of the point that we just added to
8452               * the ball line heap
8453               *
8454               * K5(3 2)             Screen y-coordinate of the point that we just added to
8455               * the ball line heap
8456               *
8457               * FLAG                Set to 0
8458               *
8459               * ******************************************************************************
8460               
8461               BLINE:
8462 288E D34E  18        movb rx,ra                      ; TXA               ; Set K6(3 2) = (T X) + K4(1 0)
8463                      .adc @K4,ra                     ; ADC K4            ; = y-coord of centre + y-coord of new point
     **** ****     > ADC
0001 2890 1701  14        jnc  !
0002 2892 B347  18        ab   rone,ra
0003               !:
0004 2894 B360  30        ab   @K4,ra
     2896 00E0     
                   < elite.a99
8464 2898 D80D  30        movb ra,@K6+2                   ; STA K6+2          ;
     289A 0084     
8465 289C D360  30        movb @K4+1,ra                   ; LDA K4+1          ; so K6(3 2) now contains the y-coordinate of the new
     289E 00E1     
8466                      .adc @T,ra                      ; ADC T             ; point on the circle but as a screen coordinate, to go
     **** ****     > ADC
0001 28A0 1701  14        jnc  !
0002 28A2 B347  18        ab   rone,ra
0003               !:
0004 28A4 B360  30        ab   @T,ra
     28A6 00D1     
                   < elite.a99
8467 28A8 D80D  30        movb ra,@K6+3                   ; STA K6+3          ; along with the screen x-coordinate in K6(1 0)
     28AA 0085     
8468               
8469 28AC D360  30        movb @FLAG,ra                   ; LDA FLAG          ; If FLAG = 0, jump down to BL1
     28AE 00A3     
8470 28B0 130C  14        jeq  BL1                        ; BEQ BL1
8471               
8472 28B2 B347  18        ab   rone,ra                    ; INC FLAG          ; Flag is &FF so this is the first call to BLINE, so
8473                                                                          ; increment FLAG to set it to 0, as then the next time
8474                                                                          ; we call BLINE it can draw the first line, from this
8475                                                                          ; point to the next
8476               
8477               BL5:
8478                                                                          ; The following inserts a &FF marker into the LSY2 line
8479                                                                          ; heap to indicate that the next call to BLINE should
8480                                                                          ; store both the (X1, Y1) and (X2, Y2) points. We do
8481                                                                          ; this on the very first call to BLINE (when FLAG is
8482                                                                          ; &FF), and on subsequent calls if the segment does not
8483                                                                          ; fit on-screen, in which case we don't draw or store
8484                                                                          ; that segment, and we start a new segment with the next
8485                                                                          ; call to BLINE that does fit on-screen
8486 28B4 D3E0  30        movb @LSP,ry                    ; LDY LSP           ; If byte LSP-1 of LSY2 = &FF, jump to BL7 to tidy up
     28B6 0077     
8487 28B8 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; and return from the subroutine, as the point that has
     28BA FF00     
8488 28BC 936F  34        cb   @LSY2-1(ry),ra             ; CMP LSY2-1,Y      ; been passed to BLINE is the start of a segment, so all
     28BE 0E73     
8489 28C0 135E  14        jeq  BL7                        ; BEQ BL7           ; we need to do is save the coordinate in K5, without
8490                                                                          ; moving the pointer in LSP
8491               
8492 28C2 DBCD  38        movb ra,@LSY2(ry)               ; STA LSY2,Y        ; Otherwise we just tried to plot a segment but it
     28C4 0E74     
8493                                                                          ; didn't fit on-screen, so put the &FF marker into the
8494                                                                          ; heap for this point, so the next call to BLINE starts
8495                                                                          ; a new segment
8496               
8497 28C6 B347  18        ab   rone,ra                    ; INC LSP           ; Increment LSP to point to the next point in the heap
8498               
8499 28C8 165A  14        jne  BL7                        ; BNE BL7           ; Jump to BL7 to tidy up and return from the subroutine
8500                                                                          ; (this BNE is effectively a JMP, as LSP will never be
8501                                                                          ; zero)
8502               
8503               BL1:
8504 28CA D360  30        movb @K5,ra                     ; LDA K5            ; Set XX15 = K5 = x_lo of previous point
     28CC 007E     
8505 28CE D80D  30        movb ra,@XX15                   ; STA XX15
     28D0 0031     
8506               
8507 28D2 D360  30        movb @K5+1,ra                   ; LDA K5+1          ; Set XX15+1 = K5+1 = x_hi of previous point
     28D4 007F     
8508 28D6 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     28D8 0032     
8509               
8510 28DA D360  30        movb @K5+2,ra                   ; LDA K5+2          ; Set XX15+2 = K5+2 = y_lo of previous point
     28DC 0080     
8511 28DE D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     28E0 0033     
8512               
8513 28E2 D360  30        movb @K5+3,ra                   ; LDA K5+3          ; Set XX15+3 = K5+3 = y_hi of previous point
     28E4 0081     
8514 28E6 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     28E8 0034     
8515               
8516 28EA D360  30        movb @K6,ra                     ; LDA K6            ; Set XX15+4 = x_lo of new point
     28EC 0082     
8517 28EE D80D  30        movb ra,@XX15+4                 ; STA XX15+4
     28F0 0035     
8518               
8519 28F2 D360  30        movb @K6+1,ra                   ; LDA K6+1          ; Set XX15+5 = x_hi of new point
     28F4 0083     
8520 28F6 D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     28F8 0036     
8521               
8522 28FA D360  30        movb @K6+2,ra                   ; LDA K6+2          ; Set XX12 = y_lo of new point
     28FC 0084     
8523 28FE D80D  30        movb ra,@XX12                   ; STA XX12
     2900 0037     
8524               
8525 2902 D360  30        movb @K6+3,ra                   ; LDA K6+3          ; Set XX12+1 = y_hi of new point
     2904 0085     
8526 2906 D80D  30        movb ra,@XX12+1                 ; STA XX12+1
     2908 0038     
8527               
8528 290A 0200  20        li   rtmp,LL145                 ; JSR LL145         ; Call LL145 to see if the new line segment needs to be
     290C E6E8     
8529 290E 06A0  32        bl   @jsr                       ;
     2910 FE28     
8530                                                                          ; clipped to fit on-screen, returning the clipped line's
8531                                                                          ; end-points in (X1, Y1) and (X2, Y2)
8532               
8533 2912 18D0  14        joc  BL5                        ; BCS BL5           ; If the C flag is set then the line is not visible on
8534                                                                          ; screen anyway, so jump to BL5, to avoid drawing and
8535                                                                          ; storing this line
8536               
8537 2914 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0, then we didn't have to swap the line
     2916 00A1     
8538 2918 1310  14        jeq  BL9                        ; BEQ BL9           ; coordinates around during the clipping process, so
8539                                                                          ; jump to BL9 to skip the following swap
8540               
8541 291A D360  30        movb @X1,ra                     ; LDA X1            ; Otherwise the coordinates were swapped by the call to
     291C 0031     
8542 291E D3E0  30        movb @X2,ry                     ; LDY X2            ; LL145 above, so we swap (X1, Y1) and (X2, Y2) back
     2920 0033     
8543 2922 D80D  30        movb ra,@X2                     ; STA X2            ; again
     2924 0033     
8544 2926 D80F  30        movb ry,@X1                     ; STY X1
     2928 0031     
8545 292A D360  30        movb @Y1,ra                     ; LDA Y1
     292C 0032     
8546 292E D3E0  30        movb @Y2,ry                     ; LDY Y2
     2930 0034     
8547 2932 D80D  30        movb ra,@Y2                     ; STA Y2
     2934 0034     
8548 2936 D80F  30        movb ry,@Y1                     ; STY Y1
     2938 0032     
8549               
8550               BL9:
8551 293A D3E0  30        movb @LSP,ry                    ; LDY LSP           ; Set Y = LSP
     293C 0077     
8552               
8553 293E D36F  34        movb @LSY2-1(ry),ra             ; LDA LSY2-1,Y      ; If byte LSP-1 of LSY2 is not &FF, jump down to BL8
     2940 0E73     
8554 2942 028D  22        ci   ra,>ff*256                 ; CMP #&FF          ; to skip the following (X1, Y1) code
     2944 FF00     
8555 2946 1609  14        jne  BL8                        ; BNE BL8
8556               
8557                                                                          ; Byte LSP-1 of LSY2 is &FF, which indicates that we
8558                                                                          ; need to store (X1, Y1) in the heap
8559               
8560 2948 D360  30        movb @X1,ra                     ; LDA X1            ; Store X1 in the LSP-th byte of LSX2
     294A 0031     
8561 294C DBCD  38        movb ra,@LSX2(ry)               ; STA LSX2,Y
     294E 0E26     
8562               
8563 2950 D360  30        movb @Y1,ra                     ; LDA Y1            ; Store Y1 in the LSP-th byte of LSY2
     2952 0032     
8564 2954 DBCD  38        movb ra,@LSY2(ry)               ; STA LSY2,Y
     2956 0E74     
8565               
8566 2958 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next byte in LSX2/LSY2
8567               
8568               BL8:
8569 295A D360  30        movb @X2,ra                     ; LDA X2            ; Store X2 in the LSP-th byte of LSX2
     295C 0033     
8570 295E DBCD  38        movb ra,@LSX2(ry)               ; STA LSX2,Y
     2960 0E26     
8571               
8572 2962 D360  30        movb @Y2,ra                     ; LDA Y2            ; Store Y2 in the LSP-th byte of LSX2
     2964 0034     
8573 2966 DBCD  38        movb ra,@LSY2(ry)               ; STA LSY2,Y
     2968 0E74     
8574               
8575 296A B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next byte in LSX2/LSY2
8576               
8577 296C D80F  30        movb ry,@LSP                    ; STY LSP           ; Update LSP to point to the same as Y
     296E 0077     
8578               
8579 2970 0200  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2)
     2972 2272     
8580 2974 06A0  32        bl   @jsr                       ;
     2976 FE28     
8581               
8582 2978 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 is non-zero, jump up to BL5 to add a &FF
     297A 0098     
8583 297C 169B  14        jne  BL5                        ; BNE BL5           ; marker to the end of the line heap. XX13 is non-zero
8584                                                                          ; after the call to the clipping routine LL145 above if
8585                                                                          ; the end of the line was clipped, meaning the next line
8586                                                                          ; sent to BLINE can't join onto the end but has to start
8587                                                                          ; a new segment, and that's what inserting the &FF
8588                                                                          ; marker does
8589               
8590               BL7:
8591 297E D360  30        movb @K6,ra                     ; LDA K6            ; Copy the data for this step point from K6(3 2 1 0)
     2980 0082     
8592 2982 D80D  30        movb ra,@K5                     ; STA K5            ; into K5(3 2 1 0), for use in the next call to BLINE:
     2984 007E     
8593 2986 D360  30        movb @K6+1,ra                   ; LDA K6+1          ;
     2988 0083     
8594 298A D80D  30        movb ra,@K5+1                   ; STA K5+1          ; * K5(1 0) = screen x-coordinate of this point
     298C 007F     
8595 298E D360  30        movb @K6+2,ra                   ; LDA K6+2          ;
     2990 0084     
8596 2992 D80D  30        movb ra,@K5+2                   ; STA K5+2          ; * K5(3 2) = screen y-coordinate of this point
     2994 0080     
8597 2996 D360  30        movb @K6+3,ra                   ; LDA K6+3          ;
     2998 0085     
8598 299A D80D  30        movb ra,@K5+3                   ; STA K5+3          ; They now become the "previous point" in the next call
     299C 0081     
8599               
8600 299E D360  30        movb @CNT,ra                    ; LDA CNT           ; Set CNT = CNT + STP
     29A0 00A4     
8601                      .clc                            ; CLC
     **** ****     > CLC
0001 29A2 0A16  18        sla  rzero,1
                   < elite.a99
8602                      .adc @STP,ra                    ; ADC STP
     **** ****     > ADC
0001 29A4 1701  14        jnc  !
0002 29A6 B347  18        ab   rone,ra
0003               !:
0004 29A8 B360  30        ab   @STP,ra
     29AA 00A6     
                   < elite.a99
8603 29AC D80D  30        movb ra,@CNT                    ; STA CNT
     29AE 00A4     
8604               
8605 29B0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     29B2 FE34     
8606               
8607               * ******************************************************************************
8608               *
8609               * Name: FLIP
8610               * Type: Subroutine
8611               * Category: Stardust
8612               * Summary: Reflect the stardust particles in the screen diagonal and redraw
8613               * the stardust field
8614               *
8615               * ------------------------------------------------------------------------------
8616               *
8617               * Swap the x- and y-coordinates of all the stardust particles and draw the new
8618               * set of particles. Called by LOOK1 when we switch views.
8619               *
8620               * This is a quick way of making the stardust field in the new view feel
8621               * different without having to generate a whole new field. If you look carefully
8622               * at the stardust field when you switch views, you can just about see that the
8623               * new field is a reflection of the previous field in the screen diagonal, i.e.
8624               * in the line from bottom left to top right. This is the line where x = y when
8625               * the origin is in the middle of the screen, and positive x and y are right and
8626               * up, which is the coordinate system we use for stardust).
8627               *
8628               * ******************************************************************************
8629               
8630               FLIP:
8631               * LDA MJ                 \ These instructions are commented out in the original
8632               * BNE FLIP-1             \ source. They would have the effect of not swapping the
8633                                                                          ; stardust if we had mis-jumped into witchspace
8634 29B4 D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     29B6 0F33     
8635                                                                          ; we can use it as a counter through all the stardust
8636               
8637               FLL1:
8638 29B8 D3AF  34        movb @SY(ry),rx                 ; LDX SY,Y          ; Copy the Y-th particle's y-coordinate from SY+Y into X
     29BA 0EC2     
8639               
8640 29BC D36F  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Copy the Y-th particle's x-coordinate from SX+Y into
     29BE 034C     
8641 29C0 D80D  30        movb ra,@Y1                     ; STA Y1            ; both Y1 and the particle's y-coordinate
     29C2 0032     
8642 29C4 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y
     29C6 0EC2     
8643               
8644 29C8 D34E  18        movb rx,ra                      ; TXA               ; Copy the Y-th particle's original y-coordinate into
8645 29CA D80D  30        movb ra,@X1                     ; STA X1            ; both X1 and the particle's x-coordinate, so the x- and
     29CC 0031     
8646 29CE DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; y-coordinates are now swapped and (X1, Y1) contains
     29D0 034C     
8647                                                                          ; the particle's new coordinates
8648               
8649 29D2 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Fetch the Y-th particle's distance from SZ+Y into ZZ
     29D4 0EE8     
8650 29D6 D80D  30        movb ra,@ZZ                     ; STA ZZ
     29D8 0097     
8651               
8652 29DA 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ
     29DC 27B4     
8653 29DE 06A0  32        bl   @jsr                       ;
     29E0 FE28     
8654               
8655 29E2 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point to the next particle of
8656                                                                          ; stardust
8657               
8658 29E4 16E9  14        jne  FLL1                       ; BNE FLL1          ; Loop back to FLL1 until we have moved all the stardust
8659                                                                          ; particles
8660               
8661 29E6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     29E8 FE34     
8662               
8663               * ******************************************************************************
8664               *
8665               * Name: STARS
8666               * Type: Subroutine
8667               * Category: Stardust
8668               * Summary: The main routine for processing the stardust
8669               *
8670               * ------------------------------------------------------------------------------
8671               *
8672               * Called at the very end of the main flight loop.
8673               *
8674               * ******************************************************************************
8675               
8676               STARS:
8677               * LDA #&FF               \ These instructions are commented out in the original
8678               * STA COL                \ source, but they would set the stardust colour to
8679                                                                          ; white. That said, COL is only used when updating the
8680                                                                          ; dashboard, so this would have no effect - perhaps it's
8681                                                                          ; left over from experiments with a colour top part of
8682                                                                          ; the screen? Who knows...
8683 29EA D3A0  30        movb @VIEW,rx                   ; LDX VIEW          ; Load the current view into X:
     29EC 0D5F     
8684                                                                          ;
8685                                                                          ; 0 = front
8686                                                                          ; 1 = rear
8687                                                                          ; 2 = left
8688                                                                          ; 3 = right
8689               
8690 29EE 1306  14        jeq  STARS1                     ; BEQ STARS1        ; If this 0, jump to STARS1 to process the stardust for
8691                                                                          ; the front view
8692               
8693 29F0 7387  18        sb   rone,rx                    ; DEX               ; If this is view 2 or 3, jump to STARS2 (via ST11) to
8694 29F2 1602  14        jne  ST11                       ; BNE ST11          ; process the stardust for the left or right views
8695               
8696 29F4 0460  28        b    @STARS6                    ; JMP STARS6        ; Otherwise this is the rear view, so jump to STARS6 to
     29F6 2C0A     
8697                                                                          ; process the stardust for the rear view
8698               
8699               ST11:
8700 29F8 0460  28        b    @STARS2                    ; JMP STARS2        ; Jump to STARS2 for the left or right views, as it's
     29FA 3FB8     
8701                                                                          ; too far for the branch instruction above
8702               
8703               * ******************************************************************************
8704               *
8705               * Name: STARS1
8706               * Type: Subroutine
8707               * Category: Stardust
8708               * Summary: Process the stardust for the front view
8709               * Deep dive: Stardust in the front view
8710               *
8711               * ------------------------------------------------------------------------------
8712               *
8713               * This moves the stardust towards us according to our speed (so the dust rushes
8714               * past us), and applies our current pitch and roll to each particle of dust, so
8715               * the stardust moves correctly when we steer our ship.
8716               *
8717               * When a stardust particle rushes past us and falls off the side of the screen,
8718               * its memory is recycled as a new particle that's positioned randomly on-screen.
8719               *
8720               * These are the calculations referred to in the commentary:
8721               *
8722               * 1. q = 64 * speed / z_hi
8723               * 2. z = z - speed * 64
8724               * 3. y = y + |y_hi| * q
8725               * 4. x = x + |x_hi| * q
8726               *
8727               * 5. y = y + alpha * x / 256
8728               * 6. x = x - alpha * y / 256
8729               *
8730               * 7. x = x + 2 * (beta * y / 256) ^ 2
8731               * 8. y = y - beta * 256
8732               *
8733               * For more information see the deep dive on "Stardust in the front view".
8734               *
8735               * ******************************************************************************
8736               
8737               STARS1:
8738 29FC D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     29FE 0F33     
8739                                                                          ; we can use it as a counter through all the stardust
8740               
8741                                                                          ; In the following, we're going to refer to the 16-bit
8742                                                                          ; space coordinates of the current particle of stardust
8743                                                                          ; (i.e. the Y-th particle) like this:
8744                                                                          ;
8745                                                                          ; x = (x_hi x_lo)
8746                                                                          ; y = (y_hi y_lo)
8747                                                                          ; z = (z_hi z_lo)
8748                                                                          ;
8749                                                                          ; These values are stored in (SX+Y SXL+Y), (SY+Y SYL+Y)
8750                                                                          ; and (SZ+Y SZL+Y) respectively
8751               
8752               STL1:
8753 2A00 0200  20        li   rtmp,DV42                  ; JSR DV42          ; Call DV42 to set the following:
     2A02 4658     
8754 2A04 06A0  32        bl   @jsr                       ;
     2A06 FE28     
8755                                                                          ;
8756                                                                          ; (P R) = 256 * DELTA / z_hi
8757                                                                          ; = 256 * speed / z_hi
8758                                                                          ;
8759                                                                          ; The maximum value returned is P = 2 and R = 128 (see
8760                                                                          ; DV42 for an explanation)
8761               
8762 2A08 D360  30        movb @R,ra                      ; LDA R             ; Set A = R, so now:
     2A0A 0091     
8763                                                                          ;
8764                                                                          ; (P A) = 256 * speed / z_hi
8765               
8766                      .lsr @P                         ; LSR P             ; Rotate (P A) right by 2 places, which sets P = 0 (as P
     **** ****     > LSR
0001 2A0C D020  30        movb @P,rtmp
     2A0E 001B     
0002 2A10 0910  18        srl  rtmp,1
0003 2A12 D800  30        movb rtmp,@P
     2A14 001B     
                   < elite.a99
8767 2A16 06A0  32        bl   @rora                      ; ROR A             ; has a maximum value of 2) and leaves:
     2A18 FE62     
8768                      .lsr @P                         ; LSR P             ;
     **** ****     > LSR
0001 2A1A D020  30        movb @P,rtmp
     2A1C 001B     
0002 2A1E 0910  18        srl  rtmp,1
0003 2A20 D800  30        movb rtmp,@P
     2A22 001B     
                   < elite.a99
8769 2A24 06A0  32        bl   @rora                      ; ROR A             ; A = 64 * speed / z_hi
     2A26 FE62     
8770               
8771 2A28 026D  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1, and store it in Q, so we
     2A2A 0100     
8772 2A2C D80D  30        movb ra,@Q                      ; STA Q             ; now have result 1 above:
     2A2E 0090     
8773                                                                          ;
8774                                                                          ; Q = 64 * speed / z_hi
8775               
8776 2A30 D36F  34        movb @SZL(ry),ra                ; LDA SZL,Y         ; We now calculate the following:
     2A32 0EFB     
8777                      .sbc @DELT4,ra                  ; SBC DELT4         ;
     **** ****     > SBC
0001 2A34 1801  14        joc  !
0002 2A36 7347  18        sb   rone,ra
0003               !:
0004 2A38 7360  30        sb   @DELT4,ra
     2A3A 008D     
                   < elite.a99
8778 2A3C DBCD  38        movb ra,@SZL(ry)                ; STA SZL,Y         ; (z_hi z_lo) = (z_hi z_lo) - DELT4(1 0)
     2A3E 0EFB     
8779                                                                          ;
8780                                                                          ; starting with the low bytes
8781               
8782 2A40 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; And then we do the high bytes
     2A42 0EE8     
8783 2A44 D80D  30        movb ra,@ZZ                     ; STA ZZ            ;
     2A46 0097     
8784                      .sbc @DELT4+1,ra                ; SBC DELT4+1       ; We also set ZZ to the original value of z_hi, which we
     **** ****     > SBC
0001 2A48 1801  14        joc  !
0002 2A4A 7347  18        sb   rone,ra
0003               !:
0004 2A4C 7360  30        sb   @DELT4+1,ra
     2A4E 008E     
                   < elite.a99
8785 2A50 DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; use below to remove the existing particle
     2A52 0EE8     
8786                                                                          ;
8787                                                                          ; So now we have result 2 above:
8788                                                                          ;
8789                                                                          ; z = z - DELT4(1 0)
8790                                                                          ; = z - speed * 64
8791               
8792 2A54 0200  20        li   rtmp,MLU1                  ; JSR MLU1          ; Call MLU1 to set:
     2A56 4382     
8793 2A58 06A0  32        bl   @jsr                       ;
     2A5A FE28     
8794                                                                          ;
8795                                                                          ; Y1 = y_hi
8796                                                                          ;
8797                                                                          ; (A P) = |y_hi| * Q
8798                                                                          ;
8799                                                                          ; So Y1 contains the original value of y_hi, which we
8800                                                                          ; use below to remove the existing particle
8801               
8802                                                                          ; We now calculate:
8803                                                                          ;
8804                                                                          ; (S R) = YY(1 0) = (A P) + y
8805               
8806 2A5C D80D  30        movb ra,@YY+1                   ; STA YY+1          ; First we do the low bytes with:
     2A5E 0027     
8807 2A60 D360  30        movb @P,ra                      ; LDA P             ;
     2A62 001B     
8808                      .adc @SYL(ry),ra                ; ADC SYL,Y         ; YY+1 = A
     **** ****     > ADC
0001 2A64 1701  14        jnc  !
0002 2A66 B347  18        ab   rone,ra
0003               !:
0004 2A68 B36F  34        ab   @SYL(RY),ra
     2A6A 0ED5     
                   < elite.a99
8809 2A6C D80D  30        movb ra,@YY                     ; STA YY            ; R = YY = P + y_lo
     2A6E 0026     
8810 2A70 D80D  30        movb ra,@R                      ; STA R             ;
     2A72 0091     
8811                                                                          ; so we get this:
8812                                                                          ;
8813                                                                          ; (? R) = YY(1 0) = (A P) + y_lo
8814               
8815 2A74 D360  30        movb @Y1,ra                     ; LDA Y1            ; And then we do the high bytes with:
     2A76 0032     
8816                      .adc @YY+1,ra                   ; ADC YY+1          ;
     **** ****     > ADC
0001 2A78 1701  14        jnc  !
0002 2A7A B347  18        ab   rone,ra
0003               !:
0004 2A7C B360  30        ab   @YY+1,ra
     2A7E 0027     
                   < elite.a99
8817 2A80 D80D  30        movb ra,@YY+1                   ; STA YY+1          ; S = YY+1 = y_hi + YY+1
     2A82 0027     
8818 2A84 D80D  30        movb ra,@S                      ; STA S             ;
     2A86 0092     
8819                                                                          ; so we get our result:
8820                                                                          ;
8821                                                                          ; (S R) = YY(1 0) = (A P) + (y_hi y_lo)
8822                                                                          ; = |y_hi| * Q + y
8823                                                                          ;
8824                                                                          ; which is result 3 above, and (S R) is set to the new
8825                                                                          ; value of y
8826               
8827 2A88 D36F  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Set X1 = A = x_hi
     2A8A 034C     
8828 2A8C D80D  30        movb ra,@X1                     ; STA X1            ;
     2A8E 0031     
8829                                                                          ; So X1 contains the original value of x_hi, which we
8830                                                                          ; use below to remove the existing particle
8831               
8832 2A90 0200  20        li   rtmp,MLU2                  ; JSR MLU2          ; Set (A P) = |x_hi| * Q
     2A92 438A     
8833 2A94 06A0  32        bl   @jsr                       ;
     2A96 FE28     
8834               
8835                                                                          ; We now calculate:
8836                                                                          ;
8837                                                                          ; XX(1 0) = (A P) + x
8838               
8839 2A98 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; First we do the low bytes:
     2A9A 0025     
8840 2A9C D360  30        movb @P,ra                      ; LDA P             ;
     2A9E 001B     
8841                      .adc @SXL(ry),ra                ; ADC SXL,Y         ; XX(1 0) = (A P) + x_lo
     **** ****     > ADC
0001 2AA0 1701  14        jnc  !
0002 2AA2 B347  18        ab   rone,ra
0003               !:
0004 2AA4 B36F  34        ab   @SXL(RY),ra
     2AA6 035F     
                   < elite.a99
8842 2AA8 D80D  30        movb ra,@XX                     ; STA XX
     2AAA 0024     
8843               
8844 2AAC D360  30        movb @X1,ra                     ; LDA X1            ; And then we do the high bytes:
     2AAE 0031     
8845                      .adc @XX+1,ra                   ; ADC XX+1          ;
     **** ****     > ADC
0001 2AB0 1701  14        jnc  !
0002 2AB2 B347  18        ab   rone,ra
0003               !:
0004 2AB4 B360  30        ab   @XX+1,ra
     2AB6 0025     
                   < elite.a99
8846 2AB8 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; XX(1 0) = XX(1 0) + (x_hi 0)
     2ABA 0025     
8847                                                                          ;
8848                                                                          ; so we get our result:
8849                                                                          ;
8850                                                                          ; XX(1 0) = (A P) + x
8851                                                                          ; = |x_hi| * Q + x
8852                                                                          ;
8853                                                                          ; which is result 4 above, and we also have:
8854                                                                          ;
8855                                                                          ; A = XX+1 = (|x_hi| * Q + x) / 256
8856                                                                          ;
8857                                                                          ; i.e. A is the new value of x, divided by 256
8858               
8859                      .eor @ALP2+1                    ; EOR ALP2+1        ; EOR with the flipped sign of the roll angle alpha, so
     **** ****     > EOR
0001 2ABC D020  30        movb @ALP2+1,rtmp
     2ABE 0089     
0002 2AC0 2B40  18        xor  rtmp,ra
                   < elite.a99
8860                                                                          ; A has the opposite sign to the flipped roll angle
8861                                                                          ; alpha, i.e. it gets the same sign as alpha
8862               
8863 2AC2 0200  20        li   rtmp,MLS1                  ; JSR MLS1          ; Call MLS1 to calculate:
     2AC4 42A2     
8864 2AC6 06A0  32        bl   @jsr                       ;
     2AC8 FE28     
8865                                                                          ;
8866                                                                          ; (A P) = A * ALP1
8867                                                                          ; = (x / 256) * alpha
8868               
8869 2ACA 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2ACC 456E     
8870 2ACE 06A0  32        bl   @jsr                       ;
     2AD0 FE28     
8871                                                                          ;
8872                                                                          ; (A X) = (A P) + (S R)
8873                                                                          ; = (x / 256) * alpha + y
8874                                                                          ; = y + alpha * x / 256
8875               
8876 2AD2 D80D  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY(1 0) = (A X) to give:
     2AD4 0027     
8877 2AD6 D80E  30        movb rx,@YY                     ; STX YY            ;
     2AD8 0026     
8878                                                                          ; YY(1 0) = y + alpha * x / 256
8879                                                                          ;
8880                                                                          ; which is result 5 above, and we also have:
8881                                                                          ;
8882                                                                          ; A = YY+1 = y + alpha * x / 256
8883                                                                          ;
8884                                                                          ; i.e. A is the new value of y, divided by 256
8885               
8886                      .eor @ALP2                      ; EOR ALP2          ; EOR A with the correct sign of the roll angle alpha,
     **** ****     > EOR
0001 2ADA D020  30        movb @ALP2,rtmp
     2ADC 0088     
0002 2ADE 2B40  18        xor  rtmp,ra
                   < elite.a99
8887                                                                          ; so A has the opposite sign to the roll angle alpha
8888               
8889 2AE0 0200  20        li   rtmp,MLS2                  ; JSR MLS2          ; Call MLS2 to calculate:
     2AE2 4292     
8890 2AE4 06A0  32        bl   @jsr                       ;
     2AE6 FE28     
8891                                                                          ;
8892                                                                          ; (S R) = XX(1 0)
8893                                                                          ; = x
8894                                                                          ;
8895                                                                          ; (A P) = A * ALP1
8896                                                                          ; = -y / 256 * alpha
8897               
8898 2AE8 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2AEA 456E     
8899 2AEC 06A0  32        bl   @jsr                       ;
     2AEE FE28     
8900                                                                          ;
8901                                                                          ; (A X) = (A P) + (S R)
8902                                                                          ; = -y / 256 * alpha + x
8903               
8904 2AF0 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Set XX(1 0) = (A X), which gives us result 6 above:
     2AF2 0025     
8905 2AF4 D80E  30        movb rx,@XX                     ; STX XX            ;
     2AF6 0024     
8906                                                                          ; x = x - alpha * y / 256
8907               
8908 2AF8 D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the pitch magnitude into X
     2AFA 002B     
8909               
8910 2AFC D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set A to y_hi and set it to the flipped sign of beta
     2AFE 0027     
8911                      .eor @BET2+1                    ; EOR BET2+1
     **** ****     > EOR
0001 2B00 D020  30        movb @BET2+1,rtmp
     2B02 008B     
0002 2B04 2B40  18        xor  rtmp,ra
                   < elite.a99
8912               
8913 2B06 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     2B08 42A8     
8914 2B0A 06A0  32        bl   @jsr                       ;
     2B0C FE28     
8915                                                                          ;
8916                                                                          ; (A P) = X * A
8917                                                                          ; = -beta * y_hi
8918               
8919 2B0E D80D  30        movb ra,@Q                      ; STA Q             ; Store the high byte of the result in Q, so:
     2B10 0090     
8920                                                                          ;
8921                                                                          ; Q = -beta * y_hi / 256
8922               
8923 2B12 0200  20        li   rtmp,MUT2                  ; JSR MUT2          ; Call MUT2 to calculate:
     2B14 4498     
8924 2B16 06A0  32        bl   @jsr                       ;
     2B18 FE28     
8925                                                                          ;
8926                                                                          ; (S R) = XX(1 0) = x
8927                                                                          ;
8928                                                                          ; (A P) = Q * A
8929                                                                          ; = (-beta * y_hi / 256) * (-beta * y_hi / 256)
8930                                                                          ; = (beta * y / 256) ^ 2
8931               
8932                      .asl @P                         ; ASL P             ; Double (A P), store the top byte in A and set the C
     **** ****     > ASL
0001 2B1A D020  30        movb @P,rtmp
     2B1C 001B     
0002 2B1E 0240  22        andi rtmp,>ff00
     2B20 FF00     
0003 2B22 0A10  18        sla  rtmp,1
0004 2B24 D800  30        movb rtmp,@P
     2B26 001B     
                   < elite.a99
8933 2B28 06A0  32        bl   @rola                      ; ROL A             ; flag to bit 7 of the original A, so this does:
     2B2A FE3E     
8934 2B2C D80D  30        movb ra,@T                      ; STA T             ;
     2B2E 00D1     
8935                                                                          ; (T P) = (A P) << 1
8936                                                                          ; = 2 * (beta * y / 256) ^ 2
8937               
8938 2B30 020D  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 in A to the sign bit from the A in the
     2B32 0000     
8939 2B34 06A0  32        bl   @rora                      ; ROR A             ; calculation above and apply it to T, so we now have:
     2B36 FE62     
8940 2B38 F360  30        socb @T,ra                      ; ORA T             ;
     2B3A 00D1     
8941                                                                          ; (A P) = (A P) * 2
8942                                                                          ; = 2 * (beta * y / 256) ^ 2
8943                                                                          ;
8944                                                                          ; with the doubling retaining the sign of (A P)
8945               
8946 2B3C 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2B3E 456E     
8947 2B40 06A0  32        bl   @jsr                       ;
     2B42 FE28     
8948                                                                          ;
8949                                                                          ; (A X) = (A P) + (S R)
8950                                                                          ; = 2 * (beta * y / 256) ^ 2 + x
8951               
8952 2B44 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     2B46 0025     
8953               
8954 2B48 D34E  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
8955 2B4A DBCD  38        movb ra,@SXL(ry)                ; STA SXL,Y
     2B4C 035F     
8956               
8957                                                                          ; So (XX+1 x_lo) now contains:
8958                                                                          ;
8959                                                                          ; x = x + 2 * (beta * y / 256) ^ 2
8960                                                                          ;
8961                                                                          ; which is result 7 above
8962               
8963 2B4E D360  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0) = y
     2B50 0026     
8964 2B52 D80D  30        movb ra,@R                      ; STA R
     2B54 0091     
8965 2B56 D360  30        movb @YY+1,ra                   ; LDA YY+1
     2B58 0027     
8966               * JSR MAD                \ These instructions are commented out in the original
8967               * STA S                  \ source
8968               * STX R
8969 2B5A D80D  30        movb ra,@S                      ; STA S
     2B5C 0092     
8970               
8971 2B5E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     2B60 0000     
8972 2B62 D80D  30        movb ra,@P                      ; STA P
     2B64 001B     
8973               
8974 2B66 D360  30        movb @BETA,ra                   ; LDA BETA          ; Set A = -beta, so:
     2B68 002A     
8975                      .eoi (>80*256)                  ; EOR #%10000000    ;
     **** ****     > EOI
0001 2B6A 0200  20        li   rtmp,(>80*256)
     2B6C 8000     
0002 2B6E 2B40  18        xor  rtmp,ra
                   < elite.a99
8976                                                                          ; (A P) = (-beta 0)
8977                                                                          ; = -beta * 256
8978               
8979 2B70 0200  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     2B72 27A2     
8980 2B74 06A0  32        bl   @jsr                       ;
     2B76 FE28     
8981                                                                          ;
8982                                                                          ; (YY+1 y_lo) = (A P) + (S R)
8983                                                                          ; = -beta * 256 + y
8984                                                                          ;
8985                                                                          ; i.e. y = y - beta * 256, which is result 8 above
8986                                                                          ;
8987                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
8988                                                                          ; ZZ, which will remove the old stardust particle, as we
8989                                                                          ; set X1, Y1 and ZZ to the original values for this
8990                                                                          ; particle during the calculations above
8991               
8992                                                                          ; We now have our newly moved stardust particle at
8993                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
8994                                                                          ; and distance z_hi, so we draw it if it's still on
8995                                                                          ; screen, otherwise we recycle it as a new bit of
8996                                                                          ; stardust and draw that
8997               
8998 2B78 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     2B7A 0025     
8999 2B7C D80D  30        movb ra,@X1                     ; STA X1            ; the new x-coordinate is in (x_hi x_lo) and the high
     2B7E 0031     
9000 2B80 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; byte is in X1
     2B82 034C     
9001               
9002 2B84 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |x_hi| >= 120 then jump to KILL1 to recycle this
     2B86 7F00     
9003 2B88 028D  22        ci   ra,>78*256                 ; CMP #120          ; particle, as it's gone off the side of the screen,
     2B8A 7800     
9004 2B8C 181C  14        joc  KILL1                      ; BCS KILL1         ; and rejoin at STC1 with the new particle
9005               
9006 2B8E D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     2B90 0027     
9007 2B92 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     2B94 0EC2     
9008 2B96 D80D  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     2B98 0032     
9009               
9010 2B9A 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 120 then jump to KILL1 to recycle this
     2B9C 7F00     
9011 2B9E 028D  22        ci   ra,>78*256                 ; CMP #120          ; particle, as it's gone off the top or bottom of the
     2BA0 7800     
9012 2BA2 1811  14        joc  KILL1                      ; BCS KILL1         ; screen, and rejoin at STC1 with the new particle
9013               
9014 2BA4 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; If z_hi < 16 then jump to KILL1 to recycle this
     2BA6 0EE8     
9015 2BA8 028D  22        ci   ra,>10*256                 ; CMP #16           ; particle, as it's so close that it's effectively gone
     2BAA 1000     
9016 2BAC 170C  14        jnc  KILL1                      ; BCC KILL1         ; past us, and rejoin at STC1 with the new particle
9017               
9018 2BAE D80D  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the z-coordinate in z_hi
     2BB0 0097     
9019               
9020               STC1:
9021 2BB2 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     2BB4 27B4     
9022 2BB6 06A0  32        bl   @jsr                       ;
     2BB8 FE28     
9023                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
9024                                                                          ; with distance z_hi
9025               
9026 2BBA 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
9027                                                                          ; stardust particle
9028               
9029 2BBC 1302  14        jeq  B18                        ; BEQ B18           ; If we have just done the last particle, skip the next
9030                                                                          ; instruction to return from the subroutine
9031               
9032 2BBE 0460  28        b    @STL1                      ; JMP STL1          ; We have more stardust to process, so jump back up to
     2BC0 2A00     
9033                                                                          ; STL1 for the next particle
9034               
9035               B18:
9036 2BC2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2BC4 FE34     
9037               
9038               KILL1:
9039                                                                          ; Our particle of stardust just flew past us, so let's
9040                                                                          ; recycle that particle, starting it at a random
9041                                                                          ; position that isn't too close to the centre point
9042 2BC6 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2BC8 C120     
9043 2BCA 06A0  32        bl   @jsr                       ;
     2BCC FE28     
9044               
9045 2BCE 026D  22        ori  ra,>04*256                 ; ORA #4            ; Make sure A is at least 4 and store it in Y1 and y_hi,
     2BD0 0400     
9046 2BD2 D80D  30        movb ra,@Y1                     ; STA Y1            ; so the new particle starts at least 4 pixels above or
     2BD4 0032     
9047 2BD6 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; below the centre of the screen
     2BD8 0EC2     
9048               
9049 2BDA 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2BDC C120     
9050 2BDE 06A0  32        bl   @jsr                       ;
     2BE0 FE28     
9051               
9052 2BE2 026D  22        ori  ra,>08*256                 ; ORA #8            ; Make sure A is at least 8 and store it in X1 and x_hi,
     2BE4 0800     
9053 2BE6 D80D  30        movb ra,@X1                     ; STA X1            ; so the new particle starts at least 8 pixels either
     2BE8 0031     
9054 2BEA DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; side of the centre of the screen
     2BEC 034C     
9055               
9056 2BEE 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2BF0 C120     
9057 2BF2 06A0  32        bl   @jsr                       ;
     2BF4 FE28     
9058               
9059 2BF6 026D  22        ori  ra,>90*256                 ; ORA #144          ; Make sure A is at least 144 and store it in ZZ and
     2BF8 9000     
9060 2BFA DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; z_hi so the new particle starts in the far distance
     2BFC 0EE8     
9061 2BFE D80D  30        movb ra,@ZZ                     ; STA ZZ
     2C00 0097     
9062               
9063 2C02 D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A to the new value of y_hi. This has no effect as
     2C04 0032     
9064                                                                          ; STC1 starts with a jump to PIXEL2, which starts with a
9065                                                                          ; LDA instruction
9066               
9067 2C06 0460  28        b    @STC1                      ; JMP STC1          ; Jump up to STC1 to draw this new particle
     2C08 2BB2     
9068               
9069               * ******************************************************************************
9070               *
9071               * Name: STARS6
9072               * Type: Subroutine
9073               * Category: Stardust
9074               * Summary: Process the stardust for the rear view
9075               *
9076               * ------------------------------------------------------------------------------
9077               *
9078               * This routine is very similar to STARS1, which processes stardust for the front
9079               * view. The main difference is that the direction of travel is reversed, so the
9080               * signs in the calculations are different, as well as the order of the first
9081               * batch of calculations.
9082               *
9083               * When a stardust particle falls away into the far distance, it is removed from
9084               * the screen and its memory is recycled as a new particle, positioned randomly
9085               * along one of the four edges of the screen.
9086               *
9087               * These are the calculations referred to in the commentary:
9088               *
9089               * 1. q = 64 * speed / z_hi
9090               * 2. z = z - speed * 64
9091               * 3. y = y + |y_hi| * q
9092               * 4. x = x + |x_hi| * q
9093               *
9094               * 5. y = y + alpha * x / 256
9095               * 6. x = x - alpha * y / 256
9096               *
9097               * 7. x = x + 2 * (beta * y / 256) ^ 2
9098               * 8. y = y - beta * 256
9099               *
9100               * For more information see the deep dive on "Stardust in the front view".
9101               *
9102               * ******************************************************************************
9103               
9104               STARS6:
9105 2C0A D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     2C0C 0F33     
9106                                                                          ; we can use it as a counter through all the stardust
9107               
9108               STL6:
9109 2C0E 0200  20        li   rtmp,DV42                  ; JSR DV42          ; Call DV42 to set the following:
     2C10 4658     
9110 2C12 06A0  32        bl   @jsr                       ;
     2C14 FE28     
9111                                                                          ;
9112                                                                          ; (P R) = 256 * DELTA / z_hi
9113                                                                          ; = 256 * speed / z_hi
9114                                                                          ;
9115                                                                          ; The maximum value returned is P = 2 and R = 128 (see
9116                                                                          ; DV42 for an explanation)
9117               
9118 2C16 D360  30        movb @R,ra                      ; LDA R             ; Set A = R, so now:
     2C18 0091     
9119                                                                          ;
9120                                                                          ; (P A) = 256 * speed / z_hi
9121               
9122                      .lsr @P                         ; LSR P             ; Rotate (P A) right by 2 places, which sets P = 0 (as P
     **** ****     > LSR
0001 2C1A D020  30        movb @P,rtmp
     2C1C 001B     
0002 2C1E 0910  18        srl  rtmp,1
0003 2C20 D800  30        movb rtmp,@P
     2C22 001B     
                   < elite.a99
9123 2C24 06A0  32        bl   @rora                      ; ROR A             ; has a maximum value of 2) and leaves:
     2C26 FE62     
9124                      .lsr @P                         ; LSR P             ;
     **** ****     > LSR
0001 2C28 D020  30        movb @P,rtmp
     2C2A 001B     
0002 2C2C 0910  18        srl  rtmp,1
0003 2C2E D800  30        movb rtmp,@P
     2C30 001B     
                   < elite.a99
9125 2C32 06A0  32        bl   @rora                      ; ROR A             ; A = 64 * speed / z_hi
     2C34 FE62     
9126               
9127 2C36 026D  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1, and store it in Q, so we
     2C38 0100     
9128 2C3A D80D  30        movb ra,@Q                      ; STA Q             ; now have result 1 above:
     2C3C 0090     
9129                                                                          ;
9130                                                                          ; Q = 64 * speed / z_hi
9131               
9132 2C3E D36F  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Set X1 = A = x_hi
     2C40 034C     
9133 2C42 D80D  30        movb ra,@X1                     ; STA X1            ;
     2C44 0031     
9134                                                                          ; So X1 contains the original value of x_hi, which we
9135                                                                          ; use below to remove the existing particle
9136               
9137 2C46 0200  20        li   rtmp,MLU2                  ; JSR MLU2          ; Set (A P) = |x_hi| * Q
     2C48 438A     
9138 2C4A 06A0  32        bl   @jsr                       ;
     2C4C FE28     
9139               
9140                                                                          ; We now calculate:
9141                                                                          ;
9142                                                                          ; XX(1 0) = x - (A P)
9143               
9144 2C4E D80D  30        movb ra,@XX+1                   ; STA XX+1          ; First we do the low bytes:
     2C50 0025     
9145 2C52 D36F  34        movb @SXL(ry),ra                ; LDA SXL,Y         ;
     2C54 035F     
9146                      .sbc @P,ra                      ; SBC P             ; XX(1 0) = x_lo - (A P)
     **** ****     > SBC
0001 2C56 1801  14        joc  !
0002 2C58 7347  18        sb   rone,ra
0003               !:
0004 2C5A 7360  30        sb   @P,ra
     2C5C 001B     
                   < elite.a99
9147 2C5E D80D  30        movb ra,@XX                     ; STA XX
     2C60 0024     
9148               
9149 2C62 D360  30        movb @X1,ra                     ; LDA X1            ; And then we do the high bytes:
     2C64 0031     
9150                      .sbc @XX+1,ra                   ; SBC XX+1          ;
     **** ****     > SBC
0001 2C66 1801  14        joc  !
0002 2C68 7347  18        sb   rone,ra
0003               !:
0004 2C6A 7360  30        sb   @XX+1,ra
     2C6C 0025     
                   < elite.a99
9151 2C6E D80D  30        movb ra,@XX+1                   ; STA XX+1          ; XX(1 0) = (x_hi 0) - XX(1 0)
     2C70 0025     
9152                                                                          ;
9153                                                                          ; so we get our result:
9154                                                                          ;
9155                                                                          ; XX(1 0) = x - (A P)
9156                                                                          ; = x - |x_hi| * Q
9157                                                                          ;
9158                                                                          ; which is result 2 above, and we also have:
9159               
9160 2C72 0200  20        li   rtmp,MLU1                  ; JSR MLU1          ; Call MLU1 to set:
     2C74 4382     
9161 2C76 06A0  32        bl   @jsr                       ;
     2C78 FE28     
9162                                                                          ;
9163                                                                          ; Y1 = y_hi
9164                                                                          ;
9165                                                                          ; (A P) = |y_hi| * Q
9166                                                                          ;
9167                                                                          ; So Y1 contains the original value of y_hi, which we
9168                                                                          ; use below to remove the existing particle
9169               
9170                                                                          ; We now calculate:
9171                                                                          ;
9172                                                                          ; (S R) = YY(1 0) = y - (A P)
9173               
9174 2C7A D80D  30        movb ra,@YY+1                   ; STA YY+1          ; First we do the low bytes with:
     2C7C 0027     
9175 2C7E D36F  34        movb @SYL(ry),ra                ; LDA SYL,Y         ;
     2C80 0ED5     
9176                      .sbc @P,ra                      ; SBC P             ; YY+1 = A
     **** ****     > SBC
0001 2C82 1801  14        joc  !
0002 2C84 7347  18        sb   rone,ra
0003               !:
0004 2C86 7360  30        sb   @P,ra
     2C88 001B     
                   < elite.a99
9177 2C8A D80D  30        movb ra,@YY                     ; STA YY            ; R = YY = y_lo - P
     2C8C 0026     
9178 2C8E D80D  30        movb ra,@R                      ; STA R             ;
     2C90 0091     
9179                                                                          ; so we get this:
9180                                                                          ;
9181                                                                          ; (? R) = YY(1 0) = y_lo - (A P)
9182               
9183 2C92 D360  30        movb @Y1,ra                     ; LDA Y1            ; And then we do the high bytes with:
     2C94 0032     
9184                      .sbc @YY+1,ra                   ; SBC YY+1          ;
     **** ****     > SBC
0001 2C96 1801  14        joc  !
0002 2C98 7347  18        sb   rone,ra
0003               !:
0004 2C9A 7360  30        sb   @YY+1,ra
     2C9C 0027     
                   < elite.a99
9185 2C9E D80D  30        movb ra,@YY+1                   ; STA YY+1          ; S = YY+1 = y_hi - YY+1
     2CA0 0027     
9186 2CA2 D80D  30        movb ra,@S                      ; STA S             ;
     2CA4 0092     
9187                                                                          ; so we get our result:
9188                                                                          ;
9189                                                                          ; (S R) = YY(1 0) = (y_hi y_lo) - (A P)
9190                                                                          ; = y - |y_hi| * Q
9191                                                                          ;
9192                                                                          ; which is result 3 above, and (S R) is set to the new
9193                                                                          ; value of y
9194               
9195 2CA6 D36F  34        movb @SZL(ry),ra                ; LDA SZL,Y         ; We now calculate the following:
     2CA8 0EFB     
9196                      .adc @DELT4,ra                  ; ADC DELT4         ;
     **** ****     > ADC
0001 2CAA 1701  14        jnc  !
0002 2CAC B347  18        ab   rone,ra
0003               !:
0004 2CAE B360  30        ab   @DELT4,ra
     2CB0 008D     
                   < elite.a99
9197 2CB2 DBCD  38        movb ra,@SZL(ry)                ; STA SZL,Y         ; (z_hi z_lo) = (z_hi z_lo) + DELT4(1 0)
     2CB4 0EFB     
9198                                                                          ;
9199                                                                          ; starting with the low bytes
9200               
9201 2CB6 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; And then we do the high bytes
     2CB8 0EE8     
9202 2CBA D80D  30        movb ra,@ZZ                     ; STA ZZ            ;
     2CBC 0097     
9203                      .adc @DELT4+1,ra                ; ADC DELT4+1       ; We also set ZZ to the original value of z_hi, which we
     **** ****     > ADC
0001 2CBE 1701  14        jnc  !
0002 2CC0 B347  18        ab   rone,ra
0003               !:
0004 2CC2 B360  30        ab   @DELT4+1,ra
     2CC4 008E     
                   < elite.a99
9204 2CC6 DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; use below to remove the existing particle
     2CC8 0EE8     
9205                                                                          ;
9206                                                                          ; So now we have result 4 above:
9207                                                                          ;
9208                                                                          ; z = z + DELT4(1 0)
9209                                                                          ; = z + speed * 64
9210               
9211 2CCA D360  30        movb @XX+1,ra                   ; LDA XX+1          ; EOR x with the correct sign of the roll angle alpha,
     2CCC 0025     
9212                      .eor @ALP2                      ; EOR ALP2          ; so A has the opposite sign to the roll angle alpha
     **** ****     > EOR
0001 2CCE D020  30        movb @ALP2,rtmp
     2CD0 0088     
0002 2CD2 2B40  18        xor  rtmp,ra
                   < elite.a99
9213               
9214 2CD4 0200  20        li   rtmp,MLS1                  ; JSR MLS1          ; Call MLS1 to calculate:
     2CD6 42A2     
9215 2CD8 06A0  32        bl   @jsr                       ;
     2CDA FE28     
9216                                                                          ;
9217                                                                          ; (A P) = A * ALP1
9218                                                                          ; = (-x / 256) * alpha
9219               
9220 2CDC 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2CDE 456E     
9221 2CE0 06A0  32        bl   @jsr                       ;
     2CE2 FE28     
9222                                                                          ;
9223                                                                          ; (A X) = (A P) + (S R)
9224                                                                          ; = (-x / 256) * alpha + y
9225                                                                          ; = y - alpha * x / 256
9226               
9227 2CE4 D80D  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY(1 0) = (A X) to give:
     2CE6 0027     
9228 2CE8 D80E  30        movb rx,@YY                     ; STX YY            ;
     2CEA 0026     
9229                                                                          ; YY(1 0) = y - alpha * x / 256
9230                                                                          ;
9231                                                                          ; which is result 5 above, and we also have:
9232                                                                          ;
9233                                                                          ; A = YY+1 = y - alpha * x / 256
9234                                                                          ;
9235                                                                          ; i.e. A is the new value of y, divided by 256
9236               
9237                      .eor @ALP2+1                    ; EOR ALP2+1        ; EOR with the flipped sign of the roll angle alpha, so
     **** ****     > EOR
0001 2CEC D020  30        movb @ALP2+1,rtmp
     2CEE 0089     
0002 2CF0 2B40  18        xor  rtmp,ra
                   < elite.a99
9238                                                                          ; A has the opposite sign to the flipped roll angle
9239                                                                          ; alpha, i.e. it gets the same sign as alpha
9240               
9241 2CF2 0200  20        li   rtmp,MLS2                  ; JSR MLS2          ; Call MLS2 to calculate:
     2CF4 4292     
9242 2CF6 06A0  32        bl   @jsr                       ;
     2CF8 FE28     
9243                                                                          ;
9244                                                                          ; (S R) = XX(1 0)
9245                                                                          ; = x
9246                                                                          ;
9247                                                                          ; (A P) = A * ALP1
9248                                                                          ; = y / 256 * alpha
9249               
9250 2CFA 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2CFC 456E     
9251 2CFE 06A0  32        bl   @jsr                       ;
     2D00 FE28     
9252                                                                          ;
9253                                                                          ; (A X) = (A P) + (S R)
9254                                                                          ; = y / 256 * alpha + x
9255               
9256 2D02 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Set XX(1 0) = (A X), which gives us result 6 above:
     2D04 0025     
9257 2D06 D80E  30        movb rx,@XX                     ; STX XX            ;
     2D08 0024     
9258                                                                          ; x = x + alpha * y / 256
9259               
9260 2D0A D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set A to y_hi and set it to the flipped sign of beta
     2D0C 0027     
9261                      .eor @BET2+1                    ; EOR BET2+1
     **** ****     > EOR
0001 2D0E D020  30        movb @BET2+1,rtmp
     2D10 008B     
0002 2D12 2B40  18        xor  rtmp,ra
                   < elite.a99
9262               
9263 2D14 D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the pitch magnitude into X
     2D16 002B     
9264               
9265 2D18 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     2D1A 42A8     
9266 2D1C 06A0  32        bl   @jsr                       ;
     2D1E FE28     
9267                                                                          ;
9268                                                                          ; (A P) = X * A
9269                                                                          ; = beta * y_hi
9270               
9271 2D20 D80D  30        movb ra,@Q                      ; STA Q             ; Store the high byte of the result in Q, so:
     2D22 0090     
9272                                                                          ;
9273                                                                          ; Q = beta * y_hi / 256
9274               
9275 2D24 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set S = x_hi
     2D26 0025     
9276 2D28 D80D  30        movb ra,@S                      ; STA S
     2D2A 0092     
9277               
9278                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A, so A now contains -x
     **** ****     > EOI
0001 2D2C 0200  20        li   rtmp,(>80*256)
     2D2E 8000     
0002 2D30 2B40  18        xor  rtmp,ra
                   < elite.a99
9279               
9280 2D32 0200  20        li   rtmp,MUT1                  ; JSR MUT1          ; Call MUT1 to calculate:
     2D34 44A0     
9281 2D36 06A0  32        bl   @jsr                       ;
     2D38 FE28     
9282                                                                          ;
9283                                                                          ; R = XX = x_lo
9284                                                                          ;
9285                                                                          ; (A P) = Q * A
9286                                                                          ; = (beta * y_hi / 256) * (-beta * y_hi / 256)
9287                                                                          ; = (-beta * y / 256) ^ 2
9288               
9289                      .asl @P                         ; ASL P             ; Double (A P), store the top byte in A and set the C
     **** ****     > ASL
0001 2D3A D020  30        movb @P,rtmp
     2D3C 001B     
0002 2D3E 0240  22        andi rtmp,>ff00
     2D40 FF00     
0003 2D42 0A10  18        sla  rtmp,1
0004 2D44 D800  30        movb rtmp,@P
     2D46 001B     
                   < elite.a99
9290 2D48 06A0  32        bl   @rola                      ; ROL A             ; flag to bit 7 of the original A, so this does:
     2D4A FE3E     
9291 2D4C D80D  30        movb ra,@T                      ; STA T             ;
     2D4E 00D1     
9292                                                                          ; (T P) = (A P) << 1
9293                                                                          ; = 2 * (-beta * y / 256) ^ 2
9294               
9295 2D50 020D  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 in A to the sign bit from the A in the
     2D52 0000     
9296 2D54 06A0  32        bl   @rora                      ; ROR A             ; calculation above and apply it to T, so we now have:
     2D56 FE62     
9297 2D58 F360  30        socb @T,ra                      ; ORA T             ;
     2D5A 00D1     
9298                                                                          ; (A P) = -2 * (beta * y / 256) ^ 2
9299                                                                          ;
9300                                                                          ; with the doubling retaining the sign of (A P)
9301               
9302 2D5C 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2D5E 456E     
9303 2D60 06A0  32        bl   @jsr                       ;
     2D62 FE28     
9304                                                                          ;
9305                                                                          ; (A X) = (A P) + (S R)
9306                                                                          ; = -2 * (beta * y / 256) ^ 2 + x
9307               
9308 2D64 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     2D66 0025     
9309               
9310 2D68 D34E  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
9311 2D6A DBCD  38        movb ra,@SXL(ry)                ; STA SXL,Y
     2D6C 035F     
9312               
9313                                                                          ; So (XX+1 x_lo) now contains:
9314                                                                          ;
9315                                                                          ; x = x - 2 * (beta * y / 256) ^ 2
9316                                                                          ;
9317                                                                          ; which is result 7 above
9318               
9319 2D6E D360  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0) = y
     2D70 0026     
9320 2D72 D80D  30        movb ra,@R                      ; STA R
     2D74 0091     
9321 2D76 D360  30        movb @YY+1,ra                   ; LDA YY+1
     2D78 0027     
9322 2D7A D80D  30        movb ra,@S                      ; STA S
     2D7C 0092     
9323               
9324               * EOR #128               \ These instructions are commented out in the original
9325               * JSR MAD                \ source
9326               * STA S
9327               * STX R
9328               
9329 2D7E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     2D80 0000     
9330 2D82 D80D  30        movb ra,@P                      ; STA P
     2D84 001B     
9331               
9332 2D86 D360  30        movb @BETA,ra                   ; LDA BETA          ; Set A = beta, so (A P) = (beta 0) = beta * 256
     2D88 002A     
9333               
9334 2D8A 0200  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     2D8C 27A2     
9335 2D8E 06A0  32        bl   @jsr                       ;
     2D90 FE28     
9336                                                                          ;
9337                                                                          ; (YY+1 y_lo) = (A P) + (S R)
9338                                                                          ; = beta * 256 + y
9339                                                                          ;
9340                                                                          ; i.e. y = y + beta * 256, which is result 8 above
9341                                                                          ;
9342                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
9343                                                                          ; ZZ, which will remove the old stardust particle, as we
9344                                                                          ; set X1, Y1 and ZZ to the original values for this
9345                                                                          ; particle during the calculations above
9346               
9347                                                                          ; We now have our newly moved stardust particle at
9348                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
9349                                                                          ; and distance z_hi, so we draw it if it's still on
9350                                                                          ; screen, otherwise we recycle it as a new bit of
9351                                                                          ; stardust and draw that
9352               
9353 2D92 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     2D94 0025     
9354 2D96 D80D  30        movb ra,@X1                     ; STA X1            ; the new x-coordinate is in (x_hi x_lo) and the high
     2D98 0031     
9355 2D9A DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; byte is in X1
     2D9C 034C     
9356               
9357 2D9E D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     2DA0 0027     
9358 2DA2 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     2DA4 0EC2     
9359 2DA6 D80D  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     2DA8 0032     
9360               
9361 2DAA 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 110 then jump to KILL6 to recycle this
     2DAC 7F00     
9362 2DAE 028D  22        ci   ra,>6e*256                 ; CMP #110          ; particle, as it's gone off the top or bottom of the
     2DB0 6E00     
9363 2DB2 1811  14        joc  KILL6                      ; BCS KILL6         ; screen, and rejoin at STC6 with the new particle
9364               
9365 2DB4 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; If z_hi >= 160 then jump to KILL6 to recycle this
     2DB6 0EE8     
9366 2DB8 028D  22        ci   ra,>a0*256                 ; CMP #160          ; particle, as it's so far away that it's too far to
     2DBA A000     
9367 2DBC 180C  14        joc  KILL6                      ; BCS KILL6         ; see, and rejoin at STC1 with the new particle
9368               
9369 2DBE D80D  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the z-coordinate in z_hi
     2DC0 0097     
9370               
9371               STC6:
9372 2DC2 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     2DC4 27B4     
9373 2DC6 06A0  32        bl   @jsr                       ;
     2DC8 FE28     
9374                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
9375                                                                          ; with distance z_hi
9376               
9377 2DCA 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
9378                                                                          ; stardust particle
9379               
9380 2DCC 1302  14        jeq  ST3                        ; BEQ ST3           ; If we have just done the last particle, skip the next
9381                                                                          ; instruction to return from the subroutine
9382               
9383 2DCE 0460  28        b    @STL6                      ; JMP STL6          ; We have more stardust to process, so jump back up to
     2DD0 2C0E     
9384                                                                          ; STL6 for the next particle
9385               
9386               ST3:
9387 2DD2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2DD4 FE34     
9388               
9389               KILL6:
9390 2DD6 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2DD8 C120     
9391 2DDA 06A0  32        bl   @jsr                       ;
     2DDC FE28     
9392               
9393 2DDE 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit of A to get |A|
     2DE0 7F00     
9394               
9395                      .adi (>0a*256)                  ; ADC #10           ; Make sure A is at least 10 and store it in z_hi and
     **** ****     > ADI
0001 2DE2 1701  14        jnc  !
0002 2DE4 B347  18        ab   rone,ra
0003               !:
0004 2DE6 022D  22        ai   ra,(>0A*256)
     2DE8 0A00     
                   < elite.a99
9396 2DEA DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; ZZ, so the new particle starts close to us
     2DEC 0EE8     
9397 2DEE D80D  30        movb ra,@ZZ                     ; STA ZZ
     2DF0 0097     
9398               
9399 2DF2 091D  18        srl  ra,1                       ; LSR A             ; Divide A by 2 and randomly set the C flag
9400               
9401 2DF4 1813  14        joc  ST4                        ; BCS ST4           ; Jump to ST4 half the time
9402               
9403 2DF6 091D  18        srl  ra,1                       ; LSR A             ; Randomly set the C flag again
9404               
9405 2DF8 020D  20        li   ra,>fc*256                 ; LDA #252          ; Set A to either +126 or -126 (252 >> 1) depending on
     2DFA FC00     
9406 2DFC 06A0  32        bl   @rora                      ; ROR A             ; the C flag, as this is a sign-magnitude number with
     2DFE FE62     
9407                                                                          ; the C flag rotated into its sign bit
9408               
9409 2E00 D80D  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to A, so this particle starts on
     2E02 0031     
9410 2E04 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; either the left or right edge of the screen
     2E06 034C     
9411               
9412 2E08 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2E0A C120     
9413 2E0C 06A0  32        bl   @jsr                       ;
     2E0E FE28     
9414               
9415 2E10 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to random numbers, so the particle
     2E12 0032     
9416 2E14 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; starts anywhere along either the left or right edge
     2E16 0EC2     
9417               
9418 2E18 0460  28        b    @STC6                      ; JMP STC6          ; Jump up to STC6 to draw this new particle
     2E1A 2DC2     
9419               
9420               ST4:
9421 2E1C 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2E1E C120     
9422 2E20 06A0  32        bl   @jsr                       ;
     2E22 FE28     
9423               
9424 2E24 D80D  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to random numbers, so the particle
     2E26 0031     
9425 2E28 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; starts anywhere along the x-axis
     2E2A 034C     
9426               
9427 2E2C 091D  18        srl  ra,1                       ; LSR A             ; Randomly set the C flag
9428               
9429 2E2E 020D  20        li   ra,>e6*256                 ; LDA #230          ; Set A to either +115 or -115 (230 >> 1) depending on
     2E30 E600     
9430 2E32 06A0  32        bl   @rora                      ; ROR A             ; the C flag, as this is a sign-magnitude number with
     2E34 FE62     
9431                                                                          ; the C flag rotated into its sign bit
9432               
9433 2E36 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to A, so the particle starts anywhere
     2E38 0032     
9434 2E3A DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; along either the top or bottom edge of the screen
     2E3C 0EC2     
9435               
9436 2E3E 16C1  14        jne  STC6                       ; BNE STC6          ; Jump up to STC6 to draw this new particle (this BNE is
9437                                                                          ; effectively a JMP as A will never be zero)
9438               
9439               * ******************************************************************************
9440               *
9441               * Name: PRXS
9442               * Type: Variable
9443               * Category: Equipment
9444               * Summary: Equipment prices
9445               *
9446               * ------------------------------------------------------------------------------
9447               *
9448               * Equipment prices are stored as 10 * the actual value, so we can support prices
9449               * with fractions of credits (0.1 Cr). This is used for the price of fuel only.
9450               *
9451               * ******************************************************************************
9452               
9453               PRXS:
9454 2E40 0100            data >0100                                          ; 0  Fuel, calculated in EQSHP  140.0 Cr (full tank)
9455 2E42 2C01            data >2c01                                          ; 1  Missile                     30.0 Cr
9456 2E44 A00F            data >a00f                                          ; 2  Large Cargo Bay            400.0 Cr
9457 2E46 7017            data >7017                                          ; 3  E.C.M. System              600.0 Cr
9458 2E48 A00F            data >a00f                                          ; 4  Extra Pulse Lasers         400.0 Cr
9459 2E4A 1027            data >1027                                          ; 5  Extra Beam Lasers         1000.0 Cr
9460 2E4C 8214            data >8214                                          ; 6  Fuel Scoops                525.0 Cr
9461 2E4E 1027            data >1027                                          ; 7  Escape Pod                1000.0 Cr
9462 2E50 2823            data >2823                                          ; 8  Energy Bomb                900.0 Cr
9463 2E52 983A            data >983a                                          ; 9  Energy Unit               1500.0 Cr
9464 2E54 1027            data >1027                                          ; 10 Docking Computer          1000.0 Cr
9465 2E56 50C3            data >50c3                                          ; 11 Galactic Hyperspace       5000.0 Cr
9466               
9467               * ******************************************************************************
9468               *
9469               * Name: STATUS
9470               * Type: Subroutine
9471               * Category: Status
9472               * Summary: Show the Status Mode screen (red key f8)
9473               * Deep dive: Combat rank
9474               *
9475               * ******************************************************************************
9476               
9477               st4_:
9478                                                                          ; We call this from st5 below with the high byte of the
9479                                                                          ; kill tally in A, which is non-zero, and want to return
9480                                                                          ; with the following in X, depending on our rating:
9481                                                                          ;
9482                                                                          ; Competent = 6
9483                                                                          ; Dangerous = 7
9484                                                                          ; Deadly    = 8
9485                                                                          ; Elite     = 9
9486                                                                          ;
9487                                                                          ; The high bytes of the top tier ratings are as follows,
9488                                                                          ; so this a relatively simple calculation:
9489                                                                          ;
9490                                                                          ; Competent       = 1 to 2
9491                                                                          ; Dangerous       = 2 to 9
9492                                                                          ; Deadly          = 10 to 24
9493                                                                          ; Elite           = 25 and up
9494 2E58 020E  20        li   rx,>09*256                 ; LDX #9            ; Set X to 9 for an Elite rating
     2E5A 0900     
9495               
9496 2E5C 028D  22        ci   ra,>19*256                 ; CMP #25           ; If A >= 25, jump to st3 to print out our rating, as we
     2E5E 1900     
9497 2E60 185C  14        joc  st3_                       ; BCS st3           ; are Elite
9498               
9499 2E62 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to 8 for a Deadly rating
9500               
9501 2E64 028D  22        ci   ra,>0a*256                 ; CMP #10           ; If A >= 10, jump to st3 to print out our rating, as we
     2E66 0A00     
9502 2E68 1858  14        joc  st3_                       ; BCS st3           ; are Deadly
9503               
9504 2E6A 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to 7 for a Dangerous rating
9505               
9506 2E6C 028D  22        ci   ra,>02*256                 ; CMP #2            ; If A >= 2, jump to st3 to print out our rating, as we
     2E6E 0200     
9507 2E70 1854  14        joc  st3_                       ; BCS st3           ; are Dangerous
9508               
9509 2E72 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to 6 for a Competent rating
9510               
9511 2E74 1652  14        jne  st3_                       ; BNE st3           ; Jump to st3 to print out our rating, as we are
9512                                                                          ; Competent (this BNE is effectively a JMP as A will
9513                                                                          ; never be zero)
9514               
9515               STATUS:
9516 2E76 020D  20        li   ra,>08*256                 ; LDA #8            ; Clear the top part of the screen, draw a white border,
     2E78 0800     
9517 2E7A 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 8 (Status
     2E7C 4BDE     
9518 2E7E 06A0  32        bl   @jsr                       ;
     2E80 FE28     
9519                                                                          ; Mode screen)
9520               
9521 2E82 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     2E84 5B78     
9522 2E86 06A0  32        bl   @jsr                       ;
     2E88 FE28     
9523                                                                          ; (QQ9, QQ10)
9524               
9525 2E8A 020D  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     2E8C 0700     
9526 2E8E D80D  30        movb ra,@XC                     ; STA XC
     2E90 002C     
9527               
9528 2E92 020D  20        li   ra,>7e*256                 ; LDA #126          ; Print recursive token 126, which prints the top
     2E94 7E00     
9529 2E96 0200  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; four lines of the Status Mode screen:
     2E98 25E4     
9530 2E9A 06A0  32        bl   @jsr                       ;
     2E9C FE28     
9531                                                                          ;
9532                                                                          ; COMMANDER {commander name}
9533                                                                          ;
9534                                                                          ;
9535                                                                          ; Present System      : {current system name}
9536                                                                          ; Hyperspace System   : {selected system name}
9537                                                                          ; Condition           :
9538                                                                          ;
9539                                                                          ; and draw a horizontal line at pixel row 19 to box
9540                                                                          ; in the title
9541               
9542 2E9E 020D  20        li   ra,>0f*256                 ; LDA #15           ; Set A to token 129 ("{sentence case}DOCKED")
     2EA0 0F00     
9543               
9544 2EA2 D3E0  30        movb @QQ12,ry                   ; LDY QQ12          ; Fetch the docked status from QQ12, and if we are
     2EA4 009F     
9545 2EA6 160F  14        jne  st6_                       ; BNE st6           ; docked, jump to st6 to print "Docked" for our
9546                                                                          ; ship's condition
9547               
9548 2EA8 020D  20        li   ra,>e6*256                 ; LDA #230          ; Otherwise we are in space, so start off by setting A
     2EAA E600     
9549                                                                          ; to token 70 ("GREEN")
9550               
9551 2EAC D3E0  30        movb @MANY+AST,ry               ; LDY MANY+AST      ; Set Y to the number of asteroids in our local bubble
     2EAE 0D57     
9552                                                                          ; of universe
9553               
9554 2EB0 D3AF  34        movb @FRIN+2(ry),rx             ; LDX FRIN+2,Y      ; The ship slots at FRIN are ordered with the first two
     2EB2 0D42     
9555                                                                          ; slots reserved for the planet and sun/space station,
9556                                                                          ; and then any ships, so if the slot at FRIN+2+Y is not
9557                                                                          ; empty (i.e. is non-zero), then that means the number
9558                                                                          ; of non-asteroids in the vicinity is at least 1
9559               
9560 2EB4 1308  14        jeq  st6_                       ; BEQ st6           ; So if X = 0, there are no ships in the vicinity, so
9561                                                                          ; jump to st6 to print "Green" for our ship's condition
9562               
9563 2EB6 D3E0  30        movb @ENERGY,ry                 ; LDY ENERGY        ; Otherwise we have ships in the vicinity, so we load
     2EB8 0F13     
9564                                                                          ; our energy levels into Y
9565               
9566 2EBA 028F  22        ci   ry,>80*256                 ; CPY #128          ; Set the C flag if Y >= 128, so C is set if we have
     2EBC 8000     
9567                                                                          ; more than half of our energy banks charged
9568               
9569                      .adi (>01*256)                  ; ADC #1            ; Add 1 + C to A, so if C is not set (i.e. we have low
     **** ****     > ADI
0001 2EBE 1701  14        jnc  !
0002 2EC0 B347  18        ab   rone,ra
0003               !:
0004 2EC2 022D  22        ai   ra,(>01*256)
     2EC4 0100     
                   < elite.a99
9570                                                                          ; energy levels) then A is set to token 231 ("RED"),
9571                                                                          ; and if C is set (i.e. we have healthy energy levels)
9572                                                                          ; then A is set to token 232 ("YELLOW")
9573               
9574               st6_:
9575 2EC6 0200  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A (which contains our ship's
     2EC8 A6D0     
9576 2ECA 06A0  32        bl   @jsr                       ;
     2ECC FE28     
9577                                                                          ; condition) followed by a newline
9578               
9579 2ECE 020D  20        li   ra,>7d*256                 ; LDA #125          ; Print recursive token 125, which prints the next
     2ED0 7D00     
9580 2ED2 0200  20        li   rtmp,spc_                  ; JSR spc           ; three lines of the Status Mode screen:
     2ED4 4FBE     
9581 2ED6 06A0  32        bl   @jsr                       ;
     2ED8 FE28     
9582                                                                          ;
9583                                                                          ; Fuel: {fuel level} Light Years
9584                                                                          ; Cash: {cash} Cr
9585                                                                          ; Legal Status:
9586                                                                          ;
9587                                                                          ; followed by a space
9588               
9589 2EDA 020D  20        li   ra,>13*256                 ; LDA #19           ; Set A to token 133 ("CLEAN")
     2EDC 1300     
9590               
9591 2EDE D3E0  30        movb @FIST,ry                   ; LDY FIST          ; Fetch our legal status, and if it is 0, we are clean,
     2EE0 0334     
9592 2EE2 1306  14        jeq  st5_                       ; BEQ st5           ; so jump to st5 to print "Clean"
9593               
9594 2EE4 028F  22        ci   ry,>32*256                 ; CPY #50           ; Set the C flag if Y >= 50, so C is set if we have
     2EE6 3200     
9595                                                                          ; a legal status of 50+ (i.e. we are a fugitive)
9596               
9597                      .adi (>01*256)                  ; ADC #1            ; Add 1 + C to A, so if C is not set (i.e. we have a
     **** ****     > ADI
0001 2EE8 1701  14        jnc  !
0002 2EEA B347  18        ab   rone,ra
0003               !:
0004 2EEC 022D  22        ai   ra,(>01*256)
     2EEE 0100     
                   < elite.a99
9598                                                                          ; legal status between 1 and 49) then A is set to token
9599                                                                          ; 134 ("OFFENDER"), and if C is set (i.e. we have a
9600                                                                          ; legal status of 50+) then A is set to token 135
9601                                                                          ; ("FUGITIVE")
9602               
9603               st5_:
9604 2EF0 0200  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A (which contains our legal
     2EF2 A6D0     
9605 2EF4 06A0  32        bl   @jsr                       ;
     2EF6 FE28     
9606                                                                          ; status) followed by a newline
9607               
9608 2EF8 020D  20        li   ra,>10*256                 ; LDA #16           ; Print recursive token 130 ("RATING:") followed by a
     2EFA 1000     
9609 2EFC 0200  20        li   rtmp,spc_                  ; JSR spc           ; space
     2EFE 4FBE     
9610 2F00 06A0  32        bl   @jsr                       ;
     2F02 FE28     
9611               
9612 2F04 D360  30        movb @TALLY+1,ra                ; LDA TALLY+1       ; Fetch the high byte of the kill tally, and if it is
     2F06 0348     
9613 2F08 16A7  14        jne  st4_                       ; BNE st4           ; not zero, then we have more than 256 kills, so jump
9614                                                                          ; to st4 to work out whether we are Competent,
9615                                                                          ; Dangerous, Deadly or Elite
9616               
9617                                                                          ; Otherwise we have fewer than 256 kills, so we are one
9618                                                                          ; of Harmless, Mostly Harmless, Poor, Average or Above
9619                                                                          ; Average
9620               
9621 2F0A D38D  18        movb ra,rx                      ; TAX               ; Set X to 0 (as A is 0)
9622               
9623 2F0C D360  30        movb @TALLY,ra                  ; LDA TALLY         ; Set A = lower byte of tally / 4
     2F0E 0347     
9624 2F10 091D  18        srl  ra,1                       ; LSR A
9625 2F12 091D  18        srl  ra,1                       ; LSR A
9626               
9627               st5L:
9628                                                                          ; We now loop through bits 2 to 7, shifting each of them
9629                                                                          ; off the end of A until there are no set bits left, and
9630                                                                          ; incrementing X for each shift, so at the end of the
9631                                                                          ; process, X contains the position of the leftmost 1 in
9632                                                                          ; A. Looking at the rank values in TALLY:
9633                                                                          ;
9634                                                                          ; Harmless        = %00000000 to %00000011
9635                                                                          ; Mostly Harmless = %00000100 to %00000111
9636                                                                          ; Poor            = %00001000 to %00001111
9637                                                                          ; Average         = %00010000 to %00011111
9638                                                                          ; Above Average   = %00100000 to %11111111
9639                                                                          ;
9640                                                                          ; we can see that the values returned by this process
9641                                                                          ; are:
9642                                                                          ;
9643                                                                          ; Harmless        = 1
9644                                                                          ; Mostly Harmless = 2
9645                                                                          ; Poor            = 3
9646                                                                          ; Average         = 4
9647                                                                          ; Above Average   = 5
9648 2F14 B387  18        ab   rone,rx                    ; INX               ; Increment X for each shift
9649               
9650 2F16 091D  18        srl  ra,1                       ; LSR A             ; Shift A to the right
9651               
9652 2F18 16FD  14        jne  st5L                       ; BNE st5L          ; Keep looping around until A = 0, which means there are
9653                                                                          ; no set bits left in A
9654               
9655               st3_:
9656 2F1A D34E  18        movb rx,ra                      ; TXA               ; A now contains our rating as a value of 1 to 9, so
9657                                                                          ; transfer X to A, so we can print it out
9658               
9659                      .clc                            ; CLC               ; Print recursive token 135 + A, which will be in the
     **** ****     > CLC
0001 2F1C 0A16  18        sla  rzero,1
                   < elite.a99
9660                      .adi (>15*256)                  ; ADC #21           ; range 136 ("HARMLESS") to 144 ("---- E L I T E ----")
     **** ****     > ADI
0001 2F1E 1701  14        jnc  !
0002 2F20 B347  18        ab   rone,ra
0003               !:
0004 2F22 022D  22        ai   ra,(>15*256)
     2F24 1500     
                   < elite.a99
9661 2F26 0200  20        li   rtmp,plf_                  ; JSR plf           ; followed by a newline
     2F28 A6D0     
9662 2F2A 06A0  32        bl   @jsr                       ;
     2F2C FE28     
9663               
9664 2F2E 020D  20        li   ra,>12*256                 ; LDA #18           ; Print recursive token 132, which prints the next bit
     2F30 1200     
9665 2F32 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; of the Status Mode screen:
     2F34 2FE4     
9666 2F36 06A0  32        bl   @jsr                       ;
     2F38 FE28     
9667                                                                          ;
9668                                                                          ; EQUIPMENT:
9669                                                                          ;
9670                                                                          ; followed by a newline and an indent of 6 characters
9671               
9672 2F3A D360  30        movb @CRGO,ra                   ; LDA CRGO          ; If our ship's cargo capacity is < 26 (i.e. we do not
     2F3C 0316     
9673 2F3E 028D  22        ci   ra,>1a*256                 ; CMP #26           ; have a cargo bay extension), skip the following two
     2F40 1A00     
9674 2F42 1706  14        jnc  B19                        ; BCC B19           ; instructions
9675               
9676 2F44 020D  20        li   ra,>6b*256                 ; LDA #107          ; We do have a cargo bay extension, so print recursive
     2F46 6B00     
9677 2F48 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; token 107 ("LARGE CARGO{sentence case} BAY"), followed
     2F4A 2FE4     
9678 2F4C 06A0  32        bl   @jsr                       ;
     2F4E FE28     
9679                                                                          ; by a newline and an indent of 6 characters
9680               
9681               B19:
9682 2F50 D360  30        movb @BST,ra                    ; LDA BST           ; If we don't have fuel scoops fitted, skip the
     2F52 0329     
9683 2F54 1306  14        jeq  B20                        ; BEQ B20           ; following two instructions
9684               
9685 2F56 020D  20        li   ra,>6f*256                 ; LDA #111          ; We do have fuel scoops fitted, so print recursive
     2F58 6F00     
9686 2F5A 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; token 111 ("FUEL SCOOPS"), followed by a newline and
     2F5C 2FE4     
9687 2F5E 06A0  32        bl   @jsr                       ;
     2F60 FE28     
9688                                                                          ; an indent of 6 characters
9689               
9690               B20:
9691 2F62 D360  30        movb @ECM,ra                    ; LDA ECM           ; If we don't have an E.C.M. fitted, skip the following
     2F64 0328     
9692 2F66 1306  14        jeq  B21                        ; BEQ B21           ; two instructions
9693               
9694 2F68 020D  20        li   ra,>6c*256                 ; LDA #108          ; We do have an E.C.M. fitted, so print recursive token
     2F6A 6C00     
9695 2F6C 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; 108 ("E.C.M.SYSTEM"), followed by a newline and an
     2F6E 2FE4     
9696 2F70 06A0  32        bl   @jsr                       ;
     2F72 FE28     
9697                                                                          ; indent of 6 characters
9698               
9699               B21:
9700 2F74 020D  20        li   ra,>71*256                 ; LDA #113          ; We now cover the four pieces of equipment whose flags
     2F76 7100     
9701 2F78 D80D  30        movb ra,@XX4                    ; STA XX4           ; are stored in BOMB through BOMB+3, and whose names
     2F7A 00A7     
9702                                                                          ; correspond with text tokens 113 through 116:
9703                                                                          ;
9704                                                                          ; BOMB+0 = BOMB  = token 113 = Energy bomb
9705                                                                          ; BOMB+1 = ENGY  = token 114 = Energy unit
9706                                                                          ; BOMB+2 = DKCMP = token 115 = Docking computer
9707                                                                          ; BOMB+3 = GHYP  = token 116 = Galactic hyperdrive
9708                                                                          ;
9709                                                                          ; We can print these out using a loop, so we set XX4 to
9710                                                                          ; 113 as a counter (and we also set A as well, to pass
9711                                                                          ; through to plf2)
9712               
9713               stqv_:
9714 2F7C D3CD  18        movb ra,ry                      ; TAY               ; Fetch byte BOMB+0 through BOMB+4 for values of XX4
9715 2F7E D3AF  34        movb @BOMB-113(ry),rx           ; LDX BOMB-113,Y    ; from 113 through 117
     2F80 02B9     
9716               
9717 2F82 1304  14        jeq  B22                        ; BEQ B22           ; If it is zero then we do not own that piece of
9718                                                                          ; equipment, so skip the next instruction
9719               
9720 2F84 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; Print the recursive token in A from 113 ("ENERGY
     2F86 2FE4     
9721 2F88 06A0  32        bl   @jsr                       ;
     2F8A FE28     
9722                                                                          ; BOMB") through 116 ("GALACTIC HYPERSPACE "), followed
9723                                                                          ; by a newline and an indent of 6 characters
9724               
9725               B22:
9726 2F8C B347  18        ab   rone,ra                    ; INC XX4           ; Increment the counter (and A as well)
9727 2F8E D360  30        movb @XX4,ra                    ; LDA XX4
     2F90 00A7     
9728               
9729 2F92 028D  22        ci   ra,>75*256                 ; CMP #117          ; If A < 117, loop back up to stqv to print the next
     2F94 7500     
9730 2F96 17F2  14        jnc  stqv_                      ; BCC stqv          ; piece of equipment
9731               
9732 2F98 020E  20        li   rx,>00*256                 ; LDX #0            ; Now to print our ship's lasers, so set a counter in X
     2F9A 0000     
9733                                                                          ; to count through the four views (0 = front, 1 = rear,
9734                                                                          ; 2 = left, 3 = right)
9735               
9736               st_:
9737 2F9C D80E  30        movb rx,@CNT                    ; STX CNT           ; Store the view number in CNT
     2F9E 00A4     
9738               
9739 2FA0 D3EE  34        movb @LASER(rx),ry              ; LDY LASER,X       ; Fetch the laser power for view X, and if we do not
     2FA2 0310     
9740 2FA4 1317  14        jeq  st1_                       ; BEQ st1           ; have a laser fitted to that view, jump to st1 to move
9741                                                                          ; on to the next one
9742               
9743 2FA6 D34E  18        movb rx,ra                      ; TXA               ; Print recursive token 96 + X, which will print from 96
9744                      .clc                            ; CLC               ; ("FRONT") through to 99 ("RIGHT"), followed by a space
     **** ****     > CLC
0001 2FA8 0A16  18        sla  rzero,1
                   < elite.a99
9745                      .adi (>60*256)                  ; ADC #96
     **** ****     > ADI
0001 2FAA 1701  14        jnc  !
0002 2FAC B347  18        ab   rone,ra
0003               !:
0004 2FAE 022D  22        ai   ra,(>60*256)
     2FB0 6000     
                   < elite.a99
9746 2FB2 0200  20        li   rtmp,spc_                  ; JSR spc
     2FB4 4FBE     
9747 2FB6 06A0  32        bl   @jsr                       ;
     2FB8 FE28     
9748               
9749 2FBA 020D  20        li   ra,>67*256                 ; LDA #103          ; Set A to token 103 ("PULSE LASER")
     2FBC 6700     
9750               
9751 2FBE D3A0  30        movb @CNT,rx                    ; LDX CNT           ; If the laser power for view X has bit 7 clear, then it
     2FC0 00A4     
9752 2FC2 D3EE  34        movb @LASER(rx),ry              ; LDY LASER,X       ; is a pulse laser, so skip the following instruction
     2FC4 0310     
9753 2FC6 1502  14        jgt  B23                        ; BPL B23
9754               
9755 2FC8 020D  20        li   ra,>68*256                 ; LDA #104          ; Set A to token 104 ("BEAM LASER")
     2FCA 6800     
9756               
9757               B23:
9758 2FCC 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; Print the text token in A (which contains the laser
     2FCE 2FE4     
9759 2FD0 06A0  32        bl   @jsr                       ;
     2FD2 FE28     
9760                                                                          ; type) followed by a newline and an indent of 6
9761                                                                          ; characters
9762               
9763               st1_:
9764 2FD4 D3A0  30        movb @CNT,rx                    ; LDX CNT           ; Increment the counter in X and CNT to point to the
     2FD6 00A4     
9765 2FD8 B387  18        ab   rone,rx                    ; INX               ; next view
9766               
9767 2FDA 028E  22        ci   rx,>04*256                 ; CPX #4            ; If this isn't the last of the four views, jump back up
     2FDC 0400     
9768 2FDE 17DE  14        jnc  st_                        ; BCC st            ; to st to print out the next one
9769               
9770 2FE0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2FE2 FE34     
9771               
9772               * ******************************************************************************
9773               *
9774               * Name: plf2
9775               * Type: Subroutine
9776               * Category: Text
9777               * Summary: Print text followed by a newline and indent of 6 characters
9778               *
9779               * ------------------------------------------------------------------------------
9780               *
9781               * Print a text token followed by a newline, and indent the next line to text
9782               * column 6.
9783               *
9784               * ------------------------------------------------------------------------------
9785               *
9786               * Arguments:
9787               *
9788               * A                   The text token to be printed
9789               *
9790               * ******************************************************************************
9791               
9792               plf2_:
9793 2FE4 0200  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A followed by a newline
     2FE6 A6D0     
9794 2FE8 06A0  32        bl   @jsr                       ;
     2FEA FE28     
9795               
9796 2FEC 020E  20        li   rx,>06*256                 ; LDX #6            ; Move the text cursor to column 6
     2FEE 0600     
9797 2FF0 D80E  30        movb rx,@XC                     ; STX XC
     2FF2 002C     
9798               
9799 2FF4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2FF6 FE34     
9800               
9801               * ******************************************************************************
9802               *
9803               * Name: TENS
9804               * Type: Variable
9805               * Category: Text
9806               * Summary: A constant used when printing large numbers in BPRNT
9807               * Deep dive: Printing decimal numbers
9808               *
9809               * ------------------------------------------------------------------------------
9810               *
9811               * Contains the four low bytes of the value 100,000,000,000 (100 billion).
9812               *
9813               * The maximum number of digits that we can print with the BPRNT routine is 11,
9814               * so the biggest number we can print is 99,999,999,999. This maximum number
9815               * plus 1 is 100,000,000,000, which in hexadecimal is:
9816               *
9817               * & 17 48 76 E8 00
9818               *
9819               * The TENS variable contains the lowest four bytes in this number, with the
9820               * most significant byte first, i.e. 48 76 E8 00. This value is used in the
9821               * BPRNT routine when working out which decimal digits to print when printing a
9822               * number.
9823               *
9824               * ******************************************************************************
9825               
9826               TENS:
9827 2FF8 0000            data >0000, >0000
     2FFA 0000     
9828               
9829               * ******************************************************************************
9830               *
9831               * Name: pr2
9832               * Type: Subroutine
9833               * Category: Text
9834               * Summary: Print an 8-bit number, left-padded to 3 digits, and optional point
9835               *
9836               * ------------------------------------------------------------------------------
9837               *
9838               * Print the 8-bit number in X to 3 digits, left-padding with spaces for numbers
9839               * with fewer than 3 digits (so numbers < 100 are right-aligned). Optionally
9840               * include a decimal point.
9841               *
9842               * ------------------------------------------------------------------------------
9843               *
9844               * Arguments:
9845               *
9846               * X                   The number to print
9847               *
9848               * C flag              If set, include a decimal point
9849               *
9850               * ------------------------------------------------------------------------------
9851               *
9852               * Other entry points:
9853               *
9854               * pr2+2               Print the 8-bit number in X to the number of digits in A
9855               *
9856               * ******************************************************************************
9857               
9858               pr2_:
9859 2FFC 020D  20        li   ra,>03*256                 ; LDA #3            ; Set A to the number of digits (3)
     2FFE 0300     
9860               
9861 3000 020F  20        li   ry,>00*256                 ; LDY #0            ; Zero the Y register, so we can fall through into TT11
     3002 0000     
9862                                                                          ; to print the 16-bit number (Y X) to 3 digits, which
9863                                                                          ; effectively prints X to 3 digits as the high byte is
9864                                                                          ; zero
9865               
9866               * ******************************************************************************
9867               *
9868               * Name: TT11
9869               * Type: Subroutine
9870               * Category: Text
9871               * Summary: Print a 16-bit number, left-padded to n digits, and optional point
9872               *
9873               * ------------------------------------------------------------------------------
9874               *
9875               * Print the 16-bit number in (Y X) to a specific number of digits, left-padding
9876               * with spaces for numbers with fewer digits (so lower numbers will be right-
9877               * aligned). Optionally include a decimal point.
9878               *
9879               * ------------------------------------------------------------------------------
9880               *
9881               * Arguments:
9882               *
9883               * X                   The low byte of the number to print
9884               *
9885               * Y                   The high byte of the number to print
9886               *
9887               * A                   The number of digits
9888               *
9889               * C flag              If set, include a decimal point
9890               *
9891               * ******************************************************************************
9892               
9893               TT11:
9894 3004 D80D  30        movb ra,@U                      ; STA U             ; We are going to use the BPRNT routine (below) to
     3006 008F     
9895                                                                          ; print this number, so we store the number of digits
9896                                                                          ; in U, as that's what BPRNT takes as an argument
9897               
9898 3008 020D  20        li   ra,>00*256                 ; LDA #0            ; BPRNT takes a 32-bit number in K to K+3, with the
     300A 0000     
9899 300C D80D  30        movb ra,@K                      ; STA K             ; most significant byte first (big-endian), so we set
     300E 003D     
9900 3010 D80D  30        movb ra,@K+1                    ; STA K+1           ; the two most significant bytes to zero (K and K+1)
     3012 003E     
9901 3014 D80F  30        movb ry,@K+2                    ; STY K+2           ; and store (Y X) in the least two significant bytes
     3016 003F     
9902 3018 D80E  30        movb rx,@K+3                    ; STX K+3           ; (K+2 and K+3), so we are going to print the 32-bit
     301A 0040     
9903                                                                          ; number (0 0 Y X)
9904               
9905                                                                          ; Finally we fall through into BPRNT to print out the
9906                                                                          ; number in K to K+3, which now contains (Y X), to 3
9907                                                                          ; digits (as U = 3), using the same C flag as when pr2
9908                                                                          ; was called to control the decimal point
9909               
9910               * ******************************************************************************
9911               *
9912               * Name: BPRNT
9913               * Type: Subroutine
9914               * Category: Text
9915               * Summary: Print a 32-bit number, left-padded to a specific number of digits,
9916               * with an optional decimal point
9917               * Deep dive: Printing decimal numbers
9918               *
9919               * ------------------------------------------------------------------------------
9920               *
9921               * Print the 32-bit number stored in K(0 1 2 3) to a specific number of digits,
9922               * left-padding with spaces for numbers with fewer digits (so lower numbers are
9923               * right-aligned). Optionally include a decimal point.
9924               *
9925               * See the deep dive on "Printing decimal numbers" for details of the algorithm
9926               * used in this routine.
9927               *
9928               * ------------------------------------------------------------------------------
9929               *
9930               * Arguments:
9931               *
9932               * K(0 1 2 3)          The number to print, stored with the most significant
9933               * byte in K and the least significant in K+3 (i.e. as a
9934               * big-endian number, which is the opposite way to how the
9935               * 6502 assembler stores addresses, for example)
9936               *
9937               * U                   The maximum number of digits to print, including the
9938               * decimal point (spaces will be used on the left to pad
9939               * out the result to this width, so the number is right-
9940               * aligned to this width). U must be 11 or less
9941               *
9942               * C flag              If set, include a decimal point followed by one
9943               * fractional digit (i.e. show the number to 1 decimal
9944               * place). In this case, the number in K(0 1 2 3) contains
9945               * 10 * the number we end up printing, so to print 123.4,
9946               * we would pass 1234 in K(0 1 2 3) and would set the C
9947               * flag to include the decimal point
9948               *
9949               * ******************************************************************************
9950               
9951               BPRNT:
9952 301C 020E  20        li   rx,>0b*256                 ; LDX #11           ; Set T to the maximum number of digits allowed (11
     301E 0B00     
9953 3020 D80E  30        movb rx,@T                      ; STX T             ; characters, which is the number of digits in 10
     3022 00D1     
9954                                                                          ; billion). We will use this as a flag when printing
9955                                                                          ; characters in TT37 below
9956               
9957                      .php                            ; PHP               ; Make a copy of the status register (in particular
     **** ****     > PHP
0001 3024 02C0  12        stst rtmp
0002 3026 D680  30        movb rtmp,*rsp
0003 3028 060A  14        dec  rsp
                   < elite.a99
9958                                                                          ; the C flag) so we can retrieve it later
9959               
9960 302A 1702  14        jnc  TT30                       ; BCC TT30          ; If the C flag is clear, we do not want to print a
9961                                                                          ; decimal point, so skip the next two instructions
9962               
9963 302C 7347  18        sb   rone,ra                    ; DEC T             ; As we are going to show a decimal point, decrement
9964 302E 7347  18        sb   rone,ra                    ; DEC U             ; both the number of characters and the number of
9965                                                                          ; digits (as one of them is now a decimal point)
9966               
9967               TT30:
9968 3030 020D  20        li   ra,>0b*256                 ; LDA #11           ; Set A to 11, the maximum number of digits allowed
     3032 0B00     
9969               
9970                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 3034 0A18  18        sla  rmone,1
                   < elite.a99
9971                                                                          ; C flag affecting the result
9972               
9973 3036 D80D  30        movb ra,@XX17                   ; STA XX17          ; Store the maximum number of digits allowed (11) in
     3038 0095     
9974                                                                          ; XX17
9975               
9976                      .sbc @U,ra                      ; SBC U             ; Set U = 11 - U + 1, so U now contains the maximum
     **** ****     > SBC
0001 303A 1801  14        joc  !
0002 303C 7347  18        sb   rone,ra
0003               !:
0004 303E 7360  30        sb   @U,ra
     3040 008F     
                   < elite.a99
9977 3042 D80D  30        movb ra,@U                      ; STA U             ; number of digits minus the number of digits we want
     3044 008F     
9978 3046 B347  18        ab   rone,ra                    ; INC U             ; to display, plus 1 (so this is the number of digits
9979                                                                          ; we should skip before starting to print the number
9980                                                                          ; itself, and the plus 1 is there to ensure we print at
9981                                                                          ; least one digit)
9982               
9983 3048 020F  20        li   ry,>00*256                 ; LDY #0            ; In the main loop below, we use Y to count the number
     304A 0000     
9984                                                                          ; of times we subtract 10 billion to get the leftmost
9985                                                                          ; digit, so set this to zero
9986               
9987 304C D80F  30        movb ry,@S                      ; STY S             ; In the main loop below, we use location S as an
     304E 0092     
9988                                                                          ; 8-bit overflow for the 32-bit calculations, so
9989                                                                          ; we need to set this to 0 before joining the loop
9990               
9991 3050 0460  28        b    @TT36                      ; JMP TT36          ; Jump to TT36 to start the process of printing this
     3052 3124     
9992                                                                          ; number's digits
9993               
9994               TT35:
9995                                                                          ; This subroutine multiplies K(S 0 1 2 3) by 10 and
9996                                                                          ; stores the result back in K(S 0 1 2 3), using the fact
9997                                                                          ; that K * 10 = (K * 2) + (K * 2 * 2 * 2)
9998                      .asl @K+3                       ; ASL K+3           ; Set K(S 0 1 2 3) = K(S 0 1 2 3) * 2 by rotating left
     **** ****     > ASL
0001 3054 D020  30        movb @K+3,rtmp
     3056 0040     
0002 3058 0240  22        andi rtmp,>ff00
     305A FF00     
0003 305C 0A10  18        sla  rtmp,1
0004 305E D800  30        movb rtmp,@K+3
     3060 0040     
                   < elite.a99
9999 3062 0204  20        li   rarg1,K+2                  ; ROL K+2
     3064 003F     
10000 3066 06A0  32        bl   @rol                       ;
     3068 FE4E     
10001 306A 0204  20        li   rarg1,K+1                  ; ROL K+1
     306C 003E     
10002 306E 06A0  32        bl   @rol                       ;
     3070 FE4E     
10003 3072 0204  20        li   rarg1,K                    ; ROL K
     3074 003D     
10004 3076 06A0  32        bl   @rol                       ;
     3078 FE4E     
10005 307A 0204  20        li   rarg1,S                    ; ROL S
     307C 0092     
10006 307E 06A0  32        bl   @rol                       ;
     3080 FE4E     
10007               
10008 3082 020E  20        li   rx,>03*256                 ; LDX #3            ; Now we want to make a copy of the newly doubled K in
     3084 0300     
10009                                                                          ; XX15, so we can use it for the first (K * 2) in the
10010                                                                          ; equation above, so set up a counter in X for copying
10011                                                                          ; four bytes, starting with the last byte in memory
10012                                                                          ; (i.e. the least significant)
10013               
10014               tt35_:
10015 3086 D36E  34        movb @K(rx),ra                  ; LDA K,X           ; Copy the X-th byte of K(0 1 2 3) to the X-th byte of
     3088 003D     
10016 308A DB8D  38        movb ra,@XX15(rx)               ; STA XX15,X        ; XX15(0 1 2 3), so that XX15 will contain a copy of
     308C 0031     
10017                                                                          ; K(0 1 2 3) once we've copied all four bytes
10018               
10019 308E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10020               
10021 3090 15FA  14        jgt  tt35_                      ; BPL tt35          ; Loop back to copy the next byte until we have copied
10022                                                                          ; all four
10023               
10024 3092 D360  30        movb @S,ra                      ; LDA S             ; Store the value of location S, our overflow byte, in
     3094 0092     
10025 3096 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; XX15+4, so now XX15(4 0 1 2 3) contains a copy of
     3098 0035     
10026                                                                          ; K(S 0 1 2 3), which is the value of (K * 2) that we
10027                                                                          ; want to use in our calculation
10028               
10029                      .asl @K+3                       ; ASL K+3           ; Now to calculate the (K * 2 * 2 * 2) part. We still
     **** ****     > ASL
0001 309A D020  30        movb @K+3,rtmp
     309C 0040     
0002 309E 0240  22        andi rtmp,>ff00
     30A0 FF00     
0003 30A2 0A10  18        sla  rtmp,1
0004 30A4 D800  30        movb rtmp,@K+3
     30A6 0040     
                   < elite.a99
10030 30A8 0204  20        li   rarg1,K+2                  ; ROL K+2           ; have (K * 2) in K(S 0 1 2 3), so we just need to shift
     30AA 003F     
10031 30AC 06A0  32        bl   @rol                       ;
     30AE FE4E     
10032 30B0 0204  20        li   rarg1,K+1                  ; ROL K+1           ; it twice. This is the first one, so we do this:
     30B2 003E     
10033 30B4 06A0  32        bl   @rol                       ;
     30B6 FE4E     
10034 30B8 0204  20        li   rarg1,K                    ; ROL K             ;
     30BA 003D     
10035 30BC 06A0  32        bl   @rol                       ;
     30BE FE4E     
10036 30C0 0204  20        li   rarg1,S                    ; ROL S             ; K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 4
     30C2 0092     
10037 30C4 06A0  32        bl   @rol                       ;
     30C6 FE4E     
10038               
10039                      .asl @K+3                       ; ASL K+3           ; And then we do it again, so that means:
     **** ****     > ASL
0001 30C8 D020  30        movb @K+3,rtmp
     30CA 0040     
0002 30CC 0240  22        andi rtmp,>ff00
     30CE FF00     
0003 30D0 0A10  18        sla  rtmp,1
0004 30D2 D800  30        movb rtmp,@K+3
     30D4 0040     
                   < elite.a99
10040 30D6 0204  20        li   rarg1,K+2                  ; ROL K+2           ;
     30D8 003F     
10041 30DA 06A0  32        bl   @rol                       ;
     30DC FE4E     
10042 30DE 0204  20        li   rarg1,K+1                  ; ROL K+1           ; K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 8
     30E0 003E     
10043 30E2 06A0  32        bl   @rol                       ;
     30E4 FE4E     
10044 30E6 0204  20        li   rarg1,K                    ; ROL K
     30E8 003D     
10045 30EA 06A0  32        bl   @rol                       ;
     30EC FE4E     
10046 30EE 0204  20        li   rarg1,S                    ; ROL S
     30F0 0092     
10047 30F2 06A0  32        bl   @rol                       ;
     30F4 FE4E     
10048               
10049                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 30F6 0A16  18        sla  rzero,1
                   < elite.a99
10050                                                                          ; C flag affecting the result
10051               
10052 30F8 020E  20        li   rx,>03*256                 ; LDX #3            ; By now we've got (K * 2) in XX15(4 0 1 2 3) and
     30FA 0300     
10053                                                                          ; (K * 8) in K(S 0 1 2 3), so the final step is to add
10054                                                                          ; these two 32-bit numbers together to get K * 10.
10055                                                                          ; So we set a counter in X for four bytes, starting
10056                                                                          ; with the last byte in memory (i.e. the least
10057                                                                          ; significant)
10058               
10059               tt36_:
10060 30FC D36E  34        movb @K(rx),ra                  ; LDA K,X           ; Fetch the X-th byte of K into A
     30FE 003D     
10061               
10062                      .adc @XX15(rx),ra               ; ADC XX15,X        ; Add the X-th byte of XX15 to A, with carry
     **** ****     > ADC
0001 3100 1701  14        jnc  !
0002 3102 B347  18        ab   rone,ra
0003               !:
0004 3104 B36E  34        ab   @XX15(RX),ra
     3106 0031     
                   < elite.a99
10063               
10064 3108 DB8D  38        movb ra,@K(rx)                  ; STA K,X           ; Store the result in the X-th byte of K
     310A 003D     
10065               
10066 310C 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10067               
10068 310E 15F6  14        jgt  tt36_                      ; BPL tt36          ; Loop back to add the next byte, moving from the least
10069                                                                          ; significant byte to the most significant, until we
10070                                                                          ; have added all four
10071               
10072 3110 D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Finally, fetch the overflow byte from XX15(4 0 1 2 3)
     3112 0035     
10073               
10074                      .adc @S,ra                      ; ADC S             ; And add it to the overflow byte from K(S 0 1 2 3),
     **** ****     > ADC
0001 3114 1701  14        jnc  !
0002 3116 B347  18        ab   rone,ra
0003               !:
0004 3118 B360  30        ab   @S,ra
     311A 0092     
                   < elite.a99
10075                                                                          ; with carry
10076               
10077 311C D80D  30        movb ra,@S                      ; STA S             ; And store the result in the overflow byte from
     311E 0092     
10078                                                                          ; K(S 0 1 2 3), so now we have our desired result, i.e.
10079                                                                          ;
10080                                                                          ; K(S 0 1 2 3) = K(S 0 1 2 3) * 10
10081               
10082 3120 020F  20        li   ry,>00*256                 ; LDY #0            ; In the main loop below, we use Y to count the number
     3122 0000     
10083                                                                          ; of times we subtract 10 billion to get the leftmost
10084                                                                          ; digit, so set this to zero so we can rejoin the main
10085                                                                          ; loop for another subtraction process
10086               
10087               TT36:
10088                                                                          ; This is the main loop of our digit-printing routine.
10089                                                                          ; In the following loop, we are going to count the
10090                                                                          ; number of times that we can subtract 10 million and
10091                                                                          ; store that count in Y, which we have already set to 0
10092 3124 020E  20        li   rx,>03*256                 ; LDX #3            ; Our first calculation concerns 32-bit numbers, so
     3126 0300     
10093                                                                          ; set up a counter for a four-byte loop
10094               
10095                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 3128 0A18  18        sla  rmone,1
                   < elite.a99
10096                                                                          ; C flag affecting the result
10097               
10098               tt37_:
10099                                                                          ; We now loop through each byte in turn to do this:
10100                                                                          ;
10101                                                                          ; XX15(4 0 1 2 3) = K(S 0 1 2 3) - 100,000,000,000
10102 312A D36E  34        movb @K(rx),ra                  ; LDA K,X           ; Subtract the X-th byte of TENS (i.e. 10 billion) from
     312C 003D     
10103                      .sbc @TENS(rx),ra               ; SBC TENS,X        ; the X-th byte of K
     **** ****     > SBC
0001 312E 1801  14        joc  !
0002 3130 7347  18        sb   rone,ra
0003               !:
0004 3132 736E  34        sb   @TENS(RX),ra
     3134 2FF8     
                   < elite.a99
10104               
10105 3136 DB8D  38        movb ra,@XX15(rx)               ; STA XX15,X        ; Store the result in the X-th byte of XX15
     3138 0031     
10106               
10107 313A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10108               
10109 313C 15F6  14        jgt  tt37_                      ; BPL tt37          ; Loop back to subtract the next byte, moving from the
10110                                                                          ; least significant byte to the most significant, until
10111                                                                          ; we have subtracted all four
10112               
10113 313E D360  30        movb @S,ra                      ; LDA S             ; Subtract the fifth byte of 10 billion (i.e. &17) from
     3140 0092     
10114                      .sbi (>17*256)                  ; SBC #&17          ; the fifth (overflow) byte of K, which is S
     **** ****     > SBI
0001 3142 1801  14        joc  !
0002 3144 7347  18        sb   rone,ra
0003               !:
0004 3146 022D  22        ai   ra,-(>17*256)
     3148 E900     
                   < elite.a99
10115               
10116 314A D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; Store the result in the overflow byte of XX15
     314C 0035     
10117               
10118 314E 170F  14        jnc  TT37                       ; BCC TT37          ; If subtracting 10 billion took us below zero, jump to
10119                                                                          ; TT37 to print out this digit, which is now in Y
10120               
10121 3150 020E  20        li   rx,>03*256                 ; LDX #3            ; We now want to copy XX15(4 0 1 2 3) back into
     3152 0300     
10122                                                                          ; K(S 0 1 2 3), so we can loop back up to do the next
10123                                                                          ; subtraction, so set up a counter for a four-byte loop
10124               
10125               tt38_:
10126 3154 D36E  34        movb @XX15(rx),ra               ; LDA XX15,X        ; Copy the X-th byte of XX15(0 1 2 3) to the X-th byte
     3156 0031     
10127 3158 DB8D  38        movb ra,@K(rx)                  ; STA K,X           ; of K(0 1 2 3), so that K(0 1 2 3) will contain a copy
     315A 003D     
10128                                                                          ; of XX15(0 1 2 3) once we've copied all four bytes
10129               
10130 315C 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10131               
10132 315E 15FA  14        jgt  tt38_                      ; BPL tt38          ; Loop back to copy the next byte, until we have copied
10133                                                                          ; all four
10134               
10135 3160 D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Store the value of location XX15+4, our overflow
     3162 0035     
10136 3164 D80D  30        movb ra,@S                      ; STA S             ; byte in S, so now K(S 0 1 2 3) contains a copy of
     3166 0092     
10137                                                                          ; XX15(4 0 1 2 3)
10138               
10139 3168 B3C7  18        ab   rone,ry                    ; INY               ; We have now managed to subtract 10 billion from our
10140                                                                          ; number, so increment Y, which is where we are keeping
10141                                                                          ; a count of the number of subtractions so far
10142               
10143 316A 0460  28        b    @TT36                      ; JMP TT36          ; Jump back to TT36 to subtract the next 10 billion
     316C 3124     
10144               
10145               TT37:
10146 316E D34F  18        movb ry,ra                      ; TYA               ; If we get here then Y contains the digit that we want
10147                                                                          ; to print (as Y has now counted the total number of
10148                                                                          ; subtractions of 10 billion), so transfer Y into A
10149               
10150 3170 1608  14        jne  TT32                       ; BNE TT32          ; If the digit is non-zero, jump to TT32 to print it
10151               
10152 3172 D360  30        movb @T,ra                      ; LDA T             ; Otherwise the digit is zero. If we are already
     3174 00D1     
10153                                                                          ; printing the number then we will want to print a 0,
10154                                                                          ; but if we haven't started printing the number yet,
10155                                                                          ; then we probably don't, as we don't want to print
10156                                                                          ; leading zeroes unless this is the only digit before
10157                                                                          ; the decimal point
10158                                                                          ;
10159                                                                          ; To help with this, we are going to use T as a flag
10160                                                                          ; that tells us whether we have already started
10161                                                                          ; printing digits:
10162                                                                          ;
10163                                                                          ; * If T <> 0 we haven't printed anything yet
10164                                                                          ;
10165                                                                          ; * If T = 0 then we have started printing digits
10166                                                                          ;
10167                                                                          ; We initially set T above to the maximum number of
10168                                                                          ; characters allowed, less 1 if we are printing a
10169                                                                          ; decimal point, so the first time we enter the digit
10170                                                                          ; printing routine at TT37, it is definitely non-zero
10171               
10172 3176 1305  14        jeq  TT32                       ; BEQ TT32          ; If T = 0, jump straight to the print routine at TT32,
10173                                                                          ; as we have already started printing the number, so we
10174                                                                          ; definitely want to print this digit too
10175               
10176 3178 7347  18        sb   rone,ra                    ; DEC U             ; We initially set U to the number of digits we want to
10177 317A 1510  14        jgt  TT34                       ; BPL TT34          ; skip before starting to print the number. If we get
10178                                                                          ; here then we haven't printed any digits yet, so
10179                                                                          ; decrement U to see if we have reached the point where
10180                                                                          ; we should start printing the number, and if not, jump
10181                                                                          ; to TT34 to set up things for the next digit
10182               
10183 317C 020D  20        li   ra,(' ')*256               ; LDA #' '          ; We haven't started printing any digits yet, but we
     317E 2000     
10184 3180 1609  14        jne  tt34_                      ; BNE tt34          ; have reached the point where we should start printing
10185                                                                          ; our number, so call TT26 (via tt34) to print a space
10186                                                                          ; so that the number is left-padded with spaces (this
10187                                                                          ; BNE is effectively a JMP as A will never be zero)
10188               
10189               TT32:
10190 3182 020F  20        li   ry,>00*256                 ; LDY #0            ; We are printing an actual digit, so first set T to 0,
     3184 0000     
10191 3186 D80F  30        movb ry,@T                      ; STY T             ; to denote that we have now started printing digits as
     3188 00D1     
10192                                                                          ; opposed to spaces
10193               
10194                      .clc                            ; CLC               ; The digit value is in A, so add ASCII "0" to get the
     **** ****     > CLC
0001 318A 0A16  18        sla  rzero,1
                   < elite.a99
10195                      .adi (('0')*256)                ; ADC #'0'          ; ASCII character number to print
     **** ****     > ADI
0001 318C 1701  14        jnc  !
0002 318E B347  18        ab   rone,ra
0003               !:
0004 3190 022D  22        ai   ra,(('0')*256)
     3192 3000     
                   < elite.a99
10196               
10197               tt34_:
10198 3194 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Call TT26 to print the character in A and fall through
     3196 31C2     
10199 3198 06A0  32        bl   @jsr                       ;
     319A FE28     
10200                                                                          ; into TT34 to get things ready for the next digit
10201               
10202               TT34:
10203 319C 7347  18        sb   rone,ra                    ; DEC T             ; Decrement T but keep T >= 0 (by incrementing it
10204 319E 1501  14        jgt  B24                        ; BPL B24           ; again if the above decrement made T negative)
10205 31A0 B347  18        ab   rone,ra                    ; INC T
10206               
10207               B24:
10208 31A2 7347  18        sb   rone,ra                    ; DEC XX17          ; Decrement the total number of characters left to
10209                                                                          ; print, which we stored in XX17
10210               
10211 31A4 1166  14        jlt  RR3+1                      ; BMI RR3+1         ; If the result is negative, we have printed all the
10212                                                                          ; characters, so return from the subroutine (as RR3
10213                                                                          ; contains an ORA #&60 instruction, so RR3+1 is &60,
10214                                                                          ; which is the opcode for an RTS)
10215               
10216 31A6 1609  14        jne  B25                        ; BNE B25           ; If the result is positive (> 0) then we still have
10217                                                                          ; characters left to print, so loop back to TT35 (via
10218                                                                          ; the JMP TT35 instruction below) to print the next
10219                                                                          ; digit
10220               
10221                      .plp                            ; PLP               ; If we get here then we have printed the exact number
     **** ****     > PLP
0001 31A8 058A  14        inc  rsp
0002 31AA D01A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
10222                                                                          ; of digits that we wanted to, so restore the C flag
10223                                                                          ; that we stored at the start of the routine
10224               
10225 31AC 1706  14        jnc  B25                        ; BCC B25           ; If the C flag is clear, we don't want a decimal point,
10226                                                                          ; so loop back to TT35 (via the JMP TT35 instruction
10227                                                                          ; below) to print the next digit
10228               
10229 31AE 020D  20        li   ra,('.')*256               ; LDA #'.'          ; Otherwise the C flag is set, so print the decimal
     31B0 2E00     
10230 31B2 0200  20        li   rtmp,TT26                  ; JSR TT26          ; point
     31B4 31C2     
10231 31B6 06A0  32        bl   @jsr                       ;
     31B8 FE28     
10232               
10233               B25:
10234 31BA 0460  28        b    @TT35                      ; JMP TT35          ; Loop back to TT35 to print the next digit
     31BC 3054     
10235               
10236               * ******************************************************************************
10237               *
10238               * Name: BELL
10239               * Type: Subroutine
10240               * Category: Sound
10241               * Summary: Make a standard system beep
10242               *
10243               * ------------------------------------------------------------------------------
10244               *
10245               * This is the standard system beep, as made by the ASCII 7 "BELL" control code.
10246               *
10247               * ******************************************************************************
10248               
10249               BELL:
10250 31BE 020D  20        li   ra,>07*256                 ; LDA #7            ; Control code 7 makes a beep, so load this into A
     31C0 0700     
10251               
10252                                                                          ; Fall through into the TT26 print routine to
10253                                                                          ; actually make the sound
10254               
10255               * ******************************************************************************
10256               *
10257               * Name: TT26
10258               * Type: Subroutine
10259               * Category: Text
10260               * Summary: Print a character at the text cursor by poking into screen memory
10261               * Deep dive: Drawing text
10262               *
10263               * ------------------------------------------------------------------------------
10264               *
10265               * Print a character at the text cursor (XC, YC), do a beep, print a newline,
10266               * or delete left (backspace).
10267               *
10268               * WRCHV is set to point here by the loading process.
10269               *
10270               * ------------------------------------------------------------------------------
10271               *
10272               * Arguments:
10273               *
10274               * A                   The character to be printed. Can be one of the
10275               * following:
10276               *
10277               * * 7 (beep)
10278               *
10279               * * 10-13 (line feeds and carriage returns)
10280               *
10281               * * 32-95 (ASCII capital letters, numbers and
10282               * punctuation)
10283               *
10284               * * 127 (delete the character to the left of the text
10285               * cursor and move the cursor to the left)
10286               *
10287               * XC                  Contains the text column to print at (the x-coordinate)
10288               *
10289               * YC                  Contains the line number to print on (the y-coordinate)
10290               *
10291               * ------------------------------------------------------------------------------
10292               *
10293               * Returns:
10294               *
10295               * A                   A is preserved
10296               *
10297               * X                   X is preserved
10298               *
10299               * Y                   Y is preserved
10300               *
10301               * C flag              The C flag is cleared
10302               *
10303               * ------------------------------------------------------------------------------
10304               *
10305               * Other entry points:
10306               *
10307               * RR3+1               Contains an RTS
10308               *
10309               * RREN                Prints the character definition pointed to by P(2 1) at
10310               * the screen address pointed to by (A SC). Used by the
10311               * BULB routine
10312               *
10313               * rT9                 Contains an RTS
10314               *
10315               * ******************************************************************************
10316               
10317               TT26:
10318 31C2 D80D  30        movb ra,@K3                     ; STA K3            ; Store the A, X and Y registers, so we can restore
     31C4 00D2     
10319 31C6 D80F  30        movb ry,@YSAV2                  ; STY YSAV2         ; them at the end (so they don't get changed by this
     31C8 0F0F     
10320 31CA D80E  30        movb rx,@XSAV2                  ; STX XSAV2         ; routine)
     31CC 0F0E     
10321               
10322 31CE D3E0  30        movb @QQ17,ry                   ; LDY QQ17          ; Load the QQ17 flag, which contains the text printing
     31D0 007E     
10323                                                                          ; flags
10324               
10325 31D2 028F  22        ci   ry,>ff*256                 ; CPY #255          ; If QQ17 = 255 then printing is disabled, so jump to
     31D4 FF00     
10326 31D6 136A  14        jeq  RR4                        ; BEQ RR4           ; RR4, which doesn't print anything, it just restores
10327                                                                          ; the registers and returns from the subroutine
10328               
10329 31D8 028D  22        ci   ra,>07*256                 ; CMP #7            ; If this is a beep character (A = 7), jump to R5,
     31DA 0700     
10330 31DC 1370  14        jeq  R5_                        ; BEQ R5_           ; which will emit the beep, restore the registers and
10331                                                                          ; return from the subroutine
10332               
10333 31DE 028D  22        ci   ra,>20*256                 ; CMP #32           ; If this is an ASCII character (A >= 32), jump to RR1
     31E0 2000     
10334 31E2 1809  14        joc  RR1                        ; BCS RR1           ; below, which will print the character, restore the
10335                                                                          ; registers and return from the subroutine
10336               
10337 31E4 028D  22        ci   ra,>0a*256                 ; CMP #10           ; If this is control code 10 (line feed) then jump to
     31E6 0A00     
10338 31E8 1304  14        jeq  RRX1                       ; BEQ RRX1          ; RRX1, which will move down a line, restore the
10339                                                                          ; registers and return from the subroutine
10340               
10341 31EA 020E  20        li   rx,>01*256                 ; LDX #1            ; If we get here, then this is control code 11-13, of
     31EC 0100     
10342 31EE D80E  30        movb rx,@XC                     ; STX XC            ; which only 13 is used. This code prints a newline,
     31F0 002C     
10343                                                                          ; which we can achieve by moving the text cursor
10344                                                                          ; to the start of the line (carriage return) and down
10345                                                                          ; one line (line feed). These two lines do the first
10346                                                                          ; bit by setting XC = 1, and we then fall through into
10347                                                                          ; the line feed routine that's used by control code 10
10348               
10349               RRX1:
10350 31F2 B347  18        ab   rone,ra                    ; INC YC            ; Print a line feed, simply by incrementing the row
10351                                                                          ; number (y-coordinate) of the text cursor, which is
10352                                                                          ; stored in YC
10353               
10354 31F4 165B  14        jne  RR4                        ; BNE RR4           ; Jump to RR4 to restore the registers and return from
10355                                                                          ; the subroutine (this BNE is effectively a JMP as Y
10356                                                                          ; will never be zero)
10357               
10358               RR1:
10359                                                                          ; If we get here, then the character to print is an
10360                                                                          ; ASCII character in the range 32-95. The quickest way
10361                                                                          ; to display text on-screen is to poke the character
10362                                                                          ; pixel by pixel, directly into screen memory, so
10363                                                                          ; that's what the rest of this routine does
10364                                                                          ;
10365                                                                          ; The first step, then, is to get hold of the bitmap
10366                                                                          ; definition for the character we want to draw on the
10367                                                                          ; screen (i.e. we need the pixel shape of this
10368                                                                          ; character). The MOS ROM contains bitmap definitions
10369                                                                          ; of the system's ASCII characters, starting from &C000
10370                                                                          ; for space (ASCII 32) and ending with the  symbol
10371                                                                          ; (ASCII 126)
10372                                                                          ;
10373                                                                          ; There are definitions for 32 characters in each of the
10374                                                                          ; three pages of MOS memory, as each definition takes up
10375                                                                          ; 8 bytes (8 rows of 8 pixels) and 32 * 8 = 256 bytes =
10376                                                                          ; 1 page. So:
10377                                                                          ;
10378                                                                          ; ASCII 32-63  are defined in &C000-&C0FF (page 0)
10379                                                                          ; ASCII 64-95  are defined in &C100-&C1FF (page 1)
10380                                                                          ; ASCII 96-126 are defined in &C200-&C2F0 (page 2)
10381                                                                          ;
10382                                                                          ; The following code reads the relevant character
10383                                                                          ; bitmap from the above locations in ROM and pokes
10384                                                                          ; those values into the correct position in screen
10385                                                                          ; memory, thus printing the character on-screen
10386                                                                          ;
10387                                                                          ; It's a long way from 10 PRINT "Hello world!":GOTO 10
10388               * LDX #LO(K3)            \ These instructions are commented out in the original
10389               * INX                    \ source, but they call OSWORD 10, which reads the
10390               * STX P+1                \ character bitmap for the character number in K3 and
10391               * DEX                    \ stores it in the block at K3+1, while also setting
10392               * LDY #HI(K3)            \ P+1 to point to the character definition. This is
10393               * STY P+2                \ exactly what the following uncommented code does,
10394               * LDA #10                \ just without calling OSWORD. Presumably the code
10395               * JSR OSWORD             \ below is faster than using the system call, as this
10396                                                                          ; version takes up 15 bytes, while the version below
10397                                                                          ; (which ends with STA P+1 and SYX P+2) is 17 bytes.
10398                                                                          ; Every efficiency saving helps, especially as this
10399                                                                          ; routine is run each time the game prints a character
10400                                                                          ;
10401                                                                          ; If you want to switch this code back on, uncomment
10402                                                                          ; the above block, and comment out the code below from
10403                                                                          ; TAY to STX P+2. You will also need to uncomment the
10404                                                                          ; LDA YC instruction a few lines down (in RR2), just to
10405                                                                          ; make sure the rest of the code doesn't shift in
10406                                                                          ; memory. To be honest I can't see a massive difference
10407                                                                          ; in speed, but there you go
10408 31F6 D3CD  18        movb ra,ry                      ; TAY               ; Copy the character number from A to Y, as we are
10409                                                                          ; about to pull A apart to work out where this
10410                                                                          ; character definition lives in memory
10411               
10412                                                                          ; Now we want to set X to point to the relevant page
10413                                                                          ; number for this character - i.e. &C0, &C1 or &C2.
10414               
10415                                                                          ; The following logic is easier to follow if we look
10416                                                                          ; at the three character number ranges in binary:
10417                                                                          ;
10418                                                                          ; Bit #  76543210
10419                                                                          ;
10420                                                                          ; 32  = %00100000     Page 0 of bitmap definitions
10421                                                                          ; 63  = %00111111
10422                                                                          ;
10423                                                                          ; 64  = %01000000     Page 1 of bitmap definitions
10424                                                                          ; 95  = %01011111
10425                                                                          ;
10426                                                                          ; 96  = %01100000     Page 2 of bitmap definitions
10427                                                                          ; 125 = %01111101
10428                                                                          ;
10429                                                                          ; We'll refer to this below
10430               
10431 31F8 020E  20        li   rx,>bf*256                 ; LDX #&BF          ; Set X to point to the first font page in ROM minus 1,
     31FA BF00     
10432                                                                          ; which is &C0 - 1, or &BF
10433               
10434                      .asla                           ; ASL A             ; If bit 6 of the character is clear (A is 32-63)
     **** ****     > ASLA
0001 31FC 024D  22        andi ra,>ff00
     31FE FF00     
0002 3200 0A1D  18        sla  ra,1
                   < elite.a99
10435                      .asla                           ; ASL A             ; then skip the following instruction
     **** ****     > ASLA
0001 3202 024D  22        andi ra,>ff00
     3204 FF00     
0002 3206 0A1D  18        sla  ra,1
                   < elite.a99
10436 3208 1702  14        jnc  B26                        ; BCC B26
10437               
10438 320A 020E  20        li   rx,>c1*256                 ; LDX #&C1          ; A is 64-126, so set X to point to page &C1
     320C C100     
10439               
10440               B26:
10441                      .asla                           ; ASL A             ; If bit 5 of the character is clear (A is 64-95)
     **** ****     > ASLA
0001 320E 024D  22        andi ra,>ff00
     3210 FF00     
0002 3212 0A1D  18        sla  ra,1
                   < elite.a99
10442 3214 1701  14        jnc  B27                        ; BCC B27           ; then skip the following instruction
10443               
10444 3216 B387  18        ab   rone,rx                    ; INX               ; Increment X
10445                                                                          ;
10446                                                                          ; By this point, we started with X = &BF, and then
10447                                                                          ; we did the following:
10448                                                                          ;
10449                                                                          ; If A = 32-63:   skip    then INX  so X = &C0
10450                                                                          ; If A = 64-95:   X = &C1 then skip so X = &C1
10451                                                                          ; If A = 96-126:  X = &C1 then INX  so X = &C2
10452                                                                          ;
10453                                                                          ; In other words, X points to the relevant page. But
10454                                                                          ; what about the value of A? That gets shifted to the
10455                                                                          ; left three times during the above code, which
10456                                                                          ; multiplies the number by 8 but also drops bits 7, 6
10457                                                                          ; and 5 in the process. Look at the above binary
10458                                                                          ; figures and you can see that if we cleared bits 5-7,
10459                                                                          ; then that would change 32-53 to 0-31... but it would
10460                                                                          ; do exactly the same to 64-95 and 96-125. And because
10461                                                                          ; we also multiply this figure by 8, A now points to
10462                                                                          ; the start of the character's definition within its
10463                                                                          ; page (because there are 8 bytes per character
10464                                                                          ; definition)
10465                                                                          ;
10466                                                                          ; Or, to put it another way, X contains the high byte
10467                                                                          ; (the page) of the address of the definition that we
10468                                                                          ; want, while A contains the low byte (the offset into
10469                                                                          ; the page) of the address
10470               
10471               B27:
10472 3218 D80D  30        movb ra,@P+1                    ; STA P+1           ; Store the address of this character's definition in
     321A 001C     
10473 321C D80E  30        movb rx,@P+2                    ; STX P+2           ; P(2 1)
     321E 001D     
10474               
10475 3220 D360  30        movb @XC,ra                     ; LDA XC            ; Fetch XC, the x-coordinate (column) of the text cursor
     3222 002C     
10476                                                                          ; into A
10477               
10478                      .asla                           ; ASL A             ; Multiply A by 8, and store in SC. As each character is
     **** ****     > ASLA
0001 3224 024D  22        andi ra,>ff00
     3226 FF00     
0002 3228 0A1D  18        sla  ra,1
                   < elite.a99
10479                      .asla                           ; ASL A             ; 8 pixels wide, and the special screen mode Elite uses
     **** ****     > ASLA
0001 322A 024D  22        andi ra,>ff00
     322C FF00     
0002 322E 0A1D  18        sla  ra,1
                   < elite.a99
10480                      .asla                           ; ASL A             ; for the top part of the screen is 256 pixels across
     **** ****     > ASLA
0001 3230 024D  22        andi ra,>ff00
     3232 FF00     
0002 3234 0A1D  18        sla  ra,1
                   < elite.a99
10481 3236 D80D  30        movb ra,@SC                     ; STA SC            ; with one bit per pixel, this value is not only the
     3238 0007     
10482                                                                          ; screen address offset of the text cursor from the left
10483                                                                          ; side of the screen, it's also the least significant
10484                                                                          ; byte of the screen address where we want to print this
10485                                                                          ; character, as each row of on-screen pixels corresponds
10486                                                                          ; to one page. To put this more explicitly, the screen
10487                                                                          ; starts at &6000, so the text rows are stored in screen
10488                                                                          ; memory like this:
10489                                                                          ;
10490                                                                          ; Row 1: &6000 - &60FF    YC = 1, XC = 0 to 31
10491                                                                          ; Row 2: &6100 - &61FF    YC = 2, XC = 0 to 31
10492                                                                          ; Row 3: &6200 - &62FF    YC = 3, XC = 0 to 31
10493                                                                          ;
10494                                                                          ; and so on
10495               
10496 323A D360  30        movb @YC,ra                     ; LDA YC            ; Fetch YC, the y-coordinate (row) of the text cursor
     323C 002D     
10497               
10498 323E 028F  22        ci   ry,>7f*256                 ; CPY #127          ; If the character number (which is in Y) <> 127, then
     3240 7F00     
10499 3242 160D  14        jne  RR2                        ; BNE RR2           ; skip to RR2 to print that character, otherwise this is
10500                                                                          ; the delete character, so continue on
10501               
10502 3244 7347  18        sb   rone,ra                    ; DEC XC            ; We want to delete the character to the left of the
10503                                                                          ; text cursor and move the cursor back one, so let's
10504                                                                          ; do that by decrementing YC. Note that this doesn't
10505                                                                          ; have anything to do with the actual deletion below,
10506                                                                          ; we're just updating the cursor so it's in the right
10507                                                                          ; position following the deletion
10508               
10509                      .adi (>5e*256)                  ; ADC #&5E          ; A contains YC (from above) and the C flag is set (from
     **** ****     > ADI
0001 3246 1701  14        jnc  !
0002 3248 B347  18        ab   rone,ra
0003               !:
0004 324A 022D  22        ai   ra,(>5E*256)
     324C 5E00     
                   < elite.a99
10510 324E D38D  18        movb ra,rx                      ; TAX               ; the CPY #127 above), so these instructions do this:
10511                                                                          ;
10512                                                                          ; X = YC + &5E + 1
10513                                                                          ; = YC + &5F
10514               
10515                                                                          ; Because YC starts at 0 for the first text row, this
10516                                                                          ; means that X will be &5F for row 0, &60 for row 1 and
10517                                                                          ; so on. In other words, X is now set to the page number
10518                                                                          ; for the row before the one containing the text cursor,
10519                                                                          ; and given that we set SC above to point to the offset
10520                                                                          ; in memory of the text cursor within the row's page,
10521                                                                          ; this means that (X SC) now points to the character
10522                                                                          ; above the text cursor
10523               
10524 3250 020F  20        li   ry,>f8*256                 ; LDY #&F8          ; Set Y = &F8, so the following call to ZES2 will count
     3252 F800     
10525                                                                          ; Y upwards from &F8 to &FF
10526               
10527 3254 0200  20        li   rtmp,ZES2                  ; JSR ZES2          ; Call ZES2, which zero-fills from address (X SC) + Y to
     3256 C8CE     
10528 3258 06A0  32        bl   @jsr                       ;
     325A FE28     
10529                                                                          ; (X SC) + &FF. (X SC) points to the character above the
10530                                                                          ; text cursor, and adding &FF to this would point to the
10531                                                                          ; cursor, so adding &F8 points to the character before
10532                                                                          ; the cursor, which is the one we want to delete. So
10533                                                                          ; this call zero-fills the character to the left of the
10534                                                                          ; cursor, which erases it from the screen
10535               
10536 325C 1327  14        jeq  RR4                        ; BEQ RR4           ; We are done deleting, so restore the registers and
10537                                                                          ; return from the subroutine (this BNE is effectively
10538                                                                          ; a JMP as ZES2 always returns with the Z flag set)
10539               
10540               RR2:
10541                                                                          ; Now to actually print the character
10542 325E B347  18        ab   rone,ra                    ; INC XC            ; Once we print the character, we want to move the text
10543                                                                          ; cursor to the right, so we do this by incrementing
10544                                                                          ; XC. Note that this doesn't have anything to do
10545                                                                          ; with the actual printing below, we're just updating
10546                                                                          ; the cursor so it's in the right position following
10547                                                                          ; the print
10548               
10549               * LDA YC                 \ This instruction is commented out in the original
10550                                                                          ; source. It isn't required because we only just did a
10551                                                                          ; LDA YC before jumping to RR2, so this is presumably
10552                                                                          ; an example of the authors squeezing the code to save
10553                                                                          ; 2 bytes and 3 cycles
10554                                                                          ;
10555                                                                          ; If you want to re-enable the commented block near the
10556                                                                          ; start of this routine, you should uncomment this
10557                                                                          ; instruction as well
10558               
10559 3260 028D  22        ci   ra,>18*256                 ; CMP #24           ; If the text cursor is on the screen (i.e. YC < 24, so
     3262 1800     
10560 3264 1706  14        jnc  RR3                        ; BCC RR3           ; we are on rows 0-23), then jump to RR3 to print the
10561                                                                          ; character
10562               
10563 3266 0200  20        li   rtmp,TTX66                 ; JSR TTX66         ; Otherwise we are off the bottom of the screen, so
     3268 4BE2     
10564 326A 06A0  32        bl   @jsr                       ;
     326C FE28     
10565                                                                          ; clear the screen and draw a white border
10566               
10567 326E 0460  28        b    @RR4                       ; JMP RR4           ; And restore the registers and return from the
     3270 32AC     
10568                                                                          ; subroutine
10569               
10570               RR3:
10571                                                                          ; A contains the value of YC - the screen row where we
10572                                                                          ; want to print this character - so now we need to
10573                                                                          ; convert this into a screen address, so we can poke
10574                                                                          ; the character data to the right place in screen
10575                                                                          ; memory
10576 3272 026D  22        ori  ra,>60*256                 ; ORA #&60          ; We already stored the least significant byte
     3274 6000     
10577                                                                          ; of this screen address in SC above (see the STA SC
10578                                                                          ; instruction above), so all we need is the most
10579                                                                          ; significant byte. As mentioned above, in Elite's
10580                                                                          ; square mode 4 screen, each row of text on-screen
10581                                                                          ; takes up exactly one page, so the first row is page
10582                                                                          ; &60xx, the second row is page &61xx, so we can get
10583                                                                          ; the page for character (XC, YC) by OR'ing with &60.
10584                                                                          ; To see this in action, consider that our two values
10585                                                                          ; are, in binary:
10586                                                                          ;
10587                                                                          ; YC is between:  %00000000
10588                                                                          ; and:  %00010111
10589                                                                          ; &60 is:  %01100000
10590                                                                          ;
10591                                                                          ; so YC OR &60 effectively adds &60 to YC, giving us
10592                                                                          ; the page number that we want
10593               
10594               RREN:
10595 3276 D80D  30        movb ra,@SC+1                   ; STA SC+1          ; Store the page number of the destination screen
     3278 0008     
10596                                                                          ; location in SC+1, so SC now points to the full screen
10597                                                                          ; location where this character should go
10598               
10599 327A 020F  20        li   ry,>07*256                 ; LDY #7            ; We want to print the 8 bytes of character data to the
     327C 0700     
10600                                                                          ; screen (one byte per row), so set up a counter in Y
10601                                                                          ; to count these bytes
10602               
10603               RRL1:
10604                      .ld_ind_y_idx @P+1,ra           ; LDA (P+1),Y       ; The character definition is at P(2 1) - we set this up
     **** ****     > LD_IND_Y_IDX
0001 327E D820  42        movb @P+1,@rtmplb
     3280 001C     
     3282 8301     
0002 3284 D020  30        movb @P+1+1,rtmp
     3286 001D     
0003 3288 06CF  14        swpb ry
0004 328A A00F  18        a    ry,rtmp
0005 328C 06CF  14        swpb ry
0006 328E D350  26        movb *rtmp,RA
                   < elite.a99
10605                                                                          ; above - so load the Y-th byte from P(2 1), which will
10606                                                                          ; contain the bitmap for the Y-th row of the character
10607               
10608                      .eor @SC                        ; EOR (SC),Y        ; If we EOR this value with the existing screen
     **** ****     > EOR
0001 3290 D020  30        movb @SC,rtmp
     3292 0007     
0002 3294 2B40  18        xor  rtmp,ra
                   < elite.a99
10609                                                                          ; contents, then it's reversible (so reprinting the
10610                                                                          ; same character in the same place will revert the
10611                                                                          ; screen to what it looked like before we printed
10612                                                                          ; anything); this means that printing a white pixel
10613                                                                          ; onto a white background results in a black pixel, but
10614                                                                          ; that's a small price to pay for easily erasable text
10615               
10616                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Store the Y-th byte at the screen address for this
     **** ****     > ST_IND_Y_IDX
0001 3296 D820  42        movb @SC,@rtmplb
     3298 0007     
     329A 8301     
0002 329C D020  30        movb @SC+1,rtmp
     329E 0008     
0003 32A0 06CF  14        swpb ry
0004 32A2 A00F  18        a    ry,rtmp
0005 32A4 06CF  14        swpb ry
0006 32A6 D40D  30        movb RA,*rtmp
                   < elite.a99
10617                                                                          ; character location
10618               
10619 32A8 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
10620               
10621 32AA 15E9  14        jgt  RRL1                       ; BPL RRL1          ; Loop back for the next byte to print to the screen
10622               
10623               RR4:
10624 32AC D3E0  30        movb @YSAV2,ry                  ; LDY YSAV2         ; We're done printing, so restore the values of the
     32AE 0F0F     
10625 32B0 D3A0  30        movb @XSAV2,rx                  ; LDX XSAV2         ; A, X and Y registers that we saved above and clear
     32B2 0F0E     
10626 32B4 D360  30        movb @K3,ra                     ; LDA K3            ; the C flag, so everything is back to how it was
     32B6 00D2     
10627                      .clc                            ; CLC
     **** ****     > CLC
0001 32B8 0A16  18        sla  rzero,1
                   < elite.a99
10628               
10629               rT9:
10630 32BA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     32BC FE34     
10631               
10632               R5_:
10633 32BE 0200  20        li   rtmp,BEEP                  ; JSR BEEP          ; Call the BEEP subroutine to make a short, high beep
     32C0 CC58     
10634 32C2 06A0  32        bl   @jsr                       ;
     32C4 FE28     
10635               
10636 32C6 0460  28        b    @RR4                       ; JMP RR4           ; Jump to RR4 to restore the registers and return from
     32C8 32AC     
10637                                                                          ; the subroutine using a tail call
10638               
10639               * ******************************************************************************
10640               *
10641               * Name: DIALS (Part 1 of 4)
10642               * Type: Subroutine
10643               * Category: Dashboard
10644               * Summary: Update the dashboard: speed indicator
10645               * Deep dive: The dashboard indicators
10646               *
10647               * ------------------------------------------------------------------------------
10648               *
10649               * This routine updates the dashboard. First we draw all the indicators in the
10650               * right part of the dashboard, from top (speed) to bottom (energy banks), and
10651               * then we move on to the left part, again drawing from top (forward shield) to
10652               * bottom (altitude).
10653               *
10654               * This first section starts us off with the speedometer in the top right.
10655               *
10656               * ******************************************************************************
10657               
10658               DIALS:
10659 32CA 020D  20        li   ra,>d0*256                 ; LDA #&D0          ; Set SC(1 0) = &78D0, which is the screen address for
     32CC D000     
10660 32CE D80D  30        movb ra,@SC                     ; STA SC            ; the character block containing the left end of the
     32D0 0007     
10661 32D2 020D  20        li   ra,>78*256                 ; LDA #&78          ; top indicator in the right part of the dashboard, the
     32D4 7800     
10662 32D6 D80D  30        movb ra,@SC+1                   ; STA SC+1          ; one showing our speed
     32D8 0008     
10663               
10664 32DA 0200  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     32DC 345A     
10665 32DE 06A0  32        bl   @jsr                       ;
     32E0 FE28     
10666                                                                          ; and X to the colour for safe values
10667               
10668 32E2 D80E  30        movb rx,@K+1                    ; STX K+1           ; Set K+1 (the colour we should show for low values) to
     32E4 003E     
10669                                                                          ; X (the colour to use for safe values)
10670               
10671 32E6 D80D  30        movb ra,@K                      ; STA K             ; Set K (the colour we should show for high values) to
     32E8 003D     
10672                                                                          ; A (the colour to use for dangerous values)
10673               
10674                                                                          ; The above sets the following indicators to show red
10675                                                                          ; for high values and yellow/white for low values
10676               
10677 32EA 020D  20        li   ra,>0e*256                 ; LDA #14           ; Set T1 to 14, the threshold at which we change the
     32EC 0E00     
10678 32EE D80D  30        movb ra,@T1                     ; STA T1            ; indicator's colour
     32F0 0006     
10679               
10680 32F2 D360  30        movb @DELTA,ra                  ; LDA DELTA         ; Fetch our ship's speed into A, in the range 0-40
     32F4 008C     
10681               
10682               * LSR A                  \ Draw the speed indicator using a range of 0-31, and
10683 32F6 0200  20        li   rtmp,DIL-1                 ; JSR DIL-1         ; increment SC to point to the next indicator (the roll
     32F8 3483     
10684 32FA 06A0  32        bl   @jsr                       ;
     32FC FE28     
10685                                                                          ; indicator). The LSR is commented out as it isn't
10686                                                                          ; required with a call to DIL-1, so perhaps this was
10687                                                                          ; originally a call to DIL that got optimised
10688               
10689               * ******************************************************************************
10690               *
10691               * Name: DIALS (Part 2 of 4)
10692               * Type: Subroutine
10693               * Category: Dashboard
10694               * Summary: Update the dashboard: pitch and roll indicators
10695               * Deep dive: The dashboard indicators
10696               *
10697               * ******************************************************************************
10698               
10699 32FE 020D  20        li   ra,>00*256                 ; LDA #0            ; Set R = P = 0 for the low bytes in the call to the ADD
     3300 0000     
10700 3302 D80D  30        movb ra,@R                      ; STA R             ; routine below
     3304 0091     
10701 3306 D80D  30        movb ra,@P                      ; STA P
     3308 001B     
10702               
10703 330A 020D  20        li   ra,>08*256                 ; LDA #8            ; Set S = 8, which is the value of the centre of the
     330C 0800     
10704 330E D80D  30        movb ra,@S                      ; STA S             ; roll indicator
     3310 0092     
10705               
10706 3312 D360  30        movb @ALP1,ra                   ; LDA ALP1          ; Fetch the roll angle alpha as a value between 0 and
     3314 0087     
10707 3316 091D  18        srl  ra,1                       ; LSR A             ; 31, and divide by 4 to get a value of 0 to 7
10708 3318 091D  18        srl  ra,1                       ; LSR A
10709               
10710 331A F360  30        socb @ALP2,ra                   ; ORA ALP2          ; Apply the roll sign to the value, and flip the sign,
     331C 0088     
10711                      .eoi (>80*256)                  ; EOR #%10000000    ; so it's now in the range -7 to +7, with a positive
     **** ****     > EOI
0001 331E 0200  20        li   rtmp,(>80*256)
     3320 8000     
0002 3322 2B40  18        xor  rtmp,ra
                   < elite.a99
10712                                                                          ; roll angle alpha giving a negative value in A
10713               
10714 3324 0200  20        li   rtmp,ADD                   ; JSR ADD           ; We now add A to S to give us a value in the range 1 to
     3326 456E     
10715 3328 06A0  32        bl   @jsr                       ;
     332A FE28     
10716                                                                          ; 15, which we can pass to DIL2 to draw the vertical
10717                                                                          ; bar on the indicator at this position. We use the ADD
10718                                                                          ; routine like this:
10719                                                                          ;
10720                                                                          ; (A X) = (A 0) + (S 0)
10721                                                                          ;
10722                                                                          ; and just take the high byte of the result. We use ADD
10723                                                                          ; rather than a normal ADC because ADD separates out the
10724                                                                          ; sign bit and does the arithmetic using absolute values
10725                                                                          ; and separate sign bits, which we want here rather than
10726                                                                          ; the two's complement that ADC uses
10727               
10728 332C 0200  20        li   rtmp,DIL2                  ; JSR DIL2          ; Draw a vertical bar on the roll indicator at offset A
     332E 355A     
10729 3330 06A0  32        bl   @jsr                       ;
     3332 FE28     
10730                                                                          ; and increment SC to point to the next indicator (the
10731                                                                          ; pitch indicator)
10732               
10733 3334 D360  30        movb @BETA,ra                   ; LDA BETA          ; Fetch the pitch angle beta as a value between -8 and
     3336 002A     
10734                                                                          ; +8
10735               
10736 3338 D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the magnitude of the pitch angle beta, and if it
     333A 002B     
10737 333C 1304  14        jeq  B28                        ; BEQ B28           ; is 0 (i.e. we are not pitching), skip the next
10738                                                                          ; instruction
10739               
10740                      .sbi (>01*256)                  ; SBC #1            ; The pitch angle beta is non-zero, so set A = A - 1
     **** ****     > SBI
0001 333E 1801  14        joc  !
0002 3340 7347  18        sb   rone,ra
0003               !:
0004 3342 022D  22        ai   ra,-(>01*256)
     3344 FF00     
                   < elite.a99
10741                                                                          ; (the C flag is set by the call to DIL2 above, so we
10742                                                                          ; don't need to do a SEC). This gives us a value of A
10743                                                                          ; from -7 to +7 because these are magnitude-based
10744                                                                          ; numbers with sign bits, rather than two's complement
10745                                                                          ; numbers
10746               
10747               B28:
10748 3346 0200  20        li   rtmp,ADD                   ; JSR ADD           ; We now add A to S to give us a value in the range 1 to
     3348 456E     
10749 334A 06A0  32        bl   @jsr                       ;
     334C FE28     
10750                                                                          ; 15, which we can pass to DIL2 to draw the vertical
10751                                                                          ; bar on the indicator at this position (see the JSR ADD
10752                                                                          ; above for more on this)
10753               
10754 334E 0200  20        li   rtmp,DIL2                  ; JSR DIL2          ; Draw a vertical bar on the pitch indicator at offset A
     3350 355A     
10755 3352 06A0  32        bl   @jsr                       ;
     3354 FE28     
10756                                                                          ; and increment SC to point to the next indicator (the
10757                                                                          ; four energy banks)
10758               
10759               * ******************************************************************************
10760               *
10761               * Name: DIALS (Part 3 of 4)
10762               * Type: Subroutine
10763               * Category: Dashboard
10764               * Summary: Update the dashboard: four energy banks
10765               * Deep dive: The dashboard indicators
10766               *
10767               * ------------------------------------------------------------------------------
10768               *
10769               * This and the next section only run once every four iterations of the main
10770               * loop, so while the speed, pitch and roll indicators update every iteration,
10771               * the other indicators update less often.
10772               *
10773               * ******************************************************************************
10774               
10775 3356 D360  30        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 4,
     3358 0099     
10776 335A 024D  22        andi ra,>03*256                 ; AND #3            ; jumping to rT9 if it is non-zero. rT9 contains an RTS,
     335C 0300     
10777 335E 16AD  14        jne  rT9                        ; BNE rT9           ; so the following code only runs every 4 iterations of
10778                                                                          ; the main loop, otherwise we return from the subroutine
10779               
10780 3360 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0, for use in various places below
     3362 0000     
10781               
10782 3364 0200  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     3366 345A     
10783 3368 06A0  32        bl   @jsr                       ;
     336A FE28     
10784                                                                          ; and X to the colour for safe values
10785               
10786 336C D80E  30        movb rx,@K                      ; STX K             ; Set K (the colour we should show for high values) to X
     336E 003D     
10787                                                                          ; (the colour to use for safe values)
10788               
10789 3370 D80D  30        movb ra,@K+1                    ; STA K+1           ; Set K+1 (the colour we should show for low values) to
     3372 003E     
10790                                                                          ; A (the colour to use for dangerous values)
10791               
10792                                                                          ; The above sets the following indicators to show red
10793                                                                          ; for low values and yellow/white for high values, which
10794                                                                          ; we use not only for the energy banks, but also for the
10795                                                                          ; shield levels and current fuel
10796               
10797 3374 020E  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X so we can zero the four bytes at
     3376 0300     
10798                                                                          ; XX12, so we can then calculate each of the four energy
10799                                                                          ; banks' values before drawing them later
10800               
10801 3378 D80E  30        movb rx,@T1                     ; STX T1            ; Set T1 to 3, the threshold at which we change the
     337A 0006     
10802                                                                          ; indicator's colour
10803               
10804               DLL23:
10805 337C DB8F  38        movb ry,@XX12(rx)               ; STY XX12,X        ; Set the X-th byte of XX12 to 0
     337E 0037     
10806               
10807 3380 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
10808               
10809 3382 15FC  14        jgt  DLL23                      ; BPL DLL23         ; Loop back for the next byte until the four bytes at
10810                                                                          ; XX12 are all zeroed
10811               
10812 3384 020E  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X to loop through the 4 energy
     3386 0300     
10813                                                                          ; bank indicators, so we can calculate each of the four
10814                                                                          ; energy banks' values and store them in XX12
10815               
10816 3388 D360  30        movb @ENERGY,ra                 ; LDA ENERGY        ; Set A = Q = ENERGY / 4, so they are both now in the
     338A 0F13     
10817 338C 091D  18        srl  ra,1                       ; LSR A             ; range 0-63 (so that's a maximum of 16 in each of the
10818 338E 091D  18        srl  ra,1                       ; LSR A             ; banks, and a maximum of 15 in the top bank)
10819               
10820 3390 D80D  30        movb ra,@Q                      ; STA Q             ; Set Q to A, so we can use Q to hold the remaining
     3392 0090     
10821                                                                          ; energy as we work our way through each bank, from the
10822                                                                          ; full ones at the bottom to the empty ones at the top
10823               
10824               DLL24:
10825                      .sec                            ; SEC               ; Set A = A - 16 to reduce the energy count by a full
     **** ****     > SEC
0001 3394 0A18  18        sla  rmone,1
                   < elite.a99
10826                      .sbi (>10*256)                  ; SBC #16           ; bank
     **** ****     > SBI
0001 3396 1801  14        joc  !
0002 3398 7347  18        sb   rone,ra
0003               !:
0004 339A 022D  22        ai   ra,-(>10*256)
     339C F000     
                   < elite.a99
10827               
10828 339E 170B  14        jnc  DLL26                      ; BCC DLL26         ; If the C flag is clear then A < 16, so this bank is
10829                                                                          ; not full to the brim, and is therefore the last one
10830                                                                          ; with any energy in it, so jump to DLL26
10831               
10832 33A0 D80D  30        movb ra,@Q                      ; STA Q             ; This bank is full, so update Q with the energy of the
     33A2 0090     
10833                                                                          ; remaining banks
10834               
10835 33A4 020D  20        li   ra,>10*256                 ; LDA #16           ; Store this bank's level in XX12 as 16, as it is full,
     33A6 1000     
10836 33A8 DB8D  38        movb ra,@XX12(rx)               ; STA XX12,X        ; with XX12+3 for the bottom bank and XX12+0 for the top
     33AA 0037     
10837               
10838 33AC D360  30        movb @Q,ra                      ; LDA Q             ; Set A to the remaining energy level again
     33AE 0090     
10839               
10840 33B0 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to point to the next bank, i.e. the one
10841                                                                          ; above the bank we just processed
10842               
10843 33B2 15F0  14        jgt  DLL24                      ; BPL DLL24         ; Loop back to DLL24 until we have either processed all
10844                                                                          ; four banks, or jumped out early to DLL26 if the top
10845                                                                          ; banks have no charge
10846               
10847 33B4 1104  14        jlt  DLL9                       ; BMI DLL9          ; Jump to DLL9 as we have processed all four banks (this
10848                                                                          ; BMI is effectively a JMP as A will never be positive)
10849               
10850               DLL26:
10851 33B6 D360  30        movb @Q,ra                      ; LDA Q             ; If we get here then the bank we just checked is not
     33B8 0090     
10852 33BA DB8D  38        movb ra,@XX12(rx)               ; STA XX12,X        ; fully charged, so store its value in XX12 (using Q,
     33BC 0037     
10853                                                                          ; which contains the energy of the remaining banks -
10854                                                                          ; i.e. this one)
10855               
10856                                                                          ; Now that we have the four energy bank values in XX12,
10857                                                                          ; we can draw them, starting with the top bank in XX12
10858                                                                          ; and looping down to the bottom bank in XX12+3, using Y
10859                                                                          ; as a loop counter, which was set to 0 above
10860               
10861               DLL9:
10862 33BE D36F  34        movb @XX12(ry),ra               ; LDA XX12,Y        ; Fetch the value of the Y-th indicator, starting from
     33C0 0037     
10863                                                                          ; the top
10864               
10865 33C2 D80F  30        movb ry,@P                      ; STY P             ; Store the indicator number in P for retrieval later
     33C4 001B     
10866               
10867 33C6 0200  20        li   rtmp,DIL                   ; JSR DIL           ; Draw the energy bank using a range of 0-15, and
     33C8 3484     
10868 33CA 06A0  32        bl   @jsr                       ;
     33CC FE28     
10869                                                                          ; increment SC to point to the next indicator (the
10870                                                                          ; next energy bank down)
10871               
10872 33CE D3E0  30        movb @P,ry                      ; LDY P             ; Restore the indicator number into Y
     33D0 001B     
10873               
10874 33D2 B3C7  18        ab   rone,ry                    ; INY               ; Increment the indicator number
10875               
10876 33D4 028F  22        ci   ry,>04*256                 ; CPY #4            ; Check to see if we have drawn the last energy bank
     33D6 0400     
10877               
10878 33D8 16F2  14        jne  DLL9                       ; BNE DLL9          ; Loop back to DLL9 if we have more banks to draw,
10879                                                                          ; otherwise we are done
10880               
10881               * ******************************************************************************
10882               *
10883               * Name: DIALS (Part 4 of 4)
10884               * Type: Subroutine
10885               * Category: Dashboard
10886               * Summary: Update the dashboard: shields, fuel, laser & cabin temp, altitude
10887               * Deep dive: The dashboard indicators
10888               *
10889               * ******************************************************************************
10890               
10891 33DA 020D  20        li   ra,>78*256                 ; LDA #&78          ; Set SC(1 0) = &7810, which is the screen address for
     33DC 7800     
10892 33DE D80D  30        movb ra,@SC+1                   ; STA SC+1          ; the character block containing the left end of the
     33E0 0008     
10893 33E2 020D  20        li   ra,>10*256                 ; LDA #&10          ; top indicator in the left part of the dashboard, the
     33E4 1000     
10894 33E6 D80D  30        movb ra,@SC                     ; STA SC            ; one showing the forward shield
     33E8 0007     
10895               
10896 33EA D360  30        movb @FSH,ra                    ; LDA FSH           ; Draw the forward shield indicator using a range of
     33EC 0F11     
10897 33EE 0200  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     33F0 347C     
10898 33F2 06A0  32        bl   @jsr                       ;
     33F4 FE28     
10899                                                                          ; (the aft shield)
10900               
10901 33F6 D360  30        movb @ASH,ra                    ; LDA ASH           ; Draw the aft shield indicator using a range of 0-255,
     33F8 0F12     
10902 33FA 0200  20        li   rtmp,DILX                  ; JSR DILX          ; and increment SC to point to the next indicator (the
     33FC 347C     
10903 33FE 06A0  32        bl   @jsr                       ;
     3400 FE28     
10904                                                                          ; fuel level)
10905               
10906 3402 D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Draw the fuel level indicator using a range of 0-63,
     3404 030D     
10907 3406 0200  20        li   rtmp,DILX+2                ; JSR DILX+2        ; and increment SC to point to the next indicator (the
     3408 347E     
10908 340A 06A0  32        bl   @jsr                       ;
     340C FE28     
10909                                                                          ; cabin temperature)
10910               
10911 340E 0200  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     3410 345A     
10912 3412 06A0  32        bl   @jsr                       ;
     3414 FE28     
10913                                                                          ; and X to the colour for safe values
10914               
10915 3416 D80E  30        movb rx,@K+1                    ; STX K+1           ; Set K+1 (the colour we should show for low values) to
     3418 003E     
10916                                                                          ; X (the colour to use for safe values)
10917               
10918 341A D80D  30        movb ra,@K                      ; STA K             ; Set K (the colour we should show for high values) to
     341C 003D     
10919                                                                          ; A (the colour to use for dangerous values)
10920               
10921                                                                          ; The above sets the following indicators to show red
10922                                                                          ; for high values and yellow/white for low values, which
10923                                                                          ; we use for the cabin and laser temperature bars
10924               
10925 341E 020E  20        li   rx,>0b*256                 ; LDX #11           ; Set T1 to 11, the threshold at which we change the
     3420 0B00     
10926 3422 D80E  30        movb rx,@T1                     ; STX T1            ; cabin and laser temperature indicators' colours
     3424 0006     
10927               
10928 3426 D360  30        movb @CABTMP,ra                 ; LDA CABTMP        ; Draw the cabin temperature indicator using a range of
     3428 0D4D     
10929 342A 0200  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     342C 347C     
10930 342E 06A0  32        bl   @jsr                       ;
     3430 FE28     
10931                                                                          ; (the laser temperature)
10932               
10933 3432 D360  30        movb @GNTMP,ra                  ; LDA GNTMP         ; Draw the laser temperature indicator using a range of
     3434 0D61     
10934 3436 0200  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     3438 347C     
10935 343A 06A0  32        bl   @jsr                       ;
     343C FE28     
10936                                                                          ; (the altitude)
10937               
10938 343E 020D  20        li   ra,>f0*256                 ; LDA #240          ; Set T1 to 240, the threshold at which we change the
     3440 F000     
10939 3442 D80D  30        movb ra,@T1                     ; STA T1            ; altitude indicator's colour. As the altitude has a
     3444 0006     
10940                                                                          ; range of 0-255, pixel 16 will not be filled in, and
10941                                                                          ; 240 would change the colour when moving between pixels
10942                                                                          ; 15 and 16, so this effectively switches off the colour
10943                                                                          ; change for the altitude indicator
10944               
10945 3446 D80D  30        movb ra,@K+1                    ; STA K+1           ; Set K+1 (the colour we should show for low values) to
     3448 003E     
10946                                                                          ; 240, or &F0 (dashboard colour 2, yellow/white), so the
10947                                                                          ; altitude indicator always shows in this colour
10948               
10949 344A D360  30        movb @ALTIT,ra                  ; LDA ALTIT         ; Draw the altitude indicator using a range of 0-255
     344C 0F21     
10950 344E 0200  20        li   rtmp,DILX                  ; JSR DILX
     3450 347C     
10951 3452 06A0  32        bl   @jsr                       ;
     3454 FE28     
10952               
10953 3456 0460  28        b    @COMPAS                    ; JMP COMPAS        ; We have now drawn all the indicators, so jump to
     3458 AD36     
10954                                                                          ; COMPAS to draw the compass, returning from the
10955                                                                          ; subroutine using a tail call
10956               
10957               * ******************************************************************************
10958               *
10959               * Name: PZW
10960               * Type: Subroutine
10961               * Category: Dashboard
10962               * Summary: Fetch the current dashboard colours, to support flashing
10963               *
10964               * ------------------------------------------------------------------------------
10965               *
10966               * Set A and X to the colours we should use for indicators showing dangerous and
10967               * safe values respectively. This enables us to implement flashing indicators,
10968               * which is one of the game's configurable options.
10969               *
10970               * If flashing is enabled, the colour returned in A (dangerous values) will be
10971               * red for 8 iterations of the main loop, and yellow/white for the next 8, before
10972               * going back to red. If we always use PZW to decide which colours we should use
10973               * when updating indicators, flashing colours will be automatically taken care of
10974               * for us.
10975               *
10976               * The values returned are &F0 for yellow/white and &0F for red. These are mode 5
10977               * bytes that contain 4 pixels, with the colour of each pixel given in two bits,
10978               * the high bit from the first nibble (bits 4-7) and the low bit from the second
10979               * nibble (bits 0-3). So in &F0 each pixel is %10, or colour 2 (yellow or white,
10980               * depending on the dashboard palette), while in &0F each pixel is %01, or colour
10981               * 1 (red).
10982               *
10983               * ------------------------------------------------------------------------------
10984               *
10985               * Returns:
10986               *
10987               * A                   The colour to use for indicators with dangerous values
10988               *
10989               * X                   The colour to use for indicators with safe values
10990               *
10991               * ******************************************************************************
10992               
10993               PZW:
10994 345A 020E  20        li   rx,>f0*256                 ; LDX #&F0          ; Set X to dashboard colour 2 (yellow/white)
     345C F000     
10995               
10996 345E D360  30        movb @MCNT,ra                   ; LDA MCNT          ; A will be non-zero for 8 out of every 16 main loop
     3460 0099     
10997 3462 024D  22        andi ra,>08*256                 ; AND #%00001000    ; counts, when bit 4 is set, so this is what we use to
     3464 0800     
10998                                                                          ; flash the "danger" colour
10999               
11000                      .and @FLH                       ; AND FLH           ; A will be zeroed if flashing colours are disabled
     **** ****     > AND
0001 3466 D020  30        movb @FLH,rtmp
     3468 0F4D     
0002 346A 0540  14        inv  rtmp
0003 346C 5340  18        szcb rtmp,ra
                   < elite.a99
11001               
11002 346E 1302  14        jeq  B29                        ; BEQ B29           ; If A is zero, skip to the LDA instruction below
11003               
11004 3470 D34E  18        movb rx,ra                      ; TXA               ; Otherwise flashing colours are enabled and it's the
11005                                                                          ; main loop iteration where we flash them, so set A to
11006                                                                          ; colour 2 (yellow/white) and use the BIT trick below to
11007                                                                          ; return from the subroutine
11008               
11009 3472 2C              byte >2c                                            ; Skip the next instruction by turning it into
11010                                                                          ; &2C &A9 &0F, or BIT &0FA9, which does nothing apart
11011                                                                          ; from affect the flags
11012               
11013               B29:
11014 3474 020D  20        li   ra,>0f*256                 ; LDA #&0F          ; Set A to dashboard colour 1 (red)
     3476 0F00     
11015               
11016 3478 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     347A FE34     
11017               
11018               * ******************************************************************************
11019               *
11020               * Name: DILX
11021               * Type: Subroutine
11022               * Category: Dashboard
11023               * Summary: Update a bar-based indicator on the dashboard
11024               * Deep dive: The dashboard indicators
11025               *
11026               * ------------------------------------------------------------------------------
11027               *
11028               * The range of values shown on the indicator depends on which entry point is
11029               * called. For the default entry point of DILX, the range is 0-255 (as the value
11030               * passed in A is one byte). The other entry points are shown below.
11031               *
11032               * ------------------------------------------------------------------------------
11033               *
11034               * Arguments:
11035               *
11036               * A                   The value to be shown on the indicator (so the larger
11037               * the value, the longer the bar)
11038               *
11039               * T1                  The threshold at which we change the indicator's colour
11040               * from the low value colour to the high value colour. The
11041               * threshold is in pixels, so it should have a value from
11042               * 0-16, as each bar indicator is 16 pixels wide
11043               *
11044               * K                   The colour to use when A is a high value, as a 4-pixel
11045               * mode 5 character row byte
11046               *
11047               * K+1                 The colour to use when A is a low value, as a 4-pixel
11048               * mode 5 character row byte
11049               *
11050               * SC(1 0)             The screen address of the first character block in the
11051               * indicator
11052               *
11053               * ------------------------------------------------------------------------------
11054               *
11055               * Other entry points:
11056               *
11057               * DILX+2              The range of the indicator is 0-64 (for the fuel
11058               * indicator)
11059               *
11060               * DIL-1               The range of the indicator is 0-32 (for the speed
11061               * indicator)
11062               *
11063               * DIL                 The range of the indicator is 0-16 (for the energy
11064               * banks)
11065               *
11066               * ******************************************************************************
11067               
11068               DILX:
11069 347C 091D  18        srl  ra,1                       ; LSR A             ; If we call DILX, we set A = A / 16, so A is 0-15
11070 347E 091D  18        srl  ra,1                       ; LSR A
11071               
11072 3480 091D  18        srl  ra,1                       ; LSR A             ; If we call DILX+2, we set A = A / 4, so A is 0-15
11073               
11074 3482 091D  18        srl  ra,1                       ; LSR A             ; If we call DIL-1, we set A = A / 2, so A is 0-15
11075               
11076               DIL:
11077                                                                          ; If we call DIL, we leave A alone, so A is 0-15
11078 3484 D80D  30        movb ra,@Q                      ; STA Q             ; Store the indicator value in Q, now reduced to 0-15,
     3486 0090     
11079                                                                          ; which is the length of the indicator to draw in pixels
11080               
11081 3488 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set R = &FF, to use as a mask for drawing each row of
     348A FF00     
11082 348C D80E  30        movb rx,@R                      ; STX R             ; each character block of the bar, starting with a full
     348E 0091     
11083                                                                          ; character's width of 4 pixels
11084               
11085 3490 9360  30        cb   @T1,ra                     ; CMP T1            ; If A >= T1 then we have passed the threshold where we
     3492 0006     
11086 3494 1803  14        joc  DL30                       ; BCS DL30          ; change bar colour, so jump to DL30 to set A to the
11087                                                                          ; "high value" colour
11088               
11089 3496 D360  30        movb @K+1,ra                    ; LDA K+1           ; Set A to K+1, the "low value" colour to use
     3498 003E     
11090               
11091 349A 1602  14        jne  DL31                       ; BNE DL31          ; Jump down to DL31 (this BNE is effectively a JMP as A
11092                                                                          ; will never be zero)
11093               
11094               DL30:
11095 349C D360  30        movb @K,ra                      ; LDA K             ; Set A to K, the "high value" colour to use
     349E 003D     
11096               
11097               DL31:
11098 34A0 D80D  30        movb ra,@COL                    ; STA COL           ; Store the colour of the indicator in COL
     34A2 00A2     
11099               
11100 34A4 020F  20        li   ry,>02*256                 ; LDY #2            ; We want to start drawing the indicator on the third
     34A6 0200     
11101                                                                          ; line in this character row, so set Y to point to that
11102                                                                          ; row's offset
11103               
11104 34A8 020E  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X for the width of the indicator,
     34AA 0300     
11105                                                                          ; which is 4 characters (each of which is 4 pixels wide,
11106                                                                          ; to give a total width of 16 pixels)
11107               
11108               DL1:
11109 34AC D360  30        movb @Q,ra                      ; LDA Q             ; Fetch the indicator value (0-15) from Q into A
     34AE 0090     
11110               
11111 34B0 028D  22        ci   ra,>04*256                 ; CMP #4            ; If Q < 4, then we need to draw the end cap of the
     34B2 0400     
11112 34B4 1733  14        jnc  DL2                        ; BCC DL2           ; indicator, which is less than a full character's
11113                                                                          ; width, so jump down to DL2 to do this
11114               
11115                      .sbi (>04*256)                  ; SBC #4            ; Otherwise we can draw a 4-pixel wide block, so
     **** ****     > SBI
0001 34B6 1801  14        joc  !
0002 34B8 7347  18        sb   rone,ra
0003               !:
0004 34BA 022D  22        ai   ra,-(>04*256)
     34BC FC00     
                   < elite.a99
11116 34BE D80D  30        movb ra,@Q                      ; STA Q             ; subtract 4 from Q so it contains the amount of the
     34C0 0090     
11117                                                                          ; indicator that's left to draw after this character
11118               
11119 34C2 D360  30        movb @R,ra                      ; LDA R             ; Fetch the shape of the indicator row that we need to
     34C4 0091     
11120                                                                          ; display from R, so we can use it as a mask when
11121                                                                          ; painting the indicator. It will be &FF at this point
11122                                                                          ; (i.e. a full 4-pixel row)
11123               
11124               DL5:
11125                      .and @COL                       ; AND COL           ; Fetch the 4-pixel mode 5 colour byte from COL, and
     **** ****     > AND
0001 34C6 D020  30        movb @COL,rtmp
     34C8 00A2     
0002 34CA 0540  14        inv  rtmp
0003 34CC 5340  18        szcb rtmp,ra
                   < elite.a99
11126                                                                          ; only keep pixels that have their equivalent bits set
11127                                                                          ; in the mask byte in A
11128               
11129                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the shape of the mask on pixel row Y of the
     **** ****     > ST_IND_Y_IDX
0001 34CE D820  42        movb @SC,@rtmplb
     34D0 0007     
     34D2 8301     
0002 34D4 D020  30        movb @SC+1,rtmp
     34D6 0008     
0003 34D8 06CF  14        swpb ry
0004 34DA A00F  18        a    ry,rtmp
0005 34DC 06CF  14        swpb ry
0006 34DE D40D  30        movb RA,*rtmp
                   < elite.a99
11130                                                                          ; character block we are processing
11131               
11132 34E0 B3C7  18        ab   rone,ry                    ; INY               ; Draw the next pixel row, incrementing Y
11133                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 34E2 D820  42        movb @SC,@rtmplb
     34E4 0007     
     34E6 8301     
0002 34E8 D020  30        movb @SC+1,rtmp
     34EA 0008     
0003 34EC 06CF  14        swpb ry
0004 34EE A00F  18        a    ry,rtmp
0005 34F0 06CF  14        swpb ry
0006 34F2 D40D  30        movb RA,*rtmp
                   < elite.a99
11134               
11135 34F4 B3C7  18        ab   rone,ry                    ; INY               ; And draw the third pixel row, incrementing Y
11136                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 34F6 D820  42        movb @SC,@rtmplb
     34F8 0007     
     34FA 8301     
0002 34FC D020  30        movb @SC+1,rtmp
     34FE 0008     
0003 3500 06CF  14        swpb ry
0004 3502 A00F  18        a    ry,rtmp
0005 3504 06CF  14        swpb ry
0006 3506 D40D  30        movb RA,*rtmp
                   < elite.a99
11137               
11138 3508 D34F  18        movb ry,ra                      ; TYA               ; Add 6 to Y, so Y is now 8 more than when we started
11139                      .clc                            ; CLC               ; this loop iteration, so Y now points to the address
     **** ****     > CLC
0001 350A 0A16  18        sla  rzero,1
                   < elite.a99
11140                      .adi (>06*256)                  ; ADC #6            ; of the first line of the indicator bar in the next
     **** ****     > ADI
0001 350C 1701  14        jnc  !
0002 350E B347  18        ab   rone,ra
0003               !:
0004 3510 022D  22        ai   ra,(>06*256)
     3512 0600     
                   < elite.a99
11141 3514 D3CD  18        movb ra,ry                      ; TAY               ; character block (as each character is 8 bytes of
11142                                                                          ; screen memory)
11143               
11144 3516 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter for the next character
11145                                                                          ; block along in the indicator
11146               
11147 3518 111D  14        jlt  DL6                        ; BMI DL6           ; If we just drew the last character block then we are
11148                                                                          ; done drawing, so jump down to DL6 to finish off
11149               
11150 351A 15C8  14        jgt  DL1                        ; BPL DL1           ; Loop back to DL1 to draw the next character block of
11151                                                                          ; the indicator (this BPL is effectively a JMP as A will
11152                                                                          ; never be negative following the previous BMI)
11153               
11154               DL2:
11155                      .eoi (>03*256)                  ; EOR #3            ; If we get here then we are drawing the indicator's
     **** ****     > EOI
0001 351C 0200  20        li   rtmp,(>03*256)
     351E 0300     
0002 3520 2B40  18        xor  rtmp,ra
                   < elite.a99
11156 3522 D80D  30        movb ra,@Q                      ; STA Q             ; end cap, so Q is < 4, and this EOR flips the bits, so
     3524 0090     
11157                                                                          ; instead of containing the number of indicator columns
11158                                                                          ; we need to fill in on the left side of the cap's
11159                                                                          ; character block, Q now contains the number of blank
11160                                                                          ; columns there should be on the right side of the cap's
11161                                                                          ; character block
11162               
11163 3526 D360  30        movb @R,ra                      ; LDA R             ; Fetch the current mask from R, which will be &FF at
     3528 0091     
11164                                                                          ; this point, so we need to turn Q of the columns on the
11165                                                                          ; right side of the mask to black to get the correct end
11166                                                                          ; cap shape for the indicator
11167               
11168               DL3:
11169                      .asla                           ; ASL A             ; Shift the mask left so bit 0 is cleared, and then
     **** ****     > ASLA
0001 352A 024D  22        andi ra,>ff00
     352C FF00     
0002 352E 0A1D  18        sla  ra,1
                   < elite.a99
11170 3530 024D  22        andi ra,>ef*256                 ; AND #%11101111    ; clear bit 4, which has the effect of shifting zeroes
     3532 EF00     
11171                                                                          ; from the left into each nibble (i.e. xxxx xxxx becomes
11172                                                                          ; xxx0 xxx0, which blanks out the last column in the
11173                                                                          ; 4-pixel mode 5 character block)
11174               
11175 3534 7347  18        sb   rone,ra                    ; DEC Q             ; Decrement the counter for the number of columns to
11176                                                                          ; blank out
11177               
11178 3536 15F9  14        jgt  DL3                        ; BPL DL3           ; If we still have columns to blank out in the mask,
11179                                                                          ; loop back to DL3 until the mask is correct for the
11180                                                                          ; end cap
11181               
11182                      .pha                            ; PHA               ; Store the mask byte on the stack while we use the
     **** ****     > PHA
0001 3538 D68D  30        movb ra,*rsp
0002 353A 060A  14        dec  rsp
                   < elite.a99
11183                                                                          ; accumulator for a bit
11184               
11185 353C 020D  20        li   ra,>00*256                 ; LDA #0            ; Change the mask so no bits are set, so the characters
     353E 0000     
11186 3540 D80D  30        movb ra,@R                      ; STA R             ; after the one we're about to draw will be all blank
     3542 0091     
11187               
11188 3544 020D  20        li   ra,>63*256                 ; LDA #99           ; Set Q to a high number (99, why not) so we will keep
     3546 6300     
11189 3548 D80D  30        movb ra,@Q                      ; STA Q             ; drawing blank characters until we reach the end of
     354A 0090     
11190                                                                          ; the indicator row
11191               
11192                      .pla                            ; PLA               ; Restore the mask byte from the stack so we can use it
     **** ****     > PLA
0001 354C 058A  14        inc  rsp
0002 354E D35A  26        movb *rsp,ra
                   < elite.a99
11193                                                                          ; to draw the end cap of the indicator
11194               
11195 3550 0460  28        b    @DL5                       ; JMP DL5           ; Jump back up to DL5 to draw the mask byte on-screen
     3552 34C6     
11196               
11197               DL6:
11198 3554 B347  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of SC to point to the next
11199                                                                          ; character row on-screen (as each row takes up exactly
11200                                                                          ; one page of 256 bytes) - so this sets up SC to point
11201                                                                          ; to the next indicator, i.e. the one below the one we
11202                                                                          ; just drew
11203               
11204               DL9:
11205 3556 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3558 FE34     
11206               
11207               * ******************************************************************************
11208               *
11209               * Name: DIL2
11210               * Type: Subroutine
11211               * Category: Dashboard
11212               * Summary: Update the roll or pitch indicator on the dashboard
11213               * Deep dive: The dashboard indicators
11214               *
11215               * ------------------------------------------------------------------------------
11216               *
11217               * The indicator can show a vertical bar in 16 positions, with a value of 8
11218               * showing the bar in the middle of the indicator.
11219               *
11220               * In practice this routine is only ever called with A in the range 1 to 15, so
11221               * the vertical bar never appears in the leftmost position (though it does appear
11222               * in the rightmost).
11223               *
11224               * ------------------------------------------------------------------------------
11225               *
11226               * Arguments:
11227               *
11228               * A                   The offset of the vertical bar to show in the indicator,
11229               * from 0 at the far left, to 8 in the middle, and 15 at
11230               * the far right
11231               *
11232               * ------------------------------------------------------------------------------
11233               *
11234               * Returns:
11235               *
11236               * C flag              The C flag is set
11237               *
11238               * ******************************************************************************
11239               
11240               DIL2:
11241 355A 020F  20        li   ry,>01*256                 ; LDY #1            ; We want to start drawing the vertical indicator bar on
     355C 0100     
11242                                                                          ; the second line in the indicator's character block, so
11243                                                                          ; set Y to point to that row's offset
11244               
11245 355E D80D  30        movb ra,@Q                      ; STA Q             ; Store the offset of the vertical bar to draw in Q
     3560 0090     
11246               
11247                                                                          ; We are now going to work our way along the indicator
11248                                                                          ; on the dashboard, from left to right, working our way
11249                                                                          ; along one character block at a time. Y will be used as
11250                                                                          ; a pixel row counter to work our way through the
11251                                                                          ; character blocks, so each time we draw a character
11252                                                                          ; block, we will increment Y by 8 to move on to the next
11253                                                                          ; block (as each character block contains 8 rows)
11254               
11255               DLL10:
11256                      .sec                            ; SEC               ; Set A = Q - 4, so that A contains the offset of the
     **** ****     > SEC
0001 3562 0A18  18        sla  rmone,1
                   < elite.a99
11257 3564 D360  30        movb @Q,ra                      ; LDA Q             ; vertical bar from the start of this character block
     3566 0090     
11258                      .sbi (>04*256)                  ; SBC #4
     **** ****     > SBI
0001 3568 1801  14        joc  !
0002 356A 7347  18        sb   rone,ra
0003               !:
0004 356C 022D  22        ai   ra,-(>04*256)
     356E FC00     
                   < elite.a99
11259               
11260 3570 180B  14        joc  DLL11                      ; BCS DLL11         ; If Q >= 4 then the character block we are drawing does
11261                                                                          ; not contain the vertical indicator bar, so jump to
11262                                                                          ; DLL11 to draw a blank character block
11263               
11264 3572 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to a high number (and &FF is as high as they go)
     3574 FF00     
11265               
11266 3576 D3A0  30        movb @Q,rx                      ; LDX Q             ; Set X to the offset of the vertical bar, which we know
     3578 0090     
11267                                                                          ; is within this character block
11268               
11269 357A D80D  30        movb ra,@Q                      ; STA Q             ; Set Q to a high number (&FF, why not) so we will keep
     357C 0090     
11270                                                                          ; drawing blank characters after this one until we reach
11271                                                                          ; the end of the indicator row
11272               
11273 357E D36E  34        movb @CTWOS(rx),ra              ; LDA CTWOS,X       ; CTWOS is a table of ready-made 1-pixel mode 5 bytes,
     3580 226D     
11274                                                                          ; just like the TWOS and TWOS2 tables for mode 4 (see
11275                                                                          ; the PIXEL routine for details of how they work). This
11276                                                                          ; fetches a mode 5 1-pixel byte with the pixel position
11277                                                                          ; at X, so the pixel is at the offset that we want for
11278                                                                          ; our vertical bar
11279               
11280 3582 024D  22        andi ra,>f0*256                 ; AND #&F0          ; The 4-pixel mode 5 colour byte &F0 represents four
     3584 F000     
11281                                                                          ; pixels of colour %10 (3), which is yellow in the
11282                                                                          ; normal dashboard palette and white if we have an
11283                                                                          ; escape pod fitted. We AND this with A so that we only
11284                                                                          ; keep the pixel that matches the position of the
11285                                                                          ; vertical bar (i.e. A is acting as a mask on the
11286                                                                          ; 4-pixel colour byte)
11287               
11288 3586 1604  14        jne  DLL12                      ; BNE DLL12         ; Jump to DLL12 to skip the code for drawing a blank,
11289                                                                          ; and move on to drawing the indicator (this BNE is
11290                                                                          ; effectively a JMP as A is always non-zero)
11291               
11292               DLL11:
11293                                                                          ; If we get here then we want to draw a blank for this
11294                                                                          ; character block
11295 3588 D80D  30        movb ra,@Q                      ; STA Q             ; Update Q with the new offset of the vertical bar, so
     358A 0090     
11296                                                                          ; it becomes the offset after the character block we
11297                                                                          ; are about to draw
11298               
11299 358C 020D  20        li   ra,>00*256                 ; LDA #0            ; Change the mask so no bits are set, so all of the
     358E 0000     
11300                                                                          ; character blocks we display from now on will be blank
11301               DLL12:
11302                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the shape of the mask on pixel row Y of the
     **** ****     > ST_IND_Y_IDX
0001 3590 D820  42        movb @SC,@rtmplb
     3592 0007     
     3594 8301     
0002 3596 D020  30        movb @SC+1,rtmp
     3598 0008     
0003 359A 06CF  14        swpb ry
0004 359C A00F  18        a    ry,rtmp
0005 359E 06CF  14        swpb ry
0006 35A0 D40D  30        movb RA,*rtmp
                   < elite.a99
11303                                                                          ; character block we are processing
11304               
11305 35A2 B3C7  18        ab   rone,ry                    ; INY               ; Draw the next pixel row, incrementing Y
11306                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 35A4 D820  42        movb @SC,@rtmplb
     35A6 0007     
     35A8 8301     
0002 35AA D020  30        movb @SC+1,rtmp
     35AC 0008     
0003 35AE 06CF  14        swpb ry
0004 35B0 A00F  18        a    ry,rtmp
0005 35B2 06CF  14        swpb ry
0006 35B4 D40D  30        movb RA,*rtmp
                   < elite.a99
11307               
11308 35B6 B3C7  18        ab   rone,ry                    ; INY               ; And draw the third pixel row, incrementing Y
11309                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 35B8 D820  42        movb @SC,@rtmplb
     35BA 0007     
     35BC 8301     
0002 35BE D020  30        movb @SC+1,rtmp
     35C0 0008     
0003 35C2 06CF  14        swpb ry
0004 35C4 A00F  18        a    ry,rtmp
0005 35C6 06CF  14        swpb ry
0006 35C8 D40D  30        movb RA,*rtmp
                   < elite.a99
11310               
11311 35CA B3C7  18        ab   rone,ry                    ; INY               ; And draw the fourth pixel row, incrementing Y
11312                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 35CC D820  42        movb @SC,@rtmplb
     35CE 0007     
     35D0 8301     
0002 35D2 D020  30        movb @SC+1,rtmp
     35D4 0008     
0003 35D6 06CF  14        swpb ry
0004 35D8 A00F  18        a    ry,rtmp
0005 35DA 06CF  14        swpb ry
0006 35DC D40D  30        movb RA,*rtmp
                   < elite.a99
11313               
11314 35DE D34F  18        movb ry,ra                      ; TYA               ; Add 5 to Y, so Y is now 8 more than when we started
11315                      .clc                            ; CLC               ; this loop iteration, so Y now points to the address
     **** ****     > CLC
0001 35E0 0A16  18        sla  rzero,1
                   < elite.a99
11316                      .adi (>05*256)                  ; ADC #5            ; of the first line of the indicator bar in the next
     **** ****     > ADI
0001 35E2 1701  14        jnc  !
0002 35E4 B347  18        ab   rone,ra
0003               !:
0004 35E6 022D  22        ai   ra,(>05*256)
     35E8 0500     
                   < elite.a99
11317 35EA D3CD  18        movb ra,ry                      ; TAY               ; character block (as each character is 8 bytes of
11318                                                                          ; screen memory)
11319               
11320 35EC 028F  22        ci   ry,>1e*256                 ; CPY #30           ; If Y < 30 then we still have some more character
     35EE 1E00     
11321 35F0 17B8  14        jnc  DLL10                      ; BCC DLL10         ; blocks to draw, so loop back to DLL10 to display the
11322                                                                          ; next one along
11323               
11324 35F2 B347  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of SC to point to the next
11325                                                                          ; character row on-screen (as each row takes up exactly
11326                                                                          ; one page of 256 bytes) - so this sets up SC to point
11327                                                                          ; to the next indicator, i.e. the one below the one we
11328                                                                          ; just drew
11329               
11330 35F4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     35F6 FE34     
11331               
11332               * ******************************************************************************
11333               *
11334               * Name: TVT1
11335               * Type: Variable
11336               * Category: Drawing the screen
11337               * Summary: Palette data for space and the two dashboard colour schemes
11338               *
11339               * ------------------------------------------------------------------------------
11340               *
11341               * Palette bytes for use with the split-screen mode (see IRQ1 below for more
11342               * details).
11343               *
11344               * Palette data is given as a set of bytes, with each byte mapping a logical
11345               * colour to a physical one. In each byte, the logical colour is given in bits
11346               * 4-7 and the physical colour in bits 0-3. See p.379 of the Advanced User Guide
11347               * for details of how palette mapping works, as in modes 4 and 5 we have to do
11348               * multiple palette commands to change the colours correctly, and the physical
11349               * colour value is EOR'd with 7, just to make things even more confusing.
11350               *
11351               * Similarly, the palette at TVT1+16 is for the monochrome space view, where
11352               * logical colour 1 is mapped to physical colour 0 EOR 7 = 7 (white), and
11353               * logical colour 0 is mapped to physical colour 7 EOR 7 = 0 (black). Each of
11354               * these mappings requires six calls to SHEILA &21 - see p.379 of the Advanced
11355               * User Guide for an explanation.
11356               *
11357               * The mode 5 palette table has two blocks which overlap. The block used depends
11358               * on whether or not we have an escape pod fitted. The block at TVT1 is used for
11359               * the standard dashboard colours, while TVT1+8 is used for the dashboard when an
11360               * escape pod is fitted. The colours are as follows:
11361               *
11362               * Normal (TVT1)     Escape pod (TVT1+8)
11363               *
11364               * Colour 0      Black             Black
11365               * Colour 1      Red               Red
11366               * Colour 2      Yellow            White
11367               * Colour 3      Green             Cyan
11368               *
11369               * ******************************************************************************
11370               
11371               TVT1:
11372 35F8 D4C4            byte >d4,>c4                                        ; This block of palette data is used to create two
11373 35FA 9484            byte >94,>84                                        ; palettes used in three different places, all of them
11374 35FC F5E5            byte >f5,>e5                                        ; redefining four colours in mode 5:
11375 35FE B5A5            byte >b5,>a5                                        ;
11376                                                                          ; 12 bytes from TVT1 (i.e. the first 6 rows): applied
11377 3600 7666            byte >76,>66                                        ; when the T1 timer runs down at the switch from the
11378 3602 3626            byte >36,>26                                        ; space view to the dashboard, so this is the standard
11379                                                                          ; dashboard palette
11380 3604 E1F1            byte >e1,>f1                                        ;
11381 3606 B1A1            byte >b1,>a1                                        ; 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
11382                                                                          ; when the T1 timer runs down at the switch from the
11383                                                                          ; space view to the dashboard, and we have an escape
11384                                                                          ; pod fitted, so this is the escape pod dashboard
11385                                                                          ; palette
11386                                                                          ;
11387                                                                          ; 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
11388                                                                          ; at vertical sync in LINSCN when HFX is non-zero, to
11389                                                                          ; create the hyperspace effect in LINSCN (where the
11390                                                                          ; whole screen is switched to mode 5 at vertical sync)
11391               
11392 3608 F0E0            byte >f0,>e0                                        ; 12 bytes of palette data at TVT1+16, used to set the
11393 360A B0A0            byte >b0,>a0                                        ; mode 4 palette in LINSCN when we hit vertical sync,
11394 360C D0C0            byte >d0,>c0                                        ; so the palette is set to monochrome when we start to
11395 360E 9080            byte >90,>80                                        ; draw the first row of the screen
11396 3610 7767            byte >77,>67
11397 3612 3727            byte >37,>27
11398               
11399               * ******************************************************************************
11400               *
11401               * Name: IRQ1
11402               * Type: Subroutine
11403               * Category: Drawing the screen
11404               * Summary: The main screen-mode interrupt handler (IRQ1V points here)
11405               * Deep dive: The split-screen mode in BBC Micro Elite
11406               *
11407               * ------------------------------------------------------------------------------
11408               *
11409               * The main interrupt handler, which implements Elite's split-screen mode (see
11410               * the deep dive on "The split-screen mode in BBC Micro Elite" for details).
11411               *
11412               * IRQ1V is set to point to IRQ1 by the loading process.
11413               *
11414               * ******************************************************************************
11415               
11416               LINSCN:
11417                                                                          ; This is called from the interrupt handler below, at
11418                                                                          ; the start of each vertical sync (i.e. when the screen
11419                                                                          ; refresh starts)
11420 3614 020D  20        li   ra,>1e*256                 ; LDA #30           ; Set the line scan counter to a non-zero value, so
     3616 1E00     
11421 3618 D80D  30        movb ra,@DL                     ; STA DL            ; routines like WSCAN can set DL to 0 and then wait for
     361A 009A     
11422                                                                          ; it to change to non-zero to catch the vertical sync
11423               
11424 361C D80D  38        movb ra,@VIA+>44                ; STA VIA+&44       ; Set 6522 System VIA T1C-L timer 1 low-order counter
     361E FE44     
11425                                                                          ; (SHEILA &44) to 30
11426               
11427 3620 020D  20        li   ra,(VSCAN)*256             ; LDA #VSCAN        ; Set 6522 System VIA T1C-L timer 1 high-order counter
     3622 3900     
11428 3624 D80D  38        movb ra,@VIA+>45                ; STA VIA+&45       ; (SHEILA &45) to VSCAN (57) to start the T1 counter
     3626 FE45     
11429                                                                          ; counting down from 14622 at a rate of 1 MHz
11430               
11431 3628 D360  30        movb @HFX,ra                    ; LDA HFX           ; If HFX is non-zero, jump to VNT1 to set the mode 5
     362A 0D62     
11432 362C 163D  14        jne  VNT1                       ; BNE VNT1          ; palette instead of switching to mode 4, which will
11433                                                                          ; have the effect of blurring and colouring the top
11434                                                                          ; screen. This is how the white hyperspace rings turn
11435                                                                          ; to colour when we do a hyperspace jump, and is
11436                                                                          ; triggered by setting HFX to 1 in routine LL164
11437               
11438 362E 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; Set the Video ULA control register (SHEILA &20) to
     3630 0800     
11439 3632 D80D  38        movb ra,@VIA+>20                ; STA VIA+&20       ; %00001000, which is the same as switching to mode 4
     3634 FE20     
11440                                                                          ; (i.e. the top part of the screen) but with no cursor
11441               
11442               VNT3:
11443 3636 D36F  34        movb @TVT1+16(ry),ra            ; LDA TVT1+16,Y     ; Copy the Y-th palette byte from TVT1+16 to SHEILA &21
     3638 3608     
11444 363A D80D  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     363C FE21     
11445                                                                          ; of the screen (i.e. the dashboard)
11446               
11447 363E 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11448               
11449 3640 15FA  14        jgt  VNT3                       ; BPL VNT3          ; Loop back to VNT3 until we have copied all the
11450                                                                          ; palette bytes
11451               
11452 3642 D360  30        movb @LASCT,ra                  ; LDA LASCT         ; Decrement the value of LASCT, but if we go too far
     3644 0D60     
11453 3646 1301  14        jeq  B30                        ; BEQ B30           ; and it becomes negative, bump it back up again (this
11454 3648 7347  18        sb   rone,ra                    ; DEC LASCT         ; controls the pulsing of pulse lasers)
11455               
11456               B30:
11457 364A D360  34        movb @SVN,ra                    ; LDA SVN           ; If SVN is non-zero, we are in the process of saving
     364C F439     
11458 364E 1623  14        jne  jvec_                      ; BNE jvec          ; the commander file, so jump to jvec to pass control
11459                                                                          ; to the next interrupt handler, so we don't break file
11460                                                                          ; saving by blocking the interrupt chain
11461               
11462                      .pla                            ; PLA               ; Otherwise restore Y from the stack
     **** ****     > PLA
0001 3650 058A  14        inc  rsp
0002 3652 D35A  26        movb *rsp,ra
                   < elite.a99
11463 3654 D3CD  18        movb ra,ry                      ; TAY
11464               
11465 3656 D360  34        movb @VIA+>41,ra                ; LDA VIA+&41       ; Read 6522 System VIA input register IRA (SHEILA &41)
     3658 FE41     
11466               
11467 365A D360  30        movb @>FC,ra                    ; LDA &FC           ; Set A to the interrupt accumulator save register,
     365C 00FC     
11468                                                                          ; which restores A to the value it had on entering the
11469                                                                          ; interrupt
11470               
11471                      ; RTI                           ; RTI               ; Return from interrupts, so this interrupt is not
11472                                                                          ; passed on to the next interrupt handler, but instead
11473                                                                          ; the interrupt terminates here
11474               
11475               IRQ1:
11476 365E D34F  18        movb ry,ra                      ; TYA               ; Store Y on the stack
11477                      .pha                            ; PHA
     **** ****     > PHA
0001 3660 D68D  30        movb ra,*rsp
0002 3662 060A  14        dec  rsp
                   < elite.a99
11478               
11479 3664 020F  20        li   ry,>0b*256                 ; LDY #11           ; Set Y as a counter for 12 bytes, to use when setting
     3666 0B00     
11480                                                                          ; the dashboard palette below
11481               
11482 3668 020D  20        li   ra,>02*256                 ; LDA #%00000010    ; Read the 6522 System VIA status byte bit 1 (SHEILA
     366A 0200     
11483                      .bit @VIA+>4D                   ; BIT VIA+&4D       ; &4D), which is set if vertical sync has occurred on
     **** ****     > BIT
0001 366C D020  34        movb @VIA+>4D,rtmp
     366E FE4D     
0002 3670 0540  14        inv  rtmp
0003 3672 D047  18        movb rone,rtmp2
0004 3674 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
11484                                                                          ; the video system
11485               
11486 3676 16CE  14        jne  LINSCN                     ; BNE LINSCN        ; If we are on the vertical sync pulse, jump to LINSCN
11487                                                                          ; to set up the timers to enable us to switch the
11488                                                                          ; screen mode between the space view and dashboard
11489               
11490 3678 190E  14        jno  jvec_                      ; BVC jvec          ; Read the 6522 System VIA status byte bit 6, which is
11491                                                                          ; set if timer 1 has timed out. We set the timer in
11492                                                                          ; LINSCN above, so this means we only run the next bit
11493                                                                          ; if the screen redraw has reached the boundary between
11494                                                                          ; the space view and the dashboard. Otherwise bit 6 is
11495                                                                          ; clear and we aren't at the boundary, so we jump to
11496                                                                          ; jvec to pass control to the next interrupt handler
11497               
11498                      .asla                           ; ASL A             ; Double the value in A to 4
     **** ****     > ASLA
0001 367A 024D  22        andi ra,>ff00
     367C FF00     
0002 367E 0A1D  18        sla  ra,1
                   < elite.a99
11499               
11500 3680 D80D  38        movb ra,@VIA+>20                ; STA VIA+&20       ; Set the Video ULA control register (SHEILA &20) to
     3682 FE20     
11501                                                                          ; %00000100, which is the same as switching to mode 5,
11502                                                                          ; (i.e. the bottom part of the screen) but with no
11503                                                                          ; cursor
11504               
11505 3684 D360  30        movb @ESCP,ra                   ; LDA ESCP          ; If an escape pod is fitted, jump to VNT1 to set the
     3686 032E     
11506 3688 160F  14        jne  VNT1                       ; BNE VNT1          ; mode 5 palette differently (so the dashboard is a
11507                                                                          ; different colour if we have an escape pod)
11508               
11509               B31:
11510 368A D36F  34        movb @TVT1(ry),ra               ; LDA TVT1,Y        ; Copy the Y-th palette byte from TVT1 to SHEILA &21
     368C 35F8     
11511 368E D80D  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     3690 FE21     
11512                                                                          ; of the screen (i.e. the dashboard)
11513               
11514 3692 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11515               
11516 3694 15FA  14        jgt  B31                        ; BPL B31           ; Loop back to the LDA TVT1,Y instruction until we have
11517                                                                          ; copied all the palette bytes
11518               
11519               jvec_:
11520                      .pla                            ; PLA               ; Restore Y from the stack
     **** ****     > PLA
0001 3696 058A  14        inc  rsp
0002 3698 D35A  26        movb *rsp,ra
                   < elite.a99
11521 369A D3CD  18        movb ra,ry                      ; TAY
11522               
11523                      .jmpi @VEC                      ; JMP (VEC)         ; Jump to the address in VEC, which was set to the
     **** ****     > JMPI
0001 369C D82E  46        movb @VEC(rx),@rtmplb
     369E F43A     
     36A0 8301     
0002 36A2 D02E  34        movb @VEC+1(rx),rtmp
     36A4 F43B     
0003 36A6 0450  20        b    *rtmp
                   < elite.a99
11524                                                                          ; original IRQ1V vector by the loading process, so this
11525                                                                          ; instruction passes control to the next interrupt
11526                                                                          ; handler
11527               
11528               VNT1:
11529 36A8 020F  20        li   ry,>07*256                 ; LDY #7            ; Set Y as a counter for 8 bytes
     36AA 0700     
11530               
11531 36AC D36F  34        movb @TVT1+8(ry),ra             ; LDA TVT1+8,Y      ; Copy the Y-th palette byte from TVT1+8 to SHEILA &21
     36AE 3600     
11532 36B0 D80D  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     36B2 FE21     
11533                                                                          ; of the screen (i.e. the dashboard)
11534               
11535 36B4 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11536               
11537 36B6 15F9  14        jgt  VNT1+2                     ; BPL VNT1+2        ; Loop back to the LDA TVT1+8,Y instruction until we
11538                                                                          ; have copied all the palette bytes
11539               
11540 36B8 11EE  14        jlt  jvec_                      ; BMI jvec          ; Jump up to jvec to pass control to the next interrupt
11541                                                                          ; handler (this BMI is effectively a JMP as we didn't
11542                                                                          ; loop back with the BPL above, so BMI is always true)
11543               
11544               * ******************************************************************************
11545               *
11546               * Name: ESCAPE
11547               * Type: Subroutine
11548               * Category: Flight
11549               * Summary: Launch our escape pod
11550               *
11551               * ------------------------------------------------------------------------------
11552               *
11553               * This routine displays our doomed Cobra Mk III disappearing off into the ether
11554               * before arranging our replacement ship. Called when we press ESCAPE during
11555               * flight and have an escape pod fitted.
11556               *
11557               * ******************************************************************************
11558               
11559               ESCAPE:
11560 36BA D360  30        movb @MJ,ra                     ; LDA MJ            ; Store the value of MJ on the stack (the "are we in
     36BC 0D5C     
11561                      .pha                            ; PHA               ; witchspace?" flag)
     **** ****     > PHA
0001 36BE D68D  30        movb ra,*rsp
0002 36C0 060A  14        dec  rsp
                   < elite.a99
11562               
11563 36C2 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     36C4 BFD6     
11564 36C6 06A0  32        bl   @jsr                       ;
     36C8 FE28     
11565               
11566 36CA 020E  20        li   rx,(CYL)*256               ; LDX #CYL          ; Set the current ship type to a Cobra Mk III, so we
     36CC 0700     
11567 36CE D80E  30        movb rx,@TYPE                   ; STX TYPE          ; can show our ship disappear into the distance when we
     36D0 009B     
11568                                                                          ; eject in our pod
11569               
11570 36D2 0200  20        li   rtmp,FRS1                  ; JSR FRS1          ; Call FRS1 to launch the Cobra Mk III straight ahead,
     36D4 3C78     
11571 36D6 06A0  32        bl   @jsr                       ;
     36D8 FE28     
11572                                                                          ; like a missile launch, but with our ship instead
11573               
11574 36DA 020D  20        li   ra,>08*256                 ; LDA #8            ; Set the Cobra's byte #27 (speed) to 8
     36DC 0800     
11575 36DE D80D  30        movb ra,@INWK+27                ; STA INWK+27
     36E0 006E     
11576               
11577 36E2 020D  20        li   ra,>c2*256                 ; LDA #194          ; Set the Cobra's byte #30 (pitch counter) to 194, so it
     36E4 C200     
11578 36E6 D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; pitches up as we pull away
     36E8 0071     
11579               
11580 36EA 091D  18        srl  ra,1                       ; LSR A             ; Set the Cobra's byte #32 (AI flag) to %01100001, so it
11581 36EC D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; has no AI, and we can use this value as a counter to
     36EE 0073     
11582                                                                          ; do the following loop 97 times
11583               
11584               ESL1:
11585 36F0 0200  20        li   rtmp,MVEIT                 ; JSR MVEIT         ; Call MVEIT to move the Cobra in space
     36F2 17FE     
11586 36F4 06A0  32        bl   @jsr                       ;
     36F6 FE28     
11587               
11588 36F8 0200  20        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to draw the Cobra on-screen
     36FA D574     
11589 36FC 06A0  32        bl   @jsr                       ;
     36FE FE28     
11590               
11591 3700 7347  18        sb   rone,ra                    ; DEC INWK+32       ; Decrement the counter in byte #32
11592               
11593 3702 16F6  14        jne  ESL1                       ; BNE ESL1          ; Loop back to keep moving the Cobra until the AI flag
11594                                                                          ; is 0, which gives it time to drift away from our pod
11595               
11596 3704 0200  20        li   rtmp,SCAN                  ; JSR SCAN          ; Call SCAN to remove the Cobra from the scanner (by
     3706 4D3E     
11597 3708 06A0  32        bl   @jsr                       ;
     370A FE28     
11598                                                                          ; redrawing it)
11599               
11600 370C 0200  20        li   rtmp,RESET                 ; JSR RESET         ; Call RESET to reset our ship and various controls
     370E BFAE     
11601 3710 06A0  32        bl   @jsr                       ;
     3712 FE28     
11602               
11603                      .pla                            ; PLA               ; Restore the witchspace flag from before the escape pod
     **** ****     > PLA
0001 3714 058A  14        inc  rsp
0002 3716 D35A  26        movb *rsp,ra
                   < elite.a99
11604 3718 1302  14        jeq  B32                        ; BEQ B32           ; launch, and if we were in normal space, skip the
11605                                                                          ; following instruction
11606               
11607 371A 0460  28        b    @DEATH                     ; JMP DEATH         ; Launching an escape pod in witchspace is fatal, so
     371C C522     
11608                                                                          ; jump to DEATH to begin the funeral and return from the
11609                                                                          ; subroutine using a tail call
11610               
11611               B32:
11612 371E 020E  20        li   rx,>10*256                 ; LDX #16           ; We lose all our cargo when using our escape pod, so
     3720 1000     
11613                                                                          ; up a counter in X so we can zero the 17 cargo slots
11614                                                                          ; in QQ20
11615               
11616               ESL2:
11617 3722 DB8D  38        movb ra,@QQ20(rx)               ; STA QQ20,X        ; Set the X-th byte of QQ20 to zero (as we know A = 0
     3724 0317     
11618                                                                          ; from the BEQ above), so we no longer have any of item
11619                                                                          ; type X in the cargo hold
11620               
11621 3726 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
11622               
11623 3728 15FC  14        jgt  ESL2                       ; BPL ESL2          ; Loop back to ESL2 until we have emptied the entire
11624                                                                          ; cargo hold
11625               
11626 372A D80D  30        movb ra,@FIST                   ; STA FIST          ; Launching an escape pod also clears our criminal
     372C 0334     
11627                                                                          ; record, so set our legal status in FIST to 0 ("clean")
11628               
11629 372E D80D  30        movb ra,@ESCP                   ; STA ESCP          ; The escape pod is a one-use item, so set ESCP to 0 so
     3730 032E     
11630                                                                          ; we no longer have one fitted
11631               
11632 3732 020D  20        li   ra,>46*256                 ; LDA #70           ; Our replacement ship is delivered with a full tank of
     3734 4600     
11633 3736 D80D  30        movb ra,@QQ14                   ; STA QQ14          ; fuel, so set the current fuel level in QQ14 to 70, or
     3738 030D     
11634                                                                          ; 7.0 light years
11635               
11636 373A 0460  28        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     373C C704     
11637                                                                          ; screen) and return from the subroutine with a tail
11638                                                                          ; call
11639               
11640               * ******************************************************************************
11641               *
11642               * Save ELTB.bin
11643               *
11644               * ******************************************************************************
11645               
11646                      ; PRINT "ELITE B"
11647                      ; PRINT "Assembled at ", ~CODE_B%
11648                      ; PRINT "Ends at ", ~P%
11649                      ; PRINT "Code size is ", ~(P% - CODE_B%)
11650                      ; PRINT "Execute at ", ~LOAD%
11651                      ; PRINT "Reload at ", ~LOAD_B%
11652               
11653                      ; PRINT "S.ELTB ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_B%
11654                      ; SAVE "3-assembled-output/ELTB.bin", CODE_B%, P%, LOAD%
11655               
11656               * ******************************************************************************
11657               *
11658               * ELITE C FILE
11659               *
11660               * Produces the binary file ELTC.bin that gets loaded by elite-bcfs.asm.
11661               *
11662               * ******************************************************************************
11663               
11664               CODE_C.:
11665                      equ $
11666               
11667               LOAD_C.:
11668                      equ LOAD. + $ - CODE.
11669               
11670               * ******************************************************************************
11671               *
11672               * Name: TACTICS (Part 1 of 7)
11673               * Type: Subroutine
11674               * Category: Tactics
11675               * Summary: Apply tactics: Process missiles, both enemy missiles and our own
11676               * Deep dive: Program flow of the tactics routine
11677               *
11678               * ------------------------------------------------------------------------------
11679               *
11680               * This section implements missile tactics and is entered at TA18 from the main
11681               * entry point below, if the current ship is a missile. Specifically:
11682               *
11683               * * If E.C.M. is active, destroy the missile
11684               *
11685               * * If the missile is hostile towards us, then check how close it is. If it
11686               * hasn't reached us, jump to part 3 so it can streak towards us, otherwise
11687               * we've been hit, so process a large amount of damage to our ship
11688               *
11689               * * Otherwise see how close the missile is to its target. If it has not yet
11690               * reached its target, give the target a chance to activate its E.C.M. if it
11691               * has one, otherwise jump to TA19 with K3 set to the vector from the target
11692               * to the missile
11693               *
11694               * * If it has reached its target and the target is the space station, destroy
11695               * the missile, potentially damaging us if we are nearby
11696               *
11697               * * If it has reached its target and the target is a ship, destroy the missile
11698               * and the ship, potentially damaging us if we are nearby
11699               *
11700               * ******************************************************************************
11701               
11702               TA34:
11703                                                                          ; If we get here, the missile is hostile
11704 373E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to x_hi OR y_hi OR z_hi
     3740 0000     
11705 3742 0200  20        li   rtmp,MAS4                  ; JSR MAS4
     3744 C512     
11706 3746 06A0  32        bl   @jsr                       ;
     3748 FE28     
11707               
11708 374A 1300  14        jeq  B33                        ; BEQ B33           ; If A = 0 then the missile is very close to our ship,
11709                                                                          ; so skip the following instruction
11710               
11711               B33:
11712 374C 0460  28        b    @TA21                      ; JMP TA21          ; Jump down to part 3 to set up the vectors and skip
     374E 3932     
11713                                                                          ; straight to aggressive manoeuvring
11714               
11715 3750 0200  20        li   rtmp,TA87+3                ; JSR TA87+3        ; The missile has hit our ship, so call TA87+3 to set
     3752 382F     
11716 3754 06A0  32        bl   @jsr                       ;
     3756 FE28     
11717                                                                          ; bit 7 of the missile's byte #31, which marks the
11718                                                                          ; missile as being killed
11719               
11720 3758 0200  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of the missile exploding
     375A CBDA     
11721 375C 06A0  32        bl   @jsr                       ;
     375E FE28     
11722               
11723 3760 020D  20        li   ra,>fa*256                 ; LDA #250          ; Call OOPS to damage the ship by 250, which is a pretty
     3762 FA00     
11724 3764 0460  28        b    @OOPS                      ; JMP OOPS          ; big hit, and return from the subroutine using a tail
     3766 AEBE     
11725                                                                          ; call
11726               
11727               TA18:
11728                                                                          ; This is the entry point for missile tactics and is
11729                                                                          ; called from the main TACTICS routine below
11730 3768 D360  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     376A 0030     
11731 376C 1652  14        jne  TA35                       ; BNE TA35          ; opponent's), jump to TA35 to destroy this missile
11732               
11733 376E D360  30        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the AI flag from byte #32 and if bit 6 is set
     3770 0073     
11734                      .asla                           ; ASL A             ; (i.e. missile is hostile), jump up to TA34 to check
     **** ****     > ASLA
0001 3772 024D  22        andi ra,>ff00
     3774 FF00     
0002 3776 0A1D  18        sla  ra,1
                   < elite.a99
11735 3778 11E2  14        jlt  TA34                       ; BMI TA34          ; whether the missile has hit us
11736               
11737 377A 091D  18        srl  ra,1                       ; LSR A             ; Otherwise shift A right again. We know bits 6 and 7
11738                                                                          ; are now clear, so this leaves bits 0-5. Bits 1-5
11739                                                                          ; contain the target's slot number, and bit 0 is cleared
11740                                                                          ; in FRMIS when a missile is launched, so A contains
11741                                                                          ; the slot number shifted left by 1 (i.e. doubled) so we
11742                                                                          ; can use it as an index for the two-byte address table
11743                                                                          ; at UNIV
11744               
11745 377C D38D  18        movb ra,rx                      ; TAX               ; Copy the address of the target ship's data block from
11746 377E D36E  34        movb @UNIV(rx),ra               ; LDA UNIV,X        ; UNIV(X+1 X) to V(1 0)
     3780 2243     
11747 3782 D80D  30        movb ra,@V                      ; STA V
     3784 0022     
11748 3786 D36E  34        movb @UNIV+1(rx),ra             ; LDA UNIV+1,X
     3788 2244     
11749 378A D80D  30        movb ra,@V+1                    ; STA V+1
     378C 0023     
11750               
11751 378E 020F  20        li   ry,>02*256                 ; LDY #2            ; K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of
     3790 0200     
11752 3792 0200  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     3794 3B5E     
11753 3796 06A0  32        bl   @jsr                       ;
     3798 FE28     
11754               
11755 379A 020F  20        li   ry,>05*256                 ; LDY #5            ; K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of
     379C 0500     
11756 379E 0200  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     37A0 3B5E     
11757 37A2 06A0  32        bl   @jsr                       ;
     37A4 FE28     
11758               
11759 37A6 020F  20        li   ry,>08*256                 ; LDY #8            ; K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of
     37A8 0800     
11760 37AA 0200  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     37AC 3B5E     
11761 37AE 06A0  32        bl   @jsr                       ;
     37B0 FE28     
11762               
11763                                                                          ; So K3 now contains the vector from the target ship to
11764                                                                          ; the missile
11765               
11766 37B2 D360  30        movb @K3+2,ra                   ; LDA K3+2          ; Set A = OR of all the sign and high bytes of the
     37B4 00D4     
11767 37B6 F360  30        socb @K3+5,ra                   ; ORA K3+5          ; above, clearing bit 7 (i.e. ignore the signs)
     37B8 00D7     
11768 37BA F360  30        socb @K3+8,ra                   ; ORA K3+8
     37BC 00DA     
11769 37BE 024D  22        andi ra,>7f*256                 ; AND #%01111111
     37C0 7F00     
11770 37C2 F360  30        socb @K3+1,ra                   ; ORA K3+1
     37C4 00D3     
11771 37C6 F360  30        socb @K3+4,ra                   ; ORA K3+4
     37C8 00D6     
11772 37CA F360  30        socb @K3+7,ra                   ; ORA K3+7
     37CC 00D9     
11773               
11774 37CE 1640  14        jne  TA64                       ; BNE TA64          ; If the result is non-zero, then the missile is some
11775                                                                          ; distance from the target, so jump down to TA64 see if
11776                                                                          ; the target activates its E.C.M.
11777               
11778 37D0 D360  30        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the AI flag from byte #32 and if only bits 7 and
     37D2 0073     
11779 37D4 028D  22        ci   ra,>82*256                 ; CMP #%10000010    ; 1 are set (AI is enabled and the target is slot 1, the
     37D6 8200     
11780 37D8 131C  14        jeq  TA35                       ; BEQ TA35          ; space station), jump to TA35 to destroy this missile,
11781                                                                          ; as the space station ain't kidding around
11782               
11783 37DA 020F  20        li   ry,>1f*256                 ; LDY #31           ; Fetch byte #31 (the exploding flag) of the target ship
     37DC 1F00     
11784                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; into A
     **** ****     > LD_IND_Y_IDX
0001 37DE D820  42        movb @V,@rtmplb
     37E0 0022     
     37E2 8301     
0002 37E4 D020  30        movb @V+1,rtmp
     37E6 0023     
0003 37E8 06CF  14        swpb ry
0004 37EA A00F  18        a    ry,rtmp
0005 37EC 06CF  14        swpb ry
0006 37EE D350  26        movb *rtmp,RA
                   < elite.a99
11785               
11786                      .bit @M32+1                     ; BIT M32+1         ; M32 contains an LDY #32 instruction, so M32+1 contains
     **** ****     > BIT
0001 37F0 D020  34        movb @M32+1,rtmp
     37F2 385F     
0002 37F4 0540  14        inv  rtmp
0003 37F6 D047  18        movb rone,rtmp2
0004 37F8 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
11787                                                                          ; 32, so this instruction tests A with %00100000, which
11788                                                                          ; checks bit 5 of A (the "already exploding?" bit)
11789               
11790 37FA 160B  14        jne  TA35                       ; BNE TA35          ; If the target ship is already exploding, jump to TA35
11791                                                                          ; to destroy this missile
11792               
11793 37FC 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Otherwise set bit 7 of the target's byte #31 to mark
     37FE 8000     
11794                      .st_ind_y_idx @V,ra             ; STA (V),Y         ; the ship as having been killed, so it explodes
     **** ****     > ST_IND_Y_IDX
0001 3800 D820  42        movb @V,@rtmplb
     3802 0022     
     3804 8301     
0002 3806 D020  30        movb @V+1,rtmp
     3808 0023     
0003 380A 06CF  14        swpb ry
0004 380C A00F  18        a    ry,rtmp
0005 380E 06CF  14        swpb ry
0006 3810 D40D  30        movb RA,*rtmp
                   < elite.a99
11795               
11796               TA35:
11797 3812 D360  30        movb @INWK,ra                   ; LDA INWK          ; Set A = x_lo OR y_lo OR z_lo of the missile
     3814 0053     
11798 3816 F360  30        socb @INWK+3,ra                 ; ORA INWK+3
     3818 0056     
11799 381A F360  30        socb @INWK+6,ra                 ; ORA INWK+6
     381C 0059     
11800               
11801 381E 1606  14        jne  TA87                       ; BNE TA87          ; If A is non-zero then the missile is not near our
11802                                                                          ; ship, so jump to TA87 to skip damaging our ship
11803               
11804 3820 020D  20        li   ra,>50*256                 ; LDA #80           ; Otherwise the missile just got destroyed near us, so
     3822 5000     
11805 3824 0200  20        li   rtmp,OOPS                  ; JSR OOPS          ; call OOPS to damage the ship by 80, which is nowhere
     3826 AEBE     
11806 3828 06A0  32        bl   @jsr                       ;
     382A FE28     
11807                                                                          ; near as bad as the 250 damage from a missile slamming
11808                                                                          ; straight into us, but it's still pretty nasty
11809               
11810               TA87:
11811 382C 0200  20        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     382E CC0C     
11812 3830 06A0  32        bl   @jsr                       ;
     3832 FE28     
11813                                                                          ; missile (so increase the kill tally, make an explosion
11814                                                                          ; sound and so on)
11815               
11816                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the missile's byte #31 flag to mark it as
     **** ****     > ASL
0001 3834 D020  30        movb @INWK+31,rtmp
     3836 0072     
0002 3838 0240  22        andi rtmp,>ff00
     383A FF00     
0003 383C 0A10  18        sla  rtmp,1
0004 383E D800  30        movb rtmp,@INWK+31
     3840 0072     
                   < elite.a99
11817                      .sec                            ; SEC               ; having been killed, so it explodes
     **** ****     > SEC
0001 3842 0A18  18        sla  rmone,1
                   < elite.a99
11818 3844 0204  20        li   rarg1,INWK+31              ; ROR INWK+31
     3846 0072     
11819 3848 06A0  32        bl   @ror                       ;
     384A FE7A     
11820               
11821               TA1:
11822 384C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     384E FE34     
11823               
11824               TA64:
11825                                                                          ; If we get here then the missile has not reached the
11826                                                                          ; target
11827 3850 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3852 C120     
11828 3854 06A0  32        bl   @jsr                       ;
     3856 FE28     
11829               
11830 3858 028D  22        ci   ra,>10*256                 ; CMP #16           ; If A >= 16 (94% chance), jump down to TA19 with the
     385A 1000     
11831 385C 1872  14        joc  TA19                       ; BCS TA19          ; vector from the target to the missile in K3
11832               
11833               M32:
11834 385E 020F  20        li   ry,>20*256                 ; LDY #32           ; Fetch byte #32 for the target and shift bit 0 (E.C.M.)
     3860 2000     
11835                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; into the C flag
     **** ****     > LD_IND_Y_IDX
0001 3862 D820  42        movb @V,@rtmplb
     3864 0022     
     3866 8301     
0002 3868 D020  30        movb @V+1,rtmp
     386A 0023     
0003 386C 06CF  14        swpb ry
0004 386E A00F  18        a    ry,rtmp
0005 3870 06CF  14        swpb ry
0006 3872 D350  26        movb *rtmp,RA
                   < elite.a99
11836 3874 091D  18        srl  ra,1                       ; LSR A
11837               
11838 3876 1765  14        jnc  TA19                       ; BCC TA19          ; If the C flag is clear then the target does not have
11839                                                                          ; E.C.M. fitted, so jump down to TA19 with the vector
11840                                                                          ; from the target to the missile in K3
11841               
11842 3878 0460  28        b    @ECBLB2                    ; JMP ECBLB2        ; The target has E.C.M., so jump to ECBLB2 to set it
     387A B11A     
11843                                                                          ; off, returning from the subroutine using a tail call
11844               
11845               * ******************************************************************************
11846               *
11847               * Name: TACTICS (Part 2 of 7)
11848               * Type: Subroutine
11849               * Category: Tactics
11850               * Summary: Apply tactics: Escape pod, station, lone Thargon, safe-zone pirate
11851               * Deep dive: Program flow of the tactics routine
11852               *
11853               * ------------------------------------------------------------------------------
11854               *
11855               * This section contains the main entry point at TACTICS, which is called from
11856               * part 2 of MVEIT for ships that have the AI flag set (i.e. bit 7 of byte #32).
11857               * This part does the following:
11858               *
11859               * * If this is a missile, jump up to the missile code in part 1
11860               *
11861               * * If this is an escape pod, point it at the planet and jump to the
11862               * manoeuvring code in part 7
11863               *
11864               * * If this is the space station and it is hostile, consider spawning a cop
11865               * (45% chance, up to a maximum of four) and we're done
11866               *
11867               * * If this is a lone Thargon without a mothership, set it adrift aimlessly
11868               * and we're done
11869               *
11870               * * If this is a pirate and we are within the space station safe zone, stop
11871               * the pirate from attacking by removing all its aggression
11872               *
11873               * * Recharge the ship's energy banks by 1
11874               *
11875               * ------------------------------------------------------------------------------
11876               *
11877               * Arguments:
11878               *
11879               * X                   The ship type
11880               *
11881               * ******************************************************************************
11882               
11883               TACTICS:
11884 387C 028E  22        ci   rx,(MSL)*256               ; CPX #MSL          ; If this is a missile, jump up to TA18 to implement
     387E 0900     
11885 3880 1602  14        jne  FIX001                     ; BNE FIX001        ; missile tactics
11886 3882 0460  28        b    @TA18                      ; JMP TA18
     3884 3768     
11887               FIX001:
11888 3886 028E  22        ci   rx,(ESC)*256               ; CPX #ESC          ; If this is not an escape pod, skip the following two
     3888 0D00     
11889 388A 1606  14        jne  B34                        ; BNE B34           ; instructions
11890               
11891 388C 0200  20        li   rtmp,SPS1                  ; JSR SPS1          ; This is an escape pod, so call SPS1 to calculate the
     388E CA26     
11892 3890 06A0  32        bl   @jsr                       ;
     3892 FE28     
11893                                                                          ; vector to the planet and store it in XX15
11894               
11895 3894 0460  28        b    @TA15                      ; JMP TA15          ; Jump down to TA15
     3896 3AD4     
11896               
11897               B34:
11898 3898 028E  22        ci   rx,(SST)*256               ; CPX #SST          ; If this is not the space station, jump down to TA13
     389A 0800     
11899 389C 1612  14        jne  TA13                       ; BNE TA13
11900               
11901                                                                          ; We only call the tactics routine for the space station
11902                                                                          ; when it is hostile, so if we get here then this is the
11903                                                                          ; station, and we already know it's hostile, so we need
11904                                                                          ; to spawn some cops
11905               
11906 389E 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     38A0 C120     
11907 38A2 06A0  32        bl   @jsr                       ;
     38A4 FE28     
11908               
11909 38A6 028D  22        ci   ra,>8c*256                 ; CMP #140          ; If A < 140 (55% chance) then return from the
     38A8 8C00     
11910 38AA 1723  14        jnc  TA14-1                     ; BCC TA14-1        ; subroutine (as TA14-1 contains an RTS)
11911               
11912 38AC D360  30        movb @MANY+COPS,ra              ; LDA MANY+COPS     ; We only call the tactics routine for the space station
     38AE 0D4F     
11913 38B0 028D  22        ci   ra,>04*256                 ; CMP #4            ; when it is hostile, so first check the number of cops
     38B2 0400     
11914 38B4 181E  14        joc  TA14-1                     ; BCS TA14-1        ; in the vicinity, and if we already have 4 or more, we
11915                                                                          ; don't need to spawn any more, so return from the
11916                                                                          ; subroutine (as TA14-1 contains an RTS)
11917               
11918 38B6 020E  20        li   rx,(COPS)*256              ; LDX #COPS         ; Set X to the ship type for a cop
     38B8 0200     
11919               
11920 38BA 020D  20        li   ra,>f1*256                 ; LDA #%11110001    ; Set the AI flag to give the ship E.C.M., enable AI and
     38BC F100     
11921                                                                          ; make it very aggressive (60 out of 63)
11922               
11923 38BE 0460  28        b    @SFS1                      ; JMP SFS1          ; Jump to SFS1 to spawn the ship, returning from the
     38C0 3DB2     
11924                                                                          ; subroutine using a tail call
11925               
11926               TA13:
11927 38C2 028E  22        ci   rx,(TGL)*256               ; CPX #TGL          ; If this is not a Thargon, jump down to TA14
     38C4 0C00     
11928 38C6 1616  14        jne  TA14                       ; BNE TA14
11929               
11930 38C8 D360  30        movb @MANY+THG,ra               ; LDA MANY+THG      ; If there is at least one Thargoid in the vicinity,
     38CA 0D53     
11931 38CC 1613  14        jne  TA14                       ; BNE TA14          ; jump down to TA14
11932               
11933                      .lsr @INWK+32                   ; LSR INWK+32       ; This is a Thargon but there is no Thargoid mothership,
     **** ****     > LSR
0001 38CE D020  30        movb @INWK+32,rtmp
     38D0 0073     
0002 38D2 0910  18        srl  rtmp,1
0003 38D4 D800  30        movb rtmp,@INWK+32
     38D6 0073     
                   < elite.a99
11934                      .asl @INWK+32                   ; ASL INWK+32       ; so clear bit 0 of the AI flag to disable its E.C.M.
     **** ****     > ASL
0001 38D8 D020  30        movb @INWK+32,rtmp
     38DA 0073     
0002 38DC 0240  22        andi rtmp,>ff00
     38DE FF00     
0003 38E0 0A10  18        sla  rtmp,1
0004 38E2 D800  30        movb rtmp,@INWK+32
     38E4 0073     
                   < elite.a99
11935               
11936                      .lsr @INWK+27                   ; LSR INWK+27       ; And halve the Thargon's speed
     **** ****     > LSR
0001 38E6 D020  30        movb @INWK+27,rtmp
     38E8 006E     
0002 38EA 0910  18        srl  rtmp,1
0003 38EC D800  30        movb rtmp,@INWK+27
     38EE 006E     
                   < elite.a99
11937               
11938 38F0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     38F2 FE34     
11939               
11940               TA14:
11941 38F4 028E  22        ci   rx,(CYL)*256               ; CPX #CYL          ; If A >= #CYL, i.e. this is a Cobra Mk III trader (as
     38F6 0700     
11942 38F8 180C  14        joc  TA62                       ; BCS TA62          ; asteroids and cargo canisters never have AI), jump
11943                                                                          ; down to TA62
11944               
11945 38FA 028E  22        ci   rx,(COPS)*256              ; CPX #COPS         ; If this is a cop, jump down to TA62
     38FC 0200     
11946 38FE 1309  14        jeq  TA62                       ; BEQ TA62
11947               
11948 3900 D360  30        movb @SSPR,ra                   ; LDA SSPR          ; If we aren't within range of the space station, jump
     3902 0D55     
11949 3904 1306  14        jeq  TA62                       ; BEQ TA62          ; down to TA62
11950               
11951 3906 D360  30        movb @INWK+32,ra                ; LDA INWK+32       ; This is a pirate or bounty hunter, but we are inside
     3908 0073     
11952 390A 024D  22        andi ra,>81*256                 ; AND #%10000001    ; the space station's safe zone, so clear bits 1-6 of
     390C 8100     
11953 390E D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; the AI flag to stop it being hostile, because even
     3910 0073     
11954                                                                          ; pirates aren't crazy enough to breach the station's
11955                                                                          ; no-fire zone
11956               
11957               TA62:
11958 3912 020F  20        li   ry,>0e*256                 ; LDY #14           ; If the ship's energy is greater or equal to the
     3914 0E00     
11959 3916 D360  30        movb @INWK+35,ra                ; LDA INWK+35       ; maximum value from the ship's blueprint pointed to by
     3918 0076     
11960                      .cmp_ind_y_idx @XX0,ra          ; CMP (XX0),Y       ; XX0, then skip the next instruction
     **** ****     > CMP_IND_Y_IDX
0001 391A D820  42        movb @XX0,@rtmplb
     391C 001E     
     391E 8301     
0002 3920 D020  30        movb @XX0+1,rtmp
     3922 001F     
0003 3924 06CF  14        swpb ry
0004 3926 A00F  18        a    ry,rtmp
0005 3928 06CF  14        swpb ry
0006 392A D010  26        movb *rtmp,rtmp
0007 392C 900D  18        cb   ra,rtmp
                   < elite.a99
11961 392E 1801  14        joc  TA21                       ; BCS TA21
11962               
11963 3930 B347  18        ab   rone,ra                    ; INC INWK+35       ; The ship's energy is not at maximum, so recharge the
11964                                                                          ; energy banks by 1
11965               
11966               * ******************************************************************************
11967               *
11968               * Name: TACTICS (Part 3 of 7)
11969               * Type: Subroutine
11970               * Category: Tactics
11971               * Summary: Apply tactics: Calculate dot product to determine ship's aim
11972               * Deep dive: Program flow of the tactics routine
11973               *
11974               * ------------------------------------------------------------------------------
11975               *
11976               * This section sets up some vectors and calculates dot products. Specifically:
11977               *
11978               * * Calculate the dot product of the ship's nose vector (i.e. the direction it
11979               * is pointing) with the vector between us and the ship. This value will help
11980               * us work out later on whether the enemy ship is pointing towards us, and
11981               * therefore whether it can hit us with its lasers.
11982               *
11983               * ******************************************************************************
11984               
11985               TA21:
11986 3932 020E  20        li   rx,>08*256                 ; LDX #8            ; We now want to copy the ship's x, y and z coordinates
     3934 0800     
11987                                                                          ; from INWK to K3, so set up a counter for 9 bytes
11988               
11989               TAL1:
11990 3936 D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Copy the X-th byte from INWK to the X-th byte of K3
     3938 0053     
11991 393A DB8D  38        movb ra,@K3(rx)                 ; STA K3,X
     393C 00D2     
11992               
11993 393E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
11994               
11995 3940 15FA  14        jgt  TAL1                       ; BPL TAL1          ; Loop back until we have copied all 9 bytes
11996               
11997               TA19:
11998                                                                          ; If this is a missile that's heading for its target
11999                                                                          ; (not us, one of the other ships), then the missile
12000                                                                          ; routine at TA18 above jumps here after setting K3 to
12001                                                                          ; the vector from the target to the missile
12002 3942 0200  20        li   rtmp,TAS2                  ; JSR TAS2          ; Normalise the vector in K3 and store the normalised
     3944 CA4A     
12003 3946 06A0  32        bl   @jsr                       ;
     3948 FE28     
12004                                                                          ; version in XX15, so XX15 contains the normalised
12005                                                                          ; vector from our ship to the ship we are applying AI
12006                                                                          ; tactics to (or the normalised vector from the target
12007                                                                          ; to the missile - in both cases it's the vector from
12008                                                                          ; the potential victim to the attacker)
12009               
12010 394A 020F  20        li   ry,>0a*256                 ; LDY #10           ; Set (A X) = nosev . XX15
     394C 0A00     
12011 394E 0200  20        li   rtmp,TAS3                  ; JSR TAS3
     3950 452A     
12012 3952 06A0  32        bl   @jsr                       ;
     3954 FE28     
12013               
12014 3956 D80D  30        movb ra,@CNT                    ; STA CNT           ; Store the high byte of the dot product in CNT. The
     3958 00A4     
12015                                                                          ; bigger the value, the more aligned the two ships are,
12016                                                                          ; with a maximum magnitude of 36 (96 * 96 >> 8). If CNT
12017                                                                          ; is positive, the ships are facing in a similar
12018                                                                          ; direction, if it's negative they are facing in
12019                                                                          ; opposite directions
12020               
12021               * ******************************************************************************
12022               *
12023               * Name: TACTICS (Part 4 of 7)
12024               * Type: Subroutine
12025               * Category: Tactics
12026               * Summary: Apply tactics: Check energy levels, maybe launch escape pod if low
12027               * Deep dive: Program flow of the tactics routine
12028               *
12029               * ------------------------------------------------------------------------------
12030               *
12031               * This section works out what kind of condition the ship is in. Specifically:
12032               *
12033               * * Rarely (2.5% chance) roll the ship by a noticeable amount
12034               *
12035               * * If the ship has at least half its energy banks full, jump to part 6 to
12036               * consider firing the lasers
12037               *
12038               * * If the ship is not into the last 1/8th of its energy, jump to part 5 to
12039               * consider firing a missile
12040               *
12041               * * If the ship is into the last 1/8th of its energy, then rarely (10% chance)
12042               * the ship launches an escape pod and is left drifting in space
12043               *
12044               * ******************************************************************************
12045               
12046 395A D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If this is not a missile, skip the following
     395C 009B     
12047 395E 028D  22        ci   ra,(MSL)*256               ; CMP #MSL          ; instruction
     3960 0900     
12048 3962 1602  14        jne  B35                        ; BNE B35
12049               
12050 3964 0460  28        b    @TA20                      ; JMP TA20          ; This is a missile, so jump down to TA20 to get
     3966 3A9C     
12051                                                                          ; straight into some aggressive manoeuvring
12052               
12053               B35:
12054 3968 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     396A C120     
12055 396C 06A0  32        bl   @jsr                       ;
     396E FE28     
12056               
12057 3970 028D  22        ci   ra,>fa*256                 ; CMP #250          ; If A < 250 (97.5% chance), jump down to TA7 to skip
     3972 FA00     
12058 3974 1708  14        jnc  TA7                        ; BCC TA7           ; the following
12059               
12060 3976 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3978 C120     
12061 397A 06A0  32        bl   @jsr                       ;
     397C FE28     
12062               
12063 397E 026D  22        ori  ra,>68*256                 ; ORA #104          ; Bump A up to at least 104 and store in the roll
     3980 6800     
12064 3982 D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; counter, to gives the ship a noticeable roll
     3984 0070     
12065               
12066               TA7:
12067 3986 020F  20        li   ry,>0e*256                 ; LDY #14           ; Set A = the ship's maximum energy / 2
     3988 0E00     
12068                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y
     **** ****     > LD_IND_Y_IDX
0001 398A D820  42        movb @XX0,@rtmplb
     398C 001E     
     398E 8301     
0002 3990 D020  30        movb @XX0+1,rtmp
     3992 001F     
0003 3994 06CF  14        swpb ry
0004 3996 A00F  18        a    ry,rtmp
0005 3998 06CF  14        swpb ry
0006 399A D350  26        movb *rtmp,RA
                   < elite.a99
12069 399C 091D  18        srl  ra,1                       ; LSR A
12070               
12071 399E 9360  30        cb   @INWK+35,ra                ; CMP INWK+35       ; If the ship's current energy in byte #35 > A, i.e. the
     39A0 0076     
12072 39A2 1738  14        jnc  TA3                        ; BCC TA3           ; ship has at least half of its energy banks charged,
12073                                                                          ; jump down to TA3
12074               
12075 39A4 091D  18        srl  ra,1                       ; LSR A             ; If the ship's current energy in byte #35 > A / 4, i.e.
12076 39A6 091D  18        srl  ra,1                       ; LSR A             ; the ship is not into the last 1/8th of its energy,
12077 39A8 9360  30        cb   @INWK+35,ra                ; CMP INWK+35       ; jump down to ta3 to consider firing a missile
     39AA 0076     
12078 39AC 1712  14        jnc  ta3_                       ; BCC ta3
12079               
12080 39AE 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     39B0 C120     
12081 39B2 06A0  32        bl   @jsr                       ;
     39B4 FE28     
12082               
12083 39B6 028D  22        ci   ra,>e6*256                 ; CMP #230          ; If A < 230 (90% chance), jump down to ta3 to consider
     39B8 E600     
12084 39BA 170B  14        jnc  ta3_                       ; BCC ta3           ; firing a missile
12085               
12086 39BC D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If this is a Thargoid, jump down to ta3 to consider
     39BE 009B     
12087 39C0 028D  22        ci   ra,(THG)*256               ; CMP #THG          ; launching a Thargon
     39C2 0600     
12088 39C4 1306  14        jeq  ta3_                       ; BEQ ta3
12089               
12090                                                                          ; By this point, the ship has run out of both energy and
12091                                                                          ; luck, so it's time to bail
12092               
12093 39C6 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the AI flag to 0 to disable AI, hostility and
     39C8 0000     
12094 39CA D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; E.C.M., so the ship's a sitting duck
     39CC 0073     
12095               
12096 39CE 0460  28        b    @SESCP                     ; JMP SESCP         ; Jump to SESCP to spawn an escape pod from the ship,
     39D0 3DAA     
12097                                                                          ; returning from the subroutine using a tail call
12098               
12099               * ******************************************************************************
12100               *
12101               * Name: TACTICS (Part 5 of 7)
12102               * Type: Subroutine
12103               * Category: Tactics
12104               * Summary: Apply tactics: Consider whether to launch a missile at us
12105               * Deep dive: Program flow of the tactics routine
12106               *
12107               * ------------------------------------------------------------------------------
12108               *
12109               * This section considers whether to launch a missile. Specifically:
12110               *
12111               * * If the ship doesn't have any missiles, skip to the next part
12112               *
12113               * * If an E.C.M. is firing, skip to the next part
12114               *
12115               * * Randomly decide whether to fire a missile (or, in the case of Thargoids,
12116               * release a Thargon), and if we do, we're done
12117               *
12118               * ******************************************************************************
12119               
12120               ta3_:
12121                                                                          ; If we get here then the ship has less than half energy
12122                                                                          ; so there may not be enough juice for lasers, but let's
12123                                                                          ; see if we can fire a missile
12124 39D2 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set A = bits 0-2 of byte #31, the number of missiles
     39D4 0072     
12125 39D6 024D  22        andi ra,>07*256                 ; AND #%00000111    ; the ship has left
     39D8 0700     
12126               
12127 39DA 131C  14        jeq  TA3                        ; BEQ TA3           ; If it doesn't have any missiles, jump to TA3
12128               
12129 39DC D80D  30        movb ra,@T                      ; STA T             ; Store the number of missiles in T
     39DE 00D1     
12130               
12131 39E0 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     39E2 C120     
12132 39E4 06A0  32        bl   @jsr                       ;
     39E6 FE28     
12133               
12134 39E8 024D  22        andi ra,>1f*256                 ; AND #31           ; Restrict A to a random number in the range 0-31
     39EA 1F00     
12135               
12136 39EC 9360  30        cb   @T,ra                      ; CMP T             ; If A >= T, which is quite likely, though less likely
     39EE 00D1     
12137 39F0 1811  14        joc  TA3                        ; BCS TA3           ; with higher numbers of missiles, jump to TA3 to skip
12138                                                                          ; firing a missile
12139               
12140 39F2 D360  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     39F4 0030     
12141 39F6 160E  14        jne  TA3                        ; BNE TA3           ; opponent's), jump to TA3 to skip firing a missile
12142               
12143 39F8 7347  18        sb   rone,ra                    ; DEC INWK+31       ; We're done with the checks, so it's time to fire off a
12144                                                                          ; missile, so reduce the missile count in byte #31 by 1
12145               
12146 39FA D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship type into A
     39FC 009B     
12147               
12148 39FE 028D  22        ci   ra,(THG)*256               ; CMP #THG          ; If this is not a Thargoid, jump down to TA16 to launch
     3A00 0600     
12149 3A02 1606  14        jne  TA16                       ; BNE TA16          ; a missile
12150               
12151 3A04 020E  20        li   rx,(TGL)*256               ; LDX #TGL          ; This is a Thargoid, so instead of launching a missile,
     3A06 0C00     
12152 3A08 D360  30        movb @INWK+32,ra                ; LDA INWK+32       ; the mothership launches a Thargon, so call SFS1 to
     3A0A 0073     
12153 3A0C 0460  28        b    @SFS1                      ; JMP SFS1          ; spawn a Thargon from the parent ship, and return from
     3A0E 3DB2     
12154                                                                          ; the subroutine using a tail call
12155               
12156               TA16:
12157 3A10 0460  28        b    @SFRMIS                    ; JMP SFRMIS        ; Jump to SFRMIS to spawn a missile as a child of the
     3A12 CBEC     
12158                                                                          ; current ship, make a noise and print a message warning
12159                                                                          ; of incoming missiles, and return from the subroutine
12160                                                                          ; using a tail call
12161               
12162               * ******************************************************************************
12163               *
12164               * Name: TACTICS (Part 6 of 7)
12165               * Type: Subroutine
12166               * Category: Tactics
12167               * Summary: Apply tactics: Consider firing a laser at us, if aim is true
12168               * Deep dive: Program flow of the tactics routine
12169               *
12170               * ------------------------------------------------------------------------------
12171               *
12172               * This section looks at potentially firing the ship's laser at us. Specifically:
12173               *
12174               * * If the ship is not pointing at us, skip to the next part
12175               *
12176               * * If the ship is pointing at us but not accurately, fire its laser at us and
12177               * skip to the next part
12178               *
12179               * * If we are in the ship's crosshairs, register some damage to our ship, slow
12180               * down the attacking ship, make the noise of us being hit by laser fire, and
12181               * we're done
12182               *
12183               * ******************************************************************************
12184               
12185               TA3:
12186                                                                          ; If we get here then the ship either has plenty of
12187                                                                          ; energy, or levels are low but it couldn't manage to
12188                                                                          ; launch a missile, so maybe we can fire the laser?
12189 3A14 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to x_hi OR y_hi OR z_hi
     3A16 0000     
12190 3A18 0200  20        li   rtmp,MAS4                  ; JSR MAS4
     3A1A C512     
12191 3A1C 06A0  32        bl   @jsr                       ;
     3A1E FE28     
12192               
12193 3A20 024D  22        andi ra,>e0*256                 ; AND #%11100000    ; If any of the hi bytes have any of bits 5-7 set, then
     3A22 E000     
12194 3A24 1626  14        jne  TA4                        ; BNE TA4           ; jump to TA4 to skip the laser checks, as the ship is
12195                                                                          ; too far away from us to hit us with a laser
12196               
12197 3A26 D3A0  30        movb @CNT,rx                    ; LDX CNT           ; Set X = the dot product set above in CNT. If this is
     3A28 00A4     
12198                                                                          ; positive, this ship and our ship are facing in similar
12199                                                                          ; directions, but if it's negative then we are facing
12200                                                                          ; each other, so for us to be in the enemy ship's line
12201                                                                          ; of fire, X needs to be negative. The value in X can
12202                                                                          ; have a maximum magnitude of 36, which would mean we
12203                                                                          ; were facing each other square on, so in the following
12204                                                                          ; code we check X like this:
12205                                                                          ;
12206                                                                          ; X = 0 to -31, we are not in the enemy ship's line
12207                                                                          ; of fire, so they can't shoot at us
12208                                                                          ;
12209                                                                          ; X = -32 to -34, we are in the enemy ship's line
12210                                                                          ; of fire, so they can shoot at us, but they can't
12211                                                                          ; hit us as we're not dead in their crosshairs
12212                                                                          ;
12213                                                                          ; X = -35 to -36, we are bang in the middle of the
12214                                                                          ; enemy ship's crosshairs, so they can not only
12215                                                                          ; shoot us, they can hit us
12216               
12217 3A2A 028E  22        ci   rx,>a0*256                 ; CPX #160          ; If X < 160, i.e. X > -32, then we are not in the enemy
     3A2C A000     
12218 3A2E 1721  14        jnc  TA4                        ; BCC TA4           ; ship's line of fire, so jump to TA4 to skip the laser
12219                                                                          ; checks
12220               
12221 3A30 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 6 in byte #31 to denote that the ship is
     3A32 0072     
12222 3A34 026D  22        ori  ra,>40*256                 ; ORA #%01000000    ; firing its laser at us
     3A36 4000     
12223 3A38 D80D  30        movb ra,@INWK+31                ; STA INWK+31
     3A3A 0072     
12224               
12225 3A3C 028E  22        ci   rx,>a3*256                 ; CPX #163          ; If X < 163, i.e. X > -35, then we are not in the enemy
     3A3E A300     
12226 3A40 1718  14        jnc  TA4                        ; BCC TA4           ; ship's crosshairs, so jump to TA4 to skip the laser
12227                                                                          ; checks
12228               
12229               HIT:
12230 3A42 020F  20        li   ry,>13*256                 ; LDY #19           ; We are being hit by enemy laser fire, so fetch the
     3A44 1300     
12231                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; enemy ship's byte #19 from their ship's blueprint
     **** ****     > LD_IND_Y_IDX
0001 3A46 D820  42        movb @XX0,@rtmplb
     3A48 001E     
     3A4A 8301     
0002 3A4C D020  30        movb @XX0+1,rtmp
     3A4E 001F     
0003 3A50 06CF  14        swpb ry
0004 3A52 A00F  18        a    ry,rtmp
0005 3A54 06CF  14        swpb ry
0006 3A56 D350  26        movb *rtmp,RA
                   < elite.a99
12232                                                                          ; into A
12233               
12234 3A58 091D  18        srl  ra,1                       ; LSR A             ; Halve the enemy ship's byte #19 (which contains both
12235                                                                          ; the laser power and number of missiles) to get the
12236                                                                          ; amount of damage we should take
12237               
12238 3A5A 0200  20        li   rtmp,OOPS                  ; JSR OOPS          ; Call OOPS to take some damage, which could do anything
     3A5C AEBE     
12239 3A5E 06A0  32        bl   @jsr                       ;
     3A60 FE28     
12240                                                                          ; from reducing the shields and energy, all the way to
12241                                                                          ; losing cargo or dying (if the latter, we don't come
12242                                                                          ; back from this subroutine)
12243               
12244 3A62 7347  18        sb   rone,ra                    ; DEC INWK+28       ; Halve the attacking ship's acceleration in byte #28
12245               
12246 3A64 D360  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     3A66 0030     
12247 3A68 1678  14        jne  TA10                       ; BNE TA10          ; opponent's), return from the subroutine without making
12248                                                                          ; the laser-strike sound (as TA10 contains an RTS)
12249               
12250 3A6A 020D  20        li   ra,>08*256                 ; LDA #8            ; Call the NOISE routine with A = 8 to make the sound
     3A6C 0800     
12251 3A6E 0460  28        b    @NOISE                     ; JMP NOISE         ; of us being hit by lasers, returning from the
     3A70 CC5C     
12252                                                                          ; subroutine using a tail call
12253               
12254               * ******************************************************************************
12255               *
12256               * Name: TACTICS (Part 7 of 7)
12257               * Type: Subroutine
12258               * Category: Tactics
12259               * Summary: Apply tactics: Set pitch, roll, and acceleration
12260               * Deep dive: Program flow of the tactics routine
12261               *
12262               * ------------------------------------------------------------------------------
12263               *
12264               * This section looks at manoeuvring the ship. Specifically:
12265               *
12266               * * Work out which direction the ship should be moving, depending on whether
12267               * it's an escape pod, where it is, which direction it is pointing, and how
12268               * aggressive it is
12269               *
12270               * * Set the pitch and roll counters to head in that direction
12271               *
12272               * * Speed up or slow down, depending on where the ship is in relation to us
12273               *
12274               * ******************************************************************************
12275               
12276               TA4:
12277 3A72 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; If z_hi >= 3 then the ship is quite far away, so jump
     3A74 005A     
12278 3A76 028D  22        ci   ra,>03*256                 ; CMP #3            ; down to TA5
     3A78 0300     
12279 3A7A 1807  14        joc  TA5                        ; BCS TA5
12280               
12281 3A7C D360  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Otherwise set A = x_hi OR y_hi and extract bits 1-7
     3A7E 0054     
12282 3A80 F360  30        socb @INWK+4,ra                 ; ORA INWK+4
     3A82 0057     
12283 3A84 024D  22        andi ra,>fe*256                 ; AND #%11111110
     3A86 FE00     
12284               
12285 3A88 1325  14        jeq  TA15                       ; BEQ TA15          ; If A = 0 then the ship is pretty close to us, so jump
12286                                                                          ; to TA15 so it heads away from us
12287               
12288               TA5:
12289                                                                          ; If we get here then the ship is quite far away
12290 3A8A 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3A8C C120     
12291 3A8E 06A0  32        bl   @jsr                       ;
     3A90 FE28     
12292               
12293 3A92 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 of A, so A is at least 128
     3A94 8000     
12294               
12295 3A96 9360  30        cb   @INWK+32,ra                ; CMP INWK+32       ; If A >= byte #32 (the ship's AI flag) then jump down
     3A98 0073     
12296 3A9A 181C  14        joc  TA15                       ; BCS TA15          ; to TA15 so it heads away from us
12297               
12298                                                                          ; We get here if A < byte #32, and the chances of this
12299                                                                          ; being true are greater with high values of byte #32,
12300                                                                          ; as long as they are at least 128
12301                                                                          ;
12302                                                                          ; In other words, higher byte #32 values increase the
12303                                                                          ; chances of a ship changing direction to head towards
12304                                                                          ; us - or, to put it another way, ships with higher
12305                                                                          ; byte #32 values of 128 or more are spoiling for a
12306                                                                          ; fight
12307                                                                          ;
12308                                                                          ; Thargoids have byte #32 set to 255, which explains
12309                                                                          ; an awful lot
12310               
12311               TA20:
12312                                                                          ; If this is a missile we will have jumped straight
12313                                                                          ; here, but we also get here if the ship is either far
12314                                                                          ; away and aggressive, or not too close
12315 3A9C D360  30        movb @XX15,ra                   ; LDA XX15          ; Reverse the signs of XX15 and the dot product in CNT,
     3A9E 0031     
12316                      .eoi (>80*256)                  ; EOR #%10000000    ; starting with the x-coordinate
     **** ****     > EOI
0001 3AA0 0200  20        li   rtmp,(>80*256)
     3AA2 8000     
0002 3AA4 2B40  18        xor  rtmp,ra
                   < elite.a99
12317 3AA6 D80D  30        movb ra,@XX15                   ; STA XX15
     3AA8 0031     
12318               
12319 3AAA D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Then reverse the sign of the y-coordinate
     3AAC 0032     
12320                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 3AAE 0200  20        li   rtmp,(>80*256)
     3AB0 8000     
0002 3AB2 2B40  18        xor  rtmp,ra
                   < elite.a99
12321 3AB4 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     3AB6 0032     
12322               
12323 3AB8 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; And then the z-coordinate, so now the XX15 vector goes
     3ABA 0033     
12324                      .eoi (>80*256)                  ; EOR #%10000000    ; from the enemy ship to our ship (it was previously the
     **** ****     > EOI
0001 3ABC 0200  20        li   rtmp,(>80*256)
     3ABE 8000     
0002 3AC0 2B40  18        xor  rtmp,ra
                   < elite.a99
12325 3AC2 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; other way round)
     3AC4 0033     
12326               
12327 3AC6 D360  30        movb @CNT,ra                    ; LDA CNT           ; And finally change the sign of the dot product in CNT,
     3AC8 00A4     
12328                      .eoi (>80*256)                  ; EOR #%10000000    ; so now it's positive if the ships are facing each
     **** ****     > EOI
0001 3ACA 0200  20        li   rtmp,(>80*256)
     3ACC 8000     
0002 3ACE 2B40  18        xor  rtmp,ra
                   < elite.a99
12329 3AD0 D80D  30        movb ra,@CNT                    ; STA CNT           ; other, and negative if they are facing the same way
     3AD2 00A4     
12330               
12331               TA15:
12332                                                                          ; If we get here, then one of the following is true:
12333                                                                          ;
12334                                                                          ; * This is an escape pod and XX15 is pointing towards
12335                                                                          ; the planet
12336                                                                          ;
12337                                                                          ; * The ship is pretty close to us, or it's just not
12338                                                                          ; very aggressive (though there is a random factor
12339                                                                          ; at play here too). XX15 is still pointing from our
12340                                                                          ; ship towards the enemy ship
12341                                                                          ;
12342                                                                          ; * The ship is aggressive (though again, there's an
12343                                                                          ; element of randomness here). XX15 is pointing from
12344                                                                          ; the enemy ship towards our ship
12345                                                                          ;
12346                                                                          ; * This is a missile heading for a target. XX15 is
12347                                                                          ; pointing from the missile towards the target
12348                                                                          ;
12349                                                                          ; We now want to move the ship in the direction of XX15,
12350                                                                          ; which will make aggressive ships head towards us, and
12351                                                                          ; ships that are too close turn away. Escape pods,
12352                                                                          ; meanwhile, head off towards the planet in search of a
12353                                                                          ; space station, and missiles home in on their targets
12354 3AD4 020F  20        li   ry,>10*256                 ; LDY #16           ; Set (A X) = roofv . XX15
     3AD6 1000     
12355 3AD8 0200  20        li   rtmp,TAS3                  ; JSR TAS3          ;
     3ADA 452A     
12356 3ADC 06A0  32        bl   @jsr                       ;
     3ADE FE28     
12357                                                                          ; This will be positive if XX15 is pointing in the same
12358                                                                          ; direction as an arrow out of the top of the ship, in
12359                                                                          ; other words if the ship should pull up to head in the
12360                                                                          ; direction of XX15
12361               
12362                      .eoi (>80*256)                  ; EOR #%10000000    ; Set the ship's pitch counter to 3, with the opposite
     **** ****     > EOI
0001 3AE0 0200  20        li   rtmp,(>80*256)
     3AE2 8000     
0002 3AE4 2B40  18        xor  rtmp,ra
                   < elite.a99
12363 3AE6 024D  22        andi ra,>80*256                 ; AND #%10000000    ; sign to the dot product result, which gently pitches
     3AE8 8000     
12364 3AEA 026D  22        ori  ra,>03*256                 ; ORA #%00000011    ; the ship towards the direction of the XX15 vector
     3AEC 0300     
12365 3AEE D80D  30        movb ra,@INWK+30                ; STA INWK+30
     3AF0 0071     
12366               
12367 3AF2 D360  30        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the roll counter from byte #29 into A and clear
     3AF4 0070     
12368 3AF6 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; the sign bit (to give an endless clockwise roll)
     3AF8 7F00     
12369               
12370 3AFA 028D  22        ci   ra,>10*256                 ; CMP #16           ; If A >= 16 then jump to TA6, as the ship is already
     3AFC 1000     
12371 3AFE 1810  14        joc  TA6                        ; BCS TA6           ; in the process of rolling
12372               
12373 3B00 020F  20        li   ry,>16*256                 ; LDY #22           ; Set (A X) = sidev . XX15
     3B02 1600     
12374 3B04 0200  20        li   rtmp,TAS3                  ; JSR TAS3          ;
     3B06 452A     
12375 3B08 06A0  32        bl   @jsr                       ;
     3B0A FE28     
12376                                                                          ; This will be positive if XX15 is pointing in the same
12377                                                                          ; direction as an arrow out of the right side of the
12378                                                                          ; ship, in other words if the ship should roll right to
12379                                                                          ; head in the direction of XX15
12380               
12381                      .eor @INWK+30                   ; EOR INWK+30       ; Set the ship's roll counter to 5, with the sign set to
     **** ****     > EOR
0001 3B0C D020  30        movb @INWK+30,rtmp
     3B0E 0071     
0002 3B10 2B40  18        xor  rtmp,ra
                   < elite.a99
12382 3B12 024D  22        andi ra,>80*256                 ; AND #%10000000    ; positive (clockwise roll) if the pitch counter and dot
     3B14 8000     
12383                      .eoi (>85*256)                  ; EOR #%10000101    ; product have different signs, negative (anti-clockwise
     **** ****     > EOI
0001 3B16 0200  20        li   rtmp,(>85*256)
     3B18 8500     
0002 3B1A 2B40  18        xor  rtmp,ra
                   < elite.a99
12384 3B1C D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; roll) if they have the same sign
     3B1E 0070     
12385               
12386               TA6:
12387 3B20 D360  30        movb @CNT,ra                    ; LDA CNT           ; Fetch the dot product, and if it's negative jump to
     3B22 00A4     
12388 3B24 1109  14        jlt  TA9                        ; BMI TA9           ; TA9, as the ships are facing away from each other and
12389                                                                          ; the ship might want to slow down to take another shot
12390               
12391 3B26 028D  22        ci   ra,>16*256                 ; CMP #22           ; The dot product is positive, so the ships are facing
     3B28 1600     
12392 3B2A 1706  14        jnc  TA9                        ; BCC TA9           ; each other. If A < 22 then the ships are not heading
12393                                                                          ; directly towards each other, so jump to TA9 to slow
12394                                                                          ; down
12395               
12396 3B2C 020D  20        li   ra,>03*256                 ; LDA #3            ; Otherwise set the acceleration in byte #28 to 3
     3B2E 0300     
12397 3B30 D80D  30        movb ra,@INWK+28                ; STA INWK+28
     3B32 006F     
12398               
12399 3B34 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3B36 FE34     
12400               
12401               TA9:
12402 3B38 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit of the dot product in A
     3B3A 7F00     
12403               
12404 3B3C 028D  22        ci   ra,>12*256                 ; CMP #18           ; If A < 18 then the ship is way off the XX15 vector, so
     3B3E 1200     
12405 3B40 170C  14        jnc  TA10                       ; BCC TA10          ; return from the subroutine (TA10 contains an RTS)
12406                                                                          ; without slowing down, as it still has quite a bit of
12407                                                                          ; turning to do to get on course
12408               
12409 3B42 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Otherwise set A = -1
     3B44 FF00     
12410               
12411 3B46 D3A0  30        movb @TYPE,rx                   ; LDX TYPE          ; If this is not a missile then skip the ASL instruction
     3B48 009B     
12412 3B4A 028E  22        ci   rx,(MSL)*256               ; CPX #MSL
     3B4C 0900     
12413 3B4E 1603  14        jne  B36                        ; BNE B36
12414               
12415                      .asla                           ; ASL A             ; This is a missile, so set A = -2, as missiles are more
     **** ****     > ASLA
0001 3B50 024D  22        andi ra,>ff00
     3B52 FF00     
0002 3B54 0A1D  18        sla  ra,1
                   < elite.a99
12416                                                                          ; nimble and can brake more quickly
12417               
12418               B36:
12419 3B56 D80D  30        movb ra,@INWK+28                ; STA INWK+28       ; Set the ship's acceleration to A
     3B58 006F     
12420               
12421               TA10:
12422 3B5A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3B5C FE34     
12423               
12424               * ******************************************************************************
12425               *
12426               * Name: TAS1
12427               * Type: Subroutine
12428               * Category: Maths (Arithmetic)
12429               * Summary: Calculate K3 = (x_sign x_hi x_lo) - V(1 0)
12430               *
12431               * ------------------------------------------------------------------------------
12432               *
12433               * Calculate one of the following, depending on the value in Y:
12434               *
12435               * K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in V(1 0)
12436               *
12437               * K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate in V(1 0)
12438               *
12439               * K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate in V(1 0)
12440               *
12441               * where the first coordinate is from the ship data block in INWK, and the second
12442               * coordinate is from the ship data block pointed to by V(1 0).
12443               *
12444               * ------------------------------------------------------------------------------
12445               *
12446               * Arguments:
12447               *
12448               * V(1 0)              The address of the ship data block to subtract
12449               *
12450               * Y                   The coordinate in the V(1 0) block to subtract:
12451               *
12452               * * If Y = 2, subtract the x-coordinate and store the
12453               * result in K3(2 1 0)
12454               *
12455               * * If Y = 5, subtract the y-coordinate and store the
12456               * result in K3(5 4 3)
12457               *
12458               * * If Y = 8, subtract the z-coordinate and store the
12459               * result in K3(8 7 6)
12460               *
12461               * ******************************************************************************
12462               
12463               TAS1:
12464                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Copy the sign byte of the V(1 0) coordinate into K+3,
     **** ****     > LD_IND_Y_IDX
0001 3B5E D820  42        movb @V,@rtmplb
     3B60 0022     
     3B62 8301     
0002 3B64 D020  30        movb @V+1,rtmp
     3B66 0023     
0003 3B68 06CF  14        swpb ry
0004 3B6A A00F  18        a    ry,rtmp
0005 3B6C 06CF  14        swpb ry
0006 3B6E D350  26        movb *rtmp,RA
                   < elite.a99
12465                      .eoi (>80*256)                  ; EOR #%10000000    ; flipping it in the process
     **** ****     > EOI
0001 3B70 0200  20        li   rtmp,(>80*256)
     3B72 8000     
0002 3B74 2B40  18        xor  rtmp,ra
                   < elite.a99
12466 3B76 D80D  30        movb ra,@K+3                    ; STA K+3
     3B78 0040     
12467               
12468 3B7A 73C7  18        sb   rone,ry                    ; DEY               ; Copy the high byte of the V(1 0) coordinate into K+2
12469                      .ld_ind_y_idx @V,ra             ; LDA (V),Y
     **** ****     > LD_IND_Y_IDX
0001 3B7C D820  42        movb @V,@rtmplb
     3B7E 0022     
     3B80 8301     
0002 3B82 D020  30        movb @V+1,rtmp
     3B84 0023     
0003 3B86 06CF  14        swpb ry
0004 3B88 A00F  18        a    ry,rtmp
0005 3B8A 06CF  14        swpb ry
0006 3B8C D350  26        movb *rtmp,RA
                   < elite.a99
12470 3B8E D80D  30        movb ra,@K+2                    ; STA K+2
     3B90 003F     
12471               
12472 3B92 73C7  18        sb   rone,ry                    ; DEY               ; Copy the high byte of the V(1 0) coordinate into K+1,
12473                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; so now:
     **** ****     > LD_IND_Y_IDX
0001 3B94 D820  42        movb @V,@rtmplb
     3B96 0022     
     3B98 8301     
0002 3B9A D020  30        movb @V+1,rtmp
     3B9C 0023     
0003 3B9E 06CF  14        swpb ry
0004 3BA0 A00F  18        a    ry,rtmp
0005 3BA2 06CF  14        swpb ry
0006 3BA4 D350  26        movb *rtmp,RA
                   < elite.a99
12474 3BA6 D80D  30        movb ra,@K+1                    ; STA K+1           ;
     3BA8 003E     
12475                                                                          ; K(3 2 1) = - coordinate in V(1 0)
12476               
12477 3BAA D80F  30        movb ry,@U                      ; STY U             ; Copy the index (now 0, 3 or 6) into U and X
     3BAC 008F     
12478 3BAE D3A0  30        movb @U,rx                      ; LDX U
     3BB0 008F     
12479               
12480 3BB2 0200  20        li   rtmp,MVT3                  ; JSR MVT3          ; Call MVT3 to add the same coordinates, but this time
     3BB4 1CAC     
12481 3BB6 06A0  32        bl   @jsr                       ;
     3BB8 FE28     
12482                                                                          ; from INWK, so this would look like this for the
12483                                                                          ; x-axis:
12484                                                                          ;
12485                                                                          ; K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
12486                                                                          ; = (x_sign x_hi x_lo) - coordinate in V(1 0)
12487               
12488 3BBA D3E0  30        movb @U,ry                      ; LDY U             ; Restore the index into Y, though this instruction has
     3BBC 008F     
12489                                                                          ; no effect, as Y is not used again, either here or
12490                                                                          ; following calls to this routine
12491               
12492 3BBE DB8D  38        movb ra,@K3+2(rx)               ; STA K3+2,X        ; Store K(3 2 1) in K3+X(2 1 0), starting with the sign
     3BC0 00D4     
12493                                                                          ; byte
12494               
12495 3BC2 D360  30        movb @K+2,ra                    ; LDA K+2           ; And then doing the high byte
     3BC4 003F     
12496 3BC6 DB8D  38        movb ra,@K3+1(rx)               ; STA K3+1,X
     3BC8 00D3     
12497               
12498 3BCA D360  30        movb @K+1,ra                    ; LDA K+1           ; And finally the low byte
     3BCC 003E     
12499 3BCE DB8D  38        movb ra,@K3(rx)                 ; STA K3,X
     3BD0 00D2     
12500               
12501 3BD2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3BD4 FE34     
12502               
12503               * ******************************************************************************
12504               *
12505               * Name: HITCH
12506               * Type: Subroutine
12507               * Category: Tactics
12508               * Summary: Work out if the ship in INWK is in our crosshairs
12509               * Deep dive: In the crosshairs
12510               *
12511               * ------------------------------------------------------------------------------
12512               *
12513               * This is called by the main flight loop to see if we have laser or missile lock
12514               * on an enemy ship.
12515               *
12516               * ------------------------------------------------------------------------------
12517               *
12518               * Returns:
12519               *
12520               * C flag              Set if the ship is in our crosshairs, clear if it isn't
12521               *
12522               * ------------------------------------------------------------------------------
12523               *
12524               * Other entry points:
12525               *
12526               * HI1                 Contains an RTS
12527               *
12528               * ******************************************************************************
12529               
12530               HITCH:
12531                      .clc                            ; CLC               ; Clear the C flag so we can return with it cleared if
     **** ****     > CLC
0001 3BD6 0A16  18        sla  rzero,1
                   < elite.a99
12532                                                                          ; our checks fail
12533               
12534 3BD8 D360  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set A = z_sign
     3BDA 005B     
12535               
12536 3BDC 164B  14        jne  HI1                        ; BNE HI1           ; If A is non-zero then the ship is behind us and can't
12537                                                                          ; be in our crosshairs, so return from the subroutine
12538                                                                          ; with the C flag clear (as HI1 contains an RTS)
12539               
12540 3BDE D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type has bit 7 set then it is the planet
     3BE0 009B     
12541 3BE2 1148  14        jlt  HI1                        ; BMI HI1           ; or sun, which we can't target or hit with lasers, so
12542                                                                          ; return from the subroutine with the C flag clear (as
12543                                                                          ; HI1 contains an RTS)
12544               
12545 3BE4 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch bit 5 of byte #31 (the exploding flag) and OR
     3BE6 0072     
12546 3BE8 024D  22        andi ra,>20*256                 ; AND #%00100000    ; with x_hi and y_hi
     3BEA 2000     
12547 3BEC F360  30        socb @INWK+1,ra                 ; ORA INWK+1
     3BEE 0054     
12548 3BF0 F360  30        socb @INWK+4,ra                 ; ORA INWK+4
     3BF2 0057     
12549               
12550 3BF4 163F  14        jne  HI1                        ; BNE HI1           ; If this value is non-zero then either the ship is
12551                                                                          ; exploding (so we can't target it), or the ship is too
12552                                                                          ; far away from our line of fire to be targeted, so
12553                                                                          ; return from the subroutine with the C flag clear (as
12554                                                                          ; HI1 contains an RTS)
12555               
12556 3BF6 D360  30        movb @INWK,ra                   ; LDA INWK          ; Set A = x_lo
     3BF8 0053     
12557               
12558 3BFA 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A = x_lo^2
     3BFC 436E     
12559 3BFE 06A0  32        bl   @jsr                       ;
     3C00 FE28     
12560               
12561 3C02 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P) = x_lo^2
     3C04 0092     
12562 3C06 D360  30        movb @P,ra                      ; LDA P
     3C08 001B     
12563 3C0A D80D  30        movb ra,@R                      ; STA R
     3C0C 0091     
12564               
12565 3C0E D360  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set A = y_lo
     3C10 0056     
12566               
12567 3C12 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A = y_lo^2
     3C14 436E     
12568 3C16 06A0  32        bl   @jsr                       ;
     3C18 FE28     
12569               
12570 3C1A D38D  18        movb ra,rx                      ; TAX               ; Store the high byte in X
12571               
12572 3C1C D360  30        movb @P,ra                      ; LDA P             ; Add the two low bytes, so:
     3C1E 001B     
12573                      .adc @R,ra                      ; ADC R             ;
     **** ****     > ADC
0001 3C20 1701  14        jnc  !
0002 3C22 B347  18        ab   rone,ra
0003               !:
0004 3C24 B360  30        ab   @R,ra
     3C26 0091     
                   < elite.a99
12574 3C28 D80D  30        movb ra,@R                      ; STA R             ; R = P + R
     3C2A 0091     
12575               
12576 3C2C D34E  18        movb rx,ra                      ; TXA               ; Restore the high byte into A and add S to give the
12577                      .adc @S,ra                      ; ADC S             ; following:
     **** ****     > ADC
0001 3C2E 1701  14        jnc  !
0002 3C30 B347  18        ab   rone,ra
0003               !:
0004 3C32 B360  30        ab   @S,ra
     3C34 0092     
                   < elite.a99
12578                                                                          ;
12579                                                                          ; (A R) = (S R) + (A P) = x_lo^2 + y_lo^2
12580               
12581 3C36 1702  14        jnc  FIX002                     ; BCC FIX002        ; If the addition just overflowed then there is no way
12582                                                                          ; our crosshairs are within the ship's targetable area,
12583                                                                          ; so return from the subroutine with the C flag clear
12584                                                                          ; (as FR1-2 contains a CLC then an RTS)
12585 3C38 0460  28        b    @FR1-2                     ; JMP FR1-2
     3C3A 3DA0     
12586               FIX002:
12587 3C3C D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P) = x_lo^2 + y_lo^2
     3C3E 0092     
12588               
12589 3C40 020F  20        li   ry,>02*256                 ; LDY #2            ; Fetch the ship's blueprint and set A to the high byte
     3C42 0200     
12590                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; of the targetable area of the ship
     **** ****     > LD_IND_Y_IDX
0001 3C44 D820  42        movb @XX0,@rtmplb
     3C46 001E     
     3C48 8301     
0002 3C4A D020  30        movb @XX0+1,rtmp
     3C4C 001F     
0003 3C4E 06CF  14        swpb ry
0004 3C50 A00F  18        a    ry,rtmp
0005 3C52 06CF  14        swpb ry
0006 3C54 D350  26        movb *rtmp,RA
                   < elite.a99
12591               
12592 3C56 9360  30        cb   @S,ra                      ; CMP S             ; We now compare the high bytes of the targetable area
     3C58 0092     
12593                                                                          ; and the calculation in (S R):
12594                                                                          ;
12595                                                                          ; * If A >= S then then the C flag will be set
12596                                                                          ;
12597                                                                          ; * If A < S then the C flag will be C clear
12598               
12599 3C5A 160C  14        jne  HI1                        ; BNE HI1           ; If A <> S we have just set the C flag correctly, so
12600                                                                          ; return from the subroutine (as HI1 contains an RTS)
12601               
12602 3C5C 73C7  18        sb   rone,ry                    ; DEY               ; The high bytes were identical, so now we fetch the
12603                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; low byte of the targetable area into A
     **** ****     > LD_IND_Y_IDX
0001 3C5E D820  42        movb @XX0,@rtmplb
     3C60 001E     
     3C62 8301     
0002 3C64 D020  30        movb @XX0+1,rtmp
     3C66 001F     
0003 3C68 06CF  14        swpb ry
0004 3C6A A00F  18        a    ry,rtmp
0005 3C6C 06CF  14        swpb ry
0006 3C6E D350  26        movb *rtmp,RA
                   < elite.a99
12604               
12605 3C70 9360  30        cb   @R,ra                      ; CMP R             ; We now compare the low bytes of the targetable area
     3C72 0091     
12606                                                                          ; and the calculation in (S R):
12607                                                                          ;
12608                                                                          ; * If A >= R then the C flag will be set
12609                                                                          ;
12610                                                                          ; * If A < R then the C flag will be C clear
12611               
12612               HI1:
12613 3C74 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3C76 FE34     
12614               
12615               * ******************************************************************************
12616               *
12617               * Name: FRS1
12618               * Type: Subroutine
12619               * Category: Tactics
12620               * Summary: Launch a ship straight ahead of us, below the laser sights
12621               *
12622               * ------------------------------------------------------------------------------
12623               *
12624               * This is used in two places:
12625               *
12626               * * When we launch a missile, in which case the missile is the ship that is
12627               * launched ahead of us
12628               *
12629               * * When we launch our escape pod, in which case it's our abandoned Cobra Mk
12630               * III that is launched ahead of us
12631               *
12632               * * The fq1 entry point is used to launch a bunch of cargo canisters ahead of
12633               * us as part of the death screen
12634               *
12635               * ------------------------------------------------------------------------------
12636               *
12637               * Arguments:
12638               *
12639               * X                   The type of ship to launch ahead of us
12640               *
12641               * ------------------------------------------------------------------------------
12642               *
12643               * Returns:
12644               *
12645               * C flag              Set if the ship was successfully launched, clear if it
12646               * wasn't (as there wasn't enough free memory)
12647               *
12648               * ------------------------------------------------------------------------------
12649               *
12650               * Other entry points:
12651               *
12652               * fq1                 Used to add a cargo canister to the universe
12653               *
12654               * ******************************************************************************
12655               
12656               FRS1:
12657 3C78 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     3C7A C064     
12658 3C7C 06A0  32        bl   @jsr                       ;
     3C7E FE28     
12659               
12660 3C80 020D  20        li   ra,>1c*256                 ; LDA #28           ; Set y_lo = 28
     3C82 1C00     
12661 3C84 D80D  30        movb ra,@INWK+3                 ; STA INWK+3
     3C86 0056     
12662               
12663 3C88 091D  18        srl  ra,1                       ; LSR A             ; Set z_lo = 14, so the launched ship starts out
12664 3C8A D80D  30        movb ra,@INWK+6                 ; STA INWK+6        ; ahead of us
     3C8C 0059     
12665               
12666 3C8E 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set y_sign to be negative, so the launched ship is
     3C90 8000     
12667 3C92 D80D  30        movb ra,@INWK+5                 ; STA INWK+5        ; launched just below our line of sight
     3C94 0058     
12668               
12669 3C96 D360  30        movb @MSTG,ra                   ; LDA MSTG          ; Set A to the missile lock target, shifted left so the
     3C98 0052     
12670                      .asla                           ; ASL A             ; slot number is in bits 1-5
     **** ****     > ASLA
0001 3C9A 024D  22        andi ra,>ff00
     3C9C FF00     
0002 3C9E 0A1D  18        sla  ra,1
                   < elite.a99
12671               
12672 3CA0 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 and store the result in byte #32, the AI
     3CA2 8000     
12673 3CA4 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; flag launched ship for the launched ship. For missiles
     3CA6 0073     
12674                                                                          ; this enables AI (bit 7), makes it friendly towards us
12675                                                                          ; (bit 6), sets the target to the value of MSTG (bits
12676                                                                          ; 1-5), and sets its lock status as launched (bit 0).
12677                                                                          ; It doesn't matter what it does for our abandoned
12678                                                                          ; Cobra, as the AI flag gets overwritten once we return
12679                                                                          ; from the subroutine back to the ESCAPE routine that
12680                                                                          ; called FRS1 in the first place
12681               
12682               fq1_:
12683 3CA8 020D  20        li   ra,>60*256                 ; LDA #&60          ; Set byte #14 (nosev_z_hi) to 1 (&60), so the launched
     3CAA 6000     
12684 3CAC D80D  30        movb ra,@INWK+14                ; STA INWK+14       ; ship is pointing away from us
     3CAE 0061     
12685               
12686 3CB0 026D  22        ori  ra,>80*256                 ; ORA #128          ; Set byte #22 (sidev_x_hi) to -1 (&D0), so the launched
     3CB2 8000     
12687 3CB4 D80D  30        movb ra,@INWK+22                ; STA INWK+22       ; ship has the same orientation as spawned ships, just
     3CB6 0069     
12688                                                                          ; pointing away from us (if we set sidev to +1 instead,
12689                                                                          ; this ship would be a mirror image of all the other
12690                                                                          ; ships, which are spawned with -1 in nosev and +1 in
12691                                                                          ; sidev)
12692               
12693 3CB8 D360  30        movb @DELTA,ra                  ; LDA DELTA         ; Set byte #27 (speed) to 2 * DELTA, so the launched
     3CBA 008C     
12694 3CBC 06A0  32        bl   @rola                      ; ROL A             ; ship flies off at twice our speed
     3CBE FE3E     
12695 3CC0 D80D  30        movb ra,@INWK+27                ; STA INWK+27
     3CC2 006E     
12696               
12697 3CC4 D34E  18        movb rx,ra                      ; TXA               ; Add a new ship of type X to our local bubble of
12698 3CC6 0460  28        b    @NWSHP                     ; JMP NWSHP         ; universe and return from the subroutine using a tail
     3CC8 AFC6     
12699                                                                          ; call
12700               
12701               * ******************************************************************************
12702               *
12703               * Name: FRMIS
12704               * Type: Subroutine
12705               * Category: Tactics
12706               * Summary: Fire a missile from our ship
12707               *
12708               * ------------------------------------------------------------------------------
12709               *
12710               * We fired a missile, so send it streaking away from us to unleash mayhem and
12711               * destruction on our sworn enemies.
12712               *
12713               * ******************************************************************************
12714               
12715               FRMIS:
12716 3CCA 020E  20        li   rx,(MSL)*256               ; LDX #MSL          ; Call FRS1 to launch a missile straight ahead of us
     3CCC 0900     
12717 3CCE 0200  20        li   rtmp,FRS1                  ; JSR FRS1
     3CD0 3C78     
12718 3CD2 06A0  32        bl   @jsr                       ;
     3CD4 FE28     
12719               
12720 3CD6 1765  14        jnc  FR1                        ; BCC FR1           ; If FRS1 returns with the C flag clear, then there
12721                                                                          ; isn't room in the universe for our missile, so jump
12722                                                                          ; down to FR1 to display a "missile jammed" message
12723               
12724 3CD8 D3A0  30        movb @MSTG,rx                   ; LDX MSTG          ; Fetch the slot number of the missile's target
     3CDA 0052     
12725               
12726 3CDC 0200  20        li   rtmp,GINF                  ; JSR GINF          ; Get the address of the data block for the target ship
     3CDE AF58     
12727 3CE0 06A0  32        bl   @jsr                       ;
     3CE2 FE28     
12728                                                                          ; and store it in INF
12729               
12730 3CE4 D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the ship type of the missile's target into A
     3CE6 0D40     
12731               
12732 3CE8 0200  20        li   rtmp,ANGRY                 ; JSR ANGRY         ; Call ANGRY to make the target ship hostile
     3CEA 3D06     
12733 3CEC 06A0  32        bl   @jsr                       ;
     3CEE FE28     
12734               
12735 3CF0 020F  20        li   ry,>00*256                 ; LDY #0            ; We have just launched a missile, so we need to remove
     3CF2 0000     
12736 3CF4 0200  20        li   rtmp,ABORT                 ; JSR ABORT         ; missile lock and hide the leftmost indicator on the
     3CF6 B0FE     
12737 3CF8 06A0  32        bl   @jsr                       ;
     3CFA FE28     
12738                                                                          ; dashboard by setting it to black (Y = 0)
12739               
12740 3CFC 7347  18        sb   rone,ra                    ; DEC NOMSL         ; Reduce the number of missiles we have by 1
12741               
12742 3CFE 020D  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     3D00 3000     
12743 3D02 0460  28        b    @NOISE                     ; JMP NOISE         ; of a missile launch, returning from the subroutine
     3D04 CC5C     
12744                                                                          ; using a tail call
12745               
12746               * ******************************************************************************
12747               *
12748               * Name: ANGRY
12749               * Type: Subroutine
12750               * Category: Tactics
12751               * Summary: Make a ship hostile
12752               *
12753               * ------------------------------------------------------------------------------
12754               *
12755               * All this routine does is set the ship's hostile flag, start it turning and
12756               * give it a kick of acceleration - later calls to TACTICS will make the ship
12757               * start to attack us.
12758               *
12759               * ------------------------------------------------------------------------------
12760               *
12761               * Arguments:
12762               *
12763               * A                   The type of ship we're going to irritate
12764               *
12765               * INF                 The address of the data block for the ship we're going
12766               * to infuriate
12767               *
12768               * ******************************************************************************
12769               
12770               ANGRY:
12771 3D06 028D  22        ci   ra,(SST)*256               ; CMP #SST          ; If this is the space station, jump to AN2 to make the
     3D08 0800     
12772 3D0A 133C  14        jeq  AN2                        ; BEQ AN2           ; space station hostile
12773               
12774 3D0C 18B3  14        joc  HI1                        ; BCS HI1           ; If A >= #SST then this is a missile, asteroid, cargo
12775                                                                          ; canister, Thargon or escape pod, and they can't get
12776                                                                          ; hostile, so return from the subroutine (as HI1
12777                                                                          ; contains an RTS)
12778               
12779 3D0E 028D  22        ci   ra,(CYL)*256               ; CMP #CYL          ; If this is not a Cobra Mk III trader, skip the
     3D10 0700     
12780 3D12 1604  14        jne  B37                        ; BNE B37           ; following instruction
12781               
12782 3D14 0200  20        li   rtmp,AN2                   ; JSR AN2           ; Call AN2 to make the space station hostile
     3D16 3D84     
12783 3D18 06A0  32        bl   @jsr                       ;
     3D1A FE28     
12784               
12785               B37:
12786 3D1C 020F  20        li   ry,>20*256                 ; LDY #32           ; Fetch the ship's byte #32 (AI flag)
     3D1E 2000     
12787                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y
     **** ****     > LD_IND_Y_IDX
0001 3D20 D820  42        movb @INF,@rtmplb
     3D22 0020     
     3D24 8301     
0002 3D26 D020  30        movb @INF+1,rtmp
     3D28 0021     
0003 3D2A 06CF  14        swpb ry
0004 3D2C A00F  18        a    ry,rtmp
0005 3D2E 06CF  14        swpb ry
0006 3D30 D350  26        movb *rtmp,RA
                   < elite.a99
12788               
12789 3D32 13A0  14        jeq  HI1                        ; BEQ HI1           ; If the AI flag is zero then this ship has no AI and
12790                                                                          ; it can't get hostile, so return from the subroutine
12791                                                                          ; (as HI1 contains an RTS)
12792               
12793 3D34 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Otherwise set bit 7 (AI enabled) to ensure AI is
     3D36 8000     
12794                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; definitely enabled
     **** ****     > ST_IND_Y_IDX
0001 3D38 D820  42        movb @INF,@rtmplb
     3D3A 0020     
     3D3C 8301     
0002 3D3E D020  30        movb @INF+1,rtmp
     3D40 0021     
0003 3D42 06CF  14        swpb ry
0004 3D44 A00F  18        a    ry,rtmp
0005 3D46 06CF  14        swpb ry
0006 3D48 D40D  30        movb RA,*rtmp
                   < elite.a99
12795               
12796 3D4A 020F  20        li   ry,>1c*256                 ; LDY #28           ; Set the ship's byte #28 (acceleration) to 2, so it
     3D4C 1C00     
12797 3D4E 020D  20        li   ra,>02*256                 ; LDA #2            ; speeds up
     3D50 0200     
12798                      .st_ind_y_idx @INF,ra           ; STA (INF),Y
     **** ****     > ST_IND_Y_IDX
0001 3D52 D820  42        movb @INF,@rtmplb
     3D54 0020     
     3D56 8301     
0002 3D58 D020  30        movb @INF+1,rtmp
     3D5A 0021     
0003 3D5C 06CF  14        swpb ry
0004 3D5E A00F  18        a    ry,rtmp
0005 3D60 06CF  14        swpb ry
0006 3D62 D40D  30        movb RA,*rtmp
                   < elite.a99
12799               
12800                      .asla                           ; ASL A             ; Set the ship's byte #30 (pitch counter) to 4, so it
     **** ****     > ASLA
0001 3D64 024D  22        andi ra,>ff00
     3D66 FF00     
0002 3D68 0A1D  18        sla  ra,1
                   < elite.a99
12801 3D6A 020F  20        li   ry,>1e*256                 ; LDY #30           ; starts diving
     3D6C 1E00     
12802                      .st_ind_y_idx @INF,ra           ; STA (INF),Y
     **** ****     > ST_IND_Y_IDX
0001 3D6E D820  42        movb @INF,@rtmplb
     3D70 0020     
     3D72 8301     
0002 3D74 D020  30        movb @INF+1,rtmp
     3D76 0021     
0003 3D78 06CF  14        swpb ry
0004 3D7A A00F  18        a    ry,rtmp
0005 3D7C 06CF  14        swpb ry
0006 3D7E D40D  30        movb RA,*rtmp
                   < elite.a99
12803               
12804 3D80 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3D82 FE34     
12805               
12806               AN2:
12807                      .asl @K.+NI.+32                 ; ASL K%+NI%+32     ; Fetch the AI counter (byte #32) of the second ship
     **** ****     > ASL
0001 3D84 D020  30        movb @K.+NI.+32,rtmp
     3D86 0944     
0002 3D88 0240  22        andi rtmp,>ff00
     3D8A FF00     
0003 3D8C 0A10  18        sla  rtmp,1
0004 3D8E D800  30        movb rtmp,@K.+NI.+32
     3D90 0944     
                   < elite.a99
12808                      .sec                            ; SEC               ; in the ship data workspace at K%, which is reserved
     **** ****     > SEC
0001 3D92 0A18  18        sla  rmone,1
                   < elite.a99
12809 3D94 0204  20        li   rarg1,K.+NI.+32            ; ROR K%+NI%+32     ; for the sun or the space station (in this case it's
     3D96 0944     
12810 3D98 06A0  32        bl   @ror                       ;
     3D9A FE7A     
12811                                                                          ; the latter), and set bit 7 to make it hostile
12812               
12813                      .clc                            ; CLC               ; Clear the C flag, which isn't used by calls to this
     **** ****     > CLC
0001 3D9C 0A16  18        sla  rzero,1
                   < elite.a99
12814                                                                          ; routine, but it does set up the entry point FR1-2
12815                                                                          ; so that it clears the C flag and does an RTS
12816               
12817 3D9E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3DA0 FE34     
12818               
12819               * ******************************************************************************
12820               *
12821               * Name: FR1
12822               * Type: Subroutine
12823               * Category: Tactics
12824               * Summary: Display the "missile jammed" message
12825               *
12826               * ------------------------------------------------------------------------------
12827               *
12828               * This is shown if there isn't room in the local bubble of universe for a new
12829               * missile.
12830               *
12831               * ------------------------------------------------------------------------------
12832               *
12833               * Other entry points:
12834               *
12835               * FR1-2               Clear the C flag and return from the subroutine
12836               *
12837               * ******************************************************************************
12838               
12839               FR1:
12840 3DA2 020D  20        li   ra,>c9*256                 ; LDA #201          ; Print recursive token 41 ("MISSILE JAMMED") as an
     3DA4 C900     
12841 3DA6 0460  28        b    @MESS                      ; JMP MESS          ; in-flight message and return from the subroutine using
     3DA8 CF0E     
12842                                                                          ; a tail call
12843               
12844               * ******************************************************************************
12845               *
12846               * Name: SESCP
12847               * Type: Subroutine
12848               * Category: Flight
12849               * Summary: Spawn an escape pod from the current (parent) ship
12850               *
12851               * ------------------------------------------------------------------------------
12852               *
12853               * This is called when an enemy ship has run out of both energy and luck, so it's
12854               * time to bail.
12855               *
12856               * ******************************************************************************
12857               
12858               SESCP:
12859 3DAA 020E  20        li   rx,(ESC)*256               ; LDX #ESC          ; Set X to the ship type for an escape pod
     3DAC 0D00     
12860               
12861 3DAE 020D  20        li   ra,>fe*256                 ; LDA #%11111110    ; Set A to an AI flag that has AI enabled, is hostile,
     3DB0 FE00     
12862                                                                          ; but has no E.C.M.
12863               
12864                                                                          ; Fall through into SFS1 to spawn the escape pod
12865               
12866               * ******************************************************************************
12867               *
12868               * Name: SFS1
12869               * Type: Subroutine
12870               * Category: Universe
12871               * Summary: Spawn a child ship from the current (parent) ship
12872               *
12873               * ------------------------------------------------------------------------------
12874               *
12875               * If the parent is a space station then the child ship is spawned coming out of
12876               * the slot, and if the child is a cargo canister, it is sent tumbling through
12877               * space. Otherwise the child ship is spawned with the same ship data as the
12878               * parent, just with damping disabled and the ship type and AI flag that are
12879               * passed in A and X.
12880               *
12881               * ------------------------------------------------------------------------------
12882               *
12883               * Arguments:
12884               *
12885               * A                   AI flag for the new ship (see the documentation on ship
12886               * data byte #32 for details)
12887               *
12888               * X                   The ship type of the child to spawn
12889               *
12890               * INF                 Address of the parent's ship data block
12891               *
12892               * TYPE                The type of the parent ship
12893               *
12894               * ------------------------------------------------------------------------------
12895               *
12896               * Returns:
12897               *
12898               * C flag              Set if ship successfully added, clear if it failed
12899               *
12900               * INF                 INF is preserved
12901               *
12902               * XX0                 XX0 is preserved
12903               *
12904               * INWK                The whole INWK workspace is preserved
12905               *
12906               * ------------------------------------------------------------------------------
12907               *
12908               * Other entry points:
12909               *
12910               * SFS1-2              Add a missile to the local bubble that has AI enabled,
12911               * is hostile, but has no E.C.M.
12912               *
12913               * ******************************************************************************
12914               
12915               SFS1:
12916 3DB2 D80D  30        movb ra,@T1                     ; STA T1            ; Store the child ship's AI flag in T1
     3DB4 0006     
12917               
12918                                                                          ; Before spawning our child ship, we need to save the
12919                                                                          ; INF and XX00 variables and the whole INWK workspace,
12920                                                                          ; so we can restore them later when returning from the
12921                                                                          ; subroutine
12922               
12923 3DB6 D360  30        movb @XX0,ra                    ; LDA XX0           ; Store XX0(1 0) on the stack, so we can restore it
     3DB8 001E     
12924                      .pha                            ; PHA               ; later when returning from the subroutine
     **** ****     > PHA
0001 3DBA D68D  30        movb ra,*rsp
0002 3DBC 060A  14        dec  rsp
                   < elite.a99
12925 3DBE D360  30        movb @XX0+1,ra                  ; LDA XX0+1
     3DC0 001F     
12926                      .pha                            ; PHA
     **** ****     > PHA
0001 3DC2 D68D  30        movb ra,*rsp
0002 3DC4 060A  14        dec  rsp
                   < elite.a99
12927               
12928 3DC6 D360  30        movb @INF,ra                    ; LDA INF           ; Store INF(1 0) on the stack, so we can restore it
     3DC8 0020     
12929                      .pha                            ; PHA               ; later when returning from the subroutine
     **** ****     > PHA
0001 3DCA D68D  30        movb ra,*rsp
0002 3DCC 060A  14        dec  rsp
                   < elite.a99
12930 3DCE D360  30        movb @INF+1,ra                  ; LDA INF+1
     3DD0 0021     
12931                      .pha                            ; PHA
     **** ****     > PHA
0001 3DD2 D68D  30        movb ra,*rsp
0002 3DD4 060A  14        dec  rsp
                   < elite.a99
12932               
12933 3DD6 020F  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; Now we want to store the current INWK data block in
     3DD8 2300     
12934                                                                          ; temporary memory so we can restore it when we are
12935                                                                          ; done, and we also want to copy the parent's ship data
12936                                                                          ; into INWK, which we can do at the same time, so set up
12937                                                                          ; a counter in Y for NI% bytes
12938               
12939               FRL2:
12940 3DDA D36F  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Copy the Y-th byte of INWK to the Y-th byte of
     3DDC 0053     
12941 3DDE DBCD  38        movb ra,@XX3(ry)                ; STA XX3,Y         ; temporary memory in XX3, so we can restore it later
     3DE0 0100     
12942                                                                          ; when returning from the subroutine
12943               
12944                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Copy the Y-th byte of the parent ship's data block to
     **** ****     > LD_IND_Y_IDX
0001 3DE2 D820  42        movb @INF,@rtmplb
     3DE4 0020     
     3DE6 8301     
0002 3DE8 D020  30        movb @INF+1,rtmp
     3DEA 0021     
0003 3DEC 06CF  14        swpb ry
0004 3DEE A00F  18        a    ry,rtmp
0005 3DF0 06CF  14        swpb ry
0006 3DF2 D350  26        movb *rtmp,RA
                   < elite.a99
12945 3DF4 DBCD  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; the Y-th byte of INWK
     3DF6 0053     
12946               
12947 3DF8 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
12948               
12949 3DFA 15EF  14        jgt  FRL2                       ; BPL FRL2          ; Loop back to copy the next byte until we have done
12950                                                                          ; them all
12951               
12952                                                                          ; INWK now contains the ship data for the parent ship,
12953                                                                          ; so now we need to tweak the data before creating the
12954                                                                          ; new child ship (in this way, the child inherits things
12955                                                                          ; like location from the parent)
12956               
12957 3DFC D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship type of the parent into A
     3DFE 009B     
12958               
12959 3E00 028D  22        ci   ra,(SST)*256               ; CMP #SST          ; If the parent is not a space station, jump to rx to
     3E02 0800     
12960 3E04 1622  14        jne  rx_                        ; BNE rx            ; skip the following
12961               
12962                                                                          ; The parent is a space station, so the child needs to
12963                                                                          ; launch out of the space station's slot. The space
12964                                                                          ; station's nosev vector points out of the station's
12965                                                                          ; slot, so we want to move the ship along this vector.
12966                                                                          ; We do this by taking the unit vector in nosev and
12967                                                                          ; doubling it, so we spawn our ship 2 units along the
12968                                                                          ; vector from the space station's centre
12969               
12970 3E06 D34E  18        movb rx,ra                      ; TXA               ; Store the child's ship type in X on the stack
12971                      .pha                            ; PHA
     **** ****     > PHA
0001 3E08 D68D  30        movb ra,*rsp
0002 3E0A 060A  14        dec  rsp
                   < elite.a99
12972               
12973 3E0C 020D  20        li   ra,>20*256                 ; LDA #32           ; Set the child's byte #27 (speed) to 32
     3E0E 2000     
12974 3E10 D80D  30        movb ra,@INWK+27                ; STA INWK+27
     3E12 006E     
12975               
12976 3E14 020E  20        li   rx,>00*256                 ; LDX #0            ; Add 2 * nosev_x_hi to (x_lo, x_hi, x_sign) to get the
     3E16 0000     
12977 3E18 D360  30        movb @INWK+10,ra                ; LDA INWK+10       ; child's x-coordinate
     3E1A 005D     
12978 3E1C 0200  20        li   rtmp,SFS2                  ; JSR SFS2
     3E1E 3EDA     
12979 3E20 06A0  32        bl   @jsr                       ;
     3E22 FE28     
12980               
12981 3E24 020E  20        li   rx,>03*256                 ; LDX #3            ; Add 2 * nosev_y_hi to (y_lo, y_hi, y_sign) to get the
     3E26 0300     
12982 3E28 D360  30        movb @INWK+12,ra                ; LDA INWK+12       ; child's y-coordinate
     3E2A 005F     
12983 3E2C 0200  20        li   rtmp,SFS2                  ; JSR SFS2
     3E2E 3EDA     
12984 3E30 06A0  32        bl   @jsr                       ;
     3E32 FE28     
12985               
12986 3E34 020E  20        li   rx,>06*256                 ; LDX #6            ; Add 2 * nosev_z_hi to (z_lo, z_hi, z_sign) to get the
     3E36 0600     
12987 3E38 D360  30        movb @INWK+14,ra                ; LDA INWK+14       ; child's z-coordinate
     3E3A 0061     
12988 3E3C 0200  20        li   rtmp,SFS2                  ; JSR SFS2
     3E3E 3EDA     
12989 3E40 06A0  32        bl   @jsr                       ;
     3E42 FE28     
12990               
12991                      .pla                            ; PLA               ; Restore the child's ship type from the stack into X
     **** ****     > PLA
0001 3E44 058A  14        inc  rsp
0002 3E46 D35A  26        movb *rsp,ra
                   < elite.a99
12992 3E48 D38D  18        movb ra,rx                      ; TAX
12993               
12994               rx_:
12995 3E4A D360  30        movb @T1,ra                     ; LDA T1            ; Restore the child ship's AI flag from T1 and store it
     3E4C 0006     
12996 3E4E D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; in the child's byte #32 (AI)
     3E50 0073     
12997               
12998                      .lsr @INWK+29                   ; LSR INWK+29       ; Clear bit 0 of the child's byte #29 (roll counter) so
     **** ****     > LSR
0001 3E52 D020  30        movb @INWK+29,rtmp
     3E54 0070     
0002 3E56 0910  18        srl  rtmp,1
0003 3E58 D800  30        movb rtmp,@INWK+29
     3E5A 0070     
                   < elite.a99
12999                      .asl @INWK+29                   ; ASL INWK+29       ; that its roll dampens (so if we are spawning from a
     **** ****     > ASL
0001 3E5C D020  30        movb @INWK+29,rtmp
     3E5E 0070     
0002 3E60 0240  22        andi rtmp,>ff00
     3E62 FF00     
0003 3E64 0A10  18        sla  rtmp,1
0004 3E66 D800  30        movb rtmp,@INWK+29
     3E68 0070     
                   < elite.a99
13000                                                                          ; space station, for example, the spawned ship won't
13001                                                                          ; keep rolling forever)
13002               
13003 3E6A D34E  18        movb rx,ra                      ; TXA               ; Copy the child's ship type from X into A
13004               
13005 3E6C 028D  22        ci   ra,(OIL)*256               ; CMP #OIL          ; If the child we are spawning is not a cargo canister,
     3E6E 0B00     
13006 3E70 1616  14        jne  NOIL                       ; BNE NOIL          ; jump to NOIL to skip us setting up the pitch and roll
13007                                                                          ; for the canister
13008               
13009 3E72 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3E74 C120     
13010 3E76 06A0  32        bl   @jsr                       ;
     3E78 FE28     
13011               
13012                      .asla                           ; ASL A             ; Set the child's byte #30 (pitch counter) to a random
     **** ****     > ASLA
0001 3E7A 024D  22        andi ra,>ff00
     3E7C FF00     
0002 3E7E 0A1D  18        sla  ra,1
                   < elite.a99
13013 3E80 D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; value, and at the same time set the C flag randomly
     3E82 0071     
13014               
13015 3E84 D34E  18        movb rx,ra                      ; TXA               ; Set the child's byte #27 (speed) to a random value
13016 3E86 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; between 0 and 15
     3E88 0F00     
13017 3E8A D80D  30        movb ra,@INWK+27                ; STA INWK+27
     3E8C 006E     
13018               
13019 3E8E 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set the child's byte #29 (roll counter) to a full
     3E90 FF00     
13020 3E92 06A0  32        bl   @rora                      ; ROR A             ; roll with no damping (as bits 0 to 6 are set), so the
     3E94 FE62     
13021 3E96 D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; canister tumbles through space, with the direction in
     3E98 0070     
13022                                                                          ; bit 7 set randomly, depending on the C flag from above
13023               
13024 3E9A 020D  20        li   ra,(OIL)*256               ; LDA #OIL          ; Set A to the ship type of a cargo canister
     3E9C 0B00     
13025               
13026               NOIL:
13027 3E9E 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Add a new ship of type A to the local bubble
     3EA0 AFC6     
13028 3EA2 06A0  32        bl   @jsr                       ;
     3EA4 FE28     
13029               
13030                                                                          ; We have now created our child ship, so we need to
13031                                                                          ; restore all the variables we saved at the start of
13032                                                                          ; the routine, so they are preserved when we return
13033                                                                          ; from the subroutine
13034               
13035                      .pla                            ; PLA               ; Restore INF(1 0) from the stack
     **** ****     > PLA
0001 3EA6 058A  14        inc  rsp
0002 3EA8 D35A  26        movb *rsp,ra
                   < elite.a99
13036 3EAA D80D  30        movb ra,@INF+1                  ; STA INF+1
     3EAC 0021     
13037                      .pla                            ; PLA
     **** ****     > PLA
0001 3EAE 058A  14        inc  rsp
0002 3EB0 D35A  26        movb *rsp,ra
                   < elite.a99
13038 3EB2 D80D  30        movb ra,@INF                    ; STA INF
     3EB4 0020     
13039               
13040 3EB6 020E  20        li   rx,(NI.-1)*256             ; LDX #NI%-1        ; Now to restore the INWK workspace that we saved into
     3EB8 2300     
13041                                                                          ; XX3 above, so set a counter in X for NI% bytes
13042               
13043               FRL3:
13044 3EBA D36E  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Copy the Y-th byte of XX3 to the Y-th byte of INWK
     3EBC 0100     
13045 3EBE DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X
     3EC0 0053     
13046               
13047 3EC2 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
13048               
13049 3EC4 15FA  14        jgt  FRL3                       ; BPL FRL3          ; Loop back to copy the next byte until we have done
13050                                                                          ; them all
13051               
13052                      .pla                            ; PLA               ; Restore XX0(1 0) from the stack
     **** ****     > PLA
0001 3EC6 058A  14        inc  rsp
0002 3EC8 D35A  26        movb *rsp,ra
                   < elite.a99
13053 3ECA D80D  30        movb ra,@XX0+1                  ; STA XX0+1
     3ECC 001F     
13054                      .pla                            ; PLA
     **** ****     > PLA
0001 3ECE 058A  14        inc  rsp
0002 3ED0 D35A  26        movb *rsp,ra
                   < elite.a99
13055 3ED2 D80D  30        movb ra,@XX0                    ; STA XX0
     3ED4 001E     
13056               
13057 3ED6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3ED8 FE34     
13058               
13059               * ******************************************************************************
13060               *
13061               * Name: SFS2
13062               * Type: Subroutine
13063               * Category: Moving
13064               * Summary: Move a ship in space along one of the coordinate axes
13065               *
13066               * ------------------------------------------------------------------------------
13067               *
13068               * Move a ship's coordinates by a certain amount in the direction of one of the
13069               * axes, where X determines the axis. Mathematically speaking, this routine
13070               * translates the ship along a single axis by a signed delta.
13071               *
13072               * ------------------------------------------------------------------------------
13073               *
13074               * Arguments:
13075               *
13076               * A                   The amount of movement, i.e. the signed delta
13077               *
13078               * X                   Determines which coordinate axis of INWK to move:
13079               *
13080               * * X = 0 moves the ship along the x-axis
13081               *
13082               * * X = 3 moves the ship along the y-axis
13083               *
13084               * * X = 6 moves the ship along the z-axis
13085               *
13086               * ******************************************************************************
13087               
13088               SFS2:
13089                      .asla                           ; ASL A             ; Set R = |A * 2|, with the C flag set to bit 7 of A
     **** ****     > ASLA
0001 3EDA 024D  22        andi ra,>ff00
     3EDC FF00     
0002 3EDE 0A1D  18        sla  ra,1
                   < elite.a99
13090 3EE0 D80D  30        movb ra,@R                      ; STA R
     3EE2 0091     
13091               
13092 3EE4 020D  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 of A to the C flag, i.e. the sign bit from
     3EE6 0000     
13093 3EE8 06A0  32        bl   @rora                      ; ROR A             ; the original argument in A
     3EEA FE62     
13094               
13095 3EEC 0460  24        b    @MVT1                      ; JMP MVT1          ; Add the delta R with sign A to (x_lo, x_hi, x_sign)
     3EEE 1BCE     
13096                                                                          ; (or y or z, depending on the value in X) and return
13097                                                                          ; from the subroutine using a tail call
13098               
13099               * ******************************************************************************
13100               *
13101               * Name: LL164
13102               * Type: Subroutine
13103               * Category: Drawing circles
13104               * Summary: Make the hyperspace sound and draw the hyperspace tunnel
13105               *
13106               * ------------------------------------------------------------------------------
13107               *
13108               * See the IRQ1 routine for details on the multi-coloured effect that's used.
13109               *
13110               * ******************************************************************************
13111               
13112               LL164:
13113 3EF0 020D  20        li   ra,>38*256                 ; LDA #56           ; Call the NOISE routine with A = 56 to make the sound
     3EF2 3800     
13114 3EF4 0200  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the hyperspace drive being engaged
     3EF6 CC5C     
13115 3EF8 06A0  32        bl   @jsr                       ;
     3EFA FE28     
13116               
13117 3EFC 020D  20        li   ra,>01*256                 ; LDA #1            ; Set HFX to 1, which switches the screen mode to a full
     3EFE 0100     
13118 3F00 D80D  30        movb ra,@HFX                    ; STA HFX           ; mode 5 screen, therefore making the hyperspace rings
     3F02 0D62     
13119                                                                          ; multi-coloured and all zig-zaggy (see the IRQ1 routine
13120                                                                          ; for details)
13121               
13122 3F04 020D  20        li   ra,>04*256                 ; LDA #4            ; Set the step size for the hyperspace rings to 4, so
     3F06 0400     
13123                                                                          ; there are more sections in the rings and they are
13124                                                                          ; quite round (compared to the step size of 8 used in
13125                                                                          ; the much more polygonal launch rings)
13126               
13127 3F08 0200  20        li   rtmp,HFS2                  ; JSR HFS2          ; Call HFS2 to draw the hyperspace tunnel rings
     3F0A 3F26     
13128 3F0C 06A0  32        bl   @jsr                       ;
     3F0E FE28     
13129               
13130 3F10 7347  18        sb   rone,ra                    ; DEC HFX           ; Set HFX back to 0, so we switch back to the normal
13131                                                                          ; split-screen mode
13132               
13133 3F12 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3F14 FE34     
13134               
13135               * ******************************************************************************
13136               *
13137               * Name: LAUN
13138               * Type: Subroutine
13139               * Category: Drawing circles
13140               * Summary: Make the launch sound and draw the launch tunnel
13141               *
13142               * ------------------------------------------------------------------------------
13143               *
13144               * This is shown when launching from or docking with the space station.
13145               *
13146               * ******************************************************************************
13147               
13148               LAUN:
13149 3F16 020D  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     3F18 3000     
13150 3F1A 0200  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the ship launching from the station
     3F1C CC5C     
13151 3F1E 06A0  32        bl   @jsr                       ;
     3F20 FE28     
13152               
13153 3F22 020D  20        li   ra,>08*256                 ; LDA #8            ; Set the step size for the launch tunnel rings to 8, so
     3F24 0800     
13154                                                                          ; there are fewer sections in the rings and they are
13155                                                                          ; quite polygonal (compared to the step size of 4 used
13156                                                                          ; in the much rounder hyperspace rings)
13157               
13158                                                                          ; Fall through into HFS2 to draw the launch tunnel rings
13159               
13160               * ******************************************************************************
13161               *
13162               * Name: HFS2
13163               * Type: Subroutine
13164               * Category: Drawing circles
13165               * Summary: Draw the launch or hyperspace tunnel
13166               *
13167               * ------------------------------------------------------------------------------
13168               *
13169               * The animation gets drawn like this. First, we draw a circle of radius 8 at the
13170               * centre, and then double the radius, draw another circle, double the radius
13171               * again and draw a circle, and we keep doing this until the radius is bigger
13172               * than 160 (which goes beyond the edge of the screen, which is 256 pixels wide,
13173               * equivalent to a radius of 128). We then repeat this whole process for an
13174               * initial circle of radius 9, then radius 10, all the way up to radius 15.
13175               *
13176               * This has the effect of making the tunnel appear to be racing towards us as we
13177               * hurtle out into hyperspace or through the space station's docking tunnel.
13178               *
13179               * The hyperspace effect is done in a full mode 5 screen, which makes the rings
13180               * all coloured and zig-zaggy, while the launch screen is in the normal
13181               * monochrome mode 4 screen.
13182               *
13183               * ------------------------------------------------------------------------------
13184               *
13185               * Arguments:
13186               *
13187               * A                   The step size of the straight lines making up the rings
13188               * (4 for launch, 8 for hyperspace)
13189               *
13190               * ******************************************************************************
13191               
13192               HFS2:
13193 3F26 D80D  30        movb ra,@STP                    ; STA STP           ; Store the step size in A
     3F28 00A6     
13194               
13195 3F2A 0200  20        li   rtmp,TTX66                 ; JSR TTX66         ; Clear the screen and draw a white border
     3F2C 4BE2     
13196 3F2E 06A0  32        bl   @jsr                       ;
     3F30 FE28     
13197               
13198 3F32 0200  20        li   rtmp,HFS1                  ; JSR HFS1          ; Call HFS1 below and then fall through into the same
     3F34 3F3A     
13199 3F36 06A0  32        bl   @jsr                       ;
     3F38 FE28     
13200                                                                          ; routine, so this effectively runs HFS1 twice, and as
13201                                                                          ; HFS1 draws 8 concentric rings, this means we draw 16
13202                                                                          ; of them in all
13203               
13204               HFS1:
13205 3F3A 020D  20        li   ra,>80*256                 ; LDA #128          ; Set K3 = 128 (the x-coordinate of the centre of the
     3F3C 8000     
13206 3F3E D80D  30        movb ra,@K3                     ; STA K3            ; screen)
     3F40 00D2     
13207               
13208 3F42 020E  20        li   rx,(Y)*256                 ; LDX #Y            ; Set K4 = #Y (the y-coordinate of the centre of the
     3F44 6000     
13209 3F46 D80E  30        movb rx,@K4                     ; STX K4            ; screen)
     3F48 00E0     
13210               
13211                      .asla                           ; ASL A             ; Set A = 0
     **** ****     > ASLA
0001 3F4A 024D  22        andi ra,>ff00
     3F4C FF00     
0002 3F4E 0A1D  18        sla  ra,1
                   < elite.a99
13212               
13213 3F50 D80D  30        movb ra,@XX4                    ; STA XX4           ; Set XX4 = 0, which we will use as a counter for
     3F52 00A7     
13214                                                                          ; drawing eight concentric rings
13215               
13216 3F54 D80D  30        movb ra,@K3+1                   ; STA K3+1          ; Set the high bytes of K3(1 0) and K4(1 0) to 0
     3F56 00D3     
13217 3F58 D80D  30        movb ra,@K4+1                   ; STA K4+1
     3F5A 00E1     
13218               
13219               HFL5:
13220 3F5C 0200  20        li   rtmp,HFL1                  ; JSR HFL1          ; Call HFL1 below to draw a set of rings, with each one
     3F5E 3F74     
13221 3F60 06A0  32        bl   @jsr                       ;
     3F62 FE28     
13222                                                                          ; twice the radius of the previous one, until they won't
13223                                                                          ; fit on-screen
13224               
13225 3F64 B347  18        ab   rone,ra                    ; INC XX4           ; Increment the counter and fetch it into X
13226 3F66 D3A0  30        movb @XX4,rx                    ; LDX XX4
     3F68 00A7     
13227               
13228 3F6A 028E  22        ci   rx,>08*256                 ; CPX #8            ; If we haven't drawn 8 sets of rings yet, loop back to
     3F6C 0800     
13229 3F6E 16F6  14        jne  HFL5                       ; BNE HFL5          ; HFL5 to draw the next ring
13230               
13231 3F70 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3F72 FE34     
13232               
13233               HFL1:
13234 3F74 D360  30        movb @XX4,ra                    ; LDA XX4           ; Set K to the ring number in XX4 (0-7) + 8, so K has
     3F76 00A7     
13235 3F78 024D  22        andi ra,>07*256                 ; AND #7            ; a value of 8 to 15, which we will use as the starting
     3F7A 0700     
13236                      .clc                            ; CLC               ; radius for our next set of rings
     **** ****     > CLC
0001 3F7C 0A16  18        sla  rzero,1
                   < elite.a99
13237                      .adi (>08*256)                  ; ADC #8
     **** ****     > ADI
0001 3F7E 1701  14        jnc  !
0002 3F80 B347  18        ab   rone,ra
0003               !:
0004 3F82 022D  22        ai   ra,(>08*256)
     3F84 0800     
                   < elite.a99
13238 3F86 D80D  30        movb ra,@K                      ; STA K
     3F88 003D     
13239               
13240               HFL2:
13241 3F8A 020D  20        li   ra,>01*256                 ; LDA #1            ; Set LSP = 1 to reset the ball line heap
     3F8C 0100     
13242 3F8E D80D  30        movb ra,@LSP                    ; STA LSP
     3F90 0077     
13243               
13244 3F92 0200  20        li   rtmp,CIRCLE2               ; JSR CIRCLE2       ; Call CIRCLE2 to draw a circle with the centre at
     3F94 B88C     
13245 3F96 06A0  32        bl   @jsr                       ;
     3F98 FE28     
13246                                                                          ; (K3(1 0), K4(1 0)) and radius K
13247               
13248                      .asl @K                         ; ASL K             ; Double the radius in K
     **** ****     > ASL
0001 3F9A D020  30        movb @K,rtmp
     3F9C 003D     
0002 3F9E 0240  22        andi rtmp,>ff00
     3FA0 FF00     
0003 3FA2 0A10  18        sla  rtmp,1
0004 3FA4 D800  30        movb rtmp,@K
     3FA6 003D     
                   < elite.a99
13249               
13250 3FA8 1805  14        joc  HF8                        ; BCS HF8           ; If the radius had a 1 in bit 7 before the above shift,
13251                                                                          ; then doubling K will means the circle will no longer
13252                                                                          ; fit on the screen (which is width 256), so jump to
13253                                                                          ; HF8 to stop drawing circles
13254               
13255 3FAA D360  30        movb @K,ra                      ; LDA K             ; If the radius in K <= 160, loop back to HFL2 to draw
     3FAC 003D     
13256 3FAE 028D  22        ci   ra,>a0*256                 ; CMP #160          ; another one
     3FB0 A000     
13257 3FB2 17EB  14        jnc  HFL2                       ; BCC HFL2
13258               
13259               HF8:
13260 3FB4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3FB6 FE34     
13261               
13262               * ******************************************************************************
13263               *
13264               * Name: STARS2
13265               * Type: Subroutine
13266               * Category: Stardust
13267               * Summary: Process the stardust for the left or right view
13268               * Deep dive: Stardust in the side views
13269               *
13270               * ------------------------------------------------------------------------------
13271               *
13272               * This moves the stardust sideways according to our speed and which side we are
13273               * looking out of, and applies our current pitch and roll to each particle of
13274               * dust, so the stardust moves correctly when we steer our ship.
13275               *
13276               * These are the calculations referred to in the commentary:
13277               *
13278               * 1. delta_x = 8 * 256 * speed / z_hi
13279               * 2. x = x + delta_x
13280               *
13281               * 3. x = x + beta * y
13282               * 4. y = y - beta * x
13283               *
13284               * 5. x = x - alpha * x * y
13285               * 6. y = y + alpha * y * y + alpha
13286               *
13287               * For more information see the deep dive on "Stardust in the side views".
13288               *
13289               * ------------------------------------------------------------------------------
13290               *
13291               * Arguments:
13292               *
13293               * X                   The view to process:
13294               *
13295               * * X = 1 for left view
13296               *
13297               * * X = 2 for right view
13298               *
13299               * ******************************************************************************
13300               
13301               STARS2:
13302 3FB8 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can use it to capture a sign bit
     3FBA 0000     
13303               
13304 3FBC 028E  22        ci   rx,>02*256                 ; CPX #2            ; If X >= 2 then the C flag is set
     3FBE 0200     
13305               
13306 3FC0 06A0  32        bl   @rora                      ; ROR A             ; Roll the C flag into the sign bit of A and store in
     3FC2 FE62     
13307 3FC4 D80D  30        movb ra,@RAT                    ; STA RAT           ; RAT, so:
     3FC6 00AA     
13308                                                                          ;
13309                                                                          ; * Left view, C is clear so RAT = 0 (positive)
13310                                                                          ;
13311                                                                          ; * Right view, C is set so RAT = 128 (negative)
13312                                                                          ;
13313                                                                          ; RAT represents the end of the x-axis where we want new
13314                                                                          ; stardust particles to come from: positive for the left
13315                                                                          ; view where new particles come in from the right,
13316                                                                          ; negative for the right view where new particles come
13317                                                                          ; in from the left
13318               
13319                      .eoi (>80*256)                  ; EOR #%10000000    ; Set RAT2 to the opposite sign, so:
     **** ****     > EOI
0001 3FC8 0200  20        li   rtmp,(>80*256)
     3FCA 8000     
0002 3FCC 2B40  18        xor  rtmp,ra
                   < elite.a99
13320 3FCE D80D  30        movb ra,@RAT2                   ; STA RAT2          ;
     3FD0 00AB     
13321                                                                          ; * Left view, RAT2 = 128 (negative)
13322                                                                          ;
13323                                                                          ; * Right view, RAT2 = 0 (positive)
13324                                                                          ;
13325                                                                          ; RAT2 represents the direction in which stardust
13326                                                                          ; particles should move along the x-axis: negative for
13327                                                                          ; the left view where particles go from right to left,
13328                                                                          ; positive for the right view where particles go from
13329                                                                          ; left to right
13330               
13331 3FD2 0200  20        li   rtmp,ST2                   ; JSR ST2           ; Call ST2 to flip the signs of the following if this is
     3FD4 412C     
13332 3FD6 06A0  32        bl   @jsr                       ;
     3FD8 FE28     
13333                                                                          ; the right view: ALPHA, ALP2, ALP2+1, BET2 and BET2+1
13334               
13335 3FDA D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     3FDC 0F33     
13336                                                                          ; we can use it as a counter through all the stardust
13337               
13338               STL2:
13339 3FDE D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Set A = ZZ = z_hi
     3FE0 0EE8     
13340               
13341 3FE2 D80D  30        movb ra,@ZZ                     ; STA ZZ            ; We also set ZZ to the original value of z_hi, which we
     3FE4 0097     
13342                                                                          ; use below to remove the existing particle
13343               
13344 3FE6 091D  18        srl  ra,1                       ; LSR A             ; Set A = z_hi / 8
13345 3FE8 091D  18        srl  ra,1                       ; LSR A
13346 3FEA 091D  18        srl  ra,1                       ; LSR A
13347               
13348 3FEC 0200  20        li   rtmp,DV41                  ; JSR DV41          ; Call DV41 to set the following:
     3FEE 465C     
13349 3FF0 06A0  32        bl   @jsr                       ;
     3FF2 FE28     
13350                                                                          ;
13351                                                                          ; (P R) = 256 * DELTA / A
13352                                                                          ; = 256 * speed / (z_hi / 8)
13353                                                                          ; = 8 * 256 * speed / z_hi
13354                                                                          ;
13355                                                                          ; This represents the distance we should move this
13356                                                                          ; particle along the x-axis, let's call it delta_x
13357               
13358 3FF4 D360  30        movb @P,ra                      ; LDA P             ; Set S = P but with the sign from RAT2, so we now have
     3FF6 001B     
13359                      .eor @RAT2                      ; EOR RAT2          ; the distance delta_x with the correct sign in (S R):
     **** ****     > EOR
0001 3FF8 D020  30        movb @RAT2,rtmp
     3FFA 00AB     
0002 3FFC 2B40  18        xor  rtmp,ra
                   < elite.a99
13360 3FFE D80D  30        movb ra,@S                      ; STA S             ;
     4000 0092     
13361                                                                          ; (S R) = delta_x
13362                                                                          ; = 8 * 256 * speed / z_hi
13363                                                                          ;
13364                                                                          ; So (S R) is the delta, signed to match the direction
13365                                                                          ; the stardust should move in, which is result 1 above
13366               
13367 4002 D36F  34        movb @SXL(ry),ra                ; LDA SXL,Y         ; Set (A P) = (x_hi x_lo)
     4004 035F     
13368 4006 D80D  30        movb ra,@P                      ; STA P             ; = x
     4008 001B     
13369 400A D36F  34        movb @SX(ry),ra                 ; LDA SX,Y
     400C 034C     
13370               
13371 400E D80D  30        movb ra,@X1                     ; STA X1            ; Set X1 = A, so X1 contains the original value of x_hi,
     4010 0031     
13372                                                                          ; which we use below to remove the existing particle
13373               
13374 4012 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     4014 456E     
13375 4016 06A0  32        bl   @jsr                       ;
     4018 FE28     
13376                                                                          ;
13377                                                                          ; (A X) = (A P) + (S R)
13378                                                                          ; = x + delta_x
13379               
13380 401A D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     401C 0092     
13381 401E D80E  30        movb rx,@R                      ; STX R             ; = x + delta_x
     4020 0091     
13382               
13383 4022 D36F  34        movb @SY(ry),ra                 ; LDA SY,Y          ; Set A = y_hi
     4024 0EC2     
13384               
13385 4026 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 = A, so Y1 contains the original value of y_hi,
     4028 0032     
13386                                                                          ; which we use below to remove the existing particle
13387               
13388                      .eor @BET2                      ; EOR BET2          ; Give A the correct sign of A * beta, i.e. y_hi * beta
     **** ****     > EOR
0001 402A D020  30        movb @BET2,rtmp
     402C 008A     
0002 402E 2B40  18        xor  rtmp,ra
                   < elite.a99
13389               
13390 4030 D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch |beta| from BET1, the pitch angle
     4032 002B     
13391               
13392 4034 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     4036 42A8     
13393 4038 06A0  32        bl   @jsr                       ;
     403A FE28     
13394                                                                          ;
13395                                                                          ; (A P) = X * A
13396                                                                          ; = beta * y_hi
13397               
13398 403C 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     403E 456E     
13399 4040 06A0  32        bl   @jsr                       ;
     4042 FE28     
13400                                                                          ;
13401                                                                          ; (A X) = (A P) + (S R)
13402                                                                          ; = beta * y + x + delta_x
13403               
13404 4044 D80E  30        movb rx,@XX                     ; STX XX            ; Set XX(1 0) = (A X), which gives us results 2 and 3
     4046 0024     
13405 4048 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; above, done at the same time:
     404A 0025     
13406                                                                          ;
13407                                                                          ; x = x + delta_x + beta * y
13408               
13409 404C D3AF  34        movb @SYL(ry),rx                ; LDX SYL,Y         ; Set (S R) = (y_hi y_lo)
     404E 0ED5     
13410 4050 D80E  30        movb rx,@R                      ; STX R             ; = y
     4052 0091     
13411 4054 D3A0  30        movb @Y1,rx                     ; LDX Y1
     4056 0032     
13412 4058 D80E  30        movb rx,@S                      ; STX S
     405A 0092     
13413               
13414 405C D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch |beta| from BET1, the pitch angle
     405E 002B     
13415               
13416                      .eor @BET2+1                    ; EOR BET2+1        ; Give A the opposite sign to x * beta
     **** ****     > EOR
0001 4060 D020  30        movb @BET2+1,rtmp
     4062 008B     
0002 4064 2B40  18        xor  rtmp,ra
                   < elite.a99
13417               
13418 4066 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     4068 42A8     
13419 406A 06A0  32        bl   @jsr                       ;
     406C FE28     
13420                                                                          ;
13421                                                                          ; (A P) = X * A
13422                                                                          ; = -beta * x
13423               
13424 406E 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     4070 456E     
13425 4072 06A0  32        bl   @jsr                       ;
     4074 FE28     
13426                                                                          ;
13427                                                                          ; (A X) = (A P) + (S R)
13428                                                                          ; = -beta * x + y
13429               
13430 4076 D80E  30        movb rx,@YY                     ; STX YY            ; Set YY(1 0) = (A X), which gives us result 4 above:
     4078 0026     
13431 407A D80D  30        movb ra,@YY+1                   ; STA YY+1          ;
     407C 0027     
13432                                                                          ; y = y - beta * x
13433               
13434 407E D3A0  30        movb @ALP1,rx                   ; LDX ALP1          ; Set X = |alpha| from ALP2, the roll angle
     4080 0087     
13435               
13436                      .eor @ALP2                      ; EOR ALP2          ; Give A the correct sign of A * alpha, i.e. y_hi *
     **** ****     > EOR
0001 4082 D020  30        movb @ALP2,rtmp
     4084 0088     
0002 4086 2B40  18        xor  rtmp,ra
                   < elite.a99
13437                                                                          ; alpha
13438               
13439 4088 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     408A 42A8     
13440 408C 06A0  32        bl   @jsr                       ;
     408E FE28     
13441                                                                          ;
13442                                                                          ; (A P) = X * A
13443                                                                          ; = alpha * y
13444               
13445 4090 D80D  30        movb ra,@Q                      ; STA Q             ; Set Q = high byte of alpha * y
     4092 0090     
13446               
13447 4094 D360  30        movb @XX,ra                     ; LDA XX            ; Set (S R) = XX(1 0)
     4096 0024     
13448 4098 D80D  30        movb ra,@R                      ; STA R             ; = x
     409A 0091     
13449 409C D360  30        movb @XX+1,ra                   ; LDA XX+1          ;
     409E 0025     
13450 40A0 D80D  30        movb ra,@S                      ; STA S             ; and set A = y_hi at the same time
     40A2 0092     
13451               
13452                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A = -x_hi
     **** ****     > EOI
0001 40A4 0200  20        li   rtmp,(>80*256)
     40A6 8000     
0002 40A8 2B40  18        xor  rtmp,ra
                   < elite.a99
13453               
13454 40AA 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Call MAD to calculate:
     40AC 4566     
13455 40AE 06A0  32        bl   @jsr                       ;
     40B0 FE28     
13456                                                                          ;
13457                                                                          ; (A X) = Q * A + (S R)
13458                                                                          ; = alpha * y * -x + x
13459               
13460 40B2 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     40B4 0025     
13461               
13462 40B6 D34E  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
13463 40B8 DBCD  38        movb ra,@SXL(ry)                ; STA SXL,Y
     40BA 035F     
13464               
13465                                                                          ; So (XX+1 x_lo) now contains result 5 above:
13466                                                                          ;
13467                                                                          ; x = x - alpha * x * y
13468               
13469 40BC D360  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0)
     40BE 0026     
13470 40C0 D80D  30        movb ra,@R                      ; STA R             ; = y
     40C2 0091     
13471 40C4 D360  30        movb @YY+1,ra                   ; LDA YY+1          ;
     40C6 0027     
13472 40C8 D80D  30        movb ra,@S                      ; STA S             ; and set A = y_hi at the same time
     40CA 0092     
13473               
13474 40CC 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Call MAD to calculate:
     40CE 4566     
13475 40D0 06A0  32        bl   @jsr                       ;
     40D2 FE28     
13476                                                                          ;
13477                                                                          ; (A X) = Q * A + (S R)
13478                                                                          ; = alpha * y * y_hi + y
13479               
13480 40D4 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     40D6 0092     
13481 40D8 D80E  30        movb rx,@R                      ; STX R             ; = y + alpha * y * y
     40DA 0091     
13482               
13483 40DC 020D  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     40DE 0000     
13484 40E0 D80D  30        movb ra,@P                      ; STA P
     40E2 001B     
13485               
13486 40E4 D360  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set A = alpha, so:
     40E6 009E     
13487                                                                          ;
13488                                                                          ; (A P) = (alpha 0)
13489                                                                          ; = alpha / 256
13490               
13491 40E8 0200  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     40EA 27A2     
13492 40EC 06A0  32        bl   @jsr                       ;
     40EE FE28     
13493                                                                          ;
13494                                                                          ; (YY+1 y_lo) = (A P) + (S R)
13495                                                                          ; = alpha * 256 + y + alpha * y * y
13496                                                                          ;
13497                                                                          ; i.e. y = y + alpha / 256 + alpha * y^2, which is
13498                                                                          ; result 6 above
13499                                                                          ;
13500                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
13501                                                                          ; ZZ, which will remove the old stardust particle, as we
13502                                                                          ; set X1, Y1 and ZZ to the original values for this
13503                                                                          ; particle during the calculations above
13504               
13505                                                                          ; We now have our newly moved stardust particle at
13506                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
13507                                                                          ; and distance z_hi, so we draw it if it's still on
13508                                                                          ; screen, otherwise we recycle it as a new bit of
13509                                                                          ; stardust and draw that
13510               
13511 40F0 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     40F2 0025     
13512 40F4 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; the new x-coordinate is in (x_hi x_lo) and the high
     40F6 034C     
13513 40F8 D80D  30        movb ra,@X1                     ; STA X1            ; byte is in X1
     40FA 0031     
13514               
13515 40FC 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |x_hi| >= 116 then jump to KILL2 to recycle this
     40FE 7F00     
13516 4100 028D  22        ci   ra,>74*256                 ; CMP #116          ; particle, as it's gone off the side of the screen,
     4102 7400     
13517 4104 1834  14        joc  KILL2                      ; BCS KILL2         ; and rejoin at STC2 with the new particle
13518               
13519 4106 D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     4108 0027     
13520 410A DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     410C 0EC2     
13521 410E D80D  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     4110 0032     
13522               
13523 4112 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 116 then jump to ST5 to recycle this
     4114 7F00     
13524 4116 028D  22        ci   ra,>74*256                 ; CMP #116          ; particle, as it's gone off the top or bottom of the
     4118 7400     
13525 411A 183A  14        joc  ST5                        ; BCS ST5           ; screen, and rejoin at STC2 with the new particle
13526               
13527               STC2:
13528 411C 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     411E 27B4     
13529 4120 06A0  32        bl   @jsr                       ;
     4122 FE28     
13530                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
13531                                                                          ; with distance z_hi
13532               
13533 4124 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
13534                                                                          ; stardust particle
13535               
13536 4126 1302  14        jeq  ST2                        ; BEQ ST2           ; If we have just done the last particle, skip the next
13537                                                                          ; instruction to return from the subroutine
13538               
13539 4128 0460  28        b    @STL2                      ; JMP STL2          ; We have more stardust to process, so jump back up to
     412A 3FDE     
13540                                                                          ; STL2 for the next particle
13541               
13542                                                                          ; Fall through into ST2 to restore the signs of the
13543                                                                          ; following if this is the right view: ALPHA, ALP2,
13544                                                                          ; ALP2+1, BET2 and BET2+1
13545               
13546               ST2:
13547 412C D360  30        movb @ALPHA,ra                  ; LDA ALPHA         ; If this is the right view, flip the sign of ALPHA
     412E 009E     
13548                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 4130 D020  30        movb @RAT,rtmp
     4132 00AA     
0002 4134 2B40  18        xor  rtmp,ra
                   < elite.a99
13549 4136 D80D  30        movb ra,@ALPHA                  ; STA ALPHA
     4138 009E     
13550               
13551 413A D360  30        movb @ALP2,ra                   ; LDA ALP2          ; If this is the right view, flip the sign of ALP2
     413C 0088     
13552                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 413E D020  30        movb @RAT,rtmp
     4140 00AA     
0002 4142 2B40  18        xor  rtmp,ra
                   < elite.a99
13553 4144 D80D  30        movb ra,@ALP2                   ; STA ALP2
     4146 0088     
13554               
13555                      .eoi (>80*256)                  ; EOR #%10000000    ; If this is the right view, flip the sign of ALP2+1
     **** ****     > EOI
0001 4148 0200  20        li   rtmp,(>80*256)
     414A 8000     
0002 414C 2B40  18        xor  rtmp,ra
                   < elite.a99
13556 414E D80D  30        movb ra,@ALP2+1                 ; STA ALP2+1
     4150 0089     
13557               
13558 4152 D360  30        movb @BET2,ra                   ; LDA BET2          ; If this is the right view, flip the sign of BET2
     4154 008A     
13559                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 4156 D020  30        movb @RAT,rtmp
     4158 00AA     
0002 415A 2B40  18        xor  rtmp,ra
                   < elite.a99
13560 415C D80D  30        movb ra,@BET2                   ; STA BET2
     415E 008A     
13561               
13562                      .eoi (>80*256)                  ; EOR #%10000000    ; If this is the right view, flip the sign of BET2+1
     **** ****     > EOI
0001 4160 0200  20        li   rtmp,(>80*256)
     4162 8000     
0002 4164 2B40  18        xor  rtmp,ra
                   < elite.a99
13563 4166 D80D  30        movb ra,@BET2+1                 ; STA BET2+1
     4168 008B     
13564               
13565 416A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     416C FE34     
13566               
13567               KILL2:
13568 416E 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     4170 C120     
13569 4172 06A0  32        bl   @jsr                       ;
     4174 FE28     
13570               
13571 4176 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to random numbers, so the particle
     4178 0032     
13572 417A DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; starts anywhere along the y-axis
     417C 0EC2     
13573               
13574 417E 020D  20        li   ra,>73*256                 ; LDA #115          ; Make sure A is at least 115 and has the sign in RAT
     4180 7300     
13575 4182 F360  30        socb @RAT,ra                    ; ORA RAT
     4184 00AA     
13576               
13577 4186 D80D  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to A, so this particle starts on the
     4188 0031     
13578 418A DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; correct edge of the screen for new particles
     418C 034C     
13579               
13580 418E 1610  14        jne  STF1                       ; BNE STF1          ; Jump down to STF1 to set the z-coordinate (this BNE is
13581                                                                          ; effectively a JMP as A will never be zero)
13582               
13583               ST5:
13584 4190 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     4192 C120     
13585 4194 06A0  32        bl   @jsr                       ;
     4196 FE28     
13586               
13587 4198 D80D  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to random numbers, so the particle
     419A 0031     
13588 419C DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; starts anywhere along the x-axis
     419E 034C     
13589               
13590 41A0 020D  20        li   ra,>6e*256                 ; LDA #110          ; Make sure A is at least 110 and has the sign in AL2+1,
     41A2 6E00     
13591 41A4 F360  30        socb @ALP2+1,ra                 ; ORA ALP2+1        ; the flipped sign of the roll angle alpha
     41A6 0089     
13592               
13593 41A8 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to A, so the particle starts at the
     41AA 0032     
13594 41AC DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; top or bottom edge, depending on the current roll
     41AE 0EC2     
13595                                                                          ; angle alpha
13596               
13597               STF1:
13598 41B0 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     41B2 C120     
13599 41B4 06A0  32        bl   @jsr                       ;
     41B6 FE28     
13600               
13601 41B8 026D  22        ori  ra,>08*256                 ; ORA #8            ; Make sure A is at least 8 and store it in z_hi and
     41BA 0800     
13602 41BC D80D  30        movb ra,@ZZ                     ; STA ZZ            ; ZZ, so the new particle starts at any distance from
     41BE 0097     
13603 41C0 DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; us, but not too close
     41C2 0EE8     
13604               
13605 41C4 16AB  14        jne  STC2                       ; BNE STC2          ; Jump up to STC2 to draw this new particle (this BNE is
13606                                                                          ; effectively a JMP as A will never be zero)
13607               
13608               * ******************************************************************************
13609               *
13610               * Name: SNE
13611               * Type: Variable
13612               * Category: Maths (Geometry)
13613               * Summary: Sine/cosine table
13614               * Deep dive: The sine, cosine and arctan tables
13615               * Drawing circles
13616               * Drawing ellipses
13617               *
13618               * ------------------------------------------------------------------------------
13619               *
13620               * This lookup table contains sine values for the first half of a circle, from 0
13621               * to 180 degrees (0 to PI radians). In terms of circle or ellipse line segments,
13622               * there are 64 segments in a circle, so this contains sine values for segments
13623               * 0 to 31.
13624               *
13625               * In terms of segments, to calculate the sine of the angle at segment x, we look
13626               * up the value in SNE + x, and to calculate the cosine of the angle we look up
13627               * the value in SNE + ((x + 16) mod 32).
13628               *
13629               * In terms of radians, to calculate the following:
13630               *
13631               * sin(theta) * 256
13632               *
13633               * where theta is in radians, we look up the value in:
13634               *
13635               * SNE + (theta * 10)
13636               *
13637               * To calculate the following:
13638               *
13639               * cos(theta) * 256
13640               *
13641               * where theta is in radians, look up the value in:
13642               *
13643               * SNE + ((theta * 10) + 16) mod 32
13644               *
13645               * Theta must be between 0 and 3.1 radians, so theta * 10 is between 0 and 31.
13646               *
13647               * ******************************************************************************
13648               
13649               SNE:
13650                      ; FOR I%, 0, 31
13651               
13652                      ; N = ABS(SIN((I% / 64) * 2 * PI)) ;
13653               
13654                      ; IF N >= 1                     ;
13655                      ; B% = 255                      ;
13656                      ; ELSE                          ;
13657                      ; B% = INT(256 * N + 0.5)       ;
13658                      ; ENDIF                         ;
13659               
13660                      ; EQUB B%                       ;
13661               
13662                      ; NEXT
13663               
13664 41C6 00              byte >00
13665 41C7   19            byte >19
13666 41C8 32              byte >32
13667 41C9   4A            byte >4a
13668 41CA 62              byte >62
13669 41CB   79            byte >79
13670 41CC 8E              byte >8e
13671 41CD   A2            byte >a2
13672 41CE B5              byte >b5
13673 41CF   C6            byte >c6
13674 41D0 D5              byte >d5
13675 41D1   E2            byte >e2
13676 41D2 ED              byte >ed
13677 41D3   F5            byte >f5
13678 41D4 FB              byte >fb
13679 41D5   FF            byte >ff
13680 41D6 FF              byte >ff
13681 41D7   FF            byte >ff
13682 41D8 FB              byte >fb
13683 41D9   F5            byte >f5
13684 41DA ED              byte >ed
13685 41DB   E2            byte >e2
13686 41DC D5              byte >d5
13687 41DD   C6            byte >c6
13688 41DE B5              byte >b5
13689 41DF   A2            byte >a2
13690 41E0 8E              byte >8e
13691 41E1   79            byte >79
13692 41E2 62              byte >62
13693 41E3   4A            byte >4a
13694 41E4 32              byte >32
13695 41E5   19            byte >19
13696               
13697               * ******************************************************************************
13698               *
13699               * Name: MU5
13700               * Type: Subroutine
13701               * Category: Maths (Arithmetic)
13702               * Summary: Set K(3 2 1 0) = (A A A A) and clear the C flag
13703               *
13704               * ------------------------------------------------------------------------------
13705               *
13706               * In practice this is only called via a BEQ following an AND instruction, in
13707               * which case A = 0, so this routine effectively does this:
13708               *
13709               * K(3 2 1 0) = 0
13710               *
13711               * ******************************************************************************
13712               
13713               MU5:
13714 41E6 D80D  30        movb ra,@K                      ; STA K             ; Set K(3 2 1 0) to (A A A A)
     41E8 003D     
13715 41EA D80D  30        movb ra,@K+1                    ; STA K+1
     41EC 003E     
13716 41EE D80D  30        movb ra,@K+2                    ; STA K+2
     41F0 003F     
13717 41F2 D80D  30        movb ra,@K+3                    ; STA K+3
     41F4 0040     
13718               
13719                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 41F6 0A16  18        sla  rzero,1
                   < elite.a99
13720               
13721 41F8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     41FA FE34     
13722               
13723               * ******************************************************************************
13724               *
13725               * Name: MULT3
13726               * Type: Subroutine
13727               * Category: Maths (Arithmetic)
13728               * Summary: Calculate K(3 2 1 0) = (A P+1 P) * Q
13729               * Deep dive: Shift-and-add multiplication
13730               *
13731               * ------------------------------------------------------------------------------
13732               *
13733               * Calculate the following multiplication between a signed 24-bit number and a
13734               * signed 8-bit number, returning the result as a signed 32-bit number:
13735               *
13736               * K(3 2 1 0) = (A P+1 P) * Q
13737               *
13738               * The algorithm is the same shift-and-add algorithm as in routine MULT1, but
13739               * extended to cope with more bits.
13740               *
13741               * ------------------------------------------------------------------------------
13742               *
13743               * Returns:
13744               *
13745               * C flag              The C flag is cleared
13746               *
13747               * ******************************************************************************
13748               
13749               MULT3:
13750 41FC D80D  30        movb ra,@R                      ; STA R             ; Store the high byte of (A P+1 P) in R
     41FE 0091     
13751               
13752 4200 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Set K+2 to |A|, the high byte of K(2 1 0)
     4202 7F00     
13753 4204 D80D  30        movb ra,@K+2                    ; STA K+2
     4206 003F     
13754               
13755 4208 D360  30        movb @Q,ra                      ; LDA Q             ; Set A to bits 0-6 of Q, so A = |Q|
     420A 0090     
13756 420C 024D  22        andi ra,>7f*256                 ; AND #%01111111
     420E 7F00     
13757               
13758 4210 13EA  14        jeq  MU5                        ; BEQ MU5           ; If |Q| = 0, jump to MU5 to set K(3 2 1 0) to 0,
13759                                                                          ; returning from the subroutine using a tail call
13760               
13761                      .sec                            ; SEC               ; Set T = |Q| - 1
     **** ****     > SEC
0001 4212 0A18  18        sla  rmone,1
                   < elite.a99
13762                      .sbi (>01*256)                  ; SBC #1
     **** ****     > SBI
0001 4214 1801  14        joc  !
0002 4216 7347  18        sb   rone,ra
0003               !:
0004 4218 022D  22        ai   ra,-(>01*256)
     421A FF00     
                   < elite.a99
13763 421C D80D  30        movb ra,@T                      ; STA T
     421E 00D1     
13764               
13765                                                                          ; We now use the same shift-and-add algorithm as MULT1
13766                                                                          ; to calculate the following:
13767                                                                          ;
13768                                                                          ; K(2 1 0) = K(2 1 0) * |Q|
13769                                                                          ;
13770                                                                          ; so we start with the first shift right, in which we
13771                                                                          ; take (K+2 P+1 P) and shift it right, storing the
13772                                                                          ; result in K(2 1 0), ready for the multiplication loop
13773                                                                          ; (so the multiplication loop actually calculates
13774                                                                          ; (|A| P+1 P) * |Q|, as the following sets K(2 1 0) to
13775                                                                          ; (|A| P+1 P) shifted right)
13776               
13777 4220 D360  30        movb @P+1,ra                    ; LDA P+1           ; Set A = P+1
     4222 001C     
13778               
13779                      .lsr @K+2                       ; LSR K+2           ; Shift the high byte in K+2 to the right
     **** ****     > LSR
0001 4224 D020  30        movb @K+2,rtmp
     4226 003F     
0002 4228 0910  18        srl  rtmp,1
0003 422A D800  30        movb rtmp,@K+2
     422C 003F     
                   < elite.a99
13780               
13781 422E 06A0  32        bl   @rora                      ; ROR A             ; Shift the middle byte in A to the right and store in
     4230 FE62     
13782 4232 D80D  30        movb ra,@K+1                    ; STA K+1           ; K+1 (so K+1 contains P+1 shifted right)
     4234 003E     
13783               
13784 4236 D360  30        movb @P,ra                      ; LDA P             ; Shift the middle byte in P to the right and store in
     4238 001B     
13785 423A 06A0  32        bl   @rora                      ; ROR A             ; K, so K(2 1 0) now contains (|A| P+1 P) shifted right
     423C FE62     
13786 423E D80D  30        movb ra,@K                      ; STA K
     4240 003D     
13787               
13788                                                                          ; We now use the same shift-and-add algorithm as MULT1
13789                                                                          ; to calculate the following:
13790                                                                          ;
13791                                                                          ; K(2 1 0) = K(2 1 0) * |Q|
13792               
13793 4242 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4244 0000     
13794               
13795 4246 020E  20        li   rx,>18*256                 ; LDX #24           ; Set up a counter in X to count the 24 bits in K(2 1 0)
     4248 1800     
13796               
13797               MUL2:
13798 424A 1704  14        jnc  B38                        ; BCC B38           ; If C (i.e. the next bit from K) is set, do the
13799                      .adc @T,ra                      ; ADC T             ; addition for this bit of K:
     **** ****     > ADC
0001 424C 1701  14        jnc  !
0002 424E B347  18        ab   rone,ra
0003               !:
0004 4250 B360  30        ab   @T,ra
     4252 00D1     
                   < elite.a99
13800                                                                          ;
13801                                                                          ; A = A + T + C
13802                                                                          ; = A + |Q| - 1 + 1
13803                                                                          ; = A + |Q|
13804               
13805               B38:
13806 4254 06A0  32        bl   @rora                      ; ROR A             ; Shift A right by one place to catch the next digit
     4256 FE62     
13807 4258 0204  20        li   rarg1,K+2                  ; ROR K+2           ; next digit of our result in the left end of K(2 1 0),
     425A 003F     
13808 425C 06A0  32        bl   @ror                       ;
     425E FE7A     
13809 4260 0204  20        li   rarg1,K+1                  ; ROR K+1           ; while also shifting K(2 1 0) right to fetch the next
     4262 003E     
13810 4264 06A0  32        bl   @ror                       ;
     4266 FE7A     
13811 4268 0204  20        li   rarg1,K                    ; ROR K             ; bit for the calculation into the C flag
     426A 003D     
13812 426C 06A0  32        bl   @ror                       ;
     426E FE7A     
13813                                                                          ;
13814                                                                          ; On the last iteration of this loop, the bit falling
13815                                                                          ; off the end of K will be bit 0 of the original A, as
13816                                                                          ; we did one shift before the loop and we are doing 24
13817                                                                          ; iterations. We set A to 0 before looping, so this
13818                                                                          ; means the loop exits with the C flag clear
13819               
13820 4270 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
13821               
13822 4272 16EB  14        jne  MUL2                       ; BNE MUL2          ; Loop back for the next bit until K(2 1 0) has been
13823                                                                          ; rotated all the way
13824               
13825                                                                          ; The result (|A| P+1 P) * |Q| is now in (A K+2 K+1 K),
13826                                                                          ; but it is positive and doesn't have the correct sign
13827                                                                          ; of the final result yet
13828               
13829 4274 D80D  30        movb ra,@T                      ; STA T             ; Save the high byte of the result into T
     4276 00D1     
13830               
13831 4278 D360  30        movb @R,ra                      ; LDA R             ; Fetch the sign byte from the original (A P+1 P)
     427A 0091     
13832                                                                          ; argument that we stored in R
13833               
13834                      .eor @Q                         ; EOR Q             ; EOR with Q so the sign bit is the same as that of
     **** ****     > EOR
0001 427C D020  30        movb @Q,rtmp
     427E 0090     
0002 4280 2B40  18        xor  rtmp,ra
                   < elite.a99
13835                                                                          ; (A P+1 P) * Q
13836               
13837 4282 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign bit
     4284 8000     
13838               
13839 4286 F360  30        socb @T,ra                      ; ORA T             ; Apply this to the high byte of the result in T, so
     4288 00D1     
13840                                                                          ; that A now has the correct sign for the result, and
13841                                                                          ; (A K+2 K+1 K) therefore contains the correctly signed
13842                                                                          ; result
13843               
13844 428A D80D  30        movb ra,@K+3                    ; STA K+3           ; Store A in K+3, so K(3 2 1 0) now contains the result
     428C 0040     
13845               
13846 428E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4290 FE34     
13847               
13848               * ******************************************************************************
13849               *
13850               * Name: MLS2
13851               * Type: Subroutine
13852               * Category: Maths (Arithmetic)
13853               * Summary: Calculate (S R) = XX(1 0) and (A P) = A * ALP1
13854               *
13855               * ------------------------------------------------------------------------------
13856               *
13857               * Calculate the following:
13858               *
13859               * (S R) = XX(1 0)
13860               *
13861               * (A P) = A * ALP1
13862               *
13863               * where ALP1 is the magnitude of the current roll angle alpha, in the range
13864               * 0-31.
13865               *
13866               * ******************************************************************************
13867               
13868               MLS2:
13869 4292 D3A0  30        movb @XX,rx                     ; LDX XX            ; Set (S R) = XX(1 0), starting with the low bytes
     4294 0024     
13870 4296 D80E  30        movb rx,@R                      ; STX R
     4298 0091     
13871               
13872 429A D3A0  30        movb @XX+1,rx                   ; LDX XX+1          ; And then doing the high bytes
     429C 0025     
13873 429E D80E  30        movb rx,@S                      ; STX S
     42A0 0092     
13874               
13875                                                                          ; Fall through into MLS1 to calculate (A P) = A * ALP1
13876               
13877               * ******************************************************************************
13878               *
13879               * Name: MLS1
13880               * Type: Subroutine
13881               * Category: Maths (Arithmetic)
13882               * Summary: Calculate (A P) = ALP1 * A
13883               *
13884               * ------------------------------------------------------------------------------
13885               *
13886               * Calculate the following:
13887               *
13888               * (A P) = ALP1 * A
13889               *
13890               * where ALP1 is the magnitude of the current roll angle alpha, in the range
13891               * 0-31.
13892               *
13893               * This routine uses an unrolled version of MU11. MU11 calculates P * X, so we
13894               * use the same algorithm but with P set to ALP1 and X set to A. The unrolled
13895               * version here can skip the bit tests for bits 5-7 of P as we know P < 32, so
13896               * only 5 shifts with bit tests are needed (for bits 0-4), while the other 3
13897               * shifts can be done without a test (for bits 5-7).
13898               *
13899               * ------------------------------------------------------------------------------
13900               *
13901               * Other entry points:
13902               *
13903               * MULTS-2             Calculate (A P) = X * A
13904               *
13905               * ******************************************************************************
13906               
13907               MLS1:
13908 42A2 D3A0  30        movb @ALP1,rx                   ; LDX ALP1          ; Set P to the roll angle alpha magnitude in ALP1
     42A4 0087     
13909 42A6 D80E  30        movb rx,@P                      ; STX P             ; (0-31), so now we calculate P * A
     42A8 001B     
13910               
13911               MULTS:
13912 42AA D38D  18        movb ra,rx                      ; TAX               ; Set X = A, so now we can calculate P * X instead of
13913                                                                          ; P * A to get our result, and we can use the algorithm
13914                                                                          ; from MU11 to do that, just unrolled (as MU11 returns
13915                                                                          ; P * X)
13916               
13917 42AC 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Set T to the sign bit of A
     42AE 8000     
13918 42B0 D80D  30        movb ra,@T                      ; STA T
     42B2 00D1     
13919               
13920 42B4 D34E  18        movb rx,ra                      ; TXA               ; Set A = |A|
13921 42B6 024D  22        andi ra,>7f*256                 ; AND #127
     42B8 7F00     
13922               
13923 42BA 1602  14        jne  FIX003                     ; BNE FIX003        ; If A = 0, jump to MU6 to set P(1 0) = 0 and return
13924                                                                          ; from the subroutine using a tail call
13925 42BC 0460  28        b    @MU6                       ; JMP MU6
     42BE 43CE     
13926               FIX003:
13927 42C0 D38D  18        movb ra,rx                      ; TAX               ; Set T1 = X - 1
13928 42C2 7387  18        sb   rone,rx                    ; DEX               ;
13929 42C4 D80E  30        movb rx,@T1                     ; STX T1            ; We subtract 1 as the C flag will be set when we want
     42C6 0006     
13930                                                                          ; to do an addition in the loop below
13931               
13932 42C8 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     42CA 0000     
13933               
13934                      .lsr @P                         ; LSR P             ; Set P = P >> 1
     **** ****     > LSR
0001 42CC D020  30        movb @P,rtmp
     42CE 001B     
0002 42D0 0910  18        srl  rtmp,1
0003 42D2 D800  30        movb rtmp,@P
     42D4 001B     
                   < elite.a99
13935                                                                          ; and C flag = bit 0 of P
13936               
13937                                                                          ; We are now going to work our way through the bits of
13938                                                                          ; P, and do a shift-add for any bits that are set,
13939                                                                          ; keeping the running total in A, but instead of using a
13940                                                                          ; loop like MU11, we just unroll it, starting with bit 0
13941               
13942 42D6 1704  14        jnc  B39                        ; BCC B39           ; If C (i.e. the next bit from P) is set, do the
13943                      .adc @T1,ra                     ; ADC T1            ; addition for this bit of P:
     **** ****     > ADC
0001 42D8 1701  14        jnc  !
0002 42DA B347  18        ab   rone,ra
0003               !:
0004 42DC B360  30        ab   @T1,ra
     42DE 0006     
                   < elite.a99
13944                                                                          ;
13945                                                                          ; A = A + T1 + C
13946                                                                          ; = A + X - 1 + 1
13947                                                                          ; = A + X
13948               
13949               B39:
13950 42E0 06A0  32        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result,
     42E2 FE62     
13951                                                                          ; which the next ROR sticks into the left end of P while
13952                                                                          ; also extracting the next bit of P
13953               
13954 42E4 0204  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     42E6 001B     
13955 42E8 06A0  32        bl   @ror                       ;
     42EA FE7A     
13956                                                                          ; the start of P, and shift P right to fetch the next
13957                                                                          ; bit for the calculation into the C flag
13958               
13959 42EC 1704  14        jnc  B40                        ; BCC B40           ; Repeat the shift-and-add loop for bit 1
13960                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 42EE 1701  14        jnc  !
0002 42F0 B347  18        ab   rone,ra
0003               !:
0004 42F2 B360  30        ab   @T1,ra
     42F4 0006     
                   < elite.a99
13961               B40:
13962 42F6 06A0  32        bl   @rora                      ; ROR A
     42F8 FE62     
13963 42FA 0204  20        li   rarg1,P                    ; ROR P
     42FC 001B     
13964 42FE 06A0  32        bl   @ror                       ;
     4300 FE7A     
13965               
13966 4302 1704  14        jnc  B41                        ; BCC B41           ; Repeat the shift-and-add loop for bit 2
13967                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 4304 1701  14        jnc  !
0002 4306 B347  18        ab   rone,ra
0003               !:
0004 4308 B360  30        ab   @T1,ra
     430A 0006     
                   < elite.a99
13968               B41:
13969 430C 06A0  32        bl   @rora                      ; ROR A
     430E FE62     
13970 4310 0204  20        li   rarg1,P                    ; ROR P
     4312 001B     
13971 4314 06A0  32        bl   @ror                       ;
     4316 FE7A     
13972               
13973 4318 1704  14        jnc  B42                        ; BCC B42           ; Repeat the shift-and-add loop for bit 3
13974                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 431A 1701  14        jnc  !
0002 431C B347  18        ab   rone,ra
0003               !:
0004 431E B360  30        ab   @T1,ra
     4320 0006     
                   < elite.a99
13975               B42:
13976 4322 06A0  32        bl   @rora                      ; ROR A
     4324 FE62     
13977 4326 0204  20        li   rarg1,P                    ; ROR P
     4328 001B     
13978 432A 06A0  32        bl   @ror                       ;
     432C FE7A     
13979               
13980 432E 1704  14        jnc  B43                        ; BCC B43           ; Repeat the shift-and-add loop for bit 4
13981                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 4330 1701  14        jnc  !
0002 4332 B347  18        ab   rone,ra
0003               !:
0004 4334 B360  30        ab   @T1,ra
     4336 0006     
                   < elite.a99
13982               B43:
13983 4338 06A0  32        bl   @rora                      ; ROR A
     433A FE62     
13984 433C 0204  20        li   rarg1,P                    ; ROR P
     433E 001B     
13985 4340 06A0  32        bl   @ror                       ;
     4342 FE7A     
13986               
13987 4344 091D  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 5
13988 4346 0204  20        li   rarg1,P                    ; ROR P
     4348 001B     
13989 434A 06A0  32        bl   @ror                       ;
     434C FE7A     
13990               
13991 434E 091D  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 6
13992 4350 0204  20        li   rarg1,P                    ; ROR P
     4352 001B     
13993 4354 06A0  32        bl   @ror                       ;
     4356 FE7A     
13994               
13995 4358 091D  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 7
13996 435A 0204  20        li   rarg1,P                    ; ROR P
     435C 001B     
13997 435E 06A0  32        bl   @ror                       ;
     4360 FE7A     
13998               
13999 4362 F360  30        socb @T,ra                      ; ORA T             ; Give A the sign bit of the original argument A that
     4364 00D1     
14000                                                                          ; we put into T above
14001               
14002 4366 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4368 FE34     
14003               
14004               * ******************************************************************************
14005               *
14006               * Name: SQUA
14007               * Type: Subroutine
14008               * Category: Maths (Arithmetic)
14009               * Summary: Clear bit 7 of A and calculate (A P) = A * A
14010               *
14011               * ------------------------------------------------------------------------------
14012               *
14013               * Do the following multiplication of unsigned 8-bit numbers, after first
14014               * clearing bit 7 of A:
14015               *
14016               * (A P) = A * A
14017               *
14018               * ******************************************************************************
14019               
14020               SQUA:
14021 436A 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear bit 7 of A and fall through into SQUA2 to set
     436C 7F00     
14022                                                                          ; (A P) = A * A
14023               
14024               * ******************************************************************************
14025               *
14026               * Name: SQUA2
14027               * Type: Subroutine
14028               * Category: Maths (Arithmetic)
14029               * Summary: Calculate (A P) = A * A
14030               *
14031               * ------------------------------------------------------------------------------
14032               *
14033               * Do the following multiplication of unsigned 8-bit numbers:
14034               *
14035               * (A P) = A * A
14036               *
14037               * ******************************************************************************
14038               
14039               SQUA2:
14040 436E D80D  30        movb ra,@P                      ; STA P             ; Copy A into P and X
     4370 001B     
14041 4372 D38D  18        movb ra,rx                      ; TAX
14042               
14043 4374 1611  14        jne  MU11                       ; BNE MU11          ; If X = 0 fall through into MU1 to return a 0,
14044                                                                          ; otherwise jump to MU11 to return P * X
14045               
14046               * ******************************************************************************
14047               *
14048               * Name: MU1
14049               * Type: Subroutine
14050               * Category: Maths (Arithmetic)
14051               * Summary: Copy X into P and A, and clear the C flag
14052               *
14053               * ------------------------------------------------------------------------------
14054               *
14055               * Used to return a 0 result quickly from MULTU below.
14056               *
14057               * ******************************************************************************
14058               
14059               MU1:
14060                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 4376 0A16  18        sla  rzero,1
                   < elite.a99
14061               
14062 4378 D80E  30        movb rx,@P                      ; STX P             ; Copy X into P and A
     437A 001B     
14063 437C D34E  18        movb rx,ra                      ; TXA
14064               
14065 437E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4380 FE34     
14066               
14067               * ******************************************************************************
14068               *
14069               * Name: MLU1
14070               * Type: Subroutine
14071               * Category: Maths (Arithmetic)
14072               * Summary: Calculate Y1 = y_hi and (A P) = |y_hi| * Q for Y-th stardust
14073               *
14074               * ------------------------------------------------------------------------------
14075               *
14076               * Do the following assignment, and multiply the Y-th stardust particle's
14077               * y-coordinate with an unsigned number Q:
14078               *
14079               * Y1 = y_hi
14080               *
14081               * (A P) = |y_hi| * Q
14082               *
14083               * ******************************************************************************
14084               
14085               MLU1:
14086 4382 D36F  34        movb @SY(ry),ra                 ; LDA SY,Y          ; Set Y1 the Y-th byte of SY
     4384 0EC2     
14087 4386 D80D  30        movb ra,@Y1                     ; STA Y1
     4388 0032     
14088               
14089                                                                          ; Fall through into MLU2 to calculate:
14090                                                                          ;
14091                                                                          ; (A P) = |A| * Q
14092               
14093               * ******************************************************************************
14094               *
14095               * Name: MLU2
14096               * Type: Subroutine
14097               * Category: Maths (Arithmetic)
14098               * Summary: Calculate (A P) = |A| * Q
14099               *
14100               * ------------------------------------------------------------------------------
14101               *
14102               * Do the following multiplication of a sign-magnitude 8-bit number P with an
14103               * unsigned number Q:
14104               *
14105               * (A P) = |A| * Q
14106               *
14107               * ******************************************************************************
14108               
14109               MLU2:
14110 438A 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit in P, so P = |A|
     438C 7F00     
14111 438E D80D  30        movb ra,@P                      ; STA P
     4390 001B     
14112               
14113                                                                          ; Fall through into MULTU to calculate:
14114                                                                          ;
14115                                                                          ; (A P) = P * Q
14116                                                                          ; = |A| * Q
14117               
14118               * ******************************************************************************
14119               *
14120               * Name: MULTU
14121               * Type: Subroutine
14122               * Category: Maths (Arithmetic)
14123               * Summary: Calculate (A P) = P * Q
14124               *
14125               * ------------------------------------------------------------------------------
14126               *
14127               * Do the following multiplication of unsigned 8-bit numbers:
14128               *
14129               * (A P) = P * Q
14130               *
14131               * ******************************************************************************
14132               
14133               MULTU:
14134 4392 D3A0  30        movb @Q,rx                      ; LDX Q             ; Set X = Q
     4394 0090     
14135               
14136 4396 13EF  14        jeq  MU1                        ; BEQ MU1           ; If X = Q = 0, jump to MU1 to copy X into P and A,
14137                                                                          ; clear the C flag and return from the subroutine using
14138                                                                          ; a tail call
14139               
14140                                                                          ; Otherwise fall through into MU11 to set (A P) = P * X
14141               
14142               * ******************************************************************************
14143               *
14144               * Name: MU11
14145               * Type: Subroutine
14146               * Category: Maths (Arithmetic)
14147               * Summary: Calculate (A P) = P * X
14148               * Deep dive: Shift-and-add multiplication
14149               *
14150               * ------------------------------------------------------------------------------
14151               *
14152               * Do the following multiplication of two unsigned 8-bit numbers:
14153               *
14154               * (A P) = P * X
14155               *
14156               * This uses the same shift-and-add approach as MULT1, but it's simpler as we
14157               * are dealing with unsigned numbers in P and X. See the deep dive on
14158               * "Shift-and-add multiplication" for a discussion of how this algorithm works.
14159               *
14160               * ******************************************************************************
14161               
14162               MU11:
14163 4398 7387  18        sb   rone,rx                    ; DEX               ; Set T = X - 1
14164 439A D80E  30        movb rx,@T                      ; STX T             ;
     439C 00D1     
14165                                                                          ; We subtract 1 as the C flag will be set when we want
14166                                                                          ; to do an addition in the loop below
14167               
14168 439E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     43A0 0000     
14169               
14170 43A2 020E  20        li   rx,>08*256                 ; LDX #8            ; Set up a counter in X to count the 8 bits in P
     43A4 0800     
14171               
14172                      .lsr @P                         ; LSR P             ; Set P = P >> 1
     **** ****     > LSR
0001 43A6 D020  30        movb @P,rtmp
     43A8 001B     
0002 43AA 0910  18        srl  rtmp,1
0003 43AC D800  30        movb rtmp,@P
     43AE 001B     
                   < elite.a99
14173                                                                          ; and C flag = bit 0 of P
14174               
14175                                                                          ; We are now going to work our way through the bits of
14176                                                                          ; P, and do a shift-add for any bits that are set,
14177                                                                          ; keeping the running total in A. We just did the first
14178                                                                          ; shift right, so we now need to do the first add and
14179                                                                          ; loop through the other bits in P
14180               
14181               MUL6:
14182 43B0 1704  14        jnc  B44                        ; BCC B44           ; If C (i.e. the next bit from P) is set, do the
14183                      .adc @T,ra                      ; ADC T             ; addition for this bit of P:
     **** ****     > ADC
0001 43B2 1701  14        jnc  !
0002 43B4 B347  18        ab   rone,ra
0003               !:
0004 43B6 B360  30        ab   @T,ra
     43B8 00D1     
                   < elite.a99
14184                                                                          ;
14185                                                                          ; A = A + T + C
14186                                                                          ; = A + X - 1 + 1
14187                                                                          ; = A + X
14188               
14189               B44:
14190 43BA 06A0  32        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result,
     43BC FE62     
14191                                                                          ; which the next ROR sticks into the left end of P while
14192                                                                          ; also extracting the next bit of P
14193               
14194 43BE 0204  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     43C0 001B     
14195 43C2 06A0  32        bl   @ror                       ;
     43C4 FE7A     
14196                                                                          ; the start of P, and shift P right to fetch the next
14197                                                                          ; bit for the calculation into the C flag
14198               
14199 43C6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14200               
14201 43C8 16F3  14        jne  MUL6                       ; BNE MUL6          ; Loop back for the next bit until P has been rotated
14202                                                                          ; all the way
14203               
14204 43CA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     43CC FE34     
14205               
14206               * ******************************************************************************
14207               *
14208               * Name: MU6
14209               * Type: Subroutine
14210               * Category: Maths (Arithmetic)
14211               * Summary: Set P(1 0) = (A A)
14212               *
14213               * ------------------------------------------------------------------------------
14214               *
14215               * In practice this is only called via a BEQ following an AND instruction, in
14216               * which case A = 0, so this routine effectively does this:
14217               *
14218               * P(1 0) = 0
14219               *
14220               * ******************************************************************************
14221               
14222               MU6:
14223 43CE D80D  30        movb ra,@P+1                    ; STA P+1           ; Set P(1 0) = (A A)
     43D0 001C     
14224 43D2 D80D  30        movb ra,@P                      ; STA P
     43D4 001B     
14225               
14226 43D6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     43D8 FE34     
14227               
14228               * ******************************************************************************
14229               *
14230               * Name: FMLTU2
14231               * Type: Subroutine
14232               * Category: Maths (Arithmetic)
14233               * Summary: Calculate A = K * sin(A)
14234               * Deep dive: The sine, cosine and arctan tables
14235               *
14236               * ------------------------------------------------------------------------------
14237               *
14238               * Calculate the following:
14239               *
14240               * A = K * sin(A)
14241               *
14242               * Because this routine uses the sine lookup table SNE, we can also call this
14243               * routine to calculate cosine multiplication. To calculate the following:
14244               *
14245               * A = K * cos(B)
14246               *
14247               * call this routine with B + 16 in the accumulator, as sin(B + 16) = cos(B).
14248               *
14249               * ******************************************************************************
14250               
14251               FMLTU2:
14252 43DA 024D  22        andi ra,>1f*256                 ; AND #%00011111    ; Restrict A to bits 0-5 (so it's in the range 0-31)
     43DC 1F00     
14253               
14254 43DE D38D  18        movb ra,rx                      ; TAX               ; Set Q = sin(A) * 256
14255 43E0 D36E  34        movb @SNE(rx),ra                ; LDA SNE,X
     43E2 41C6     
14256 43E4 D80D  30        movb ra,@Q                      ; STA Q
     43E6 0090     
14257               
14258 43E8 D360  30        movb @K,ra                      ; LDA K             ; Set A to the radius in K
     43EA 003D     
14259               
14260                                                                          ; Fall through into FMLTU to do the following:
14261                                                                          ;
14262                                                                          ; (A ?) = A * Q
14263                                                                          ; = K * sin(A) * 256
14264                                                                          ;
14265                                                                          ; which is equivalent to:
14266                                                                          ;
14267                                                                          ; A = K * sin(A)
14268               
14269               * ******************************************************************************
14270               *
14271               * Name: FMLTU
14272               * Type: Subroutine
14273               * Category: Maths (Arithmetic)
14274               * Summary: Calculate A = A * Q / 256
14275               *
14276               * ------------------------------------------------------------------------------
14277               *
14278               * Do the following multiplication of two unsigned 8-bit numbers, returning only
14279               * the high byte of the result:
14280               *
14281               * (A ?) = A * Q
14282               *
14283               * or, to put it another way:
14284               *
14285               * A = A * Q / 256
14286               *
14287               * ------------------------------------------------------------------------------
14288               *
14289               * Returns:
14290               *
14291               * C flag              The C flag is set
14292               *
14293               * ******************************************************************************
14294               
14295               FMLTU:
14296                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip the bits in A, set the C flag and rotate right,
     **** ****     > EOI
0001 43EC 0200  20        li   rtmp,(>FF*256)
     43EE FF00     
0002 43F0 2B40  18        xor  rtmp,ra
                   < elite.a99
14297                      .sec                            ; SEC               ; so the C flag now contains bit 0 of A inverted, and P
     **** ****     > SEC
0001 43F2 0A18  18        sla  rmone,1
                   < elite.a99
14298 43F4 06A0  32        bl   @rora                      ; ROR A             ; contains A inverted and shifted right by one, with bit
     43F6 FE62     
14299 43F8 D80D  30        movb ra,@P                      ; STA P             ; 7 set to a 1. We can now use P as our source of bits
     43FA 001B     
14300                                                                          ; to shift right, just as in MU11, just with the logic
14301                                                                          ; reversed
14302               
14303 43FC 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     43FE 0000     
14304               
14305               MUL3:
14306 4400 180E  14        joc  MU7                        ; BCS MU7           ; If C (i.e. the next bit from P) is set, do not do the
14307                                                                          ; addition for this bit of P, and instead skip to MU7
14308                                                                          ; to just do the shifts
14309               
14310                      .adc @Q,ra                      ; ADC Q             ; Do the addition for this bit of P:
     **** ****     > ADC
0001 4402 1701  14        jnc  !
0002 4404 B347  18        ab   rone,ra
0003               !:
0004 4406 B360  30        ab   @Q,ra
     4408 0090     
                   < elite.a99
14311                                                                          ;
14312                                                                          ; A = A + Q + C
14313                                                                          ; = A + Q
14314               
14315 440A 06A0  32        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result.
     440C FE62     
14316                                                                          ; If we were interested in the low byte of the result we
14317                                                                          ; would want to save the bit that falls off the end, but
14318                                                                          ; we aren't, so we can ignore it
14319               
14320                      .lsr @P                         ; LSR P             ; Shift P right to fetch the next bit for the
     **** ****     > LSR
0001 440E D020  30        movb @P,rtmp
     4410 001B     
0002 4412 0910  18        srl  rtmp,1
0003 4414 D800  30        movb rtmp,@P
     4416 001B     
                   < elite.a99
14321                                                                          ; calculation into the C flag
14322               
14323 4418 16F3  14        jne  MUL3                       ; BNE MUL3          ; Loop back to MUL3 if P still contains some set bits
14324                                                                          ; (so we loop through the bits of P until we get to the
14325                                                                          ; 1 we inserted before the loop, and then we stop)
14326               
14327                                                                          ; If we get here then the C flag is set as we just
14328                                                                          ; rotated a 1 out of the right end of P
14329               
14330 441A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     441C FE34     
14331               
14332               MU7:
14333 441E 091D  18        srl  ra,1                       ; LSR A             ; Shift A right to catch the next digit of our result,
14334                                                                          ; pushing a 0 into bit 7 as we aren't adding anything
14335                                                                          ; here (we can't use a ROR here as the C flag is set, so
14336                                                                          ; a ROR would push a 1 into bit 7)
14337               
14338                      .lsr @P                         ; LSR P             ; Fetch the next bit from P into the C flag
     **** ****     > LSR
0001 4420 D020  30        movb @P,rtmp
     4422 001B     
0002 4424 0910  18        srl  rtmp,1
0003 4426 D800  30        movb rtmp,@P
     4428 001B     
                   < elite.a99
14339               
14340 442A 16EA  14        jne  MUL3                       ; BNE MUL3          ; Loop back to MUL3 if P still contains some set bits
14341                                                                          ; (so we loop through the bits of P until we get to the
14342                                                                          ; 1 we inserted before the loop, and then we stop)
14343               
14344                                                                          ; If we get here then the C flag is set as we just
14345                                                                          ; rotated a 1 out of the right end of P
14346               
14347 442C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     442E FE34     
14348               
14349               * ******************************************************************************
14350               *
14351               * Name: Unused duplicate of MULTU
14352               * Type: Subroutine
14353               * Category: Maths (Arithmetic)
14354               * Summary: An unused duplicate of the MULTU routine
14355               *
14356               * ------------------------------------------------------------------------------
14357               *
14358               * This is a duplicate of the MULTU routine, but with no entry label, so it can't
14359               * be called by name. It is unused, and could have been culled to save a few
14360               * bytes (24 to be precise), but it's still here, unnamed, unloved and unvisited,
14361               * through no fault of its own.
14362               *
14363               * ******************************************************************************
14364               
14365               * {
14366               * LDX Q
14367               * BEQ MU1
14368               * DEX
14369               * STX T
14370               * LDA #0
14371               * LDX #8
14372               * LSR P
14373               *
14374               * .MUL6
14375               *
14376               * BCC B45
14377               * ADC T
14378               * .B45
14379               * ROR A
14380               * ROR P
14381               * DEX
14382               * BNE MUL6
14383               * RTS
14384               * }
14385               
14386               * ******************************************************************************
14387               *
14388               * Name: MLTU2
14389               * Type: Subroutine
14390               * Category: Maths (Arithmetic)
14391               * Summary: Calculate (A P+1 P) = (A ~P) * Q
14392               * Deep dive: Shift-and-add multiplication
14393               *
14394               * ------------------------------------------------------------------------------
14395               *
14396               * Do the following multiplication of an unsigned 16-bit number and an unsigned
14397               * 8-bit number:
14398               *
14399               * (A P+1 P) = (A ~P) * Q
14400               *
14401               * where ~P means P EOR %11111111 (i.e. P with all its bits flipped). In other
14402               * words, if you wanted to calculate &1234 * &56, you would:
14403               *
14404               * * Set A to &12
14405               * * Set P to &34 EOR %11111111 = &CB
14406               * * Set Q to &56
14407               *
14408               * before calling MLTU2.
14409               *
14410               * This routine is like a mash-up of MU11 and FMLTU. It uses part of FMLTU's
14411               * inverted argument trick to work out whether or not to do an addition, and like
14412               * MU11 it sets up a counter in X to extract bits from (P+1 P). But this time we
14413               * extract 16 bits from (P+1 P), so the result is a 24-bit number. The core of
14414               * the algorithm is still the shift-and-add approach explained in MULT1, just
14415               * with more bits.
14416               *
14417               * ------------------------------------------------------------------------------
14418               *
14419               * Returns:
14420               *
14421               * Q                   Q is preserved
14422               *
14423               * ------------------------------------------------------------------------------
14424               *
14425               * Other entry points:
14426               *
14427               * MLTU2-2             Set Q to X, so this calculates (A P+1 P) = (A ~P) * X
14428               *
14429               * ******************************************************************************
14430               
14431 4430 D80E  30        movb rx,@Q                      ; STX Q             ; Store X in Q
     4432 0090     
14432               
14433               MLTU2:
14434                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip the bits in A and rotate right, storing the
     **** ****     > EOI
0001 4434 0200  20        li   rtmp,(>FF*256)
     4436 FF00     
0002 4438 2B40  18        xor  rtmp,ra
                   < elite.a99
14435 443A 091D  18        srl  ra,1                       ; LSR A             ; result in P+1, so we now calculate (P+1 P) * Q
14436 443C D80D  30        movb ra,@P+1                    ; STA P+1
     443E 001C     
14437               
14438 4440 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4442 0000     
14439               
14440 4444 020E  20        li   rx,>10*256                 ; LDX #16           ; Set up a counter in X to count the 16 bits in (P+1 P)
     4446 1000     
14441               
14442 4448 0204  20        li   rarg1,P                    ; ROR P             ; Set P = P >> 1 with bit 7 = bit 0 of A
     444A 001B     
14443 444C 06A0  32        bl   @ror                       ;
     444E FE7A     
14444                                                                          ; and C flag = bit 0 of P
14445               
14446               MUL7:
14447 4450 1812  14        joc  MU21                       ; BCS MU21          ; If C (i.e. the next bit from P) is set, do not do the
14448                                                                          ; addition for this bit of P, and instead skip to MU21
14449                                                                          ; to just do the shifts
14450               
14451                      .adc @Q,ra                      ; ADC Q             ; Do the addition for this bit of P:
     **** ****     > ADC
0001 4452 1701  14        jnc  !
0002 4454 B347  18        ab   rone,ra
0003               !:
0004 4456 B360  30        ab   @Q,ra
     4458 0090     
                   < elite.a99
14452                                                                          ;
14453                                                                          ; A = A + Q + C
14454                                                                          ; = A + Q
14455               
14456 445A 06A0  32        bl   @rora                      ; ROR A             ; Rotate (A P+1 P) to the right, so we capture the next
     445C FE62     
14457 445E 0204  20        li   rarg1,P+1                  ; ROR P+1           ; digit of the result in P+1, and extract the next digit
     4460 001C     
14458 4462 06A0  32        bl   @ror                       ;
     4464 FE7A     
14459 4466 0204  20        li   rarg1,P                    ; ROR P             ; of (P+1 P) in the C flag
     4468 001B     
14460 446A 06A0  32        bl   @ror                       ;
     446C FE7A     
14461               
14462 446E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14463               
14464 4470 16EF  14        jne  MUL7                       ; BNE MUL7          ; Loop back for the next bit until P has been rotated
14465                                                                          ; all the way
14466               
14467 4472 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4474 FE34     
14468               
14469               MU21:
14470 4476 091D  18        srl  ra,1                       ; LSR A             ; Shift (A P+1 P) to the right, so we capture the next
14471 4478 0204  20        li   rarg1,P+1                  ; ROR P+1           ; digit of the result in P+1, and extract the next digit
     447A 001C     
14472 447C 06A0  32        bl   @ror                       ;
     447E FE7A     
14473 4480 0204  20        li   rarg1,P                    ; ROR P             ; of (P+1 P) in the C flag
     4482 001B     
14474 4484 06A0  32        bl   @ror                       ;
     4486 FE7A     
14475               
14476 4488 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14477               
14478 448A 16E2  14        jne  MUL7                       ; BNE MUL7          ; Loop back for the next bit until P has been rotated
14479                                                                          ; all the way
14480               
14481 448C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     448E FE34     
14482               
14483               * ******************************************************************************
14484               *
14485               * Name: MUT3
14486               * Type: Subroutine
14487               * Category: Maths (Arithmetic)
14488               * Summary: An unused routine that does the same as MUT2
14489               *
14490               * ------------------------------------------------------------------------------
14491               *
14492               * This routine is never actually called, but it is identical to MUT2, as the
14493               * extra instructions have no effect.
14494               *
14495               * ******************************************************************************
14496               
14497               MUT3:
14498 4490 D3A0  30        movb @ALP1,rx                   ; LDX ALP1          ; Set P = ALP1, though this gets overwritten by the
     4492 0087     
14499 4494 D80E  30        movb rx,@P                      ; STX P             ; following, so this has no effect
     4496 001B     
14500               
14501                                                                          ; Fall through into MUT2 to do the following:
14502                                                                          ;
14503                                                                          ; (S R) = XX(1 0)
14504                                                                          ; (A P) = Q * A
14505               
14506               * ******************************************************************************
14507               *
14508               * Name: MUT2
14509               * Type: Subroutine
14510               * Category: Maths (Arithmetic)
14511               * Summary: Calculate (S R) = XX(1 0) and (A P) = Q * A
14512               *
14513               * ------------------------------------------------------------------------------
14514               *
14515               * Do the following assignment, and multiplication of two signed 8-bit numbers:
14516               *
14517               * (S R) = XX(1 0)
14518               * (A P) = Q * A
14519               *
14520               * ******************************************************************************
14521               
14522               MUT2:
14523 4498 D3A0  30        movb @XX+1,rx                   ; LDX XX+1          ; Set S = XX+1
     449A 0025     
14524 449C D80E  30        movb rx,@S                      ; STX S
     449E 0092     
14525               
14526                                                                          ; Fall through into MUT1 to do the following:
14527                                                                          ;
14528                                                                          ; R = XX
14529                                                                          ; (A P) = Q * A
14530               
14531               * ******************************************************************************
14532               *
14533               * Name: MUT1
14534               * Type: Subroutine
14535               * Category: Maths (Arithmetic)
14536               * Summary: Calculate R = XX and (A P) = Q * A
14537               *
14538               * ------------------------------------------------------------------------------
14539               *
14540               * Do the following assignment, and multiplication of two signed 8-bit numbers:
14541               *
14542               * R = XX
14543               * (A P) = Q * A
14544               *
14545               * ******************************************************************************
14546               
14547               MUT1:
14548 44A0 D3A0  30        movb @XX,rx                     ; LDX XX            ; Set R = XX
     44A2 0024     
14549 44A4 D80E  30        movb rx,@R                      ; STX R
     44A6 0091     
14550               
14551                                                                          ; Fall through into MULT1 to do the following:
14552                                                                          ;
14553                                                                          ; (A P) = Q * A
14554               
14555               * ******************************************************************************
14556               *
14557               * Name: MULT1
14558               * Type: Subroutine
14559               * Category: Maths (Arithmetic)
14560               * Summary: Calculate (A P) = Q * A
14561               * Deep dive: Shift-and-add multiplication
14562               *
14563               * ------------------------------------------------------------------------------
14564               *
14565               * Do the following multiplication of two 8-bit sign-magnitude numbers:
14566               *
14567               * (A P) = Q * A
14568               *
14569               * ******************************************************************************
14570               
14571               MULT1:
14572 44A8 D38D  18        movb ra,rx                      ; TAX               ; Store A in X
14573               
14574 44AA 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Set P = |A| >> 1
     44AC 7F00     
14575 44AE 091D  18        srl  ra,1                       ; LSR A             ; and C flag = bit 0 of A
14576 44B0 D80D  30        movb ra,@P                      ; STA P
     44B2 001B     
14577               
14578 44B4 D34E  18        movb rx,ra                      ; TXA               ; Restore argument A
14579               
14580                      .eor @Q                         ; EOR Q             ; Set bit 7 of A and T if Q and A have different signs,
     **** ****     > EOR
0001 44B6 D020  30        movb @Q,rtmp
     44B8 0090     
0002 44BA 2B40  18        xor  rtmp,ra
                   < elite.a99
14581 44BC 024D  22        andi ra,>80*256                 ; AND #%10000000    ; clear bit 7 if they have the same signs, 0 all other
     44BE 8000     
14582 44C0 D80D  30        movb ra,@T                      ; STA T             ; bits, i.e. T contains the sign bit of Q * A
     44C2 00D1     
14583               
14584 44C4 D360  30        movb @Q,ra                      ; LDA Q             ; Set A = |Q|
     44C6 0090     
14585 44C8 024D  22        andi ra,>7f*256                 ; AND #%01111111
     44CA 7F00     
14586               
14587 44CC 131E  14        jeq  mu10_                      ; BEQ mu10          ; If |Q| = 0 jump to mu10 (with A set to 0)
14588               
14589 44CE D38D  18        movb ra,rx                      ; TAX               ; Set T1 = |Q| - 1
14590 44D0 7387  18        sb   rone,rx                    ; DEX               ;
14591 44D2 D80E  30        movb rx,@T1                     ; STX T1            ; We subtract 1 as the C flag will be set when we want
     44D4 0006     
14592                                                                          ; to do an addition in the loop below
14593               
14594                                                                          ; We are now going to work our way through the bits of
14595                                                                          ; P, and do a shift-add for any bits that are set,
14596                                                                          ; keeping the running total in A. We already set up
14597                                                                          ; the first shift at the start of this routine, as
14598                                                                          ; P = |A| >> 1 and C = bit 0 of A, so we now need to set
14599                                                                          ; up a loop to sift through the other 7 bits in P
14600               
14601 44D6 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     44D8 0000     
14602               
14603 44DA 020E  20        li   rx,>07*256                 ; LDX #7            ; Set up a counter in X to count the 7 bits remaining
     44DC 0700     
14604                                                                          ; in P
14605               
14606               MUL4:
14607 44DE 1704  14        jnc  B46                        ; BCC B46           ; If C (i.e. the next bit from P) is set, do the
14608                      .adc @T1,ra                     ; ADC T1            ; addition for this bit of P:
     **** ****     > ADC
0001 44E0 1701  14        jnc  !
0002 44E2 B347  18        ab   rone,ra
0003               !:
0004 44E4 B360  30        ab   @T1,ra
     44E6 0006     
                   < elite.a99
14609                                                                          ;
14610                                                                          ; A = A + T1 + C
14611                                                                          ; = A + |Q| - 1 + 1
14612                                                                          ; = A + |Q|
14613               
14614               B46:
14615 44E8 06A0  32        bl   @rora                      ; ROR A             ; As mentioned above, this ROR shifts A right and
     44EA FE62     
14616                                                                          ; catches bit 0 in C - giving another digit for our
14617                                                                          ; result - and the next ROR sticks that bit into the
14618                                                                          ; left end of P while also extracting the next bit of P
14619                                                                          ; for the next addition
14620               
14621 44EC 0204  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     44EE 001B     
14622 44F0 06A0  32        bl   @ror                       ;
     44F2 FE7A     
14623                                                                          ; the start of P, and shift P right to fetch the next
14624                                                                          ; bit for the calculation
14625               
14626 44F4 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14627               
14628 44F6 16F3  14        jne  MUL4                       ; BNE MUL4          ; Loop back for the next bit until P has been rotated
14629                                                                          ; all the way
14630               
14631 44F8 091D  18        srl  ra,1                       ; LSR A             ; Rotate (A P) once more to get the final result, as
14632 44FA 0204  20        li   rarg1,P                    ; ROR P             ; we only pushed 7 bits through the above process
     44FC 001B     
14633 44FE 06A0  32        bl   @ror                       ;
     4500 FE7A     
14634               
14635 4502 F360  30        socb @T,ra                      ; ORA T             ; Set the sign bit of the result that we stored in T
     4504 00D1     
14636               
14637 4506 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4508 FE34     
14638               
14639               mu10_:
14640 450A D80D  30        movb ra,@P                      ; STA P             ; If we get here, the result is 0 and A = 0, so set
     450C 001B     
14641                                                                          ; P = 0 so (A P) = 0
14642               
14643 450E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4510 FE34     
14644               
14645               * ******************************************************************************
14646               *
14647               * Name: MULT12
14648               * Type: Subroutine
14649               * Category: Maths (Arithmetic)
14650               * Summary: Calculate (S R) = Q * A
14651               *
14652               * ------------------------------------------------------------------------------
14653               *
14654               * Calculate:
14655               *
14656               * (S R) = Q * A
14657               *
14658               * ******************************************************************************
14659               
14660               MULT12:
14661 4512 0200  20        li   rtmp,MULT1                 ; JSR MULT1         ; Set (A P) = Q * A
     4514 44A8     
14662 4516 06A0  32        bl   @jsr                       ;
     4518 FE28     
14663               
14664 451A D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P)
     451C 0092     
14665 451E D360  30        movb @P,ra                      ; LDA P             ; = Q * A
     4520 001B     
14666 4522 D80D  30        movb ra,@R                      ; STA R
     4524 0091     
14667               
14668 4526 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4528 FE34     
14669               
14670               * ******************************************************************************
14671               *
14672               * Name: TAS3
14673               * Type: Subroutine
14674               * Category: Maths (Geometry)
14675               * Summary: Calculate the dot product of XX15 and an orientation vector
14676               *
14677               * ------------------------------------------------------------------------------
14678               *
14679               * Calculate the dot product of the vector in XX15 and one of the orientation
14680               * vectors, as determined by the value of Y. If vect is the orientation vector,
14681               * we calculate this:
14682               *
14683               * (A X) = vect . XX15
14684               * = vect_x * XX15 + vect_y * XX15+1 + vect_z * XX15+2
14685               *
14686               * ------------------------------------------------------------------------------
14687               *
14688               * Arguments:
14689               *
14690               * Y                   The orientation vector:
14691               *
14692               * * If Y = 10, calculate nosev . XX15
14693               *
14694               * * If Y = 16, calculate roofv . XX15
14695               *
14696               * * If Y = 22, calculate sidev . XX15
14697               *
14698               * ------------------------------------------------------------------------------
14699               *
14700               * Returns:
14701               *
14702               * (A X)               The result of the dot product
14703               *
14704               * ******************************************************************************
14705               
14706               TAS3:
14707 452A D3AF  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; Set Q = the Y-th byte of INWK, i.e. vect_x
     452C 0053     
14708 452E D80E  30        movb rx,@Q                      ; STX Q
     4530 0090     
14709               
14710 4532 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A = XX15
     4534 0031     
14711               
14712 4536 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A
     4538 4512     
14713 453A 06A0  32        bl   @jsr                       ;
     453C FE28     
14714                                                                          ; = vect_x * XX15
14715               
14716 453E D3AF  34        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set Q = the Y+2-th byte of INWK, i.e. vect_y
     4540 0055     
14717 4542 D80E  30        movb rx,@Q                      ; STX Q
     4544 0090     
14718               
14719 4546 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A = XX15+1
     4548 0032     
14720               
14721 454A 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     454C 4566     
14722 454E 06A0  32        bl   @jsr                       ;
     4550 FE28     
14723                                                                          ; = vect_y * XX15+1 + vect_x * XX15
14724               
14725 4552 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     4554 0092     
14726 4556 D80E  30        movb rx,@R                      ; STX R
     4558 0091     
14727               
14728 455A D3AF  34        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; Set Q = the Y+2-th byte of INWK, i.e. vect_z
     455C 0057     
14729 455E D80E  30        movb rx,@Q                      ; STX Q
     4560 0090     
14730               
14731 4562 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set A = XX15+2
     4564 0033     
14732               
14733                                                                          ; Fall through into MAD to set:
14734                                                                          ;
14735                                                                          ; (A X) = Q * A + (S R)
14736                                                                          ; = vect_z * XX15+2 + vect_y * XX15+1 +
14737                                                                          ; vect_x * XX15
14738               
14739               * ******************************************************************************
14740               *
14741               * Name: MAD
14742               * Type: Subroutine
14743               * Category: Maths (Arithmetic)
14744               * Summary: Calculate (A X) = Q * A + (S R)
14745               *
14746               * ------------------------------------------------------------------------------
14747               *
14748               * Calculate
14749               *
14750               * (A X) = Q * A + (S R)
14751               *
14752               * ******************************************************************************
14753               
14754               MAD:
14755 4566 0200  20        li   rtmp,MULT1                 ; JSR MULT1         ; Call MULT1 to set (A P) = Q * A
     4568 44A8     
14756 456A 06A0  32        bl   @jsr                       ;
     456C FE28     
14757               
14758                                                                          ; Fall through into ADD to do:
14759                                                                          ;
14760                                                                          ; (A X) = (A P) + (S R)
14761                                                                          ; = Q * A + (S R)
14762               
14763               * ******************************************************************************
14764               *
14765               * Name: ADD
14766               * Type: Subroutine
14767               * Category: Maths (Arithmetic)
14768               * Summary: Calculate (A X) = (A P) + (S R)
14769               * Deep dive: Adding sign-magnitude numbers
14770               *
14771               * ------------------------------------------------------------------------------
14772               *
14773               * Add two 16-bit sign-magnitude numbers together, calculating:
14774               *
14775               * (A X) = (A P) + (S R)
14776               *
14777               * ******************************************************************************
14778               
14779               ADD:
14780 456E D80D  30        movb ra,@T1                     ; STA T1            ; Store argument A in T1
     4570 0006     
14781               
14782 4572 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign (bit 7) of A and store it in T
     4574 8000     
14783 4576 D80D  30        movb ra,@T                      ; STA T
     4578 00D1     
14784               
14785                      .eor @S                         ; EOR S             ; EOR bit 7 of A with S. If they have different bit 7s
     **** ****     > EOR
0001 457A D020  30        movb @S,rtmp
     457C 0092     
0002 457E 2B40  18        xor  rtmp,ra
                   < elite.a99
14786 4580 1112  14        jlt  MU8                        ; BMI MU8           ; (i.e. they have different signs) then bit 7 in the
14787                                                                          ; EOR result will be 1, which means the EOR result is
14788                                                                          ; negative. So the AND, EOR and BMI together mean "jump
14789                                                                          ; to MU8 if A and S have different signs"
14790               
14791                                                                          ; If we reach here, then A and S have the same sign, so
14792                                                                          ; we can add them and set the sign to get the result
14793               
14794 4582 D360  30        movb @R,ra                      ; LDA R             ; Add the least significant bytes together into X:
     4584 0091     
14795                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 4586 0A16  18        sla  rzero,1
                   < elite.a99
14796                      .adc @P,ra                      ; ADC P             ; X = P + R
     **** ****     > ADC
0001 4588 1701  14        jnc  !
0002 458A B347  18        ab   rone,ra
0003               !:
0004 458C B360  30        ab   @P,ra
     458E 001B     
                   < elite.a99
14797 4590 D38D  18        movb ra,rx                      ; TAX
14798               
14799 4592 D360  30        movb @S,ra                      ; LDA S             ; Add the most significant bytes together into A. We
     4594 0092     
14800                      .adc @T1,ra                     ; ADC T1            ; stored the original argument A in T1 earlier, so we
     **** ****     > ADC
0001 4596 1701  14        jnc  !
0002 4598 B347  18        ab   rone,ra
0003               !:
0004 459A B360  30        ab   @T1,ra
     459C 0006     
                   < elite.a99
14801                                                                          ; can do this with:
14802                                                                          ;
14803                                                                          ; A = A  + S + C
14804                                                                          ; = T1 + S + C
14805               
14806 459E F360  30        socb @T,ra                      ; ORA T             ; If argument A was negative (and therefore S was also
     45A0 00D1     
14807                                                                          ; negative) then make sure result A is negative by
14808                                                                          ; OR'ing the result with the sign bit from argument A
14809                                                                          ; (which we stored in T)
14810               
14811 45A2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     45A4 FE34     
14812               
14813               MU8:
14814                                                                          ; If we reach here, then A and S have different signs,
14815                                                                          ; so we can subtract their absolute values and set the
14816                                                                          ; sign to get the result
14817 45A6 D360  30        movb @S,ra                      ; LDA S             ; Clear the sign (bit 7) in S and store the result in
     45A8 0092     
14818 45AA 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; U, so U now contains |S|
     45AC 7F00     
14819 45AE D80D  30        movb ra,@U                      ; STA U
     45B0 008F     
14820               
14821 45B2 D360  30        movb @P,ra                      ; LDA P             ; Subtract the least significant bytes into X:
     45B4 001B     
14822                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 45B6 0A18  18        sla  rmone,1
                   < elite.a99
14823                      .sbc @R,ra                      ; SBC R             ; X = P - R
     **** ****     > SBC
0001 45B8 1801  14        joc  !
0002 45BA 7347  18        sb   rone,ra
0003               !:
0004 45BC 7360  30        sb   @R,ra
     45BE 0091     
                   < elite.a99
14824 45C0 D38D  18        movb ra,rx                      ; TAX
14825               
14826 45C2 D360  30        movb @T1,ra                     ; LDA T1            ; Restore the A of the argument (A P) from T1 and
     45C4 0006     
14827 45C6 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; clear the sign (bit 7), so A now contains |A|
     45C8 7F00     
14828               
14829                      .sbc @U,ra                      ; SBC U             ; Set A = |A| - |S|
     **** ****     > SBC
0001 45CA 1801  14        joc  !
0002 45CC 7347  18        sb   rone,ra
0003               !:
0004 45CE 7360  30        sb   @U,ra
     45D0 008F     
                   < elite.a99
14830               
14831                                                                          ; At this point we have |A P| - |S R| in (A X), so we
14832                                                                          ; need to check whether the subtraction above was the
14833                                                                          ; right way round (i.e. that we subtracted the smaller
14834                                                                          ; absolute value from the larger absolute value)
14835               
14836 45D2 1813  14        joc  MU9                        ; BCS MU9           ; If |A| >= |S|, our subtraction was the right way
14837                                                                          ; round, so jump to MU9 to set the sign
14838               
14839                                                                          ; If we get here, then |A| < |S|, so our subtraction
14840                                                                          ; above was the wrong way round (we actually subtracted
14841                                                                          ; the larger absolute value from the smaller absolute
14842                                                                          ; value). So let's subtract the result we have in (A X)
14843                                                                          ; from zero, so that the subtraction is the right way
14844                                                                          ; round
14845               
14846 45D4 D80D  30        movb ra,@U                      ; STA U             ; Store A in U
     45D6 008F     
14847               
14848 45D8 D34E  18        movb rx,ra                      ; TXA               ; Set X = 0 - X using two's complement (to negate a
14849                      .eoi (>ff*256)                  ; EOR #&FF          ; number in two's complement, you can invert the bits
     **** ****     > EOI
0001 45DA 0200  20        li   rtmp,(>FF*256)
     45DC FF00     
0002 45DE 2B40  18        xor  rtmp,ra
                   < elite.a99
14850                      .adi (>01*256)                  ; ADC #1            ; and add one - and we know the C flag is clear as we
     **** ****     > ADI
0001 45E0 1701  14        jnc  !
0002 45E2 B347  18        ab   rone,ra
0003               !:
0004 45E4 022D  22        ai   ra,(>01*256)
     45E6 0100     
                   < elite.a99
14851 45E8 D38D  18        movb ra,rx                      ; TAX               ; didn't take the BCS branch above, so the ADC will do
14852                                                                          ; the correct addition)
14853               
14854 45EA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 - A, which we can do this time using a
     45EC 0000     
14855                      .sbc @U,ra                      ; SBC U             ; subtraction with the C flag clear
     **** ****     > SBC
0001 45EE 1801  14        joc  !
0002 45F0 7347  18        sb   rone,ra
0003               !:
0004 45F2 7360  30        sb   @U,ra
     45F4 008F     
                   < elite.a99
14856               
14857 45F6 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now set the sign bit of A, so that the EOR on the
     45F8 8000     
14858                                                                          ; next line will give the result the opposite sign to
14859                                                                          ; argument A (as T contains the sign bit of argument
14860                                                                          ; A). This is the same as giving the result the same
14861                                                                          ; sign as argument S (as A and S have different signs),
14862                                                                          ; which is what we want, as S has the larger absolute
14863                                                                          ; value
14864               
14865               MU9:
14866                      .eor @T                         ; EOR T             ; If we get here from the BCS above, then |A| >= |S|,
     **** ****     > EOR
0001 45FA D020  30        movb @T,rtmp
     45FC 00D1     
0002 45FE 2B40  18        xor  rtmp,ra
                   < elite.a99
14867                                                                          ; so we want to give the result the same sign as
14868                                                                          ; argument A, so if argument A was negative, we flip
14869                                                                          ; the sign of the result with an EOR (to make it
14870                                                                          ; negative)
14871               
14872 4600 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4602 FE34     
14873               
14874               * ******************************************************************************
14875               *
14876               * Name: TIS1
14877               * Type: Subroutine
14878               * Category: Maths (Arithmetic)
14879               * Summary: Calculate (A ?) = (-X * A + (S R)) / 96
14880               * Deep dive: Shift-and-subtract division
14881               *
14882               * ------------------------------------------------------------------------------
14883               *
14884               * Calculate the following expression between sign-magnitude numbers, ignoring
14885               * the low byte of the result:
14886               *
14887               * (A ?) = (-X * A + (S R)) / 96
14888               *
14889               * This uses the same shift-and-subtract algorithm as TIS2, just with the
14890               * quotient A hard-coded to 96.
14891               *
14892               * ------------------------------------------------------------------------------
14893               *
14894               * Returns:
14895               *
14896               * Q                   Gets set to the value of argument X
14897               *
14898               * ******************************************************************************
14899               
14900               TIS1:
14901 4604 D80E  30        movb rx,@Q                      ; STX Q             ; Set Q = X
     4606 0090     
14902               
14903                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign bit in A
     **** ****     > EOI
0001 4608 0200  20        li   rtmp,(>80*256)
     460A 8000     
0002 460C 2B40  18        xor  rtmp,ra
                   < elite.a99
14904               
14905 460E 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     4610 4566     
14906 4612 06A0  32        bl   @jsr                       ;
     4614 FE28     
14907                                                                          ; = X * -A + (S R)
14908               
14909               DVID96:
14910 4616 D38D  18        movb ra,rx                      ; TAX               ; Set T to the sign bit of the result
14911 4618 024D  22        andi ra,>80*256                 ; AND #%10000000
     461A 8000     
14912 461C D80D  30        movb ra,@T                      ; STA T
     461E 00D1     
14913               
14914 4620 D34E  18        movb rx,ra                      ; TXA               ; Set A to the high byte of the result with the sign bit
14915 4622 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; cleared, so (A ?) = |X * A + (S R)|
     4624 7F00     
14916               
14917                                                                          ; The following is identical to TIS2, except Q is
14918                                                                          ; hard-coded to 96, so this does A = A / 96
14919               
14920 4626 020E  20        li   rx,>fe*256                 ; LDX #254          ; Set T1 to have bits 1-7 set, so we can rotate through
     4628 FE00     
14921 462A D80E  30        movb rx,@T1                     ; STX T1            ; 7 loop iterations, getting a 1 each time, and then
     462C 0006     
14922                                                                          ; getting a 0 on the 8th iteration... and we can also
14923                                                                          ; use T1 to catch our result bits into bit 0 each time
14924               
14925               DVL3:
14926                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 462E 024D  22        andi ra,>ff00
     4630 FF00     
0002 4632 0A1D  18        sla  ra,1
                   < elite.a99
14927               
14928 4634 028D  22        ci   ra,>60*256                 ; CMP #96           ; If A < 96 skip the following subtraction
     4636 6000     
14929 4638 1704  14        jnc  DV4                        ; BCC DV4
14930               
14931                      .sbi (>60*256)                  ; SBC #96           ; Set A = A - 96
     **** ****     > SBI
0001 463A 1801  14        joc  !
0002 463C 7347  18        sb   rone,ra
0003               !:
0004 463E 022D  22        ai   ra,-(>60*256)
     4640 A000     
                   < elite.a99
14932                                                                          ;
14933                                                                          ; Going into this subtraction we know the C flag is
14934                                                                          ; set as we passed through the BCC above, and we also
14935                                                                          ; know that A >= 96, so the C flag will still be set
14936                                                                          ; once we are done
14937               
14938               DV4:
14939 4642 0204  20        li   rarg1,T1                   ; ROL T1            ; Rotate the counter in T1 to the left, and catch the
     4644 0006     
14940 4646 06A0  32        bl   @rol                       ;
     4648 FE4E     
14941                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
14942                                                                          ; do the subtraction, or 1 if we did)
14943               
14944 464A 18F1  14        joc  DVL3                       ; BCS DVL3          ; If we still have set bits in T1, loop back to DVL3 to
14945                                                                          ; do the next iteration of 7
14946               
14947 464C D360  30        movb @T1,ra                     ; LDA T1            ; Fetch the result from T1 into A
     464E 0006     
14948               
14949 4650 F360  30        socb @T,ra                      ; ORA T             ; Give A the sign of the result that we stored above
     4652 00D1     
14950               
14951 4654 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4656 FE34     
14952               
14953               * ******************************************************************************
14954               *
14955               * Name: DV42
14956               * Type: Subroutine
14957               * Category: Maths (Arithmetic)
14958               * Summary: Calculate (P R) = 256 * DELTA / z_hi
14959               *
14960               * ------------------------------------------------------------------------------
14961               *
14962               * Calculate the following division and remainder:
14963               *
14964               * P = DELTA / (the Y-th stardust particle's z_hi coordinate)
14965               *
14966               * R = remainder as a fraction of A, where 1.0 = 255
14967               *
14968               * Another way of saying the above is this:
14969               *
14970               * (P R) = 256 * DELTA / z_hi
14971               *
14972               * DELTA is a value between 1 and 40, and the minimum z_hi is 16 (dust particles
14973               * are removed at lower values than this), so this means P is between 0 and 2
14974               * (as 40 / 16 = 2.5, so the maximum result is P = 2 and R = 128.
14975               *
14976               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
14977               * keep the remainder.
14978               *
14979               * ------------------------------------------------------------------------------
14980               *
14981               * Arguments:
14982               *
14983               * Y                   The number of the stardust particle to process
14984               *
14985               * ------------------------------------------------------------------------------
14986               *
14987               * Returns:
14988               *
14989               * C flag              The C flag is cleared
14990               *
14991               * ******************************************************************************
14992               
14993               DV42:
14994 4658 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Fetch the Y-th dust particle's z_hi coordinate into A
     465A 0EE8     
14995               
14996                                                                          ; Fall through into DV41 to do:
14997                                                                          ;
14998                                                                          ; (P R) = 256 * DELTA / A
14999                                                                          ; = 256 * DELTA / Y-th stardust particle's z_hi
15000               
15001               * ******************************************************************************
15002               *
15003               * Name: DV41
15004               * Type: Subroutine
15005               * Category: Maths (Arithmetic)
15006               * Summary: Calculate (P R) = 256 * DELTA / A
15007               *
15008               * ------------------------------------------------------------------------------
15009               *
15010               * Calculate the following division and remainder:
15011               *
15012               * P = DELTA / A
15013               *
15014               * R = remainder as a fraction of A, where 1.0 = 255
15015               *
15016               * Another way of saying the above is this:
15017               *
15018               * (P R) = 256 * DELTA / A
15019               *
15020               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
15021               * keep the remainder.
15022               *
15023               * ------------------------------------------------------------------------------
15024               *
15025               * Returns:
15026               *
15027               * C flag              The C flag is cleared
15028               *
15029               * ******************************************************************************
15030               
15031               DV41:
15032 465C D80D  30        movb ra,@Q                      ; STA Q             ; Store A in Q
     465E 0090     
15033               
15034 4660 D360  30        movb @DELTA,ra                  ; LDA DELTA         ; Fetch the speed from DELTA into A
     4662 008C     
15035               
15036                                                                          ; Fall through into DVID4 to do:
15037                                                                          ;
15038                                                                          ; (P R) = 256 * A / Q
15039                                                                          ; = 256 * DELTA / A
15040               
15041               * ******************************************************************************
15042               *
15043               * Name: DVID4
15044               * Type: Subroutine
15045               * Category: Maths (Arithmetic)
15046               * Summary: Calculate (P R) = 256 * A / Q
15047               * Deep dive: Shift-and-subtract division
15048               *
15049               * ------------------------------------------------------------------------------
15050               *
15051               * Calculate the following division and remainder:
15052               *
15053               * P = A / Q
15054               *
15055               * R = remainder as a fraction of Q, where 1.0 = 255
15056               *
15057               * Another way of saying the above is this:
15058               *
15059               * (P R) = 256 * A / Q
15060               *
15061               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
15062               * keep the remainder.
15063               *
15064               * ------------------------------------------------------------------------------
15065               *
15066               * Returns:
15067               *
15068               * C flag              The C flag is cleared
15069               *
15070               * ******************************************************************************
15071               
15072               DVID4:
15073 4664 020E  20        li   rx,>08*256                 ; LDX #8            ; Set a counter in X to count the 8 bits in A
     4666 0800     
15074               
15075                      .asla                           ; ASL A             ; Shift A left and store in P (we will build the result
     **** ****     > ASLA
0001 4668 024D  22        andi ra,>ff00
     466A FF00     
0002 466C 0A1D  18        sla  ra,1
                   < elite.a99
15076 466E D80D  30        movb ra,@P                      ; STA P             ; in P)
     4670 001B     
15077               
15078 4672 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 for us to build a remainder
     4674 0000     
15079               
15080               DVL4:
15081 4676 06A0  32        bl   @rola                      ; ROL A             ; Shift A to the left
     4678 FE3E     
15082               
15083 467A 1803  14        joc  DV8                        ; BCS DV8           ; If the C flag is set (i.e. bit 7 of A was set) then
15084                                                                          ; skip straight to the subtraction
15085               
15086 467C 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     467E 0090     
15087 4680 1705  14        jnc  DV5                        ; BCC DV5
15088               
15089               DV8:
15090                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 4682 1801  14        joc  !
0002 4684 7347  18        sb   rone,ra
0003               !:
0004 4686 7360  30        sb   @Q,ra
     4688 0090     
                   < elite.a99
15091               
15092                      .sec                            ; SEC               ; Set the C flag, so that P gets a 1 shifted into bit 0
     **** ****     > SEC
0001 468A 0A18  18        sla  rmone,1
                   < elite.a99
15093               
15094               DV5:
15095 468C 0204  20        li   rarg1,P                    ; ROL P             ; Shift P to the left, pulling the C flag into bit 0
     468E 001B     
15096 4690 06A0  32        bl   @rol                       ;
     4692 FE4E     
15097               
15098 4694 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
15099               
15100 4696 16EF  14        jne  DVL4                       ; BNE DVL4          ; Loop back for the next bit until we have done all 8
15101                                                                          ; bits of P
15102               
15103 4698 0460  28        b    @LL28+4                    ; JMP LL28+4        ; Jump to LL28+4 to convert the remainder in A into an
     469A D408     
15104                                                                          ; integer representation of the fractional value A / Q,
15105                                                                          ; in R, where 1.0 = 255. LL28+4 always returns with the
15106                                                                          ; C flag cleared, and we return from the subroutine
15107                                                                          ; using a tail call
15108               
15109               * ******************************************************************************
15110               *
15111               * Name: DVID3B2
15112               * Type: Subroutine
15113               * Category: Maths (Arithmetic)
15114               * Summary: Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
15115               * Deep dive: Shift-and-subtract division
15116               *
15117               * ------------------------------------------------------------------------------
15118               *
15119               * Calculate the following:
15120               *
15121               * K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
15122               *
15123               * The actual division here is done as an 8-bit calculation using LL31, but this
15124               * routine shifts both the numerator (the top part of the division) and the
15125               * denominator (the bottom part of the division) around to get the multi-byte
15126               * result we want.
15127               *
15128               * Specifically, it shifts both of them to the left as far as possible, keeping a
15129               * tally of how many shifts get done in each one - and specifically, the
15130               * difference in the number of shifts between the top and bottom (as shifting
15131               * both of them once in the same direction won't change the result). It then
15132               * divides the two highest bytes with the simple 8-bit routine in LL31, and
15133               * shifts the result by the difference in the number of shifts, which acts as a
15134               * scale factor to get the correct result.
15135               *
15136               * ------------------------------------------------------------------------------
15137               *
15138               * Returns:
15139               *
15140               * K(3 2 1 0)          The result of the division
15141               *
15142               * X                   X is preserved
15143               *
15144               * ******************************************************************************
15145               
15146               DVID3B2:
15147 469C D80D  30        movb ra,@P+2                    ; STA P+2           ; Set P+2 = A
     469E 001D     
15148               
15149 46A0 D360  30        movb @INWK+6,ra                 ; LDA INWK+6        ; Set Q = z_lo
     46A2 0059     
15150 46A4 D80D  30        movb ra,@Q                      ; STA Q
     46A6 0090     
15151               
15152 46A8 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set R = z_hi
     46AA 005A     
15153 46AC D80D  30        movb ra,@R                      ; STA R
     46AE 0091     
15154               
15155 46B0 D360  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set S = z_sign
     46B2 005B     
15156 46B4 D80D  30        movb ra,@S                      ; STA S
     46B6 0092     
15157               
15158               DVID3B:
15159                                                                          ; Given the above assignments, we now want to calculate
15160                                                                          ; the following to get the result we want:
15161                                                                          ;
15162                                                                          ; K(3 2 1 0) = P(2 1 0) / (S R Q)
15163 46B8 D360  30        movb @P,ra                      ; LDA P             ; Make sure P(2 1 0) is at least 1
     46BA 001B     
15164 46BC 026D  22        ori  ra,>01*256                 ; ORA #1
     46BE 0100     
15165 46C0 D80D  30        movb ra,@P                      ; STA P
     46C2 001B     
15166               
15167 46C4 D360  30        movb @P+2,ra                    ; LDA P+2           ; Set T to the sign of P+2 * S (i.e. the sign of the
     46C6 001D     
15168                      .eor @S                         ; EOR S             ; result) and store it in T
     **** ****     > EOR
0001 46C8 D020  30        movb @S,rtmp
     46CA 0092     
0002 46CC 2B40  18        xor  rtmp,ra
                   < elite.a99
15169 46CE 024D  22        andi ra,>80*256                 ; AND #%10000000
     46D0 8000     
15170 46D2 D80D  30        movb ra,@T                      ; STA T
     46D4 00D1     
15171               
15172 46D6 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0 to store the scale factor
     46D8 0000     
15173               
15174 46DA D360  30        movb @P+2,ra                    ; LDA P+2           ; Clear the sign bit of P+2, so the division can be done
     46DC 001D     
15175 46DE 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; with positive numbers and we'll set the correct sign
     46E0 7F00     
15176                                                                          ; below, once all the maths is done
15177                                                                          ;
15178                                                                          ; This also leaves A = P+2, which we use below
15179               
15180               DVL9:
15181                                                                          ; We now shift (A P+1 P) left until A >= 64, counting
15182                                                                          ; the number of shifts in Y. This makes the top part of
15183                                                                          ; the division as large as possible, thus retaining as
15184                                                                          ; much accuracy as we can.  When we come to return the
15185                                                                          ; final result, we shift the result by the number of
15186                                                                          ; places in Y, and in the correct direction
15187 46E2 028D  22        ci   ra,>40*256                 ; CMP #64           ; If A >= 64, jump down to DV14
     46E4 4000     
15188 46E6 180F  14        joc  DV14                       ; BCS DV14
15189               
15190                      .asl @P                         ; ASL P             ; Shift (A P+1 P) to the left
     **** ****     > ASL
0001 46E8 D020  30        movb @P,rtmp
     46EA 001B     
0002 46EC 0240  22        andi rtmp,>ff00
     46EE FF00     
0003 46F0 0A10  18        sla  rtmp,1
0004 46F2 D800  30        movb rtmp,@P
     46F4 001B     
                   < elite.a99
15191 46F6 0204  20        li   rarg1,P+1                  ; ROL P+1
     46F8 001C     
15192 46FA 06A0  32        bl   @rol                       ;
     46FC FE4E     
15193 46FE 06A0  32        bl   @rola                      ; ROL A
     4700 FE3E     
15194               
15195 4702 B3C7  18        ab   rone,ry                    ; INY               ; Increment the scale factor in Y
15196               
15197 4704 16EE  14        jne  DVL9                       ; BNE DVL9          ; Loop up to DVL9 (this BNE is effectively a JMP, as Y
15198                                                                          ; will never be zero)
15199               
15200               DV14:
15201                                                                          ; If we get here, A >= 64 and contains the highest byte
15202                                                                          ; of the numerator, scaled up by the number of left
15203                                                                          ; shifts in Y
15204 4706 D80D  30        movb ra,@P+2                    ; STA P+2           ; Store A in P+2, so we now have the scaled value of
     4708 001D     
15205                                                                          ; the numerator in P(2 1 0)
15206               
15207 470A D360  30        movb @S,ra                      ; LDA S             ; Set A = |S|
     470C 0092     
15208 470E 024D  22        andi ra,>7f*256                 ; AND #%01111111
     4710 7F00     
15209               
15210 4712 110F  14        jlt  DV9                        ; BMI DV9           ; If bit 7 of A is set, jump down to DV9 to skip the
15211                                                                          ; left-shifting of the denominator (though this branch
15212                                                                          ; instruction has no effect as bit 7 of the above AND
15213                                                                          ; can never be set, which is why this instruction was
15214                                                                          ; removed from later versions)
15215               
15216               DVL6:
15217                                                                          ; We now shift (S R Q) left until bit 7 of S is set,
15218                                                                          ; reducing Y by the number of shifts. This makes the
15219                                                                          ; bottom part of the division as large as possible, thus
15220                                                                          ; retaining as much accuracy as we can. When we come to
15221                                                                          ; return the final result, we shift the result by the
15222                                                                          ; total number of places in Y, and in the correct
15223                                                                          ; direction, to give us the correct result
15224                                                                          ;
15225                                                                          ; We set A to |S| above, so the following actually
15226                                                                          ; shifts (A R Q)
15227 4714 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the scale factor in Y
15228               
15229                      .asl @Q                         ; ASL Q             ; Shift (A R Q) to the left
     **** ****     > ASL
0001 4716 D020  30        movb @Q,rtmp
     4718 0090     
0002 471A 0240  22        andi rtmp,>ff00
     471C FF00     
0003 471E 0A10  18        sla  rtmp,1
0004 4720 D800  30        movb rtmp,@Q
     4722 0090     
                   < elite.a99
15230 4724 0204  20        li   rarg1,R                    ; ROL R
     4726 0091     
15231 4728 06A0  32        bl   @rol                       ;
     472A FE4E     
15232 472C 06A0  32        bl   @rola                      ; ROL A
     472E FE3E     
15233               
15234 4730 15F1  14        jgt  DVL6                       ; BPL DVL6          ; Loop up to DVL6 to do another shift, until bit 7 of A
15235                                                                          ; is set and we can't shift left any further
15236               
15237               DV9:
15238                                                                          ; We have now shifted both the numerator and denominator
15239                                                                          ; left as far as they will go, keeping a tally of the
15240                                                                          ; overall scale factor of the various shifts in Y. We
15241                                                                          ; can now divide just the two highest bytes to get our
15242                                                                          ; result
15243 4732 D80D  30        movb ra,@Q                      ; STA Q             ; Set Q = A, the highest byte of the denominator
     4734 0090     
15244               
15245 4736 020D  20        li   ra,>fe*256                 ; LDA #254          ; Set R to have bits 1-7 set, so we can pass this to
     4738 FE00     
15246 473A D80D  30        movb ra,@R                      ; STA R             ; LL31 to act as the bit counter in the division
     473C 0091     
15247               
15248 473E D360  30        movb @P+2,ra                    ; LDA P+2           ; Set A to the highest byte of the numerator
     4740 001D     
15249               
15250 4742 0200  20        li   rtmp,LL31                  ; JSR LL31          ; Call LL31 to calculate:
     4744 D412     
15251 4746 06A0  32        bl   @jsr                       ;
     4748 FE28     
15252                                                                          ;
15253                                                                          ; R = 256 * A / Q
15254                                                                          ; = 256 * numerator / denominator
15255               
15256                                                                          ; The result of our division is now in R, so we just
15257                                                                          ; need to shift it back by the scale factor in Y
15258               
15259 474A 020D  20        li   ra,>00*256                 ; LDA #0            ; Set K(3 2 1) = 0 to hold the result (we populate K
     474C 0000     
15260 474E D80D  30        movb ra,@K+1                    ; STA K+1           ; next)
     4750 003E     
15261 4752 D80D  30        movb ra,@K+2                    ; STA K+2
     4754 003F     
15262 4756 D80D  30        movb ra,@K+3                    ; STA K+3
     4758 0040     
15263               
15264 475A D34F  18        movb ry,ra                      ; TYA               ; If Y is positive, jump to DV12
15265 475C 1527  14        jgt  DV12                       ; BPL DV12
15266               
15267                                                                          ; If we get here then Y is negative, so we need to shift
15268                                                                          ; the result R to the left by Y places, and then set the
15269                                                                          ; correct sign for the result
15270               
15271 475E D360  30        movb @R,ra                      ; LDA R             ; Set A = R
     4760 0091     
15272               
15273               DVL8:
15274                      .asla                           ; ASL A             ; Shift (K+3 K+2 K+1 A) left
     **** ****     > ASLA
0001 4762 024D  22        andi ra,>ff00
     4764 FF00     
0002 4766 0A1D  18        sla  ra,1
                   < elite.a99
15275 4768 0204  20        li   rarg1,K+1                  ; ROL K+1
     476A 003E     
15276 476C 06A0  32        bl   @rol                       ;
     476E FE4E     
15277 4770 0204  20        li   rarg1,K+2                  ; ROL K+2
     4772 003F     
15278 4774 06A0  32        bl   @rol                       ;
     4776 FE4E     
15279 4778 0204  20        li   rarg1,K+3                  ; ROL K+3
     477A 0040     
15280 477C 06A0  32        bl   @rol                       ;
     477E FE4E     
15281               
15282 4780 B3C7  18        ab   rone,ry                    ; INY               ; Increment the scale factor in Y
15283               
15284 4782 16EF  14        jne  DVL8                       ; BNE DVL8          ; Loop back to DVL8 until we have shifted left by Y
15285                                                                          ; places
15286               
15287 4784 D80D  30        movb ra,@K                      ; STA K             ; Store A in K so the result is now in K(3 2 1 0)
     4786 003D     
15288               
15289 4788 D360  30        movb @K+3,ra                    ; LDA K+3           ; Set K+3 to the sign in T, which we set above to the
     478A 0040     
15290 478C F360  30        socb @T,ra                      ; ORA T             ; correct sign for the result
     478E 00D1     
15291 4790 D80D  30        movb ra,@K+3                    ; STA K+3
     4792 0040     
15292               
15293 4794 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4796 FE34     
15294               
15295               DV13:
15296                                                                          ; If we get here then Y is zero, so we don't need to
15297                                                                          ; shift the result R, we just need to set the correct
15298                                                                          ; sign for the result
15299 4798 D360  30        movb @R,ra                      ; LDA R             ; Store R in K so the result is now in K(3 2 1 0)
     479A 0091     
15300 479C D80D  30        movb ra,@K                      ; STA K
     479E 003D     
15301               
15302 47A0 D360  30        movb @T,ra                      ; LDA T             ; Set K+3 to the sign in T, which we set above to the
     47A2 00D1     
15303 47A4 D80D  30        movb ra,@K+3                    ; STA K+3           ; correct sign for the result
     47A6 0040     
15304               
15305 47A8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     47AA FE34     
15306               
15307               DV12:
15308 47AC 13F5  14        jeq  DV13                       ; BEQ DV13          ; We jumped here having set A to the scale factor in Y,
15309                                                                          ; so this jumps up to DV13 if Y = 0
15310               
15311                                                                          ; If we get here then Y is positive and non-zero, so we
15312                                                                          ; need to shift the result R to the right by Y places
15313                                                                          ; and then set the correct sign for the result. We also
15314                                                                          ; know that K(3 2 1) will stay 0, as we are shifting the
15315                                                                          ; lowest byte to the right, so no set bits will make
15316                                                                          ; their way into the top three bytes
15317               
15318 47AE D360  30        movb @R,ra                      ; LDA R             ; Set A = R
     47B0 0091     
15319               
15320               DVL10:
15321 47B2 091D  18        srl  ra,1                       ; LSR A             ; Shift A right
15322               
15323 47B4 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the scale factor in Y
15324               
15325 47B6 16FD  14        jne  DVL10                      ; BNE DVL10         ; Loop back to DVL10 until we have shifted right by Y
15326                                                                          ; places
15327               
15328 47B8 D80D  30        movb ra,@K                      ; STA K             ; Store the shifted A in K so the result is now in
     47BA 003D     
15329                                                                          ; K(3 2 1 0)
15330               
15331 47BC D360  30        movb @T,ra                      ; LDA T             ; Set K+3 to the sign in T, which we set above to the
     47BE 00D1     
15332 47C0 D80D  30        movb ra,@K+3                    ; STA K+3           ; correct sign for the result
     47C2 0040     
15333               
15334 47C4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     47C6 FE34     
15335               
15336               * ******************************************************************************
15337               *
15338               * Name: cntr
15339               * Type: Subroutine
15340               * Category: Dashboard
15341               * Summary: Apply damping to the pitch or roll dashboard indicator
15342               *
15343               * ------------------------------------------------------------------------------
15344               *
15345               * Apply damping to the value in X, where X ranges from 1 to 255 with 128 as the
15346               * centre point (so X represents a position on a centre-based dashboard slider,
15347               * such as pitch or roll). If the value is in the left-hand side of the slider
15348               * (1-127) then it bumps the value up by 1 so it moves towards the centre, and
15349               * if it's in the right-hand side, it reduces it by 1, also moving it towards the
15350               * centre.
15351               *
15352               * ******************************************************************************
15353               
15354               cntr_:
15355 47C8 D360  30        movb @DAMP,ra                   ; LDA DAMP          ; If DAMP is non-zero, then keyboard damping is not
     47CA 0F4A     
15356 47CC 1608  14        jne  RE1                        ; BNE RE1           ; enabled, so jump to RE1 to return from the subroutine
15357               
15358 47CE D34E  18        movb rx,ra                      ; TXA               ; If X < 128, then it's in the left-hand side of the
15359 47D0 1502  14        jgt  BUMP                       ; BPL BUMP          ; dashboard slider, so jump to BUMP to bump it up by 1,
15360                                                                          ; to move it closer to the centre
15361               
15362 47D2 7387  18        sb   rone,rx                    ; DEX               ; Otherwise X >= 128, so it's in the right-hand side
15363 47D4 1104  14        jlt  RE1                        ; BMI RE1           ; of the dashboard slider, so decrement X by 1, and if
15364                                                                          ; it's still >= 128, jump to RE1 to return from the
15365                                                                          ; subroutine, otherwise fall through to BUMP to undo
15366                                                                          ; the bump and then return
15367               
15368               BUMP:
15369 47D6 B387  18        ab   rone,rx                    ; INX               ; Bump X up by 1, and if it hasn't overshot the end of
15370 47D8 1602  14        jne  RE1                        ; BNE RE1           ; the dashboard slider, jump to RE1 to return from the
15371                                                                          ; subroutine, otherwise fall through to REDU to drop
15372                                                                          ; it down by 1 again
15373               
15374               REDU:
15375 47DA 7387  18        sb   rone,rx                    ; DEX               ; Reduce X by 1, and if we have reached 0 jump up to
15376 47DC 13FC  14        jeq  BUMP                       ; BEQ BUMP          ; BUMP to add 1, because we need the value to be in the
15377                                                                          ; range 1 to 255
15378               
15379               RE1:
15380 47DE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     47E0 FE34     
15381               
15382               * ******************************************************************************
15383               *
15384               * Name: BUMP2
15385               * Type: Subroutine
15386               * Category: Dashboard
15387               * Summary: Bump up the value of the pitch or roll dashboard indicator
15388               *
15389               * ------------------------------------------------------------------------------
15390               *
15391               * Increase ("bump up") X by A, where X is either the current rate of pitch or
15392               * the current rate of roll.
15393               *
15394               * The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
15395               * This is the amount by which the pitch or roll is currently changing, so 1
15396               * means it is decreasing at the maximum rate, 128 means it is not changing,
15397               * and 255 means it is increasing at the maximum rate. These values correspond
15398               * to the line on the DC or RL indicators on the dashboard, with 1 meaning full
15399               * left, 128 meaning the middle, and 255 meaning full right.
15400               *
15401               * If bumping up X would push it past 255, then X is set to 255.
15402               *
15403               * If keyboard auto-recentre is configured and the result is less than 128, we
15404               * bump X up to the mid-point, 128. This is the equivalent of having a roll or
15405               * pitch in the left half of the indicator, when increasing the roll or pitch
15406               * should jump us straight to the mid-point.
15407               *
15408               * ------------------------------------------------------------------------------
15409               *
15410               * Other entry points:
15411               *
15412               * RE2+2               Restore A from T and return from the subroutine
15413               *
15414               * ******************************************************************************
15415               
15416               BUMP2:
15417 47E2 D80D  30        movb ra,@T                      ; STA T             ; Store argument A in T so we can restore it later
     47E4 00D1     
15418               
15419 47E6 D34E  18        movb rx,ra                      ; TXA               ; Copy argument X into A
15420               
15421                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 47E8 0A16  18        sla  rzero,1
                   < elite.a99
15422                                                                          ; C flag affecting the result
15423               
15424                      .adc @T,ra                      ; ADC T             ; Set X = A = argument X + argument A
     **** ****     > ADC
0001 47EA 1701  14        jnc  !
0002 47EC B347  18        ab   rone,ra
0003               !:
0004 47EE B360  30        ab   @T,ra
     47F0 00D1     
                   < elite.a99
15425 47F2 D38D  18        movb ra,rx                      ; TAX
15426               
15427 47F4 1702  14        jnc  RE2                        ; BCC RE2           ; If the C flag is clear, then we didn't overflow, so
15428                                                                          ; jump to RE2 to auto-recentre and return the result
15429               
15430 47F6 020E  20        li   rx,>ff*256                 ; LDX #255          ; We have an overflow, so set X to the maximum possible
     47F8 FF00     
15431                                                                          ; value of 255
15432               
15433               RE2:
15434 47FA 1511  14        jgt  RE3+2                      ; BPL RE3+2         ; If X has bit 7 clear (i.e. the result < 128), then
15435                                                                          ; jump to RE3+2 in routine REDU2 to do an auto-recentre,
15436                                                                          ; if configured, because the result is on the left side
15437                                                                          ; of the centre point of 128
15438               
15439                                                                          ; Jumps to RE2+2 end up here
15440               
15441 47FC D360  30        movb @T,ra                      ; LDA T             ; Restore the original argument A from T into A
     47FE 00D1     
15442               
15443 4800 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4802 FE34     
15444               
15445               * ******************************************************************************
15446               *
15447               * Name: REDU2
15448               * Type: Subroutine
15449               * Category: Dashboard
15450               * Summary: Reduce the value of the pitch or roll dashboard indicator
15451               *
15452               * ------------------------------------------------------------------------------
15453               *
15454               * Reduce X by A, where X is either the current rate of pitch or the current
15455               * rate of roll.
15456               *
15457               * The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
15458               * This is the amount by which the pitch or roll is currently changing, so 1
15459               * means it is decreasing at the maximum rate, 128 means it is not changing,
15460               * and 255 means it is increasing at the maximum rate. These values correspond
15461               * to the line on the DC or RL indicators on the dashboard, with 1 meaning full
15462               * left, 128 meaning the middle, and 255 meaning full right.
15463               *
15464               * If reducing X would bring it below 1, then X is set to 1.
15465               *
15466               * If keyboard auto-recentre is configured and the result is greater than 128, we
15467               * reduce X down to the mid-point, 128. This is the equivalent of having a roll
15468               * or pitch in the right half of the indicator, when decreasing the roll or pitch
15469               * should jump us straight to the mid-point.
15470               *
15471               * ------------------------------------------------------------------------------
15472               *
15473               * Other entry points:
15474               *
15475               * RE3+2               Auto-recentre the value in X, if keyboard auto-recentre
15476               * is configured
15477               *
15478               * ******************************************************************************
15479               
15480               REDU2:
15481 4804 D80D  30        movb ra,@T                      ; STA T             ; Store argument A in T so we can restore it later
     4806 00D1     
15482               
15483 4808 D34E  18        movb rx,ra                      ; TXA               ; Copy argument X into A
15484               
15485                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 480A 0A18  18        sla  rmone,1
                   < elite.a99
15486                                                                          ; C flag affecting the result
15487               
15488                      .sbc @T,ra                      ; SBC T             ; Set X = A = argument X - argument A
     **** ****     > SBC
0001 480C 1801  14        joc  !
0002 480E 7347  18        sb   rone,ra
0003               !:
0004 4810 7360  30        sb   @T,ra
     4812 00D1     
                   < elite.a99
15489 4814 D38D  18        movb ra,rx                      ; TAX
15490               
15491 4816 1802  14        joc  RE3                        ; BCS RE3           ; If the C flag is set, then we didn't underflow, so
15492                                                                          ; jump to RE3 to auto-recentre and return the result
15493               
15494 4818 020E  20        li   rx,>01*256                 ; LDX #1            ; We have an underflow, so set X to the minimum possible
     481A 0100     
15495                                                                          ; value, 1
15496               
15497               RE3:
15498 481C 15EF  14        jgt  RE2+2                      ; BPL RE2+2         ; If X has bit 7 clear (i.e. the result < 128), then
15499                                                                          ; jump to RE2+2 above to return the result as is,
15500                                                                          ; because the result is on the left side of the centre
15501                                                                          ; point of 128, so we don't need to auto-centre
15502               
15503                                                                          ; Jumps to RE3+2 end up here
15504               
15505                                                                          ; If we get here, then we need to apply auto-recentre,
15506                                                                          ; if it is configured
15507               
15508 481E D360  30        movb @DJD,ra                    ; LDA DJD           ; If keyboard auto-recentre is disabled, then
     4820 0F4B     
15509 4822 16EC  14        jne  RE2+2                      ; BNE RE2+2         ; jump to RE2+2 to restore A and return
15510               
15511 4824 020E  20        li   rx,>80*256                 ; LDX #128          ; If we get here then keyboard auto-recentre is enabled,
     4826 8000     
15512 4828 11E9  14        jlt  RE2+2                      ; BMI RE2+2         ; so set X to 128 (the middle of our range) and jump to
15513                                                                          ; RE2+2 to restore A and return from the subroutine
15514                                                                          ; (this BMI is effectively a JMP as bit 7 of X is always
15515                                                                          ; set)
15516               
15517               * ******************************************************************************
15518               *
15519               * Name: ARCTAN
15520               * Type: Subroutine
15521               * Category: Maths (Geometry)
15522               * Summary: Calculate A = arctan(P / Q)
15523               * Deep dive: The sine, cosine and arctan tables
15524               *
15525               * ------------------------------------------------------------------------------
15526               *
15527               * Calculate the following:
15528               *
15529               * A = arctan(P / Q)
15530               *
15531               * In other words, this finds the angle in the right-angled triangle where the
15532               * opposite side to angle A is length P and the adjacent side to angle A has
15533               * length Q, so:
15534               *
15535               * tan(A) = P / Q
15536               *
15537               * The result in A is an integer representing the angle in radians. The routine
15538               * returns values in the range 0 to 128, which covers 0 to 180 degrees (or 0 to
15539               * PI radians).
15540               *
15541               * ******************************************************************************
15542               
15543               ARCTAN:
15544 482A D360  30        movb @P,ra                      ; LDA P             ; Set T1 = P EOR Q, which will have the sign of P * Q
     482C 001B     
15545                      .eor @Q                         ; EOR Q             ;
     **** ****     > EOR
0001 482E D020  30        movb @Q,rtmp
     4830 0090     
0002 4832 2B40  18        xor  rtmp,ra
                   < elite.a99
15546               * AND #%10000000         \ The AND is commented out in the original source
15547 4834 D80D  30        movb ra,@T1                     ; STA T1
     4836 0006     
15548               
15549 4838 D360  30        movb @Q,ra                      ; LDA Q             ; If Q = 0, jump to AR2 to return a right angle
     483A 0090     
15550 483C 132B  14        jeq  AR2                        ; BEQ AR2
15551               
15552                      .asla                           ; ASL A             ; Set Q = |Q| * 2 (this is a quick way of clearing the
     **** ****     > ASLA
0001 483E 024D  22        andi ra,>ff00
     4840 FF00     
0002 4842 0A1D  18        sla  ra,1
                   < elite.a99
15553 4844 D80D  30        movb ra,@Q                      ; STA Q             ; sign bit, and we don't need to shift right again as we
     4846 0090     
15554                                                                          ; only ever use this value in the division with |P| * 2,
15555                                                                          ; which we set next)
15556               
15557 4848 D360  30        movb @P,ra                      ; LDA P             ; Set A = |P| * 2
     484A 001B     
15558                      .asla                           ; ASL A
     **** ****     > ASLA
0001 484C 024D  22        andi ra,>ff00
     484E FF00     
0002 4850 0A1D  18        sla  ra,1
                   < elite.a99
15559               
15560 4852 9360  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, i.e. |P| > |Q|, jump to AR1 to swap P
     4854 0090     
15561 4856 180A  14        joc  AR1                        ; BCS AR1           ; and Q around, so we can still use the lookup table
15562               
15563 4858 0200  20        li   rtmp,ARS1                  ; JSR ARS1          ; Call ARS1 to set the following from the lookup table:
     485A 48B0     
15564 485C 06A0  32        bl   @jsr                       ;
     485E FE28     
15565                                                                          ;
15566                                                                          ; A = arctan(A / Q)
15567                                                                          ; = arctan(|P / Q|)
15568               
15569                      .sec                            ; SEC               ; Set the C flag so the SBC instruction in AR3 will be
     **** ****     > SEC
0001 4860 0A18  18        sla  rmone,1
                   < elite.a99
15570                                                                          ; correct, should we jump there
15571               
15572               AR4:
15573 4862 D3A0  30        movb @T1,rx                     ; LDX T1            ; If T1 is negative, i.e. P and Q have different signs,
     4864 0006     
15574 4866 111A  14        jlt  AR3                        ; BMI AR3           ; jump down to AR3 to return arctan(-|P / Q|)
15575               
15576 4868 0460  28        b    @rts                       ; RTS               ; Otherwise P and Q have the same sign, so our result is
     486A FE34     
15577                                                                          ; correct and we can return from the subroutine
15578               
15579               AR1:
15580                                                                          ; We want to calculate arctan(t) where |t| > 1, so we
15581                                                                          ; can use the calculation described in the documentation
15582                                                                          ; for the ACT table, i.e. 64 - arctan(1 / t)
15583 486C D3A0  30        movb @Q,rx                      ; LDX Q             ; Swap the values in Q and P, using the fact that we
     486E 0090     
15584 4870 D80D  30        movb ra,@Q                      ; STA Q             ; called AR1 with A = P
     4872 0090     
15585 4874 D80E  30        movb rx,@P                      ; STX P             ;
     4876 001B     
15586 4878 D34E  18        movb rx,ra                      ; TXA               ; This also sets A = P (which now contains the original
15587                                                                          ; argument |Q|)
15588               
15589 487A 0200  20        li   rtmp,ARS1                  ; JSR ARS1          ; Call ARS1 to set the following from the lookup table:
     487C 48B0     
15590 487E 06A0  32        bl   @jsr                       ;
     4880 FE28     
15591                                                                          ;
15592                                                                          ; A = arctan(A / Q)
15593                                                                          ; = arctan(|Q / P|)
15594                                                                          ; = arctan(1 / |P / Q|)
15595               
15596 4882 D80D  30        movb ra,@T                      ; STA T             ; Set T = 64 - T
     4884 00D1     
15597 4886 020D  20        li   ra,>40*256                 ; LDA #64
     4888 4000     
15598                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 488A 1801  14        joc  !
0002 488C 7347  18        sb   rone,ra
0003               !:
0004 488E 7360  30        sb   @T,ra
     4890 00D1     
                   < elite.a99
15599               
15600 4892 18E7  14        joc  AR4                        ; BCS AR4           ; Jump to AR4 to continue the calculation (this BCS is
15601                                                                          ; effectively a JMP as the subtraction will never
15602                                                                          ; underflow, as ARS1 returns values in the range 0-31)
15603               
15604               AR2:
15605                                                                          ; If we get here then Q = 0, so tan(A) = infinity and
15606                                                                          ; A is a right angle, or 0.25 of a circle. We allocate
15607                                                                          ; 255 to a full circle, so we should return 63 for a
15608                                                                          ; right angle
15609 4894 020D  20        li   ra,>3f*256                 ; LDA #63           ; Set A to 63, to represent a right angle
     4896 3F00     
15610               
15611 4898 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     489A FE34     
15612               
15613               AR3:
15614                                                                          ; A contains arctan(|P / Q|) but P and Q have different
15615                                                                          ; signs, so we need to return arctan(-|P / Q|), using
15616                                                                          ; the calculation described in the documentation for the
15617                                                                          ; ACT table, i.e. 128 - A
15618 489C D80D  30        movb ra,@T                      ; STA T             ; Set A = 128 - A
     489E 00D1     
15619 48A0 020D  20        li   ra,>80*256                 ; LDA #128          ;
     48A2 8000     
15620               * SEC                    \ The SEC instruction is commented out in the original
15621                      .sbc @T,ra                      ; SBC T             ; source, and isn't required as we did a SEC before
     **** ****     > SBC
0001 48A4 1801  14        joc  !
0002 48A6 7347  18        sb   rone,ra
0003               !:
0004 48A8 7360  30        sb   @T,ra
     48AA 00D1     
                   < elite.a99
15622                                                                          ; calling AR3
15623               
15624 48AC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     48AE FE34     
15625               
15626               ARS1:
15627                                                                          ; This routine fetches arctan(A / Q) from the ACT table,
15628                                                                          ; so A will be set to an integer in the range 0 to 31
15629                                                                          ; that represents an angle from 0 to 45 degrees (or 0 to
15630                                                                          ; PI / 4 radians)
15631 48B0 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     48B2 D404     
15632 48B4 06A0  32        bl   @jsr                       ;
     48B6 FE28     
15633                                                                          ;
15634                                                                          ; R = 256 * A / Q
15635               
15636 48B8 D360  30        movb @R,ra                      ; LDA R             ; Set X = R / 8
     48BA 0091     
15637 48BC 091D  18        srl  ra,1                       ; LSR A             ; = 32 * A / Q
15638 48BE 091D  18        srl  ra,1                       ; LSR A             ;
15639 48C0 091D  18        srl  ra,1                       ; LSR A             ; so X has the value t * 32 where t = A / Q, which is
15640 48C2 D38D  18        movb ra,rx                      ; TAX               ; what we need to look up values in the ACT table
15641               
15642 48C4 D36E  34        movb @ACT(rx),ra                ; LDA ACT,X         ; Fetch ACT+X from the ACT table into A, so now:
     48C6 48CC     
15643                                                                          ;
15644                                                                          ; A = value in ACT + X
15645                                                                          ; = value in ACT + (32 * A / Q)
15646                                                                          ; = arctan(A / Q)
15647               
15648 48C8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     48CA FE34     
15649               
15650               * ******************************************************************************
15651               *
15652               * Name: ACT
15653               * Type: Variable
15654               * Category: Maths (Geometry)
15655               * Summary: Arctan table
15656               * Deep dive: The sine, cosine and arctan tables
15657               *
15658               * ------------------------------------------------------------------------------
15659               *
15660               * This table contains lookup values for arctangent calculations involving angles
15661               * in the range 0 to 45 degrees (or 0 to PI / 4 radians).
15662               *
15663               * To calculate the value of theta in the following:
15664               *
15665               * theta = arctan(t)
15666               *
15667               * where 0 <= t < 1, we look up the value in:
15668               *
15669               * ACT + (t * 32)
15670               *
15671               * The result will be an integer representing the angle in radians, where 256
15672               * represents a full circle of 360 degrees (2 * PI radians). The result of the
15673               * lookup will therefore be an integer in the range 0 to 31, as this represents
15674               * 0 to 45 degrees (0 to PI / 4 radians).
15675               *
15676               * The table does not support values of t >= 1 or t < 0 directly, so if we need
15677               * to calculate the arctangent for an angle greater than 45 degrees, we can apply
15678               * the following calculation to the result from the table:
15679               *
15680               * * For t > 1, arctan(t) = 64 - arctan(1 / t)
15681               *
15682               * For negative values of t where -1 < t < 0, we can apply the following
15683               * calculation to the result from the table:
15684               *
15685               * * For t < 0, arctan(-t) = 128 - arctan(t)
15686               *
15687               * Finally, if t < -1, we can do the first calculation to get arctan(|t|), and
15688               * the second to get arctan(-|t|).
15689               *
15690               * ******************************************************************************
15691               
15692               ACT:
15693                      ; FOR I%, 0, 31
15694               
15695                      ; EQUB INT((128 / PI) * ATN(I% / 32) + 0.5) ;
15696               
15697                      ; NEXT
15698               
15699 48CC 12              byte >12
15700 48CD   13            byte >13
15701 48CE 14              byte >14
15702 48CF   15            byte >15
15703 48D0 16              byte >16
15704 48D1   17            byte >17
15705 48D2 18              byte >18
15706 48D3   19            byte >19
15707 48D4 1A              byte >1a
15708 48D5   1B            byte >1b
15709 48D6 1B              byte >1b
15710 48D7   1C            byte >1c
15711 48D8 1D              byte >1d
15712 48D9   1D            byte >1d
15713 48DA 1E              byte >1e
15714 48DB   1F            byte >1f
15715 48DC 20              byte >20
15716 48DD   20            byte >20
15717 48DE 21              byte >21
15718 48DF   21            byte >21
15719 48E0 22              byte >22
15720 48E1   22            byte >22
15721 48E2 23              byte >23
15722 48E3   24            byte >24
15723 48E4 24              byte >24
15724 48E5   24            byte >24
15725 48E6 25              byte >25
15726 48E7   25            byte >25
15727 48E8 26              byte >26
15728 48E9   26            byte >26
15729 48EA 27              byte >27
15730 48EB   27            byte >27
15731               
15732               * ******************************************************************************
15733               *
15734               * Name: WARP
15735               * Type: Subroutine
15736               * Category: Flight
15737               * Summary: Perform an in-system jump
15738               *
15739               * ------------------------------------------------------------------------------
15740               *
15741               * This is called when we press "J" during flight. The following checks are
15742               * performed:
15743               *
15744               * * Make sure we don't have any ships or space stations in the vicinity
15745               *
15746               * * Make sure we are not in witchspace
15747               *
15748               * * If we are facing the planet, make sure we aren't too close
15749               *
15750               * * If we are facing the sun, make sure we aren't too close
15751               *
15752               * If the above checks are passed, then we perform an in-system jump by moving
15753               * the sun and planet in the opposite direction to travel, so we appear to jump
15754               * in space. This means that any asteroids, cargo canisters or escape pods get
15755               * dragged along for the ride.
15756               *
15757               * ******************************************************************************
15758               
15759               WARP:
15770               
15771 48EC D360  30        movb @MANY+AST,ra               ; LDA MANY+AST      ; Set X to the total number of asteroids, escape pods
     48EE 0D57     
15772                      .clc                            ; CLC               ; and cargo canisters in the vicinity
     **** ****     > CLC
0001 48F0 0A16  18        sla  rzero,1
                   < elite.a99
15773                      .adc @MANY+ESC,ra               ; ADC MANY+ESC      ;
     **** ****     > ADC
0001 48F2 1701  14        jnc  !
0002 48F4 B347  18        ab   rone,ra
0003               !:
0004 48F6 B360  30        ab   @MANY+ESC,ra
     48F8 0D5A     
                   < elite.a99
15774                      .adc @MANY+OIL,ra               ; ADC MANY+OIL      ; This code saves one byte of memory over the code in
     **** ****     > ADC
0001 48FA 1701  14        jnc  !
0002 48FC B347  18        ab   rone,ra
0003               !:
0004 48FE B360  30        ab   @MANY+OIL,ra
     4900 0D58     
                   < elite.a99
15775 4902 D38D  18        movb ra,rx                      ; TAX               ; the source disc version. The second CLC is not needed
15776                                                                          ; as there is no way that adding the number of asteroids
15777                                                                          ; and the number of escape pods will cause a carry
15778               
15780               
15781 4904 D36E  34        movb @FRIN+2(rx),ra             ; LDA FRIN+2,X      ; If the slot at FRIN+2+X is non-zero, then we have
     4906 0D42     
15782                                                                          ; something else in the vicinity besides asteroids,
15783                                                                          ; escape pods and cargo canisters, so to check whether
15784                                                                          ; we can jump, we first grab the slot contents into A
15785               
15786 4908 F360  30        socb @SSPR,ra                   ; ORA SSPR          ; If there is a space station nearby, then SSPR will
     490A 0D55     
15787                                                                          ; be non-zero, so OR'ing with SSPR will produce a
15788                                                                          ; non-zero result if either A or SSPR are non-zero
15789               
15790 490C F360  30        socb @MJ,ra                     ; ORA MJ            ; If we are in witchspace, then MJ will be non-zero, so
     490E 0D5C     
15791                                                                          ; OR'ing with MJ will produce a non-zero result if
15792                                                                          ; either A or SSPR or MJ are non-zero
15793               
15794 4910 163A  14        jne  WA1                        ; BNE WA1           ; A is non-zero if we have either a ship or a space
15795                                                                          ; station in the vicinity, or we are in witchspace, in
15796                                                                          ; which case jump to WA1 to make a low beep to show that
15797                                                                          ; we can't do an in-system jump
15798               
15799 4912 D3E0  30        movb @K.+8,ry                   ; LDY K%+8          ; Otherwise we can do an in-system jump, so now we fetch
     4914 0908     
15800                                                                          ; the byte at K%+8, which contains the z_sign for the
15801                                                                          ; first ship slot, i.e. the distance of the planet
15802               
15803 4916 1107  14        jlt  WA3                        ; BMI WA3           ; If the planet's z_sign is negative, then the planet
15804                                                                          ; is behind us, so jump to WA3 to skip the following
15805               
15806 4918 D3CD  18        movb ra,ry                      ; TAY               ; Set A = Y = 0 (as we didn't BNE above) so the call
15807                                                                          ; to MAS2 measures the distance to the planet
15808               
15809 491A 0200  20        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to set A to the largest distance to the
     491C 17A2     
15810 491E 06A0  32        bl   @jsr                       ;
     4920 FE28     
15811                                                                          ; planet in any of the three axes (we could also call
15812                                                                          ; routine m to do the same thing, as A = 0)
15813               
15821               
15822 4922 091D  18        srl  ra,1                       ; LSR A             ; If A < 2 then jump to WA1 to abort the in-system jump
15823 4924 1330  14        jeq  WA1                        ; BEQ WA1           ; with a low beep, as we are facing the planet and are
15824                                                                          ; too close to jump in that direction
15825                                                                          ;
15826                                                                          ; These instructions between them save one byte of
15827                                                                          ; memory over the CMP-based code in the source disc
15828                                                                          ; version, as LSR A is a one-byte opcode, while CMP #2
15829                                                                          ; takes up two bytes (though the code does exactly the
15830                                                                          ; same thing)
15831               
15833               
15834               WA3:
15835 4926 D3E0  30        movb @K.+NI.+8,ry               ; LDY K%+NI%+8      ; Fetch the z_sign (byte #8) of the second ship in the
     4928 092C     
15836                                                                          ; ship data workspace at K%, which is reserved for the
15837                                                                          ; sun or the space station (in this case it's the
15838                                                                          ; former, as we already confirmed there isn't a space
15839                                                                          ; station in the vicinity)
15840               
15841 492A 1108  14        jlt  WA2                        ; BMI WA2           ; If the sun's z_sign is negative, then the sun is
15842                                                                          ; behind us, so jump to WA2 to skip the following
15843               
15844 492C 020F  20        li   ry,(NI.)*256               ; LDY #NI%          ; Set Y to point to the offset of the ship data block
     492E 2400     
15845                                                                          ; for the sun, which is NI% (as each block is NI% bytes
15846                                                                          ; long, and the sun is the second block)
15847               
15848 4930 0200  20        li   rtmp,m_                    ; JSR m             ; Call m to set A to the largest distance to the sun
     4932 179E     
15849 4934 06A0  32        bl   @jsr                       ;
     4936 FE28     
15850                                                                          ; in any of the three axes
15851               
15859               
15860 4938 091D  18        srl  ra,1                       ; LSR A             ; If A < 2 then jump to WA1 to abort the in-system jump
15861 493A 1325  14        jeq  WA1                        ; BEQ WA1           ; with a low beep, as we are facing the planet and are
15862                                                                          ; too close to jump in that direction
15863                                                                          ;
15864                                                                          ; These instructions between them save one byte of
15865                                                                          ; memory over the CMP-based code in the source disc
15866                                                                          ; version, as LSR A is a one-byte opcode, while CMP #2
15867                                                                          ; takes up two bytes (though the code does exactly the
15868                                                                          ; same thing)
15869               
15871               
15872               WA2:
15873                                                                          ; If we get here, then we can do an in-system jump, as
15874                                                                          ; we don't have any ships or space stations in the
15875                                                                          ; vicinity, we are not in witchspace, and if we are
15876                                                                          ; facing the planet or the sun, we aren't too close to
15877                                                                          ; jump towards it
15878                                                                          ;
15879                                                                          ; We do an in-system jump by moving the sun and planet,
15880                                                                          ; rather than moving our own local bubble (this is why
15881                                                                          ; in-system jumps drag asteroids, cargo canisters and
15882                                                                          ; escape pods along for the ride). Specifically, we move
15883                                                                          ; them in the z-axis by a fixed amount in the opposite
15884                                                                          ; direction to travel, thus performing a jump towards
15885                                                                          ; our destination
15886 493C 020D  20        li   ra,>81*256                 ; LDA #&81          ; Set R = R = P = &81
     493E 8100     
15887 4940 D80D  30        movb ra,@S                      ; STA S
     4942 0092     
15888 4944 D80D  30        movb ra,@R                      ; STA R
     4946 0091     
15889 4948 D80D  30        movb ra,@P                      ; STA P
     494A 001B     
15890               
15891 494C D360  30        movb @K.+8,ra                   ; LDA K%+8          ; Set A = z_sign for the planet
     494E 0908     
15892               
15893 4950 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     4952 456E     
15894 4954 06A0  32        bl   @jsr                       ;
     4956 FE28     
15895                                                                          ; = (z_sign &81) + &8181
15896                                                                          ; = (z_sign &81) - &0181
15897                                                                          ;
15898                                                                          ; This moves the planet against the direction of travel
15899                                                                          ; by reducing z_sign by 1, as the above maths is:
15900                                                                          ;
15901                                                                          ; z_sign 00000000
15902                                                                          ; +   00000000 10000001
15903                                                                          ; -   00000001 10000001
15904                                                                          ;
15905                                                                          ; or:
15906                                                                          ;
15907                                                                          ; z_sign 00000000
15908                                                                          ; +   00000000 00000000
15909                                                                          ; -   00000001 00000000
15910                                                                          ;
15911                                                                          ; i.e. the high byte is z_sign - 1, making sure the sign
15912                                                                          ; is preserved
15913               
15914 4958 D80D  30        movb ra,@K.+8                   ; STA K%+8          ; Set the planet's z_sign to the high byte of the result
     495A 0908     
15915               
15916 495C D360  30        movb @K.+NI.+8,ra               ; LDA K%+NI%+8      ; Set A = z_sign for the sun
     495E 092C     
15917               
15918 4960 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     4962 456E     
15919 4964 06A0  32        bl   @jsr                       ;
     4966 FE28     
15920                                                                          ; = (z_sign &81) + &8181
15921                                                                          ; = (z_sign &81) - &0181
15922                                                                          ;
15923                                                                          ; which moves the sun against the direction of travel
15924                                                                          ; by reducing z_sign by 1
15925               
15926 4968 D80D  30        movb ra,@K.+NI.+8               ; STA K%+NI%+8      ; Set the planet's z_sign to the high byte of the result
     496A 092C     
15927               
15928 496C 020D  20        li   ra,>01*256                 ; LDA #1            ; Temporarily set the view type to a non-zero value, so
     496E 0100     
15929 4970 D80D  30        movb ra,@QQ11                   ; STA QQ11          ; the call to LOOK1 below clears the screen before
     4972 0096     
15930                                                                          ; switching to the space view
15931               
15932 4974 D80D  30        movb ra,@MCNT                   ; STA MCNT          ; Set the main loop counter to 1, so the next iteration
     4976 0099     
15933                                                                          ; through the main loop will potentially spawn ships
15934                                                                          ; (see part 2 of the main game loop at me3)
15935               
15936 4978 091D  18        srl  ra,1                       ; LSR A             ; Set EV, the extra vessels spawning counter, to 0
15937 497A D80D  30        movb ra,@EV                     ; STA EV            ; (the LSR produces a 0 as A was previously 1)
     497C 0D63     
15938               
15939 497E D3A0  30        movb @VIEW,rx                   ; LDX VIEW          ; Set X to the current view (front, rear, left or right)
     4980 0D5F     
15940 4982 0460  28        b    @LOOK1                     ; JMP LOOK1         ; and jump to LOOK1 to initialise that view, returning
     4984 4B78     
15941                                                                          ; from the subroutine using a tail call
15942               
15943               WA1:
15944 4986 020D  20        li   ra,>28*256                 ; LDA #40           ; If we get here then we can't do an in-system jump, so
     4988 2800     
15945 498A 0460  28        b    @NOISE                     ; JMP NOISE         ; call the NOISE routine with A = 40 to make a long, low
     498C CC5C     
15946                                                                          ; beep and return from the subroutine using a tail call
15947               
15948               * ******************************************************************************
15949               *
15950               * Name: LASLI
15951               * Type: Subroutine
15952               * Category: Drawing lines
15953               * Summary: Draw the laser lines for when we fire our lasers
15954               *
15955               * ------------------------------------------------------------------------------
15956               *
15957               * Draw the laser lines, aiming them to slightly different place each time so
15958               * they appear to flicker and dance. Also heat up the laser temperature and drain
15959               * some energy.
15960               *
15961               * ------------------------------------------------------------------------------
15962               *
15963               * Other entry points:
15964               *
15965               * LASLI2              Just draw the current laser lines without moving the
15966               * centre point, draining energy or heating up. This has
15967               * the effect of removing the lines from the screen
15968               *
15969               * LASLI-1             Contains an RTS
15970               *
15971               * ******************************************************************************
15972               
15973               LASLI:
15974 498E 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     4990 C120     
15975 4992 06A0  32        bl   @jsr                       ;
     4994 FE28     
15976               
15977 4996 024D  22        andi ra,>07*256                 ; AND #7            ; Restrict A to a random value in the range 0 to 7
     4998 0700     
15978               
15979                      .adi ((Y-4)*256)                ; ADC #Y-4          ; Set LASY to four pixels above the centre of the
     **** ****     > ADI
0001 499A 1701  14        jnc  !
0002 499C B347  18        ab   rone,ra
0003               !:
0004 499E 022D  22        ai   ra,((Y-4)*256)
     49A0 5C00     
                   < elite.a99
15980 49A2 D80D  30        movb ra,@LASY                   ; STA LASY          ; screen (#Y), plus our random number, so the laser
     49A4 0F15     
15981                                                                          ; dances above and below the centre point
15982               
15983 49A6 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     49A8 C120     
15984 49AA 06A0  32        bl   @jsr                       ;
     49AC FE28     
15985               
15986 49AE 024D  22        andi ra,>07*256                 ; AND #7            ; Restrict A to a random value in the range 0 to 7
     49B0 0700     
15987               
15988                      .adi ((X-4)*256)                ; ADC #X-4          ; Set LASX to four pixels left of the centre of the
     **** ****     > ADI
0001 49B2 1701  14        jnc  !
0002 49B4 B347  18        ab   rone,ra
0003               !:
0004 49B6 022D  22        ai   ra,((X-4)*256)
     49B8 7C00     
                   < elite.a99
15989 49BA D80D  30        movb ra,@LASX                   ; STA LASX          ; screen (#X), plus our random number, so the laser
     49BC 0F14     
15990                                                                          ; dances to the left and right of the centre point
15991               
15992 49BE D360  30        movb @GNTMP,ra                  ; LDA GNTMP         ; Add 8 to the laser temperature in GNTMP
     49C0 0D61     
15993                      .adi (>08*256)                  ; ADC #8
     **** ****     > ADI
0001 49C2 1701  14        jnc  !
0002 49C4 B347  18        ab   rone,ra
0003               !:
0004 49C6 022D  22        ai   ra,(>08*256)
     49C8 0800     
                   < elite.a99
15994 49CA D80D  30        movb ra,@GNTMP                  ; STA GNTMP
     49CC 0D61     
15995               
15996 49CE 0200  20        li   rtmp,DENGY                 ; JSR DENGY         ; Call DENGY to deplete our energy banks by 1
     49D0 AD22     
15997 49D2 06A0  32        bl   @jsr                       ;
     49D4 FE28     
15998               
15999               LASLI2:
16000 49D6 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view (i.e. QQ11 is non-zero)
     49D8 0096     
16001 49DA 1632  14        jne  PU1-1                      ; BNE PU1-1         ; then jump to MA9 to return from the main flight loop
16002                                                                          ; (as PU1-1 is an RTS)
16003               
16004 49DC 020D  20        li   ra,>20*256                 ; LDA #32           ; Set A = 32 and Y = 224 for the first set of laser
     49DE 2000     
16005 49E0 020F  20        li   ry,>e0*256                 ; LDY #224          ; lines (the wider pair of lines)
     49E2 E000     
16006               
16007 49E4 0200  20        li   rtmp,las_                  ; JSR las           ; Call las below to draw the first set of laser lines
     49E6 49F4     
16008 49E8 06A0  32        bl   @jsr                       ;
     49EA FE28     
16009               
16010 49EC 020D  20        li   ra,>30*256                 ; LDA #48           ; Fall through into las with A = 48 and Y = 208 to draw
     49EE 3000     
16011 49F0 020F  20        li   ry,>d0*256                 ; LDY #208          ; a second set of lines (the narrower pair)
     49F2 D000     
16012               
16013                                                                          ; The following routine draws two laser lines, one from
16014                                                                          ; the centre point down to point A on the bottom row,
16015                                                                          ; and the other from the centre point down to point Y
16016                                                                          ; on the bottom row. We therefore get lines from the
16017                                                                          ; centre point to points 32, 48, 208 and 224 along the
16018                                                                          ; bottom row, giving us the triangular laser effect
16019                                                                          ; we're after
16020               
16021               las_:
16022 49F4 D80D  30        movb ra,@X2                     ; STA X2            ; Set X2 = A
     49F6 0033     
16023               
16024 49F8 D360  30        movb @LASX,ra                   ; LDA LASX          ; Set (X1, Y1) to the random centre point we set above
     49FA 0F14     
16025 49FC D80D  30        movb ra,@X1                     ; STA X1
     49FE 0031     
16026 4A00 D360  30        movb @LASY,ra                   ; LDA LASY
     4A02 0F15     
16027 4A04 D80D  30        movb ra,@Y1                     ; STA Y1
     4A06 0032     
16028               
16029 4A08 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
     4A0A BF00     
16030 4A0C D80D  30        movb ra,@Y2                     ; STA Y2            ; y-coordinate of the mid-point of the space view, so
     4A0E 0034     
16031                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
16032                                                                          ; pixel row of the space view
16033               
16034 4A10 0200  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
     4A12 2272     
16035 4A14 06A0  32        bl   @jsr                       ;
     4A16 FE28     
16036                                                                          ; the centre point to (A, 191)
16037               
16038 4A18 D360  30        movb @LASX,ra                   ; LDA LASX          ; Set (X1, Y1) to the random centre point we set above
     4A1A 0F14     
16039 4A1C D80D  30        movb ra,@X1                     ; STA X1
     4A1E 0031     
16040 4A20 D360  30        movb @LASY,ra                   ; LDA LASY
     4A22 0F15     
16041 4A24 D80D  30        movb ra,@Y1                     ; STA Y1
     4A26 0032     
16042               
16043 4A28 D80F  30        movb ry,@X2                     ; STY X2            ; Set X2 = Y
     4A2A 0033     
16044               
16045 4A2C 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1, the y-coordinate of the bottom
     4A2E BF00     
16046 4A30 D80D  30        movb ra,@Y2                     ; STA Y2            ; pixel row of the space view (as before)
     4A32 0034     
16047               
16048 4A34 0460  28        b    @LOIN                      ; JMP LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
     4A36 2272     
16049                                                                          ; the centre point to (Y, 191), and return from
16050                                                                          ; the subroutine using a tail call
16051               
16052               * ******************************************************************************
16053               *
16054               * Name: PLUT
16055               * Type: Subroutine
16056               * Category: Flight
16057               * Summary: Flip the coordinate axes for the four different views
16058               * Deep dive: Flipping axes between space views
16059               *
16060               * ------------------------------------------------------------------------------
16061               *
16062               * This routine flips the relevant geometric axes in INWK depending on which
16063               * view we are looking through (front, rear, left, right).
16064               *
16065               * ------------------------------------------------------------------------------
16066               *
16067               * Other entry points:
16068               *
16069               * PU1-1               Contains an RTS
16070               *
16071               * ******************************************************************************
16072               
16073               PLUT:
16074 4A38 D3A0  30        movb @VIEW,rx                   ; LDX VIEW          ; Load the current view into X:
     4A3A 0D5F     
16075                                                                          ;
16076                                                                          ; 0 = front
16077                                                                          ; 1 = rear
16078                                                                          ; 2 = left
16079                                                                          ; 3 = right
16080               
16081 4A3C 1602  14        jne  PU1                        ; BNE PU1           ; If the current view is the front view, return from the
16082 4A3E 0460  28        b    @rts                       ; RTS               ; subroutine, as the geometry in INWK is already correct
     4A40 FE34     
16083               
16084               PU1:
16085 4A42 7387  18        sb   rone,rx                    ; DEX               ; Decrement the view, so now:
16086                                                                          ;
16087                                                                          ; 0 = rear
16088                                                                          ; 1 = left
16089                                                                          ; 2 = right
16090               
16091 4A44 163A  14        jne  PU2                        ; BNE PU2           ; If the current view is left or right, jump to PU2,
16092                                                                          ; otherwise this is the rear view, so continue on
16093               
16094 4A46 D360  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Flip the sign of x_sign
     4A48 0055     
16095                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4A4A 0200  20        li   rtmp,(>80*256)
     4A4C 8000     
0002 4A4E 2B40  18        xor  rtmp,ra
                   < elite.a99
16096 4A50 D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     4A52 0055     
16097               
16098 4A54 D360  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Flip the sign of z_sign
     4A56 005B     
16099                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4A58 0200  20        li   rtmp,(>80*256)
     4A5A 8000     
0002 4A5C 2B40  18        xor  rtmp,ra
                   < elite.a99
16100 4A5E D80D  30        movb ra,@INWK+8                 ; STA INWK+8
     4A60 005B     
16101               
16102 4A62 D360  30        movb @INWK+10,ra                ; LDA INWK+10       ; Flip the sign of nosev_x_hi
     4A64 005D     
16103                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4A66 0200  20        li   rtmp,(>80*256)
     4A68 8000     
0002 4A6A 2B40  18        xor  rtmp,ra
                   < elite.a99
16104 4A6C D80D  30        movb ra,@INWK+10                ; STA INWK+10
     4A6E 005D     
16105               
16106 4A70 D360  30        movb @INWK+14,ra                ; LDA INWK+14       ; Flip the sign of nosev_z_hi
     4A72 0061     
16107                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4A74 0200  20        li   rtmp,(>80*256)
     4A76 8000     
0002 4A78 2B40  18        xor  rtmp,ra
                   < elite.a99
16108 4A7A D80D  30        movb ra,@INWK+14                ; STA INWK+14
     4A7C 0061     
16109               
16110 4A7E D360  30        movb @INWK+16,ra                ; LDA INWK+16       ; Flip the sign of roofv_x_hi
     4A80 0063     
16111                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4A82 0200  20        li   rtmp,(>80*256)
     4A84 8000     
0002 4A86 2B40  18        xor  rtmp,ra
                   < elite.a99
16112 4A88 D80D  30        movb ra,@INWK+16                ; STA INWK+16
     4A8A 0063     
16113               
16114 4A8C D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Flip the sign of roofv_z_hi
     4A8E 0067     
16115                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4A90 0200  20        li   rtmp,(>80*256)
     4A92 8000     
0002 4A94 2B40  18        xor  rtmp,ra
                   < elite.a99
16116 4A96 D80D  30        movb ra,@INWK+20                ; STA INWK+20
     4A98 0067     
16117               
16118 4A9A D360  30        movb @INWK+22,ra                ; LDA INWK+22       ; Flip the sign of sidev_x_hi
     4A9C 0069     
16119                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4A9E 0200  20        li   rtmp,(>80*256)
     4AA0 8000     
0002 4AA2 2B40  18        xor  rtmp,ra
                   < elite.a99
16120 4AA4 D80D  30        movb ra,@INWK+22                ; STA INWK+22
     4AA6 0069     
16121               
16122 4AA8 D360  30        movb @INWK+26,ra                ; LDA INWK+26       ; Flip the sign of roofv_z_hi
     4AAA 006D     
16123                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4AAC 0200  20        li   rtmp,(>80*256)
     4AAE 8000     
0002 4AB0 2B40  18        xor  rtmp,ra
                   < elite.a99
16124 4AB2 D80D  30        movb ra,@INWK+26                ; STA INWK+26
     4AB4 006D     
16125               
16126 4AB6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4AB8 FE34     
16127               
16128               PU2:
16129                                                                          ; We enter this with X set to the view, as follows:
16130                                                                          ;
16131                                                                          ; 1 = left
16132                                                                          ; 2 = right
16133 4ABA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set RAT2 = 0 (left view) or -1 (right view)
     4ABC 0000     
16134 4ABE 028E  22        ci   rx,>02*256                 ; CPX #2
     4AC0 0200     
16135 4AC2 06A0  32        bl   @rora                      ; ROR A
     4AC4 FE62     
16136 4AC6 D80D  30        movb ra,@RAT2                   ; STA RAT2
     4AC8 00AB     
16137               
16138                      .eoi (>80*256)                  ; EOR #%10000000    ; Set RAT = -1 (left view) or 0 (right view)
     **** ****     > EOI
0001 4ACA 0200  20        li   rtmp,(>80*256)
     4ACC 8000     
0002 4ACE 2B40  18        xor  rtmp,ra
                   < elite.a99
16139 4AD0 D80D  30        movb ra,@RAT                    ; STA RAT
     4AD2 00AA     
16140               
16141 4AD4 D360  30        movb @INWK,ra                   ; LDA INWK          ; Swap x_lo and z_lo
     4AD6 0053     
16142 4AD8 D3A0  30        movb @INWK+6,rx                 ; LDX INWK+6
     4ADA 0059     
16143 4ADC D80D  30        movb ra,@INWK+6                 ; STA INWK+6
     4ADE 0059     
16144 4AE0 D80E  30        movb rx,@INWK                   ; STX INWK
     4AE2 0053     
16145               
16146 4AE4 D360  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Swap x_hi and z_hi
     4AE6 0054     
16147 4AE8 D3A0  30        movb @INWK+7,rx                 ; LDX INWK+7
     4AEA 005A     
16148 4AEC D80D  30        movb ra,@INWK+7                 ; STA INWK+7
     4AEE 005A     
16149 4AF0 D80E  30        movb rx,@INWK+1                 ; STX INWK+1
     4AF2 0054     
16150               
16151 4AF4 D360  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Swap x_sign and z_sign
     4AF6 0055     
16152                      .eor @RAT                       ; EOR RAT           ; If left view, flip sign of new z_sign
     **** ****     > EOR
0001 4AF8 D020  30        movb @RAT,rtmp
     4AFA 00AA     
0002 4AFC 2B40  18        xor  rtmp,ra
                   < elite.a99
16153 4AFE D38D  18        movb ra,rx                      ; TAX               ; If right view, flip sign of new x_sign
16154 4B00 D360  30        movb @INWK+8,ra                 ; LDA INWK+8
     4B02 005B     
16155                      .eor @RAT2                      ; EOR RAT2
     **** ****     > EOR
0001 4B04 D020  30        movb @RAT2,rtmp
     4B06 00AB     
0002 4B08 2B40  18        xor  rtmp,ra
                   < elite.a99
16156 4B0A D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     4B0C 0055     
16157 4B0E D80E  30        movb rx,@INWK+8                 ; STX INWK+8
     4B10 005B     
16158               
16159 4B12 020F  20        li   ry,>09*256                 ; LDY #9            ; Swap nosev_x_lo and nosev_z_lo
     4B14 0900     
16160 4B16 0200  20        li   rtmp,PUS1                  ; JSR PUS1          ; Swap nosev_x_hi and nosev_z_hi
     4B18 4B2E     
16161 4B1A 06A0  32        bl   @jsr                       ;
     4B1C FE28     
16162                                                                          ; If left view, flip sign of new nosev_z_hi
16163                                                                          ; If right view, flip sign of new nosev_x_hi
16164               
16165 4B1E 020F  20        li   ry,>0f*256                 ; LDY #15           ; Swap roofv_x_lo and roofv_z_lo
     4B20 0F00     
16166 4B22 0200  20        li   rtmp,PUS1                  ; JSR PUS1          ; Swap roofv_x_hi and roofv_z_hi
     4B24 4B2E     
16167 4B26 06A0  32        bl   @jsr                       ;
     4B28 FE28     
16168                                                                          ; If left view, flip sign of new roofv_z_hi
16169                                                                          ; If right view, flip sign of new roofv_x_hi
16170               
16171 4B2A 020F  20        li   ry,>15*256                 ; LDY #21           ; Swap sidev_x_lo and sidev_z_lo
     4B2C 1500     
16172                                                                          ; Swap sidev_x_hi and sidev_z_hi
16173                                                                          ; If left view, flip sign of new sidev_z_hi
16174                                                                          ; If right view, flip sign of new sidev_x_hi
16175               
16176               PUS1:
16177 4B2E D36F  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Swap the low x and z bytes for the vector in Y:
     4B30 0053     
16178 4B32 D3AF  34        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ;
     4B34 0057     
16179 4B36 DBCD  38        movb ra,@INWK+4(ry)             ; STA INWK+4,Y      ; * For Y =  9 swap nosev_x_lo and nosev_z_lo
     4B38 0057     
16180 4B3A DBCE  38        movb rx,@INWK(ry)               ; STX INWK,Y        ; * For Y = 15 swap roofv_x_lo and roofv_z_lo
     4B3C 0053     
16181                                                                          ; * For Y = 21 swap sidev_x_lo and sidev_z_lo
16182               
16183 4B3E D36F  34        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Swap the high x and z bytes for the offset in Y:
     4B40 0054     
16184                      .eor @RAT                       ; EOR RAT           ;
     **** ****     > EOR
0001 4B42 D020  30        movb @RAT,rtmp
     4B44 00AA     
0002 4B46 2B40  18        xor  rtmp,ra
                   < elite.a99
16185 4B48 D38D  18        movb ra,rx                      ; TAX               ; * If left view, flip sign of new z-coordinate
16186 4B4A D36F  34        movb @INWK+5(ry),ra             ; LDA INWK+5,Y      ; * If right view, flip sign of new x-coordinate
     4B4C 0058     
16187                      .eor @RAT2                      ; EOR RAT2
     **** ****     > EOR
0001 4B4E D020  30        movb @RAT2,rtmp
     4B50 00AB     
0002 4B52 2B40  18        xor  rtmp,ra
                   < elite.a99
16188 4B54 DBCD  38        movb ra,@INWK+1(ry)             ; STA INWK+1,Y
     4B56 0054     
16189 4B58 DBCE  38        movb rx,@INWK+5(ry)             ; STX INWK+5,Y
     4B5A 0058     
16190               
16191                                                                          ; Fall through into LOOK1 to return from the subroutine
16192               
16193               * ******************************************************************************
16194               *
16195               * Name: LOOK1
16196               * Type: Subroutine
16197               * Category: Flight
16198               * Summary: Initialise the space view
16199               *
16200               * ------------------------------------------------------------------------------
16201               *
16202               * Initialise the space view, with the direction of view given in X. This clears
16203               * the upper screen and draws the laser crosshairs, if the view in X has lasers
16204               * fitted. It also wipes all the ships from the scanner, so we can recalculate
16205               * ship positions for the new view (they get put back in the main flight loop).
16206               *
16207               * ------------------------------------------------------------------------------
16208               *
16209               * Arguments:
16210               *
16211               * X                   The space view to set:
16212               *
16213               * * 0 = front
16214               * * 1 = rear
16215               * * 2 = left
16216               * * 3 = right
16217               *
16218               * ------------------------------------------------------------------------------
16219               *
16220               * Other entry points:
16221               *
16222               * LO2                 Contains an RTS
16223               *
16224               * ******************************************************************************
16225               
16226               LO2:
16227 4B5C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4B5E FE34     
16228               
16229               LQ:
16230 4B60 D80E  30        movb rx,@VIEW                   ; STX VIEW          ; Set the current space view to X
     4B62 0D5F     
16231               
16232 4B64 0200  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     4B66 4BDE     
16233 4B68 06A0  32        bl   @jsr                       ;
     4B6A FE28     
16234                                                                          ; and set the current view type in QQ11 to 0 (space
16235                                                                          ; view)
16236               
16237 4B6C 0200  20        li   rtmp,SIGHT                 ; JSR SIGHT         ; Draw the laser crosshairs
     4B6E 4BA4     
16238 4B70 06A0  32        bl   @jsr                       ;
     4B72 FE28     
16239               
16240 4B74 0460  28        b    @NWSTARS                   ; JMP NWSTARS       ; Set up a new stardust field and return from the
     4B76 AC1A     
16241                                                                          ; subroutine using a tail call
16242               
16243               LOOK1:
16244 4B78 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0, the type number of a space view
     4B7A 0000     
16245               
16246 4B7C D3E0  30        movb @QQ11,ry                   ; LDY QQ11          ; If the current view is not a space view, jump up to LQ
     4B7E 0096     
16247 4B80 16EF  14        jne  LQ                         ; BNE LQ            ; to set up a new space view
16248               
16249 4B82 93A0  30        cb   @VIEW,rx                   ; CPX VIEW          ; If the current view is already of type X, jump to LO2
     4B84 0D5F     
16250 4B86 13EA  14        jeq  LO2                        ; BEQ LO2           ; to return from the subroutine (as LO2 contains an RTS)
16251               
16252 4B88 D80E  30        movb rx,@VIEW                   ; STX VIEW          ; Change the current space view to X
     4B8A 0D5F     
16253               
16254 4B8C 0200  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     4B8E 4BDE     
16255 4B90 06A0  32        bl   @jsr                       ;
     4B92 FE28     
16256                                                                          ; and set the current view type in QQ11 to 0 (space
16257                                                                          ; view)
16258               
16259 4B94 0200  20        li   rtmp,FLIP                  ; JSR FLIP          ; Swap the x- and y-coordinates of all the stardust
     4B96 29B4     
16260 4B98 06A0  32        bl   @jsr                       ;
     4B9A FE28     
16261                                                                          ; particles and redraw the stardust field
16262               
16263 4B9C 0200  20        li   rtmp,WPSHPS                ; JSR WPSHPS        ; Wipe all the ships from the scanner and mark them all
     4B9E AC64     
16264 4BA0 06A0  32        bl   @jsr                       ;
     4BA2 FE28     
16265                                                                          ; as not being shown on-screen
16266               
16267                                                                          ; And fall through into SIGHT to draw the laser
16268                                                                          ; crosshairs
16269               
16270               * ******************************************************************************
16271               *
16272               * Name: SIGHT
16273               * Type: Subroutine
16274               * Category: Flight
16275               * Summary: Draw the laser crosshairs
16276               *
16277               * ******************************************************************************
16278               
16279               SIGHT:
16280 4BA4 D3E0  30        movb @VIEW,ry                   ; LDY VIEW          ; Fetch the laser power for our new view
     4BA6 0D5F     
16281 4BA8 D36F  34        movb @LASER(ry),ra              ; LDA LASER,Y
     4BAA 0310     
16282               
16283 4BAC 13D7  14        jeq  LO2                        ; BEQ LO2           ; If it is zero (i.e. there is no laser fitted to this
16284                                                                          ; view), jump to LO2 to return from the subroutine (as
16285                                                                          ; LO2 contains an RTS)
16286               
16287 4BAE 020D  20        li   ra,>80*256                 ; LDA #128          ; Set QQ19 to the x-coordinate of the centre of the
     4BB0 8000     
16288 4BB2 D80D  30        movb ra,@QQ19                   ; STA QQ19          ; screen
     4BB4 007F     
16289               
16290 4BB6 020D  20        li   ra,(Y-24)*256              ; LDA #Y-24         ; Set QQ19+1 to the y-coordinate of the centre of the
     4BB8 4800     
16291 4BBA D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; screen, minus 24 (because TT15 will add 24 to the
     4BBC 0080     
16292                                                                          ; coordinate when it draws the crosshairs)
16293               
16294 4BBE 020D  20        li   ra,>14*256                 ; LDA #20           ; Set QQ19+2 to size 20 for the crosshairs size
     4BC0 1400     
16295 4BC2 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     4BC4 0081     
16296               
16297 4BC6 0200  20        li   rtmp,TT15                  ; JSR TT15          ; Call TT15 to draw crosshairs of size 20 just to the
     4BC8 53D6     
16298 4BCA 06A0  32        bl   @jsr                       ;
     4BCC FE28     
16299                                                                          ; left of the middle of the screen
16300               
16301 4BCE 020D  20        li   ra,>0a*256                 ; LDA #10           ; Set QQ19+2 to size 10 for the crosshairs size
     4BD0 0A00     
16302 4BD2 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     4BD4 0081     
16303               
16304 4BD6 0460  28        b    @TT15                      ; JMP TT15          ; Call TT15 to draw crosshairs of size 10 at the same
     4BD8 53D6     
16305                                                                          ; location, which will remove the centre part from the
16306                                                                          ; laser crosshairs, leaving a gap in the middle, and
16307                                                                          ; return from the subroutine using a tail call
16308               
16309               * ******************************************************************************
16310               *
16311               * Name: TT66
16312               * Type: Subroutine
16313               * Category: Drawing the screen
16314               * Summary: Clear the screen and set the current view type
16315               *
16316               * ------------------------------------------------------------------------------
16317               *
16318               * Clear the top part of the screen, draw a white border, and set the current
16319               * view type in QQ11 to A.
16320               *
16321               * ------------------------------------------------------------------------------
16322               *
16323               * Arguments:
16324               *
16325               * A                   The type of the new current view (see QQ11 for a list of
16326               * view types)
16327               *
16328               * ------------------------------------------------------------------------------
16329               *
16330               * Other entry points:
16331               *
16332               * TT66-2              Call TT66 with A = 1
16333               *
16334               * ******************************************************************************
16335               
16336 4BDA 020D  20        li   ra,>01*256                 ; LDA #1            ; Set the view type to 1 when this is called via the
     4BDC 0100     
16337                                                                          ; TT66-2 entry point
16338               
16339               TT66:
16340 4BDE D80D  30        movb ra,@QQ11                   ; STA QQ11          ; Set the current view type in QQ11 to A
     4BE0 0096     
16341               
16342                                                                          ; Fall through into TTX66 to clear the screen and draw a
16343                                                                          ; white border
16344               
16345               * ******************************************************************************
16346               *
16347               * Name: TTX66
16348               * Type: Subroutine
16349               * Category: Drawing the screen
16350               * Summary: Clear the top part of the screen and draw a white border
16351               *
16352               * ------------------------------------------------------------------------------
16353               *
16354               * Clear the top part of the screen (the space view) and draw a white border
16355               * along the top and sides.
16356               *
16357               * ------------------------------------------------------------------------------
16358               *
16359               * Other entry points:
16360               *
16361               * BOX                 Just draw the border and (if this is a space view) the
16362               * view name. This can be used to remove the border and
16363               * view name, as it is drawn using EOR logic
16364               *
16365               * ******************************************************************************
16366               
16367               TTX66:
16368 4BE2 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     4BE4 8000     
16369 4BE6 D80D  30        movb ra,@QQ17                   ; STA QQ17
     4BE8 007E     
16370               
16377               
16378                      .asla                           ; ASL A             ; Set LAS2 to 0, as 128 << 1 = %10000000 << 1 = 0. This
     **** ****     > ASLA
0001 4BEA 024D  22        andi ra,>ff00
     4BEC FF00     
0002 4BEE 0A1D  18        sla  ra,1
                   < elite.a99
16379 4BF0 D80D  30        movb ra,@LAS2                   ; STA LAS2          ; stops any laser pulsing
     4BF2 0D5D     
16380               
16382               
16383 4BF4 D80D  30        movb ra,@DLY                    ; STA DLY           ; Set the delay in DLY to 0, to indicate that we are
     4BF6 0D64     
16384                                                                          ; no longer showing an in-flight message, so any new
16385                                                                          ; in-flight messages will be shown instantly
16386               
16387 4BF8 D80D  30        movb ra,@de_                    ; STA de            ; Clear de, the flag that appends " DESTROYED" to the
     4BFA 0D65     
16388                                                                          ; end of the next text token, so that it doesn't
16389               
16390 4BFC 020E  20        li   rx,>60*256                 ; LDX #&60          ; Set X to the screen memory page for the top row of the
     4BFE 6000     
16391                                                                          ; screen (as screen memory starts at &6000)
16392               
16393               BOL1:
16394 4C00 0200  20        li   rtmp,ZES1                  ; JSR ZES1          ; Call ZES1 to zero-fill the page in X, which clears
     4C02 C8C6     
16395 4C04 06A0  32        bl   @jsr                       ;
     4C06 FE28     
16396                                                                          ; that character row on the screen
16397               
16398 4C08 B387  18        ab   rone,rx                    ; INX               ; Increment X to point to the next page, i.e. the next
16399                                                                          ; character row
16400               
16401 4C0A 028E  22        ci   rx,>78*256                 ; CPX #&78          ; Loop back to BOL1 until we have cleared page &7700,
     4C0C 7800     
16402 4C0E 16F8  14        jne  BOL1                       ; BNE BOL1          ; the last character row in the space view part of the
16403                                                                          ; screen (the top part)
16404               
16405 4C10 D3A0  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Fetch into X the number that's shown on-screen during
     4C12 002F     
16406                                                                          ; the hyperspace countdown
16407               
16408 4C14 1304  14        jeq  BOX                        ; BEQ BOX           ; If the counter is zero then we are not counting down
16409                                                                          ; to hyperspace, so jump to BOX to skip the next
16410                                                                          ; instruction
16411               
16412 4C16 0200  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1),
     4C18 5DF6     
16413 4C1A 06A0  32        bl   @jsr                       ;
     4C1C FE28     
16414                                                                          ; i.e. print the hyperspace countdown in the top-left
16415                                                                          ; corner
16416               
16417               BOX:
16418 4C1E 020F  20        li   ry,>01*256                 ; LDY #1            ; Move the text cursor to row 1
     4C20 0100     
16419 4C22 D80F  30        movb ry,@YC                     ; STY YC
     4C24 002D     
16420               
16421 4C26 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to tt66 to skip
     4C28 0096     
16422 4C2A 1616  14        jne  tt66_                      ; BNE tt66          ; displaying the view name
16423               
16424 4C2C 020F  20        li   ry,>0b*256                 ; LDY #11           ; Move the text cursor to row 11
     4C2E 0B00     
16425 4C30 D80F  30        movb ry,@XC                     ; STY XC
     4C32 002C     
16426               
16427 4C34 D360  30        movb @VIEW,ra                   ; LDA VIEW          ; Load the current view into A:
     4C36 0D5F     
16428                                                                          ;
16429                                                                          ; 0 = front
16430                                                                          ; 1 = rear
16431                                                                          ; 2 = left
16432                                                                          ; 3 = right
16433               
16434 4C38 026D  22        ori  ra,>60*256                 ; ORA #&60          ; OR with &60 so we get a value of &60 to &63 (96 to 99)
     4C3A 6000     
16435               
16436 4C3C 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print recursive token 96 to 99, which will be in the
     4C3E A6E8     
16437 4C40 06A0  32        bl   @jsr                       ;
     4C42 FE28     
16438                                                                          ; range "FRONT" to "RIGHT"
16439               
16440 4C44 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     4C46 5F24     
16441 4C48 06A0  32        bl   @jsr                       ;
     4C4A FE28     
16442               
16443 4C4C 020D  20        li   ra,>af*256                 ; LDA #175          ; Print recursive token 15 ("VIEW ")
     4C4E AF00     
16444 4C50 0200  20        li   rtmp,TT27                  ; JSR TT27
     4C52 A6E8     
16445 4C54 06A0  32        bl   @jsr                       ;
     4C56 FE28     
16446               
16447               tt66_:
16448 4C58 020E  20        li   rx,>00*256                 ; LDX #0            ; Set (X1, Y1) to (0, 0)
     4C5A 0000     
16449 4C5C D80E  30        movb rx,@X1                     ; STX X1
     4C5E 0031     
16450 4C60 D80E  30        movb rx,@Y1                     ; STX Y1
     4C62 0032     
16451               
16452 4C64 D80E  30        movb rx,@QQ17                   ; STX QQ17          ; Set QQ17 = 0 to switch to ALL CAPS
     4C66 007E     
16453               
16454 4C68 7387  18        sb   rone,rx                    ; DEX               ; Set X2 = 255
16455 4C6A D80E  30        movb rx,@X2                     ; STX X2
     4C6C 0033     
16456               
16457 4C6E 0200  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1), so
     4C70 2622     
16458 4C72 06A0  32        bl   @jsr                       ;
     4C74 FE28     
16459                                                                          ; that's (0, 0) to (255, 0), along the very top of the
16460                                                                          ; screen
16461               
16462 4C76 020D  20        li   ra,>02*256                 ; LDA #2            ; Set X1 = X2 = 2
     4C78 0200     
16463 4C7A D80D  30        movb ra,@X1                     ; STA X1
     4C7C 0031     
16464 4C7E D80D  30        movb ra,@X2                     ; STA X2
     4C80 0033     
16465               
16466 4C82 0200  20        li   rtmp,BOS2                  ; JSR BOS2          ; Call BOS2 below, which will call BOS1 twice, and then
     4C84 4C8A     
16467 4C86 06A0  32        bl   @jsr                       ;
     4C88 FE28     
16468                                                                          ; fall through into BOS2 again, so we effectively do
16469                                                                          ; BOS1 four times, decrementing X1 and X2 each time
16470                                                                          ; before calling LOIN, so this whole loop-within-a-loop
16471                                                                          ; mind-bender ends up drawing these four lines:
16472                                                                          ;
16473                                                                          ; (1, 0)   to (1, 191)
16474                                                                          ; (0, 0)   to (0, 191)
16475                                                                          ; (255, 0) to (255, 191)
16476                                                                          ; (254, 0) to (254, 191)
16477                                                                          ;
16478                                                                          ; So that's a 2-pixel wide vertical border along the
16479                                                                          ; left edge of the upper part of the screen, and a
16480                                                                          ; 2-pixel wide vertical border along the right edge
16481               
16482               BOS2:
16483 4C8A 0200  20        li   rtmp,BOS1                  ; JSR BOS1          ; Call BOS1 below and then fall through into it, which
     4C8C 4C92     
16484 4C8E 06A0  32        bl   @jsr                       ;
     4C90 FE28     
16485                                                                          ; ends up running BOS1 twice. This is all part of the
16486                                                                          ; loop-the-loop border-drawing mind-bender explained
16487                                                                          ; above
16488               
16489               BOS1:
16490 4C92 020D  20        li   ra,>00*256                 ; LDA #0            ; Set Y1 = 0
     4C94 0000     
16491 4C96 D80D  30        movb ra,@Y1                     ; STA Y1
     4C98 0032     
16492               
16493 4C9A 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
     4C9C BF00     
16494 4C9E D80D  30        movb ra,@Y2                     ; STA Y2            ; y-coordinate of the mid-point of the space view, so
     4CA0 0034     
16495                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
16496                                                                          ; pixel row of the space view
16497               
16498 4CA2 7347  18        sb   rone,ra                    ; DEC X1            ; Decrement X1 and X2
16499 4CA4 7347  18        sb   rone,ra                    ; DEC X2
16500               
16501 4CA6 0460  28        b    @LOIN                      ; JMP LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), and return from
     4CA8 2272     
16502                                                                          ; the subroutine using a tail call
16503               
16504               * ******************************************************************************
16505               *
16506               * Name: DELAY
16507               * Type: Subroutine
16508               * Category: Utility routines
16509               * Summary: Wait for a specified time, in 1/50s of a second
16510               *
16511               * ------------------------------------------------------------------------------
16512               *
16513               * Wait for the number of vertical syncs given in Y, so this effectively waits
16514               * for Y/50 of a second (as the vertical sync occurs 50 times a second).
16515               *
16516               * ------------------------------------------------------------------------------
16517               *
16518               * Arguments:
16519               *
16520               * Y                   The number of vertical sync events to wait for
16521               *
16522               * ------------------------------------------------------------------------------
16523               *
16524               * Other entry points:
16525               *
16526               * DEL8                Wait for 8/50 of a second (0.16 seconds)
16527               *
16528               * DELAY-5             Wait for 2/50 of a second (0.04 seconds)
16529               *
16530               * ******************************************************************************
16531               
16532 4CAA 020F  20        li   ry,>02*256                 ; LDY #2            ; Set Y to 2 vertical syncs
     4CAC 0200     
16533               
16534 4CAE 2C              byte >2c                                            ; Skip the next instruction by turning it into
16535                                                                          ; &2C &A0 &08, or BIT &08A0, which does nothing apart
16536                                                                          ; from affect the flags
16537               
16538               DEL8:
16539 4CB0 020F  20        li   ry,>08*256                 ; LDY #8            ; Set Y to 8 vertical syncs and fall through into DELAY
     4CB2 0800     
16540                                                                          ; to wait for this long
16541               
16542               DELAY:
16543 4CB4 0200  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     4CB6 4EA2     
16544 4CB8 06A0  32        bl   @jsr                       ;
     4CBA FE28     
16545                                                                          ; screen gets drawn
16546               
16547 4CBC 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter in Y
16548               
16549 4CBE 16FA  14        jne  DELAY                      ; BNE DELAY         ; If Y isn't yet at zero, jump back to DELAY to wait
16550                                                                          ; for another vertical sync
16551               
16552 4CC0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4CC2 FE34     
16553               
16554               * ******************************************************************************
16555               *
16556               * Name: hm
16557               * Type: Subroutine
16558               * Category: Charts
16559               * Summary: Select the closest system and redraw the chart crosshairs
16560               *
16561               * ------------------------------------------------------------------------------
16562               *
16563               * Set the system closest to galactic coordinates (QQ9, QQ10) as the selected
16564               * system, redraw the crosshairs on the chart accordingly (if they are being
16565               * shown), and, if this is not a space view, clear the bottom three text rows of
16566               * the screen.
16567               *
16568               * ******************************************************************************
16569               
16570               hm_:
16571 4CC4 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     4CC6 5932     
16572 4CC8 06A0  32        bl   @jsr                       ;
     4CCA FE28     
16573                                                                          ; which will erase the crosshairs currently there
16574               
16575 4CCC 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     4CCE 5B78     
16576 4CD0 06A0  32        bl   @jsr                       ;
     4CD2 FE28     
16577                                                                          ; (QQ9, QQ10)
16578               
16579 4CD4 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     4CD6 5932     
16580 4CD8 06A0  32        bl   @jsr                       ;
     4CDA FE28     
16581                                                                          ; which will draw the crosshairs at our current home
16582                                                                          ; system
16583               
16584 4CDC D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is a space view, return from the subroutine
     4CDE 0096     
16585 4CE0 132C  14        jeq  SC5                        ; BEQ SC5           ; (as SC5 contains an RTS)
16586               
16587                                                                          ; Otherwise fall through into CLYNS to clear space at
16588                                                                          ; the bottom of the screen
16589               
16590               * ******************************************************************************
16591               *
16592               * Name: CLYNS
16593               * Type: Subroutine
16594               * Category: Drawing the screen
16595               * Summary: Clear the bottom three text rows of the mode 4 screen
16596               *
16597               * ------------------------------------------------------------------------------
16598               *
16599               * This routine clears some space at the bottom of the screen and moves the text
16600               * cursor to column 1, row 21.
16601               *
16602               * Specifically, it zeroes the following screen locations:
16603               *
16604               * &7507 to &75F0
16605               * &7607 to &76F0
16606               * &7707 to &77F0
16607               *
16608               * which clears the three bottom text rows of the mode 4 screen (rows 21 to 23),
16609               * clearing each row from text column 1 to 30 (so it doesn't overwrite the box
16610               * border in columns 0 and 32, or the last usable column in column 31).
16611               *
16612               * ------------------------------------------------------------------------------
16613               *
16614               * Returns:
16615               *
16616               * A                   A is set to 0
16617               *
16618               * Y                   Y is set to 0
16619               *
16620               * ******************************************************************************
16621               
16622               CLYNS:
16623 4CE2 020D  20        li   ra,>14*256                 ; LDA #20           ; Move the text cursor to row 20, near the bottom of
     4CE4 1400     
16624 4CE6 D80D  30        movb ra,@YC                     ; STA YC            ; the screen
     4CE8 002D     
16625               
16626 4CEA 020D  20        li   ra,>75*256                 ; LDA #&75          ; Set the two-byte value in SC to &7507
     4CEC 7500     
16627 4CEE D80D  30        movb ra,@SC+1                   ; STA SC+1
     4CF0 0008     
16628 4CF2 020D  20        li   ra,>07*256                 ; LDA #7
     4CF4 0700     
16629 4CF6 D80D  30        movb ra,@SC                     ; STA SC
     4CF8 0007     
16630               
16631 4CFA 0200  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline, which will move the text cursor down
     4CFC 4FA6     
16632 4CFE 06A0  32        bl   @jsr                       ;
     4D00 FE28     
16633                                                                          ; a line (to row 21) and back to column 1
16634               
16635 4D02 020D  20        li   ra,>00*256                 ; LDA #0            ; Call LYN to clear the pixels from &7507 to &75F0
     4D04 0000     
16636 4D06 0200  20        li   rtmp,LYN                   ; JSR LYN
     4D08 4D20     
16637 4D0A 06A0  32        bl   @jsr                       ;
     4D0C FE28     
16638               
16639 4D0E B347  18        ab   rone,ra                    ; INC SC+1          ; Increment SC+1 so SC points to &7607
16640               
16641 4D10 0200  20        li   rtmp,LYN                   ; JSR LYN           ; Call LYN to clear the pixels from &7607 to &76F0
     4D12 4D20     
16642 4D14 06A0  32        bl   @jsr                       ;
     4D16 FE28     
16643               
16644 4D18 B347  18        ab   rone,ra                    ; INC SC+1          ; Increment SC+1 so SC points to &7707
16645               
16646 4D1A B3C7  18        ab   rone,ry                    ; INY               ; Move the text cursor to column 1 (as LYN sets Y to 0)
16647 4D1C D80F  30        movb ry,@XC                     ; STY XC
     4D1E 002C     
16648               
16649                                                                          ; Fall through into LYN to clear the pixels from &7707
16650                                                                          ; to &77F0
16651               
16652               * ******************************************************************************
16653               *
16654               * Name: LYN
16655               * Type: Subroutine
16656               * Category: Drawing the screen
16657               * Summary: Clear most of a row of pixels
16658               *
16659               * ------------------------------------------------------------------------------
16660               *
16661               * Set pixels 0-233 to the value in A, starting at the pixel pointed to by SC.
16662               *
16663               * ------------------------------------------------------------------------------
16664               *
16665               * Arguments:
16666               *
16667               * A                   The value to store in pixels 1-233 (the only value that
16668               * is actually used is A = 0, which clears those pixels)
16669               *
16670               * ------------------------------------------------------------------------------
16671               *
16672               * Returns:
16673               *
16674               * Y                   Y is set to 0
16675               *
16676               * ------------------------------------------------------------------------------
16677               *
16678               * Other entry points:
16679               *
16680               * SC5                 Contains an RTS
16681               *
16682               * ******************************************************************************
16683               
16684               LYN:
16685 4D20 020F  20        li   ry,>e9*256                 ; LDY #233          ; Set up a counter in Y to count down from pixel 233
     4D22 E900     
16686               
16687               EE2:
16688                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Store A in the Y-th byte after the address pointed to
     **** ****     > ST_IND_Y_IDX
0001 4D24 D820  42        movb @SC,@rtmplb
     4D26 0007     
     4D28 8301     
0002 4D2A D020  30        movb @SC+1,rtmp
     4D2C 0008     
0003 4D2E 06CF  14        swpb ry
0004 4D30 A00F  18        a    ry,rtmp
0005 4D32 06CF  14        swpb ry
0006 4D34 D40D  30        movb RA,*rtmp
                   < elite.a99
16689                                                                          ; by SC
16690               
16691 4D36 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y
16692               
16693 4D38 16F5  14        jne  EE2                        ; BNE EE2           ; Loop back until Y is zero
16694               
16695               SC5:
16696 4D3A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4D3C FE34     
16697               
16698               * ******************************************************************************
16699               *
16700               * Name: SCAN
16701               * Type: Subroutine
16702               * Category: Dashboard
16703               * Summary: Display the current ship on the scanner
16704               * Deep dive: The 3D scanner
16705               *
16706               * ------------------------------------------------------------------------------
16707               *
16708               * This is used both to display a ship on the scanner, and to erase it again.
16709               *
16710               * ------------------------------------------------------------------------------
16711               *
16712               * Arguments:
16713               *
16714               * INWK                The ship's data block
16715               *
16716               * ******************************************************************************
16717               
16718               SCAN:
16719 4D3E D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the ship's scanner flag from byte #31
     4D40 0072     
16720               
16721 4D42 024D  22        andi ra,>10*256                 ; AND #%00010000    ; If bit 4 is clear then the ship should not be shown
     4D44 1000     
16722 4D46 13F9  14        jeq  SC5                        ; BEQ SC5           ; on the scanner, so return from the subroutine (as SC5
16723                                                                          ; contains an RTS)
16724               
16725 4D48 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship's type from TYPE into A
     4D4A 009B     
16726               
16727 4D4C 11F6  14        jlt  SC5                        ; BMI SC5           ; If this is the planet or the sun, then the type will
16728                                                                          ; have bit 7 set and we don't want to display it on the
16729                                                                          ; scanner, so return from the subroutine (as SC5
16730                                                                          ; contains an RTS)
16731               
16732 4D4E 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set X to the default scanner colour of green/cyan
     4D50 FF00     
16733                                                                          ; (a 4-pixel mode 5 byte in colour 3)
16734               
16735               * CMP #TGL               \ These instructions are commented out in the original
16736               * BEQ SC49               \ source. Along with the block just below, they would
16737                                                                          ; set X to colour 1 (red) for asteroids, cargo canisters
16738                                                                          ; and escape pods, rather than green/cyan. Presumably
16739                                                                          ; they decided it didn't work that well against the red
16740                                                                          ; ellipse and took this code out for release
16741               
16742 4D52 028D  22        ci   ra,(MSL)*256               ; CMP #MSL          ; If this is not a missile, skip the following
     4D54 0900     
16743 4D56 1602  14        jne  B47                        ; BNE B47           ; instruction
16744               
16745 4D58 020E  20        li   rx,>f0*256                 ; LDX #&F0          ; This is a missile, so set X to colour 2 (yellow/white)
     4D5A F000     
16746               
16747               B47:
16748               * CMP #AST               \ These instructions are commented out in the original
16749               * BCC P%+4               \ source. See above for an explanation of what they do
16750               * LDX #&0F
16751               * .SC49
16752 4D5C D80E  30        movb rx,@COL                    ; STX COL           ; Store X, the colour of this ship on the scanner, in
     4D5E 00A2     
16753                                                                          ; COL
16754               
16755 4D60 D360  30        movb @INWK+1,ra                 ; LDA INWK+1        ; If any of x_hi, y_hi and z_hi have a 1 in bit 6 or 7,
     4D62 0054     
16756 4D64 F360  30        socb @INWK+4,ra                 ; ORA INWK+4        ; then the ship is too far away to be shown on the
     4D66 0057     
16757 4D68 F360  30        socb @INWK+7,ra                 ; ORA INWK+7        ; scanner, so return from the subroutine (as SC5
     4D6A 005A     
16758 4D6C 024D  22        andi ra,>c0*256                 ; AND #%11000000    ; contains an RTS)
     4D6E C000     
16759 4D70 16E4  14        jne  SC5                        ; BNE SC5
16760               
16761                                                                          ; If we get here, we know x_hi, y_hi and z_hi are all
16762                                                                          ; 63 (%00111111) or less
16763               
16764                                                                          ; Now, we convert the x_hi coordinate of the ship into
16765                                                                          ; the screen x-coordinate of the dot on the scanner,
16766                                                                          ; using the following (see the deep dive on "The 3D
16767                                                                          ; scanner" for an explanation):
16768                                                                          ;
16769                                                                          ; X1 = 123 + (x_sign x_hi)
16770               
16771 4D72 D360  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Set A = x_hi
     4D74 0054     
16772               
16773                      .clc                            ; CLC               ; Clear the C flag so we can do addition below
     **** ****     > CLC
0001 4D76 0A16  18        sla  rzero,1
                   < elite.a99
16774               
16775 4D78 D3A0  30        movb @INWK+2,rx                 ; LDX INWK+2        ; Set X = x_sign
     4D7A 0055     
16776               
16777 4D7C 1507  14        jgt  SC2                        ; BPL SC2           ; If x_sign is positive, skip the following
16778               
16779                      .eoi (>ff*256)                  ; EOR #%11111111    ; x_sign is negative, so flip the bits in A and add 1
     **** ****     > EOI
0001 4D7E 0200  20        li   rtmp,(>FF*256)
     4D80 FF00     
0002 4D82 2B40  18        xor  rtmp,ra
                   < elite.a99
16780                      .adi (>01*256)                  ; ADC #1            ; to make it a negative number (bit 7 will now be set
     **** ****     > ADI
0001 4D84 1701  14        jnc  !
0002 4D86 B347  18        ab   rone,ra
0003               !:
0004 4D88 022D  22        ai   ra,(>01*256)
     4D8A 0100     
                   < elite.a99
16781                                                                          ; as we confirmed above that bits 6 and 7 are clear). So
16782                                                                          ; this gives A the sign of x_sign and gives it a value
16783                                                                          ; range of -63 (%11000001) to 0
16784               
16785               SC2:
16786                      .adi (>7b*256)                  ; ADC #123          ; Set X1 = 123 + (x_sign x_hi)
     **** ****     > ADI
0001 4D8C 1701  14        jnc  !
0002 4D8E B347  18        ab   rone,ra
0003               !:
0004 4D90 022D  22        ai   ra,(>7B*256)
     4D92 7B00     
                   < elite.a99
16787 4D94 D80D  30        movb ra,@X1                     ; STA X1
     4D96 0031     
16788               
16789                                                                          ; Next, we convert the z_hi coordinate of the ship into
16790                                                                          ; the y-coordinate of the base of the ship's stick,
16791                                                                          ; like this (see the deep dive on "The 3D scanner" for
16792                                                                          ; an explanation):
16793                                                                          ;
16794                                                                          ; SC = 220 - (z_sign z_hi) / 4
16795                                                                          ;
16796                                                                          ; though the following code actually does it like this:
16797                                                                          ;
16798                                                                          ; SC = 255 - (35 + z_hi / 4)
16799               
16800 4D98 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set A = z_hi / 4
     4D9A 005A     
16801 4D9C 091D  18        srl  ra,1                       ; LSR A             ;
16802 4D9E 091D  18        srl  ra,1                       ; LSR A             ; So A is in the range 0-15
16803               
16804                      .clc                            ; CLC               ; Clear the C flag for the addition below
     **** ****     > CLC
0001 4DA0 0A16  18        sla  rzero,1
                   < elite.a99
16805               
16806 4DA2 D3A0  30        movb @INWK+8,rx                 ; LDX INWK+8        ; Set X = z_sign
     4DA4 005B     
16807               
16808 4DA6 1504  14        jgt  SC3                        ; BPL SC3           ; If z_sign is positive, skip the following
16809               
16810                      .eoi (>ff*256)                  ; EOR #%11111111    ; z_sign is negative, so flip the bits in A and set the
     **** ****     > EOI
0001 4DA8 0200  20        li   rtmp,(>FF*256)
     4DAA FF00     
0002 4DAC 2B40  18        xor  rtmp,ra
                   < elite.a99
16811                      .sec                            ; SEC               ; C flag. As above, this makes A negative, this time
     **** ****     > SEC
0001 4DAE 0A18  18        sla  rmone,1
                   < elite.a99
16812                                                                          ; with a range of -16 (%11110000) to -1 (%11111111). And
16813                                                                          ; as we are about to do an ADC, the SEC effectively adds
16814                                                                          ; another 1 to that value, giving a range of -15 to 0
16815               
16816               SC3:
16817                      .adi (>23*256)                  ; ADC #35           ; Set A = 35 + A to give a number in the range 20 to 50
     **** ****     > ADI
0001 4DB0 1701  14        jnc  !
0002 4DB2 B347  18        ab   rone,ra
0003               !:
0004 4DB4 022D  22        ai   ra,(>23*256)
     4DB6 2300     
                   < elite.a99
16818               
16819                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip all the bits and store in SC, so SC is in the
     **** ****     > EOI
0001 4DB8 0200  20        li   rtmp,(>FF*256)
     4DBA FF00     
0002 4DBC 2B40  18        xor  rtmp,ra
                   < elite.a99
16820 4DBE D80D  30        movb ra,@SC                     ; STA SC            ; range 205 to 235, with a higher z_hi giving a lower SC
     4DC0 0007     
16821               
16822                                                                          ; Now for the stick height, which we calculate using the
16823                                                                          ; following (see the deep dive on "The 3D scanner" for
16824                                                                          ; an explanation):
16825                                                                          ;
16826                                                                          ; A = - (y_sign y_hi) / 2
16827               
16828 4DC2 D360  30        movb @INWK+4,ra                 ; LDA INWK+4        ; Set A = y_hi / 2
     4DC4 0057     
16829 4DC6 091D  18        srl  ra,1                       ; LSR A
16830               
16831                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 4DC8 0A16  18        sla  rzero,1
                   < elite.a99
16832               
16833 4DCA D3A0  30        movb @INWK+5,rx                 ; LDX INWK+5        ; Set X = y_sign
     4DCC 0058     
16834               
16835 4DCE 1104  14        jlt  SCD6                       ; BMI SCD6          ; If y_sign is negative, skip the following, as we
16836                                                                          ; already have a positive value in A
16837               
16838                      .eoi (>ff*256)                  ; EOR #%11111111    ; y_sign is positive, so flip the bits in A and set the
     **** ****     > EOI
0001 4DD0 0200  20        li   rtmp,(>FF*256)
     4DD2 FF00     
0002 4DD4 2B40  18        xor  rtmp,ra
                   < elite.a99
16839                      .sec                            ; SEC               ; C flag. This makes A negative, and as we are about to
     **** ****     > SEC
0001 4DD6 0A18  18        sla  rmone,1
                   < elite.a99
16840                                                                          ; do an ADC below, the SEC effectively adds another 1 to
16841                                                                          ; that value to implement two's complement negation, so
16842                                                                          ; we don't need to add another 1 here
16843               
16844               SCD6:
16845                                                                          ; We now have all the information we need to draw this
16846                                                                          ; ship on the scanner, namely:
16847                                                                          ;
16848                                                                          ; X1 = the screen x-coordinate of the ship's dot
16849                                                                          ;
16850                                                                          ; SC = the screen y-coordinate of the base of the
16851                                                                          ; stick
16852                                                                          ;
16853                                                                          ; A = the screen height of the ship's stick, with the
16854                                                                          ; correct sign for adding to the base of the stick
16855                                                                          ; to get the dot's y-coordinate
16856                                                                          ;
16857                                                                          ; First, though, we have to make sure the dot is inside
16858                                                                          ; the dashboard, by moving it if necessary
16859                      .adc @SC,ra                     ; ADC SC            ; Set A = SC + A, so A now contains the y-coordinate of
     **** ****     > ADC
0001 4DD8 1701  14        jnc  !
0002 4DDA B347  18        ab   rone,ra
0003               !:
0004 4DDC B360  30        ab   @SC,ra
     4DDE 0007     
                   < elite.a99
16860                                                                          ; the end of the stick, plus the length of the stick, to
16861                                                                          ; give us the screen y-coordinate of the dot
16862               
16863 4DE0 1508  14        jgt  ld246_                     ; BPL ld246         ; If the result has bit 0 clear, then the result has
16864                                                                          ; overflowed and is bigger than 256, so jump to ld246 to
16865                                                                          ; set A to the maximum allowed value of 246 (this
16866                                                                          ; instruction isn't required as we test both the maximum
16867                                                                          ; and minimum below, but it might save a few cycles)
16868               
16869 4DE2 028D  22        ci   ra,>c2*256                 ; CMP #194          ; If A >= 194, skip the following instruction, as 194 is
     4DE4 C200     
16870 4DE6 1802  14        joc  B48                        ; BCS B48           ; the minimum allowed value of A
16871               
16872 4DE8 020D  20        li   ra,>c2*256                 ; LDA #194          ; A < 194, so set A to 194, the minimum allowed value
     4DEA C200     
16873                                                                          ; for the y-coordinate of our ship's dot
16874               
16875               B48:
16876 4DEC 028D  22        ci   ra,>f7*256                 ; CMP #247          ; If A < 247, skip the following instruction, as 246 is
     4DEE F700     
16877 4DF0 1700  14        jnc  B49                        ; BCC B49           ; the maximum allowed value of A
16878               
16879               ld246_:
16880                      equ  $
16881               B49:
16882 4DF2 020D  20        li   ra,>f6*256                 ; LDA #246          ; A >= 247, so set A to 246, the maximum allowed value
     4DF4 F600     
16883                                                                          ; for the y-coordinate of our ship's dot
16884               
16885 4DF6 D80D  30        movb ra,@Y1                     ; STA Y1            ; Store A in Y1, as it now contains the screen
     4DF8 0032     
16886                                                                          ; y-coordinate for the ship's dot, clipped so that it
16887                                                                          ; fits within the dashboard
16888               
16889                      .sec                            ; SEC               ; Set A = A - SC to get the stick length, by reversing
     **** ****     > SEC
0001 4DFA 0A18  18        sla  rmone,1
                   < elite.a99
16890                      .sbc @SC,ra                     ; SBC SC            ; the ADC SC we did above. This clears the C flag if the
     **** ****     > SBC
0001 4DFC 1801  14        joc  !
0002 4DFE 7347  18        sb   rone,ra
0003               !:
0004 4E00 7360  30        sb   @SC,ra
     4E02 0007     
                   < elite.a99
16891                                                                          ; result is negative (i.e. the stick length is negative)
16892                                                                          ; and sets it if the result is positive (i.e. the stick
16893                                                                          ; length is negative)
16894               
16895                                                                          ; So now we have the following:
16896                                                                          ;
16897                                                                          ; X1 = the screen x-coordinate of the ship's dot,
16898                                                                          ; clipped to fit into the dashboard
16899                                                                          ;
16900                                                                          ; Y1 = the screen y-coordinate of the ship's dot,
16901                                                                          ; clipped to fit into the dashboard
16902                                                                          ;
16903                                                                          ; SC = the screen y-coordinate of the base of the
16904                                                                          ; stick
16905                                                                          ;
16906                                                                          ; A = the screen height of the ship's stick, with the
16907                                                                          ; correct sign for adding to the base of the stick
16908                                                                          ; to get the dot's y-coordinate
16909                                                                          ;
16910                                                                          ; C = 0 if A is negative, 1 if A is positive
16911                                                                          ;
16912                                                                          ; and we can get on with drawing the dot and stick
16913               
16914                      .php                            ; PHP               ; Store the flags (specifically the C flag) from the
     **** ****     > PHP
0001 4E04 02C0  12        stst rtmp
0002 4E06 D680  30        movb rtmp,*rsp
0003 4E08 060A  14        dec  rsp
                   < elite.a99
16915                                                                          ; above subtraction
16916               
16917               * BCS SC48               \ These instructions are commented out in the original
16918               * EOR #&FF               \ source. They would negate A if the C flag were set,
16919               * ADC #1                 \ which would reverse the direction of all the sticks,
16920                                                                          ; so you could turn your joystick around. Perhaps one of
16921                                                                          ; the authors' test sticks was easier to use upside
16922                                                                          ; down? Who knows...
16923               
16924               SC48:
16925                      .pha                            ; PHA               ; Store the stick height in A on the stack
     **** ****     > PHA
0001 4E0A D68D  30        movb ra,*rsp
0002 4E0C 060A  14        dec  rsp
                   < elite.a99
16926               
16927 4E0E 0200  20        li   rtmp,CPIX4                 ; JSR CPIX4         ; Draw a double-height dot at (X1, Y1). This also leaves
     4E10 AE1E     
16928 4E12 06A0  32        bl   @jsr                       ;
     4E14 FE28     
16929                                                                          ; the following variables set up for the dot's top-right
16930                                                                          ; pixel, the last pixel to be drawn (as the dot gets
16931                                                                          ; drawn from the bottom up):
16932                                                                          ;
16933                                                                          ; SC(1 0) = screen address of the pixel's character
16934                                                                          ; block
16935                                                                          ;
16936                                                                          ; Y = number of the character row containing the pixel
16937                                                                          ;
16938                                                                          ; X = the pixel's number (0-3) in that row
16939                                                                          ;
16940                                                                          ; We can use there as the starting point for drawing the
16941                                                                          ; stick, if there is one
16942               
16943 4E16 D36E  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Load the same mode 5 1-pixel byte that we just used
     4E18 226E     
16944                      .and @COL                       ; AND COL           ; for the top-right pixel, and mask it with the same
     **** ****     > AND
0001 4E1A D020  30        movb @COL,rtmp
     4E1C 00A2     
0002 4E1E 0540  14        inv  rtmp
0003 4E20 5340  18        szcb rtmp,ra
                   < elite.a99
16945 4E22 D80D  30        movb ra,@X1                     ; STA X1            ; colour, storing the result in X1, so we can use it as
     4E24 0031     
16946                                                                          ; the character row byte for the stick
16947               
16948                      .pla                            ; PLA               ; Restore the stick height from the stack into A
     **** ****     > PLA
0001 4E26 058A  14        inc  rsp
0002 4E28 D35A  26        movb *rsp,ra
                   < elite.a99
16949               
16950                      .plp                            ; PLP               ; Restore the flags from above, so the C flag once again
     **** ****     > PLP
0001 4E2A 058A  14        inc  rsp
0002 4E2C D01A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
16951                                                                          ; reflects the sign of the stick height
16952               
16953 4E2E D38D  18        movb ra,rx                      ; TAX               ; Copy the stick height into X
16954               
16955 4E30 1316  14        jeq  RTS1                       ; BEQ RTS1          ; If the stick height is zero, then there is no stick to
16956                                                                          ; draw, so return from the subroutine (as RTS contains
16957                                                                          ; an RTS)
16958               
16959 4E32 1717  14        jnc  RTS3                       ; BCC RTS3          ; If the C flag is clear then the stick height in A is
16960                                                                          ; negative, so jump down to RTS+1
16961               
16962               VLL1:
16963                                                                          ; If we get here then the stick length is positive (so
16964                                                                          ; the dot is below the ellipse and the stick is above
16965                                                                          ; the dot, and we need to draw the stick upwards from
16966                                                                          ; the dot)
16967 4E34 73C7  18        sb   rone,ry                    ; DEY               ; We want to draw the stick upwards, so decrement the
16968                                                                          ; pixel row in Y
16969               
16970 4E36 1503  14        jgt  VL1                        ; BPL VL1           ; If Y is still positive then it correctly points at the
16971                                                                          ; line above, so jump to VL1 to skip the following
16972               
16973 4E38 020F  20        li   ry,>07*256                 ; LDY #7            ; We just decremented Y up through the top of the
     4E3A 0700     
16974                                                                          ; character block, so we need to move it to the last row
16975                                                                          ; in the character above, so set Y to 7, the number of
16976                                                                          ; the last row
16977               
16978 4E3C 7347  18        sb   rone,ra                    ; DEC SC+1          ; Decrement the high byte of the screen address to move
16979                                                                          ; to the character block above
16980               
16981               VL1:
16982 4E3E D360  30        movb @X1,ra                     ; LDA X1            ; Set A to the character row byte for the stick, which
     4E40 0031     
16983                                                                          ; we stored in X1 above, and which has the same pixel
16984                                                                          ; pattern as the bottom-right pixel of the dot (so the
16985                                                                          ; stick comes out of the right side of the dot)
16986               
16987                      .eor @SC                        ; EOR (SC),Y        ; Draw the stick on row Y of the character block using
     **** ****     > EOR
0001 4E42 D020  30        movb @SC,rtmp
     4E44 0007     
0002 4E46 2B40  18        xor  rtmp,ra
                   < elite.a99
16988                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; EOR logic
     **** ****     > ST_IND_Y_IDX
0001 4E48 D820  42        movb @SC,@rtmplb
     4E4A 0007     
     4E4C 8301     
0002 4E4E D020  30        movb @SC+1,rtmp
     4E50 0008     
0003 4E52 06CF  14        swpb ry
0004 4E54 A00F  18        a    ry,rtmp
0005 4E56 06CF  14        swpb ry
0006 4E58 D40D  30        movb RA,*rtmp
                   < elite.a99
16989               
16990 4E5A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the (positive) stick height in X
16991               
16992 4E5C 16EB  14        jne  VLL1                       ; BNE VLL1          ; If we still have more stick to draw, jump up to VLL1
16993                                                                          ; to draw the next pixel
16994               
16995               RTS1:
16996 4E5E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4E60 FE34     
16997               
16998                                                                          ; If we get here then the stick length is negative (so
16999                                                                          ; the dot is above the ellipse and the stick is below
17000                                                                          ; the dot, and we need to draw the stick downwards from
17001                                                                          ; the dot)
17002               
17003               RTS3:
17004 4E62 B3C7  18        ab   rone,ry                    ; INY               ; We want to draw the stick downwards, so we first
17005                                                                          ; increment the row counter so that it's pointing to the
17006                                                                          ; bottom-right pixel in the dot (as opposed to the top-
17007                                                                          ; right pixel that the call to CPIX4 finished on)
17008               
17009 4E64 028F  22        ci   ry,>08*256                 ; CPY #8            ; If the row number in Y is less than 8, then it
     4E66 0800     
17010 4E68 1603  14        jne  VLL2                       ; BNE VLL2          ; correctly points at the next line down, so jump to
17011                                                                          ; VLL2 to skip the following
17012               
17013 4E6A 020F  20        li   ry,>00*256                 ; LDY #0            ; We just incremented Y down through the bottom of the
     4E6C 0000     
17014                                                                          ; character block, so we need to move it to the first
17015                                                                          ; row in the character below, so set Y to 0, the number
17016                                                                          ; of the first row
17017               
17018 4E6E B347  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of the screen address to move
17019                                                                          ; to the character block above
17020               
17021               VLL2:
17022 4E70 B3C7  18        ab   rone,ry                    ; INY               ; We want to draw the stick itself, heading downwards,
17023                                                                          ; so increment the pixel row in Y
17024               
17025 4E72 028F  22        ci   ry,>08*256                 ; CPY #8            ; If the row number in Y is less than 8, then it
     4E74 0800     
17026 4E76 1603  14        jne  VL2                        ; BNE VL2           ; correctly points at the next line down, so jump to
17027                                                                          ; VL2 to skip the following
17028               
17029 4E78 020F  20        li   ry,>00*256                 ; LDY #0            ; We just incremented Y down through the bottom of the
     4E7A 0000     
17030                                                                          ; character block, so we need to move it to the first
17031                                                                          ; row in the character below, so set Y to 0, the number
17032                                                                          ; of the first row
17033               
17034 4E7C B347  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of the screen address to move
17035                                                                          ; to the character block above
17036               
17037               VL2:
17038 4E7E D360  30        movb @X1,ra                     ; LDA X1            ; Set A to the character row byte for the stick, which
     4E80 0031     
17039                                                                          ; we stored in X1 above, and which has the same pixel
17040                                                                          ; pattern as the bottom-right pixel of the dot (so the
17041                                                                          ; stick comes out of the right side of the dot)
17042               
17043                      .eor @SC                        ; EOR (SC),Y        ; Draw the stick on row Y of the character block using
     **** ****     > EOR
0001 4E82 D020  30        movb @SC,rtmp
     4E84 0007     
0002 4E86 2B40  18        xor  rtmp,ra
                   < elite.a99
17044                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; EOR logic
     **** ****     > ST_IND_Y_IDX
0001 4E88 D820  42        movb @SC,@rtmplb
     4E8A 0007     
     4E8C 8301     
0002 4E8E D020  30        movb @SC+1,rtmp
     4E90 0008     
0003 4E92 06CF  14        swpb ry
0004 4E94 A00F  18        a    ry,rtmp
0005 4E96 06CF  14        swpb ry
0006 4E98 D40D  30        movb RA,*rtmp
                   < elite.a99
17045               
17046 4E9A B387  18        ab   rone,rx                    ; INX               ; Increment the (negative) stick height in X
17047               
17048 4E9C 16E9  14        jne  VLL2                       ; BNE VLL2          ; If we still have more stick to draw, jump up to VLL2
17049                                                                          ; to draw the next pixel
17050               
17051 4E9E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4EA0 FE34     
17052               
17053               * ******************************************************************************
17054               *
17055               * Name: WSCAN
17056               * Type: Subroutine
17057               * Category: Drawing the screen
17058               * Summary: Wait for the vertical sync
17059               *
17060               * ------------------------------------------------------------------------------
17061               *
17062               * Wait for vertical sync to occur on the video system - in other words, wait
17063               * for the screen to start its refresh cycle, which it does 50 times a second
17064               * (50Hz).
17065               *
17066               * ******************************************************************************
17067               
17068               WSCAN:
17069 4EA2 020D  20        li   ra,>00*256                 ; LDA #0            ; Set DL to 0
     4EA4 0000     
17070 4EA6 D80D  30        movb ra,@DL                     ; STA DL
     4EA8 009A     
17071               
17072               B50:
17073 4EAA D360  30        movb @DL,ra                     ; LDA DL            ; Loop round these two instructions until DL is no
     4EAC 009A     
17074 4EAE 13FD  14        jeq  B50                        ; BEQ B50           ; longer 0 (DL gets set to 30 in the LINSCN routine,
17075                                                                          ; which is run when vertical sync has occurred on the
17076                                                                          ; video system, so DL will change to a non-zero value
17077                                                                          ; at the start of each screen refresh)
17078               
17079 4EB0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4EB2 FE34     
17080               
17081               * ******************************************************************************
17082               *
17083               * Save ELTC.bin
17084               *
17085               * ******************************************************************************
17086               
17087                      ; PRINT "ELITE C"
17088                      ; PRINT "Assembled at ", ~CODE_C%
17089                      ; PRINT "Ends at ", ~P%
17090                      ; PRINT "Code size is ", ~(P% - CODE_C%)
17091                      ; PRINT "Execute at ", ~LOAD%
17092                      ; PRINT "Reload at ", ~LOAD_C%
17093               
17094                      ; PRINT "S.ELTC ", ~CODE_C%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_C%
17095                      ; SAVE "3-assembled-output/ELTC.bin", CODE_C%, P%, LOAD%
17096               
17097               * ******************************************************************************
17098               *
17099               * ELITE D FILE
17100               *
17101               * Produces the binary file ELTD.bin that gets loaded by elite-bcfs.asm.
17102               *
17103               * ******************************************************************************
17104               
17105               CODE_D.:
17106                      equ $
17107               
17108               LOAD_D.:
17109                      equ LOAD. + $ - CODE.
17110               
17111               * ******************************************************************************
17112               *
17113               * Name: tnpr
17114               * Type: Subroutine
17115               * Category: Market
17116               * Summary: Work out if we have space for a specific amount of cargo
17117               *
17118               * ------------------------------------------------------------------------------
17119               *
17120               * Given a market item and an amount, work out whether there is room in the
17121               * cargo hold for this item.
17122               *
17123               * For standard tonne canisters, the limit is given by the type of cargo hold we
17124               * have, with a standard cargo hold having a capacity of 20t and an extended
17125               * cargo bay being 35t.
17126               *
17127               * For items measured in kg (gold, platinum), g (gem-stones) and alien items,
17128               * the individual limit on each of these is 200 units.
17129               *
17130               * ------------------------------------------------------------------------------
17131               *
17132               * Arguments:
17133               *
17134               * A                   The number of units of this market item
17135               *
17136               * QQ29                The type of market item (see QQ23 for a list of market
17137               * item numbers)
17138               *
17139               * ------------------------------------------------------------------------------
17140               *
17141               * Returns:
17142               *
17143               * A                   A is preserved
17144               *
17145               * C flag              Returns the result:
17146               *
17147               * * Set if there is no room for this item
17148               *
17149               * * Clear if there is room for this item
17150               *
17151               * ******************************************************************************
17152               
17153               tnpr_:
17154                      .pha                            ; PHA               ; Store A on the stack
     **** ****     > PHA
0001 4EB4 D68D  30        movb ra,*rsp
0002 4EB6 060A  14        dec  rsp
                   < elite.a99
17155               
17156 4EB8 020E  20        li   rx,>0c*256                 ; LDX #12           ; If QQ29 > 12 then jump to kg below, as this cargo
     4EBA 0C00     
17157 4EBC 93A0  30        cb   @QQ29,rx                   ; CPX QQ29          ; type is gold, platinum, gem-stones or alien items,
     4EBE 0F1B     
17158 4EC0 170C  14        jnc  kg_                        ; BCC kg            ; and they have different cargo limits to the standard
17159                                                                          ; tonne canisters
17160               
17161               Tml:
17162                                                                          ; Here we count the tonne canisters we have in the hold
17163                                                                          ; and add to A to see if we have enough room for A more
17164                                                                          ; tonnes of cargo, using X as the loop counter, starting
17165                                                                          ; with X = 12
17166                      .adc @QQ20(rx),ra               ; ADC QQ20,X        ; Set A = A + the number of tonnes we have in the hold
     **** ****     > ADC
0001 4EC2 1701  14        jnc  !
0002 4EC4 B347  18        ab   rone,ra
0003               !:
0004 4EC6 B36E  34        ab   @QQ20(RX),ra
     4EC8 0317     
                   < elite.a99
17167                                                                          ; of market item number X. Note that the first time we
17168                                                                          ; go round this loop, the C flag is set (as we didn't
17169                                                                          ; branch with the BCC above, so the effect of this loop
17170                                                                          ; is to count the number of tonne canisters in the hold,
17171                                                                          ; and add 1
17172               
17173 4ECA 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
17174               
17175 4ECC 15FA  14        jgt  Tml                        ; BPL Tml           ; Loop back to add in the next market item in the hold,
17176                                                                          ; until we have added up all market items from 12
17177                                                                          ; (minerals) down to 0 (food)
17178               
17179 4ECE 9360  30        cb   @CRGO,ra                   ; CMP CRGO          ; If A < CRGO then the C flag will be clear (we have
     4ED0 0316     
17180                                                                          ; room in the hold)
17181                                                                          ;
17182                                                                          ; If A >= CRGO then the C flag will be set (we do not
17183                                                                          ; have room in the hold)
17184                                                                          ;
17185                                                                          ; This works because A contains the number of canisters
17186                                                                          ; plus 1, while CRGO contains our cargo capacity plus 2,
17187                                                                          ; so if we actually have "a" canisters and a capacity
17188                                                                          ; of "c", then:
17189                                                                          ;
17190                                                                          ; A < CRGO means: a+1 <  c+2
17191                                                                          ; a   <  c+1
17192                                                                          ; a   <= c
17193                                                                          ;
17194                                                                          ; So this is why the value in CRGO is 2 higher than the
17195                                                                          ; actual cargo bay size, i.e. it's 22 for the standard
17196                                                                          ; 20-tonne bay, and 37 for the large 35-tonne bay
17197               
17198                      .pla                            ; PLA               ; Restore A from the stack
     **** ****     > PLA
0001 4ED2 058A  14        inc  rsp
0002 4ED4 D35A  26        movb *rsp,ra
                   < elite.a99
17199               
17200 4ED6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4ED8 FE34     
17201               
17202               kg_:
17203                                                                          ; Here we count the number of items of this type that
17204                                                                          ; we already have in the hold, and add to A to see if
17205                                                                          ; we have enough room for A more units
17206 4EDA D3E0  30        movb @QQ29,ry                   ; LDY QQ29          ; Set Y to the item number we want to add
     4EDC 0F1B     
17207               
17208                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; Set A = A + the number of units of this item that we
     **** ****     > ADC
0001 4EDE 1701  14        jnc  !
0002 4EE0 B347  18        ab   rone,ra
0003               !:
0004 4EE2 B36F  34        ab   @QQ20(RY),ra
     4EE4 0317     
                   < elite.a99
17209                                                                          ; already have in the hold
17210               
17211 4EE6 028D  22        ci   ra,>c8*256                 ; CMP #200          ; Is the result greater than 200 (the limit on
     4EE8 C800     
17212                                                                          ; individual stocks of gold, platinum, gem-stones and
17213                                                                          ; alien items)?
17214                                                                          ;
17215                                                                          ; If so, this sets the C flag (no room)
17216                                                                          ;
17217                                                                          ; Otherwise it is clear (we have room)
17218               
17219                      .pla                            ; PLA               ; Restore A from the stack
     **** ****     > PLA
0001 4EEA 058A  14        inc  rsp
0002 4EEC D35A  26        movb *rsp,ra
                   < elite.a99
17220               
17221 4EEE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4EF0 FE34     
17222               
17223               * ******************************************************************************
17224               *
17225               * Name: TT20
17226               * Type: Subroutine
17227               * Category: Universe
17228               * Summary: Twist the selected system's seeds four times
17229               * Deep dive: Twisting the system seeds
17230               * Galaxy and system seeds
17231               *
17232               * ------------------------------------------------------------------------------
17233               *
17234               * Twist the three 16-bit seeds in QQ15 (selected system) four times, to
17235               * generate the next system.
17236               *
17237               * ******************************************************************************
17238               
17239               TT20:
17240 4EF2 0200  20        li   rtmp,B51                   ; JSR B51           ; This line calls the line below as a subroutine, which
     4EF4 4EFA     
17241 4EF6 06A0  32        bl   @jsr                       ;
     4EF8 FE28     
17242                                                                          ; does two twists before returning here, and then we
17243                                                                          ; fall through to the line below for another two
17244                                                                          ; twists, so the net effect of these two consecutive
17245                                                                          ; JSR calls is four twists, not counting the ones
17246                                                                          ; inside your head as you try to follow this process
17247               
17248               B51:
17249 4EFA 0200  20        li   rtmp,TT54                  ; JSR TT54          ; This line calls TT54 as a subroutine to do a twist,
     4EFC 4F02     
17250 4EFE 06A0  32        bl   @jsr                       ;
     4F00 FE28     
17251                                                                          ; and then falls through into TT54 to do another twist
17252                                                                          ; before returning from the subroutine
17253               
17254               * ******************************************************************************
17255               *
17256               * Name: TT54
17257               * Type: Subroutine
17258               * Category: Universe
17259               * Summary: Twist the selected system's seeds
17260               * Deep dive: Twisting the system seeds
17261               * Galaxy and system seeds
17262               *
17263               * ------------------------------------------------------------------------------
17264               *
17265               * This routine twists the three 16-bit seeds in QQ15 once.
17266               *
17267               * If we start with seeds s0, s1 and s2 and we want to work out their new values
17268               * after we perform a twist (let's call the new values s0, s1 and s2), then:
17269               *
17270               * s0 = s1
17271               * s1 = s2
17272               * s2 = s0 + s1 + s2
17273               *
17274               * So given an existing set of seeds in s0, s1 and s2, we can get the new values
17275               * s0, s1 and s2 simply by doing the above sums. And if we want to do the
17276               * above in-place without creating three new s variables, then we can do the
17277               * following:
17278               *
17279               * tmp = s0 + s1
17280               * s0 = s1
17281               * s1 = s2
17282               * s2 = tmp + s1
17283               *
17284               * So this is what we do in this routine, where each seed is a 16-bit number.
17285               *
17286               * ******************************************************************************
17287               
17288               TT54:
17289 4F02 D360  30        movb @QQ15,ra                   ; LDA QQ15          ; X = tmp_lo = s0_lo + s1_lo
     4F04 0078     
17290                      .clc                            ; CLC
     **** ****     > CLC
0001 4F06 0A16  18        sla  rzero,1
                   < elite.a99
17291                      .adc @QQ15+2,ra                 ; ADC QQ15+2
     **** ****     > ADC
0001 4F08 1701  14        jnc  !
0002 4F0A B347  18        ab   rone,ra
0003               !:
0004 4F0C B360  30        ab   @QQ15+2,ra
     4F0E 007A     
                   < elite.a99
17292 4F10 D38D  18        movb ra,rx                      ; TAX
17293               
17294 4F12 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Y = tmp_hi = s1_hi + s1_hi + C
     4F14 0079     
17295                      .adc @QQ15+3,ra                 ; ADC QQ15+3
     **** ****     > ADC
0001 4F16 1701  14        jnc  !
0002 4F18 B347  18        ab   rone,ra
0003               !:
0004 4F1A B360  30        ab   @QQ15+3,ra
     4F1C 007B     
                   < elite.a99
17296 4F1E D3CD  18        movb ra,ry                      ; TAY
17297               
17298 4F20 D360  30        movb @QQ15+2,ra                 ; LDA QQ15+2        ; s0_lo = s1_lo
     4F22 007A     
17299 4F24 D80D  30        movb ra,@QQ15                   ; STA QQ15
     4F26 0078     
17300               
17301 4F28 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; s0_hi = s1_hi
     4F2A 007B     
17302 4F2C D80D  30        movb ra,@QQ15+1                 ; STA QQ15+1
     4F2E 0079     
17303               
17304 4F30 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; s1_hi = s2_hi
     4F32 007D     
17305 4F34 D80D  30        movb ra,@QQ15+3                 ; STA QQ15+3
     4F36 007B     
17306               
17307 4F38 D360  30        movb @QQ15+4,ra                 ; LDA QQ15+4        ; s1_lo = s2_lo
     4F3A 007C     
17308 4F3C D80D  30        movb ra,@QQ15+2                 ; STA QQ15+2
     4F3E 007A     
17309               
17310                      .clc                            ; CLC               ; s2_lo = X + s1_lo
     **** ****     > CLC
0001 4F40 0A16  18        sla  rzero,1
                   < elite.a99
17311 4F42 D34E  18        movb rx,ra                      ; TXA
17312                      .adc @QQ15+2,ra                 ; ADC QQ15+2
     **** ****     > ADC
0001 4F44 1701  14        jnc  !
0002 4F46 B347  18        ab   rone,ra
0003               !:
0004 4F48 B360  30        ab   @QQ15+2,ra
     4F4A 007A     
                   < elite.a99
17313 4F4C D80D  30        movb ra,@QQ15+4                 ; STA QQ15+4
     4F4E 007C     
17314               
17315 4F50 D34F  18        movb ry,ra                      ; TYA               ; s2_hi = Y + s1_hi + C
17316                      .adc @QQ15+3,ra                 ; ADC QQ15+3
     **** ****     > ADC
0001 4F52 1701  14        jnc  !
0002 4F54 B347  18        ab   rone,ra
0003               !:
0004 4F56 B360  30        ab   @QQ15+3,ra
     4F58 007B     
                   < elite.a99
17317 4F5A D80D  30        movb ra,@QQ15+5                 ; STA QQ15+5
     4F5C 007D     
17318               
17319 4F5E 0460  28        b    @rts                       ; RTS               ; The twist is complete so return from the subroutine
     4F60 FE34     
17320               
17321               * ******************************************************************************
17322               *
17323               * Name: TT146
17324               * Type: Subroutine
17325               * Category: Universe
17326               * Summary: Print the distance to the selected system in light years
17327               *
17328               * ------------------------------------------------------------------------------
17329               *
17330               * If it is non-zero, print the distance to the selected system in light years.
17331               * If it is zero, just move the text cursor down a line.
17332               *
17333               * Specifically, if the distance in QQ8 is non-zero, print token 31 ("DISTANCE"),
17334               * then a colon, then the distance to one decimal place, then token 35 ("LIGHT
17335               * YEARS"). If the distance is zero, move the cursor down one line.
17336               *
17337               * ******************************************************************************
17338               
17339               TT146:
17340 4F62 D360  30        movb @QQ8,ra                    ; LDA QQ8           ; Take the two bytes of the 16-bit value in QQ8 and
     4F64 0F2F     
17341 4F66 F360  30        socb @QQ8+1,ra                  ; ORA QQ8+1         ; OR them together to check whether there are any
     4F68 0F30     
17342 4F6A 1603  14        jne  TT63                       ; BNE TT63          ; non-zero bits, and if so, jump to TT63 to print the
17343                                                                          ; distance
17344               
17345 4F6C B347  18        ab   rone,ra                    ; INC YC            ; The distance is zero, so we just move the text cursor
17346 4F6E 0460  28        b    @rts                       ; RTS               ; in YC down by one line and return from the subroutine
     4F70 FE34     
17347               
17348               TT63:
17349 4F72 020D  20        li   ra,>bf*256                 ; LDA #191          ; Print recursive token 31 ("DISTANCE") followed by
     4F74 BF00     
17350 4F76 0200  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     4F78 A6DC     
17351 4F7A 06A0  32        bl   @jsr                       ;
     4F7C FE28     
17352               
17353 4F7E D3A0  30        movb @QQ8,rx                    ; LDX QQ8           ; Load (Y X) from QQ8, which contains the 16-bit
     4F80 0F2F     
17354 4F82 D3E0  30        movb @QQ8+1,ry                  ; LDY QQ8+1         ; distance we want to show
     4F84 0F30     
17355               
17356                      .sec                            ; SEC               ; Set the C flag so that the call to pr5 will include a
     **** ****     > SEC
0001 4F86 0A18  18        sla  rmone,1
                   < elite.a99
17357                                                                          ; decimal point, and display the value as (Y X) / 10
17358               
17359 4F88 0200  20        li   rtmp,pr5_                  ; JSR pr5           ; Print (Y X) to 5 digits, including a decimal point
     4F8A 5E06     
17360 4F8C 06A0  32        bl   @jsr                       ;
     4F8E FE28     
17361               
17362 4F90 020D  20        li   ra,>c3*256                 ; LDA #195          ; Set A to the recursive token 35 (" LIGHT YEARS") and
     4F92 C300     
17363                                                                          ; fall through into TT60 to print the token followed
17364                                                                          ; by a paragraph break
17365               
17366               * ******************************************************************************
17367               *
17368               * Name: TT60
17369               * Type: Subroutine
17370               * Category: Text
17371               * Summary: Print a text token and a paragraph break
17372               *
17373               * ------------------------------------------------------------------------------
17374               *
17375               * Print a text token (i.e. a character, control code, two-letter token or
17376               * recursive token). Then print a paragraph break (a blank line between
17377               * paragraphs) by moving the cursor down a line, setting Sentence Case, and then
17378               * printing a newline.
17379               *
17380               * ------------------------------------------------------------------------------
17381               *
17382               * Arguments:
17383               *
17384               * A                   The text token to be printed
17385               *
17386               * ******************************************************************************
17387               
17388               TT60:
17389 4F94 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A and fall through into TTX69
     4F96 A6E8     
17390 4F98 06A0  32        bl   @jsr                       ;
     4F9A FE28     
17391                                                                          ; to print the paragraph break
17392               
17393               * ******************************************************************************
17394               *
17395               * Name: TTX69
17396               * Type: Subroutine
17397               * Category: Text
17398               * Summary: Print a paragraph break
17399               *
17400               * ------------------------------------------------------------------------------
17401               *
17402               * Print a paragraph break (a blank line between paragraphs) by moving the cursor
17403               * down a line, setting Sentence Case, and then printing a newline.
17404               *
17405               * ******************************************************************************
17406               
17407               TTX69:
17408 4F9C B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a line
17409               
17410                                                                          ; Fall through into TT69 to set Sentence Case and print
17411                                                                          ; a newline
17412               
17413               * ******************************************************************************
17414               *
17415               * Name: TT69
17416               * Type: Subroutine
17417               * Category: Text
17418               * Summary: Set Sentence Case and print a newline
17419               *
17420               * ******************************************************************************
17421               
17422               TT69:
17423 4F9E 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     4FA0 8000     
17424 4FA2 D80D  30        movb ra,@QQ17                   ; STA QQ17
     4FA4 007E     
17425               
17426                                                                          ; Fall through into TT67 to print a newline
17427               
17428               * ******************************************************************************
17429               *
17430               * Name: TT67
17431               * Type: Subroutine
17432               * Category: Text
17433               * Summary: Print a newline
17434               *
17435               * ******************************************************************************
17436               
17437               TT67:
17438 4FA6 020D  20        li   ra,>0d*256                 ; LDA #13           ; Load a newline character into A
     4FA8 0D00     
17439               
17440 4FAA 0460  28        b    @TT27                      ; JMP TT27          ; Print the text token in A and return from the
     4FAC A6E8     
17441                                                                          ; subroutine using a tail call
17442               
17443               * ******************************************************************************
17444               *
17445               * Name: TT70
17446               * Type: Subroutine
17447               * Category: Universe
17448               * Summary: Display "MAINLY " and jump to TT72
17449               *
17450               * ------------------------------------------------------------------------------
17451               *
17452               * This subroutine is called by TT25 when displaying a system's economy.
17453               *
17454               * ******************************************************************************
17455               
17456               TT70:
17457 4FAE 020D  20        li   ra,>ad*256                 ; LDA #173          ; Print recursive token 13 ("MAINLY ")
     4FB0 AD00     
17458 4FB2 0200  20        li   rtmp,TT27                  ; JSR TT27
     4FB4 A6E8     
17459 4FB6 06A0  32        bl   @jsr                       ;
     4FB8 FE28     
17460               
17461 4FBA 0460  28        b    @TT72                      ; JMP TT72          ; Jump to TT72 to continue printing system data as part
     4FBC 5042     
17462                                                                          ; of routine TT25
17463               
17464               * ******************************************************************************
17465               *
17466               * Name: spc
17467               * Type: Subroutine
17468               * Category: Text
17469               * Summary: Print a text token followed by a space
17470               *
17471               * ------------------------------------------------------------------------------
17472               *
17473               * Print a text token (i.e. a character, control code, two-letter token or
17474               * recursive token) followed by a space.
17475               *
17476               * ------------------------------------------------------------------------------
17477               *
17478               * Arguments:
17479               *
17480               * A                   The text token to be printed
17481               *
17482               * ******************************************************************************
17483               
17484               spc_:
17485 4FBE 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     4FC0 A6E8     
17486 4FC2 06A0  32        bl   @jsr                       ;
     4FC4 FE28     
17487               
17488 4FC6 0460  28        b    @TT162                     ; JMP TT162         ; Print a space and return from the subroutine using a
     4FC8 5F24     
17489                                                                          ; tail call
17490               
17491               * ******************************************************************************
17492               *
17493               * Name: TT25
17494               * Type: Subroutine
17495               * Category: Universe
17496               * Summary: Show the Data on System screen (red key f6)
17497               * Deep dive: Generating system data
17498               * Galaxy and system seeds
17499               *
17500               * ------------------------------------------------------------------------------
17501               *
17502               * Other entry points:
17503               *
17504               * TT72                Used by TT70 to re-enter the routine after displaying
17505               * "MAINLY" for the economy type
17506               *
17507               * ******************************************************************************
17508               
17509               TT25:
17510 4FCA 0200  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     4FCC 4BDC     
17511 4FCE 06A0  32        bl   @jsr                       ;
     4FD0 FE28     
17512                                                                          ; and set the current view type in QQ11 to 1
17513               
17514 4FD2 020D  20        li   ra,>09*256                 ; LDA #9            ; Move the text cursor to column 9
     4FD4 0900     
17515 4FD6 D80D  30        movb ra,@XC                     ; STA XC
     4FD8 002C     
17516               
17517 4FDA 020D  20        li   ra,>a3*256                 ; LDA #163          ; Print recursive token 3 as a title in capitals at
     4FDC A300     
17518 4FDE 0200  20        li   rtmp,TT27                  ; JSR TT27          ; the top ("DATA ON {selected system name}")
     4FE0 A6E8     
17519 4FE2 06A0  32        bl   @jsr                       ;
     4FE4 FE28     
17520               
17521 4FE6 0200  20        li   rtmp,NLIN                  ; JSR NLIN          ; Draw a horizontal line underneath the title
     4FE8 25F2     
17522 4FEA 06A0  32        bl   @jsr                       ;
     4FEC FE28     
17523               
17524 4FEE 0200  20        li   rtmp,TTX69                 ; JSR TTX69         ; Print a paragraph break and set Sentence Case
     4FF0 4F9C     
17525 4FF2 06A0  32        bl   @jsr                       ;
     4FF4 FE28     
17526               
17527 4FF6 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one more line
17528               
17529 4FF8 0200  20        li   rtmp,TT146                 ; JSR TT146         ; If the distance to this system is non-zero, print
     4FFA 4F62     
17530 4FFC 06A0  32        bl   @jsr                       ;
     4FFE FE28     
17531                                                                          ; "DISTANCE", then the distance, "LIGHT YEARS" and a
17532                                                                          ; paragraph break, otherwise just move the cursor down
17533                                                                          ; a line
17534               
17535 5000 020D  20        li   ra,>c2*256                 ; LDA #194          ; Print recursive token 34 ("ECONOMY") followed by
     5002 C200     
17536 5004 0200  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     5006 A6DC     
17537 5008 06A0  32        bl   @jsr                       ;
     500A FE28     
17538               
17539 500C D360  30        movb @QQ3,ra                    ; LDA QQ3           ; The system economy is determined by the value in QQ3,
     500E 0F28     
17540                                                                          ; so fetch it into A. First we work out the system's
17541                                                                          ; prosperity as follows:
17542                                                                          ;
17543                                                                          ; QQ3 = 0 or 5 = %000 or %101 = Rich
17544                                                                          ; QQ3 = 1 or 6 = %001 or %110 = Average
17545                                                                          ; QQ3 = 2 or 7 = %010 or %111 = Poor
17546                                                                          ; QQ3 = 3 or 4 = %011 or %100 = Mainly
17547               
17548                      .clc                            ; CLC               ; If (QQ3 + 1) >> 1 = %10, i.e. if QQ3 = %011 or %100
     **** ****     > CLC
0001 5010 0A16  18        sla  rzero,1
                   < elite.a99
17549                      .adi (>01*256)                  ; ADC #1            ; (3 or 4), then call TT70, which prints "MAINLY " and
     **** ****     > ADI
0001 5012 1701  14        jnc  !
0002 5014 B347  18        ab   rone,ra
0003               !:
0004 5016 022D  22        ai   ra,(>01*256)
     5018 0100     
                   < elite.a99
17550 501A 091D  18        srl  ra,1                       ; LSR A             ; jumps down to TT72 to print the type of economy
17551 501C 028D  22        ci   ra,>02*256                 ; CMP #%00000010
     501E 0200     
17552 5020 13C6  14        jeq  TT70                       ; BEQ TT70
17553               
17554 5022 D360  30        movb @QQ3,ra                    ; LDA QQ3           ; If (QQ3 + 1) >> 1 < %10, i.e. if QQ3 = %000, %001 or
     5024 0F28     
17555 5026 1705  14        jnc  TT71                       ; BCC TT71          ; %010 (0, 1 or 2), then jump to TT71 with A set to the
17556                                                                          ; original value of QQ3
17557               
17558                      .sbi (>05*256)                  ; SBC #5            ; Here QQ3 = %101, %110 or %111 (5, 6 or 7), so subtract
     **** ****     > SBI
0001 5028 1801  14        joc  !
0002 502A 7347  18        sb   rone,ra
0003               !:
0004 502C 022D  22        ai   ra,-(>05*256)
     502E FB00     
                   < elite.a99
17559                      .clc                            ; CLC               ; 5 to bring it down to 0, 1 or 2 (the C flag is already
     **** ****     > CLC
0001 5030 0A16  18        sla  rzero,1
                   < elite.a99
17560                                                                          ; set so the SBC will be correct)
17561               
17562               TT71:
17563                      .adi (>aa*256)                  ; ADC #170          ; A is now 0, 1 or 2, so print recursive token 10 + A.
     **** ****     > ADI
0001 5032 1701  14        jnc  !
0002 5034 B347  18        ab   rone,ra
0003               !:
0004 5036 022D  22        ai   ra,(>AA*256)
     5038 AA00     
                   < elite.a99
17564 503A 0200  20        li   rtmp,TT27                  ; JSR TT27          ; This means that:
     503C A6E8     
17565 503E 06A0  32        bl   @jsr                       ;
     5040 FE28     
17566                                                                          ;
17567                                                                          ; QQ3 = 0 or 5 prints token 10 ("RICH ")
17568                                                                          ; QQ3 = 1 or 6 prints token 11 ("AVERAGE ")
17569                                                                          ; QQ3 = 2 or 7 prints token 12 ("POOR ")
17570               
17571               TT72:
17572 5042 D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Now to work out the type of economy, which is
     5044 0F28     
17573 5046 091D  18        srl  ra,1                       ; LSR A             ; determined by bit 2 of QQ3, as follows:
17574 5048 091D  18        srl  ra,1                       ; LSR A             ;
17575                                                                          ; QQ3 bit 2 = 0 = Industrial
17576                                                                          ; QQ3 bit 2 = 1 = Agricultural
17577                                                                          ;
17578                                                                          ; So we fetch QQ3 into A and set A = bit 2 of QQ3 using
17579                                                                          ; two right shifts (which will work as QQ3 is only a
17580                                                                          ; 3-bit number)
17581               
17582                      .clc                            ; CLC               ; Print recursive token 8 + A, followed by a paragraph
     **** ****     > CLC
0001 504A 0A16  18        sla  rzero,1
                   < elite.a99
17583                      .adi (>a8*256)                  ; ADC #168          ; break and Sentence Case, so:
     **** ****     > ADI
0001 504C 1701  14        jnc  !
0002 504E B347  18        ab   rone,ra
0003               !:
0004 5050 022D  22        ai   ra,(>A8*256)
     5052 A800     
                   < elite.a99
17584 5054 0200  20        li   rtmp,TT60                  ; JSR TT60          ;
     5056 4F94     
17585 5058 06A0  32        bl   @jsr                       ;
     505A FE28     
17586                                                                          ; QQ3 bit 2 = 0 prints token 8 ("INDUSTRIAL")
17587                                                                          ; QQ3 bit 2 = 1 prints token 9 ("AGRICULTURAL")
17588               
17589 505C 020D  20        li   ra,>a2*256                 ; LDA #162          ; Print recursive token 2 ("GOVERNMENT") followed by
     505E A200     
17590 5060 0200  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     5062 A6DC     
17591 5064 06A0  32        bl   @jsr                       ;
     5066 FE28     
17592               
17593 5068 D360  30        movb @QQ4,ra                    ; LDA QQ4           ; The system's government is determined by the value in
     506A 0F29     
17594                                                                          ; QQ4, so fetch it into A
17595               
17596                      .clc                            ; CLC               ; Print recursive token 17 + A, followed by a paragraph
     **** ****     > CLC
0001 506C 0A16  18        sla  rzero,1
                   < elite.a99
17597                      .adi (>b1*256)                  ; ADC #177          ; break and Sentence Case, so:
     **** ****     > ADI
0001 506E 1701  14        jnc  !
0002 5070 B347  18        ab   rone,ra
0003               !:
0004 5072 022D  22        ai   ra,(>B1*256)
     5074 B100     
                   < elite.a99
17598 5076 0200  20        li   rtmp,TT60                  ; JSR TT60          ;
     5078 4F94     
17599 507A 06A0  32        bl   @jsr                       ;
     507C FE28     
17600                                                                          ; QQ4 = 0 prints token 17 ("ANARCHY")
17601                                                                          ; QQ4 = 1 prints token 18 ("FEUDAL")
17602                                                                          ; QQ4 = 2 prints token 19 ("MULTI-GOVERNMENT")
17603                                                                          ; QQ4 = 3 prints token 20 ("DICTATORSHIP")
17604                                                                          ; QQ4 = 4 prints token 21 ("COMMUNIST")
17605                                                                          ; QQ4 = 5 prints token 22 ("CONFEDERACY")
17606                                                                          ; QQ4 = 6 prints token 23 ("DEMOCRACY")
17607                                                                          ; QQ4 = 7 prints token 24 ("CORPORATE STATE")
17608               
17609 507E 020D  20        li   ra,>c4*256                 ; LDA #196          ; Print recursive token 36 ("TECH.LEVEL") followed by a
     5080 C400     
17610 5082 0200  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     5084 A6DC     
17611 5086 06A0  32        bl   @jsr                       ;
     5088 FE28     
17612               
17613 508A D3A0  30        movb @QQ5,rx                    ; LDX QQ5           ; Fetch the tech level from QQ5 and increment it, as it
     508C 0F2A     
17614 508E B387  18        ab   rone,rx                    ; INX               ; is stored in the range 0-14 but the displayed range
17615                                                                          ; should be 1-15
17616               
17617                      .clc                            ; CLC               ; Call pr2 to print the technology level as a 3-digit
     **** ****     > CLC
0001 5090 0A16  18        sla  rzero,1
                   < elite.a99
17618 5092 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; number without a decimal point (by clearing the C
     5094 2FFC     
17619 5096 06A0  32        bl   @jsr                       ;
     5098 FE28     
17620                                                                          ; flag)
17621               
17622 509A 0200  20        li   rtmp,TTX69                 ; JSR TTX69         ; Print a paragraph break and set Sentence Case
     509C 4F9C     
17623 509E 06A0  32        bl   @jsr                       ;
     50A0 FE28     
17624               
17625 50A2 020D  20        li   ra,>c0*256                 ; LDA #192          ; Print recursive token 32 ("POPULATION") followed by a
     50A4 C000     
17626 50A6 0200  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     50A8 A6DC     
17627 50AA 06A0  32        bl   @jsr                       ;
     50AC FE28     
17628               
17629                      .sec                            ; SEC               ; Call pr2 to print the population as a 3-digit number
     **** ****     > SEC
0001 50AE 0A18  18        sla  rmone,1
                   < elite.a99
17630 50B0 D3A0  30        movb @QQ6,rx                    ; LDX QQ6           ; with a decimal point (by setting the C flag), so the
     50B2 0F2B     
17631 50B4 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; number printed will be population / 10
     50B6 2FFC     
17632 50B8 06A0  32        bl   @jsr                       ;
     50BA FE28     
17633               
17634 50BC 020D  20        li   ra,>c6*256                 ; LDA #198          ; Print recursive token 38 (" BILLION"), followed by a
     50BE C600     
17635 50C0 0200  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case
     50C2 4F94     
17636 50C4 06A0  32        bl   @jsr                       ;
     50C6 FE28     
17637               
17638 50C8 020D  20        li   ra,('(')*256               ; LDA #'('          ; Print an opening bracket
     50CA 2800     
17639 50CC 0200  20        li   rtmp,TT27                  ; JSR TT27
     50CE A6E8     
17640 50D0 06A0  32        bl   @jsr                       ;
     50D2 FE28     
17641               
17642 50D4 D360  30        movb @QQ15+4,ra                 ; LDA QQ15+4        ; Now to calculate the species, so first check bit 7 of
     50D6 007C     
17643 50D8 1108  14        jlt  TT75                       ; BMI TT75          ; s2_lo, and if it is set, jump to TT75 as this is an
17644                                                                          ; alien species
17645               
17646 50DA 020D  20        li   ra,>bc*256                 ; LDA #188          ; Bit 7 of s2_lo is clear, so print recursive token 28
     50DC BC00     
17647 50DE 0200  20        li   rtmp,TT27                  ; JSR TT27          ; ("HUMAN COLONIAL")
     50E0 A6E8     
17648 50E2 06A0  32        bl   @jsr                       ;
     50E4 FE28     
17649               
17650 50E6 0460  28        b    @TT76                      ; JMP TT76          ; Jump to TT76 to print "S)" and a paragraph break, so
     50E8 517E     
17651                                                                          ; the whole species string is "(HUMAN COLONIALS)"
17652               
17653               TT75:
17654 50EA D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; This is an alien species, and we start with the first
     50EC 007D     
17655 50EE 091D  18        srl  ra,1                       ; LSR A             ; adjective, so fetch bits 2-7 of s2_hi into A and push
17656 50F0 091D  18        srl  ra,1                       ; LSR A             ; onto the stack so we can use this later
17657                      .pha                            ; PHA
     **** ****     > PHA
0001 50F2 D68D  30        movb ra,*rsp
0002 50F4 060A  14        dec  rsp
                   < elite.a99
17658               
17659 50F6 024D  22        andi ra,>07*256                 ; AND #%00000111    ; Set A = bits 0-2 of A (so that's bits 2-4 of s2_hi)
     50F8 0700     
17660               
17661 50FA 028D  22        ci   ra,>03*256                 ; CMP #3            ; If A >= 3, jump to TT205 to skip the first adjective,
     50FC 0300     
17662 50FE 1808  14        joc  TT205                      ; BCS TT205
17663               
17664                      .adi (>e3*256)                  ; ADC #227          ; Otherwise A = 0, 1 or 2, so print recursive token
     **** ****     > ADI
0001 5100 1701  14        jnc  !
0002 5102 B347  18        ab   rone,ra
0003               !:
0004 5104 022D  22        ai   ra,(>E3*256)
     5106 E300     
                   < elite.a99
17665 5108 0200  20        li   rtmp,spc_                  ; JSR spc           ; 67 + A, followed by a space, so:
     510A 4FBE     
17666 510C 06A0  32        bl   @jsr                       ;
     510E FE28     
17667                                                                          ;
17668                                                                          ; A = 0 prints token 67 ("LARGE") and a space
17669                                                                          ; A = 1 prints token 68 ("FIERCE") and a space
17670                                                                          ; A = 2 prints token 69 ("SMALL") and a space
17671               
17672               TT205:
17673                      .pla                            ; PLA               ; Now for the second adjective, so restore A to bits
     **** ****     > PLA
0001 5110 058A  14        inc  rsp
0002 5112 D35A  26        movb *rsp,ra
                   < elite.a99
17674 5114 091D  18        srl  ra,1                       ; LSR A             ; 2-7 of s2_hi, and throw away bits 2-4 to leave
17675 5116 091D  18        srl  ra,1                       ; LSR A             ; A = bits 5-7 of s2_hi
17676 5118 091D  18        srl  ra,1                       ; LSR A
17677               
17678 511A 028D  22        ci   ra,>06*256                 ; CMP #6            ; If A >= 6, jump to TT206 to skip the second adjective
     511C 0600     
17679 511E 1808  14        joc  TT206                      ; BCS TT206
17680               
17681                      .adi (>e6*256)                  ; ADC #230          ; Otherwise A = 0 to 5, so print recursive token
     **** ****     > ADI
0001 5120 1701  14        jnc  !
0002 5122 B347  18        ab   rone,ra
0003               !:
0004 5124 022D  22        ai   ra,(>E6*256)
     5126 E600     
                   < elite.a99
17682 5128 0200  20        li   rtmp,spc_                  ; JSR spc           ; 70 + A, followed by a space, so:
     512A 4FBE     
17683 512C 06A0  32        bl   @jsr                       ;
     512E FE28     
17684                                                                          ;
17685                                                                          ; A = 0 prints token 70 ("GREEN") and a space
17686                                                                          ; A = 1 prints token 71 ("RED") and a space
17687                                                                          ; A = 2 prints token 72 ("YELLOW") and a space
17688                                                                          ; A = 3 prints token 73 ("BLUE") and a space
17689                                                                          ; A = 4 prints token 74 ("BLACK") and a space
17690                                                                          ; A = 5 prints token 75 ("HARMLESS") and a space
17691               
17692               TT206:
17693 5130 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Now for the third adjective, so EOR the high bytes of
     5132 007B     
17694                      .eor @QQ15+1                    ; EOR QQ15+1        ; s0 and s1 and extract bits 0-2 of the result:
     **** ****     > EOR
0001 5134 D020  30        movb @QQ15+1,rtmp
     5136 0079     
0002 5138 2B40  18        xor  rtmp,ra
                   < elite.a99
17695 513A 024D  22        andi ra,>07*256                 ; AND #%00000111    ;
     513C 0700     
17696 513E D80D  30        movb ra,@QQ19                   ; STA QQ19          ; A = (s0_hi EOR s1_hi) AND %111
     5140 007F     
17697                                                                          ;
17698                                                                          ; storing the result in QQ19 so we can use it later
17699               
17700 5142 028D  22        ci   ra,>06*256                 ; CMP #6            ; If A >= 6, jump to TT207 to skip the third adjective
     5144 0600     
17701 5146 1808  14        joc  TT207                      ; BCS TT207
17702               
17703                      .adi (>ec*256)                  ; ADC #236          ; Otherwise A = 0 to 5, so print recursive token
     **** ****     > ADI
0001 5148 1701  14        jnc  !
0002 514A B347  18        ab   rone,ra
0003               !:
0004 514C 022D  22        ai   ra,(>EC*256)
     514E EC00     
                   < elite.a99
17704 5150 0200  20        li   rtmp,spc_                  ; JSR spc           ; 76 + A, followed by a space, so:
     5152 4FBE     
17705 5154 06A0  32        bl   @jsr                       ;
     5156 FE28     
17706                                                                          ;
17707                                                                          ; A = 0 prints token 76 ("SLIMY") and a space
17708                                                                          ; A = 1 prints token 77 ("BUG-EYED") and a space
17709                                                                          ; A = 2 prints token 78 ("HORNED") and a space
17710                                                                          ; A = 3 prints token 79 ("BONY") and a space
17711                                                                          ; A = 4 prints token 80 ("FAT") and a space
17712                                                                          ; A = 5 prints token 81 ("FURRY") and a space
17713               
17714               TT207:
17715 5158 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Now for the actual species, so take bits 0-1 of
     515A 007D     
17716 515C 024D  22        andi ra,>03*256                 ; AND #%00000011    ; s2_hi, add this to the value of A that we used for
     515E 0300     
17717                      .clc                            ; CLC               ; the third adjective, and take bits 0-2 of the result
     **** ****     > CLC
0001 5160 0A16  18        sla  rzero,1
                   < elite.a99
17718                      .adc @QQ19,ra                   ; ADC QQ19
     **** ****     > ADC
0001 5162 1701  14        jnc  !
0002 5164 B347  18        ab   rone,ra
0003               !:
0004 5166 B360  30        ab   @QQ19,ra
     5168 007F     
                   < elite.a99
17719 516A 024D  22        andi ra,>07*256                 ; AND #%00000111
     516C 0700     
17720               
17721                      .adi (>f2*256)                  ; ADC #242          ; A = 0 to 7, so print recursive token 82 + A, so:
     **** ****     > ADI
0001 516E 1701  14        jnc  !
0002 5170 B347  18        ab   rone,ra
0003               !:
0004 5172 022D  22        ai   ra,(>F2*256)
     5174 F200     
                   < elite.a99
17722 5176 0200  20        li   rtmp,TT27                  ; JSR TT27          ;
     5178 A6E8     
17723 517A 06A0  32        bl   @jsr                       ;
     517C FE28     
17724                                                                          ; A = 0 prints token 82 ("RODENT")
17725                                                                          ; A = 1 prints token 83 ("FROG")
17726                                                                          ; A = 2 prints token 84 ("LIZARD")
17727                                                                          ; A = 3 prints token 85 ("LOBSTER")
17728                                                                          ; A = 4 prints token 86 ("BIRD")
17729                                                                          ; A = 5 prints token 87 ("HUMANOID")
17730                                                                          ; A = 6 prints token 88 ("FELINE")
17731                                                                          ; A = 7 prints token 89 ("INSECT")
17732               
17733               TT76:
17734 517E 020D  20        li   ra,('S')*256               ; LDA #'S'          ; Print an "S" to pluralise the species
     5180 5300     
17735 5182 0200  20        li   rtmp,TT27                  ; JSR TT27
     5184 A6E8     
17736 5186 06A0  32        bl   @jsr                       ;
     5188 FE28     
17737               
17738 518A 020D  20        li   ra,(')')*256               ; LDA #')'          ; And finally, print a closing bracket, followed by a
     518C 2900     
17739 518E 0200  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case, to end the species
     5190 4F94     
17740 5192 06A0  32        bl   @jsr                       ;
     5194 FE28     
17741                                                                          ; section
17742               
17743 5196 020D  20        li   ra,>c1*256                 ; LDA #193          ; Print recursive token 33 ("GROSS PRODUCTIVITY"),
     5198 C100     
17744 519A 0200  20        li   rtmp,TT68                  ; JSR TT68          ; followed by a colon
     519C A6DC     
17745 519E 06A0  32        bl   @jsr                       ;
     51A0 FE28     
17746               
17747 51A2 D3A0  30        movb @QQ7,rx                    ; LDX QQ7           ; Fetch the 16-bit productivity value from QQ7 into
     51A4 0F2D     
17748 51A6 D3E0  30        movb @QQ7+1,ry                  ; LDY QQ7+1         ; (Y X)
     51A8 0F2E     
17749               
17750 51AA 0200  20        li   rtmp,pr6_                  ; JSR pr6           ; Print (Y X) to 5 digits with no decimal point
     51AC 5E04     
17751 51AE 06A0  32        bl   @jsr                       ;
     51B0 FE28     
17752               
17753 51B2 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     51B4 5F24     
17754 51B6 06A0  32        bl   @jsr                       ;
     51B8 FE28     
17755               
17756 51BA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set QQ17 = 0 to switch to ALL CAPS
     51BC 0000     
17757 51BE D80D  30        movb ra,@QQ17                   ; STA QQ17
     51C0 007E     
17758               
17759 51C2 020D  20        li   ra,('M')*256               ; LDA #'M'          ; Print "M"
     51C4 4D00     
17760 51C6 0200  20        li   rtmp,TT27                  ; JSR TT27
     51C8 A6E8     
17761 51CA 06A0  32        bl   @jsr                       ;
     51CC FE28     
17762               
17763 51CE 020D  20        li   ra,>e2*256                 ; LDA #226          ; Print recursive token 66 (" CR"), followed by a
     51D0 E200     
17764 51D2 0200  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case
     51D4 4F94     
17765 51D6 06A0  32        bl   @jsr                       ;
     51D8 FE28     
17766               
17767 51DA 020D  20        li   ra,>fa*256                 ; LDA #250          ; Print recursive token 90 ("AVERAGE RADIUS"), followed
     51DC FA00     
17768 51DE 0200  20        li   rtmp,TT68                  ; JSR TT68          ; by a colon
     51E0 A6DC     
17769 51E2 06A0  32        bl   @jsr                       ;
     51E4 FE28     
17770               
17771                                                                          ; The average radius is calculated like this:
17772                                                                          ;
17773                                                                          ; ((s2_hi AND %1111) + 11) * 256 + s1_hi
17774                                                                          ;
17775                                                                          ; or, in terms of memory locations:
17776                                                                          ;
17777                                                                          ; ((QQ15+5 AND %1111) + 11) * 256 + QQ15+3
17778                                                                          ;
17779                                                                          ; Because the multiplication is by 256, this is the
17780                                                                          ; same as saying a 16-bit number, with high byte:
17781                                                                          ;
17782                                                                          ; (QQ15+5 AND %1111) + 11
17783                                                                          ;
17784                                                                          ; and low byte:
17785                                                                          ;
17786                                                                          ; QQ15+3
17787                                                                          ;
17788                                                                          ; so we can set this up in (Y X) and call the pr5
17789                                                                          ; routine to print it out
17790               
17791 51E6 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Set A = QQ15+5
     51E8 007D     
17792 51EA D3A0  30        movb @QQ15+3,rx                 ; LDX QQ15+3        ; Set X = QQ15+3
     51EC 007B     
17793               
17794 51EE 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; Set Y = (A AND %1111) + 11
     51F0 0F00     
17795                      .clc                            ; CLC
     **** ****     > CLC
0001 51F2 0A16  18        sla  rzero,1
                   < elite.a99
17796                      .adi (>0b*256)                  ; ADC #11
     **** ****     > ADI
0001 51F4 1701  14        jnc  !
0002 51F6 B347  18        ab   rone,ra
0003               !:
0004 51F8 022D  22        ai   ra,(>0B*256)
     51FA 0B00     
                   < elite.a99
17797 51FC D3CD  18        movb ra,ry                      ; TAY
17798               
17799 51FE 0200  20        li   rtmp,pr5_                  ; JSR pr5           ; Print (Y X) to 5 digits, not including a decimal
     5200 5E06     
17800 5202 06A0  32        bl   @jsr                       ;
     5204 FE28     
17801                                                                          ; point, as the C flag will be clear (as the maximum
17802                                                                          ; radius will always fit into 16 bits)
17803               
17804 5206 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     5208 5F24     
17805 520A 06A0  32        bl   @jsr                       ;
     520C FE28     
17806               
17807 520E 020D  20        li   ra,('k')*256               ; LDA #'k'          ; Print "km", returning from the subroutine using a
     5210 6B00     
17808 5212 0200  20        li   rtmp,TT26                  ; JSR TT26          ; tail call
     5214 31C2     
17809 5216 06A0  32        bl   @jsr                       ;
     5218 FE28     
17810 521A 020D  20        li   ra,('m')*256               ; LDA #'m'
     521C 6D00     
17811 521E 0460  28        b    @TT26                      ; JMP TT26
     5220 31C2     
17812               
17813               * ******************************************************************************
17814               *
17815               * Name: TT24
17816               * Type: Subroutine
17817               * Category: Universe
17818               * Summary: Calculate system data from the system seeds
17819               * Deep dive: Generating system data
17820               * Galaxy and system seeds
17821               *
17822               * ------------------------------------------------------------------------------
17823               *
17824               * Calculate system data from the seeds in QQ15 and store them in the relevant
17825               * locations. Specifically, this routine calculates the following from the three
17826               * 16-bit seeds in QQ15 (using only s0_hi, s1_hi and s1_lo):
17827               *
17828               * QQ3 = economy (0-7)
17829               * QQ4 = government (0-7)
17830               * QQ5 = technology level (0-14)
17831               * QQ6 = population * 10 (1-71)
17832               * QQ7 = productivity (96-62480)
17833               *
17834               * The ranges of the various values are shown in brackets. Note that the radius
17835               * and type of inhabitant are calculated on-the-fly in the TT25 routine when
17836               * the system data gets displayed, so they aren't calculated here.
17837               *
17838               * ******************************************************************************
17839               
17840               TT24:
17841 5222 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch s0_hi and extract bits 0-2 to determine the
     5224 0079     
17842 5226 024D  22        andi ra,>07*256                 ; AND #%00000111    ; system's economy, and store in QQ3
     5228 0700     
17843 522A D80D  30        movb ra,@QQ3                    ; STA QQ3
     522C 0F28     
17844               
17845 522E D360  30        movb @QQ15+2,ra                 ; LDA QQ15+2        ; Fetch s1_lo and extract bits 3-5 to determine the
     5230 007A     
17846 5232 091D  18        srl  ra,1                       ; LSR A             ; system's government, and store in QQ4
17847 5234 091D  18        srl  ra,1                       ; LSR A
17848 5236 091D  18        srl  ra,1                       ; LSR A
17849 5238 024D  22        andi ra,>07*256                 ; AND #%00000111
     523A 0700     
17850 523C D80D  30        movb ra,@QQ4                    ; STA QQ4
     523E 0F29     
17851               
17852 5240 091D  18        srl  ra,1                       ; LSR A             ; If government isn't anarchy or feudal, skip to TT77,
17853 5242 1606  14        jne  TT77                       ; BNE TT77          ; as we need to fix the economy of anarchy and feudal
17854                                                                          ; systems so they can't be rich
17855               
17856 5244 D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Set bit 1 of the economy in QQ3 to fix the economy
     5246 0F28     
17857 5248 026D  22        ori  ra,>02*256                 ; ORA #%00000010    ; for anarchy and feudal governments
     524A 0200     
17858 524C D80D  30        movb ra,@QQ3                    ; STA QQ3
     524E 0F28     
17859               
17860               TT77:
17861 5250 D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Now to work out the tech level, which we do like this:
     5252 0F28     
17862                      .eoi (>07*256)                  ; EOR #%00000111    ;
     **** ****     > EOI
0001 5254 0200  20        li   rtmp,(>07*256)
     5256 0700     
0002 5258 2B40  18        xor  rtmp,ra
                   < elite.a99
17863                      .clc                            ; CLC               ; flipped_economy + (s1_hi AND %11) + (government / 2)
     **** ****     > CLC
0001 525A 0A16  18        sla  rzero,1
                   < elite.a99
17864 525C D80D  30        movb ra,@QQ5                    ; STA QQ5           ;
     525E 0F2A     
17865                                                                          ; or, in terms of memory locations:
17866                                                                          ;
17867                                                                          ; QQ5 = (QQ3 EOR %111) + (QQ15+3 AND %11) + (QQ4 / 2)
17868                                                                          ;
17869                                                                          ; We start by setting QQ5 = QQ3 EOR %111
17870               
17871 5260 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; We then take the first 2 bits of s1_hi (QQ15+3) and
     5262 007B     
17872 5264 024D  22        andi ra,>03*256                 ; AND #%00000011    ; add it into QQ5
     5266 0300     
17873                      .adc @QQ5,ra                    ; ADC QQ5
     **** ****     > ADC
0001 5268 1701  14        jnc  !
0002 526A B347  18        ab   rone,ra
0003               !:
0004 526C B360  30        ab   @QQ5,ra
     526E 0F2A     
                   < elite.a99
17874 5270 D80D  30        movb ra,@QQ5                    ; STA QQ5
     5272 0F2A     
17875               
17876 5274 D360  30        movb @QQ4,ra                    ; LDA QQ4           ; And finally we add QQ4 / 2 and store the result in
     5276 0F29     
17877 5278 091D  18        srl  ra,1                       ; LSR A             ; QQ5, using LSR then ADC to divide by 2, which rounds
17878                      .adc @QQ5,ra                    ; ADC QQ5           ; up the result for odd-numbered government types
     **** ****     > ADC
0001 527A 1701  14        jnc  !
0002 527C B347  18        ab   rone,ra
0003               !:
0004 527E B360  30        ab   @QQ5,ra
     5280 0F2A     
                   < elite.a99
17879 5282 D80D  30        movb ra,@QQ5                    ; STA QQ5
     5284 0F2A     
17880               
17881                      .asla                           ; ASL A             ; Now to work out the population, like so:
     **** ****     > ASLA
0001 5286 024D  22        andi ra,>ff00
     5288 FF00     
0002 528A 0A1D  18        sla  ra,1
                   < elite.a99
17882                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 528C 024D  22        andi ra,>ff00
     528E FF00     
0002 5290 0A1D  18        sla  ra,1
                   < elite.a99
17883                      .adc @QQ3,ra                    ; ADC QQ3           ; (tech level * 4) + economy + government + 1
     **** ****     > ADC
0001 5292 1701  14        jnc  !
0002 5294 B347  18        ab   rone,ra
0003               !:
0004 5296 B360  30        ab   @QQ3,ra
     5298 0F28     
                   < elite.a99
17884                      .adc @QQ4,ra                    ; ADC QQ4           ;
     **** ****     > ADC
0001 529A 1701  14        jnc  !
0002 529C B347  18        ab   rone,ra
0003               !:
0004 529E B360  30        ab   @QQ4,ra
     52A0 0F29     
                   < elite.a99
17885                      .adi (>01*256)                  ; ADC #1            ; or, in terms of memory locations:
     **** ****     > ADI
0001 52A2 1701  14        jnc  !
0002 52A4 B347  18        ab   rone,ra
0003               !:
0004 52A6 022D  22        ai   ra,(>01*256)
     52A8 0100     
                   < elite.a99
17886 52AA D80D  30        movb ra,@QQ6                    ; STA QQ6           ;
     52AC 0F2B     
17887                                                                          ; QQ6 = (QQ5 * 4) + QQ3 + QQ4 + 1
17888               
17889 52AE D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Finally, we work out productivity, like this:
     52B0 0F28     
17890                      .eoi (>07*256)                  ; EOR #%00000111    ;
     **** ****     > EOI
0001 52B2 0200  20        li   rtmp,(>07*256)
     52B4 0700     
0002 52B6 2B40  18        xor  rtmp,ra
                   < elite.a99
17891                      .adi (>03*256)                  ; ADC #3            ; (flipped_economy + 3) * (government + 4)
     **** ****     > ADI
0001 52B8 1701  14        jnc  !
0002 52BA B347  18        ab   rone,ra
0003               !:
0004 52BC 022D  22        ai   ra,(>03*256)
     52BE 0300     
                   < elite.a99
17892 52C0 D80D  30        movb ra,@P                      ; STA P             ; * population
     52C2 001B     
17893 52C4 D360  30        movb @QQ4,ra                    ; LDA QQ4           ; * 8
     52C6 0F29     
17894                      .adi (>04*256)                  ; ADC #4            ;
     **** ****     > ADI
0001 52C8 1701  14        jnc  !
0002 52CA B347  18        ab   rone,ra
0003               !:
0004 52CC 022D  22        ai   ra,(>04*256)
     52CE 0400     
                   < elite.a99
17895 52D0 D80D  30        movb ra,@Q                      ; STA Q             ; or, in terms of memory locations:
     52D2 0090     
17896 52D4 0200  20        li   rtmp,MULTU                 ; JSR MULTU         ;
     52D6 4392     
17897 52D8 06A0  32        bl   @jsr                       ;
     52DA FE28     
17898                                                                          ; QQ7 = (QQ3 EOR %111 + 3) * (QQ4 + 4) * QQ6 * 8
17899                                                                          ;
17900                                                                          ; We do the first step by setting P to the first
17901                                                                          ; expression in brackets and Q to the second, and
17902                                                                          ; calling MULTU, so now (A P) = P * Q. The highest this
17903                                                                          ; can be is 10 * 11 (as the maximum values of economy
17904                                                                          ; and government are 7), so the high byte of the result
17905                                                                          ; will always be 0, so we actually have:
17906                                                                          ;
17907                                                                          ; P = P * Q
17908                                                                          ; = (flipped_economy + 3) * (government + 4)
17909               
17910 52DC D360  30        movb @QQ6,ra                    ; LDA QQ6           ; We now take the result in P and multiply by the
     52DE 0F2B     
17911 52E0 D80D  30        movb ra,@Q                      ; STA Q             ; population to get the productivity, by setting Q to
     52E2 0090     
17912 52E4 0200  20        li   rtmp,MULTU                 ; JSR MULTU         ; the population from QQ6 and calling MULTU again, so
     52E6 4392     
17913 52E8 06A0  32        bl   @jsr                       ;
     52EA FE28     
17914                                                                          ; now we have:
17915                                                                          ;
17916                                                                          ; (A P) = P * population
17917               
17918                      .asl @P                         ; ASL P             ; Next we multiply the result by 8, as a 16-bit number,
     **** ****     > ASL
0001 52EC D020  30        movb @P,rtmp
     52EE 001B     
0002 52F0 0240  22        andi rtmp,>ff00
     52F2 FF00     
0003 52F4 0A10  18        sla  rtmp,1
0004 52F6 D800  30        movb rtmp,@P
     52F8 001B     
                   < elite.a99
17919 52FA 06A0  32        bl   @rola                      ; ROL A             ; so we shift both bytes to the left three times, using
     52FC FE3E     
17920                      .asl @P                         ; ASL P             ; the C flag to carry bits from bit 7 of the low byte
     **** ****     > ASL
0001 52FE D020  30        movb @P,rtmp
     5300 001B     
0002 5302 0240  22        andi rtmp,>ff00
     5304 FF00     
0003 5306 0A10  18        sla  rtmp,1
0004 5308 D800  30        movb rtmp,@P
     530A 001B     
                   < elite.a99
17921 530C 06A0  32        bl   @rola                      ; ROL A             ; into bit 0 of the high byte
     530E FE3E     
17922                      .asl @P                         ; ASL P
     **** ****     > ASL
0001 5310 D020  30        movb @P,rtmp
     5312 001B     
0002 5314 0240  22        andi rtmp,>ff00
     5316 FF00     
0003 5318 0A10  18        sla  rtmp,1
0004 531A D800  30        movb rtmp,@P
     531C 001B     
                   < elite.a99
17923 531E 06A0  32        bl   @rola                      ; ROL A
     5320 FE3E     
17924               
17925 5322 D80D  30        movb ra,@QQ7+1                  ; STA QQ7+1         ; Finally, we store the productivity in two bytes, with
     5324 0F2E     
17926 5326 D360  30        movb @P,ra                      ; LDA P             ; the low byte in QQ7 and the high byte in QQ7+1
     5328 001B     
17927 532A D80D  30        movb ra,@QQ7                    ; STA QQ7
     532C 0F2D     
17928               
17929 532E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5330 FE34     
17930               
17931               * ******************************************************************************
17932               *
17933               * Name: TT22
17934               * Type: Subroutine
17935               * Category: Charts
17936               * Summary: Show the Long-range Chart (red key f4)
17937               *
17938               * ******************************************************************************
17939               
17940               TT22:
17941 5332 020D  20        li   ra,>40*256                 ; LDA #64           ; Clear the top part of the screen, draw a white border,
     5334 4000     
17942 5336 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 32 (Long-
     5338 4BDE     
17943 533A 06A0  32        bl   @jsr                       ;
     533C FE28     
17944                                                                          ; range Chart)
17945               
17946 533E 020D  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     5340 0700     
17947 5342 D80D  30        movb ra,@XC                     ; STA XC
     5344 002C     
17948               
17949 5346 0200  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     5348 5B64     
17950 534A 06A0  32        bl   @jsr                       ;
     534C FE28     
17951                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
17952               
17953 534E 020D  20        li   ra,>c7*256                 ; LDA #199          ; Print recursive token 39 ("GALACTIC CHART{galaxy
     5350 C700     
17954 5352 0200  20        li   rtmp,TT27                  ; JSR TT27          ; number right-aligned to width 3}")
     5354 A6E8     
17955 5356 06A0  32        bl   @jsr                       ;
     5358 FE28     
17956               
17957 535A 0200  20        li   rtmp,NLIN                  ; JSR NLIN          ; Draw a horizontal line at pixel row 23 to box in the
     535C 25F2     
17958 535E 06A0  32        bl   @jsr                       ;
     5360 FE28     
17959                                                                          ; title and act as the top frame of the chart, and move
17960                                                                          ; the text cursor down one line
17961               
17962 5362 020D  20        li   ra,>98*256                 ; LDA #152          ; Draw a screen-wide horizontal line at pixel row 152
     5364 9800     
17963 5366 0200  20        li   rtmp,NLIN2                 ; JSR NLIN2         ; for the bottom edge of the chart, so the chart itself
     5368 25F8     
17964 536A 06A0  32        bl   @jsr                       ;
     536C FE28     
17965                                                                          ; is 128 pixels high, starting on row 24 and ending on
17966                                                                          ; row 151
17967               
17968 536E 0200  20        li   rtmp,TT14                  ; JSR TT14          ; Call TT14 to draw a circle with crosshairs at the
     5370 54BA     
17969 5372 06A0  32        bl   @jsr                       ;
     5374 FE28     
17970                                                                          ; current system's galactic coordinates
17971               
17972 5376 020E  20        li   rx,>00*256                 ; LDX #0            ; We're now going to plot each of the galaxy's systems,
     5378 0000     
17973                                                                          ; so set up a counter in X for each system, starting at
17974                                                                          ; 0 and looping through to 255
17975               
17976               TT83:
17977 537A D80E  30        movb rx,@XSAV                   ; STX XSAV          ; Store the counter in XSAV
     537C 0093     
17978               
17979 537E D3A0  30        movb @QQ15+3,rx                 ; LDX QQ15+3        ; Fetch the s1_hi seed into X, which gives us the
     5380 007B     
17980                                                                          ; galactic x-coordinate of this system
17981               
17982 5382 D3E0  30        movb @QQ15+4,ry                 ; LDY QQ15+4        ; Fetch the s2_lo seed and set bits 4 and 6, storing the
     5384 007C     
17983 5386 D34F  18        movb ry,ra                      ; TYA               ; result in ZZ to give a random number between 80 and
17984 5388 026D  22        ori  ra,>50*256                 ; ORA #%01010000    ; (but which will always be the same for this system).
     538A 5000     
17985 538C D80D  30        movb ra,@ZZ                     ; STA ZZ            ; We use this value to determine the size of the point
     538E 0097     
17986                                                                          ; for this system on the chart by passing it as the
17987                                                                          ; distance argument to the PIXEL routine below
17988               
17989 5390 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch the s0_hi seed into A, which gives us the
     5392 0079     
17990                                                                          ; galactic y-coordinate of this system
17991               
17992 5394 091D  18        srl  ra,1                       ; LSR A             ; We halve the y-coordinate because the galaxy in
17993                                                                          ; in Elite is rectangular rather than square, and is
17994                                                                          ; twice as wide (x-axis) as it is high (y-axis), so the
17995                                                                          ; chart is 256 pixels wide and 128 high
17996               
17997                      .clc                            ; CLC               ; Add 24 to the halved y-coordinate and store in XX15+1
     **** ****     > CLC
0001 5396 0A16  18        sla  rzero,1
                   < elite.a99
17998                      .adi (>18*256)                  ; ADC #24           ; (as the top of the chart is on pixel row 24, just
     **** ****     > ADI
0001 5398 1701  14        jnc  !
0002 539A B347  18        ab   rone,ra
0003               !:
0004 539C 022D  22        ai   ra,(>18*256)
     539E 1800     
                   < elite.a99
17999 53A0 D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; below the line we drew on row 23 above)
     53A2 0032     
18000               
18001 53A4 0200  20        li   rtmp,PIXEL                 ; JSR PIXEL         ; Call PIXEL to draw a point at (X, A), with the size of
     53A6 2804     
18002 53A8 06A0  32        bl   @jsr                       ;
     53AA FE28     
18003                                                                          ; the point dependent on the distance specified in ZZ
18004                                                                          ; (so a high value of ZZ will produce a 1-pixel point,
18005                                                                          ; a medium value will produce a 2-pixel dash, and a
18006                                                                          ; small value will produce a 4-pixel square)
18007               
18008 53AC 0200  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     53AE 4EF2     
18009 53B0 06A0  32        bl   @jsr                       ;
     53B2 FE28     
18010                                                                          ; to twist the three 16-bit seeds in QQ15
18011               
18012 53B4 D3A0  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the loop counter from XSAV
     53B6 0093     
18013               
18014 53B8 B387  18        ab   rone,rx                    ; INX               ; Increment the counter
18015               
18016 53BA 16DF  14        jne  TT83                       ; BNE TT83          ; If X > 0 then we haven't done all 256 systems yet, so
18017                                                                          ; loop back up to TT83
18018               
18019 53BC D360  30        movb @QQ9,ra                    ; LDA QQ9           ; Set QQ19 to the selected system's x-coordinate
     53BE 0F31     
18020 53C0 D80D  30        movb ra,@QQ19                   ; STA QQ19
     53C2 007F     
18021               
18022 53C4 D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Set QQ19+1 to the selected system's y-coordinate,
     53C6 0F32     
18023 53C8 091D  18        srl  ra,1                       ; LSR A             ; halved to fit it into the chart
18024 53CA D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1
     53CC 0080     
18025               
18026 53CE 020D  20        li   ra,>04*256                 ; LDA #4            ; Set QQ19+2 to size 4 for the crosshairs size
     53D0 0400     
18027 53D2 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     53D4 0081     
18028               
18029                                                                          ; Fall through into TT15 to draw crosshairs of size 4 at
18030                                                                          ; the selected system's coordinates
18031               
18032               * ******************************************************************************
18033               *
18034               * Name: TT15
18035               * Type: Subroutine
18036               * Category: Drawing lines
18037               * Summary: Draw a set of crosshairs
18038               *
18039               * ------------------------------------------------------------------------------
18040               *
18041               * For all views except the Short-range Chart, the centre is drawn 24 pixels to
18042               * the right of the y-coordinate given.
18043               *
18044               * ------------------------------------------------------------------------------
18045               *
18046               * Arguments:
18047               *
18048               * QQ19                The pixel x-coordinate of the centre of the crosshairs
18049               *
18050               * QQ19+1              The pixel y-coordinate of the centre of the crosshairs
18051               *
18052               * QQ19+2              The size of the crosshairs
18053               *
18054               * ******************************************************************************
18055               
18056               TT15:
18057 53D6 020D  20        li   ra,>18*256                 ; LDA #24           ; Set A to 24, which we will use as the minimum
     53D8 1800     
18058                                                                          ; screen indent for the crosshairs (i.e. the minimum
18059                                                                          ; distance from the top-left corner of the screen)
18060               
18061 53DA D3A0  30        movb @QQ11,rx                   ; LDX QQ11          ; If the current view is not the Short-range Chart,
     53DC 0096     
18062 53DE 1502  14        jgt  B52                        ; BPL B52           ; which is the only view with bit 7 set, then skip the
18063                                                                          ; following instruction
18064               
18065 53E0 020D  20        li   ra,>00*256                 ; LDA #0            ; This is the Short-range Chart, so set A to 0, so the
     53E2 0000     
18066                                                                          ; crosshairs can go right up against the screen edges
18067               
18068               B52:
18069 53E4 D80D  30        movb ra,@QQ19+5                 ; STA QQ19+5        ; Set QQ19+5 to A, which now contains the correct indent
     53E6 0084     
18070                                                                          ; for this view
18071               
18072 53E8 D360  30        movb @QQ19,ra                   ; LDA QQ19          ; Set A = crosshairs x-coordinate - crosshairs size
     53EA 007F     
18073                      .sec                            ; SEC               ; to get the x-coordinate of the left edge of the
     **** ****     > SEC
0001 53EC 0A18  18        sla  rmone,1
                   < elite.a99
18074                      .sbc @QQ19+2,ra                 ; SBC QQ19+2        ; crosshairs
     **** ****     > SBC
0001 53EE 1801  14        joc  !
0002 53F0 7347  18        sb   rone,ra
0003               !:
0004 53F2 7360  30        sb   @QQ19+2,ra
     53F4 0081     
                   < elite.a99
18075               
18076 53F6 1802  14        joc  TT84                       ; BCS TT84          ; If the above subtraction didn't underflow, then A is
18077                                                                          ; positive, so skip the next instruction
18078               
18079 53F8 020D  20        li   ra,>00*256                 ; LDA #0            ; The subtraction underflowed, so set A to 0 so the
     53FA 0000     
18080                                                                          ; crosshairs don't spill out of the left of the screen
18081               
18082               TT84:
18083                                                                          ; In the following, the authors have used XX15 for
18084                                                                          ; temporary storage. XX15 shares location with X1, Y1,
18085                                                                          ; X2 and Y2, so in the following, you can consider
18086                                                                          ; the variables like this:
18087                                                                          ;
18088                                                                          ; XX15   is the same as X1
18089                                                                          ; XX15+1 is the same as Y1
18090                                                                          ; XX15+2 is the same as X2
18091                                                                          ; XX15+3 is the same as Y2
18092                                                                          ;
18093                                                                          ; Presumably this routine was written at a different
18094                                                                          ; time to the line-drawing routine, before the two
18095                                                                          ; workspaces were merged to save space
18096 53FC D80D  30        movb ra,@XX15                   ; STA XX15          ; Set XX15 (X1) = A (the x-coordinate of the left edge
     53FE 0031     
18097                                                                          ; of the crosshairs)
18098               
18099 5400 D360  30        movb @QQ19,ra                   ; LDA QQ19          ; Set A = crosshairs x-coordinate + crosshairs size
     5402 007F     
18100                      .clc                            ; CLC               ; to get the x-coordinate of the right edge of the
     **** ****     > CLC
0001 5404 0A16  18        sla  rzero,1
                   < elite.a99
18101                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; crosshairs
     **** ****     > ADC
0001 5406 1701  14        jnc  !
0002 5408 B347  18        ab   rone,ra
0003               !:
0004 540A B360  30        ab   @QQ19+2,ra
     540C 0081     
                   < elite.a99
18102               
18103 540E 1702  14        jnc  B53                        ; BCC B53           ; If the above addition didn't overflow, then A is
18104                                                                          ; correct, so skip the next instruction
18105               
18106 5410 020D  20        li   ra,>ff*256                 ; LDA #255          ; The addition overflowed, so set A to 255 so the
     5412 FF00     
18107                                                                          ; crosshairs don't spill out of the right of the screen
18108                                                                          ; (as 255 is the x-coordinate of the rightmost pixel
18109                                                                          ; on-screen)
18110               
18111               B53:
18112 5414 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 (X2) = A (the x-coordinate of the right
     5416 0033     
18113                                                                          ; edge of the crosshairs)
18114               
18115 5418 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set XX15+1 (Y1) = crosshairs y-coordinate + indent
     541A 0080     
18116                      .clc                            ; CLC               ; to get the y-coordinate of the centre of the
     **** ****     > CLC
0001 541C 0A16  18        sla  rzero,1
                   < elite.a99
18117                      .adc @QQ19+5,ra                 ; ADC QQ19+5        ; crosshairs
     **** ****     > ADC
0001 541E 1701  14        jnc  !
0002 5420 B347  18        ab   rone,ra
0003               !:
0004 5422 B360  30        ab   @QQ19+5,ra
     5424 0084     
                   < elite.a99
18118 5426 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     5428 0032     
18119               
18120 542A 0200  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1),
     542C 2622     
18121 542E 06A0  32        bl   @jsr                       ;
     5430 FE28     
18122                                                                          ; which will draw from the left edge of the crosshairs
18123                                                                          ; to the right edge, through the centre of the
18124                                                                          ; crosshairs
18125               
18126 5432 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set A = crosshairs y-coordinate - crosshairs size
     5434 0080     
18127                      .sec                            ; SEC               ; to get the y-coordinate of the top edge of the
     **** ****     > SEC
0001 5436 0A18  18        sla  rmone,1
                   < elite.a99
18128                      .sbc @QQ19+2,ra                 ; SBC QQ19+2        ; crosshairs
     **** ****     > SBC
0001 5438 1801  14        joc  !
0002 543A 7347  18        sb   rone,ra
0003               !:
0004 543C 7360  30        sb   @QQ19+2,ra
     543E 0081     
                   < elite.a99
18129               
18130 5440 1802  14        joc  TT86                       ; BCS TT86          ; If the above subtraction didn't underflow, then A is
18131                                                                          ; correct, so skip the next instruction
18132               
18133 5442 020D  20        li   ra,>00*256                 ; LDA #0            ; The subtraction underflowed, so set A to 0 so the
     5444 0000     
18134                                                                          ; crosshairs don't spill out of the top of the screen
18135               
18136               TT86:
18137                      .clc                            ; CLC               ; Set XX15+1 (Y1) = A + indent to get the y-coordinate
     **** ****     > CLC
0001 5446 0A16  18        sla  rzero,1
                   < elite.a99
18138                      .adc @QQ19+5,ra                 ; ADC QQ19+5        ; of the top edge of the indented crosshairs
     **** ****     > ADC
0001 5448 1701  14        jnc  !
0002 544A B347  18        ab   rone,ra
0003               !:
0004 544C B360  30        ab   @QQ19+5,ra
     544E 0084     
                   < elite.a99
18139 5450 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     5452 0032     
18140               
18141 5454 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set A = crosshairs y-coordinate + crosshairs size
     5456 0080     
18142                      .clc                            ; CLC               ; + indent to get the y-coordinate of the bottom edge
     **** ****     > CLC
0001 5458 0A16  18        sla  rzero,1
                   < elite.a99
18143                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; of the indented crosshairs
     **** ****     > ADC
0001 545A 1701  14        jnc  !
0002 545C B347  18        ab   rone,ra
0003               !:
0004 545E B360  30        ab   @QQ19+2,ra
     5460 0081     
                   < elite.a99
18144                      .adc @QQ19+5,ra                 ; ADC QQ19+5
     **** ****     > ADC
0001 5462 1701  14        jnc  !
0002 5464 B347  18        ab   rone,ra
0003               !:
0004 5466 B360  30        ab   @QQ19+5,ra
     5468 0084     
                   < elite.a99
18145               
18146 546A 028D  22        ci   ra,>98*256                 ; CMP #152          ; If A < 152 then skip the following, as the crosshairs
     546C 9800     
18147 546E 1705  14        jnc  TT87                       ; BCC TT87          ; won't spill out of the bottom of the screen
18148               
18149 5470 D3A0  30        movb @QQ11,rx                   ; LDX QQ11          ; A >= 152, so we need to check whether this will fit in
     5472 0096     
18150                                                                          ; this view, so fetch the view type
18151               
18152 5474 1102  14        jlt  TT87                       ; BMI TT87          ; If this is the Short-range Chart then the y-coordinate
18153                                                                          ; is fine, so skip to TT87
18154               
18155 5476 020D  20        li   ra,>97*256                 ; LDA #151          ; Otherwise this is the Long-range Chart, so we need to
     5478 9700     
18156                                                                          ; clip the crosshairs at a maximum y-coordinate of 151
18157               
18158               TT87:
18159 547A D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; Set XX15+3 (Y2) = A (the y-coordinate of the bottom
     547C 0034     
18160                                                                          ; edge of the crosshairs)
18161               
18162 547E D360  30        movb @QQ19,ra                   ; LDA QQ19          ; Set XX15 (X1) = the x-coordinate of the centre of the
     5480 007F     
18163 5482 D80D  30        movb ra,@XX15                   ; STA XX15          ; crosshairs
     5484 0031     
18164               
18165 5486 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 (X2) = the x-coordinate of the centre of
     5488 0033     
18166                                                                          ; the crosshairs
18167               
18168 548A 0460  28        b    @LL30                      ; JMP LL30          ; Draw a vertical line (X1, Y1) to (X2, Y2), which will
     548C 2272     
18169                                                                          ; draw from the top edge of the crosshairs to the bottom
18170                                                                          ; edge, through the centre of the crosshairs, returning
18171                                                                          ; from the subroutine using a tail call
18172               
18173               * ******************************************************************************
18174               *
18175               * Name: TT14
18176               * Type: Subroutine
18177               * Category: Drawing circles
18178               * Summary: Draw a circle with crosshairs on a chart
18179               *
18180               * ------------------------------------------------------------------------------
18181               *
18182               * Draw a circle with crosshairs at the current system's galactic coordinates.
18183               *
18184               * ******************************************************************************
18185               
18186               TT126:
18187 548E 020D  20        li   ra,>68*256                 ; LDA #104          ; Set QQ19 = 104, for the x-coordinate of the centre of
     5490 6800     
18188 5492 D80D  30        movb ra,@QQ19                   ; STA QQ19          ; the fixed circle on the Short-range Chart
     5494 007F     
18189               
18190 5496 020D  20        li   ra,>5a*256                 ; LDA #90           ; Set QQ19+1 = 90, for the y-coordinate of the centre of
     5498 5A00     
18191 549A D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; the fixed circle on the Short-range Chart
     549C 0080     
18192               
18193 549E 020D  20        li   ra,>10*256                 ; LDA #16           ; Set QQ19+2 = 16, the size of the crosshairs on the
     54A0 1000     
18194 54A2 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Short-range Chart
     54A4 0081     
18195               
18196 54A6 0200  20        li   rtmp,TT15                  ; JSR TT15          ; Draw the set of crosshairs defined in QQ19, at the
     54A8 53D6     
18197 54AA 06A0  32        bl   @jsr                       ;
     54AC FE28     
18198                                                                          ; exact coordinates as this is the Short-range Chart
18199               
18200 54AE D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Set K to the fuel level from QQ14, so this can act as
     54B0 030D     
18201 54B2 D80D  30        movb ra,@K                      ; STA K             ; the circle's radius (70 being a full tank)
     54B4 003D     
18202               
18203 54B6 0460  28        b    @TT128                     ; JMP TT128         ; Jump to TT128 to draw a circle with the centre at the
     54B8 5500     
18204                                                                          ; same coordinates as the crosshairs, (QQ19, QQ19+1),
18205                                                                          ; and radius K that reflects the current fuel levels,
18206                                                                          ; returning from the subroutine using a tail call
18207               
18208               TT14:
18209 54BA D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is the Short-range Chart, which
     54BC 0096     
18210 54BE 11E7  14        jlt  TT126                      ; BMI TT126         ; is the only view with bit 7 set, then jump up to TT126
18211                                                                          ; to draw the crosshairs and circle for that view
18212               
18213                                                                          ; Otherwise this is the Long-range Chart, so we draw the
18214                                                                          ; crosshairs and circle for that view instead
18215               
18216 54C0 D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Set K to the fuel level from QQ14 divided by 4, so
     54C2 030D     
18217 54C4 091D  18        srl  ra,1                       ; LSR A             ; this can act as the circle's radius (70 being a full
18218 54C6 091D  18        srl  ra,1                       ; LSR A             ; tank, which divides down to a radius of 17)
18219 54C8 D80D  30        movb ra,@K                      ; STA K
     54CA 003D     
18220               
18221 54CC D360  30        movb @QQ0,ra                    ; LDA QQ0           ; Set QQ19 to the x-coordinate of the current system,
     54CE 0301     
18222 54D0 D80D  30        movb ra,@QQ19                   ; STA QQ19          ; which will be the centre of the circle and crosshairs
     54D2 007F     
18223                                                                          ; we draw
18224               
18225 54D4 D360  30        movb @QQ1,ra                    ; LDA QQ1           ; Set QQ19+1 to the y-coordinate of the current system,
     54D6 0302     
18226 54D8 091D  18        srl  ra,1                       ; LSR A             ; halved because the galactic chart is half as high as
18227 54DA D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; it is wide, which will again be the centre of the
     54DC 0080     
18228                                                                          ; circle and crosshairs we draw
18229               
18230 54DE 020D  20        li   ra,>07*256                 ; LDA #7            ; Set QQ19+2 = 7, the size of the crosshairs on the
     54E0 0700     
18231 54E2 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Long-range Chart
     54E4 0081     
18232               
18233 54E6 0200  20        li   rtmp,TT15                  ; JSR TT15          ; Draw the set of crosshairs defined in QQ19, which will
     54E8 53D6     
18234 54EA 06A0  32        bl   @jsr                       ;
     54EC FE28     
18235                                                                          ; be drawn 24 pixels to the right of QQ19+1
18236               
18237 54EE D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Add 24 to the y-coordinate of the crosshairs in QQ19+1
     54F0 0080     
18238                      .clc                            ; CLC               ; so that the centre of the circle matches the centre
     **** ****     > CLC
0001 54F2 0A16  18        sla  rzero,1
                   < elite.a99
18239                      .adi (>18*256)                  ; ADC #24           ; of the crosshairs
     **** ****     > ADI
0001 54F4 1701  14        jnc  !
0002 54F6 B347  18        ab   rone,ra
0003               !:
0004 54F8 022D  22        ai   ra,(>18*256)
     54FA 1800     
                   < elite.a99
18240 54FC D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1
     54FE 0080     
18241               
18242                                                                          ; Fall through into TT128 to draw a circle with the
18243                                                                          ; centre at the same coordinates as the crosshairs,
18244                                                                          ; (QQ19, QQ19+1), and radius K that reflects the
18245                                                                          ; current fuel levels
18246               
18247               * ******************************************************************************
18248               *
18249               * Name: TT128
18250               * Type: Subroutine
18251               * Category: Drawing circles
18252               * Summary: Draw a circle on a chart
18253               * Deep dive: Drawing circles
18254               *
18255               * ------------------------------------------------------------------------------
18256               *
18257               * Draw a circle with the centre at (QQ19, QQ19+1) and radius K.
18258               *
18259               * ------------------------------------------------------------------------------
18260               *
18261               * Arguments:
18262               *
18263               * QQ19                The x-coordinate of the centre of the circle
18264               *
18265               * QQ19+1              The y-coordinate of the centre of the circle
18266               *
18267               * K                   The radius of the circle
18268               *
18269               * ******************************************************************************
18270               
18271               TT128:
18272 5500 D360  30        movb @QQ19,ra                   ; LDA QQ19          ; Set K3 = the x-coordinate of the centre
     5502 007F     
18273 5504 D80D  30        movb ra,@K3                     ; STA K3
     5506 00D2     
18274               
18275 5508 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set K4 = the y-coordinate of the centre
     550A 0080     
18276 550C D80D  30        movb ra,@K4                     ; STA K4
     550E 00E0     
18277               
18278 5510 020E  20        li   rx,>00*256                 ; LDX #0            ; Set the high bytes of K3(1 0) and K4(1 0) to 0
     5512 0000     
18279 5514 D80E  30        movb rx,@K4+1                   ; STX K4+1
     5516 00E1     
18280 5518 D80E  30        movb rx,@K3+1                   ; STX K3+1
     551A 00D3     
18281               
18282               * STX LSX                \ This instruction is commented out in the original
18283                                                                          ; source
18284               
18285 551C B387  18        ab   rone,rx                    ; INX               ; Set LSP = 1 to reset the ball line heap
18286 551E D80E  30        movb rx,@LSP                    ; STX LSP
     5520 0077     
18287               
18288 5522 020E  20        li   rx,>02*256                 ; LDX #2            ; Set STP = 2, the step size for the circle
     5524 0200     
18289 5526 D80E  30        movb rx,@STP                    ; STX STP
     5528 00A6     
18290               
18291 552A 0200  20        li   rtmp,CIRCLE2               ; JSR CIRCLE2       ; Call CIRCLE2 to draw a circle with the centre at
     552C B88C     
18292 552E 06A0  32        bl   @jsr                       ;
     5530 FE28     
18293                                                                          ; (K3(1 0), K4(1 0)) and radius K
18294               
18295               * LDA #&FF               \ These instructions are commented out in the original
18296               * STA LSX                \ source
18297               
18298 5532 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5534 FE34     
18299               
18300               * ******************************************************************************
18301               *
18302               * Name: TT219
18303               * Type: Subroutine
18304               * Category: Market
18305               * Summary: Show the Buy Cargo screen (red key f1)
18306               *
18307               * ------------------------------------------------------------------------------
18308               *
18309               * Other entry points:
18310               *
18311               * BAY2                Jump into the main loop at FRCE, setting the key
18312               * "pressed" to red key f9 (so we show the Inventory
18313               * screen)
18314               *
18315               * ******************************************************************************
18316               
18317               TT219:
18318               * LDA #2                 \ This instruction is commented out in the original
18319                                                                          ; source. Perhaps this view originally had a QQ11 value
18320                                                                          ; of 2, but it turned out not to need its own unique ID,
18321                                                                          ; so the authors found they could just use a view value
18322                                                                          ; of 1 and save an instruction at the same time?
18323 5536 0200  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     5538 4BDC     
18324 553A 06A0  32        bl   @jsr                       ;
     553C FE28     
18325                                                                          ; and set the current view type in QQ11 to 1
18326               
18327 553E 0200  20        li   rtmp,TT163                 ; JSR TT163         ; Print the column headers for the prices table
     5540 5F4E     
18328 5542 06A0  32        bl   @jsr                       ;
     5544 FE28     
18329               
18330 5546 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     5548 8000     
18331 554A D80D  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     554C 007E     
18332               
18333               * JSR FLKB               \ This instruction is commented out in the original
18334                                                                          ; source. It calls a routine to flush the keyboard
18335                                                                          ; buffer (FLKB) that isn't present in the cassette
18336                                                                          ; version but is in other versions
18337               
18338 554E 020D  20        li   ra,>00*256                 ; LDA #0            ; We're going to loop through all the available market
     5550 0000     
18339 5552 D80D  30        movb ra,@QQ29                   ; STA QQ29          ; items, so we set up a counter in QQ29 to denote the
     5554 0F1B     
18340                                                                          ; current item and start it at 0
18341               
18342               TT220:
18343 5556 0200  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to print the item name, market price and
     5558 5E22     
18344 555A 06A0  32        bl   @jsr                       ;
     555C FE28     
18345                                                                          ; availability of the current item, and set QQ24 to the
18346                                                                          ; item's price / 4, QQ25 to the quantity available and
18347                                                                          ; QQ19+1 to byte #1 from the market prices table for
18348                                                                          ; this item
18349               
18350 555E D360  30        movb @QQ25,ra                   ; LDA QQ25          ; If there are some of the current item available, jump
     5560 0F19     
18351 5562 1611  14        jne  TT224                      ; BNE TT224         ; to TT224 below to see if we want to buy any
18352               
18353 5564 0460  28        b    @TT222                     ; JMP TT222         ; Otherwise there are none available, so jump down to
     5566 565C     
18354                                                                          ; TT222 to skip this item
18355               
18356               TQ4:
18357 5568 020F  20        li   ry,>b0*256                 ; LDY #176          ; Set Y to the recursive token 16 ("QUANTITY")
     556A B000     
18358               
18359               Tc:
18360 556C 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     556E 5F24     
18361 5570 06A0  32        bl   @jsr                       ;
     5572 FE28     
18362               
18363 5574 D34F  18        movb ry,ra                      ; TYA               ; Print the recursive token in Y followed by a question
18364 5576 0200  20        li   rtmp,prq_                  ; JSR prq           ; mark
     5578 5E12     
18365 557A 06A0  32        bl   @jsr                       ;
     557C FE28     
18366               
18367               TTX224:
18368 557E 0200  20        li   rtmp,dn2_                  ; JSR dn2           ; Call dn2 to make a short, high beep and delay for 1
     5580 A4E8     
18369 5582 06A0  32        bl   @jsr                       ;
     5584 FE28     
18370                                                                          ; second
18371               
18372               TT224:
18373 5586 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     5588 4CE2     
18374 558A 06A0  32        bl   @jsr                       ;
     558C FE28     
18375                                                                          ; and move the text cursor to column 1 on row 21, i.e.
18376                                                                          ; the start of the top row of the three bottom rows
18377               
18378 558E 020D  20        li   ra,>cc*256                 ; LDA #204          ; Print recursive token 44 ("QUANTITY OF ")
     5590 CC00     
18379 5592 0200  20        li   rtmp,TT27                  ; JSR TT27
     5594 A6E8     
18380 5596 06A0  32        bl   @jsr                       ;
     5598 FE28     
18381               
18382 559A D360  30        movb @QQ29,ra                   ; LDA QQ29          ; Print recursive token 48 + QQ29, which will be in the
     559C 0F1B     
18383                      .clc                            ; CLC               ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     **** ****     > CLC
0001 559E 0A16  18        sla  rzero,1
                   < elite.a99
18384                      .adi (>d0*256)                  ; ADC #208          ; prints the current item's name
     **** ****     > ADI
0001 55A0 1701  14        jnc  !
0002 55A2 B347  18        ab   rone,ra
0003               !:
0004 55A4 022D  22        ai   ra,(>D0*256)
     55A6 D000     
                   < elite.a99
18385 55A8 0200  20        li   rtmp,TT27                  ; JSR TT27
     55AA A6E8     
18386 55AC 06A0  32        bl   @jsr                       ;
     55AE FE28     
18387               
18388 55B0 020D  20        li   ra,('/')*256               ; LDA #'/'          ; Print "/"
     55B2 2F00     
18389 55B4 0200  20        li   rtmp,TT27                  ; JSR TT27
     55B6 A6E8     
18390 55B8 06A0  32        bl   @jsr                       ;
     55BA FE28     
18391               
18392 55BC 0200  20        li   rtmp,TT152                 ; JSR TT152         ; Print the unit ("t", "kg" or "g") for the current item
     55BE 5F0C     
18393 55C0 06A0  32        bl   @jsr                       ;
     55C2 FE28     
18394                                                                          ; (as the call to TT151 above set QQ19+1 with the
18395                                                                          ; appropriate value)
18396               
18397 55C4 020D  20        li   ra,('?')*256               ; LDA #'?'          ; Print "?"
     55C6 3F00     
18398 55C8 0200  20        li   rtmp,TT27                  ; JSR TT27
     55CA A6E8     
18399 55CC 06A0  32        bl   @jsr                       ;
     55CE FE28     
18400               
18401 55D0 0200  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline
     55D2 4FA6     
18402 55D4 06A0  32        bl   @jsr                       ;
     55D6 FE28     
18403               
18404 55D8 020E  20        li   rx,>00*256                 ; LDX #0            ; These instructions have no effect, as they are
     55DA 0000     
18405 55DC D80E  30        movb rx,@R                      ; STX R             ; repeated at the start of gnum, which we call next.
     55DE 0091     
18406 55E0 020E  20        li   rx,>0c*256                 ; LDX #12           ; Perhaps they were left behind when code was moved from
     55E2 0C00     
18407 55E4 D80E  30        movb rx,@T1                     ; STX T1            ; here into gnum, and weren't deleted?
     55E6 0006     
18408               
18409               * .TT223                 \ This label is commented out in the original source,
18410                                                                          ; and is a duplicate of a label in gnum, so this could
18411                                                                          ; also be a remnant if the code in gnum was originally
18412                                                                          ; here, but got moved into the gnum subroutine
18413               
18414 55E8 0200  20        li   rtmp,gnum_                 ; JSR gnum          ; Call gnum to get a number from the keyboard, which
     55EA 568E     
18415 55EC 06A0  32        bl   @jsr                       ;
     55EE FE28     
18416                                                                          ; will be the quantity of this item we want to purchase,
18417                                                                          ; returning the number entered in A and R
18418               
18419 55F0 18BB  14        joc  TQ4                        ; BCS TQ4           ; If gnum set the C flag, the number entered is greater
18420                                                                          ; than the quantity available, so jump up to TQ4 to
18421                                                                          ; display a "Quantity?" error, beep, clear the number
18422                                                                          ; and try again
18423               
18424 55F2 D80D  30        movb ra,@P                      ; STA P             ; Otherwise we have a valid purchase quantity entered,
     55F4 001B     
18425                                                                          ; so store the amount we want to purchase in P
18426               
18427 55F6 0200  20        li   rtmp,tnpr_                 ; JSR tnpr          ; Call tnpr to work out whether there is room in the
     55F8 4EB4     
18428 55FA 06A0  32        bl   @jsr                       ;
     55FC FE28     
18429                                                                          ; cargo hold for this item
18430               
18431 55FE 020F  20        li   ry,>ce*256                 ; LDY #206          ; Set Y to recursive token 46 (" CARGO{sentence case}")
     5600 CE00     
18432                                                                          ; to pass to the Tc routine if we call it
18433               
18434 5602 18B4  14        joc  Tc                         ; BCS Tc            ; If the C flag is set, then there is no room in the
18435                                                                          ; cargo hold, jump up to Tc to print a "Cargo?" error,
18436                                                                          ; beep, clear the number and try again
18437               
18438 5604 D360  30        movb @QQ24,ra                   ; LDA QQ24          ; There is room in the cargo hold, so now to check
     5606 0F18     
18439 5608 D80D  30        movb ra,@Q                      ; STA Q             ; whether we have enough cash, so fetch the item's
     560A 0090     
18440                                                                          ; price / 4, which was returned in QQ24 by the call
18441                                                                          ; to TT151 above and store it in Q
18442               
18443 560C 0200  20        li   rtmp,GCASH                 ; JSR GCASH         ; Call GCASH to calculate:
     560E A202     
18444 5610 06A0  32        bl   @jsr                       ;
     5612 FE28     
18445                                                                          ;
18446                                                                          ; (Y X) = P * Q * 4
18447                                                                          ;
18448                                                                          ; which will be the total price of this transaction
18449                                                                          ; (as P contains the purchase quantity and Q contains
18450                                                                          ; the item's price / 4)
18451               
18452 5614 0200  20        li   rtmp,LCASH                 ; JSR LCASH         ; Subtract (Y X) cash from the cash pot in CASH
     5616 A172     
18453 5618 06A0  32        bl   @jsr                       ;
     561A FE28     
18454               
18455 561C 020F  20        li   ry,>c5*256                 ; LDY #197          ; If the C flag is clear, we didn't have enough cash,
     561E C500     
18456 5620 17A5  14        jnc  Tc                         ; BCC Tc            ; so set Y to the recursive token 37 ("CASH") and jump
18457                                                                          ; up to Tc to print a "Cash?" error, beep, clear the
18458                                                                          ; number and try again
18459               
18460 5622 D3E0  30        movb @QQ29,ry                   ; LDY QQ29          ; Fetch the current market item number from QQ29 into Y
     5624 0F1B     
18461               
18462 5626 D360  30        movb @R,ra                      ; LDA R             ; Set A to the number of items we just purchased (this
     5628 0091     
18463                                                                          ; was set by gnum above)
18464               
18465                      .pha                            ; PHA               ; Store the quantity just purchased on the stack
     **** ****     > PHA
0001 562A D68D  30        movb ra,*rsp
0002 562C 060A  14        dec  rsp
                   < elite.a99
18466               
18467                      .clc                            ; CLC               ; Add the number purchased to the Y-th byte of QQ20,
     **** ****     > CLC
0001 562E 0A16  18        sla  rzero,1
                   < elite.a99
18468                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; which contains the number of items of this type in
     **** ****     > ADC
0001 5630 1701  14        jnc  !
0002 5632 B347  18        ab   rone,ra
0003               !:
0004 5634 B36F  34        ab   @QQ20(RY),ra
     5636 0317     
                   < elite.a99
18469 5638 DBCD  38        movb ra,@QQ20(ry)               ; STA QQ20,Y        ; our hold (so this transfers the bought items into our
     563A 0317     
18470                                                                          ; cargo hold)
18471               
18472 563C D36F  34        movb @AVL(ry),ra                ; LDA AVL,Y         ; Subtract the number of items from the Y-th byte of
     563E 0335     
18473                      .sec                            ; SEC               ; AVL, which contains the number of items of this type
     **** ****     > SEC
0001 5640 0A18  18        sla  rmone,1
                   < elite.a99
18474                      .sbc @R,ra                      ; SBC R             ; that are available on the market
     **** ****     > SBC
0001 5642 1801  14        joc  !
0002 5644 7347  18        sb   rone,ra
0003               !:
0004 5646 7360  30        sb   @R,ra
     5648 0091     
                   < elite.a99
18475 564A DBCD  38        movb ra,@AVL(ry)                ; STA AVL,Y
     564C 0335     
18476               
18477                      .pla                            ; PLA               ; Restore the quantity just purchased
     **** ****     > PLA
0001 564E 058A  14        inc  rsp
0002 5650 D35A  26        movb *rsp,ra
                   < elite.a99
18478               
18479 5652 1304  14        jeq  TT222                      ; BEQ TT222         ; If we didn't buy anything, jump to TT222 to skip the
18480                                                                          ; following instruction
18481               
18482 5654 0200  20        li   rtmp,dn_                   ; JSR dn            ; Call dn to print the amount of cash left in the cash
     5656 A4D4     
18483 5658 06A0  32        bl   @jsr                       ;
     565A FE28     
18484                                                                          ; pot, then make a short, high beep to confirm the
18485                                                                          ; purchase, and delay for 1 second
18486               
18487               TT222:
18488 565C D360  30        movb @QQ29,ra                   ; LDA QQ29          ; Move the text cursor to row QQ29 + 5 (where QQ29 is
     565E 0F1B     
18489                      .clc                            ; CLC               ; the item number, starting from 0)
     **** ****     > CLC
0001 5660 0A16  18        sla  rzero,1
                   < elite.a99
18490                      .adi (>05*256)                  ; ADC #5
     **** ****     > ADI
0001 5662 1701  14        jnc  !
0002 5664 B347  18        ab   rone,ra
0003               !:
0004 5666 022D  22        ai   ra,(>05*256)
     5668 0500     
                   < elite.a99
18491 566A D80D  30        movb ra,@YC                     ; STA YC
     566C 002D     
18492               
18493 566E 020D  20        li   ra,>00*256                 ; LDA #0            ; Move the text cursor to column 0
     5670 0000     
18494 5672 D80D  30        movb ra,@XC                     ; STA XC
     5674 002C     
18495               
18496 5676 B347  18        ab   rone,ra                    ; INC QQ29          ; Increment QQ29 to point to the next item
18497               
18498 5678 D360  30        movb @QQ29,ra                   ; LDA QQ29          ; If QQ29 >= 17 then jump to BAY2 as we have done the
     567A 0F1B     
18499 567C 028D  22        ci   ra,>11*256                 ; CMP #17           ; last item
     567E 1100     
18500 5680 1802  14        joc  BAY2                       ; BCS BAY2
18501               
18502 5682 0460  28        b    @TT220                     ; JMP TT220         ; Otherwise loop back to TT220 to print the next market
     5684 5556     
18503                                                                          ; item
18504               
18505               BAY2:
18506 5686 020D  20        li   ra,(f9_)*256               ; LDA #f9           ; Jump into the main loop at FRCE, setting the key
     5688 7700     
18507 568A 0460  28        b    @FRCE                      ; JMP FRCE          ; "pressed" to red key f9 (so we show the Inventory
     568C C35C     
18508                                                                          ; screen)
18509               
18510               * ******************************************************************************
18511               *
18512               * Name: gnum
18513               * Type: Subroutine
18514               * Category: Market
18515               * Summary: Get a number from the keyboard
18516               *
18517               * ------------------------------------------------------------------------------
18518               *
18519               * Get a number from the keyboard, up to the maximum number in QQ25, for the
18520               * buying and selling of cargo and equipment.
18521               *
18522               * Pressing a key with an ASCII code less than ASCII "0" will return a 0 in A (so
18523               * that includes pressing Space or Return), while pressing a key with an ASCII
18524               * code greater than ASCII "9" will jump to the Inventory screen (so that
18525               * includes all letters and most punctuation).
18526               *
18527               * ------------------------------------------------------------------------------
18528               *
18529               * Arguments:
18530               *
18531               * QQ25                The maximum number allowed
18532               *
18533               * ------------------------------------------------------------------------------
18534               *
18535               * Returns:
18536               *
18537               * A                   The number entered
18538               *
18539               * R                   Also contains the number entered
18540               *
18541               * C flag              Set if the number is too large (> QQ25), clear otherwise
18542               *
18543               * ******************************************************************************
18544               
18545               gnum_:
18546 568E 020E  20        li   rx,>00*256                 ; LDX #0            ; We will build the number entered in R, so initialise
     5690 0000     
18547 5692 D80E  30        movb rx,@R                      ; STX R             ; it with 0
     5694 0091     
18548               
18549 5696 020E  20        li   rx,>0c*256                 ; LDX #12           ; We will check for up to 12 key presses, so set a
     5698 0C00     
18550 569A D80E  30        movb rx,@T1                     ; STX T1            ; counter in T1
     569C 0006     
18551               
18552               TT223:
18553 569E 0200  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     56A0 CEAC     
18554 56A2 06A0  32        bl   @jsr                       ;
     56A4 FE28     
18555                                                                          ; the key's ASCII code in A (and X)
18556               
18557 56A6 D80D  30        movb ra,@Q                      ; STA Q             ; Store the key pressed in Q
     56A8 0090     
18558               
18559                      .sec                            ; SEC               ; Subtract ASCII "0" from the key pressed, to leave the
     **** ****     > SEC
0001 56AA 0A18  18        sla  rmone,1
                   < elite.a99
18560                      .sbi (('0')*256)                ; SBC #'0'          ; numeric value of the key in A (if it was a number key)
     **** ****     > SBI
0001 56AC 1801  14        joc  !
0002 56AE 7347  18        sb   rone,ra
0003               !:
0004 56B0 022D  22        ai   ra,-(('0')*256)
     56B2 D000     
                   < elite.a99
18561               
18562 56B4 172B  14        jnc  OUT                        ; BCC OUT           ; If A < 0, jump to OUT to load the current number and
18563                                                                          ; return from the subroutine, as the key pressed was
18564                                                                          ; RETURN (or some other ncharacter with a value less
18565                                                                          ; than ASCII "0")
18566               
18567 56B6 028D  22        ci   ra,>0a*256                 ; CMP #10           ; If A >= 10, jump to BAY2 to display the Inventory
     56B8 0A00     
18568 56BA 18E5  14        joc  BAY2                       ; BCS BAY2          ; screen, as the key pressed was a letter or other
18569                                                                          ; non-digit and is greater than ASCII "9"
18570               
18571 56BC D80D  30        movb ra,@S                      ; STA S             ; Store the numeric value of the key pressed in S
     56BE 0092     
18572               
18573 56C0 D360  30        movb @R,ra                      ; LDA R             ; Fetch the result so far into A
     56C2 0091     
18574               
18575 56C4 028D  22        ci   ra,>1a*256                 ; CMP #26           ; If A >= 26, where A is the number entered so far, then
     56C6 1A00     
18576 56C8 1821  14        joc  OUT                        ; BCS OUT           ; adding a further digit will make it bigger than 256,
18577                                                                          ; so jump to OUT to return from the subroutine with the
18578                                                                          ; result in R (i.e. ignore the last key press)
18579               
18580                      .asla                           ; ASL A             ; Set A = (A * 2) + (A * 8) = A * 10
     **** ****     > ASLA
0001 56CA 024D  22        andi ra,>ff00
     56CC FF00     
0002 56CE 0A1D  18        sla  ra,1
                   < elite.a99
18581 56D0 D80D  30        movb ra,@T                      ; STA T
     56D2 00D1     
18582                      .asla                           ; ASL A
     **** ****     > ASLA
0001 56D4 024D  22        andi ra,>ff00
     56D6 FF00     
0002 56D8 0A1D  18        sla  ra,1
                   < elite.a99
18583                      .asla                           ; ASL A
     **** ****     > ASLA
0001 56DA 024D  22        andi ra,>ff00
     56DC FF00     
0002 56DE 0A1D  18        sla  ra,1
                   < elite.a99
18584                      .adc @T,ra                      ; ADC T
     **** ****     > ADC
0001 56E0 1701  14        jnc  !
0002 56E2 B347  18        ab   rone,ra
0003               !:
0004 56E4 B360  30        ab   @T,ra
     56E6 00D1     
                   < elite.a99
18585               
18586                      .adc @S,ra                      ; ADC S             ; Add the pressed digit to A and store in R, so R now
     **** ****     > ADC
0001 56E8 1701  14        jnc  !
0002 56EA B347  18        ab   rone,ra
0003               !:
0004 56EC B360  30        ab   @S,ra
     56EE 0092     
                   < elite.a99
18587 56F0 D80D  30        movb ra,@R                      ; STA R             ; contains its previous value with the new key press
     56F2 0091     
18588                                                                          ; tacked onto the end
18589               
18590 56F4 9360  30        cb   @QQ25,ra                   ; CMP QQ25          ; If the result in R = the maximum allowed in QQ25, jump
     56F6 0F19     
18591 56F8 1301  14        jeq  TT226                      ; BEQ TT226         ; to TT226 to print the key press and keep looping (the
18592                                                                          ; BEQ is needed because the BCS below would jump to OUT
18593                                                                          ; if R >= QQ25, which we don't want)
18594               
18595 56FA 1808  14        joc  OUT                        ; BCS OUT           ; If the result in R > QQ25, jump to OUT to return from
18596                                                                          ; the subroutine with the result in R
18597               
18598               TT226:
18599 56FC D360  30        movb @Q,ra                      ; LDA Q             ; Print the character in Q (i.e. the key that was
     56FE 0090     
18600 5700 0200  20        li   rtmp,TT26                  ; JSR TT26          ; pressed, as we stored the ASCII value in Q earlier)
     5702 31C2     
18601 5704 06A0  32        bl   @jsr                       ;
     5706 FE28     
18602               
18603 5708 7347  18        sb   rone,ra                    ; DEC T1            ; Decrement the loop counter
18604               
18605 570A 16C9  14        jne  TT223                      ; BNE TT223         ; Loop back to TT223 until we have checked for 12 digits
18606               
18607               OUT:
18608 570C D360  30        movb @R,ra                      ; LDA R             ; Set A to the result we have been building in R
     570E 0091     
18609               
18610 5710 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5712 FE34     
18611               
18612               * ******************************************************************************
18613               *
18614               * Name: TT208
18615               * Type: Subroutine
18616               * Category: Market
18617               * Summary: Show the Sell Cargo screen (red key f2)
18618               *
18619               * ******************************************************************************
18620               
18621               TT208:
18622 5714 020D  20        li   ra,>04*256                 ; LDA #4            ; Clear the top part of the screen, draw a white border,
     5716 0400     
18623 5718 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 4 (Sell
     571A 4BDE     
18624 571C 06A0  32        bl   @jsr                       ;
     571E FE28     
18625                                                                          ; Cargo screen)
18626               
18627 5720 020D  20        li   ra,>04*256                 ; LDA #4            ; Move the text cursor to row 4, column 4
     5722 0400     
18628 5724 D80D  30        movb ra,@YC                     ; STA YC
     5726 002D     
18629 5728 D80D  30        movb ra,@XC                     ; STA XC
     572A 002C     
18630               
18631               * JSR FLKB               \ This instruction is commented out in the original
18632                                                                          ; source. It calls a routine to flush the keyboard
18633                                                                          ; buffer (FLKB) that isn't present in the cassette
18634                                                                          ; version but is in other versions
18635               
18636 572C 020D  20        li   ra,>cd*256                 ; LDA #205          ; Print recursive token 45 ("SELL")
     572E CD00     
18637 5730 0200  20        li   rtmp,TT27                  ; JSR TT27
     5732 A6E8     
18638 5734 06A0  32        bl   @jsr                       ;
     5736 FE28     
18639               
18640 5738 020D  20        li   ra,>ce*256                 ; LDA #206          ; Print recursive token 46 (" CARGO{sentence case}")
     573A CE00     
18641 573C 0200  20        li   rtmp,TT68                  ; JSR TT68          ; followed by a colon
     573E A6DC     
18642 5740 06A0  32        bl   @jsr                       ;
     5742 FE28     
18643               
18644                                                                          ; Fall through into TT210 to show the Inventory screen
18645                                                                          ; with the option to sell
18646               
18647               * ******************************************************************************
18648               *
18649               * Name: TT210
18650               * Type: Subroutine
18651               * Category: Market
18652               * Summary: Show a list of current cargo in our hold, optionally to sell
18653               *
18654               * ------------------------------------------------------------------------------
18655               *
18656               * Show a list of current cargo in our hold, either with the ability to sell (the
18657               * Sell Cargo screen) or without (the Inventory screen), depending on the current
18658               * view.
18659               *
18660               * ------------------------------------------------------------------------------
18661               *
18662               * Arguments:
18663               *
18664               * QQ11                The current view:
18665               *
18666               * * 4 = Sell Cargo
18667               *
18668               * * 8 = Inventory
18669               *
18670               * ******************************************************************************
18671               
18672               TT210:
18673 5744 020F  20        li   ry,>00*256                 ; LDY #0            ; We're going to loop through all the available market
     5746 0000     
18674                                                                          ; items and check whether we have any in the hold (and,
18675                                                                          ; if we are in the Sell Cargo screen, whether we want
18676                                                                          ; to sell any items), so we set up a counter in Y to
18677                                                                          ; denote the current item and start it at 0
18678               
18679               TT211:
18680 5748 D80F  30        movb ry,@QQ29                   ; STY QQ29          ; Store the current item number in QQ29
     574A 0F1B     
18681               
18682 574C D3AF  34        movb @QQ20(ry),rx               ; LDX QQ20,Y        ; Fetch into X the amount of the current item that we
     574E 0317     
18683 5750 135E  14        jeq  TT212                      ; BEQ TT212         ; have in our cargo hold, which is stored in QQ20+Y,
18684                                                                          ; and if there are no items of this type in the hold,
18685                                                                          ; jump down to TT212 to skip to the next item
18686               
18687 5752 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y * 4, so this will act as an index into the
18688                      .asla                           ; ASL A             ; market prices table at QQ23 for this item (as there
     **** ****     > ASLA
0001 5754 024D  22        andi ra,>ff00
     5756 FF00     
0002 5758 0A1D  18        sla  ra,1
                   < elite.a99
18689                      .asla                           ; ASL A             ; are four bytes per item in the table)
     **** ****     > ASLA
0001 575A 024D  22        andi ra,>ff00
     575C FF00     
0002 575E 0A1D  18        sla  ra,1
                   < elite.a99
18690 5760 D3CD  18        movb ra,ry                      ; TAY
18691               
18692 5762 D36F  34        movb @QQ23+1(ry),ra             ; LDA QQ23+1,Y      ; Fetch byte #1 from the market prices table for the
     5764 CFDF     
18693 5766 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; current item and store it in QQ19+1, for use by the
     5768 0080     
18694                                                                          ; call to TT152 below
18695               
18696 576A D34E  18        movb rx,ra                      ; TXA               ; Store the amount of item in the hold (in X) on the
18697                      .pha                            ; PHA               ; stack
     **** ****     > PHA
0001 576C D68D  30        movb ra,*rsp
0002 576E 060A  14        dec  rsp
                   < elite.a99
18698               
18699 5770 0200  20        li   rtmp,TT69                  ; JSR TT69          ; Call TT69 to set Sentence Case and print a newline
     5772 4F9E     
18700 5774 06A0  32        bl   @jsr                       ;
     5776 FE28     
18701               
18702                      .clc                            ; CLC               ; Print recursive token 48 + QQ29, which will be in the
     **** ****     > CLC
0001 5778 0A16  18        sla  rzero,1
                   < elite.a99
18703 577A D360  30        movb @QQ29,ra                   ; LDA QQ29          ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     577C 0F1B     
18704                      .adi (>d0*256)                  ; ADC #208          ; prints the current item's name
     **** ****     > ADI
0001 577E 1701  14        jnc  !
0002 5780 B347  18        ab   rone,ra
0003               !:
0004 5782 022D  22        ai   ra,(>D0*256)
     5784 D000     
                   < elite.a99
18705 5786 0200  20        li   rtmp,TT27                  ; JSR TT27
     5788 A6E8     
18706 578A 06A0  32        bl   @jsr                       ;
     578C FE28     
18707               
18708 578E 020D  20        li   ra,>0e*256                 ; LDA #14           ; Move the text cursor to column 14, for the item's
     5790 0E00     
18709 5792 D80D  30        movb ra,@XC                     ; STA XC            ; quantity
     5794 002C     
18710               
18711                      .pla                            ; PLA               ; Restore the amount of item in the hold into X
     **** ****     > PLA
0001 5796 058A  14        inc  rsp
0002 5798 D35A  26        movb *rsp,ra
                   < elite.a99
18712 579A D38D  18        movb ra,rx                      ; TAX
18713               
18714                      .clc                            ; CLC               ; Print the 8-bit number in X to 3 digits, without a
     **** ****     > CLC
0001 579C 0A16  18        sla  rzero,1
                   < elite.a99
18715 579E 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; decimal point
     57A0 2FFC     
18716 57A2 06A0  32        bl   @jsr                       ;
     57A4 FE28     
18717               
18718 57A6 0200  20        li   rtmp,TT152                 ; JSR TT152         ; Print the unit ("t", "kg" or "g") for the market item
     57A8 5F0C     
18719 57AA 06A0  32        bl   @jsr                       ;
     57AC FE28     
18720                                                                          ; whose byte #1 from the market prices table is in
18721                                                                          ; QQ19+1 (which we set up above)
18722               
18723 57AE D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view type in QQ11 is not 4 (Sell Cargo
     57B0 0096     
18724 57B2 028D  22        ci   ra,>04*256                 ; CMP #4            ; screen), jump to TT212 to skip the option to sell
     57B4 0400     
18725 57B6 162B  14        jne  TT212                      ; BNE TT212         ; items
18726               
18727 57B8 020D  20        li   ra,>cd*256                 ; LDA #205          ; Set A to recursive token 45 ("SELL")
     57BA CD00     
18728               
18729 57BC 0200  20        li   rtmp,TT214                 ; JSR TT214         ; Call TT214 to print "Sell(Y/N)?" and return the
     57BE 5882     
18730 57C0 06A0  32        bl   @jsr                       ;
     57C2 FE28     
18731                                                                          ; response in the C flag
18732               
18733 57C4 1724  14        jnc  TT212                      ; BCC TT212         ; If the response was "no", jump to TT212 to move on to
18734                                                                          ; the next item
18735               
18736 57C6 D360  30        movb @QQ29,ra                   ; LDA QQ29          ; We are selling this item, so fetch the item number
     57C8 0F1B     
18737                                                                          ; from QQ29
18738               
18739 57CA 020E  20        li   rx,>ff*256                 ; LDX #255          ; Set QQ17 = 255 to disable printing
     57CC FF00     
18740 57CE D80E  30        movb rx,@QQ17                   ; STX QQ17
     57D0 007E     
18741               
18742 57D2 0200  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to set QQ24 to the item's price / 4 (the
     57D4 5E22     
18743 57D6 06A0  32        bl   @jsr                       ;
     57D8 FE28     
18744                                                                          ; routine doesn't print the item details, as we just
18745                                                                          ; disabled printing)
18746               
18747 57DA D3E0  30        movb @QQ29,ry                   ; LDY QQ29          ; Set P to the amount of this item we have in our cargo
     57DC 0F1B     
18748 57DE D36F  34        movb @QQ20(ry),ra               ; LDA QQ20,Y        ; hold (which is the amount to sell)
     57E0 0317     
18749 57E2 D80D  30        movb ra,@P                      ; STA P
     57E4 001B     
18750               
18751 57E6 D360  30        movb @QQ24,ra                   ; LDA QQ24          ; Set Q to the item's price / 4
     57E8 0F18     
18752 57EA D80D  30        movb ra,@Q                      ; STA Q
     57EC 0090     
18753               
18754 57EE 0200  20        li   rtmp,GCASH                 ; JSR GCASH         ; Call GCASH to calculate
     57F0 A202     
18755 57F2 06A0  32        bl   @jsr                       ;
     57F4 FE28     
18756                                                                          ;
18757                                                                          ; (Y X) = P * Q * 4
18758                                                                          ;
18759                                                                          ; which will be the total price we make from this sale
18760                                                                          ; (as P contains the quantity we're selling and Q
18761                                                                          ; contains the item's price / 4)
18762               
18763 57F6 0200  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH
     57F8 A1BE     
18764 57FA 06A0  32        bl   @jsr                       ;
     57FC FE28     
18765               
18766 57FE 020D  20        li   ra,>00*256                 ; LDA #0            ; We've made the sale, so set the amount
     5800 0000     
18767 5802 D3E0  30        movb @QQ29,ry                   ; LDY QQ29
     5804 0F1B     
18768 5806 DBCD  38        movb ra,@QQ20(ry)               ; STA QQ20,Y
     5808 0317     
18769               
18770 580A D80D  30        movb ra,@QQ17                   ; STA QQ17          ; Set QQ17 = 0, which enables printing again
     580C 007E     
18771               
18772               TT212:
18773 580E D3E0  30        movb @QQ29,ry                   ; LDY QQ29          ; Fetch the item number from QQ29 into Y, and increment
     5810 0F1B     
18774 5812 B3C7  18        ab   rone,ry                    ; INY               ; Y to point to the next item
18775               
18776 5814 028F  22        ci   ry,>11*256                 ; CPY #17           ; If Y >= 17 then skip the next instruction as we have
     5816 1100     
18777 5818 1802  14        joc  B54                        ; BCS B54           ; done the last item
18778               
18779 581A 0460  28        b    @TT211                     ; JMP TT211         ; Otherwise loop back to TT211 to print the next item
     581C 5748     
18780                                                                          ; in the hold
18781               
18782               B54:
18783 581E D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view type in QQ11 is not 4 (Sell Cargo
     5820 0096     
18784 5822 028D  22        ci   ra,>04*256                 ; CMP #4            ; screen), skip the next two instructions and just
     5824 0400     
18785 5826 1606  14        jne  B55                        ; BNE B55           ; return from the subroutine
18786               
18787 5828 0200  20        li   rtmp,dn2_                  ; JSR dn2           ; This is the Sell Cargo screen, so call dn2 to make a
     582A A4E8     
18788 582C 06A0  32        bl   @jsr                       ;
     582E FE28     
18789                                                                          ; short, high beep and delay for 1 second
18790               
18791 5830 0460  28        b    @BAY2                      ; JMP BAY2          ; And then jump to BAY2 to display the Inventory
     5832 5686     
18792                                                                          ; screen, as we have finished selling cargo
18793               
18794               B55:
18795 5834 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5836 FE34     
18796               
18797               * ******************************************************************************
18798               *
18799               * Name: TT213
18800               * Type: Subroutine
18801               * Category: Market
18802               * Summary: Show the Inventory screen (red key f9)
18803               *
18804               * ******************************************************************************
18805               
18806               TT213:
18807 5838 020D  20        li   ra,>08*256                 ; LDA #8            ; Clear the top part of the screen, draw a white border,
     583A 0800     
18808 583C 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 8 (Inventory
     583E 4BDE     
18809 5840 06A0  32        bl   @jsr                       ;
     5842 FE28     
18810                                                                          ; screen)
18811               
18812 5844 020D  20        li   ra,>0b*256                 ; LDA #11           ; Move the text cursor to column 11 to print the screen
     5846 0B00     
18813 5848 D80D  30        movb ra,@XC                     ; STA XC            ; title
     584A 002C     
18814               
18815 584C 020D  20        li   ra,>a4*256                 ; LDA #164          ; Print recursive token 4 ("INVENTORY{crlf}") followed
     584E A400     
18816 5850 0200  20        li   rtmp,TT60                  ; JSR TT60          ; by a paragraph break and Sentence Case
     5852 4F94     
18817 5854 06A0  32        bl   @jsr                       ;
     5856 FE28     
18818               
18819 5858 0200  20        li   rtmp,NLIN4                 ; JSR NLIN4         ; Draw a horizontal line at pixel row 19 to box in the
     585A 25EC     
18820 585C 06A0  32        bl   @jsr                       ;
     585E FE28     
18821                                                                          ; title. The authors could have used a call to NLIN3
18822                                                                          ; instead and saved the above call to TT60, but you
18823                                                                          ; just can't optimise everything
18824               
18825 5860 0200  20        li   rtmp,fwl_                  ; JSR fwl           ; Call fwl to print the fuel and cash levels on two
     5862 A67E     
18826 5864 06A0  32        bl   @jsr                       ;
     5866 FE28     
18827                                                                          ; separate lines
18828               
18829 5868 D360  30        movb @CRGO,ra                   ; LDA CRGO          ; If our ship's cargo capacity is < 26 (i.e. we do not
     586A 0316     
18830 586C 028D  22        ci   ra,>1a*256                 ; CMP #26           ; have a cargo bay extension), skip the following two
     586E 1A00     
18831 5870 1706  14        jnc  B56                        ; BCC B56           ; instructions
18832               
18833 5872 020D  20        li   ra,>6b*256                 ; LDA #107          ; We do have a cargo bay extension, so print recursive
     5874 6B00     
18834 5876 0200  20        li   rtmp,TT27                  ; JSR TT27          ; token 107 ("LARGE CARGO{sentence case} BAY")
     5878 A6E8     
18835 587A 06A0  32        bl   @jsr                       ;
     587C FE28     
18836               
18837               B56:
18838 587E 0460  28        b    @TT210                     ; JMP TT210         ; Jump to TT210 to print the contents of our cargo bay
     5880 5744     
18839                                                                          ; and return from the subroutine using a tail call
18840               
18841               * ******************************************************************************
18842               *
18843               * Name: TT214
18844               * Type: Subroutine
18845               * Category: Keyboard
18846               * Summary: Ask a question with a "Y/N?" prompt and return the response
18847               *
18848               * ------------------------------------------------------------------------------
18849               *
18850               * Arguments:
18851               *
18852               * A                   The text token to print before the "Y/N?" prompt
18853               *
18854               * ------------------------------------------------------------------------------
18855               *
18856               * Returns:
18857               *
18858               * C flag              Set if the response was "yes", clear otherwise
18859               *
18860               * ******************************************************************************
18861               
18862               TT214:
18863                      .pha                            ; PHA               ; Print a space, using the stack to preserve the value
     **** ****     > PHA
0001 5882 D68D  30        movb ra,*rsp
0002 5884 060A  14        dec  rsp
                   < elite.a99
18864 5886 0200  20        li   rtmp,TT162                 ; JSR TT162         ; of A
     5888 5F24     
18865 588A 06A0  32        bl   @jsr                       ;
     588C FE28     
18866                      .pla                            ; PLA
     **** ****     > PLA
0001 588E 058A  14        inc  rsp
0002 5890 D35A  26        movb *rsp,ra
                   < elite.a99
18867               
18868               TT221:
18869 5892 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     5894 A6E8     
18870 5896 06A0  32        bl   @jsr                       ;
     5898 FE28     
18871               
18872 589A 020D  20        li   ra,>e1*256                 ; LDA #225          ; Print recursive token 65 ("(Y/N)?")
     589C E100     
18873 589E 0200  20        li   rtmp,TT27                  ; JSR TT27
     58A0 A6E8     
18874 58A2 06A0  32        bl   @jsr                       ;
     58A4 FE28     
18875               
18876 58A6 0200  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     58A8 CEAC     
18877 58AA 06A0  32        bl   @jsr                       ;
     58AC FE28     
18878                                                                          ; the key's ASCII code in A and X
18879               
18880 58AE 026D  22        ori  ra,>20*256                 ; ORA #%00100000    ; Set bit 5 in the value of the key pressed, which
     58B0 2000     
18881                                                                          ; converts it to lower case
18882               
18883 58B2 028D  22        ci   ra,('y')*256               ; CMP #'y'          ; If "y" was pressed, jump to TT218
     58B4 7900     
18884 58B6 1304  14        jeq  TT218                      ; BEQ TT218
18885               
18886 58B8 020D  20        li   ra,('n')*256               ; LDA #'n'          ; Otherwise jump to TT26 to print "n" and return from
     58BA 6E00     
18887 58BC 0460  28        b    @TT26                      ; JMP TT26          ; the subroutine using a tail call (so all other
     58BE 31C2     
18888                                                                          ; responses apart from "y" indicate a no)
18889               
18890               TT218:
18891 58C0 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character in A, i.e. print "y"
     58C2 31C2     
18892 58C4 06A0  32        bl   @jsr                       ;
     58C6 FE28     
18893               
18894                      .sec                            ; SEC               ; Set the C flag to indicate a "yes" response
     **** ****     > SEC
0001 58C8 0A18  18        sla  rmone,1
                   < elite.a99
18895               
18896 58CA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     58CC FE34     
18897               
18898               * ******************************************************************************
18899               *
18900               * Name: TT16
18901               * Type: Subroutine
18902               * Category: Charts
18903               * Summary: Move the crosshairs on a chart
18904               *
18905               * ------------------------------------------------------------------------------
18906               *
18907               * Move the chart crosshairs by the amount in X and Y.
18908               *
18909               * ------------------------------------------------------------------------------
18910               *
18911               * Arguments:
18912               *
18913               * X                   The amount to move the crosshairs in the x-axis
18914               *
18915               * Y                   The amount to move the crosshairs in the y-axis
18916               *
18917               * ******************************************************************************
18918               
18919               TT16:
18920 58CE D34E  18        movb rx,ra                      ; TXA               ; Push the change in X onto the stack (let's call this
18921                      .pha                            ; PHA               ; the x-delta)
     **** ****     > PHA
0001 58D0 D68D  30        movb ra,*rsp
0002 58D2 060A  14        dec  rsp
                   < elite.a99
18922               
18923 58D4 73C7  18        sb   rone,ry                    ; DEY               ; Negate the change in Y and push it onto the stack
18924 58D6 D34F  18        movb ry,ra                      ; TYA               ; (let's call this the y-delta)
18925                      .eoi (>ff*256)                  ; EOR #&FF
     **** ****     > EOI
0001 58D8 0200  20        li   rtmp,(>FF*256)
     58DA FF00     
0002 58DC 2B40  18        xor  rtmp,ra
                   < elite.a99
18926                      .pha                            ; PHA
     **** ****     > PHA
0001 58DE D68D  30        movb ra,*rsp
0002 58E0 060A  14        dec  rsp
                   < elite.a99
18927               
18928 58E2 0200  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     58E4 4EA2     
18929 58E6 06A0  32        bl   @jsr                       ;
     58E8 FE28     
18930                                                                          ; screen gets drawn and we can move the crosshairs with
18931                                                                          ; no screen flicker
18932               
18933 58EA 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     58EC 5932     
18934 58EE 06A0  32        bl   @jsr                       ;
     58F0 FE28     
18935                                                                          ; which will erase the crosshairs currently there
18936               
18937                      .pla                            ; PLA               ; Store the y-delta in QQ19+3 and fetch the current
     **** ****     > PLA
0001 58F2 058A  14        inc  rsp
0002 58F4 D35A  26        movb *rsp,ra
                   < elite.a99
18938 58F6 D80D  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; y-coordinate of the crosshairs from QQ10 into A, ready
     58F8 0082     
18939 58FA D360  30        movb @QQ10,ra                   ; LDA QQ10          ; for the call to TT123
     58FC 0F32     
18940               
18941 58FE 0200  20        li   rtmp,TT123                 ; JSR TT123         ; Call TT123 to move the selected system's galactic
     5900 5958     
18942 5902 06A0  32        bl   @jsr                       ;
     5904 FE28     
18943                                                                          ; y-coordinate by the y-delta, putting the new value in
18944                                                                          ; QQ19+4
18945               
18946 5906 D360  30        movb @QQ19+4,ra                 ; LDA QQ19+4        ; Store the updated y-coordinate in QQ10 (the current
     5908 0083     
18947 590A D80D  30        movb ra,@QQ10                   ; STA QQ10          ; y-coordinate of the crosshairs)
     590C 0F32     
18948               
18949 590E D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; This instruction has no effect, as QQ19+1 is
     5910 0080     
18950                                                                          ; overwritten below, both in TT103 and TT105
18951               
18952                      .pla                            ; PLA               ; Store the x-delta in QQ19+3 and fetch the current
     **** ****     > PLA
0001 5912 058A  14        inc  rsp
0002 5914 D35A  26        movb *rsp,ra
                   < elite.a99
18953 5916 D80D  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; x-coordinate of the crosshairs from QQ10 into A, ready
     5918 0082     
18954 591A D360  30        movb @QQ9,ra                    ; LDA QQ9           ; for the call to TT123
     591C 0F31     
18955               
18956 591E 0200  20        li   rtmp,TT123                 ; JSR TT123         ; Call TT123 to move the selected system's galactic
     5920 5958     
18957 5922 06A0  32        bl   @jsr                       ;
     5924 FE28     
18958                                                                          ; x-coordinate by the x-delta, putting the new value in
18959                                                                          ; QQ19+4
18960               
18961 5926 D360  30        movb @QQ19+4,ra                 ; LDA QQ19+4        ; Store the updated x-coordinate in QQ9 (the current
     5928 0083     
18962 592A D80D  30        movb ra,@QQ9                    ; STA QQ9           ; x-coordinate of the crosshairs)
     592C 0F31     
18963               
18964 592E D80D  30        movb ra,@QQ19                   ; STA QQ19          ; This instruction has no effect, as QQ19 is overwritten
     5930 007F     
18965                                                                          ; below, both in TT103 and TT105
18966               
18967                                                                          ; Now we've updated the coordinates of the crosshairs,
18968                                                                          ; fall through into TT103 to redraw them at their new
18969                                                                          ; location
18970               
18971               * ******************************************************************************
18972               *
18973               * Name: TT103
18974               * Type: Subroutine
18975               * Category: Charts
18976               * Summary: Draw a small set of crosshairs on a chart
18977               *
18978               * ------------------------------------------------------------------------------
18979               *
18980               * Draw a small set of crosshairs on a galactic chart at the coordinates in
18981               * (QQ9, QQ10).
18982               *
18983               * ******************************************************************************
18984               
18985               TT103:
18986 5932 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; Fetch the current view type into A
     5934 0096     
18987               
18988 5936 1320  14        jeq  TT180                      ; BEQ TT180         ; If this is a space view, return from the subroutine
18989                                                                          ; (as TT180 contains an RTS), as there are no moveable
18990                                                                          ; crosshairs in space
18991               
18992 5938 1121  14        jlt  TT105                      ; BMI TT105         ; If this is the Short-range Chart screen, jump to TT105
18993               
18994 593A D360  30        movb @QQ9,ra                    ; LDA QQ9           ; Store the crosshairs x-coordinate in QQ19
     593C 0F31     
18995 593E D80D  30        movb ra,@QQ19                   ; STA QQ19
     5940 007F     
18996               
18997 5942 D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Halve the crosshairs y-coordinate and store it in QQ19
     5944 0F32     
18998 5946 091D  18        srl  ra,1                       ; LSR A             ; (we halve it because the Long-range Chart is half as
18999 5948 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; high as it is wide)
     594A 0080     
19000               
19001 594C 020D  20        li   ra,>04*256                 ; LDA #4            ; Set QQ19+2 to 4 denote crosshairs of size 4
     594E 0400     
19002 5950 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     5952 0081     
19003               
19004 5954 0460  28        b    @TT15                      ; JMP TT15          ; Jump to TT15 to draw crosshairs of size 4 at the
     5956 53D6     
19005                                                                          ; crosshairs coordinates, returning from the subroutine
19006                                                                          ; using a tail call
19007               
19008               * ******************************************************************************
19009               *
19010               * Name: TT123
19011               * Type: Subroutine
19012               * Category: Charts
19013               * Summary: Move galactic coordinates by a signed delta
19014               *
19015               * ------------------------------------------------------------------------------
19016               *
19017               * Move an 8-bit galactic coordinate by a certain distance in either direction
19018               * (i.e. a signed 8-bit delta), but only if it doesn't cause the coordinate to
19019               * overflow. The coordinate is in a single axis, so it's either an x-coordinate
19020               * or a y-coordinate.
19021               *
19022               * ------------------------------------------------------------------------------
19023               *
19024               * Arguments:
19025               *
19026               * A                   The galactic coordinate to update
19027               *
19028               * QQ19+3              The delta (can be positive or negative)
19029               *
19030               * ------------------------------------------------------------------------------
19031               *
19032               * Returns:
19033               *
19034               * QQ19+4              The updated coordinate after moving by the delta (this
19035               * will be the same as A if moving by the delta overflows)
19036               *
19037               * ------------------------------------------------------------------------------
19038               *
19039               * Other entry points:
19040               *
19041               * TT180               Contains an RTS
19042               *
19043               * ******************************************************************************
19044               
19045               TT123:
19046 5958 D80D  30        movb ra,@QQ19+4                 ; STA QQ19+4        ; Store the original coordinate in temporary storage at
     595A 0083     
19047                                                                          ; QQ19+4
19048               
19049                      .clc                            ; CLC               ; Set A = A + QQ19+3, so A now contains the original
     **** ****     > CLC
0001 595C 0A16  18        sla  rzero,1
                   < elite.a99
19050                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ; coordinate, moved by the delta
     **** ****     > ADC
0001 595E 1701  14        jnc  !
0002 5960 B347  18        ab   rone,ra
0003               !:
0004 5962 B360  30        ab   @QQ19+3,ra
     5964 0082     
                   < elite.a99
19051               
19052 5966 D3A0  30        movb @QQ19+3,rx                 ; LDX QQ19+3        ; If the delta is negative, jump to TT124
     5968 0082     
19053 596A 1103  14        jlt  TT124                      ; BMI TT124
19054               
19055 596C 1703  14        jnc  TT125                      ; BCC TT125         ; If the C flag is clear, then the above addition didn't
19056                                                                          ; overflow, so jump to TT125 to return the updated value
19057               
19058 596E 0460  28        b    @rts                       ; RTS               ; Otherwise the C flag is set and the above addition
     5970 FE34     
19059                                                                          ; overflowed, so do not update the return value
19060               
19061               TT124:
19062 5972 1702  14        jnc  TT180                      ; BCC TT180         ; If the C flag is clear, then because the delta is
19063                                                                          ; negative, this indicates the addition (which is
19064                                                                          ; effectively a subtraction) underflowed, so jump to
19065                                                                          ; TT180 to return from the subroutine without updating
19066                                                                          ; the return value
19067               
19068               TT125:
19069 5974 D80D  30        movb ra,@QQ19+4                 ; STA QQ19+4        ; Store the updated coordinate in QQ19+4
     5976 0083     
19070               
19071               TT180:
19072 5978 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     597A FE34     
19073               
19074               * ******************************************************************************
19075               *
19076               * Name: TT105
19077               * Type: Subroutine
19078               * Category: Charts
19079               * Summary: Draw crosshairs on the Short-range Chart, with clipping
19080               *
19081               * ------------------------------------------------------------------------------
19082               *
19083               * Check whether the crosshairs are close enough to the current system to appear
19084               * on the Short-range Chart, and if so, draw them.
19085               *
19086               * ******************************************************************************
19087               
19088               TT105:
19089 597C D360  30        movb @QQ9,ra                    ; LDA QQ9           ; Set A = QQ9 - QQ0, the horizontal distance between the
     597E 0F31     
19090                      .sec                            ; SEC               ; crosshairs (QQ9) and the current system (QQ0)
     **** ****     > SEC
0001 5980 0A18  18        sla  rmone,1
                   < elite.a99
19091                      .sbc @QQ0,ra                    ; SBC QQ0
     **** ****     > SBC
0001 5982 1801  14        joc  !
0002 5984 7347  18        sb   rone,ra
0003               !:
0004 5986 7360  30        sb   @QQ0,ra
     5988 0301     
                   < elite.a99
19092               
19093 598A 028D  22        ci   ra,>26*256                 ; CMP #38           ; If the horizontal distance in A < 38, then the
     598C 2600     
19094 598E 1703  14        jnc  TT179                      ; BCC TT179         ; crosshairs are close enough to the current system to
19095                                                                          ; appear in the Short-range Chart, so jump to TT179 to
19096                                                                          ; check the vertical distance
19097               
19098 5990 028D  22        ci   ra,>e6*256                 ; CMP #230          ; If the horizontal distance in A < -26, then the
     5992 E600     
19099 5994 17F1  14        jnc  TT180                      ; BCC TT180         ; crosshairs are too far from the current system to
19100                                                                          ; appear in the Short-range Chart, so jump to TT180 to
19101                                                                          ; return from the subroutine (as TT180 contains an RTS)
19102               
19103               TT179:
19104                      .asla                           ; ASL A             ; Set QQ19 = 104 + A * 4
     **** ****     > ASLA
0001 5996 024D  22        andi ra,>ff00
     5998 FF00     
0002 599A 0A1D  18        sla  ra,1
                   < elite.a99
19105                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 599C 024D  22        andi ra,>ff00
     599E FF00     
0002 59A0 0A1D  18        sla  ra,1
                   < elite.a99
19106                      .clc                            ; CLC               ; 104 is the x-coordinate of the centre of the chart,
     **** ****     > CLC
0001 59A2 0A16  18        sla  rzero,1
                   < elite.a99
19107                      .adi (>68*256)                  ; ADC #104          ; so this sets QQ19 to the screen pixel x-coordinate
     **** ****     > ADI
0001 59A4 1701  14        jnc  !
0002 59A6 B347  18        ab   rone,ra
0003               !:
0004 59A8 022D  22        ai   ra,(>68*256)
     59AA 6800     
                   < elite.a99
19108 59AC D80D  30        movb ra,@QQ19                   ; STA QQ19          ; of the crosshairs
     59AE 007F     
19109               
19110 59B0 D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Set A = QQ10 - QQ1, the vertical distance between the
     59B2 0F32     
19111                      .sec                            ; SEC               ; crosshairs (QQ10) and the current system (QQ1)
     **** ****     > SEC
0001 59B4 0A18  18        sla  rmone,1
                   < elite.a99
19112                      .sbc @QQ1,ra                    ; SBC QQ1
     **** ****     > SBC
0001 59B6 1801  14        joc  !
0002 59B8 7347  18        sb   rone,ra
0003               !:
0004 59BA 7360  30        sb   @QQ1,ra
     59BC 0302     
                   < elite.a99
19113               
19114 59BE 028D  22        ci   ra,>26*256                 ; CMP #38           ; If the vertical distance in A is < 38, then the
     59C0 2600     
19115 59C2 1703  14        jnc  B57                        ; BCC B57           ; crosshairs are close enough to the current system to
19116                                                                          ; appear in the Short-range Chart, so skip the next two
19117                                                                          ; instructions
19118               
19119 59C4 028D  22        ci   ra,>dc*256                 ; CMP #220          ; If the horizontal distance in A is < -36, then the
     59C6 DC00     
19120 59C8 17D7  14        jnc  TT180                      ; BCC TT180         ; crosshairs are too far from the current system to
19121                                                                          ; appear in the Short-range Chart, so jump to TT180 to
19122                                                                          ; return from the subroutine (as TT180 contains an RTS)
19123               
19124               B57:
19125                      .asla                           ; ASL A             ; Set QQ19+1 = 90 + A * 2
     **** ****     > ASLA
0001 59CA 024D  22        andi ra,>ff00
     59CC FF00     
0002 59CE 0A1D  18        sla  ra,1
                   < elite.a99
19126                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 59D0 0A16  18        sla  rzero,1
                   < elite.a99
19127                      .adi (>5a*256)                  ; ADC #90           ; 90 is the y-coordinate of the centre of the chart,
     **** ****     > ADI
0001 59D2 1701  14        jnc  !
0002 59D4 B347  18        ab   rone,ra
0003               !:
0004 59D6 022D  22        ai   ra,(>5A*256)
     59D8 5A00     
                   < elite.a99
19128 59DA D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; so this sets QQ19+1 to the screen pixel x-coordinate
     59DC 0080     
19129                                                                          ; of the crosshairs
19130               
19131 59DE 020D  20        li   ra,>08*256                 ; LDA #8            ; Set QQ19+2 to 8 denote crosshairs of size 8
     59E0 0800     
19132 59E2 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     59E4 0081     
19133               
19134 59E6 0460  28        b    @TT15                      ; JMP TT15          ; Jump to TT15 to draw crosshairs of size 8 at the
     59E8 53D6     
19135                                                                          ; crosshairs coordinates, returning from the subroutine
19136                                                                          ; using a tail call
19137               
19138               * ******************************************************************************
19139               *
19140               * Name: TT23
19141               * Type: Subroutine
19142               * Category: Charts
19143               * Summary: Show the Short-range Chart (red key f5)
19144               *
19145               * ******************************************************************************
19146               
19147               TT23:
19148 59EA 020D  20        li   ra,>80*256                 ; LDA #128          ; Clear the top part of the screen, draw a white border,
     59EC 8000     
19149 59EE 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 128 (Short-
     59F0 4BDE     
19150 59F2 06A0  32        bl   @jsr                       ;
     59F4 FE28     
19151                                                                          ; range Chart)
19152               
19153 59F6 020D  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     59F8 0700     
19154 59FA D80D  30        movb ra,@XC                     ; STA XC
     59FC 002C     
19155               
19156 59FE 020D  20        li   ra,>be*256                 ; LDA #190          ; Print recursive token 30 ("SHORT RANGE CHART") and
     5A00 BE00     
19157 5A02 0200  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; draw a horizontal line at pixel row 19 to box in the
     5A04 25E4     
19158 5A06 06A0  32        bl   @jsr                       ;
     5A08 FE28     
19159                                                                          ; title
19160               
19161 5A0A 0200  20        li   rtmp,TT14                  ; JSR TT14          ; Call TT14 to draw a circle with crosshairs at the
     5A0C 54BA     
19162 5A0E 06A0  32        bl   @jsr                       ;
     5A10 FE28     
19163                                                                          ; current system's galactic coordinates
19164               
19165 5A12 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     5A14 5932     
19166 5A16 06A0  32        bl   @jsr                       ;
     5A18 FE28     
19167                                                                          ; i.e. at the selected system
19168               
19169 5A1A 0200  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     5A1C 5B64     
19170 5A1E 06A0  32        bl   @jsr                       ;
     5A20 FE28     
19171                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
19172               
19173 5A22 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0, which we'll use below to zero out the INWK
     5A24 0000     
19174                                                                          ; workspace
19175               
19176 5A26 D80D  30        movb ra,@XX20                   ; STA XX20          ; We're about to start working our way through each of
     5A28 00A8     
19177                                                                          ; the galaxy's systems, so set up a counter in XX20 for
19178                                                                          ; each system, starting at 0 and looping through to 255
19179               
19180 5A2A 020E  20        li   rx,>18*256                 ; LDX #24           ; First, though, we need to zero out the 25 bytes at
     5A2C 1800     
19181                                                                          ; INWK so we can use them to work out which systems have
19182                                                                          ; room for a label, so set a counter in X for 25 bytes
19183               
19184               EE3:
19185 5A2E DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X        ; Set the X-th byte of INWK to zero
     5A30 0053     
19186               
19187 5A32 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19188               
19189 5A34 15FC  14        jgt  EE3                        ; BPL EE3           ; Loop back to EE3 for the next byte until we've zeroed
19190                                                                          ; all 25 bytes
19191               
19192                                                                          ; We now loop through every single system in the galaxy
19193                                                                          ; and check the distance from the current system whose
19194                                                                          ; coordinates are in (QQ0, QQ1). We get the galactic
19195                                                                          ; coordinates of each system from the system's seeds,
19196                                                                          ; like this:
19197                                                                          ;
19198                                                                          ; x = s1_hi (which is stored in QQ15+3)
19199                                                                          ; y = s0_hi (which is stored in QQ15+1)
19200                                                                          ;
19201                                                                          ; so the following loops through each system in the
19202                                                                          ; galaxy in turn and calculates the distance between
19203                                                                          ; (QQ0, QQ1) and (s1_hi, s0_hi) to find the closest one
19204               
19205               TT182:
19206 5A36 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ0, the horizontal distance between
     5A38 007B     
19207                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ0, QQ1)
     **** ****     > SEC
0001 5A3A 0A18  18        sla  rmone,1
                   < elite.a99
19208                      .sbc @QQ0,ra                    ; SBC QQ0
     **** ****     > SBC
0001 5A3C 1801  14        joc  !
0002 5A3E 7347  18        sb   rone,ra
0003               !:
0004 5A40 7360  30        sb   @QQ0,ra
     5A42 0301     
                   < elite.a99
19209               
19210 5A44 1807  14        joc  TT184                      ; BCS TT184         ; If a borrow didn't occur, i.e. s1_hi >= QQ0, then the
19211                                                                          ; result is positive, so jump to TT184 and skip the
19212                                                                          ; following two instructions
19213               
19214                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5A46 0200  20        li   rtmp,(>FF*256)
     5A48 FF00     
0002 5A4A 2B40  18        xor  rtmp,ra
                   < elite.a99
19215                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s1_hi - QQ0|)
     **** ****     > ADI
0001 5A4C 1701  14        jnc  !
0002 5A4E B347  18        ab   rone,ra
0003               !:
0004 5A50 022D  22        ai   ra,(>01*256)
     5A52 0100     
                   < elite.a99
19216               
19217               TT184:
19218 5A54 028D  22        ci   ra,>14*256                 ; CMP #20           ; If the horizontal distance in A is >= 20, then this
     5A56 1400     
19219 5A58 187D  14        joc  TT187                      ; BCS TT187         ; system is too far away from the current system to
19220                                                                          ; appear in the Short-range Chart, so jump to TT187 to
19221                                                                          ; move on to the next system
19222               
19223 5A5A D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ1, the vertical distance between
     5A5C 0079     
19224                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ0, QQ1)
     **** ****     > SEC
0001 5A5E 0A18  18        sla  rmone,1
                   < elite.a99
19225                      .sbc @QQ1,ra                    ; SBC QQ1
     **** ****     > SBC
0001 5A60 1801  14        joc  !
0002 5A62 7347  18        sb   rone,ra
0003               !:
0004 5A64 7360  30        sb   @QQ1,ra
     5A66 0302     
                   < elite.a99
19226               
19227 5A68 1807  14        joc  TT186                      ; BCS TT186         ; If a borrow didn't occur, i.e. s0_hi >= QQ1, then the
19228                                                                          ; result is positive, so jump to TT186 and skip the
19229                                                                          ; following two instructions
19230               
19231                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5A6A 0200  20        li   rtmp,(>FF*256)
     5A6C FF00     
0002 5A6E 2B40  18        xor  rtmp,ra
                   < elite.a99
19232                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s0_hi - QQ1|)
     **** ****     > ADI
0001 5A70 1701  14        jnc  !
0002 5A72 B347  18        ab   rone,ra
0003               !:
0004 5A74 022D  22        ai   ra,(>01*256)
     5A76 0100     
                   < elite.a99
19233               
19234               TT186:
19235 5A78 028D  22        ci   ra,>26*256                 ; CMP #38           ; If the vertical distance in A is >= 38, then this
     5A7A 2600     
19236 5A7C 186B  14        joc  TT187                      ; BCS TT187         ; system is too far away from the current system to
19237                                                                          ; appear in the Short-range Chart, so jump to TT187 to
19238                                                                          ; move on to the next system
19239               
19240                                                                          ; This system should be shown on the Short-range Chart,
19241                                                                          ; so now we need to work out where the label should go,
19242                                                                          ; and set up the various variables we need to draw the
19243                                                                          ; system's filled circle on the chart
19244               
19245 5A7E D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ0, the horizontal distance between
     5A80 007B     
19246                      .sec                            ; SEC               ; this system and the current system, where |A| < 20.
     **** ****     > SEC
0001 5A82 0A18  18        sla  rmone,1
                   < elite.a99
19247                      .sbc @QQ0,ra                    ; SBC QQ0           ; Let's call this the x-delta, as it's the horizontal
     **** ****     > SBC
0001 5A84 1801  14        joc  !
0002 5A86 7347  18        sb   rone,ra
0003               !:
0004 5A88 7360  30        sb   @QQ0,ra
     5A8A 0301     
                   < elite.a99
19248                                                                          ; difference between the current system at the centre of
19249                                                                          ; the chart, and this system (and this time we keep the
19250                                                                          ; sign of A, so it can be negative if it's to the left
19251                                                                          ; of the chart's centre, or positive if it's to the
19252                                                                          ; right)
19253               
19254                      .asla                           ; ASL A             ; Set XX12 = 104 + x-delta * 4
     **** ****     > ASLA
0001 5A8C 024D  22        andi ra,>ff00
     5A8E FF00     
0002 5A90 0A1D  18        sla  ra,1
                   < elite.a99
19255                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 5A92 024D  22        andi ra,>ff00
     5A94 FF00     
0002 5A96 0A1D  18        sla  ra,1
                   < elite.a99
19256                      .adi (>68*256)                  ; ADC #104          ; 104 is the x-coordinate of the centre of the chart,
     **** ****     > ADI
0001 5A98 1701  14        jnc  !
0002 5A9A B347  18        ab   rone,ra
0003               !:
0004 5A9C 022D  22        ai   ra,(>68*256)
     5A9E 6800     
                   < elite.a99
19257 5AA0 D80D  30        movb ra,@XX12                   ; STA XX12          ; so this sets XX12 to the centre 104 +/- 76, the pixel
     5AA2 0037     
19258                                                                          ; x-coordinate of this system
19259               
19260 5AA4 091D  18        srl  ra,1                       ; LSR A             ; Move the text cursor to column x-delta / 2 + 1
19261 5AA6 091D  18        srl  ra,1                       ; LSR A             ; which will be in the range 1-10
19262 5AA8 091D  18        srl  ra,1                       ; LSR A
19263 5AAA D80D  30        movb ra,@XC                     ; STA XC
     5AAC 002C     
19264 5AAE B347  18        ab   rone,ra                    ; INC XC
19265               
19266 5AB0 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ1, the vertical distance between
     5AB2 0079     
19267                      .sec                            ; SEC               ; this system and the current system, where |A| < 38.
     **** ****     > SEC
0001 5AB4 0A18  18        sla  rmone,1
                   < elite.a99
19268                      .sbc @QQ1,ra                    ; SBC QQ1           ; Let's call this the y-delta, as it's the vertical
     **** ****     > SBC
0001 5AB6 1801  14        joc  !
0002 5AB8 7347  18        sb   rone,ra
0003               !:
0004 5ABA 7360  30        sb   @QQ1,ra
     5ABC 0302     
                   < elite.a99
19269                                                                          ; difference between the current system at the centre of
19270                                                                          ; the chart, and this system (and this time we keep the
19271                                                                          ; sign of A, so it can be negative if it's above the
19272                                                                          ; chart's centre, or positive if it's below)
19273               
19274                      .asla                           ; ASL A             ; Set K4 = 90 + y-delta * 2
     **** ****     > ASLA
0001 5ABE 024D  22        andi ra,>ff00
     5AC0 FF00     
0002 5AC2 0A1D  18        sla  ra,1
                   < elite.a99
19275                      .adi (>5a*256)                  ; ADC #90           ;
     **** ****     > ADI
0001 5AC4 1701  14        jnc  !
0002 5AC6 B347  18        ab   rone,ra
0003               !:
0004 5AC8 022D  22        ai   ra,(>5A*256)
     5ACA 5A00     
                   < elite.a99
19276 5ACC D80D  30        movb ra,@K4                     ; STA K4            ; 90 is the y-coordinate of the centre of the chart,
     5ACE 00E0     
19277                                                                          ; so this sets K4 to the centre 90 +/- 74, the pixel
19278                                                                          ; y-coordinate of this system
19279               
19280 5AD0 091D  18        srl  ra,1                       ; LSR A             ; Set Y = K4 / 8, so Y contains the number of the text
19281 5AD2 091D  18        srl  ra,1                       ; LSR A             ; row that contains this system
19282 5AD4 091D  18        srl  ra,1                       ; LSR A
19283 5AD6 D3CD  18        movb ra,ry                      ; TAY
19284               
19285                                                                          ; Now to see if there is room for this system's label.
19286                                                                          ; Ideally we would print the system name on the same
19287                                                                          ; text row as the system, but we only want to print one
19288                                                                          ; label per row, to prevent overlap, so now we check
19289                                                                          ; this system's row, and if that's already occupied,
19290                                                                          ; the row above, and if that's already occupied, the
19291                                                                          ; row below... and if that's already occupied, we give
19292                                                                          ; up and don't print a label for this system
19293               
19294 5AD8 D3AF  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; If the value in INWK+Y is 0 (i.e. the text row
     5ADA 0053     
19295 5ADC 1309  14        jeq  EE4                        ; BEQ EE4           ; containing this system does not already have another
19296                                                                          ; system's label on it), jump to EE4 to store this
19297                                                                          ; system's label on this row
19298               
19299 5ADE B3C7  18        ab   rone,ry                    ; INY               ; If the value in INWK+Y+1 is 0 (i.e. the text row below
19300 5AE0 D3AF  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; the one containing this system does not already have
     5AE2 0053     
19301 5AE4 1305  14        jeq  EE4                        ; BEQ EE4           ; another system's label on it), jump to EE4 to store
19302                                                                          ; this system's label on this row
19303               
19304 5AE6 73C7  18        sb   rone,ry                    ; DEY               ; If the value in INWK+Y-1 is 0 (i.e. the text row above
19305 5AE8 73C7  18        sb   rone,ry                    ; DEY               ; the one containing this system does not already have
19306 5AEA D3AF  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; another system's label on it), fall through into to
     5AEC 0053     
19307 5AEE 1610  14        jne  ee1_                       ; BNE ee1           ; EE4 to store this system's label on this row,
19308                                                                          ; otherwise jump to ee1 to skip printing a label for
19309                                                                          ; this system (as there simply isn't room)
19310               
19311               EE4:
19312 5AF0 D80F  30        movb ry,@YC                     ; STY YC            ; Now to print the label, so move the text cursor to row
     5AF2 002D     
19313                                                                          ; Y (which contains the row where we can print this
19314                                                                          ; system's label)
19315               
19316 5AF4 028F  22        ci   ry,>03*256                 ; CPY #3            ; If Y < 3, then the system would clash with the chart
     5AF6 0300     
19317 5AF8 172D  14        jnc  TT187                      ; BCC TT187         ; title, so jump to TT187 to skip showing the system
19318               
19319 5AFA 7387  18        sb   rone,rx                    ; DEX               ; We entered the EE4 routine with X = 0, so this stores
19320 5AFC DBCE  38        movb rx,@INWK(ry)               ; STX INWK,Y        ; &FF in INWK+Y, to denote that this row is now occupied
     5AFE 0053     
19321                                                                          ; so we don't try to print another system's label on
19322                                                                          ; this row
19323               
19324 5B00 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     5B02 8000     
19325 5B04 D80D  30        movb ra,@QQ17                   ; STA QQ17
     5B06 007E     
19326               
19327 5B08 0200  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print out the system name for the seeds
     5B0A A5C4     
19328 5B0C 06A0  32        bl   @jsr                       ;
     5B0E FE28     
19329                                                                          ; in QQ15 (which now contains the seeds for the current
19330                                                                          ; system)
19331               
19332               ee1_:
19333 5B10 020D  20        li   ra,>00*256                 ; LDA #0            ; Now to plot the star, so set the high bytes of K, K3
     5B12 0000     
19334 5B14 D80D  30        movb ra,@K3+1                   ; STA K3+1          ; and K4 to 0
     5B16 00D3     
19335 5B18 D80D  30        movb ra,@K4+1                   ; STA K4+1
     5B1A 00E1     
19336 5B1C D80D  30        movb ra,@K+1                    ; STA K+1
     5B1E 003E     
19337               
19338 5B20 D360  30        movb @XX12,ra                   ; LDA XX12          ; Set the low byte of K3 to XX12, the pixel x-coordinate
     5B22 0037     
19339 5B24 D80D  30        movb ra,@K3                     ; STA K3            ; of this system
     5B26 00D2     
19340               
19341 5B28 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Fetch s2_hi for this system from QQ15+5, extract bit 0
     5B2A 007D     
19342 5B2C 024D  22        andi ra,>01*256                 ; AND #1            ; and add 2 to get the size of the star, which we store
     5B2E 0100     
19343                      .adi (>02*256)                  ; ADC #2            ; in K. This will be either 2, 3 or 4, depending on the
     **** ****     > ADI
0001 5B30 1701  14        jnc  !
0002 5B32 B347  18        ab   rone,ra
0003               !:
0004 5B34 022D  22        ai   ra,(>02*256)
     5B36 0200     
                   < elite.a99
19344 5B38 D80D  30        movb ra,@K                      ; STA K             ; value of bit 0, and whether the C flag is set (which
     5B3A 003D     
19345                                                                          ; will vary depending on what happens in the above call
19346                                                                          ; to cpl). Incidentally, the planet's average radius
19347                                                                          ; also uses s2_hi, bits 0-3 to be precise, but that
19348                                                                          ; doesn't mean the two sizes affect each other
19349               
19350                                                                          ; We now have the following:
19351                                                                          ;
19352                                                                          ; K(1 0)  = radius of star (2, 3 or 4)
19353                                                                          ;
19354                                                                          ; K3(1 0) = pixel x-coordinate of system
19355                                                                          ;
19356                                                                          ; K4(1 0) = pixel y-coordinate of system
19357                                                                          ;
19358                                                                          ; which we can now pass to the SUN routine to draw a
19359                                                                          ; small "sun" on the Short-range Chart for this system
19360               
19361 5B3C 0200  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Call FLFLLS to reset the LSO block
     5B3E ACE6     
19362 5B40 06A0  32        bl   @jsr                       ;
     5B42 FE28     
19363               
19364 5B44 0200  20        li   rtmp,SUN                   ; JSR SUN           ; Call SUN to plot a sun with radius K at pixel
     5B46 B624     
19365 5B48 06A0  32        bl   @jsr                       ;
     5B4A FE28     
19366                                                                          ; coordinate (K3, K4)
19367               
19368 5B4C 0200  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Call FLFLLS to reset the LSO block
     5B4E ACE6     
19369 5B50 06A0  32        bl   @jsr                       ;
     5B52 FE28     
19370               
19371               TT187:
19372 5B54 0200  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     5B56 4EF2     
19373 5B58 06A0  32        bl   @jsr                       ;
     5B5A FE28     
19374                                                                          ; to twist the three 16-bit seeds in QQ15
19375               
19376 5B5C B347  18        ab   rone,ra                    ; INC XX20          ; Increment the counter
19377               
19378 5B5E 130B  14        jeq  TT111-1                    ; BEQ TT111-1       ; If X = 0 then we have done all 256 systems, so return
19379                                                                          ; from the subroutine (as TT111-1 contains an RTS)
19380               
19381 5B60 0460  28        b    @TT182                     ; JMP TT182         ; Otherwise jump back up to TT182 to process the next
     5B62 5A36     
19382                                                                          ; system
19383               
19384               * ******************************************************************************
19385               *
19386               * Name: TT81
19387               * Type: Subroutine
19388               * Category: Universe
19389               * Summary: Set the selected system's seeds to those of system 0
19390               *
19391               * ------------------------------------------------------------------------------
19392               *
19393               * Copy the three 16-bit seeds for the current galaxy's system 0 (QQ21) into the
19394               * seeds for the selected system (QQ15) - in other words, set the selected
19395               * system's seeds to those of system 0.
19396               *
19397               * ******************************************************************************
19398               
19399               TT81:
19400 5B64 020E  20        li   rx,>05*256                 ; LDX #5            ; Set up a counter in X to copy six bytes (for three
     5B66 0500     
19401                                                                          ; 16-bit numbers)
19402               
19403 5B68 D36E  34        movb @QQ21(rx),ra               ; LDA QQ21,X        ; Copy the X-th byte in QQ21 to the X-th byte in QQ15
     5B6A 0303     
19404 5B6C DB8D  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     5B6E 0078     
19405               
19406 5B70 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19407               
19408 5B72 15F9  14        jgt  TT81+2                     ; BPL TT81+2        ; Loop back up to the LDA instruction if we still have
19409                                                                          ; more bytes to copy
19410               
19411 5B74 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5B76 FE34     
19412               
19413               * ******************************************************************************
19414               *
19415               * Name: TT111
19416               * Type: Subroutine
19417               * Category: Universe
19418               * Summary: Set the current system to the nearest system to a point
19419               *
19420               * ------------------------------------------------------------------------------
19421               *
19422               * Given a set of galactic coordinates in (QQ9, QQ10), find the nearest system
19423               * to this point in the galaxy, and set this as the currently selected system.
19424               *
19425               * ------------------------------------------------------------------------------
19426               *
19427               * Arguments:
19428               *
19429               * QQ9                 The x-coordinate near which we want to find a system
19430               *
19431               * QQ10                The y-coordinate near which we want to find a system
19432               *
19433               * ------------------------------------------------------------------------------
19434               *
19435               * Returns:
19436               *
19437               * QQ8(1 0)            The distance from the current system to the nearest
19438               * system to the original coordinates
19439               *
19440               * QQ9                 The x-coordinate of the nearest system to the original
19441               * coordinates
19442               *
19443               * QQ10                The y-coordinate of the nearest system to the original
19444               * coordinates
19445               *
19446               * QQ15 to QQ15+5      The three 16-bit seeds of the nearest system to the
19447               * original coordinates
19448               *
19449               * ------------------------------------------------------------------------------
19450               *
19451               * Other entry points:
19452               *
19453               * TT111-1             Contains an RTS
19454               *
19455               * ******************************************************************************
19456               
19457               TT111:
19458 5B78 0200  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     5B7A 5B64     
19459 5B7C 06A0  32        bl   @jsr                       ;
     5B7E FE28     
19460                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
19461               
19462                                                                          ; We now loop through every single system in the galaxy
19463                                                                          ; and check the distance from (QQ9, QQ10). We get the
19464                                                                          ; galactic coordinates of each system from the system's
19465                                                                          ; seeds, like this:
19466                                                                          ;
19467                                                                          ; x = s1_hi (which is stored in QQ15+3)
19468                                                                          ; y = s0_hi (which is stored in QQ15+1)
19469                                                                          ;
19470                                                                          ; so the following loops through each system in the
19471                                                                          ; galaxy in turn and calculates the distance between
19472                                                                          ; (QQ9, QQ10) and (s1_hi, s0_hi) to find the closest one
19473               
19474 5B80 020F  20        li   ry,>7f*256                 ; LDY #127          ; Set Y = T = 127 to hold the shortest distance we've
     5B82 7F00     
19475 5B84 D80F  30        movb ry,@T                      ; STY T             ; found so far, which we initially set to half the
     5B86 00D1     
19476                                                                          ; distance across the galaxy, or 127, as our coordinate
19477                                                                          ; system ranges from (0,0) to (255, 255)
19478               
19479 5B88 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = U = 0 to act as a counter for each system in
     5B8A 0000     
19480 5B8C D80D  30        movb ra,@U                      ; STA U             ; the current galaxy, which we start at system 0 and
     5B8E 008F     
19481                                                                          ; loop through to 255, the last system
19482               
19483               TT130:
19484 5B90 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ9, the horizontal distance between
     5B92 007B     
19485                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ9, QQ10)
     **** ****     > SEC
0001 5B94 0A18  18        sla  rmone,1
                   < elite.a99
19486                      .sbc @QQ9,ra                    ; SBC QQ9
     **** ****     > SBC
0001 5B96 1801  14        joc  !
0002 5B98 7347  18        sb   rone,ra
0003               !:
0004 5B9A 7360  30        sb   @QQ9,ra
     5B9C 0F31     
                   < elite.a99
19487               
19488 5B9E 1807  14        joc  TT132                      ; BCS TT132         ; If a borrow didn't occur, i.e. s1_hi >= QQ9, then the
19489                                                                          ; result is positive, so jump to TT132 and skip the
19490                                                                          ; following two instructions
19491               
19492                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5BA0 0200  20        li   rtmp,(>FF*256)
     5BA2 FF00     
0002 5BA4 2B40  18        xor  rtmp,ra
                   < elite.a99
19493                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s1_hi - QQ9|)
     **** ****     > ADI
0001 5BA6 1701  14        jnc  !
0002 5BA8 B347  18        ab   rone,ra
0003               !:
0004 5BAA 022D  22        ai   ra,(>01*256)
     5BAC 0100     
                   < elite.a99
19494               
19495               TT132:
19496 5BAE 091D  18        srl  ra,1                       ; LSR A             ; Set S = A / 2
19497 5BB0 D80D  30        movb ra,@S                      ; STA S             ; = |s1_hi - QQ9| / 2
     5BB2 0092     
19498               
19499 5BB4 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ10, the vertical distance between
     5BB6 0079     
19500                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ9, QQ10)
     **** ****     > SEC
0001 5BB8 0A18  18        sla  rmone,1
                   < elite.a99
19501                      .sbc @QQ10,ra                   ; SBC QQ10
     **** ****     > SBC
0001 5BBA 1801  14        joc  !
0002 5BBC 7347  18        sb   rone,ra
0003               !:
0004 5BBE 7360  30        sb   @QQ10,ra
     5BC0 0F32     
                   < elite.a99
19502               
19503 5BC2 1807  14        joc  TT134                      ; BCS TT134         ; If a borrow didn't occur, i.e. s0_hi >= QQ10, then the
19504                                                                          ; result is positive, so jump to TT134 and skip the
19505                                                                          ; following two instructions
19506               
19507                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5BC4 0200  20        li   rtmp,(>FF*256)
     5BC6 FF00     
0002 5BC8 2B40  18        xor  rtmp,ra
                   < elite.a99
19508                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s0_hi - QQ10|)
     **** ****     > ADI
0001 5BCA 1701  14        jnc  !
0002 5BCC B347  18        ab   rone,ra
0003               !:
0004 5BCE 022D  22        ai   ra,(>01*256)
     5BD0 0100     
                   < elite.a99
19509               
19510               TT134:
19511 5BD2 091D  18        srl  ra,1                       ; LSR A             ; Set A = S + A / 2
19512                      .clc                            ; CLC               ; = |s1_hi - QQ9| / 2 + |s0_hi - QQ10| / 2
     **** ****     > CLC
0001 5BD4 0A16  18        sla  rzero,1
                   < elite.a99
19513                      .adc @S,ra                      ; ADC S             ;
     **** ****     > ADC
0001 5BD6 1701  14        jnc  !
0002 5BD8 B347  18        ab   rone,ra
0003               !:
0004 5BDA B360  30        ab   @S,ra
     5BDC 0092     
                   < elite.a99
19514                                                                          ; So A now contains the sum of the horizontal and
19515                                                                          ; vertical distances, both divided by 2 so the result
19516                                                                          ; fits into one byte, and although this doesn't contain
19517                                                                          ; the actual distance between the systems, it's a good
19518                                                                          ; enough approximation to use for comparing distances
19519               
19520 5BDE 9360  30        cb   @T,ra                      ; CMP T             ; If A >= T, then this system's distance is bigger than
     5BE0 00D1     
19521 5BE2 180A  14        joc  TT135                      ; BCS TT135         ; our "minimum distance so far" stored in T, so it's no
19522                                                                          ; closer than the systems we have already found, so
19523                                                                          ; skip to TT135 to move on to the next system
19524               
19525 5BE4 D80D  30        movb ra,@T                      ; STA T             ; This system is the closest to (QQ9, QQ10) so far, so
     5BE6 00D1     
19526                                                                          ; update T with the new "distance" approximation
19527               
19528 5BE8 020E  20        li   rx,>05*256                 ; LDX #5            ; As this system is the closest we have found yet, we
     5BEA 0500     
19529                                                                          ; want to store the system's seeds in case it ends up
19530                                                                          ; being the closest of all, so we set up a counter in X
19531                                                                          ; to copy six bytes (for three 16-bit numbers)
19532               
19533               TT136:
19534 5BEC D36E  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy the X-th byte in QQ15 to the X-th byte in QQ19,
     5BEE 0078     
19535 5BF0 DB8D  38        movb ra,@QQ19(rx)               ; STA QQ19,X        ; where QQ15 contains the seeds for the system we just
     5BF2 007F     
19536                                                                          ; found to be the closest so far, and QQ19 is temporary
19537                                                                          ; storage
19538               
19539 5BF4 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19540               
19541 5BF6 15FA  14        jgt  TT136                      ; BPL TT136         ; Loop back to TT136 if we still have more bytes to
19542                                                                          ; copy
19543               
19544               TT135:
19545 5BF8 0200  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     5BFA 4EF2     
19546 5BFC 06A0  32        bl   @jsr                       ;
     5BFE FE28     
19547                                                                          ; to twist the three 16-bit seeds in QQ15
19548               
19549 5C00 B347  18        ab   rone,ra                    ; INC U             ; Increment the system counter in U
19550               
19551 5C02 16C6  14        jne  TT130                      ; BNE TT130         ; If U > 0 then we haven't done all 256 systems yet, so
19552                                                                          ; loop back up to TT130
19553               
19554                                                                          ; We have now finished checking all the systems in the
19555                                                                          ; galaxy, and the seeds for the closest system are in
19556                                                                          ; QQ19, so now we want to copy these seeds to QQ15,
19557                                                                          ; to set the selected system to this closest system
19558               
19559 5C04 020E  20        li   rx,>05*256                 ; LDX #5            ; So we set up a counter in X to copy six bytes (for
     5C06 0500     
19560                                                                          ; three 16-bit numbers)
19561               
19562               TT137:
19563 5C08 D36E  34        movb @QQ19(rx),ra               ; LDA QQ19,X        ; Copy the X-th byte in QQ19 to the X-th byte in QQ15
     5C0A 007F     
19564 5C0C DB8D  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     5C0E 0078     
19565               
19566 5C10 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19567               
19568 5C12 15FA  14        jgt  TT137                      ; BPL TT137         ; Loop back to TT137 if we still have more bytes to
19569                                                                          ; copy
19570               
19571 5C14 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; The y-coordinate of the system described by the seeds
     5C16 0079     
19572 5C18 D80D  30        movb ra,@QQ10                   ; STA QQ10          ; in QQ15 is in QQ15+1 (s0_hi), so we copy this to QQ10
     5C1A 0F32     
19573                                                                          ; as this is where we store the selected system's
19574                                                                          ; y-coordinate
19575               
19576 5C1C D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; The x-coordinate of the system described by the seeds
     5C1E 007B     
19577 5C20 D80D  30        movb ra,@QQ9                    ; STA QQ9           ; in QQ15 is in QQ15+3 (s1_hi), so we copy this to QQ9
     5C22 0F31     
19578                                                                          ; as this is where we store the selected system's
19579                                                                          ; x-coordinate
19580               
19581                                                                          ; We have now found the closest system to (QQ9, QQ10)
19582                                                                          ; and have set it as the selected system, so now we
19583                                                                          ; need to work out the distance between the selected
19584                                                                          ; system and the current system
19585               
19586                      .sec                            ; SEC               ; Set A = QQ9 - QQ0, the horizontal distance between
     **** ****     > SEC
0001 5C24 0A18  18        sla  rmone,1
                   < elite.a99
19587                      .sbc @QQ0,ra                    ; SBC QQ0           ; the selected system's x-coordinate (QQ9) and the
     **** ****     > SBC
0001 5C26 1801  14        joc  !
0002 5C28 7347  18        sb   rone,ra
0003               !:
0004 5C2A 7360  30        sb   @QQ0,ra
     5C2C 0301     
                   < elite.a99
19588                                                                          ; current system's x-coordinate (QQ0)
19589               
19590 5C2E 1807  14        joc  TT139                      ; BCS TT139         ; If a borrow didn't occur, i.e. QQ9 >= QQ0, then the
19591                                                                          ; result is positive, so jump to TT139 and skip the
19592                                                                          ; following two instructions
19593               
19594                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5C30 0200  20        li   rtmp,(>FF*256)
     5C32 FF00     
0002 5C34 2B40  18        xor  rtmp,ra
                   < elite.a99
19595                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |QQ9 - QQ0|)
     **** ****     > ADI
0001 5C36 1701  14        jnc  !
0002 5C38 B347  18        ab   rone,ra
0003               !:
0004 5C3A 022D  22        ai   ra,(>01*256)
     5C3C 0100     
                   < elite.a99
19596               
19597                                                                          ; A now contains the difference between the two
19598                                                                          ; systems' x-coordinates, with the sign removed. We
19599                                                                          ; will refer to this as the x-delta ("delta" means
19600                                                                          ; change or difference in maths)
19601               
19602               TT139:
19603 5C3E 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A
     5C40 436E     
19604 5C42 06A0  32        bl   @jsr                       ;
     5C44 FE28     
19605                                                                          ; = |QQ9 - QQ0| ^ 2
19606                                                                          ; = x_delta ^ 2
19607               
19608 5C46 D80D  30        movb ra,@K+1                    ; STA K+1           ; Store (A P) in K(1 0)
     5C48 003E     
19609 5C4A D360  30        movb @P,ra                      ; LDA P
     5C4C 001B     
19610 5C4E D80D  30        movb ra,@K                      ; STA K
     5C50 003D     
19611               
19612 5C52 D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Set A = QQ10 - QQ1, the vertical distance between the
     5C54 0F32     
19613                      .sec                            ; SEC               ; selected system's y-coordinate (QQ10) and the current
     **** ****     > SEC
0001 5C56 0A18  18        sla  rmone,1
                   < elite.a99
19614                      .sbc @QQ1,ra                    ; SBC QQ1           ; system's y-coordinate (QQ1)
     **** ****     > SBC
0001 5C58 1801  14        joc  !
0002 5C5A 7347  18        sb   rone,ra
0003               !:
0004 5C5C 7360  30        sb   @QQ1,ra
     5C5E 0302     
                   < elite.a99
19615               
19616 5C60 1807  14        joc  TT141                      ; BCS TT141         ; If a borrow didn't occur, i.e. QQ10 >= QQ1, then the
19617                                                                          ; result is positive, so jump to TT141 and skip the
19618                                                                          ; following two instructions
19619               
19620                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5C62 0200  20        li   rtmp,(>FF*256)
     5C64 FF00     
0002 5C66 2B40  18        xor  rtmp,ra
                   < elite.a99
19621                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |QQ10 - QQ1|)
     **** ****     > ADI
0001 5C68 1701  14        jnc  !
0002 5C6A B347  18        ab   rone,ra
0003               !:
0004 5C6C 022D  22        ai   ra,(>01*256)
     5C6E 0100     
                   < elite.a99
19622               
19623               TT141:
19624 5C70 091D  18        srl  ra,1                       ; LSR A             ; Set A = A / 2
19625               
19626                                                                          ; A now contains the difference between the two
19627                                                                          ; systems' y-coordinates, with the sign removed, and
19628                                                                          ; halved. We halve the value because the galaxy in
19629                                                                          ; in Elite is rectangular rather than square, and is
19630                                                                          ; twice as wide (x-axis) as it is high (y-axis), so to
19631                                                                          ; get a distance that matches the shape of the
19632                                                                          ; long-range galaxy chart, we need to halve the
19633                                                                          ; distance between the vertical y-coordinates. We will
19634                                                                          ; refer to this as the y-delta
19635               
19636 5C72 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A
     5C74 436E     
19637 5C76 06A0  32        bl   @jsr                       ;
     5C78 FE28     
19638                                                                          ; = (|QQ10 - QQ1| / 2) ^ 2
19639                                                                          ; = y_delta ^ 2
19640               
19641                                                                          ; By this point we have the following results:
19642                                                                          ;
19643                                                                          ; K(1 0) = x_delta ^ 2
19644                                                                          ; (A P) = y_delta ^ 2
19645                                                                          ;
19646                                                                          ; so to find the distance between the two points, we
19647                                                                          ; can use Pythagoras - so first we need to add the two
19648                                                                          ; results together, and then take the square root
19649               
19650                      .pha                            ; PHA               ; Store the high byte of the y-axis value on the stack,
     **** ****     > PHA
0001 5C7A D68D  30        movb ra,*rsp
0002 5C7C 060A  14        dec  rsp
                   < elite.a99
19651                                                                          ; so we can use A for another purpose
19652               
19653 5C7E D360  30        movb @P,ra                      ; LDA P             ; Set Q = P + K, which adds the low bytes of the two
     5C80 001B     
19654                      .clc                            ; CLC               ; calculated values
     **** ****     > CLC
0001 5C82 0A16  18        sla  rzero,1
                   < elite.a99
19655                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 5C84 1701  14        jnc  !
0002 5C86 B347  18        ab   rone,ra
0003               !:
0004 5C88 B360  30        ab   @K,ra
     5C8A 003D     
                   < elite.a99
19656 5C8C D80D  30        movb ra,@Q                      ; STA Q
     5C8E 0090     
19657               
19658                      .pla                            ; PLA               ; Restore the high byte of the y-axis value from the
     **** ****     > PLA
0001 5C90 058A  14        inc  rsp
0002 5C92 D35A  26        movb *rsp,ra
                   < elite.a99
19659                                                                          ; stack into A again
19660               
19661                      .adc @K+1,ra                    ; ADC K+1           ; Set R = A + K+1, which adds the high bytes of the two
     **** ****     > ADC
0001 5C94 1701  14        jnc  !
0002 5C96 B347  18        ab   rone,ra
0003               !:
0004 5C98 B360  30        ab   @K+1,ra
     5C9A 003E     
                   < elite.a99
19662 5C9C D80D  30        movb ra,@R                      ; STA R             ; calculated values, so we now have:
     5C9E 0091     
19663                                                                          ;
19664                                                                          ; (R Q) = K(1 0) + (A P)
19665                                                                          ; = (x_delta ^ 2) + (y_delta ^ 2)
19666               
19667 5CA0 0200  20        li   rtmp,LL5                   ; JSR LL5           ; Set Q = SQRT(R Q), so Q now contains the distance
     5CA2 D376     
19668 5CA4 06A0  32        bl   @jsr                       ;
     5CA6 FE28     
19669                                                                          ; between the two systems, in terms of coordinates
19670               
19671                                                                          ; We now store the distance to the selected system * 4
19672                                                                          ; in the two-byte location QQ8, by taking (0 Q) and
19673                                                                          ; shifting it left twice, storing it in QQ8(1 0)
19674               
19675 5CA8 D360  30        movb @Q,ra                      ; LDA Q             ; First we shift the low byte left by setting
     5CAA 0090     
19676                      .asla                           ; ASL A             ; A = Q * 2, with bit 7 of A going into the C flag
     **** ****     > ASLA
0001 5CAC 024D  22        andi ra,>ff00
     5CAE FF00     
0002 5CB0 0A1D  18        sla  ra,1
                   < elite.a99
19677               
19678 5CB2 020E  20        li   rx,>00*256                 ; LDX #0            ; Now we set the high byte in QQ8+1 to 0 and rotate
     5CB4 0000     
19679 5CB6 D80E  30        movb rx,@QQ8+1                  ; STX QQ8+1         ; the C flag into bit 0 of QQ8+1
     5CB8 0F30     
19680 5CBA 0204  20        li   rarg1,QQ8+1                ; ROL QQ8+1
     5CBC 0F30     
19681 5CBE 06A0  32        bl   @rol                       ;
     5CC0 FE4E     
19682               
19683                      .asla                           ; ASL A             ; And then we repeat the shift left of (QQ8+1 A)
     **** ****     > ASLA
0001 5CC2 024D  22        andi ra,>ff00
     5CC4 FF00     
0002 5CC6 0A1D  18        sla  ra,1
                   < elite.a99
19684 5CC8 0204  20        li   rarg1,QQ8+1                ; ROL QQ8+1
     5CCA 0F30     
19685 5CCC 06A0  32        bl   @rol                       ;
     5CCE FE4E     
19686               
19687 5CD0 D80D  30        movb ra,@QQ8                    ; STA QQ8           ; And store A in the low byte, QQ8, so QQ8(1 0) now
     5CD2 0F2F     
19688                                                                          ; contains Q * 4. Given that the width of the galaxy is
19689                                                                          ; 256 in coordinate terms, the width of the galaxy
19690                                                                          ; would be 1024 in the units we store in QQ8
19691               
19692 5CD4 0460  28        b    @TT24                      ; JMP TT24          ; Call TT24 to calculate system data from the seeds in
     5CD6 5222     
19693                                                                          ; QQ15 and store them in the relevant locations, so our
19694                                                                          ; new selected system is fully set up, and return from
19695                                                                          ; the subroutine using a tail call
19696               
19697               * ******************************************************************************
19698               *
19699               * Name: hy6
19700               * Type: Subroutine
19701               * Category: Flight
19702               * Summary: Print a message to say there is no hyperspacing allowed inside the
19703               * station
19704               *
19705               * ------------------------------------------------------------------------------
19706               *
19707               * Print "Docked" at the bottom of the screen to indicate we can't hyperspace
19708               * when docked.
19709               *
19710               * ******************************************************************************
19711               
19712               hy6_:
19713 5CD8 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     5CDA 4CE2     
19714 5CDC 06A0  32        bl   @jsr                       ;
     5CDE FE28     
19715                                                                          ; and move the text cursor to column 1 on row 21, i.e.
19716                                                                          ; the start of the top row of the three bottom rows
19717               
19718 5CE0 020D  20        li   ra,>0f*256                 ; LDA #15           ; Move the text cursor to column 15 (the middle of the
     5CE2 0F00     
19719 5CE4 D80D  30        movb ra,@XC                     ; STA XC            ; screen), setting A to 15 at the same time for the
     5CE6 002C     
19720                                                                          ; following call to TT27
19721               
19722 5CE8 0460  28        b    @TT27                      ; JMP TT27          ; Print recursive token 129 ("{sentence case}DOCKED")
     5CEA A6E8     
19723                                                                          ; and return from the subroutine using a tail call
19724               
19725               * ******************************************************************************
19726               *
19727               * Name: hyp
19728               * Type: Subroutine
19729               * Category: Flight
19730               * Summary: Start the hyperspace process
19731               *
19732               * ------------------------------------------------------------------------------
19733               *
19734               * Called when "H" or CTRL-H is pressed during flight. Checks the following:
19735               *
19736               * * We are in space
19737               *
19738               * * We are not already in a hyperspace countdown
19739               *
19740               * If CTRL is being held down, we jump to Ghy to engage the galactic hyperdrive,
19741               * otherwise we check that:
19742               *
19743               * * The selected system is not the current system
19744               *
19745               * * We have enough fuel to make the jump
19746               *
19747               * and if all the pre-jump checks are passed, we print the destination on-screen
19748               * and start the countdown.
19749               *
19750               * ******************************************************************************
19751               
19752               hyp_:
19753 5CEC D360  30        movb @QQ12,ra                   ; LDA QQ12          ; If we are docked (QQ12 = &FF) then jump to hy6 to
     5CEE 009F     
19754 5CF0 16F3  14        jne  hy6_                       ; BNE hy6           ; print an error message and return from the subroutine
19755                                                                          ; using a tail call (as we can't hyperspace when docked)
19756               
19757 5CF2 D360  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; Fetch QQ22+1, which contains the number that's shown
     5CF4 002F     
19758                                                                          ; on-screen during hyperspace countdown
19759               
19760 5CF6 165B  14        jne  zZ_+1                      ; BNE zZ_+1         ; If it is non-zero, return from the subroutine (as zZ+1
19761                                                                          ; contains an RTS), as there is already a countdown in
19762                                                                          ; progress
19763               
19764 5CF8 0200  20        li   rtmp,CTRL                  ; JSR CTRL          ; Scan the keyboard to see if CTRL is currently pressed
     5CFA CCD0     
19765 5CFC 06A0  32        bl   @jsr                       ;
     5CFE FE28     
19766               
19767 5D00 1136  14        jlt  Ghy                        ; BMI Ghy           ; If it is, then the galactic hyperdrive has been
19768                                                                          ; activated, so jump to Ghy to process it
19769               
19770 5D02 0200  20        li   rtmp,hm_                   ; JSR hm            ; This is a chart view, so call hm to redraw the chart
     5D04 4CC4     
19771 5D06 06A0  32        bl   @jsr                       ;
     5D08 FE28     
19772                                                                          ; crosshairs
19773               
19774 5D0A D360  30        movb @QQ8,ra                    ; LDA QQ8           ; If both bytes of the distance to the selected system
     5D0C 0F2F     
19775 5D0E F360  30        socb @QQ8+1,ra                  ; ORA QQ8+1         ; in QQ8 are zero, return from the subroutine (as zZ+1
     5D10 0F30     
19776 5D12 134D  14        jeq  zZ_+1                      ; BEQ zZ_+1         ; contains an RTS), as the selected system is the
19777                                                                          ; current system
19778               
19779 5D14 020D  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7, row 23 (in the
     5D16 0700     
19780 5D18 D80D  30        movb ra,@XC                     ; STA XC            ; middle of the bottom text row)
     5D1A 002C     
19781 5D1C 020D  20        li   ra,>17*256                 ; LDA #23
     5D1E 1700     
19782 5D20 D80D  30        movb ra,@YC                     ; STA YC
     5D22 002D     
19783               
19784 5D24 020D  20        li   ra,>00*256                 ; LDA #0            ; Set QQ17 = 0 to switch to ALL CAPS
     5D26 0000     
19785 5D28 D80D  30        movb ra,@QQ17                   ; STA QQ17
     5D2A 007E     
19786               
19787 5D2C 020D  20        li   ra,>bd*256                 ; LDA #189          ; Print recursive token 29 ("HYPERSPACE ")
     5D2E BD00     
19788 5D30 0200  20        li   rtmp,TT27                  ; JSR TT27
     5D32 A6E8     
19789 5D34 06A0  32        bl   @jsr                       ;
     5D36 FE28     
19790               
19791 5D38 D360  30        movb @QQ8+1,ra                  ; LDA QQ8+1         ; If the high byte of the distance to the selected
     5D3A 0F30     
19792 5D3C 1668  14        jne  TT147                      ; BNE TT147         ; system in QQ8 is > 0, then it is definitely too far to
19793                                                                          ; jump (as our maximum range is 7.0 light years, or a
19794                                                                          ; value of 70 in QQ8(1 0)), so jump to TT147 to print
19795                                                                          ; "RANGE?" and return from the subroutine using a tail
19796                                                                          ; call
19797               
19798 5D3E D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Fetch our current fuel level from Q114 into A
     5D40 030D     
19799               
19800 5D42 9360  30        cb   @QQ8,ra                    ; CMP QQ8           ; If our fuel reserves are less than the distance to the
     5D44 0F2F     
19801 5D46 1763  14        jnc  TT147                      ; BCC TT147         ; selected system, then we don't have enough fuel for
19802                                                                          ; this jump, so jump to TT147 to print "RANGE?" and
19803                                                                          ; return from the subroutine using a tail call
19804               
19805 5D48 020D  20        li   ra,('-')*256               ; LDA #'-'          ; Print a hyphen
     5D4A 2D00     
19806 5D4C 0200  20        li   rtmp,TT27                  ; JSR TT27
     5D4E A6E8     
19807 5D50 06A0  32        bl   @jsr                       ;
     5D52 FE28     
19808               
19809 5D54 0200  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print the name of the selected system
     5D56 A5C4     
19810 5D58 06A0  32        bl   @jsr                       ;
     5D5A FE28     
19811               
19812                                                                          ; Fall through into wW to start the hyperspace countdown
19813               
19814               * ******************************************************************************
19815               *
19816               * Name: wW
19817               * Type: Subroutine
19818               * Category: Flight
19819               * Summary: Start a hyperspace countdown
19820               *
19821               * ------------------------------------------------------------------------------
19822               *
19823               * Start the hyperspace countdown (for both inter-system hyperspace and the
19824               * galactic hyperdrive).
19825               *
19826               * ******************************************************************************
19827               
19828               wW:
19829 5D5C 020D  20        li   ra,>0f*256                 ; LDA #15           ; The hyperspace countdown starts from 15, so set A to
     5D5E 0F00     
19830                                                                          ; 15 so we can set the two hyperspace counters
19831               
19832 5D60 D80D  30        movb ra,@QQ22+1                 ; STA QQ22+1        ; Set the number in QQ22+1 to A, which is the number
     5D62 002F     
19833                                                                          ; that's shown on-screen during the hyperspace countdown
19834               
19835 5D64 D80D  30        movb ra,@QQ22                   ; STA QQ22          ; Set the number in QQ22 to 15, which is the internal
     5D66 002E     
19836                                                                          ; counter that counts down by 1 each iteration of the
19837                                                                          ; main game loop, and each time it reaches zero, the
19838                                                                          ; on-screen counter gets decremented, and QQ22 gets set
19839                                                                          ; to 5, so setting QQ22 to 15 here makes the first tick
19840                                                                          ; of the hyperspace counter longer than subsequent ticks
19841               
19842 5D68 D38D  18        movb ra,rx                      ; TAX               ; Print the 8-bit number in X (i.e. 15) at text location
19843 5D6A 0460  28        b    @ee3_                      ; JMP ee3           ; (0, 1), padded to 5 digits, so it appears in the top
     5D6C 5DF6     
19844                                                                          ; left corner of the screen, and return from the
19845                                                                          ; subroutine using a tail call
19846               
19847               * .hy5                   \ This instruction and the hy5 label are commented out
19848               * RTS                    \ in the original - they can actually be found at the
19849                                                                          ; end of the jmp routine below, so perhaps this is where
19850                                                                          ; they were originally, but the authors realised they
19851                                                                          ; could save a byte by using a tail call instead of an
19852                                                                          ; RTS?
19853               
19854               * ******************************************************************************
19855               *
19856               * Name: Ghy
19857               * Type: Subroutine
19858               * Category: Flight
19859               * Summary: Perform a galactic hyperspace jump
19860               * Deep dive: Twisting the system seeds
19861               * Galaxy and system seeds
19862               *
19863               * ------------------------------------------------------------------------------
19864               *
19865               * Engage the galactic hyperdrive. Called from the hyp routine above if CTRL-H is
19866               * being pressed.
19867               *
19868               * This routine also updates the galaxy seeds to point to the next galaxy. Using
19869               * a galactic hyperdrive rotates each seed byte to the left, rolling each byte
19870               * left within itself like this:
19871               *
19872               * 01234567 -> 12345670
19873               *
19874               * to get the seeds for the next galaxy. So after 8 galactic jumps, the seeds
19875               * roll round to those of the first galaxy again.
19876               *
19877               * We always arrive in a new galaxy at galactic coordinates (96, 96), and then
19878               * find the nearest system and set that as our location.
19879               *
19880               * ------------------------------------------------------------------------------
19881               *
19882               * Other entry points:
19883               *
19884               * zZ+1                Contains an RTS
19885               *
19886               * ******************************************************************************
19887               
19888               Ghy:
19917               
19918 5D6E D3A0  30        movb @GHYP,rx                   ; LDX GHYP          ; Fetch GHYP, which tells us whether we own a galactic
     5D70 032D     
19919 5D72 133F  14        jeq  hy5_                       ; BEQ hy5           ; hyperdrive, and if it is zero, which means we don't,
19920                                                                          ; return from the subroutine (as hy5 contains an RTS)
19921               
19922 5D74 B387  18        ab   rone,rx                    ; INX               ; We own a galactic hyperdrive, so X is &FF, so this
19923                                                                          ; instruction sets X = 0
19924               
19931               
19932 5D76 D80E  30        movb rx,@GHYP                   ; STX GHYP          ; The galactic hyperdrive is a one-use item, so set GHYP
     5D78 032D     
19933                                                                          ; to 0 so we no longer have one fitted
19934               
19935 5D7A D80E  30        movb rx,@FIST                   ; STX FIST          ; Changing galaxy also clears our criminal record, so
     5D7C 0334     
19936                                                                          ; set our legal status in FIST to 0 ("clean")
19937               
19938 5D7E 0200  20        li   rtmp,wW                    ; JSR wW            ; Call wW to start the hyperspace countdown
     5D80 5D5C     
19939 5D82 06A0  32        bl   @jsr                       ;
     5D84 FE28     
19940               
19941 5D86 020E  20        li   rx,>05*256                 ; LDX #5            ; To move galaxy, we rotate the galaxy's seeds left, so
     5D88 0500     
19942                                                                          ; set a counter in X for the 6 seed bytes
19943               
19944 5D8A B347  18        ab   rone,ra                    ; INC GCNT          ; Increment the current galaxy number in GCNT
19945               
19946 5D8C D360  30        movb @GCNT,ra                   ; LDA GCNT          ; Set GCNT = GCNT mod 8, so we jump from galaxy 7 back
     5D8E 030F     
19947 5D90 024D  22        andi ra,>07*256                 ; AND #7            ; to galaxy 0 (shown in-game as going from galaxy 8 back
     5D92 0700     
19948 5D94 D80D  30        movb ra,@GCNT                   ; STA GCNT          ; to the starting point in galaxy 1)
     5D96 030F     
19949               
19950               G1:
19951 5D98 D36E  34        movb @QQ21(rx),ra               ; LDA QQ21,X        ; Load the X-th seed byte into A
     5D9A 0303     
19952               
19953                      .asla                           ; ASL A             ; Set the C flag to bit 7 of the seed
     **** ****     > ASLA
0001 5D9C 024D  22        andi ra,>ff00
     5D9E FF00     
0002 5DA0 0A1D  18        sla  ra,1
                   < elite.a99
19954               
19955 5DA2 0204  20        li   rarg1,QQ21                 ; ROL QQ21,X        ; Rotate the seed in memory, which will add bit 7 back
     5DA4 0303     
19956 5DA6 06A0  32        bl   @rol                       ;
     5DA8 FE4E     
19957                                                                          ; in as bit 0, so this rolls the seed around on itself
19958               
19959 5DAA 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19960               
19961 5DAC 15F5  14        jgt  G1                         ; BPL G1            ; Loop back for the next seed byte, until we have
19962                                                                          ; rotated them all
19963               
19964               * JSR DORND              \ This instruction is commented out in the original
19965                                                                          ; source, and would set A and X to random numbers, so
19966                                                                          ; perhaps the original plan was to arrive in each new
19967                                                                          ; galaxy in a random place?
19968               
19969               zZ_:
19970 5DAE 020D  20        li   ra,>60*256                 ; LDA #96           ; Set (QQ9, QQ10) to (96, 96), which is where we always
     5DB0 6000     
19971 5DB2 D80D  30        movb ra,@QQ9                    ; STA QQ9           ; arrive in a new galaxy (the selected system will be
     5DB4 0F31     
19972 5DB6 D80D  30        movb ra,@QQ10                   ; STA QQ10          ; set to the nearest actual system later on)
     5DB8 0F32     
19973               
19974 5DBA 0200  20        li   rtmp,TT110                 ; JSR TT110         ; Call TT110 to show the front space view
     5DBC A10A     
19975 5DBE 06A0  32        bl   @jsr                       ;
     5DC0 FE28     
19976               
19978               
19979 5DC2 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Call TT111 to set the current system to the nearest
     5DC4 5B78     
19980 5DC6 06A0  32        bl   @jsr                       ;
     5DC8 FE28     
19981                                                                          ; system to (QQ9, QQ10), and put the seeds of the
19982                                                                          ; nearest system into QQ15 to QQ15+5
19983                                                                          ;
19984                                                                          ; This call fixes a bug in the early cassette versions,
19985                                                                          ; where the galactic hyperdrive will take us to
19986                                                                          ; coordinates (96, 96) in the new galaxy, even if there
19987                                                                          ; isn't actually a system there, so if we jump when we
19988                                                                          ; are low on fuel, it is possible to get stuck in the
19989                                                                          ; middle of nowhere when changing galaxy
19990                                                                          ;
19991                                                                          ; This call sets the current system correctly, so we
19992                                                                          ; always arrive at the nearest system to (96, 96)
19993               
19995               
19997               
19998 5DCA 020E  20        li   rx,>00*256                 ; LDX #0            ; Set the distance to the selected system in QQ8(1 0)
     5DCC 0000     
19999 5DCE D80E  30        movb rx,@QQ8                    ; STX QQ8           ; to 0
     5DD0 0F2F     
20000 5DD2 D80E  30        movb rx,@QQ8+1                  ; STX QQ8+1
     5DD4 0F30     
20001               
20003               
20004 5DD6 020D  20        li   ra,>74*256                 ; LDA #116          ; Print recursive token 116 ("GALACTIC HYPERSPACE")
     5DD8 7400     
20005 5DDA 0200  20        li   rtmp,MESS                  ; JSR MESS          ; as an in-flight message
     5DDC CF0E     
20006 5DDE 06A0  32        bl   @jsr                       ;
     5DE0 FE28     
20007               
20008                                                                          ; Fall through into jmp to set the system to the
20009                                                                          ; current system and return from the subroutine there
20010               
20011               * ******************************************************************************
20012               *
20013               * Name: jmp
20014               * Type: Subroutine
20015               * Category: Universe
20016               * Summary: Set the current system to the selected system
20017               *
20018               * ------------------------------------------------------------------------------
20019               *
20020               * Returns:
20021               *
20022               * (QQ0, QQ1)          The galactic coordinates of the new system
20023               *
20024               * ------------------------------------------------------------------------------
20025               *
20026               * Other entry points:
20027               *
20028               * hy5                 Contains an RTS
20029               *
20030               * ******************************************************************************
20031               
20032               jmp_:
20033 5DE2 D360  30        movb @QQ9,ra                    ; LDA QQ9           ; Set the current system's galactic x-coordinate to the
     5DE4 0F31     
20034 5DE6 D80D  30        movb ra,@QQ0                    ; STA QQ0           ; x-coordinate of the selected system
     5DE8 0301     
20035               
20036 5DEA D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Set the current system's galactic y-coordinate to the
     5DEC 0F32     
20037 5DEE D80D  30        movb ra,@QQ1                    ; STA QQ1           ; y-coordinate of the selected system
     5DF0 0302     
20038               
20039               hy5_:
20040 5DF2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5DF4 FE34     
20041               
20042               * ******************************************************************************
20043               *
20044               * Name: ee3
20045               * Type: Subroutine
20046               * Category: Flight
20047               * Summary: Print the hyperspace countdown in the top-left of the screen
20048               *
20049               * ------------------------------------------------------------------------------
20050               *
20051               * Print the 8-bit number in X at text location (0, 1). Print the number to
20052               * 5 digits, left-padding with spaces for numbers with fewer than 3 digits (so
20053               * numbers < 10000 are right-aligned), with no decimal point.
20054               *
20055               * ------------------------------------------------------------------------------
20056               *
20057               * Arguments:
20058               *
20059               * X                   The number to print
20060               *
20061               * ******************************************************************************
20062               
20063               ee3_:
20064 5DF6 020F  20        li   ry,>01*256                 ; LDY #1            ; Move the text cursor to row 1
     5DF8 0100     
20065 5DFA D80F  30        movb ry,@YC                     ; STY YC
     5DFC 002D     
20066               
20067 5DFE 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to 0 for the high byte in pr6
20068               
20069 5E00 D80F  30        movb ry,@XC                     ; STY XC            ; Move the text cursor to column 0
     5E02 002C     
20070               
20071                                                                          ; Fall through into pr6 to print X to 5 digits, as the
20072                                                                          ; high byte in Y is 0
20073               
20074               * ******************************************************************************
20075               *
20076               * Name: pr6
20077               * Type: Subroutine
20078               * Category: Text
20079               * Summary: Print 16-bit number, left-padded to 5 digits, no point
20080               *
20081               * ------------------------------------------------------------------------------
20082               *
20083               * Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
20084               * numbers with fewer than 3 digits (so numbers < 10000 are right-aligned),
20085               * with no decimal point.
20086               *
20087               * ------------------------------------------------------------------------------
20088               *
20089               * Arguments:
20090               *
20091               * X                   The low byte of the number to print
20092               *
20093               * Y                   The high byte of the number to print
20094               *
20095               * ******************************************************************************
20096               
20097               pr6_:
20098                      .clc                            ; CLC               ; Do not display a decimal point when printing
     **** ****     > CLC
0001 5E04 0A16  18        sla  rzero,1
                   < elite.a99
20099               
20100                                                                          ; Fall through into pr5 to print X to 5 digits
20101               
20102               * ******************************************************************************
20103               *
20104               * Name: pr5
20105               * Type: Subroutine
20106               * Category: Text
20107               * Summary: Print a 16-bit number, left-padded to 5 digits, and optional point
20108               *
20109               * ------------------------------------------------------------------------------
20110               *
20111               * Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
20112               * numbers with fewer than 3 digits (so numbers < 10000 are right-aligned).
20113               * Optionally include a decimal point.
20114               *
20115               * ------------------------------------------------------------------------------
20116               *
20117               * Arguments:
20118               *
20119               * X                   The low byte of the number to print
20120               *
20121               * Y                   The high byte of the number to print
20122               *
20123               * C flag              If set, include a decimal point
20124               *
20125               * ******************************************************************************
20126               
20127               pr5_:
20128 5E06 020D  20        li   ra,>05*256                 ; LDA #5            ; Set the number of digits to print to 5
     5E08 0500     
20129               
20130 5E0A 0460  28        b    @TT11                      ; JMP TT11          ; Call TT11 to print (Y X) to 5 digits and return from
     5E0C 3004     
20131                                                                          ; the subroutine using a tail call
20132               
20133               * ******************************************************************************
20134               *
20135               * Name: TT147
20136               * Type: Subroutine
20137               * Category: Flight
20138               * Summary: Print an error when a system is out of hyperspace range
20139               *
20140               * ------------------------------------------------------------------------------
20141               *
20142               * Print "RANGE?" for when the hyperspace distance is too far
20143               *
20144               * ******************************************************************************
20145               
20146               TT147:
20147 5E0E 020D  20        li   ra,>ca*256                 ; LDA #202          ; Load A with token 42 ("RANGE") and fall through into
     5E10 CA00     
20148                                                                          ; prq to print it, followed by a question mark
20149               
20150               * ******************************************************************************
20151               *
20152               * Name: prq
20153               * Type: Subroutine
20154               * Category: Text
20155               * Summary: Print a text token followed by a question mark
20156               *
20157               * ------------------------------------------------------------------------------
20158               *
20159               * Arguments:
20160               *
20161               * A                   The text token to be printed
20162               *
20163               * ------------------------------------------------------------------------------
20164               *
20165               * Other entry points:
20166               *
20167               * prq+3               Print a question mark
20168               *
20169               * ******************************************************************************
20170               
20171               prq_:
20172 5E12 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     5E14 A6E8     
20173 5E16 06A0  32        bl   @jsr                       ;
     5E18 FE28     
20174               
20175 5E1A 020D  20        li   ra,('?')*256               ; LDA #'?'          ; Print a question mark and return from the
     5E1C 3F00     
20176 5E1E 0460  28        b    @TT27                      ; JMP TT27          ; subroutine using a tail call
     5E20 A6E8     
20177               
20178               * ******************************************************************************
20179               *
20180               * Name: TT151
20181               * Type: Subroutine
20182               * Category: Market
20183               * Summary: Print the name, price and availability of a market item
20184               * Deep dive: Market item prices and availability
20185               * Galaxy and system seeds
20186               *
20187               * ------------------------------------------------------------------------------
20188               *
20189               * Arguments:
20190               *
20191               * A                   The number of the market item to print, 0-16 (see QQ23
20192               * for details of item numbers)
20193               *
20194               * ------------------------------------------------------------------------------
20195               *
20196               * Returns:
20197               *
20198               * QQ19+1              Byte #1 from the market prices table for this item
20199               *
20200               * QQ24                The item's price / 4
20201               *
20202               * QQ25                The item's availability
20203               *
20204               * ******************************************************************************
20205               
20206               TT151:
20207                      .pha                            ; PHA               ; Store the item number on the stack and in QQ19+4
     **** ****     > PHA
0001 5E22 D68D  30        movb ra,*rsp
0002 5E24 060A  14        dec  rsp
                   < elite.a99
20208 5E26 D80D  30        movb ra,@QQ19+4                 ; STA QQ19+4
     5E28 0083     
20209               
20210                      .asla                           ; ASL A             ; Store the item number * 4 in QQ19, so this will act as
     **** ****     > ASLA
0001 5E2A 024D  22        andi ra,>ff00
     5E2C FF00     
0002 5E2E 0A1D  18        sla  ra,1
                   < elite.a99
20211                      .asla                           ; ASL A             ; an index into the market prices table at QQ23 for this
     **** ****     > ASLA
0001 5E30 024D  22        andi ra,>ff00
     5E32 FF00     
0002 5E34 0A1D  18        sla  ra,1
                   < elite.a99
20212 5E36 D80D  30        movb ra,@QQ19                   ; STA QQ19          ; item (as there are four bytes per item in the table)
     5E38 007F     
20213               
20214 5E3A 020D  20        li   ra,>01*256                 ; LDA #1            ; Move the text cursor to column 1, for the item's name
     5E3C 0100     
20215 5E3E D80D  30        movb ra,@XC                     ; STA XC
     5E40 002C     
20216               
20217                      .pla                            ; PLA               ; Restore the item number
     **** ****     > PLA
0001 5E42 058A  14        inc  rsp
0002 5E44 D35A  26        movb *rsp,ra
                   < elite.a99
20218               
20219                      .adi (>d0*256)                  ; ADC #208          ; Print recursive token 48 + A, which will be in the
     **** ****     > ADI
0001 5E46 1701  14        jnc  !
0002 5E48 B347  18        ab   rone,ra
0003               !:
0004 5E4A 022D  22        ai   ra,(>D0*256)
     5E4C D000     
                   < elite.a99
20220 5E4E 0200  20        li   rtmp,TT27                  ; JSR TT27          ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     5E50 A6E8     
20221 5E52 06A0  32        bl   @jsr                       ;
     5E54 FE28     
20222                                                                          ; prints the item's name
20223               
20224 5E56 020D  20        li   ra,>0e*256                 ; LDA #14           ; Move the text cursor to column 14, for the price
     5E58 0E00     
20225 5E5A D80D  30        movb ra,@XC                     ; STA XC
     5E5C 002C     
20226               
20227 5E5E D3A0  30        movb @QQ19,rx                   ; LDX QQ19          ; Fetch byte #1 from the market prices table (units and
     5E60 007F     
20228 5E62 D36E  34        movb @QQ23+1(rx),ra             ; LDA QQ23+1,X      ; economic_factor) for this item and store in QQ19+1
     5E64 CFDF     
20229 5E66 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1
     5E68 0080     
20230               
20231 5E6A D360  30        movb @QQ26,ra                   ; LDA QQ26          ; Fetch the random number for this system visit and
     5E6C 0346     
20232                      .and @QQ23+3(rx)                ; AND QQ23+3,X      ; AND with byte #3 from the market prices table (mask)
     **** ****     > AND
0001 5E6E D02E  34        movb @QQ23+3(RX),rtmp
     5E70 CFE1     
0002 5E72 0540  14        inv  rtmp
0003 5E74 5340  18        szcb rtmp,ra
                   < elite.a99
20233                                                                          ; to give:
20234                                                                          ;
20235                                                                          ; A = random AND mask
20236               
20237                      .clc                            ; CLC               ; Add byte #0 from the market prices table (base_price),
     **** ****     > CLC
0001 5E76 0A16  18        sla  rzero,1
                   < elite.a99
20238                      .adc @QQ23(rx),ra               ; ADC QQ23,X        ; so we now have:
     **** ****     > ADC
0001 5E78 1701  14        jnc  !
0002 5E7A B347  18        ab   rone,ra
0003               !:
0004 5E7C B36E  34        ab   @QQ23(RX),ra
     5E7E CFDE     
                   < elite.a99
20239 5E80 D80D  30        movb ra,@QQ24                   ; STA QQ24          ;
     5E82 0F18     
20240                                                                          ; A = base_price + (random AND mask)
20241               
20242 5E84 0200  20        li   rtmp,TT152                 ; JSR TT152         ; Call TT152 to print the item's unit ("t", "kg" or
     5E86 5F0C     
20243 5E88 06A0  32        bl   @jsr                       ;
     5E8A FE28     
20244                                                                          ; "g"), padded to a width of two characters
20245               
20246 5E8C 0200  20        li   rtmp,var_                  ; JSR var           ; Call var to set QQ19+3 = economy * |economic_factor|
     5E8E 5FB6     
20247 5E90 06A0  32        bl   @jsr                       ;
     5E92 FE28     
20248                                                                          ; (and set the availability of alien items to 0)
20249               
20250 5E94 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Fetch the byte #1 that we stored above and jump to
     5E96 0080     
20251 5E98 1108  14        jlt  TT155                      ; BMI TT155         ; TT155 if it is negative (i.e. if the economic_factor
20252                                                                          ; is negative)
20253               
20254 5E9A D360  30        movb @QQ24,ra                   ; LDA QQ24          ; Set A = QQ24 + QQ19+3
     5E9C 0F18     
20255                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ;
     **** ****     > ADC
0001 5E9E 1701  14        jnc  !
0002 5EA0 B347  18        ab   rone,ra
0003               !:
0004 5EA2 B360  30        ab   @QQ19+3,ra
     5EA4 0082     
                   < elite.a99
20256                                                                          ; = base_price + (random AND mask)
20257                                                                          ; + (economy * |economic_factor|)
20258                                                                          ;
20259                                                                          ; which is the result we want, as the economic_factor
20260                                                                          ; is positive
20261               
20262 5EA6 0460  28        b    @TT156                     ; JMP TT156         ; Jump to TT156 to multiply the result by 4
     5EA8 5EB8     
20263               
20264               TT155:
20265 5EAA D360  30        movb @QQ24,ra                   ; LDA QQ24          ; Set A = QQ24 - QQ19+3
     5EAC 0F18     
20266                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 5EAE 0A18  18        sla  rmone,1
                   < elite.a99
20267                      .sbc @QQ19+3,ra                 ; SBC QQ19+3        ; = base_price + (random AND mask)
     **** ****     > SBC
0001 5EB0 1801  14        joc  !
0002 5EB2 7347  18        sb   rone,ra
0003               !:
0004 5EB4 7360  30        sb   @QQ19+3,ra
     5EB6 0082     
                   < elite.a99
20268                                                                          ; - (economy * |economic_factor|)
20269                                                                          ;
20270                                                                          ; which is the result we want, as economic_factor
20271                                                                          ; is negative
20272               
20273               TT156:
20274 5EB8 D80D  30        movb ra,@QQ24                   ; STA QQ24          ; Store the result in QQ24 and P
     5EBA 0F18     
20275 5EBC D80D  30        movb ra,@P                      ; STA P
     5EBE 001B     
20276               
20277 5EC0 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 and call GC2 to calculate (Y X) = (A P) * 4,
     5EC2 0000     
20278 5EC4 0200  20        li   rtmp,GC2                   ; JSR GC2           ; which is the same as (Y X) = P * 4 because A = 0
     5EC6 A20A     
20279 5EC8 06A0  32        bl   @jsr                       ;
     5ECA FE28     
20280               
20281                      .sec                            ; SEC               ; We now have our final price, * 10, so we can call pr5
     **** ****     > SEC
0001 5ECC 0A18  18        sla  rmone,1
                   < elite.a99
20282 5ECE 0200  20        li   rtmp,pr5_                  ; JSR pr5           ; to print (Y X) to 5 digits, including a decimal
     5ED0 5E06     
20283 5ED2 06A0  32        bl   @jsr                       ;
     5ED4 FE28     
20284                                                                          ; point, as the C flag is set
20285               
20286 5ED6 D3E0  30        movb @QQ19+4,ry                 ; LDY QQ19+4        ; We now move on to availability, so fetch the market
     5ED8 0083     
20287                                                                          ; item number that we stored in QQ19+4 at the start
20288               
20289 5EDA 020D  20        li   ra,>05*256                 ; LDA #5            ; Set A to 5 so we can print the availability to 5
     5EDC 0500     
20290                                                                          ; digits (right-padded with spaces)
20291               
20292 5EDE D3AF  34        movb @AVL(ry),rx                ; LDX AVL,Y         ; Set X to the item's availability, which is given in
     5EE0 0335     
20293                                                                          ; the AVL table
20294               
20295 5EE2 D80E  30        movb rx,@QQ25                   ; STX QQ25          ; Store the availability in QQ25
     5EE4 0F19     
20296               
20297                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 5EE6 0A16  18        sla  rzero,1
                   < elite.a99
20298               
20299 5EE8 1306  14        jeq  TT172                      ; BEQ TT172         ; If none are available, jump to TT172 to print a tab
20300                                                                          ; and a "-"
20301               
20302 5EEA 0200  20        li   rtmp,pr2_+2                ; JSR pr2+2         ; Otherwise print the 8-bit number in X to 5 digits,
     5EEC 2FFE     
20303 5EEE 06A0  32        bl   @jsr                       ;
     5EF0 FE28     
20304                                                                          ; right-aligned with spaces. This works because we set
20305                                                                          ; A to 5 above, and we jump into the pr2 routine just
20306                                                                          ; after the first instruction, which would normally
20307                                                                          ; set the number of digits to 3
20308               
20309 5EF2 0460  28        b    @TT152                     ; JMP TT152         ; Print the unit ("t", "kg" or "g") for the market item,
     5EF4 5F0C     
20310                                                                          ; with a following space if required to make it two
20311                                                                          ; characters long, and return from the subroutine using
20312                                                                          ; a tail call
20313               
20314               TT172:
20315 5EF6 D360  30        movb @XC,ra                     ; LDA XC            ; Move the text cursor in XC to the right by 4 columns,
     5EF8 002C     
20316                      .adi (>04*256)                  ; ADC #4            ; so the cursor is where the last digit would be if we
     **** ****     > ADI
0001 5EFA 1701  14        jnc  !
0002 5EFC B347  18        ab   rone,ra
0003               !:
0004 5EFE 022D  22        ai   ra,(>04*256)
     5F00 0400     
                   < elite.a99
20317 5F02 D80D  30        movb ra,@XC                     ; STA XC            ; were printing a 5-digit availability number
     5F04 002C     
20318               
20319 5F06 020D  20        li   ra,('-')*256               ; LDA #'-'          ; Print a "-" character by jumping to TT162+2, which
     5F08 2D00     
20320 5F0A 160D  14        jne  TT162+2                    ; BNE TT162+2       ; contains JMP TT27 (this BNE is effectively a JMP as A
20321                                                                          ; will never be zero), and return from the subroutine
20322                                                                          ; using a tail call
20323               
20324               * ******************************************************************************
20325               *
20326               * Name: TT152
20327               * Type: Subroutine
20328               * Category: Market
20329               * Summary: Print the unit ("t", "kg" or "g") for a market item
20330               *
20331               * ------------------------------------------------------------------------------
20332               *
20333               * Print the unit ("t", "kg" or "g") for the market item whose byte #1 from the
20334               * market prices table is in QQ19+1, right-padded with spaces to a width of two
20335               * characters (so that's "t ", "kg" or "g ").
20336               *
20337               * ******************************************************************************
20338               
20339               TT152:
20340 5F0C D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Fetch the economic_factor from QQ19+1
     5F0E 0080     
20341               
20342 5F10 024D  22        andi ra,>60*256                 ; AND #96           ; If bits 5 and 6 are both clear, jump to TT160 to
     5F12 6000     
20343 5F14 130B  14        jeq  TT160                      ; BEQ TT160         ; print "t" for tonne, followed by a space, and return
20344                                                                          ; from the subroutine using a tail call
20345               
20346 5F16 028D  22        ci   ra,>20*256                 ; CMP #32           ; If bit 5 is set, jump to TT161 to print "kg" for
     5F18 2000     
20347 5F1A 130F  14        jeq  TT161                      ; BEQ TT161         ; kilograms, and return from the subroutine using a tail
20348                                                                          ; call
20349               
20350 5F1C 0200  20        li   rtmp,TT16a                 ; JSR TT16a         ; Otherwise call TT16a to print "g" for grams, and fall
     5F1E 5F46     
20351 5F20 06A0  32        bl   @jsr                       ;
     5F22 FE28     
20352                                                                          ; through into TT162 to print a space and return from
20353                                                                          ; the subroutine
20354               
20355               * ******************************************************************************
20356               *
20357               * Name: TT162
20358               * Type: Subroutine
20359               * Category: Text
20360               * Summary: Print a space
20361               *
20362               * ------------------------------------------------------------------------------
20363               *
20364               * Other entry points:
20365               *
20366               * TT162+2             Jump to TT27 to print the text token in A
20367               *
20368               * ******************************************************************************
20369               
20370               TT162:
20371 5F24 020D  20        li   ra,(' ')*256               ; LDA #' '          ; Load a space character into A
     5F26 2000     
20372               
20373 5F28 0460  28        b    @TT27                      ; JMP TT27          ; Print the text token in A and return from the
     5F2A A6E8     
20374                                                                          ; subroutine using a tail call
20375               
20376               * ******************************************************************************
20377               *
20378               * Name: TT160
20379               * Type: Subroutine
20380               * Category: Market
20381               * Summary: Print "t" (for tonne) and a space
20382               *
20383               * ******************************************************************************
20384               
20385               TT160:
20386 5F2C 020D  20        li   ra,('t')*256               ; LDA #'t'          ; Load a "t" character into A
     5F2E 7400     
20387               
20388 5F30 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character, using TT216 so that it doesn't
     5F32 31C2     
20389 5F34 06A0  32        bl   @jsr                       ;
     5F36 FE28     
20390                                                                          ; change the character case
20391               
20392 5F38 17F5  14        jnc  TT162                      ; BCC TT162         ; Jump to TT162 to print a space and return from the
20393                                                                          ; subroutine using a tail call (this BCC is effectively
20394                                                                          ; a JMP as the C flag is cleared by TT26)
20395               
20396               * ******************************************************************************
20397               *
20398               * Name: TT161
20399               * Type: Subroutine
20400               * Category: Market
20401               * Summary: Print "kg" (for kilograms)
20402               *
20403               * ******************************************************************************
20404               
20405               TT161:
20406 5F3A 020D  20        li   ra,('k')*256               ; LDA #'k'          ; Load a "k" character into A
     5F3C 6B00     
20407               
20408 5F3E 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character, using TT216 so that it doesn't
     5F40 31C2     
20409 5F42 06A0  32        bl   @jsr                       ;
     5F44 FE28     
20410                                                                          ; change the character case, and fall through into
20411                                                                          ; TT16a to print a "g" character
20412               
20413               * ******************************************************************************
20414               *
20415               * Name: TT16a
20416               * Type: Subroutine
20417               * Category: Market
20418               * Summary: Print "g" (for grams)
20419               *
20420               * ******************************************************************************
20421               
20422               TT16a:
20423 5F46 020D  20        li   ra,('g')*256               ; LDA #'g'          ; Load a "g" character into A
     5F48 6700     
20424               
20425 5F4A 0460  28        b    @TT26                      ; JMP TT26          ; Print the character, using TT216 so that it doesn't
     5F4C 31C2     
20426                                                                          ; change the character case, and return from the
20427                                                                          ; subroutine using a tail call
20428               
20429               * ******************************************************************************
20430               *
20431               * Name: TT163
20432               * Type: Subroutine
20433               * Category: Market
20434               * Summary: Print the headers for the table of market prices
20435               *
20436               * ------------------------------------------------------------------------------
20437               *
20438               * Print the column headers for the prices table in the Buy Cargo and Market
20439               * Price screens.
20440               *
20441               * ******************************************************************************
20442               
20443               TT163:
20444 5F4E 020D  20        li   ra,>11*256                 ; LDA #17           ; Move the text cursor in XC to column 17
     5F50 1100     
20445 5F52 D80D  30        movb ra,@XC                     ; STA XC
     5F54 002C     
20446               
20447 5F56 020D  20        li   ra,>ff*256                 ; LDA #255          ; Print recursive token 95 token ("UNIT  QUANTITY
     5F58 FF00     
20448 5F5A 16E5  14        jne  TT162+2                    ; BNE TT162+2       ; {crlf} PRODUCT   UNIT PRICE FOR SALE{crlf}{lf}") by
20449                                                                          ; jumping to TT162+2, which contains JMP TT27 (this BNE
20450                                                                          ; is effectively a JMP as A will never be zero), and
20451                                                                          ; return from the subroutine using a tail call
20452               
20453               * ******************************************************************************
20454               *
20455               * Name: TT167
20456               * Type: Subroutine
20457               * Category: Market
20458               * Summary: Show the Market Price screen (red key f7)
20459               *
20460               * ******************************************************************************
20461               
20462               TT167:
20463 5F5C 020D  20        li   ra,>10*256                 ; LDA #16           ; Clear the top part of the screen, draw a white border,
     5F5E 1000     
20464 5F60 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 16 (Market
     5F62 4BDE     
20465 5F64 06A0  32        bl   @jsr                       ;
     5F66 FE28     
20466                                                                          ; Price screen)
20467               
20468 5F68 020D  20        li   ra,>05*256                 ; LDA #5            ; Move the text cursor to column 5
     5F6A 0500     
20469 5F6C D80D  30        movb ra,@XC                     ; STA XC
     5F6E 002C     
20470               
20471 5F70 020D  20        li   ra,>a7*256                 ; LDA #167          ; Print recursive token 7 ("{current system name} MARKET
     5F72 A700     
20472 5F74 0200  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; PRICES") and draw a horizontal line at pixel row 19
     5F76 25E4     
20473 5F78 06A0  32        bl   @jsr                       ;
     5F7A FE28     
20474                                                                          ; to box in the title
20475               
20476 5F7C 020D  20        li   ra,>03*256                 ; LDA #3            ; Move the text cursor to row 3
     5F7E 0300     
20477 5F80 D80D  30        movb ra,@YC                     ; STA YC
     5F82 002D     
20478               
20479 5F84 0200  20        li   rtmp,TT163                 ; JSR TT163         ; Print the column headers for the prices table
     5F86 5F4E     
20480 5F88 06A0  32        bl   @jsr                       ;
     5F8A FE28     
20481               
20482 5F8C 020D  20        li   ra,>00*256                 ; LDA #0            ; We're going to loop through all the available market
     5F8E 0000     
20483 5F90 D80D  30        movb ra,@QQ29                   ; STA QQ29          ; items, so we set up a counter in QQ29 to denote the
     5F92 0F1B     
20484                                                                          ; current item and start it at 0
20485               
20486               TT168:
20487 5F94 020E  20        li   rx,>80*256                 ; LDX #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     5F96 8000     
20488 5F98 D80E  30        movb rx,@QQ17                   ; STX QQ17          ; next letter in capitals
     5F9A 007E     
20489               
20490 5F9C 0200  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to print the item name, market price and
     5F9E 5E22     
20491 5FA0 06A0  32        bl   @jsr                       ;
     5FA2 FE28     
20492                                                                          ; availability of the current item, and set QQ24 to the
20493                                                                          ; item's price / 4, QQ25 to the quantity available and
20494                                                                          ; QQ19+1 to byte #1 from the market prices table for
20495                                                                          ; this item
20496               
20497 5FA4 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one row
20498               
20499 5FA6 B347  18        ab   rone,ra                    ; INC QQ29          ; Increment QQ29 to point to the next item
20500               
20501 5FA8 D360  30        movb @QQ29,ra                   ; LDA QQ29          ; If QQ29 >= 17 then jump to TT168 as we have done the
     5FAA 0F1B     
20502 5FAC 028D  22        ci   ra,>11*256                 ; CMP #17           ; last item
     5FAE 1100     
20503 5FB0 17F1  14        jnc  TT168                      ; BCC TT168
20504               
20505 5FB2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5FB4 FE34     
20506               
20507               * ******************************************************************************
20508               *
20509               * Name: var
20510               * Type: Subroutine
20511               * Category: Market
20512               * Summary: Calculate QQ19+3 = economy * |economic_factor|
20513               *
20514               * ------------------------------------------------------------------------------
20515               *
20516               * Set QQ19+3 = economy * |economic_factor|, given byte #1 of the market prices
20517               * table for an item. Also sets the availability of alien items to 0.
20518               *
20519               * This routine forms part of the calculations for market item prices (TT151)
20520               * and availability (GVL).
20521               *
20522               * ------------------------------------------------------------------------------
20523               *
20524               * Arguments:
20525               *
20526               * QQ19+1              Byte #1 of the market prices table for this market item
20527               * (which contains the economic_factor in bits 0-5, and the
20528               * sign of the economic_factor in bit 7)
20529               *
20530               * ******************************************************************************
20531               
20532               var_:
20533 5FB6 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Extract bits 0-5 from QQ19+1 into A, to get the
     5FB8 0080     
20534 5FBA 024D  22        andi ra,>1f*256                 ; AND #31           ; economic_factor without its sign, in other words:
     5FBC 1F00     
20535                                                                          ;
20536                                                                          ; A = |economic_factor|
20537               
20538 5FBE D3E0  30        movb @QQ28,ry                   ; LDY QQ28          ; Set Y to the economy byte of the current system
     5FC0 0F1A     
20539               
20540 5FC2 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Store A in QQ19+2
     5FC4 0081     
20541               
20542                      .clc                            ; CLC               ; Clear the C flag so we can do additions below
     **** ****     > CLC
0001 5FC6 0A16  18        sla  rzero,1
                   < elite.a99
20543               
20544 5FC8 020D  20        li   ra,>00*256                 ; LDA #0            ; Set AVL+16 (availability of alien items) to 0,
     5FCA 0000     
20545 5FCC D80D  30        movb ra,@AVL+16                 ; STA AVL+16        ; setting A to 0 in the process
     5FCE 0345     
20546               
20547               TT153:
20548                                                                          ; We now do the multiplication by doing a series of
20549                                                                          ; additions in a loop, building the result in A. Each
20550                                                                          ; loop adds QQ19+2 (|economic_factor|) to A, and it
20551                                                                          ; loops the number of times given by the economy byte;
20552                                                                          ; in other words, because A starts at 0, this sets:
20553                                                                          ;
20554                                                                          ; A = economy * |economic_factor|
20555 5FD0 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the economy in Y, exiting the loop when it
20556 5FD2 1106  14        jlt  TT154                      ; BMI TT154         ; becomes negative
20557               
20558                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; Add QQ19+2 to A
     **** ****     > ADC
0001 5FD4 1701  14        jnc  !
0002 5FD6 B347  18        ab   rone,ra
0003               !:
0004 5FD8 B360  30        ab   @QQ19+2,ra
     5FDA 0081     
                   < elite.a99
20559               
20560 5FDC 0460  28        b    @TT153                     ; JMP TT153         ; Loop back to TT153 to do another addition
     5FDE 5FD0     
20561               
20562               TT154:
20563 5FE0 D80D  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; Store the result in QQ19+3
     5FE2 0082     
20564               
20565 5FE4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5FE6 FE34     
20566               
20567               * ******************************************************************************
20568               *
20569               * Name: hyp1
20570               * Type: Subroutine
20571               * Category: Universe
20572               * Summary: Process a jump to the system closest to (QQ9, QQ10)
20573               *
20574               * ------------------------------------------------------------------------------
20575               *
20576               * Do a hyperspace jump to the system closest to galactic coordinates
20577               * (QQ9, QQ10), and set up the current system's state to those of the new system.
20578               *
20579               * ------------------------------------------------------------------------------
20580               *
20581               * Returns:
20582               *
20583               * (QQ0, QQ1)          The galactic coordinates of the new system
20584               *
20585               * QQ2 to QQ2+6        The seeds of the new system
20586               *
20587               * EV                  Set to 0
20588               *
20589               * QQ28                The new system's economy
20590               *
20591               * tek                 The new system's tech level
20592               *
20593               * gov                 The new system's government
20594               *
20595               * ------------------------------------------------------------------------------
20596               *
20597               * Other entry points:
20598               *
20599               * hyp1+3              Jump straight to the system at (QQ9, QQ10) without
20600               * first calculating which system is closest. We do this
20601               * if we already know that (QQ9, QQ10) points to a system
20602               *
20603               * ******************************************************************************
20604               
20605               hyp1_:
20606 5FE8 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     5FEA 5B78     
20607 5FEC 06A0  32        bl   @jsr                       ;
     5FEE FE28     
20608                                                                          ; (QQ9, QQ10)
20609               
20610 5FF0 0200  20        li   rtmp,jmp_                  ; JSR jmp           ; Set the current system to the selected system
     5FF2 5DE2     
20611 5FF4 06A0  32        bl   @jsr                       ;
     5FF6 FE28     
20612               
20613 5FF8 020E  20        li   rx,>05*256                 ; LDX #5            ; We now want to copy the seeds for the selected system
     5FFA 0500     
20614                                                                          ; in QQ15 into QQ2, where we store the seeds for the
20615                                                                          ; current system, so set up a counter in X for copying
20616                                                                          ; 6 bytes (for three 16-bit seeds)
20617               
20618               TT112:
20619 5FFC D36E  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy the X-th byte in QQ15 to the X-th byte in QQ2, to
     5FFE 0078     
20620 6000 DB8D  38        movb ra,@QQ2(rx)                ; STA QQ2,X         ; update the selected system to the new one. Note that
     6002 0F22     
20621                                                                          ; this approach has a minor bug associated with it: if
20622                                                                          ; your hyperspace counter hits 0 just as you're docking,
20623                                                                          ; then you will magically appear in the station in your
20624                                                                          ; hyperspace destination, without having to go to the
20625                                                                          ; effort of actually flying there. This bug was fixed in
20626                                                                          ; later versions by saving the destination seeds in a
20627                                                                          ; separate location called safehouse, and using those
20628                                                                          ; instead... but that isn't the case in this version
20629               
20630 6004 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
20631               
20632 6006 15FA  14        jgt  TT112                      ; BPL TT112         ; Loop back to TT112 if we still have more bytes to
20633                                                                          ; copy
20634               
20635 6008 B387  18        ab   rone,rx                    ; INX               ; Set X = 0 (as we ended the above loop with X = &FF)
20636               
20637 600A D80E  30        movb rx,@EV                     ; STX EV            ; Set EV, the extra vessels spawning counter, to 0, as
     600C 0D63     
20638                                                                          ; we are entering a new system with no extra vessels
20639                                                                          ; spawned
20640               
20641 600E D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Set the current system's economy in QQ28 to the
     6010 0F28     
20642 6012 D80D  30        movb ra,@QQ28                   ; STA QQ28          ; selected system's economy from QQ3
     6014 0F1A     
20643               
20644 6016 D360  30        movb @QQ5,ra                    ; LDA QQ5           ; Set the current system's tech level in tek to the
     6018 0F2A     
20645 601A D80D  30        movb ra,@tek_                   ; STA tek           ; selected system's economy from QQ5
     601C 0F1D     
20646               
20647 601E D360  30        movb @QQ4,ra                    ; LDA QQ4           ; Set the current system's government in gov to the
     6020 0F29     
20648 6022 D80D  30        movb ra,@gov_                   ; STA gov           ; selected system's government from QQ4
     6024 0F1C     
20649               
20650 6026 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     6028 FE34     
20651               
20652               * ******************************************************************************
20653               *
20654               * Name: GVL
20655               * Type: Subroutine
20656               * Category: Universe
20657               * Summary: Calculate the availability of market items
20658               * Deep dive: Market item prices and availability
20659               * Galaxy and system seeds
20660               *
20661               * ------------------------------------------------------------------------------
20662               *
20663               * Calculate the availability for each market item and store it in AVL. This is
20664               * called on arrival in a new system.
20665               *
20666               * ------------------------------------------------------------------------------
20667               *
20668               * Other entry points:
20669               *
20670               * hyR                 Contains an RTS
20671               *
20672               * ******************************************************************************
20673               
20674               GVL:
20675 602A 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     602C C120     
20676 602E 06A0  32        bl   @jsr                       ;
     6030 FE28     
20677               
20678 6032 D80D  30        movb ra,@QQ26                   ; STA QQ26          ; Set QQ26 to the random byte that's used in the market
     6034 0346     
20679                                                                          ; calculations
20680               
20681 6036 020E  20        li   rx,>00*256                 ; LDX #0            ; We are now going to loop through the market item
     6038 0000     
20682 603A D80E  30        movb rx,@XX4                    ; STX XX4           ; availability table in AVL, so set a counter in XX4
     603C 00A7     
20683                                                                          ; (and X) for the market item number, starting with 0
20684               
20685               hy9_:
20686 603E D36E  34        movb @QQ23+1(rx),ra             ; LDA QQ23+1,X      ; Fetch byte #1 from the market prices table (units and
     6040 CFDF     
20687 6042 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; economic_factor) for item number X and store it in
     6044 0080     
20688                                                                          ; QQ19+1
20689               
20690 6046 0200  20        li   rtmp,var_                  ; JSR var           ; Call var to set QQ19+3 = economy * |economic_factor|
     6048 5FB6     
20691 604A 06A0  32        bl   @jsr                       ;
     604C FE28     
20692                                                                          ; (and set the availability of alien items to 0)
20693               
20694 604E D36E  34        movb @QQ23+3(rx),ra             ; LDA QQ23+3,X      ; Fetch byte #3 from the market prices table (mask) and
     6050 CFE1     
20695                      .and @QQ26                      ; AND QQ26          ; AND with the random number for this system visit
     **** ****     > AND
0001 6052 D020  30        movb @QQ26,rtmp
     6054 0346     
0002 6056 0540  14        inv  rtmp
0003 6058 5340  18        szcb rtmp,ra
                   < elite.a99
20696                                                                          ; to give:
20697                                                                          ;
20698                                                                          ; A = random AND mask
20699               
20700                      .clc                            ; CLC               ; Add byte #2 from the market prices table
     **** ****     > CLC
0001 605A 0A16  18        sla  rzero,1
                   < elite.a99
20701                      .adc @QQ23+2(rx),ra             ; ADC QQ23+2,X      ; (base_quantity) so we now have:
     **** ****     > ADC
0001 605C 1701  14        jnc  !
0002 605E B347  18        ab   rone,ra
0003               !:
0004 6060 B36E  34        ab   @QQ23+2(RX),ra
     6062 CFE0     
                   < elite.a99
20702                                                                          ;
20703                                                                          ; A = base_quantity + (random AND mask)
20704               
20705 6064 D3E0  30        movb @QQ19+1,ry                 ; LDY QQ19+1        ; Fetch the byte #1 that we stored above and jump to
     6066 0080     
20706 6068 1107  14        jlt  TT157                      ; BMI TT157         ; TT157 if it is negative (i.e. if the economic_factor
20707                                                                          ; is negative)
20708               
20709                      .sec                            ; SEC               ; Set A = A - QQ19+3
     **** ****     > SEC
0001 606A 0A18  18        sla  rmone,1
                   < elite.a99
20710                      .sbc @QQ19+3,ra                 ; SBC QQ19+3        ;
     **** ****     > SBC
0001 606C 1801  14        joc  !
0002 606E 7347  18        sb   rone,ra
0003               !:
0004 6070 7360  30        sb   @QQ19+3,ra
     6072 0082     
                   < elite.a99
20711                                                                          ; = base_quantity + (random AND mask)
20712                                                                          ; - (economy * |economic_factor|)
20713                                                                          ;
20714                                                                          ; which is the result we want, as the economic_factor
20715                                                                          ; is positive
20716               
20717 6074 0460  28        b    @TT158                     ; JMP TT158         ; Jump to TT158 to skip TT157
     6076 6082     
20718               
20719               TT157:
20720                      .clc                            ; CLC               ; Set A = A + QQ19+3
     **** ****     > CLC
0001 6078 0A16  18        sla  rzero,1
                   < elite.a99
20721                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ;
     **** ****     > ADC
0001 607A 1701  14        jnc  !
0002 607C B347  18        ab   rone,ra
0003               !:
0004 607E B360  30        ab   @QQ19+3,ra
     6080 0082     
                   < elite.a99
20722                                                                          ; = base_quantity + (random AND mask)
20723                                                                          ; + (economy * |economic_factor|)
20724                                                                          ;
20725                                                                          ; which is the result we want, as the economic_factor
20726                                                                          ; is negative
20727               
20728               TT158:
20729 6082 1502  14        jgt  TT159                      ; BPL TT159         ; If A < 0, then set A = 0, so we don't have negative
20730 6084 020D  20        li   ra,>00*256                 ; LDA #0            ; availability
     6086 0000     
20731               
20732               TT159:
20733 6088 D3E0  30        movb @XX4,ry                    ; LDY XX4           ; Fetch the counter (the market item number) into Y
     608A 00A7     
20734               
20735 608C 024D  22        andi ra,>3f*256                 ; AND #%00111111    ; Take bits 0-5 of A, i.e. A mod 64, and store this as
     608E 3F00     
20736 6090 DBCD  38        movb ra,@AVL(ry)                ; STA AVL,Y         ; this item's availability in the Y=th byte of AVL, so
     6092 0335     
20737                                                                          ; each item has a maximum availability of 63t
20738               
20739 6094 B3C7  18        ab   rone,ry                    ; INY               ; Increment the counter into XX44, Y and A
20740 6096 D34F  18        movb ry,ra                      ; TYA
20741 6098 D80D  30        movb ra,@XX4                    ; STA XX4
     609A 00A7     
20742               
20743                      .asla                           ; ASL A             ; Set X = counter * 4, so that X points to the next
     **** ****     > ASLA
0001 609C 024D  22        andi ra,>ff00
     609E FF00     
0002 60A0 0A1D  18        sla  ra,1
                   < elite.a99
20744                      .asla                           ; ASL A             ; item's entry in the four-byte market prices table,
     **** ****     > ASLA
0001 60A2 024D  22        andi ra,>ff00
     60A4 FF00     
0002 60A6 0A1D  18        sla  ra,1
                   < elite.a99
20745 60A8 D38D  18        movb ra,rx                      ; TAX               ; ready for the next loop
20746               
20747 60AA 028D  22        ci   ra,>3f*256                 ; CMP #63           ; If A < 63, jump back up to hy9 to set the availability
     60AC 3F00     
20748 60AE 17C7  14        jnc  hy9_                       ; BCC hy9           ; for the next market item
20749               
20750               hyR:
20751 60B0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     60B2 FE34     
20752               
20753               * ******************************************************************************
20754               *
20755               * Name: GTHG
20756               * Type: Subroutine
20757               * Category: Universe
20758               * Summary: Spawn a Thargoid ship and a Thargon companion
20759               * Deep dive: Fixing ship positions
20760               *
20761               * ******************************************************************************
20762               
20763                      aorg CODE_UPPER.                                    ; TI-99/4A upper RAM code
20764               
20765               GTHG:
20766 A000 0200  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK
     A002 C0D6     
20767 A004 06A0  32        bl   @jsr                       ;
     A006 FE28     
20768                                                                          ;
20769                                                                          ; Note that because Ze uses the value of X returned by
20770                                                                          ; DORND, and X contains the value of A returned by the
20771                                                                          ; previous call to DORND, this does not set the new ship
20772                                                                          ; to a totally random location. See the deep dive on
20773                                                                          ; "Fixing ship positions" for details
20774               
20775 A008 020D  20        li   ra,>ff*256                 ; LDA #%11111111    ; Set the AI flag in byte #32 so that the ship has AI,
     A00A FF00     
20776 A00C D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; is extremely and aggressively hostile, and has E.C.M.
     A00E 0073     
20777               
20778 A010 020D  20        li   ra,(THG)*256               ; LDA #THG          ; Call NWSHP to add a new Thargoid ship to our local
     A012 0600     
20779 A014 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; bubble of universe
     A016 AFC6     
20780 A018 06A0  32        bl   @jsr                       ;
     A01A FE28     
20781               
20782 A01C 020D  20        li   ra,(TGL)*256               ; LDA #TGL          ; Call NWSHP to add a new Thargon ship to our local
     A01E 0C00     
20783 A020 0460  28        b    @NWSHP                     ; JMP NWSHP         ; bubble of universe, and return from the subroutine
     A022 AFC6     
20784                                                                          ; using a tail call
20785               
20786               * ******************************************************************************
20787               *
20788               * Name: MJP
20789               * Type: Subroutine
20790               * Category: Flight
20791               * Summary: Process a mis-jump into witchspace
20792               *
20793               * ------------------------------------------------------------------------------
20794               *
20795               * Process a mis-jump into witchspace (which happens very rarely). Witchspace has
20796               * a strange, almost dust-free aspect to it, and it is populated by hostile
20797               * Thargoids. Using our escape pod will be fatal, and our position on the
20798               * galactic chart is in-between systems. It is a scary place...
20799               *
20800               * There is a 0.78% chance that this routine is called from TT18 instead of doing
20801               * a normal hyperspace, or we can manually trigger a mis-jump by holding down
20802               * CTRL after first enabling the "author display" configuration option ("X") when
20803               * paused.
20804               *
20805               * ------------------------------------------------------------------------------
20806               *
20807               * Other entry points:
20808               *
20809               * ptg                 Called when the user manually forces a mis-jump
20810               *
20811               * ******************************************************************************
20812               
20813               ptg_:
20814                      .lsr @COK                       ; LSR COK           ; Set bit 0 of the competition flags in COK, so that the
     **** ****     > LSR
0001 A024 D020  30        movb @COK,rtmp
     A026 030E     
0002 A028 0910  18        srl  rtmp,1
0003 A02A D800  30        movb rtmp,@COK
     A02C 030E     
                   < elite.a99
20815                      .sec                            ; SEC               ; competition code will include the fact that we have
     **** ****     > SEC
0001 A02E 0A18  18        sla  rmone,1
                   < elite.a99
20816 A030 0204  20        li   rarg1,COK                  ; ROL COK           ; manually forced a mis-jump into witchspace
     A032 030E     
20817 A034 06A0  32        bl   @rol                       ;
     A036 FE4E     
20818               
20819               MJP:
20820               * LDA #1                 \ This instruction is commented out in the original
20821                                                                          ; source - it is not required as a call to TT66-2 sets
20822                                                                          ; A to 1 for us. This is presumably an example of the
20823                                                                          ; authors saving a couple of bytes by calling TT66-2
20824                                                                          ; instead of TT66, while leaving the original LDA
20825                                                                          ; instruction in place
20826 A038 0200  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     A03A 4BDC     
20827 A03C 06A0  32        bl   @jsr                       ;
     A03E FE28     
20828                                                                          ; and set the current view type in QQ11 to 1
20829               
20830 A040 0200  20        li   rtmp,LL164                 ; JSR LL164         ; Call LL164 to show the hyperspace tunnel and make the
     A042 3EF0     
20831 A044 06A0  32        bl   @jsr                       ;
     A046 FE28     
20832                                                                          ; hyperspace sound for a second time (as we already
20833                                                                          ; called LL164 in TT18)
20834               
20835 A048 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces, as
     A04A BFD6     
20836 A04C 06A0  32        bl   @jsr                       ;
     A04E FE28     
20837                                                                          ; well as setting Y to &FF
20838               
20839 A050 D80F  30        movb ry,@MJ                     ; STY MJ            ; Set the mis-jump flag in MJ to &FF, to indicate that
     A052 0D5C     
20840                                                                          ; we are now in witchspace
20841               
20842               MJP1:
20843 A054 0200  20        li   rtmp,GTHG                  ; JSR GTHG          ; Call GTHG to spawn a Thargoid ship and a Thargon
     A056 A000     
20844 A058 06A0  32        bl   @jsr                       ;
     A05A FE28     
20845                                                                          ; companion
20846               
20847 A05C 020D  20        li   ra,>03*256                 ; LDA #3            ; Fetch the number of Thargoid ships from MANY+THG, and
     A05E 0300     
20848 A060 9360  30        cb   @MANY+THG,ra               ; CMP MANY+THG      ; if it is less than or equal to 3, loop back to MJP1 to
     A062 0D53     
20849 A064 18F7  14        joc  MJP1                       ; BCS MJP1          ; spawn another one, until we have four Thargoids
20850               
20851 A066 D80D  30        movb ra,@NOSTM                  ; STA NOSTM         ; Set NOSTM (the maximum number of stardust particles)
     A068 0F33     
20852                                                                          ; to 3, so there are fewer bits of stardust in
20853                                                                          ; witchspace (normal space has a maximum of 18)
20854               
20855 A06A 020E  20        li   rx,>00*256                 ; LDX #0            ; Initialise the front space view
     A06C 0000     
20856 A06E 0200  20        li   rtmp,LOOK1                 ; JSR LOOK1
     A070 4B78     
20857 A072 06A0  32        bl   @jsr                       ;
     A074 FE28     
20858               
20859 A076 D360  30        movb @QQ1,ra                    ; LDA QQ1           ; Fetch the current system's galactic y-coordinate in
     A078 0302     
20860                      .eoi (>1f*256)                  ; EOR #%00011111    ; QQ1 and flip bits 0-5, so we end up somewhere in the
     **** ****     > EOI
0001 A07A 0200  20        li   rtmp,(>1F*256)
     A07C 1F00     
0002 A07E 2B40  18        xor  rtmp,ra
                   < elite.a99
20861 A080 D80D  30        movb ra,@QQ1                    ; STA QQ1           ; vicinity of our original destination, but above or
     A082 0302     
20862                                                                          ; below it in the galactic chart
20863               ptg1_:
20864 A084 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A086 FE34     
20865               
20866               * ******************************************************************************
20867               *
20868               * Name: TT18
20869               * Type: Subroutine
20870               * Category: Flight
20871               * Summary: Try to initiate a jump into hyperspace
20872               *
20873               * ------------------------------------------------------------------------------
20874               *
20875               * Try to go through hyperspace. Called from TT102 in the main loop when the
20876               * hyperspace countdown has finished.
20877               *
20878               * ******************************************************************************
20879               
20880               TT18:
20881 A088 D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Subtract the distance to the selected system (in QQ8)
     A08A 030D     
20882                      .sec                            ; SEC               ; from the amount of fuel in our tank (in QQ14) into A
     **** ****     > SEC
0001 A08C 0A18  18        sla  rmone,1
                   < elite.a99
20883                      .sbc @QQ8,ra                    ; SBC QQ8
     **** ****     > SBC
0001 A08E 1801  14        joc  !
0002 A090 7347  18        sb   rone,ra
0003               !:
0004 A092 7360  30        sb   @QQ8,ra
     A094 0F2F     
                   < elite.a99
20884               
20885 A096 D80D  30        movb ra,@QQ14                   ; STA QQ14          ; Store the updated fuel amount in QQ14
     A098 030D     
20886               
20887 A09A D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is not a space view, jump to ee5
     A09C 0096     
20888 A09E 1608  14        jne  ee5_                       ; BNE ee5           ; to skip the following
20889               
20890 A0A0 0200  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     A0A2 4BDE     
20891 A0A4 06A0  32        bl   @jsr                       ;
     A0A6 FE28     
20892                                                                          ; and set the current view type in QQ11 to 0 (space
20893                                                                          ; view)
20894               
20895 A0A8 0200  20        li   rtmp,LL164                 ; JSR LL164         ; Call LL164 to show the hyperspace tunnel and make the
     A0AA 3EF0     
20896 A0AC 06A0  32        bl   @jsr                       ;
     A0AE FE28     
20897                                                                          ; hyperspace sound
20898               
20899               ee5_:
20900 A0B0 0200  20        li   rtmp,CTRL                  ; JSR CTRL          ; Scan the keyboard to see if CTRL is currently pressed,
     A0B2 CCD0     
20901 A0B4 06A0  32        bl   @jsr                       ;
     A0B6 FE28     
20902                                                                          ; returning a negative value in A if it is
20903               
20904                      .and @PATG                      ; AND PATG          ; If the game is configured to show the author's names
     **** ****     > AND
0001 A0B8 D020  30        movb @PATG,rtmp
     A0BA 0F4C     
0002 A0BC 0540  14        inv  rtmp
0003 A0BE 5340  18        szcb rtmp,ra
                   < elite.a99
20905                                                                          ; on the start-up screen, then PATG will contain &FF,
20906                                                                          ; otherwise it will be 0
20907               
20908 A0C0 11B1  14        jlt  ptg_                       ; BMI ptg           ; By now, A will be negative if we are holding down CTRL
20909                                                                          ; and author names are configured, which is what we have
20910                                                                          ; to do in order to trigger a manual mis-jump, so jump
20911                                                                          ; to ptg to do a mis-jump (ptg not only mis-jumps, but
20912                                                                          ; updates the competition flags, so Acornsoft could tell
20913                                                                          ; from the competition code whether this feature had
20914                                                                          ; been used)
20915               
20916 A0C2 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     A0C4 C120     
20917 A0C6 06A0  32        bl   @jsr                       ;
     A0C8 FE28     
20918               
20919 A0CA 028D  22        ci   ra,>fd*256                 ; CMP #253          ; If A >= 253 (0.78% chance) then jump to MJP to trigger
     A0CC FD00     
20920 A0CE 18B4  14        joc  MJP                        ; BCS MJP           ; a mis-jump into witchspace
20921               
20922               * JSR TT111              \ This instruction is commented out in the original
20923                                                                          ; source. It finds the closest system to coordinates
20924                                                                          ; (QQ9, QQ10), but we don't need to do this as the
20925                                                                          ; crosshairs will already be on a system by this point
20926               
20927 A0D0 0200  20        li   rtmp,hyp1_+3               ; JSR hyp1+3        ; Jump straight to the system at (QQ9, QQ10) without
     A0D2 5FEB     
20928 A0D4 06A0  32        bl   @jsr                       ;
     A0D6 FE28     
20929                                                                          ; first calculating which system is closest
20930               
20931 A0D8 0200  20        li   rtmp,GVL                   ; JSR GVL           ; Calculate the availability for each market item in the
     A0DA 602A     
20932 A0DC 06A0  32        bl   @jsr                       ;
     A0DE FE28     
20933                                                                          ; new system
20934               
20935 A0E0 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     A0E2 BFD6     
20936 A0E4 06A0  32        bl   @jsr                       ;
     A0E6 FE28     
20937               
20938 A0E8 0200  20        li   rtmp,SOLAR                 ; JSR SOLAR         ; Halve our legal status, update the missile indicators,
     A0EA ABA6     
20939 A0EC 06A0  32        bl   @jsr                       ;
     A0EE FE28     
20940                                                                          ; and set up data blocks and slots for the planet and
20941                                                                          ; sun
20942               
20943 A0F0 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view in QQ11 is not a space view (0) or
     A0F2 0096     
20944 A0F4 024D  22        andi ra,>3f*256                 ; AND #%00111111    ; one of the charts (64 or 128), return from the
     A0F6 3F00     
20945 A0F8 16C5  14        jne  ptg1_                      ; BNE ptg1          ; subroutine (as hyR contains an RTS)
20946               
20947 A0FA 0200  20        li   rtmp,TTX66                 ; JSR TTX66         ; Otherwise clear the screen and draw a white border
     A0FC 4BE2     
20948 A0FE 06A0  32        bl   @jsr                       ;
     A100 FE28     
20949               
20950 A102 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is one of the charts, jump to
     A104 0096     
20951 A106 1630  14        jne  TT114                      ; BNE TT114         ; TT114 (from which we jump to the correct routine to
20952                                                                          ; display the chart)
20953               
20954 A108 B347  18        ab   rone,ra                    ; INC QQ11          ; This is a space view, so increment QQ11 to 1
20955               
20956                                                                          ; Fall through into TT110 to show the front space view
20957               
20958               * ******************************************************************************
20959               *
20960               * Name: TT110
20961               * Type: Subroutine
20962               * Category: Flight
20963               * Summary: Launch from a station or show the front space view
20964               *
20965               * ------------------------------------------------------------------------------
20966               *
20967               * Launch the ship (if we are docked), or show the front space view (if we are
20968               * already in space).
20969               *
20970               * Called when red key f0 is pressed while docked (launch), after we arrive in a
20971               * new galaxy, or after a hyperspace if the current view is a space view.
20972               *
20973               * ******************************************************************************
20974               
20975               TT110:
20976 A10A D3A0  30        movb @QQ12,rx                   ; LDX QQ12          ; If we are not docked (QQ12 = 0) then jump to NLUNCH
     A10C 009F     
20977 A10E 1326  14        jeq  NLUNCH                     ; BEQ NLUNCH        ; to skip the launch tunnel and setup process
20978               
20979 A110 0200  20        li   rtmp,LAUN                  ; JSR LAUN          ; Show the space station launch tunnel
     A112 3F16     
20980 A114 06A0  32        bl   @jsr                       ;
     A116 FE28     
20981               
20982 A118 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     A11A BFD6     
20983 A11C 06A0  32        bl   @jsr                       ;
     A11E FE28     
20984               
20985 A120 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     A122 5B78     
20986 A124 06A0  32        bl   @jsr                       ;
     A126 FE28     
20987                                                                          ; (QQ9, QQ10)
20988               
20989 A128 B347  18        ab   rone,ra                    ; INC INWK+8        ; Increment z_sign ready for the call to SOS, so the
20990                                                                          ; planet appears at a z_sign of 1 in front of us when
20991                                                                          ; we launch
20992               
20993 A12A 0200  20        li   rtmp,SOS1                  ; JSR SOS1          ; Call SOS1 to set up the planet's data block and add it
     A12C AB82     
20994 A12E 06A0  32        bl   @jsr                       ;
     A130 FE28     
20995                                                                          ; to FRIN, where it will get put in the first slot as
20996                                                                          ; it's the first one to be added to our local bubble of
20997                                                                          ; universe following the call to RES2 above
20998               
20999 A132 020D  20        li   ra,>80*256                 ; LDA #128          ; For the space station, set z_sign to &80, so it's
     A134 8000     
21000 A136 D80D  30        movb ra,@INWK+8                 ; STA INWK+8        ; behind us (&80 is negative)
     A138 005B     
21001               
21002 A13A B347  18        ab   rone,ra                    ; INC INWK+7        ; And increment z_hi, so it's only just behind us
21003               
21004 A13C 0200  20        li   rtmp,NWSPS                 ; JSR NWSPS         ; Add a new space station to our local bubble of
     A13E AF76     
21005 A140 06A0  32        bl   @jsr                       ;
     A142 FE28     
21006                                                                          ; universe
21007               
21008 A144 020D  20        li   ra,>0c*256                 ; LDA #12           ; Set our launch speed in DELTA to 12
     A146 0C00     
21009 A148 D80D  30        movb ra,@DELTA                  ; STA DELTA
     A14A 008C     
21010               
21011 A14C 0200  20        li   rtmp,BAD                   ; JSR BAD           ; Call BAD to work out how much illegal contraband we
     A14E C4DA     
21012 A150 06A0  32        bl   @jsr                       ;
     A152 FE28     
21013                                                                          ; are carrying in our hold (A is up to 40 for a
21014                                                                          ; standard hold crammed with contraband, up to 70 for
21015                                                                          ; an extended cargo hold full of narcotics and slaves)
21016               
21017 A154 F360  30        socb @FIST,ra                   ; ORA FIST          ; OR the value in A with our legal status in FIST to
     A156 0334     
21018                                                                          ; get a new value that is at least as high as both
21019                                                                          ; values, to reflect the fact that launching with a
21020                                                                          ; hold full of contraband can only make matters worse
21021               
21022 A158 D80D  30        movb ra,@FIST                   ; STA FIST          ; Update our legal status with the new value
     A15A 0334     
21023               
21024               NLUNCH:
21025 A15C 020E  20        li   rx,>00*256                 ; LDX #0            ; Set QQ12 to 0 to indicate we are not docked
     A15E 0000     
21026 A160 D80E  30        movb rx,@QQ12                   ; STX QQ12
     A162 009F     
21027               
21028 A164 0460  28        b    @LOOK1                     ; JMP LOOK1         ; Jump to LOOK1 to switch to the front view (X = 0),
     A166 4B78     
21029                                                                          ; returning from the subroutine using a tail call
21030               
21031               * ******************************************************************************
21032               *
21033               * Name: TT114
21034               * Type: Subroutine
21035               * Category: Charts
21036               * Summary: Display either the Long-range or Short-range Chart
21037               *
21038               * ------------------------------------------------------------------------------
21039               *
21040               * Display either the Long-range or Short-range Chart, depending on the current
21041               * view setting. Called from TT18 once we know the current view is one of the
21042               * charts.
21043               *
21044               * ------------------------------------------------------------------------------
21045               *
21046               * Arguments:
21047               *
21048               * A                   The current view, loaded from QQ11
21049               *
21050               * ******************************************************************************
21051               
21052               TT114:
21053 A168 1102  14        jlt  TT115                      ; BMI TT115         ; If bit 7 of the current view is set (i.e. the view is
21054                                                                          ; the Short-range Chart, 128), skip to TT115 below to
21055                                                                          ; jump to TT23 to display the chart
21056               
21057 A16A 0460  28        b    @TT22                      ; JMP TT22          ; Otherwise the current view is the Long-range Chart, so
     A16C 5332     
21058                                                                          ; jump to TT22 to display it
21059               
21060               TT115:
21061 A16E 0460  28        b    @TT23                      ; JMP TT23          ; Jump to TT23 to display the Short-range Chart
     A170 59EA     
21062               
21063               * ******************************************************************************
21064               *
21065               * Name: LCASH
21066               * Type: Subroutine
21067               * Category: Maths (Arithmetic)
21068               * Summary: Subtract an amount of cash from the cash pot
21069               *
21070               * ------------------------------------------------------------------------------
21071               *
21072               * Subtract (Y X) cash from the cash pot in CASH, but only if there is enough
21073               * cash in the pot. As CASH is a four-byte number, this calculates:
21074               *
21075               * CASH(0 1 2 3) = CASH(0 1 2 3) - (0 0 Y X)
21076               *
21077               * ------------------------------------------------------------------------------
21078               *
21079               * Returns:
21080               *
21081               * C flag              If set, there was enough cash to do the subtraction
21082               *
21083               * If clear, there was not enough cash to do the
21084               * subtraction
21085               *
21086               * ******************************************************************************
21087               
21088               LCASH:
21089 A172 D80E  30        movb rx,@T1                     ; STX T1            ; Subtract the least significant bytes:
     A174 0006     
21090 A176 D360  30        movb @CASH+3,ra                 ; LDA CASH+3        ;
     A178 030C     
21091                      .sec                            ; SEC               ; CASH+3 = CASH+3 - X
     **** ****     > SEC
0001 A17A 0A18  18        sla  rmone,1
                   < elite.a99
21092                      .sbc @T1,ra                     ; SBC T1
     **** ****     > SBC
0001 A17C 1801  14        joc  !
0002 A17E 7347  18        sb   rone,ra
0003               !:
0004 A180 7360  30        sb   @T1,ra
     A182 0006     
                   < elite.a99
21093 A184 D80D  30        movb ra,@CASH+3                 ; STA CASH+3
     A186 030C     
21094               
21095 A188 D80F  30        movb ry,@T1                     ; STY T1            ; Then the second most significant bytes:
     A18A 0006     
21096 A18C D360  30        movb @CASH+2,ra                 ; LDA CASH+2        ;
     A18E 030B     
21097                      .sbc @T1,ra                     ; SBC T1            ; CASH+2 = CASH+2 - Y
     **** ****     > SBC
0001 A190 1801  14        joc  !
0002 A192 7347  18        sb   rone,ra
0003               !:
0004 A194 7360  30        sb   @T1,ra
     A196 0006     
                   < elite.a99
21098 A198 D80D  30        movb ra,@CASH+2                 ; STA CASH+2
     A19A 030B     
21099               
21100 A19C D360  30        movb @CASH+1,ra                 ; LDA CASH+1        ; Then the third most significant bytes (which are 0):
     A19E 030A     
21101                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 A1A0 1801  14        joc  !
0002 A1A2 7347  18        sb   rone,ra
0003               !:
0004 A1A4 022D  22        ai   ra,-(>00*256)
     A1A6 0000     
                   < elite.a99
21102 A1A8 D80D  30        movb ra,@CASH+1                 ; STA CASH+1        ; CASH+1 = CASH+1 - 0
     A1AA 030A     
21103               
21104 A1AC D360  30        movb @CASH,ra                   ; LDA CASH          ; And finally the most significant bytes (which are 0):
     A1AE 0309     
21105                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 A1B0 1801  14        joc  !
0002 A1B2 7347  18        sb   rone,ra
0003               !:
0004 A1B4 022D  22        ai   ra,-(>00*256)
     A1B6 0000     
                   < elite.a99
21106 A1B8 D80D  30        movb ra,@CASH                   ; STA CASH          ; CASH = CASH - 0
     A1BA 0309     
21107               
21108 A1BC 1820  14        joc  TT113                      ; BCS TT113         ; If the C flag is set then the subtraction didn't
21109                                                                          ; underflow, so the value in CASH is correct and we can
21110                                                                          ; jump to TT113 to return from the subroutine with the
21111                                                                          ; C flag set to indicate success (as TT113 contains an
21112                                                                          ; RTS)
21113               
21114                                                                          ; Otherwise we didn't have enough cash in CASH to
21115                                                                          ; subtract (Y X) from it, so fall through into
21116                                                                          ; MCASH to reverse the sum and restore the original
21117                                                                          ; value in CASH, and returning with the C flag clear
21118               
21119               * ******************************************************************************
21120               *
21121               * Name: MCASH
21122               * Type: Subroutine
21123               * Category: Maths (Arithmetic)
21124               * Summary: Add an amount of cash to the cash pot
21125               *
21126               * ------------------------------------------------------------------------------
21127               *
21128               * Add (Y X) cash to the cash pot in CASH. As CASH is a four-byte number, this
21129               * calculates:
21130               *
21131               * CASH(0 1 2 3) = CASH(0 1 2 3) + (Y X)
21132               *
21133               * ------------------------------------------------------------------------------
21134               *
21135               * Other entry points:
21136               *
21137               * TT113               Contains an RTS
21138               *
21139               * ******************************************************************************
21140               
21141               MCASH:
21142 A1BE D34E  18        movb rx,ra                      ; TXA               ; Add the least significant bytes:
21143                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 A1C0 0A16  18        sla  rzero,1
                   < elite.a99
21144                      .adc @CASH+3,ra                 ; ADC CASH+3        ; CASH+3 = CASH+3 + X
     **** ****     > ADC
0001 A1C2 1701  14        jnc  !
0002 A1C4 B347  18        ab   rone,ra
0003               !:
0004 A1C6 B360  30        ab   @CASH+3,ra
     A1C8 030C     
                   < elite.a99
21145 A1CA D80D  30        movb ra,@CASH+3                 ; STA CASH+3
     A1CC 030C     
21146               
21147 A1CE D34F  18        movb ry,ra                      ; TYA               ; Then the second most significant bytes:
21148                      .adc @CASH+2,ra                 ; ADC CASH+2        ;
     **** ****     > ADC
0001 A1D0 1701  14        jnc  !
0002 A1D2 B347  18        ab   rone,ra
0003               !:
0004 A1D4 B360  30        ab   @CASH+2,ra
     A1D6 030B     
                   < elite.a99
21149 A1D8 D80D  30        movb ra,@CASH+2                 ; STA CASH+2        ; CASH+2 = CASH+2 + Y
     A1DA 030B     
21150               
21151 A1DC D360  30        movb @CASH+1,ra                 ; LDA CASH+1        ; Then the third most significant bytes (which are 0):
     A1DE 030A     
21152                      .adi (>00*256)                  ; ADC #0            ;
     **** ****     > ADI
0001 A1E0 1701  14        jnc  !
0002 A1E2 B347  18        ab   rone,ra
0003               !:
0004 A1E4 022D  22        ai   ra,(>00*256)
     A1E6 0000     
                   < elite.a99
21153 A1E8 D80D  30        movb ra,@CASH+1                 ; STA CASH+1        ; CASH+1 = CASH+1 + 0
     A1EA 030A     
21154               
21155 A1EC D360  30        movb @CASH,ra                   ; LDA CASH          ; And finally the most significant bytes (which are 0):
     A1EE 0309     
21156                      .adi (>00*256)                  ; ADC #0            ;
     **** ****     > ADI
0001 A1F0 1701  14        jnc  !
0002 A1F2 B347  18        ab   rone,ra
0003               !:
0004 A1F4 022D  22        ai   ra,(>00*256)
     A1F6 0000     
                   < elite.a99
21157 A1F8 D80D  30        movb ra,@CASH                   ; STA CASH          ; CASH = CASH + 0
     A1FA 0309     
21158               
21159                      .clc                            ; CLC               ; Clear the C flag, so if the above was done following
     **** ****     > CLC
0001 A1FC 0A16  18        sla  rzero,1
                   < elite.a99
21160                                                                          ; a failed LCASH call, the C flag correctly indicates
21161                                                                          ; failure
21162               
21163               TT113:
21164 A1FE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A200 FE34     
21165               
21166               * ******************************************************************************
21167               *
21168               * Name: GCASH
21169               * Type: Subroutine
21170               * Category: Maths (Arithmetic)
21171               * Summary: Calculate (Y X) = P * Q * 4
21172               *
21173               * ------------------------------------------------------------------------------
21174               *
21175               * Calculate the following multiplication of unsigned 8-bit numbers:
21176               *
21177               * (Y X) = P * Q * 4
21178               *
21179               * ******************************************************************************
21180               
21181               GCASH:
21182 A202 0200  20        li   rtmp,MULTU                 ; JSR MULTU         ; Call MULTU to calculate (A P) = P * Q
     A204 4392     
21183 A206 06A0  32        bl   @jsr                       ;
     A208 FE28     
21184               
21185               * ******************************************************************************
21186               *
21187               * Name: GC2
21188               * Type: Subroutine
21189               * Category: Maths (Arithmetic)
21190               * Summary: Calculate (Y X) = (A P) * 4
21191               *
21192               * ------------------------------------------------------------------------------
21193               *
21194               * Calculate the following multiplication of unsigned 16-bit numbers:
21195               *
21196               * (Y X) = (A P) * 4
21197               *
21198               * ******************************************************************************
21199               
21200               GC2:
21201                      .asl @P                         ; ASL P             ; Set (A P) = (A P) * 4
     **** ****     > ASL
0001 A20A D020  30        movb @P,rtmp
     A20C 001B     
0002 A20E 0240  22        andi rtmp,>ff00
     A210 FF00     
0003 A212 0A10  18        sla  rtmp,1
0004 A214 D800  30        movb rtmp,@P
     A216 001B     
                   < elite.a99
21202 A218 06A0  32        bl   @rola                      ; ROL A
     A21A FE3E     
21203                      .asl @P                         ; ASL P
     **** ****     > ASL
0001 A21C D020  30        movb @P,rtmp
     A21E 001B     
0002 A220 0240  22        andi rtmp,>ff00
     A222 FF00     
0003 A224 0A10  18        sla  rtmp,1
0004 A226 D800  30        movb rtmp,@P
     A228 001B     
                   < elite.a99
21204 A22A 06A0  32        bl   @rola                      ; ROL A
     A22C FE3E     
21205               
21206 A22E D3CD  18        movb ra,ry                      ; TAY               ; Set (Y X) = (A P)
21207 A230 D3A0  30        movb @P,rx                      ; LDX P
     A232 001B     
21208               
21209 A234 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A236 FE34     
21210               
21211               * ******************************************************************************
21212               *
21213               * Name: EQSHP
21214               * Type: Subroutine
21215               * Category: Equipment
21216               * Summary: Show the Equip Ship screen (red key f3)
21217               *
21218               * ------------------------------------------------------------------------------
21219               *
21220               * Other entry points:
21221               *
21222               * err                 Beep, pause and go to the docking bay (i.e. show the
21223               * Status Mode screen)
21224               *
21225               * pres                Given an item number A with the item name in recursive
21226               * token Y, show an error to say that the item is already
21227               * present, refund the cost of the item, and then beep and
21228               * exit to the docking bay (i.e. show the Status Mode
21229               * screen)
21230               *
21231               * ******************************************************************************
21232               
21233               bay_:
21234 A238 0460  28        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     A23A C704     
21235                                                                          ; screen)
21236               
21237               EQSHP:
21238 A23C 0200  20        li   rtmp,DIALS                 ; JSR DIALS         ; Call DIALS to update the dashboard
     A23E 32CA     
21239 A240 06A0  32        bl   @jsr                       ;
     A242 FE28     
21240               
21241 A244 020D  20        li   ra,>20*256                 ; LDA #32           ; Clear the top part of the screen, draw a white border,
     A246 2000     
21242 A248 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 32 (Equip
     A24A 4BDE     
21243 A24C 06A0  32        bl   @jsr                       ;
     A24E FE28     
21244                                                                          ; Ship screen)
21245               
21246 A250 020D  20        li   ra,>0c*256                 ; LDA #12           ; Move the text cursor to column 12
     A252 0C00     
21247 A254 D80D  30        movb ra,@XC                     ; STA XC
     A256 002C     
21248               
21249 A258 020D  20        li   ra,>cf*256                 ; LDA #207          ; Print recursive token 47 ("EQUIP") followed by a space
     A25A CF00     
21250 A25C 0200  20        li   rtmp,spc_                  ; JSR spc
     A25E 4FBE     
21251 A260 06A0  32        bl   @jsr                       ;
     A262 FE28     
21252               
21253 A264 020D  20        li   ra,>b9*256                 ; LDA #185          ; Print recursive token 25 ("SHIP") and draw a
     A266 B900     
21254 A268 0200  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; horizontal line at pixel row 19 to box in the title
     A26A 25E4     
21255 A26C 06A0  32        bl   @jsr                       ;
     A26E FE28     
21256               
21257 A270 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     A272 8000     
21258 A274 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     A276 007E     
21259               
21260 A278 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
21261               
21262 A27A D360  30        movb @tek_,ra                   ; LDA tek           ; Fetch the tech level of the current system from tek
     A27C 0F1D     
21263                      .clc                            ; CLC               ; and add 3 (the tech level is stored as 0-14, so A is
     **** ****     > CLC
0001 A27E 0A16  18        sla  rzero,1
                   < elite.a99
21264                      .adi (>03*256)                  ; ADC #3            ; now set to between 3 and 17)
     **** ****     > ADI
0001 A280 1701  14        jnc  !
0002 A282 B347  18        ab   rone,ra
0003               !:
0004 A284 022D  22        ai   ra,(>03*256)
     A286 0300     
                   < elite.a99
21265               
21266 A288 028D  22        ci   ra,>0c*256                 ; CMP #12           ; If A >= 12 then set A = 12, so A is now set to between
     A28A 0C00     
21267 A28C 1702  14        jnc  B58                        ; BCC B58           ; 3 and 12
21268 A28E 020D  20        li   ra,>0c*256                 ; LDA #12
     A290 0C00     
21269               
21270               B58:
21271 A292 D80D  30        movb ra,@Q                      ; STA Q             ; Set QQ25 = A (so QQ25 is in the range 3-12 and
     A294 0090     
21272 A296 D80D  30        movb ra,@QQ25                   ; STA QQ25          ; represents number of the most advanced item available
     A298 0F19     
21273 A29A B347  18        ab   rone,ra                    ; INC Q             ; in this system, which we can pass to gnum below when
21274                                                                          ; asking which item we want to buy)
21275                                                                          ;
21276                                                                          ; Set Q = A + 1 (so Q is in the range 4-13 and contains
21277                                                                          ; QQ25 + 1, i.e. the highest item number on sale + 1)
21278               
21279 A29C 020D  20        li   ra,>46*256                 ; LDA #70           ; Set A = 70 - QQ14, where QQ14 contains the current
     A29E 4600     
21280                      .sec                            ; SEC               ; fuel in light years * 10, so this leaves the amount
     **** ****     > SEC
0001 A2A0 0A18  18        sla  rmone,1
                   < elite.a99
21281                      .sbc @QQ14,ra                   ; SBC QQ14          ; of fuel we need to fill 'er up (in light years * 10)
     **** ****     > SBC
0001 A2A2 1801  14        joc  !
0002 A2A4 7347  18        sb   rone,ra
0003               !:
0004 A2A6 7360  30        sb   @QQ14,ra
     A2A8 030D     
                   < elite.a99
21282               
21283                      .asla                           ; ASL A             ; The price of fuel is always 2 Cr per light year, so we
     **** ****     > ASLA
0001 A2AA 024D  22        andi ra,>ff00
     A2AC FF00     
0002 A2AE 0A1D  18        sla  ra,1
                   < elite.a99
21284 A2B0 D80D  38        movb ra,@PRXS                   ; STA PRXS          ; double A and store it in PRXS, as the first price in
     A2B2 2E40     
21285                                                                          ; the price list (which is reserved for fuel), and
21286                                                                          ; because the table contains prices as price * 10, it's
21287                                                                          ; in the right format (so tank containing 7.0 light
21288                                                                          ; years of fuel would be 14.0 Cr, or a PRXS value of
21289                                                                          ; 140)
21290               
21291 A2B4 020E  20        li   rx,>01*256                 ; LDX #1            ; We are now going to work our way through the equipment
     A2B6 0100     
21292                                                                          ; price list at PRXS, printing out the equipment that is
21293                                                                          ; available at this station, so set a counter in X,
21294                                                                          ; starting at 1, to hold the number of the current item
21295                                                                          ; plus 1 (so the item number in X loops through 1-13)
21296               
21297               EQL1:
21298 A2B8 D80E  30        movb rx,@XX13                   ; STX XX13          ; Store the current item number + 1 in XX13
     A2BA 0098     
21299               
21300 A2BC 0200  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline
     A2BE 4FA6     
21301 A2C0 06A0  32        bl   @jsr                       ;
     A2C2 FE28     
21302               
21303 A2C4 D3A0  30        movb @XX13,rx                   ; LDX XX13          ; Print the current item number + 1 to 3 digits, left-
     A2C6 0098     
21304                      .clc                            ; CLC               ; padding with spaces, and with no decimal point, so the
     **** ****     > CLC
0001 A2C8 0A16  18        sla  rzero,1
                   < elite.a99
21305 A2CA 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; items are numbered from 1
     A2CC 2FFC     
21306 A2CE 06A0  32        bl   @jsr                       ;
     A2D0 FE28     
21307               
21308 A2D2 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     A2D4 5F24     
21309 A2D6 06A0  32        bl   @jsr                       ;
     A2D8 FE28     
21310               
21311 A2DA D360  30        movb @XX13,ra                   ; LDA XX13          ; Print recursive token 104 + XX13, which will be in the
     A2DC 0098     
21312                      .clc                            ; CLC               ; range 105 ("FUEL") to 116 ("GALACTIC HYPERSPACE ")
     **** ****     > CLC
0001 A2DE 0A16  18        sla  rzero,1
                   < elite.a99
21313                      .adi (>68*256)                  ; ADC #104          ; so this prints the current item's name
     **** ****     > ADI
0001 A2E0 1701  14        jnc  !
0002 A2E2 B347  18        ab   rone,ra
0003               !:
0004 A2E4 022D  22        ai   ra,(>68*256)
     A2E6 6800     
                   < elite.a99
21314 A2E8 0200  20        li   rtmp,TT27                  ; JSR TT27
     A2EA A6E8     
21315 A2EC 06A0  32        bl   @jsr                       ;
     A2EE FE28     
21316               
21317 A2F0 D360  30        movb @XX13,ra                   ; LDA XX13          ; Call prx-3 to set (Y X) to the price of the item with
     A2F2 0098     
21318 A2F4 0200  20        li   rtmp,prx_-3                ; JSR prx-3         ; number XX13 - 1 (as XX13 contains the item number + 1)
     A2F6 A521     
21319 A2F8 06A0  32        bl   @jsr                       ;
     A2FA FE28     
21320               
21321                      .sec                            ; SEC               ; Set the C flag so we will print a decimal point when
     **** ****     > SEC
0001 A2FC 0A18  18        sla  rmone,1
                   < elite.a99
21322                                                                          ; we print the price
21323               
21324 A2FE 020D  20        li   ra,>19*256                 ; LDA #25           ; Move the text cursor to column 25
     A300 1900     
21325 A302 D80D  30        movb ra,@XC                     ; STA XC
     A304 002C     
21326               
21327 A306 020D  20        li   ra,>06*256                 ; LDA #6            ; Print the number in (Y X) to 6 digits, left-padding
     A308 0600     
21328 A30A 0200  20        li   rtmp,TT11                  ; JSR TT11          ; with spaces and including a decimal point, which will
     A30C 3004     
21329 A30E 06A0  32        bl   @jsr                       ;
     A310 FE28     
21330                                                                          ; be the correct price for this item as (Y X) contains
21331                                                                          ; the price * 10, so the trailing zero will go after the
21332                                                                          ; decimal point (i.e. 5250 will be printed as 525.0)
21333               
21334 A312 D3A0  30        movb @XX13,rx                   ; LDX XX13          ; Increment the current item number in XX13
     A314 0098     
21335 A316 B387  18        ab   rone,rx                    ; INX
21336               
21337 A318 93A0  30        cb   @Q,rx                      ; CPX Q             ; If X < Q, loop back up to print the next item on the
     A31A 0090     
21338 A31C 17CD  14        jnc  EQL1                       ; BCC EQL1          ; list of equipment available at this station
21339               
21340 A31E 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     A320 4CE2     
21341 A322 06A0  32        bl   @jsr                       ;
     A324 FE28     
21342                                                                          ; and move the text cursor to column 1 on row 21, i.e.
21343                                                                          ; the start of the top row of the three bottom rows
21344               
21345 A326 020D  20        li   ra,>7f*256                 ; LDA #127          ; Print recursive token 127 ("ITEM") followed by a
     A328 7F00     
21346 A32A 0200  20        li   rtmp,prq_                  ; JSR prq           ; question mark
     A32C 5E12     
21347 A32E 06A0  32        bl   @jsr                       ;
     A330 FE28     
21348               
21349 A332 0200  20        li   rtmp,gnum_                 ; JSR gnum          ; Call gnum to get a number from the keyboard, which
     A334 568E     
21350 A336 06A0  32        bl   @jsr                       ;
     A338 FE28     
21351                                                                          ; will be the number of the item we want to purchase,
21352                                                                          ; returning the number entered in A and R, and setting
21353                                                                          ; the C flag if the number is bigger than the highest
21354                                                                          ; item number in QQ25
21355               
21356 A33A 1602  14        jne  FIX004                     ; BNE FIX004        ; If no number was entered, jump up to bay to go to the
21357                                                                          ; docking bay (i.e. show the Status Mode screen)
21358 A33C 0460  28        b    @bay_                      ; JMP bay
     A33E A238     
21359               FIX004:
21360 A340 1702  14        jnc  FIX005                     ; BCC FIX005        ; If the number entered was too big, jump up to bay to
21361                                                                          ; go to the docking bay (i.e. show the Status Mode
21362                                                                          ; screen)
21363 A342 0460  28        b    @bay_                      ; JMP bay
     A344 A238     
21364               FIX005:
21365                      .sbi (>00*256)                  ; SBC #0            ; Set A to the number entered - 1 (because the C flag is
     **** ****     > SBI
0001 A346 1801  14        joc  !
0002 A348 7347  18        sb   rone,ra
0003               !:
0004 A34A 022D  22        ai   ra,-(>00*256)
     A34C 0000     
                   < elite.a99
21366                                                                          ; clear), which will be the actual item number we want
21367                                                                          ; to buy
21368               
21369 A34E 020E  20        li   rx,>02*256                 ; LDX #2            ; Move the text cursor to column 2
     A350 0200     
21370 A352 D80E  30        movb rx,@XC                     ; STX XC
     A354 002C     
21371               
21372 A356 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
21373               
21374                      .pha                            ; PHA               ; While preserving the value in A, call eq to subtract
     **** ****     > PHA
0001 A358 D68D  30        movb ra,*rsp
0002 A35A 060A  14        dec  rsp
                   < elite.a99
21375 A35C 0200  20        li   rtmp,eq_                   ; JSR eq            ; the price of the item we want to buy (which is in A)
     A35E A4F8     
21376 A360 06A0  32        bl   @jsr                       ;
     A362 FE28     
21377                      .pla                            ; PLA               ; from our cash pot, but only if we have enough cash in
     **** ****     > PLA
0001 A364 058A  14        inc  rsp
0002 A366 D35A  26        movb *rsp,ra
                   < elite.a99
21378                                                                          ; the pot. If we don't have enough cash, exit to the
21379                                                                          ; docking bay (i.e. show the Status Mode screen)
21380               
21381 A368 1606  14        jne  et0_                       ; BNE et0           ; If A is not 0 (i.e. the item we've just bought is not
21382                                                                          ; fuel), skip to et0
21383               
21384 A36A D80D  30        movb ra,@MCNT                   ; STA MCNT          ; We just bought fuel, so we zero the main loop counter
     A36C 0099     
21385               
21386 A36E 020E  20        li   rx,>46*256                 ; LDX #70           ; Set the current fuel level * 10 in QQ14 to 70, or 7.0
     A370 4600     
21387 A372 D80E  30        movb rx,@QQ14                   ; STX QQ14          ; light years (a full tank)
     A374 030D     
21388               
21389               et0_:
21390 A376 028D  22        ci   ra,>01*256                 ; CMP #1            ; If A is not 1 (i.e. the item we've just bought is not
     A378 0100     
21391 A37A 160E  14        jne  et1_                       ; BNE et1           ; a missile), skip to et1
21392               
21393 A37C D3A0  30        movb @NOMSL,rx                  ; LDX NOMSL         ; Fetch the current number of missiles from NOMSL into X
     A37E 0333     
21394               
21395 A380 B387  18        ab   rone,rx                    ; INX               ; Increment X to the new number of missiles
21396               
21397 A382 020F  20        li   ry,>75*256                 ; LDY #117          ; Set Y to recursive token 117 ("ALL")
     A384 7500     
21398               
21399 A386 028E  22        ci   rx,>05*256                 ; CPX #5            ; If buying this missile would give us 5 missiles, this
     A388 0500     
21400 A38A 1856  14        joc  pres_                      ; BCS pres          ; is more than the maximum of 4 missiles that we can
21401                                                                          ; fit, so jump to pres to show the error "All Present",
21402                                                                          ; beep and exit to the docking bay (i.e. show the Status
21403                                                                          ; Mode screen)
21404               
21405 A38C D80E  30        movb rx,@NOMSL                  ; STX NOMSL         ; Otherwise update the number of missiles in NOMSL
     A38E 0333     
21406               
21407 A390 0200  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     A392 C08C     
21408 A394 06A0  32        bl   @jsr                       ;
     A396 FE28     
21409                                                                          ; them are targeted
21410               
21411               et1_:
21412 A398 020F  20        li   ry,>6b*256                 ; LDY #107          ; Set Y to recursive token 107 ("LARGE CARGO{sentence
     A39A 6B00     
21413                                                                          ; case} BAY")
21414               
21415 A39C 028D  22        ci   ra,>02*256                 ; CMP #2            ; If A is not 2 (i.e. the item we've just bought is not
     A39E 0200     
21416 A3A0 1607  14        jne  et2_                       ; BNE et2           ; a large cargo bay), skip to et2
21417               
21418 A3A2 020E  20        li   rx,>25*256                 ; LDX #37           ; If our current cargo capacity in CRGO is 37, then we
     A3A4 2500     
21419 A3A6 93A0  30        cb   @CRGO,rx                   ; CPX CRGO          ; already have a large cargo bay fitted, so jump to pres
     A3A8 0316     
21420 A3AA 1346  14        jeq  pres_                      ; BEQ pres          ; to show the error "Large Cargo Bay Present", beep and
21421                                                                          ; exit to the docking bay (i.e. show the Status Mode
21422                                                                          ; screen)
21423               
21424 A3AC D80E  30        movb rx,@CRGO                   ; STX CRGO          ; Otherwise we just scored ourselves a large cargo bay,
     A3AE 0316     
21425                                                                          ; so update our current cargo capacity in CRGO to 37
21426               
21427               et2_:
21428 A3B0 028D  22        ci   ra,>03*256                 ; CMP #3            ; If A is not 3 (i.e. the item we've just bought is not
     A3B2 0300     
21429 A3B4 1605  14        jne  et3_                       ; BNE et3           ; an E.C.M. system), skip to et3
21430               
21431 A3B6 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 108 ("E.C.M.SYSTEM")
21432               
21433 A3B8 D3A0  30        movb @ECM,rx                    ; LDX ECM           ; If we already have an E.C.M. fitted (i.e. ECM is
     A3BA 0328     
21434 A3BC 163D  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "E.C.M.
21435                                                                          ; System Present", beep and exit to the docking bay
21436                                                                          ; (i.e. show the Status Mode screen)
21437               
21438 A3BE 7347  18        sb   rone,ra                    ; DEC ECM           ; Otherwise we just took delivery of a brand new E.C.M.
21439                                                                          ; system, so set ECM to &FF (as ECM was 0 before the DEC
21440                                                                          ; instruction)
21441               
21442               et3_:
21443 A3C0 028D  22        ci   ra,>04*256                 ; CMP #4            ; If A is not 4 (i.e. the item we've just bought is not
     A3C2 0400     
21444 A3C4 1612  14        jne  et4_                       ; BNE et4           ; an extra pulse laser), skip to et4
21445               
21446 A3C6 0200  20        li   rtmp,qv_                   ; JSR qv            ; Print a menu listing the four views, with a "View ?"
     A3C8 A53A     
21447 A3CA 06A0  32        bl   @jsr                       ;
     A3CC FE28     
21448                                                                          ; prompt, and ask for a view number, which is returned
21449                                                                          ; in X (which now contains 0-3)
21450               
21451 A3CE 020D  20        li   ra,>04*256                 ; LDA #4            ; This instruction doesn't appear to do anything, as we
     A3D0 0400     
21452                                                                          ; either don't need it (if we already have this laser)
21453                                                                          ; or we set A to 4 below (if we buy it)
21454               
21455 A3D2 D3EE  34        movb @LASER(rx),ry              ; LDY LASER,X       ; If there is no laser mounted in the chosen view (i.e.
     A3D4 0310     
21456 A3D6 1303  14        jeq  ed4_                       ; BEQ ed4           ; LASER+X, which contains the laser power for view X, is
21457                                                                          ; zero), jump to ed4 to buy a pulse laser
21458               
21459               ed7_:
21460 A3D8 020F  20        li   ry,>bb*256                 ; LDY #187          ; Otherwise we already have a laser mounted in this
     A3DA BB00     
21461 A3DC 162D  14        jne  pres_                      ; BNE pres          ; view, so jump to pres with Y set to token 27
21462                                                                          ; (" LASER") to show the error "Laser Present", beep
21463                                                                          ; and exit to the docking bay (i.e. show the Status
21464                                                                          ; Mode screen)
21465               
21466               ed4_:
21467 A3DE 020D  20        li   ra,(POW)*256               ; LDA #POW          ; We just bought a pulse laser for view X, so we need
     A3E0 0F00     
21468 A3E2 DB8D  38        movb ra,@LASER(rx)              ; STA LASER,X       ; to fit it by storing the laser power for a pulse laser
     A3E4 0310     
21469                                                                          ; (given in POW) in LASER+X
21470               
21471 A3E6 020D  20        li   ra,>04*256                 ; LDA #4            ; Set A to 4 as we just overwrote the original value,
     A3E8 0400     
21472                                                                          ; and we still need it set correctly so we can continue
21473                                                                          ; through the conditional statements for all the other
21474                                                                          ; equipment
21475               
21476               et4_:
21477 A3EA 028D  22        ci   ra,>05*256                 ; CMP #5            ; If A is not 5 (i.e. the item we've just bought is not
     A3EC 0500     
21478 A3EE 161C  14        jne  et5_                       ; BNE et5           ; an extra beam laser), skip to et5
21479               
21480 A3F0 0200  20        li   rtmp,qv_                   ; JSR qv            ; Print a menu listing the four views, with a "View ?"
     A3F2 A53A     
21481 A3F4 06A0  32        bl   @jsr                       ;
     A3F6 FE28     
21482                                                                          ; prompt, and ask for a view number, which is returned
21483                                                                          ; in X (which now contains 0-3)
21484               
21485 A3F8 D80E  30        movb rx,@T1                     ; STX T1            ; Store the view in T1 so we can retrieve it below
     A3FA 0006     
21486               
21487 A3FC 020D  20        li   ra,>05*256                 ; LDA #5            ; Set A to 5 as the call to qv will have overwritten
     A3FE 0500     
21488                                                                          ; the original value, and we still need it set
21489                                                                          ; correctly so we can continue through the conditional
21490                                                                          ; statements for all the other equipment
21491               
21492 A400 D3EE  34        movb @LASER(rx),ry              ; LDY LASER,X       ; If there is no laser mounted in the chosen view (i.e.
     A402 0310     
21493 A404 130B  14        jeq  ed5_                       ; BEQ ed5           ; LASER+X, which contains the laser power for view X,
21494                                                                          ; is zero), jump to ed5 to buy a beam laser
21495               
21496               * BPL P%+4               \ This instruction is commented out in the original
21497                                                                          ; source, though it would have no effect (it would
21498                                                                          ; simply skip the BMI if A is positive, which is what
21499                                                                          ; BMI does anyway)
21500               
21501 A406 11E8  14        jlt  ed7_                       ; BMI ed7           ; If there is a beam laser already mounted in the chosen
21502                                                                          ; view (i.e. LASER+X has bit 7 set, which indicates a
21503                                                                          ; beam laser rather than a pulse laser), skip back to
21504                                                                          ; ed7 to print a "Laser Present" error, beep and exit
21505                                                                          ; to the docking bay (i.e. show the Status Mode screen)
21506               
21507 A408 020D  20        li   ra,>04*256                 ; LDA #4            ; If we get here then we already have a pulse laser in
     A40A 0400     
21508 A40C 0200  20        li   rtmp,prx_                  ; JSR prx           ; the selected view, so we call prx to set (Y X) to the
     A40E A524     
21509 A410 06A0  32        bl   @jsr                       ;
     A412 FE28     
21510                                                                          ; price of equipment item number 4 (extra pulse laser)
21511                                                                          ; so we can give a refund of the pulse laser
21512               
21513 A414 0200  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH, so we refund
     A416 A1BE     
21514 A418 06A0  32        bl   @jsr                       ;
     A41A FE28     
21515                                                                          ; the price of the pulse laser we are exchanging for a
21516                                                                          ; new beam laser
21517               
21518               ed5_:
21519 A41C 020D  20        li   ra,(POW+128)*256           ; LDA #POW+128      ; We just bought a beam laser for view X, so we need
     A41E 8F00     
21520 A420 D3A0  30        movb @T1,rx                     ; LDX T1            ; to fit it by storing the laser power for a beam laser
     A422 0006     
21521 A424 DB8D  38        movb ra,@LASER(rx)              ; STA LASER,X       ; (given in POW+128) in LASER+X, using the view number
     A426 0310     
21522                                                                          ; we stored in T1 earlier, as the call to prx will have
21523                                                                          ; overwritten the original value in X
21524               
21525               et5_:
21526 A428 020F  20        li   ry,>6f*256                 ; LDY #111          ; Set Y to recursive token 107 ("FUEL SCOOPS")
     A42A 6F00     
21527               
21528 A42C 028D  22        ci   ra,>06*256                 ; CMP #6            ; If A is not 6 (i.e. the item we've just bought is not
     A42E 0600     
21529 A430 1620  14        jne  et6_                       ; BNE et6           ; a fuel scoop), skip to et6
21530               
21531 A432 D3A0  30        movb @BST,rx                    ; LDX BST           ; If we already have fuel scoops fitted (i.e. BST is
     A434 0329     
21532 A436 131C  14        jeq  ed9_                       ; BEQ ed9           ; zero), jump to ed9, otherwise fall through into pres
21533                                                                          ; to show the error "Fuel Scoops Present", beep and
21534                                                                          ; exit to the docking bay (i.e. show the Status Mode
21535                                                                          ; screen)
21536               
21537               pres_:
21538                                                                          ; If we get here we need to show an error to say that
21539                                                                          ; the item whose name is in recursive token Y is already
21540                                                                          ; present, and then process a refund for the cost of
21541                                                                          ; item number A
21542 A438 D80F  30        movb ry,@K                      ; STY K             ; Store the item's name in K
     A43A 003D     
21543               
21544 A43C 0200  20        li   rtmp,prx_                  ; JSR prx           ; Call prx to set (Y X) to the price of equipment item
     A43E A524     
21545 A440 06A0  32        bl   @jsr                       ;
     A442 FE28     
21546                                                                          ; number A
21547               
21548 A444 0200  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH, as the station
     A446 A1BE     
21549 A448 06A0  32        bl   @jsr                       ;
     A44A FE28     
21550                                                                          ; already took the money for this item in the JSR eq
21551                                                                          ; instruction above, but we can't fit the item, so need
21552                                                                          ; our money back
21553               
21554 A44C D360  30        movb @K,ra                      ; LDA K             ; Print the recursive token in K (the item's name)
     A44E 003D     
21555 A450 0200  20        li   rtmp,spc_                  ; JSR spc           ; followed by a space
     A452 4FBE     
21556 A454 06A0  32        bl   @jsr                       ;
     A456 FE28     
21557               
21558 A458 020D  20        li   ra,>1f*256                 ; LDA #31           ; Print recursive token 145 ("PRESENT")
     A45A 1F00     
21559 A45C 0200  20        li   rtmp,TT27                  ; JSR TT27
     A45E A6E8     
21560 A460 06A0  32        bl   @jsr                       ;
     A462 FE28     
21561               
21562               err_:
21563 A464 0200  20        li   rtmp,dn2_                  ; JSR dn2           ; Call dn2 to make a short, high beep and delay for 1
     A466 A4E8     
21564 A468 06A0  32        bl   @jsr                       ;
     A46A FE28     
21565                                                                          ; second
21566               
21567 A46C 0460  28        b    @BAY                       ; JMP BAY           ; Jump to BAY to go to the docking bay (i.e. show the
     A46E C704     
21568                                                                          ; Status Mode screen)
21569               
21570               ed9_:
21571 A470 7347  18        sb   rone,ra                    ; DEC BST           ; We just bought a shiny new fuel scoop, so set BST to
21572                                                                          ; &FF (as BST was 0 before the jump to ed9 above)
21573               
21574               et6_:
21575 A472 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 112 ("E.C.M.SYSTEM")
21576               
21577 A474 028D  22        ci   ra,>07*256                 ; CMP #7            ; If A is not 7 (i.e. the item we've just bought is not
     A476 0700     
21578 A478 1604  14        jne  et7_                       ; BNE et7           ; an escape pod), skip to et7
21579               
21580 A47A D3A0  30        movb @ESCP,rx                   ; LDX ESCP          ; If we already have an escape pod fitted (i.e. ESCP is
     A47C 032E     
21581 A47E 16DC  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "Escape Pod
21582                                                                          ; Present", beep and exit to the docking bay (i.e. show
21583                                                                          ; the Status Mode screen)
21584               
21585 A480 7347  18        sb   rone,ra                    ; DEC ESCP          ; Otherwise we just bought an escape pod, so set ESCP
21586                                                                          ; to &FF (as ESCP was 0 before the DEC instruction)
21587               
21588               et7_:
21589 A482 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 113 ("ENERGY BOMB")
21590               
21591 A484 028D  22        ci   ra,>08*256                 ; CMP #8            ; If A is not 8 (i.e. the item we've just bought is not
     A486 0800     
21592 A488 1607  14        jne  et8_                       ; BNE et8           ; an energy bomb), skip to et8
21593               
21594 A48A D3A0  30        movb @BOMB,rx                   ; LDX BOMB          ; If we already have an energy bomb fitted (i.e. BOMB
     A48C 032A     
21595 A48E 16D4  14        jne  pres_                      ; BNE pres          ; is non-zero), jump to pres to show the error "Energy
21596                                                                          ; Bomb Present", beep and exit to the docking bay (i.e.
21597                                                                          ; show the Status Mode screen)
21598               
21599 A490 020E  20        li   rx,>7f*256                 ; LDX #&7F          ; Otherwise we just bought an energy bomb, so set BOMB
     A492 7F00     
21600 A494 D80E  30        movb rx,@BOMB                   ; STX BOMB          ; to &7F
     A496 032A     
21601               
21602               et8_:
21603 A498 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 114 ("ENERGY UNIT")
21604               
21605 A49A 028D  22        ci   ra,>09*256                 ; CMP #9            ; If A is not 9 (i.e. the item we've just bought is not
     A49C 0900     
21606 A49E 1604  14        jne  etA                        ; BNE etA           ; an energy unit), skip to etA
21607               
21608 A4A0 D3A0  30        movb @ENGY,rx                   ; LDX ENGY          ; If we already have an energy unit fitted (i.e. ENGY is
     A4A2 032B     
21609 A4A4 16C9  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "Energy Unit
21610                                                                          ; Present", beep and exit to the docking bay (i.e. show
21611                                                                          ; the Status Mode screen)
21612               
21613 A4A6 B347  18        ab   rone,ra                    ; INC ENGY          ; Otherwise we just picked up an energy unit, so set
21614                                                                          ; ENGY to 1 (as ENGY was 0 before the INC instruction)
21615               
21616               etA:
21617 A4A8 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 115 ("DOCKING
21618                                                                          ; COMPUTERS")
21619               
21620 A4AA 028D  22        ci   ra,>0a*256                 ; CMP #10           ; If A is not 10 (i.e. the item we've just bought is not
     A4AC 0A00     
21621 A4AE 1604  14        jne  etB                        ; BNE etB           ; a docking computer), skip to etB
21622               
21623 A4B0 D3A0  30        movb @DKCMP,rx                  ; LDX DKCMP         ; If we already have a docking computer fitted (i.e.
     A4B2 032C     
21624 A4B4 16C1  14        jne  pres_                      ; BNE pres          ; DKCMP is non-zero), jump to pres to show the error
21625                                                                          ; "Docking Computer Present", beep and exit to the
21626                                                                          ; docking bay (i.e. show the Status Mode screen)
21627               
21628 A4B6 7347  18        sb   rone,ra                    ; DEC DKCMP         ; Otherwise we just got hold of a docking computer, so
21629                                                                          ; set DKCMP to &FF (as DKCMP was 0 before the DEC
21630                                                                          ; instruction)
21631               
21632               etB:
21633 A4B8 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 116 ("GALACTIC
21634                                                                          ; HYPERSPACE ")
21635               
21636 A4BA 028D  22        ci   ra,>0b*256                 ; CMP #11           ; If A is not 11 (i.e. the item we've just bought is not
     A4BC 0B00     
21637 A4BE 1604  14        jne  et9_                       ; BNE et9           ; a galactic hyperdrive), skip to et9
21638               
21639 A4C0 D3A0  30        movb @GHYP,rx                   ; LDX GHYP          ; If we already have a galactic hyperdrive fitted (i.e.
     A4C2 032D     
21640 A4C4 16B9  14        jne  pres_                      ; BNE pres          ; GHYP is non-zero), jump to pres to show the error
21641                                                                          ; "Galactic Hyperspace Present", beep and exit to the
21642                                                                          ; docking bay (i.e. show the Status Mode screen)
21643               
21644 A4C6 7347  18        sb   rone,ra                    ; DEC GHYP          ; Otherwise we just splashed out on a galactic
21645                                                                          ; hyperdrive, so set GHYP to &FF (as GHYP was 0 before
21646                                                                          ; the DEC instruction)
21647               
21648               et9_:
21649 A4C8 0200  20        li   rtmp,dn_                   ; JSR dn            ; We are done buying equipment, so print the amount of
     A4CA A4D4     
21650 A4CC 06A0  32        bl   @jsr                       ;
     A4CE FE28     
21651                                                                          ; cash left in the cash pot, then make a short, high
21652                                                                          ; beep to confirm the purchase, and delay for 1 second
21653               
21654 A4D0 0460  28        b    @EQSHP                     ; JMP EQSHP         ; Jump back up to EQSHP to show the Equip Ship screen
     A4D2 A23C     
21655                                                                          ; again and see if we can't track down another bargain
21656               
21657               * ******************************************************************************
21658               *
21659               * Name: dn
21660               * Type: Subroutine
21661               * Category: Market
21662               * Summary: Print the amount of money we have left in the cash pot, then make
21663               * a short, high beep and delay for 1 second
21664               *
21665               * ******************************************************************************
21666               
21667               dn_:
21668 A4D4 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     A4D6 5F24     
21669 A4D8 06A0  32        bl   @jsr                       ;
     A4DA FE28     
21670               
21671 A4DC 020D  20        li   ra,>77*256                 ; LDA #119          ; Print recursive token 119 ("CASH:{cash} CR{crlf}")
     A4DE 7700     
21672 A4E0 0200  20        li   rtmp,spc_                  ; JSR spc           ; followed by a space
     A4E2 4FBE     
21673 A4E4 06A0  32        bl   @jsr                       ;
     A4E6 FE28     
21674               
21675                                                                          ; Fall through into dn2 to make a beep and delay for
21676                                                                          ; 1 second before returning from the subroutine
21677               
21678               * ******************************************************************************
21679               *
21680               * Name: dn2
21681               * Type: Subroutine
21682               * Category: Text
21683               * Summary: Make a short, high beep and delay for 1 second
21684               *
21685               * ******************************************************************************
21686               
21687               dn2_:
21688 A4E8 0200  20        li   rtmp,BEEP                  ; JSR BEEP          ; Call the BEEP subroutine to make a short, high beep
     A4EA CC58     
21689 A4EC 06A0  32        bl   @jsr                       ;
     A4EE FE28     
21690               
21691 A4F0 020F  20        li   ry,>32*256                 ; LDY #50           ; Delay for 50 vertical syncs (50/50 = 1 second) and
     A4F2 3200     
21692 A4F4 0460  28        b    @DELAY                     ; JMP DELAY         ; return from the subroutine using a tail call
     A4F6 4CB4     
21693               
21694               * ******************************************************************************
21695               *
21696               * Name: eq
21697               * Type: Subroutine
21698               * Category: Equipment
21699               * Summary: Subtract the price of equipment from the cash pot
21700               *
21701               * ------------------------------------------------------------------------------
21702               *
21703               * If we have enough cash, subtract the price of a specified piece of equipment
21704               * from our cash pot and return from the subroutine. If we don't have enough
21705               * cash, exit to the docking bay (i.e. show the Status Mode screen).
21706               *
21707               * ------------------------------------------------------------------------------
21708               *
21709               * Arguments:
21710               *
21711               * A                   The item number of the piece of equipment (0-11) as
21712               * shown in the table at PRXS
21713               *
21714               * ******************************************************************************
21715               
21716               eq_:
21717 A4F8 0200  20        li   rtmp,prx_                  ; JSR prx           ; Call prx to set (Y X) to the price of equipment item
     A4FA A524     
21718 A4FC 06A0  32        bl   @jsr                       ;
     A4FE FE28     
21719                                                                          ; number A
21720               
21721 A500 0200  20        li   rtmp,LCASH                 ; JSR LCASH         ; Subtract (Y X) cash from the cash pot, but only if
     A502 A172     
21722 A504 06A0  32        bl   @jsr                       ;
     A506 FE28     
21723                                                                          ; we have enough cash
21724               
21725 A508 1816  14        joc  c_                         ; BCS c             ; If the C flag is set then we did have enough cash for
21726                                                                          ; the transaction, so jump to c to return from the
21727                                                                          ; subroutine (as c contains an RTS)
21728               
21729 A50A 020D  20        li   ra,>c5*256                 ; LDA #197          ; Otherwise we don't have enough cash to buy this piece
     A50C C500     
21730 A50E 0200  20        li   rtmp,prq_                  ; JSR prq           ; of equipment, so print recursive token 37 ("CASH")
     A510 5E12     
21731 A512 06A0  32        bl   @jsr                       ;
     A514 FE28     
21732                                                                          ; followed by a question mark
21733               
21734 A516 0460  28        b    @err_                      ; JMP err           ; Jump to err to beep, pause and go to the docking bay
     A518 A464     
21735                                                                          ; (i.e. show the Status Mode screen)
21736               
21737               * ******************************************************************************
21738               *
21739               * Name: prx
21740               * Type: Subroutine
21741               * Category: Equipment
21742               * Summary: Return the price of a piece of equipment
21743               *
21744               * ------------------------------------------------------------------------------
21745               *
21746               * This routine returns the price of equipment as listed in the table at PRXS.
21747               *
21748               * ------------------------------------------------------------------------------
21749               *
21750               * Arguments:
21751               *
21752               * A                   The item number of the piece of equipment (0-11) as
21753               * shown in the table at PRXS
21754               *
21755               * ------------------------------------------------------------------------------
21756               *
21757               * Returns:
21758               *
21759               * (Y X)               The item price in Cr * 10 (Y = high byte, X = low byte)
21760               *
21761               * ------------------------------------------------------------------------------
21762               *
21763               * Other entry points:
21764               *
21765               * prx-3               Return the price of the item with number A - 1
21766               *
21767               * c                   Contains an RTS
21768               *
21769               * ******************************************************************************
21770               
21771                      .sec                            ; SEC               ; Decrement A (for when this routine is called via
     **** ****     > SEC
0001 A51A 0A18  18        sla  rmone,1
                   < elite.a99
21772                      .sbi (>01*256)                  ; SBC #1            ; prx-3)
     **** ****     > SBI
0001 A51C 1801  14        joc  !
0002 A51E 7347  18        sb   rone,ra
0003               !:
0004 A520 022D  22        ai   ra,-(>01*256)
     A522 FF00     
                   < elite.a99
21773               
21774               prx_:
21775                      .asla                           ; ASL A             ; Set Y = A * 2, so it can act as an index into the
     **** ****     > ASLA
0001 A524 024D  22        andi ra,>ff00
     A526 FF00     
0002 A528 0A1D  18        sla  ra,1
                   < elite.a99
21776 A52A D3CD  18        movb ra,ry                      ; TAY               ; PRXS table, which has two bytes per entry
21777               
21778 A52C D3AF  34        movb @PRXS(ry),rx               ; LDX PRXS,Y        ; Fetch the low byte of the price into X
     A52E 2E40     
21779               
21780 A530 D36F  34        movb @PRXS+1(ry),ra             ; LDA PRXS+1,Y      ; Fetch the high byte of the price into A and transfer
     A532 2E41     
21781 A534 D3CD  18        movb ra,ry                      ; TAY               ; it to X, so the price is now in (Y X)
21782               
21783               c_:
21784 A536 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A538 FE34     
21785               
21786               * ******************************************************************************
21787               *
21788               * Name: qv
21789               * Type: Subroutine
21790               * Category: Equipment
21791               * Summary: Print a menu of the four space views, for buying lasers
21792               *
21793               * ------------------------------------------------------------------------------
21794               *
21795               * Print a menu in the bottom-middle of the screen, at row 16, column 12, that
21796               * lists the four available space views, like this:
21797               *
21798               * 0 Front
21799               * 1 Rear
21800               * 2 Left
21801               * 3 Right
21802               *
21803               * Also print a "View ?" prompt and ask for a view number. The menu is shown
21804               * when we choose to buy a new laser in the Equip Ship screen.
21805               *
21806               * ------------------------------------------------------------------------------
21807               *
21808               * Returns:
21809               *
21810               * X                   The chosen view number (0-3)
21811               *
21812               * ******************************************************************************
21813               
21814               qv_:
21815 A53A 020F  20        li   ry,>10*256                 ; LDY #16           ; Move the text cursor to row 16, and at the same time
     A53C 1000     
21816 A53E D80F  30        movb ry,@YC                     ; STY YC            ; set Y to a counter going from 16 to 19 in the loop
     A540 002D     
21817                                                                          ; below
21818               
21819               qv1_:
21820 A542 020E  20        li   rx,>0c*256                 ; LDX #12           ; Move the text cursor to column 12
     A544 0C00     
21821 A546 D80E  30        movb rx,@XC                     ; STX XC
     A548 002C     
21822               
21823 A54A D34F  18        movb ry,ra                      ; TYA               ; Transfer the counter value from Y to A
21824               
21825                      .clc                            ; CLC               ; Print ASCII character "0" - 16 + A, so as A goes from
     **** ****     > CLC
0001 A54C 0A16  18        sla  rzero,1
                   < elite.a99
21826                      .adi (('0'-16)*256)             ; ADC #'0'-16       ; 16 to 19, this prints "0" through "3" followed by a
     **** ****     > ADI
0001 A54E 1701  14        jnc  !
0002 A550 B347  18        ab   rone,ra
0003               !:
0004 A552 022D  22        ai   ra,(('0'-16)*256)
     A554 2000     
                   < elite.a99
21827 A556 0200  20        li   rtmp,spc_                  ; JSR spc           ; space
     A558 4FBE     
21828 A55A 06A0  32        bl   @jsr                       ;
     A55C FE28     
21829               
21830 A55E D360  30        movb @YC,ra                     ; LDA YC            ; Print recursive text token 80 + YC, so as YC goes from
     A560 002D     
21831                      .clc                            ; CLC               ; 16 to 19, this prints "FRONT", "REAR", "LEFT" and
     **** ****     > CLC
0001 A562 0A16  18        sla  rzero,1
                   < elite.a99
21832                      .adi (>50*256)                  ; ADC #80           ; "RIGHT"
     **** ****     > ADI
0001 A564 1701  14        jnc  !
0002 A566 B347  18        ab   rone,ra
0003               !:
0004 A568 022D  22        ai   ra,(>50*256)
     A56A 5000     
                   < elite.a99
21833 A56C 0200  20        li   rtmp,TT27                  ; JSR TT27
     A56E A6E8     
21834 A570 06A0  32        bl   @jsr                       ;
     A572 FE28     
21835               
21836 A574 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a row, and increment the
21837                                                                          ; counter in YC at the same time
21838               
21839 A576 D3E0  30        movb @YC,ry                     ; LDY YC            ; Update Y with the incremented counter in YC
     A578 002D     
21840               
21841 A57A 028F  22        ci   ry,>14*256                 ; CPY #20           ; If Y < 20 then loop back up to qv1 to print the next
     A57C 1400     
21842 A57E 17E1  14        jnc  qv1_                       ; BCC qv1           ; view in the menu
21843               
21844               qv3_:
21845 A580 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     A582 4CE2     
21846 A584 06A0  32        bl   @jsr                       ;
     A586 FE28     
21847                                                                          ; and move the text cursor to column 1 on row 21, i.e.
21848                                                                          ; the start of the top row of the three bottom rows
21849               
21850               qv2_:
21851 A588 020D  20        li   ra,>af*256                 ; LDA #175          ; Print recursive text token 15 ("VIEW ") followed by
     A58A AF00     
21852 A58C 0200  20        li   rtmp,prq_                  ; JSR prq           ; a question mark
     A58E 5E12     
21853 A590 06A0  32        bl   @jsr                       ;
     A592 FE28     
21854               
21855 A594 0200  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     A596 CEAC     
21856 A598 06A0  32        bl   @jsr                       ;
     A59A FE28     
21857                                                                          ; the key's ASCII code in A (and X)
21858               
21859                      .sec                            ; SEC               ; Subtract ASCII "0" from the key pressed, to leave the
     **** ****     > SEC
0001 A59C 0A18  18        sla  rmone,1
                   < elite.a99
21860                      .sbi (('0')*256)                ; SBC #'0'          ; numeric value of the key in A (if it was a number key)
     **** ****     > SBI
0001 A59E 1801  14        joc  !
0002 A5A0 7347  18        sb   rone,ra
0003               !:
0004 A5A2 022D  22        ai   ra,-(('0')*256)
     A5A4 D000     
                   < elite.a99
21861               
21862 A5A6 028D  22        ci   ra,>04*256                 ; CMP #4            ; If the number entered in A >= 4, then it is not a
     A5A8 0400     
21863 A5AA 18EA  14        joc  qv3_                       ; BCS qv3           ; valid view number, so jump back to qv3 to try again
21864               
21865 A5AC D38D  18        movb ra,rx                      ; TAX               ; We have a valid view number, so transfer it to X
21866               
21867 A5AE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A5B0 FE34     
21868               
21869               * ******************************************************************************
21870               *
21871               * Save ELTD.bin
21872               *
21873               * ******************************************************************************
21874               
21875                      ; PRINT "ELITE D"
21876                      ; PRINT "Assembled at ", ~CODE_D%
21877                      ; PRINT "Ends at ", ~P%
21878                      ; PRINT "Code size is ", ~(P% - CODE_D%)
21879                      ; PRINT "Execute at ", ~LOAD%
21880                      ; PRINT "Reload at ", ~LOAD_D%
21881               
21882                      ; PRINT "S.ELTD ", ~CODE_D%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_D%
21883                      ; SAVE "3-assembled-output/ELTD.bin", CODE_D%, P%, LOAD%
21884               
21885               * ******************************************************************************
21886               *
21887               * ELITE E FILE
21888               *
21889               * Produces the binary file ELTE.bin that gets loaded by elite-bcfs.asm.
21890               *
21891               * ******************************************************************************
21892               
21893               CODE_E.:
21894                      equ $
21895               
21896               LOAD_E.:
21897                      equ LOAD. + $ - CODE.
21898               
21899               * ******************************************************************************
21900               *
21901               * Name: Authors' names
21902               * Type: Variable
21903               * Category: Copy protection
21904               * Summary: The authors' names and a copyright notice, buried in the code
21905               *
21906               * ------------------------------------------------------------------------------
21907               *
21908               * This copyright notice is not used anywhere and it is obfuscated by EOR'ing
21909               * each character with 164, but presumably the authors wanted their names buried
21910               * in the code somewhere. Though they do also have recursive token 94, which
21911               * reads "BY D.BRABEN & I.BELL" and can be displayed on the title screen using
21912               * the "X" configuration option, so this isn't the only author name easter egg
21913               * in the game. It contains the following text:
21914               *
21915               * (C)Bell/Braben1984
21916               *
21917               * ******************************************************************************
21918               
21919 A5B2 8C              byte '(' ^ 164
21920 A5B3   E7            byte 'C' ^ 164
21921 A5B4 8D              byte ')' ^ 164
21922 A5B5   E6            byte 'B' ^ 164
21923 A5B6 C1              byte 'e' ^ 164
21924 A5B7   C8            byte 'l' ^ 164
21925 A5B8 C8              byte 'l' ^ 164
21926 A5B9   8B            byte '/' ^ 164
21927 A5BA E6              byte 'B' ^ 164
21928 A5BB   D6            byte 'r' ^ 164
21929 A5BC C5              byte 'a' ^ 164
21930 A5BD   C6            byte 'b' ^ 164
21931 A5BE C1              byte 'e' ^ 164
21932 A5BF   CA            byte 'n' ^ 164
21933 A5C0 95              byte '1' ^ 164
21934 A5C1   9D            byte '9' ^ 164
21935 A5C2 9C              byte '8' ^ 164
21936 A5C3   90            byte '4' ^ 164
21937               
21938               * ******************************************************************************
21939               *
21940               * Name: cpl
21941               * Type: Subroutine
21942               * Category: Universe
21943               * Summary: Print the selected system name
21944               * Deep dive: Generating system names
21945               * Galaxy and system seeds
21946               *
21947               * ------------------------------------------------------------------------------
21948               *
21949               * Print control code 3 (the selected system name, i.e. the one in the crosshairs
21950               * in the Short-range Chart).
21951               *
21952               * ******************************************************************************
21953               
21954               cpl_:
21955 A5C4 020E  20        li   rx,>05*256                 ; LDX #5            ; First we need to back up the seeds in QQ15, so set up
     A5C6 0500     
21956                                                                          ; a counter in X to cover three 16-bit seeds (i.e.
21957                                                                          ; 6 bytes)
21958               
21959               TT53:
21960 A5C8 D36E  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy byte X from QQ15 to QQ19
     A5CA 0078     
21961 A5CC DB8D  38        movb ra,@QQ19(rx)               ; STA QQ19,X
     A5CE 007F     
21962               
21963 A5D0 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
21964               
21965 A5D2 15FA  14        jgt  TT53                       ; BPL TT53          ; Loop back for the next byte to back up
21966               
21967 A5D4 020F  20        li   ry,>03*256                 ; LDY #3            ; Step 1: Now that the seeds are backed up, we can
     A5D6 0300     
21968                                                                          ; start the name-generation process. We will either
21969                                                                          ; need to loop three or four times, so for now set
21970                                                                          ; up a counter in Y to loop four times
21971               
21972                      .bit @QQ15                      ; BIT QQ15          ; Check bit 6 of s0_lo, which is stored in QQ15
     **** ****     > BIT
0001 A5D8 D020  30        movb @QQ15,rtmp
     A5DA 0078     
0002 A5DC 0540  14        inv  rtmp
0003 A5DE D047  18        movb rone,rtmp2
0004 A5E0 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
21973               
21974                      .bvs B59                        ; BVS B59           ; If bit 6 is set then skip over the next instruction
     **** ****     > BVS
0001 A5E2 1801  14        joc  !
0002 A5E4 1001  14        jmp  B59
0003               !:
                   < elite.a99
21975               
21976 A5E6 73C7  18        sb   rone,ry                    ; DEY               ; Bit 6 is clear, so we only want to loop three times,
21977                                                                          ; so decrement the loop counter in Y
21978               
21979               B59:
21980 A5E8 D80F  30        movb ry,@T                      ; STY T             ; Store the loop counter in T
     A5EA 00D1     
21981               
21982               TT55:
21983 A5EC D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Step 2: Load s2_hi, which is stored in QQ15+5, and
     A5EE 007D     
21984 A5F0 024D  22        andi ra,>1f*256                 ; AND #%00011111    ; extract bits 0-4 by AND'ing with %11111
     A5F2 1F00     
21985               
21986 A5F4 1306  14        jeq  B60                        ; BEQ B60           ; If all those bits are zero, then skip the following
21987                                                                          ; two instructions to go to step 3
21988               
21989 A5F6 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now have a number in the range 1-31, which we can
     A5F8 8000     
21990                                                                          ; easily convert into a two-letter token, but first we
21991                                                                          ; need to add 128 (or set bit 7) to get a range of
21992                                                                          ; 129-159
21993               
21994 A5FA 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the two-letter token in A
     A5FC A6E8     
21995 A5FE 06A0  32        bl   @jsr                       ;
     A600 FE28     
21996               
21997               B60:
21998 A602 0200  20        li   rtmp,TT54                  ; JSR TT54          ; Step 3: twist the seeds in QQ15
     A604 4F02     
21999 A606 06A0  32        bl   @jsr                       ;
     A608 FE28     
22000               
22001 A60A 7347  18        sb   rone,ra                    ; DEC T             ; Decrement the loop counter
22002               
22003 A60C 15EF  14        jgt  TT55                       ; BPL TT55          ; Loop back for the next two letters
22004               
22005 A60E 020E  20        li   rx,>05*256                 ; LDX #5            ; We have printed the system name, so we can now
     A610 0500     
22006                                                                          ; restore the seeds we backed up earlier. Set up a
22007                                                                          ; counter in X to cover three 16-bit seeds (i.e. 6
22008                                                                          ; bytes)
22009               
22010               TT56:
22011 A612 D36E  34        movb @QQ19(rx),ra               ; LDA QQ19,X        ; Copy byte X from QQ19 to QQ15
     A614 007F     
22012 A616 DB8D  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     A618 0078     
22013               
22014 A61A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22015               
22016 A61C 15FA  14        jgt  TT56                       ; BPL TT56          ; Loop back for the next byte to restore
22017               
22018 A61E 0460  28        b    @rts                       ; RTS               ; Once all the seeds are restored, return from the
     A620 FE34     
22019                                                                          ; subroutine
22020               
22021               * ******************************************************************************
22022               *
22023               * Name: cmn
22024               * Type: Subroutine
22025               * Category: Status
22026               * Summary: Print the commander's name
22027               *
22028               * ------------------------------------------------------------------------------
22029               *
22030               * Print control code 4 (the commander's name).
22031               *
22032               * ------------------------------------------------------------------------------
22033               *
22034               * Other entry points:
22035               *
22036               * cmn-1               Contains an RTS
22037               *
22038               * ******************************************************************************
22039               
22040               cmn_:
22041 A622 020F  20        li   ry,>00*256                 ; LDY #0            ; Set up a counter in Y, starting from 0
     A624 0000     
22042               
22043               QUL4:
22044 A626 D36F  34        movb @NA.(ry),ra                ; LDA NA%,Y         ; The commander's name is stored at NA%, so load the
     A628 21EC     
22045                                                                          ; Y-th character from NA%
22046               
22047 A62A 028D  22        ci   ra,>0d*256                 ; CMP #13           ; If we have reached the end of the name, return from
     A62C 0D00     
22048 A62E 1307  14        jeq  ypl_-1                     ; BEQ ypl-1         ; the subroutine (ypl-1 points to the RTS below)
22049               
22050 A630 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character we just loaded
     A632 31C2     
22051 A634 06A0  32        bl   @jsr                       ;
     A636 FE28     
22052               
22053 A638 B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter
22054               
22055 A63A 16F5  14        jne  QUL4                       ; BNE QUL4          ; Loop back for the next character
22056               
22057 A63C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A63E FE34     
22058               
22059               * ******************************************************************************
22060               *
22061               * Name: ypl
22062               * Type: Subroutine
22063               * Category: Universe
22064               * Summary: Print the current system name
22065               *
22066               * ------------------------------------------------------------------------------
22067               *
22068               * Print control code 2 (the current system name).
22069               *
22070               * ------------------------------------------------------------------------------
22071               *
22072               * Other entry points:
22073               *
22074               * ypl-1               Contains an RTS
22075               *
22076               * ******************************************************************************
22077               
22078               ypl_:
22079 A640 D360  30        movb @MJ,ra                     ; LDA MJ            ; Check the mis-jump flag at MJ, and if it is non-zero
     A642 0D5C     
22080 A644 16ED  14        jne  cmn_-1                     ; BNE cmn-1         ; then we are in witchspace, and witchspace doesn't have
22081                                                                          ; a system name, so return from the subroutine (cmn-1
22082                                                                          ; contains an RTS)
22083               
22084 A646 0200  20        li   rtmp,TT62                  ; JSR TT62          ; Call TT62 below to swap the three 16-bit seeds in
     A648 A656     
22085 A64A 06A0  32        bl   @jsr                       ;
     A64C FE28     
22086                                                                          ; QQ2 and QQ15 (before the swap, QQ2 contains the seeds
22087                                                                          ; for the current system, while QQ15 contains the seeds
22088                                                                          ; for the selected system)
22089               
22090 A64E 0200  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print out the system name for the seeds
     A650 A5C4     
22091 A652 06A0  32        bl   @jsr                       ;
     A654 FE28     
22092                                                                          ; in QQ15 (which now contains the seeds for the current
22093                                                                          ; system)
22094               
22095                                                                          ; Now we fall through into the TT62 subroutine, which
22096                                                                          ; will swap QQ2 and QQ15 once again, so everything goes
22097                                                                          ; back into the right place, and the RTS at the end of
22098                                                                          ; TT62 will return from the subroutine
22099               
22100               TT62:
22101 A656 020E  20        li   rx,>05*256                 ; LDX #5            ; Set up a counter in X for the three 16-bit seeds we
     A658 0500     
22102                                                                          ; want to swap (i.e. 6 bytes)
22103               
22104               TT78:
22105 A65A D36E  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Swap byte X between QQ2 and QQ15
     A65C 0078     
22106 A65E D3EE  34        movb @QQ2(rx),ry                ; LDY QQ2,X
     A660 0F22     
22107 A662 DB8D  38        movb ra,@QQ2(rx)                ; STA QQ2,X
     A664 0F22     
22108 A666 DB8F  38        movb ry,@QQ15(rx)               ; STY QQ15,X
     A668 0078     
22109               
22110 A66A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22111               
22112 A66C 15F6  14        jgt  TT78                       ; BPL TT78          ; Loop back for the next byte to swap
22113               
22114 A66E 0460  28        b    @rts                       ; RTS               ; Once all bytes are swapped, return from the
     A670 FE34     
22115                                                                          ; subroutine
22116               
22117               * ******************************************************************************
22118               *
22119               * Name: tal
22120               * Type: Subroutine
22121               * Category: Universe
22122               * Summary: Print the current galaxy number
22123               *
22124               * ------------------------------------------------------------------------------
22125               *
22126               * Print control code 1 (the current galaxy number, right-aligned to width 3).
22127               *
22128               * ******************************************************************************
22129               
22130               tal_:
22131                      .clc                            ; CLC               ; We don't want to print the galaxy number with a
     **** ****     > CLC
0001 A672 0A16  18        sla  rzero,1
                   < elite.a99
22132                                                                          ; decimal point, so clear the C flag for pr2 to take as
22133                                                                          ; an argument
22134               
22135 A674 D3A0  30        movb @GCNT,rx                   ; LDX GCNT          ; Load the current galaxy number from GCNT into X
     A676 030F     
22136               
22137 A678 B387  18        ab   rone,rx                    ; INX               ; Add 1 to the galaxy number, as the galaxy numbers
22138                                                                          ; are 0-7 internally, but we want to display them as
22139                                                                          ; galaxy 1 through 8
22140               
22141 A67A 0460  28        b    @pr2_                      ; JMP pr2           ; Jump to pr2, which prints the number in X to a width
     A67C 2FFC     
22142                                                                          ; of 3 figures, left-padding with spaces to a width of
22143                                                                          ; 3, and return from the subroutine using a tail call
22144               
22145               * ******************************************************************************
22146               *
22147               * Name: fwl
22148               * Type: Subroutine
22149               * Category: Status
22150               * Summary: Print fuel and cash levels
22151               *
22152               * ------------------------------------------------------------------------------
22153               *
22154               * Print control code 5 ("FUEL: ", fuel level, " LIGHT YEARS", newline, "CASH:",
22155               * control code 0).
22156               *
22157               * ******************************************************************************
22158               
22159               fwl_:
22160 A67E 020D  20        li   ra,>69*256                 ; LDA #105          ; Print recursive token 105 ("FUEL") followed by a
     A680 6900     
22161 A682 0200  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     A684 A6DC     
22162 A686 06A0  32        bl   @jsr                       ;
     A688 FE28     
22163               
22164 A68A D3A0  30        movb @QQ14,rx                   ; LDX QQ14          ; Load the current fuel level from QQ14
     A68C 030D     
22165               
22166                      .sec                            ; SEC               ; We want to print the fuel level with a decimal point,
     **** ****     > SEC
0001 A68E 0A18  18        sla  rmone,1
                   < elite.a99
22167                                                                          ; so set the C flag for pr2 to take as an argument
22168               
22169 A690 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; Call pr2, which prints the number in X to a width of
     A692 2FFC     
22170 A694 06A0  32        bl   @jsr                       ;
     A696 FE28     
22171                                                                          ; 3 figures (i.e. in the format x.x, which will always
22172                                                                          ; be exactly 3 characters as the maximum fuel is 7.0)
22173               
22174 A698 020D  20        li   ra,>c3*256                 ; LDA #195          ; Print recursive token 35 ("LIGHT YEARS") followed by
     A69A C300     
22175 A69C 0200  20        li   rtmp,plf_                  ; JSR plf           ; a newline
     A69E A6D0     
22176 A6A0 06A0  32        bl   @jsr                       ;
     A6A2 FE28     
22177               
22178               PCASH:
22179 A6A4 020D  20        li   ra,>77*256                 ; LDA #119          ; Print recursive token 119 ("CASH:" then control code
     A6A6 7700     
22180 A6A8 161F  14        jne  TT27                       ; BNE TT27          ; 0, which prints cash levels, then " CR" and newline)
22181               
22182               * ******************************************************************************
22183               *
22184               * Name: csh
22185               * Type: Subroutine
22186               * Category: Status
22187               * Summary: Print the current amount of cash
22188               *
22189               * ------------------------------------------------------------------------------
22190               *
22191               * Print control code 0 (the current amount of cash, right-aligned to width 9,
22192               * followed by " CR" and a newline).
22193               *
22194               * ******************************************************************************
22195               
22196               csh_:
22197 A6AA 020E  20        li   rx,>03*256                 ; LDX #3            ; We are going to use the BPRNT routine to print out
     A6AC 0300     
22198                                                                          ; the current amount of cash, which is stored as a
22199                                                                          ; 32-bit number at location CASH. BPRNT prints out
22200                                                                          ; the 32-bit number stored in K, so before we call
22201                                                                          ; BPRNT, we need to copy the four bytes from CASH into
22202                                                                          ; K, so first we set up a counter in X for the 4 bytes
22203               
22204               pc1_:
22205 A6AE D36E  34        movb @CASH(rx),ra               ; LDA CASH,X        ; Copy byte X from CASH to K
     A6B0 0309     
22206 A6B2 DB8D  38        movb ra,@K(rx)                  ; STA K,X
     A6B4 003D     
22207               
22208 A6B6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22209               
22210 A6B8 15FA  14        jgt  pc1_                       ; BPL pc1           ; Loop back for the next byte to copy
22211               
22212 A6BA 020D  20        li   ra,>09*256                 ; LDA #9            ; We want to print the cash amount using up to 9 digits
     A6BC 0900     
22213 A6BE D80D  30        movb ra,@U                      ; STA U             ; (including the decimal point), so store this in U
     A6C0 008F     
22214                                                                          ; for BRPNT to take as an argument
22215               
22216                      .sec                            ; SEC               ; We want to print the cash amount with a decimal point,
     **** ****     > SEC
0001 A6C2 0A18  18        sla  rmone,1
                   < elite.a99
22217                                                                          ; so set the C flag for BRPNT to take as an argument
22218               
22219 A6C4 0200  20        li   rtmp,BPRNT                 ; JSR BPRNT         ; Print the amount of cash to 9 digits with a decimal
     A6C6 301C     
22220 A6C8 06A0  32        bl   @jsr                       ;
     A6CA FE28     
22221                                                                          ; point
22222               
22223 A6CC 020D  20        li   ra,>e2*256                 ; LDA #226          ; Print recursive token 66 (" CR") followed by a
     A6CE E200     
22224                                                                          ; newline by falling through into plf
22225               
22226               * ******************************************************************************
22227               *
22228               * Name: plf
22229               * Type: Subroutine
22230               * Category: Text
22231               * Summary: Print a text token followed by a newline
22232               *
22233               * ------------------------------------------------------------------------------
22234               *
22235               * Arguments:
22236               *
22237               * A                   The text token to be printed
22238               *
22239               * ******************************************************************************
22240               
22241               plf_:
22242 A6D0 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     A6D2 A6E8     
22243 A6D4 06A0  32        bl   @jsr                       ;
     A6D6 FE28     
22244               
22245 A6D8 0460  28        b    @TT67                      ; JMP TT67          ; Jump to TT67 to print a newline and return from the
     A6DA 4FA6     
22246                                                                          ; subroutine using a tail call
22247               
22248               * ******************************************************************************
22249               *
22250               * Name: TT68
22251               * Type: Subroutine
22252               * Category: Text
22253               * Summary: Print a text token followed by a colon
22254               *
22255               * ------------------------------------------------------------------------------
22256               *
22257               * Arguments:
22258               *
22259               * A                   The text token to be printed
22260               *
22261               * ******************************************************************************
22262               
22263               TT68:
22264 A6DC 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A and fall through into TT73
     A6DE A6E8     
22265 A6E0 06A0  32        bl   @jsr                       ;
     A6E2 FE28     
22266                                                                          ; to print a colon
22267               
22268               * ******************************************************************************
22269               *
22270               * Name: TT73
22271               * Type: Subroutine
22272               * Category: Text
22273               * Summary: Print a colon
22274               *
22275               * ******************************************************************************
22276               
22277               TT73:
22278 A6E4 020D  20        li   ra,(':')*256               ; LDA #':'          ; Set A to ASCII ":" and fall through into TT27 to
     A6E6 3A00     
22279                                                                          ; actually print the colon
22280               
22281               * ******************************************************************************
22282               *
22283               * Name: TT27
22284               * Type: Subroutine
22285               * Category: Text
22286               * Summary: Print a text token
22287               * Deep dive: Printing text tokens
22288               *
22289               * ------------------------------------------------------------------------------
22290               *
22291               * Print a text token (i.e. a character, control code, two-letter token or
22292               * recursive token).
22293               *
22294               * ------------------------------------------------------------------------------
22295               *
22296               * Arguments:
22297               *
22298               * A                   The text token to be printed
22299               *
22300               * ******************************************************************************
22301               
22302               TT27:
22303 A6E8 D38D  18        movb ra,rx                      ; TAX               ; Copy the token number from A to X. We can then keep
22304                                                                          ; decrementing X and testing it against zero, while
22305                                                                          ; keeping the original token number intact in A; this
22306                                                                          ; effectively implements a switch statement on the
22307                                                                          ; value of the token
22308               
22309 A6EA 13DF  14        jeq  csh_                       ; BEQ csh           ; If token = 0, this is control code 0 (current amount
22310                                                                          ; of cash and newline), so jump to csh to print the
22311                                                                          ; amount of cash and return from the subroutine using
22312                                                                          ; a tail call
22313               
22314 A6EC 116E  14        jlt  TT43                       ; BMI TT43          ; If token > 127, this is either a two-letter token
22315                                                                          ; (128-159) or a recursive token (160-255), so jump
22316                                                                          ; to TT43 to process tokens
22317               
22318 A6EE 7387  18        sb   rone,rx                    ; DEX               ; If token = 1, this is control code 1 (current galaxy
22319 A6F0 13C0  14        jeq  tal_                       ; BEQ tal           ; number), so jump to tal to print the galaxy number and
22320                                                                          ; return from the subroutine using a tail call
22321               
22322 A6F2 7387  18        sb   rone,rx                    ; DEX               ; If token = 2, this is control code 2 (current system
22323 A6F4 13A5  14        jeq  ypl_                       ; BEQ ypl           ; name), so jump to ypl to print the current system name
22324                                                                          ; and return from the subroutine using a tail call
22325               
22326 A6F6 7387  18        sb   rone,rx                    ; DEX               ; If token > 3, skip the following instruction
22327 A6F8 1602  14        jne  B61                        ; BNE B61
22328               
22329 A6FA 0460  28        b    @cpl_                      ; JMP cpl           ; This token is control code 3 (selected system name)
     A6FC A5C4     
22330                                                                          ; so jump to cpl to print the selected system name
22331                                                                          ; and return from the subroutine using a tail call
22332               
22333               B61:
22334 A6FE 7387  18        sb   rone,rx                    ; DEX               ; If token = 4, this is control code 4 (commander
22335 A700 1390  14        jeq  cmn_                       ; BEQ cmn           ; name), so jump to cmm to print the commander name
22336                                                                          ; and return from the subroutine using a tail call
22337               
22338 A702 7387  18        sb   rone,rx                    ; DEX               ; If token = 5, this is control code 5 (fuel, newline,
22339 A704 13BC  14        jeq  fwl_                       ; BEQ fwl           ; cash, newline), so jump to fwl to print the fuel level
22340                                                                          ; and return from the subroutine using a tail call
22341               
22342 A706 7387  18        sb   rone,rx                    ; DEX               ; If token > 6, skip the following three instructions
22343 A708 1606  14        jne  B62                        ; BNE B62
22344               
22345 A70A 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; This token is control code 6 (switch to Sentence
     A70C 8000     
22346 A70E D80D  30        movb ra,@QQ17                   ; STA QQ17          ; Case), so set bit 7 of QQ17 to switch to Sentence Case
     A710 007E     
22347 A712 0460  28        b    @rts                       ; RTS               ; and return from the subroutine as we are done
     A714 FE34     
22348               
22349               B62:
22350 A716 7387  18        sb   rone,rx                    ; DEX               ; If token > 8, skip the following two instructions
22351 A718 7387  18        sb   rone,rx                    ; DEX
22352 A71A 1604  14        jne  B63                        ; BNE B63
22353               
22354 A71C D80E  30        movb rx,@QQ17                   ; STX QQ17          ; This token is control code 8 (switch to ALL CAPS), so
     A71E 007E     
22355 A720 0460  28        b    @rts                       ; RTS               ; set QQ17 to 0 to switch to ALL CAPS and return from
     A722 FE34     
22356                                                                          ; the subroutine as we are done
22357               
22358               B63:
22359 A724 7387  18        sb   rone,rx                    ; DEX               ; If token = 9, this is control code 9 (tab to column
22360 A726 1339  14        jeq  crlf_                      ; BEQ crlf          ; 21 and print a colon), so jump to crlf
22361               
22362 A728 028D  22        ci   ra,>60*256                 ; CMP #96           ; By this point, token is either 7, or in 10-127.
     A72A 6000     
22363 A72C 186A  14        joc  ex_                        ; BCS ex            ; Check token number in A and if token >= 96, then the
22364                                                                          ; token is in 96-127, which is a recursive token, so
22365                                                                          ; jump to ex, which prints recursive tokens in this
22366                                                                          ; range (i.e. where the recursive token number is
22367                                                                          ; correct and doesn't need correcting)
22368               
22369 A72E 028D  22        ci   ra,>0e*256                 ; CMP #14           ; If token < 14, skip the following two instructions
     A730 0E00     
22370 A732 1703  14        jnc  B64                        ; BCC B64
22371               
22372 A734 028D  22        ci   ra,>20*256                 ; CMP #32           ; If token < 32, then this means token is in 14-31, so
     A736 2000     
22373 A738 172B  14        jnc  qw_                        ; BCC qw            ; this is a recursive token that needs 114 adding to it
22374                                                                          ; to get the recursive token number, so jump to qw
22375                                                                          ; which will do this
22376               
22377                                                                          ; By this point, token is either 7 (beep) or in 10-13
22378                                                                          ; (line feeds and carriage returns), or in 32-95
22379                                                                          ; (ASCII letters, numbers and punctuation)
22380               
22381               B64:
22382 A73A D3A0  30        movb @QQ17,rx                   ; LDX QQ17          ; Fetch QQ17, which controls letter case, into X
     A73C 007E     
22383               
22384 A73E 1343  14        jeq  TT74                       ; BEQ TT74          ; If QQ17 = 0, then ALL CAPS is set, so jump to TT74
22385                                                                          ; to print this character as is (i.e. as a capital)
22386               
22387 A740 1113  14        jlt  TT41                       ; BMI TT41          ; If QQ17 has bit 7 set, then we are using Sentence
22388                                                                          ; Case, so jump to TT41, which will print the
22389                                                                          ; character in upper or lower case, depending on
22390                                                                          ; whether this is the first letter in a word
22391               
22392                      .bit @QQ17                      ; BIT QQ17          ; If we get here, QQ17 is not 0 and bit 7 is clear, so
     **** ****     > BIT
0001 A742 D020  30        movb @QQ17,rtmp
     A744 007E     
0002 A746 0540  14        inv  rtmp
0003 A748 D047  18        movb rone,rtmp2
0004 A74A 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
22393                      .bvs TT46                       ; BVS TT46          ; either it is bit 6 that is set, or some other flag in
     **** ****     > BVS
0001 A74C 1801  14        joc  !
0002 A74E 1032  14        jmp  TT46
0003               !:
                   < elite.a99
22394                                                                          ; QQ17 is set (bits 0-5). So check whether bit 6 is set.
22395                                                                          ; If it is, then ALL CAPS has been set (as bit 7 is
22396                                                                          ; clear) but bit 6 is still indicating that the next
22397                                                                          ; character should be printed in lower case, so we need
22398                                                                          ; to fix this. We do this with a jump to TT46, which
22399                                                                          ; will print this character in upper case and clear bit
22400                                                                          ; 6, so the flags are consistent with ALL CAPS going
22401                                                                          ; forward
22402               
22403                                                                          ; If we get here, some other flag is set in QQ17 (one
22404                                                                          ; of bits 0-5 is set), which shouldn't happen in this
22405                                                                          ; version of Elite. If this were the case, then we
22406                                                                          ; would fall through into TT42 to print in lower case,
22407                                                                          ; which is how printing all words in lower case could
22408                                                                          ; be supported (by setting QQ17 to 1, say)
22409               
22410               * ******************************************************************************
22411               *
22412               * Name: TT42
22413               * Type: Subroutine
22414               * Category: Text
22415               * Summary: Print a letter in lower case
22416               *
22417               * ------------------------------------------------------------------------------
22418               *
22419               * Arguments:
22420               *
22421               * A                   The character to be printed. Can be one of the
22422               * following:
22423               *
22424               * * 7 (beep)
22425               *
22426               * * 10-13 (line feeds and carriage returns)
22427               *
22428               * * 32-95 (ASCII capital letters, numbers and
22429               * punctuation)
22430               *
22431               * ------------------------------------------------------------------------------
22432               *
22433               * Other entry points:
22434               *
22435               * TT44                Jumps to TT26 to print the character in A (used to
22436               * enable us to use a branch instruction to jump to TT26)
22437               *
22438               * ******************************************************************************
22439               
22440               TT42:
22441 A750 028D  22        ci   ra,('A')*256               ; CMP #'A'          ; If A < ASCII "A", then this is punctuation, so jump
     A752 4100     
22442 A754 1707  14        jnc  TT44                       ; BCC TT44          ; to TT26 (via TT44) to print the character as is, as
22443                                                                          ; we don't care about the character's case
22444               
22445 A756 028D  22        ci   ra,('Z'+1)*256             ; CMP #'Z'+1        ; If A >= (ASCII "Z" + 1), then this is also
     A758 5B00     
22446 A75A 1804  14        joc  TT44                       ; BCS TT44          ; punctuation, so jump to TT26 (via TT44) to print the
22447                                                                          ; character as is, as we don't care about the
22448                                                                          ; character's case
22449               
22450                      .adi (>20*256)                  ; ADC #32           ; Add 32 to the character, to convert it from upper to
     **** ****     > ADI
0001 A75C 1701  14        jnc  !
0002 A75E B347  18        ab   rone,ra
0003               !:
0004 A760 022D  22        ai   ra,(>20*256)
     A762 2000     
                   < elite.a99
22451                                                                          ; lower case
22452               
22453               TT44:
22454 A764 0460  28        b    @TT26                      ; JMP TT26          ; Print the character in A
     A766 31C2     
22455               
22456               * ******************************************************************************
22457               *
22458               * Name: TT41
22459               * Type: Subroutine
22460               * Category: Text
22461               * Summary: Print a letter according to Sentence Case
22462               *
22463               * ------------------------------------------------------------------------------
22464               *
22465               * The rules for printing in Sentence Case are as follows:
22466               *
22467               * * If QQ17 bit 6 is set, print lower case (via TT45)
22468               *
22469               * * If QQ17 bit 6 is clear, then:
22470               *
22471               * * If character is punctuation, just print it
22472               *
22473               * * If character is a letter, set QQ17 bit 6 and print letter as a capital
22474               *
22475               * ------------------------------------------------------------------------------
22476               *
22477               * Arguments:
22478               *
22479               * A                   The character to be printed. Can be one of the
22480               * following:
22481               *
22482               * * 7 (beep)
22483               *
22484               * * 10-13 (line feeds and carriage returns)
22485               *
22486               * * 32-95 (ASCII capital letters, numbers and
22487               * punctuation)
22488               *
22489               * X                   Contains the current value of QQ17
22490               *
22491               * QQ17                Bit 7 is set
22492               *
22493               * ******************************************************************************
22494               
22495               TT41:
22496                                                                          ; If we get here, then QQ17 has bit 7 set, so we are in
22497                                                                          ; Sentence Case
22498                      .bit @QQ17                      ; BIT QQ17          ; If QQ17 also has bit 6 set, jump to TT45 to print
     **** ****     > BIT
0001 A768 D020  30        movb @QQ17,rtmp
     A76A 007E     
0002 A76C 0540  14        inv  rtmp
0003 A76E D047  18        movb rone,rtmp2
0004 A770 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
22499                      .bvs TT45                       ; BVS TT45          ; this character in lower case
     **** ****     > BVS
0001 A772 1801  14        joc  !
0002 A774 1017  14        jmp  TT45
0003               !:
                   < elite.a99
22500               
22501                                                                          ; If we get here, then QQ17 has bit 6 clear and bit 7
22502                                                                          ; set, so we are in Sentence Case and we need to print
22503                                                                          ; the next letter in upper case
22504               
22505 A776 028D  22        ci   ra,('A')*256               ; CMP #'A'          ; If A < ASCII "A", then this is punctuation, so jump
     A778 4100     
22506 A77A 1725  14        jnc  TT74                       ; BCC TT74          ; to TT26 (via TT44) to print the character as is, as
22507                                                                          ; we don't care about the character's case
22508               
22509                      .pha                            ; PHA               ; Otherwise this is a letter, so store the token number
     **** ****     > PHA
0001 A77C D68D  30        movb ra,*rsp
0002 A77E 060A  14        dec  rsp
                   < elite.a99
22510               
22511 A780 D34E  18        movb rx,ra                      ; TXA               ; Set bit 6 in QQ17 (X contains the current QQ17)
22512 A782 026D  22        ori  ra,>40*256                 ; ORA #%1000000     ; so the next letter after this one is printed in lower
     A784 4000     
22513 A786 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; case
     A788 007E     
22514               
22515                      .pla                            ; PLA               ; Restore the token number into A
     **** ****     > PLA
0001 A78A 058A  14        inc  rsp
0002 A78C D35A  26        movb *rsp,ra
                   < elite.a99
22516               
22517 A78E 16EA  14        jne  TT44                       ; BNE TT44          ; Jump to TT26 (via TT44) to print the character in A
22518                                                                          ; (this BNE is effectively a JMP as A will never be
22519                                                                          ; zero)
22520               
22521               * ******************************************************************************
22522               *
22523               * Name: qw
22524               * Type: Subroutine
22525               * Category: Text
22526               * Summary: Print a recursive token in the range 128-145
22527               *
22528               * ------------------------------------------------------------------------------
22529               *
22530               * Print a recursive token where the token number is in 128-145 (so the value
22531               * passed to TT27 is in the range 14-31).
22532               *
22533               * ------------------------------------------------------------------------------
22534               *
22535               * Arguments:
22536               *
22537               * A                   A value from 128-145, which refers to a recursive token
22538               * in the range 14-31
22539               *
22540               * ******************************************************************************
22541               
22542               qw_:
22543                      .adi (>72*256)                  ; ADC #114          ; This is a recursive token in the range 0-95, so add
     **** ****     > ADI
0001 A790 1701  14        jnc  !
0002 A792 B347  18        ab   rone,ra
0003               !:
0004 A794 022D  22        ai   ra,(>72*256)
     A796 7200     
                   < elite.a99
22544 A798 1634  14        jne  ex_                        ; BNE ex            ; 114 to the argument to get the token number 128-145
22545                                                                          ; and jump to ex to print it
22546               
22547               * ******************************************************************************
22548               *
22549               * Name: crlf
22550               * Type: Subroutine
22551               * Category: Text
22552               * Summary: Tab to column 21 and print a colon
22553               *
22554               * ------------------------------------------------------------------------------
22555               *
22556               * Print control code 9 (tab to column 21 and print a colon). The subroutine
22557               * name is pretty misleading, as it doesn't have anything to do with carriage
22558               * returns or line feeds.
22559               *
22560               * ******************************************************************************
22561               
22562               crlf_:
22563 A79A 020D  20        li   ra,>15*256                 ; LDA #21           ; Set the X-column in XC to 21
     A79C 1500     
22564 A79E D80D  30        movb ra,@XC                     ; STA XC
     A7A0 002C     
22565               
22566 A7A2 16A0  14        jne  TT73                       ; BNE TT73          ; Jump to TT73, which prints a colon (this BNE is
22567                                                                          ; effectively a JMP as A will never be zero)
22568               
22569               * ******************************************************************************
22570               *
22571               * Name: TT45
22572               * Type: Subroutine
22573               * Category: Text
22574               * Summary: Print a letter in lower case
22575               *
22576               * ------------------------------------------------------------------------------
22577               *
22578               * This routine prints a letter in lower case. Specifically:
22579               *
22580               * * If QQ17 = 255, abort printing this character as printing is disabled
22581               *
22582               * * If this is a letter then print in lower case
22583               *
22584               * * Otherwise this is punctuation, so clear bit 6 in QQ17 and print
22585               *
22586               * ------------------------------------------------------------------------------
22587               *
22588               * Arguments:
22589               *
22590               * A                   The character to be printed. Can be one of the
22591               * following:
22592               *
22593               * * 7 (beep)
22594               *
22595               * * 10-13 (line feeds and carriage returns)
22596               *
22597               * * 32-95 (ASCII capital letters, numbers and
22598               * punctuation)
22599               *
22600               * X                   Contains the current value of QQ17
22601               *
22602               * QQ17                Bits 6 and 7 are set
22603               *
22604               * ******************************************************************************
22605               
22606               TT45:
22607                                                                          ; If we get here, then QQ17 has bit 6 and 7 set, so we
22608                                                                          ; are in Sentence Case and we need to print the next
22609                                                                          ; letter in lower case
22610 A7A4 028E  22        ci   rx,>ff*256                 ; CPX #255          ; If QQ17 = 255 then printing is disabled, so return
     A7A6 FF00     
22611 A7A8 1602  14        jne  FIX006                     ; BNE FIX006        ; from the subroutine (as TT48 contains an RTS)
22612 A7AA 0460  28        b    @TT48                      ; JMP TT48
     A7AC A898     
22613               
22614               FIX006:
22615 A7AE 028D  22        ci   ra,('A')*256               ; CMP #'A'          ; If A >= ASCII "A", then jump to TT42, which will
     A7B0 4100     
22616 A7B2 18CE  14        joc  TT42                       ; BCS TT42          ; print the letter in lowercase
22617               
22618                                                                          ; Otherwise this is not a letter, it's punctuation, so
22619                                                                          ; this is effectively a word break. We therefore fall
22620                                                                          ; through to TT46 to print the character and set QQ17
22621                                                                          ; to ensure the next word starts with a capital letter
22622               
22623               * ******************************************************************************
22624               *
22625               * Name: TT46
22626               * Type: Subroutine
22627               * Category: Text
22628               * Summary: Print a character and switch to capitals
22629               *
22630               * ------------------------------------------------------------------------------
22631               *
22632               * Print a character and clear bit 6 in QQ17, so that the next letter that gets
22633               * printed after this will start with a capital letter.
22634               *
22635               * ------------------------------------------------------------------------------
22636               *
22637               * Arguments:
22638               *
22639               * A                   The character to be printed. Can be one of the
22640               * following:
22641               *
22642               * * 7 (beep)
22643               *
22644               * * 10-13 (line feeds and carriage returns)
22645               *
22646               * * 32-95 (ASCII capital letters, numbers and
22647               * punctuation)
22648               *
22649               * X                   Contains the current value of QQ17
22650               *
22651               * QQ17                Bits 6 and 7 are set
22652               *
22653               * ******************************************************************************
22654               
22655               TT46:
22656                      .pha                            ; PHA               ; Store the token number
     **** ****     > PHA
0001 A7B4 D68D  30        movb ra,*rsp
0002 A7B6 060A  14        dec  rsp
                   < elite.a99
22657               
22658 A7B8 D34E  18        movb rx,ra                      ; TXA               ; Clear bit 6 in QQ17 (X contains the current QQ17) so
22659 A7BA 024D  22        andi ra,>bf*256                 ; AND #%10111111    ; the next letter after this one is printed in upper
     A7BC BF00     
22660 A7BE D80D  30        movb ra,@QQ17                   ; STA QQ17          ; case
     A7C0 007E     
22661               
22662                      .pla                            ; PLA               ; Restore the token number into A
     **** ****     > PLA
0001 A7C2 058A  14        inc  rsp
0002 A7C4 D35A  26        movb *rsp,ra
                   < elite.a99
22663               
22664                                                                          ; Now fall through into TT74 to print the character
22665               
22666               * ******************************************************************************
22667               *
22668               * Name: TT74
22669               * Type: Subroutine
22670               * Category: Text
22671               * Summary: Print a character
22672               *
22673               * ------------------------------------------------------------------------------
22674               *
22675               * Arguments:
22676               *
22677               * A                   The character to be printed
22678               *
22679               * ******************************************************************************
22680               
22681               TT74:
22682 A7C6 0460  28        b    @TT26                      ; JMP TT26          ; Print the character in A
     A7C8 31C2     
22683               
22684               * ******************************************************************************
22685               *
22686               * Name: TT43
22687               * Type: Subroutine
22688               * Category: Text
22689               * Summary: Print a two-letter token or recursive token 0-95
22690               *
22691               * ------------------------------------------------------------------------------
22692               *
22693               * Print a two-letter token, or a recursive token where the token number is in
22694               * 0-95 (so the value passed to TT27 is in the range 160-255).
22695               *
22696               * ------------------------------------------------------------------------------
22697               *
22698               * Arguments:
22699               *
22700               * A                   One of the following:
22701               *
22702               * * 128-159 (two-letter token)
22703               *
22704               * * 160-255 (the argument to TT27 that refers to a
22705               * recursive token in the range 0-95)
22706               *
22707               * ******************************************************************************
22708               
22709               TT43:
22710 A7CA 028D  22        ci   ra,>a0*256                 ; CMP #160          ; If token >= 160, then this is a recursive token, so
     A7CC A000     
22711 A7CE 1815  14        joc  TT47                       ; BCS TT47          ; jump to TT47 below to process it
22712               
22713 A7D0 024D  22        andi ra,>7f*256                 ; AND #127          ; This is a two-letter token with number 128-159. The
     A7D2 7F00     
22714                      .asla                           ; ASL A             ; set of two-letter tokens is stored in a lookup table
     **** ****     > ASLA
0001 A7D4 024D  22        andi ra,>ff00
     A7D6 FF00     
0002 A7D8 0A1D  18        sla  ra,1
                   < elite.a99
22715                                                                          ; at QQ16, with each token taking up two bytes, so to
22716                                                                          ; convert this into the token's position in the table,
22717                                                                          ; we subtract 128 (or just clear bit 7) and multiply
22718                                                                          ; by 2 (or shift left)
22719               
22720 A7DA D3CD  18        movb ra,ry                      ; TAY               ; Transfer the token's position into Y so we can look
22721                                                                          ; up the token using absolute indexed mode
22722               
22723 A7DC D36F  34        movb @QQ16(ry),ra               ; LDA QQ16,Y        ; Get the first letter of the token and print it
     A7DE CF9E     
22724 A7E0 0200  20        li   rtmp,TT27                  ; JSR TT27
     A7E2 A6E8     
22725 A7E4 06A0  32        bl   @jsr                       ;
     A7E6 FE28     
22726               
22727 A7E8 D36F  34        movb @QQ16+1(ry),ra             ; LDA QQ16+1,Y      ; Get the second letter of the token
     A7EA CF9F     
22728               
22729 A7EC 028D  22        ci   ra,('?')*256               ; CMP #'?'          ; If the second letter of the token is a question mark
     A7EE 3F00     
22730 A7F0 1602  14        jne  FIX007                     ; BNE FIX007        ; then this is a one-letter token, so just return from
22731                                                                          ; the subroutine without printing (as TT48 contains an
22732                                                                          ; RTS)
22733 A7F2 0460  28        b    @TT48                      ; JMP TT48
     A7F4 A898     
22734               FIX007:
22735 A7F6 0460  28        b    @TT27                      ; JMP TT27          ; Print the second letter and return from the
     A7F8 A6E8     
22736                                                                          ; subroutine
22737               
22738               TT47:
22739                      .sbi (>a0*256)                  ; SBC #160          ; This is a recursive token in the range 160-255, so
     **** ****     > SBI
0001 A7FA 1801  14        joc  !
0002 A7FC 7347  18        sb   rone,ra
0003               !:
0004 A7FE 022D  22        ai   ra,-(>A0*256)
     A800 6000     
                   < elite.a99
22740                                                                          ; subtract 160 from the argument to get the token
22741                                                                          ; number 0-95 and fall through into ex to print it
22742               
22743               * ******************************************************************************
22744               *
22745               * Name: ex
22746               * Type: Subroutine
22747               * Category: Text
22748               * Summary: Print a recursive token
22749               * Deep dive: Printing text tokens
22750               *
22751               * ------------------------------------------------------------------------------
22752               *
22753               * This routine works its way through the recursive text tokens that are stored
22754               * in tokenised form in the table at QQ18, and when it finds token number A,
22755               * it prints it. Tokens are null-terminated in memory and fill three pages,
22756               * but there is no lookup table as that would consume too much memory, so the
22757               * only way to find the correct token is to start at the beginning and look
22758               * through the table byte by byte, counting tokens as we go until we are in the
22759               * right place. This approach might not be terribly speed efficient, but it is
22760               * certainly memory-efficient.
22761               *
22762               * ------------------------------------------------------------------------------
22763               *
22764               * Arguments:
22765               *
22766               * A                   The recursive token to be printed, in the range 0-148
22767               *
22768               * ------------------------------------------------------------------------------
22769               *
22770               * Other entry points:
22771               *
22772               * TT48                Contains an RTS
22773               *
22774               * ******************************************************************************
22775               
22776               ex_:
22777 A802 D38D  18        movb ra,rx                      ; TAX               ; Copy the token number into X
22778               
22779 A804 020D  20        li   ra,((QQ18)%256)*256        ; LDA #LO(QQ18)     ; Set V(1 0) to point to the recursive token table at
     A806 0000     
22780 A808 D80D  30        movb ra,@V                      ; STA V             ; location QQ18
     A80A 0022     
22781 A80C 020D  20        li   ra,((QQ18)/256)*256        ; LDA #HI(QQ18)
     A80E 0400     
22782 A810 D80D  30        movb ra,@V+1                    ; STA V+1
     A812 0023     
22783               
22784 A814 020F  20        li   ry,>00*256                 ; LDY #0            ; Set a counter Y to point to the character offset
     A816 0000     
22785                                                                          ; as we scan through the table
22786               
22787 A818 D34E  18        movb rx,ra                      ; TXA               ; Copy the token number back into A, so both A and X
22788                                                                          ; now contain the token number we want to print
22789               
22790 A81A 1313  14        jeq  TT50                       ; BEQ TT50          ; If the token number we want is 0, then we have
22791                                                                          ; already found the token we are looking for, so jump
22792                                                                          ; to TT50, otherwise start working our way through the
22793                                                                          ; null-terminated token table until we find the X-th
22794                                                                          ; token
22795               
22796               TT51:
22797                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch the Y-th character from the token table page
     **** ****     > LD_IND_Y_IDX
0001 A81C D820  42        movb @V,@rtmplb
     A81E 0022     
     A820 8301     
0002 A822 D020  30        movb @V+1,rtmp
     A824 0023     
0003 A826 06CF  14        swpb ry
0004 A828 A00F  18        a    ry,rtmp
0005 A82A 06CF  14        swpb ry
0006 A82C D350  26        movb *rtmp,RA
                   < elite.a99
22798                                                                          ; we are currently scanning
22799               
22800 A82E 1304  14        jeq  TT49                       ; BEQ TT49          ; If the character is null, we've reached the end of
22801                                                                          ; this token, so jump to TT49
22802               
22803 A830 B3C7  18        ab   rone,ry                    ; INY               ; Increment character pointer and loop back around for
22804 A832 16F4  14        jne  TT51                       ; BNE TT51          ; the next character in this token, assuming Y hasn't
22805                                                                          ; yet wrapped around to 0
22806               
22807 A834 B347  18        ab   rone,ra                    ; INC V+1           ; If it has wrapped round to 0, we have just crossed
22808 A836 16F2  14        jne  TT51                       ; BNE TT51          ; into a new page, so increment V+1 so that V points
22809                                                                          ; to the start of the new page
22810               
22811               TT49:
22812 A838 B3C7  18        ab   rone,ry                    ; INY               ; Increment the character pointer
22813               
22814 A83A 1601  14        jne  TT59                       ; BNE TT59          ; If Y hasn't just wrapped around to 0, skip the next
22815                                                                          ; instruction
22816               
22817 A83C B347  18        ab   rone,ra                    ; INC V+1           ; We have just crossed into a new page, so increment
22818                                                                          ; V+1 so that V points to the start of the new page
22819               
22820               TT59:
22821 A83E 7387  18        sb   rone,rx                    ; DEX               ; We have just reached a new token, so decrement the
22822                                                                          ; token number we are looking for
22823               
22824 A840 16ED  14        jne  TT51                       ; BNE TT51          ; Assuming we haven't yet reached the token number in
22825                                                                          ; X, look back up to keep fetching characters
22826               
22827               TT50:
22828                                                                          ; We have now reached the correct token in the token
22829                                                                          ; table, with Y pointing to the start of the token as
22830                                                                          ; an offset within the page pointed to by V, so let's
22831                                                                          ; print the recursive token. Because recursive tokens
22832                                                                          ; can contain other recursive tokens, we need to store
22833                                                                          ; our current state on the stack, so we can retrieve
22834                                                                          ; it after printing each character in this token
22835 A842 D34F  18        movb ry,ra                      ; TYA               ; Store the offset in Y on the stack
22836                      .pha                            ; PHA
     **** ****     > PHA
0001 A844 D68D  30        movb ra,*rsp
0002 A846 060A  14        dec  rsp
                   < elite.a99
22837               
22838 A848 D360  30        movb @V+1,ra                    ; LDA V+1           ; Store the high byte of V (the page containing the
     A84A 0023     
22839                      .pha                            ; PHA               ; token we have found) on the stack, so the stack now
     **** ****     > PHA
0001 A84C D68D  30        movb ra,*rsp
0002 A84E 060A  14        dec  rsp
                   < elite.a99
22840                                                                          ; contains the address of the start of this token
22841               
22842                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Load the character at offset Y in the token table,
     **** ****     > LD_IND_Y_IDX
0001 A850 D820  42        movb @V,@rtmplb
     A852 0022     
     A854 8301     
0002 A856 D020  30        movb @V+1,rtmp
     A858 0023     
0003 A85A 06CF  14        swpb ry
0004 A85C A00F  18        a    ry,rtmp
0005 A85E 06CF  14        swpb ry
0006 A860 D350  26        movb *rtmp,RA
                   < elite.a99
22843                                                                          ; which is the next character of this token that we
22844                                                                          ; want to print
22845               
22846                      .eoi ((RE)*256)                 ; EOR #RE           ; Tokens are stored in memory having been EOR'd with the
     **** ****     > EOI
0001 A862 0200  20        li   rtmp,((RE)*256)
     A864 2300     
0002 A866 2B40  18        xor  rtmp,ra
                   < elite.a99
22847                                                                          ; value of RE - which is 35 for all versions of Elite
22848                                                                          ; except for NES, where RE is 62 - so we repeat the
22849                                                                          ; EOR to get the actual character to print
22850               
22851 A868 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A, which could be a letter,
     A86A A6E8     
22852 A86C 06A0  32        bl   @jsr                       ;
     A86E FE28     
22853                                                                          ; number, control code, two-letter token or another
22854                                                                          ; recursive token
22855               
22856                      .pla                            ; PLA               ; Restore the high byte of V (the page containing the
     **** ****     > PLA
0001 A870 058A  14        inc  rsp
0002 A872 D35A  26        movb *rsp,ra
                   < elite.a99
22857 A874 D80D  30        movb ra,@V+1                    ; STA V+1           ; token we have found) into V+1
     A876 0023     
22858               
22859                      .pla                            ; PLA               ; Restore the offset into Y
     **** ****     > PLA
0001 A878 058A  14        inc  rsp
0002 A87A D35A  26        movb *rsp,ra
                   < elite.a99
22860 A87C D3CD  18        movb ra,ry                      ; TAY
22861               
22862 A87E B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next character in the
22863                                                                          ; token we are printing
22864               
22865 A880 1601  14        jne  B65                        ; BNE B65           ; If Y is zero then we have just crossed into a new
22866 A882 B347  18        ab   rone,ra                    ; INC V+1           ; page, so increment V+1 so that V points to the start
22867                                                                          ; of the new page
22868               
22869               B65:
22870                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Load the next character we want to print into A
     **** ****     > LD_IND_Y_IDX
0001 A884 D820  42        movb @V,@rtmplb
     A886 0022     
     A888 8301     
0002 A88A D020  30        movb @V+1,rtmp
     A88C 0023     
0003 A88E 06CF  14        swpb ry
0004 A890 A00F  18        a    ry,rtmp
0005 A892 06CF  14        swpb ry
0006 A894 D350  26        movb *rtmp,RA
                   < elite.a99
22871               
22872 A896 16D5  14        jne  TT50                       ; BNE TT50          ; If this is not the null character at the end of the
22873                                                                          ; token, jump back up to TT50 to print the next
22874                                                                          ; character, otherwise we are done printing
22875               
22876               TT48:
22877 A898 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A89A FE34     
22878               
22879               * ******************************************************************************
22880               *
22881               * Name: DOEXP
22882               * Type: Subroutine
22883               * Category: Drawing ships
22884               * Summary: Draw an exploding ship
22885               * Deep dive: Drawing explosion clouds
22886               * Generating random numbers
22887               *
22888               * ******************************************************************************
22889               
22890               EX2:
22891 A89C D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bits 5 and 7 of the ship's byte #31 to denote that
     A89E 0072     
22892 A8A0 026D  22        ori  ra,>a0*256                 ; ORA #%10100000    ; the ship is exploding and has been killed
     A8A2 A000     
22893 A8A4 D80D  30        movb ra,@INWK+31                ; STA INWK+31
     A8A6 0072     
22894               
22895 A8A8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A8AA FE34     
22896               
22897               DOEXP:
22898 A8AC D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; If bit 6 of the ship's byte #31 is clear, then the
     A8AE 0072     
22899 A8B0 024D  22        andi ra,>40*256                 ; AND #%01000000    ; ship is not already exploding so there is no existing
     A8B2 4000     
22900 A8B4 1304  14        jeq  B66                        ; BEQ B66           ; explosion cloud to remove, so skip the following
22901                                                                          ; instruction
22902               
22903 A8B6 0200  20        li   rtmp,PTCLS                 ; JSR PTCLS         ; Call PTCLS to remove the existing cloud by drawing it
     A8B8 A9F0     
22904 A8BA 06A0  32        bl   @jsr                       ;
     A8BC FE28     
22905                                                                          ; again
22906               
22907               B66:
22908 A8BE D360  30        movb @INWK+6,ra                 ; LDA INWK+6        ; Set T = z_lo
     A8C0 0059     
22909 A8C2 D80D  30        movb ra,@T                      ; STA T
     A8C4 00D1     
22910               
22911 A8C6 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set A = z_hi, so (A T) = z
     A8C8 005A     
22912               
22913 A8CA 028D  22        ci   ra,>20*256                 ; CMP #32           ; If z_hi < 32, skip the next two instructions
     A8CC 2000     
22914 A8CE 1703  14        jnc  B67                        ; BCC B67
22915               
22916 A8D0 020D  20        li   ra,>fe*256                 ; LDA #&FE          ; Set A = 254 and jump to yy (this BNE is effectively a
     A8D2 FE00     
22917 A8D4 1615  14        jne  yy_                        ; BNE yy            ; JMP, as A is never zero)
22918               
22919               B67:
22920                      .asl @T                         ; ASL T             ; Shift (A T) left twice
     **** ****     > ASL
0001 A8D6 D020  30        movb @T,rtmp
     A8D8 00D1     
0002 A8DA 0240  22        andi rtmp,>ff00
     A8DC FF00     
0003 A8DE 0A10  18        sla  rtmp,1
0004 A8E0 D800  30        movb rtmp,@T
     A8E2 00D1     
                   < elite.a99
22921 A8E4 06A0  32        bl   @rola                      ; ROL A
     A8E6 FE3E     
22922                      .asl @T                         ; ASL T
     **** ****     > ASL
0001 A8E8 D020  30        movb @T,rtmp
     A8EA 00D1     
0002 A8EC 0240  22        andi rtmp,>ff00
     A8EE FF00     
0003 A8F0 0A10  18        sla  rtmp,1
0004 A8F2 D800  30        movb rtmp,@T
     A8F4 00D1     
                   < elite.a99
22923 A8F6 06A0  32        bl   @rola                      ; ROL A
     A8F8 FE3E     
22924               
22925                      .sec                            ; SEC               ; And then shift A left once more, inserting a 1 into
     **** ****     > SEC
0001 A8FA 0A18  18        sla  rmone,1
                   < elite.a99
22926 A8FC 06A0  32        bl   @rola                      ; ROL A             ; bit 0
     A8FE FE3E     
22927               
22928                                                                          ; Overall, the above multiplies A by 8 and makes sure it
22929                                                                          ; is at least 1, to leave a one-byte distance in A. We
22930                                                                          ; can use this as the distance for our cloud, to ensure
22931                                                                          ; that the explosion cloud is visible even for ships
22932                                                                          ; that blow up a long way away
22933               
22934               yy_:
22935 A900 D80D  30        movb ra,@Q                      ; STA Q             ; Store the distance to the explosion in Q
     A902 0090     
22936               
22937 A904 020F  20        li   ry,>01*256                 ; LDY #1            ; Fetch byte #1 of the ship line heap, which contains
     A906 0100     
22938                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; the cloud counter
     **** ****     > LD_IND_Y_IDX
0001 A908 D820  42        movb @XX19,@rtmplb
     A90A 0074     
     A90C 8301     
0002 A90E D020  30        movb @XX19+1,rtmp
     A910 0075     
0003 A912 06CF  14        swpb ry
0004 A914 A00F  18        a    ry,rtmp
0005 A916 06CF  14        swpb ry
0006 A918 D350  26        movb *rtmp,RA
                   < elite.a99
22939               
22940                      .adi (>04*256)                  ; ADC #4            ; Add 4 to the cloud counter, so it ticks onwards every
     **** ****     > ADI
0001 A91A 1701  14        jnc  !
0002 A91C B347  18        ab   rone,ra
0003               !:
0004 A91E 022D  22        ai   ra,(>04*256)
     A920 0400     
                   < elite.a99
22941                                                                          ; we redraw it
22942               
22943 A922 18BC  14        joc  EX2                        ; BCS EX2           ; If the addition overflowed, jump up to EX2 to update
22944                                                                          ; the explosion flags and return from the subroutine
22945               
22946                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store the updated cloud counter in byte #1 of the ship
     **** ****     > ST_IND_Y_IDX
0001 A924 D820  42        movb @XX19,@rtmplb
     A926 0074     
     A928 8301     
0002 A92A D020  30        movb @XX19+1,rtmp
     A92C 0075     
0003 A92E 06CF  14        swpb ry
0004 A930 A00F  18        a    ry,rtmp
0005 A932 06CF  14        swpb ry
0006 A934 D40D  30        movb RA,*rtmp
                   < elite.a99
22947                                                                          ; line heap
22948               
22949 A936 0200  20        li   rtmp,DVID4                 ; JSR DVID4         ; Calculate the following:
     A938 4664     
22950 A93A 06A0  32        bl   @jsr                       ;
     A93C FE28     
22951                                                                          ;
22952                                                                          ; (P R) = 256 * A / Q
22953                                                                          ; = 256 * cloud counter / distance
22954                                                                          ;
22955                                                                          ; We are going to use this as our cloud size, so the
22956                                                                          ; further away the cloud, the smaller it is, and as the
22957                                                                          ; cloud counter ticks onward, the cloud expands
22958               
22959 A93E D360  30        movb @P,ra                      ; LDA P             ; Set A = P, so we now have:
     A940 001B     
22960                                                                          ;
22961                                                                          ; (A R) = 256 * cloud counter / distance
22962               
22963 A942 028D  22        ci   ra,>1c*256                 ; CMP #&1C          ; If A < 28, skip the next two instructions
     A944 1C00     
22964 A946 1703  14        jnc  B68                        ; BCC B68
22965               
22966 A948 020D  20        li   ra,>fe*256                 ; LDA #&FE          ; Set A = 254 and skip the following (this BNE is
     A94A FE00     
22967 A94C 161B  14        jne  LABEL_1                    ; BNE LABEL_1       ; effectively a JMP as A is never zero)
22968               
22969               B68:
22970                      .asl @R                         ; ASL R             ; Shift (A R) left three times to multiply by 8
     **** ****     > ASL
0001 A94E D020  30        movb @R,rtmp
     A950 0091     
0002 A952 0240  22        andi rtmp,>ff00
     A954 FF00     
0003 A956 0A10  18        sla  rtmp,1
0004 A958 D800  30        movb rtmp,@R
     A95A 0091     
                   < elite.a99
22971 A95C 06A0  32        bl   @rola                      ; ROL A
     A95E FE3E     
22972                      .asl @R                         ; ASL R
     **** ****     > ASL
0001 A960 D020  30        movb @R,rtmp
     A962 0091     
0002 A964 0240  22        andi rtmp,>ff00
     A966 FF00     
0003 A968 0A10  18        sla  rtmp,1
0004 A96A D800  30        movb rtmp,@R
     A96C 0091     
                   < elite.a99
22973 A96E 06A0  32        bl   @rola                      ; ROL A
     A970 FE3E     
22974                      .asl @R                         ; ASL R
     **** ****     > ASL
0001 A972 D020  30        movb @R,rtmp
     A974 0091     
0002 A976 0240  22        andi rtmp,>ff00
     A978 FF00     
0003 A97A 0A10  18        sla  rtmp,1
0004 A97C D800  30        movb rtmp,@R
     A97E 0091     
                   < elite.a99
22975 A980 06A0  32        bl   @rola                      ; ROL A
     A982 FE3E     
22976               
22977                                                                          ; Overall, the above multiplies (A R) by 8 to leave a
22978                                                                          ; one-byte cloud size in A, given by the following:
22979                                                                          ;
22980                                                                          ; A = 8 * cloud counter / distance
22981               
22982               LABEL_1:
22983 A984 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to 0
22984               
22985                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store the cloud size in byte #0 of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 A986 D820  42        movb @XX19,@rtmplb
     A988 0074     
     A98A 8301     
0002 A98C D020  30        movb @XX19+1,rtmp
     A98E 0075     
0003 A990 06CF  14        swpb ry
0004 A992 A00F  18        a    ry,rtmp
0005 A994 06CF  14        swpb ry
0006 A996 D40D  30        movb RA,*rtmp
                   < elite.a99
22986               
22987 A998 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Clear bit 6 of the ship's byte #31 to denote that the
     A99A 0072     
22988 A99C 024D  22        andi ra,>bf*256                 ; AND #%10111111    ; explosion has not yet been drawn
     A99E BF00     
22989 A9A0 D80D  30        movb ra,@INWK+31                ; STA INWK+31
     A9A2 0072     
22990               
22991 A9A4 024D  22        andi ra,>08*256                 ; AND #%00001000    ; If bit 3 of the ship's byte #31 is clear, then nothing
     A9A6 0800     
22992 A9A8 1602  14        jne  FIX008                     ; BNE FIX008        ; is being drawn on-screen for this ship anyway, so
22993 A9AA 0460  28        b    @TT48                      ; JMP TT48          ; return from the subroutine (as TT48 contains an RTS)
     A9AC A898     
22994               
22995               FIX008:
22996 A9AE 020F  20        li   ry,>02*256                 ; LDY #2            ; Otherwise it's time to draw an explosion cloud, so
     A9B0 0200     
22997                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; fetch byte #2 of the ship line heap into Y, which we
     **** ****     > LD_IND_Y_IDX
0001 A9B2 D820  42        movb @XX19,@rtmplb
     A9B4 0074     
     A9B6 8301     
0002 A9B8 D020  30        movb @XX19+1,rtmp
     A9BA 0075     
0003 A9BC 06CF  14        swpb ry
0004 A9BE A00F  18        a    ry,rtmp
0005 A9C0 06CF  14        swpb ry
0006 A9C2 D350  26        movb *rtmp,RA
                   < elite.a99
22998 A9C4 D3CD  18        movb ra,ry                      ; TAY               ; set to the explosion count for this ship (i.e. the
22999                                                                          ; number of vertices used as origins for explosion
23000                                                                          ; clouds)
23001                                                                          ;
23002                                                                          ; The explosion count is stored as 4 * n + 6, where n is
23003                                                                          ; the number of vertices, so the following loop copies
23004                                                                          ; the coordinates of the first n vertices from the heap
23005                                                                          ; at XX3, which is where we stored all the visible
23006                                                                          ; vertex coordinates in part 8 of the LL9 routine, and
23007                                                                          ; sticks them in the ship line heap pointed to by XX19,
23008                                                                          ; starting at byte #7 (so it leaves the first 6 bytes of
23009                                                                          ; the ship line heap alone)
23010               
23011               EXL1:
23012 A9C6 D36F  34        movb @XX3-7(ry),ra              ; LDA XX3-7,Y       ; Copy byte Y-7 from the XX3 heap, into the Y-th byte of
     A9C8 00F9     
23013                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 A9CA D820  42        movb @XX19,@rtmplb
     A9CC 0074     
     A9CE 8301     
0002 A9D0 D020  30        movb @XX19+1,rtmp
     A9D2 0075     
0003 A9D4 06CF  14        swpb ry
0004 A9D6 A00F  18        a    ry,rtmp
0005 A9D8 06CF  14        swpb ry
0006 A9DA D40D  30        movb RA,*rtmp
                   < elite.a99
23014               
23015 A9DC 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
23016               
23017 A9DE 028F  22        ci   ry,>06*256                 ; CPY #6            ; Keep copying vertex coordinates into the ship line
     A9E0 0600     
23018 A9E2 16F1  14        jne  EXL1                       ; BNE EXL1          ; heap until Y = 6 (which will copy n vertices, where n
23019                                                                          ; is the number of vertices we should be exploding)
23020               
23021 A9E4 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 6 of the ship's byte #31 to denote that the
     A9E6 0072     
23022 A9E8 026D  22        ori  ra,>40*256                 ; ORA #%01000000    ; explosion has been drawn (as it's about to be)
     A9EA 4000     
23023 A9EC D80D  30        movb ra,@INWK+31                ; STA INWK+31
     A9EE 0072     
23024               
23025               PTCLS:
23026                                                                          ; This part of the routine actually draws the explosion
23027                                                                          ; cloud
23028 A9F0 020F  20        li   ry,>00*256                 ; LDY #0            ; Fetch byte #0 of the ship line heap, which contains
     A9F2 0000     
23029                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; the cloud size we stored above, and store it in Q
     **** ****     > LD_IND_Y_IDX
0001 A9F4 D820  42        movb @XX19,@rtmplb
     A9F6 0074     
     A9F8 8301     
0002 A9FA D020  30        movb @XX19+1,rtmp
     A9FC 0075     
0003 A9FE 06CF  14        swpb ry
0004 AA00 A00F  18        a    ry,rtmp
0005 AA02 06CF  14        swpb ry
0006 AA04 D350  26        movb *rtmp,RA
                   < elite.a99
23030 AA06 D80D  30        movb ra,@Q                      ; STA Q
     AA08 0090     
23031               
23032 AA0A B3C7  18        ab   rone,ry                    ; INY               ; Increment the index in Y to point to byte #1
23033               
23034                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch byte #1 of the ship line heap, which contains
     **** ****     > LD_IND_Y_IDX
0001 AA0C D820  42        movb @XX19,@rtmplb
     AA0E 0074     
     AA10 8301     
0002 AA12 D020  30        movb @XX19+1,rtmp
     AA14 0075     
0003 AA16 06CF  14        swpb ry
0004 AA18 A00F  18        a    ry,rtmp
0005 AA1A 06CF  14        swpb ry
0006 AA1C D350  26        movb *rtmp,RA
                   < elite.a99
23035                                                                          ; the cloud counter. We are now going to process this
23036                                                                          ; into the number of particles in each vertex's cloud
23037               
23038 AA1E 1503  14        jgt  B69                        ; BPL B69           ; If the cloud counter < 128, then we are in the first
23039                                                                          ; half of the cloud's existence, so skip the next
23040                                                                          ; instruction
23041               
23042                      .eoi (>ff*256)                  ; EOR #&FF          ; Flip the value of A so that in the second half of the
     **** ****     > EOI
0001 AA20 0200  20        li   rtmp,(>FF*256)
     AA22 FF00     
0002 AA24 2B40  18        xor  rtmp,ra
                   < elite.a99
23043                                                                          ; cloud's existence, A counts down instead of up
23044               
23045               B69:
23046 AA26 091D  18        srl  ra,1                       ; LSR A             ; Divide A by 8 so that is has a maximum value of 15
23047 AA28 091D  18        srl  ra,1                       ; LSR A
23048 AA2A 091D  18        srl  ra,1                       ; LSR A
23049               
23050 AA2C 026D  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1 and store it in U, to
     AA2E 0100     
23051 AA30 D80D  30        movb ra,@U                      ; STA U             ; give us the number of particles in the explosion for
     AA32 008F     
23052                                                                          ; each vertex
23053               
23054 AA34 B3C7  18        ab   rone,ry                    ; INY               ; Increment the index in Y to point to byte #2
23055               
23056                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch byte #2 of the ship line heap, which contains
     **** ****     > LD_IND_Y_IDX
0001 AA36 D820  42        movb @XX19,@rtmplb
     AA38 0074     
     AA3A 8301     
0002 AA3C D020  30        movb @XX19+1,rtmp
     AA3E 0075     
0003 AA40 06CF  14        swpb ry
0004 AA42 A00F  18        a    ry,rtmp
0005 AA44 06CF  14        swpb ry
0006 AA46 D350  26        movb *rtmp,RA
                   < elite.a99
23057 AA48 D80D  30        movb ra,@TGT                    ; STA TGT           ; the explosion count for this ship (i.e. the number of
     AA4A 00A0     
23058                                                                          ; vertices used as origins for explosion clouds) and
23059                                                                          ; store it in TGT
23060               
23061 AA4C D360  30        movb @RAND+1,ra                 ; LDA RAND+1        ; Fetch the current random number seed in RAND+1 and
     AA4E 0001     
23062                      .pha                            ; PHA               ; store it on the stack, so we can re-randomise the
     **** ****     > PHA
0001 AA50 D68D  30        movb ra,*rsp
0002 AA52 060A  14        dec  rsp
                   < elite.a99
23063                                                                          ; seeds when we are done
23064               
23065 AA54 020F  20        li   ry,>06*256                 ; LDY #6            ; Set Y = 6 to point to the byte before the first vertex
     AA56 0600     
23066                                                                          ; coordinate we stored on the ship line heap above (we
23067                                                                          ; increment it below so it points to the first vertex)
23068               
23069               EXL5:
23070 AA58 020E  20        li   rx,>03*256                 ; LDX #3            ; We are about to fetch a pair of coordinates from the
     AA5A 0300     
23071                                                                          ; ship line heap, so set a counter in X for 4 bytes
23072               
23073               EXL3:
23074 AA5C B3C7  18        ab   rone,ry                    ; INY               ; Increment the index in Y so it points to the next byte
23075                                                                          ; from the coordinate we are copying
23076               
23077                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Copy the Y-th byte from the ship line heap to the X-th
     **** ****     > LD_IND_Y_IDX
0001 AA5E D820  42        movb @XX19,@rtmplb
     AA60 0074     
     AA62 8301     
0002 AA64 D020  30        movb @XX19+1,rtmp
     AA66 0075     
0003 AA68 06CF  14        swpb ry
0004 AA6A A00F  18        a    ry,rtmp
0005 AA6C 06CF  14        swpb ry
0006 AA6E D350  26        movb *rtmp,RA
                   < elite.a99
23078 AA70 DB8D  38        movb ra,@K3(rx)                 ; STA K3,X          ; byte of K3
     AA72 00D2     
23079               
23080 AA74 7387  18        sb   rone,rx                    ; DEX               ; Decrement the X index
23081               
23082 AA76 15F2  14        jgt  EXL3                       ; BPL EXL3          ; Loop back to EXL3 until we have copied all four bytes
23083               
23084                                                                          ; The above loop copies the vertex coordinates from the
23085                                                                          ; ship line heap to K3, reversing them as we go, so it
23086                                                                          ; sets the following:
23087                                                                          ;
23088                                                                          ; K3+3 = x_lo
23089                                                                          ; K3+2 = x_hi
23090                                                                          ; K3+1 = y_lo
23091                                                                          ; K3+0 = y_hi
23092               
23093 AA78 D80F  30        movb ry,@CNT                    ; STY CNT           ; Set CNT to the index that points to the next vertex on
     AA7A 00A4     
23094                                                                          ; the ship line heap
23095               
23096 AA7C 020F  20        li   ry,>02*256                 ; LDY #2            ; Set Y = 2, which we will use to point to bytes #3 to
     AA7E 0200     
23097                                                                          ; #6, after incrementing it
23098               
23099                                                                          ; This next loop copies bytes #3 to #6 from the ship
23100                                                                          ; line heap into the four random number seeds in RAND to
23101                                                                          ; RAND+3, EOR'ing them with the vertex index so they are
23102                                                                          ; different for every vertex. This enables us to
23103                                                                          ; generate random numbers for drawing each vertex that
23104                                                                          ; are random but repeatable, which we need when we
23105                                                                          ; redraw the cloud to remove it
23106                                                                          ;
23107                                                                          ; Note that we haven't actually set the values of bytes
23108                                                                          ; #3 to #6 in the ship line heap, so we have no idea
23109                                                                          ; what they are, we just use what's already there. But
23110                                                                          ; the fact that those bytes are stored for this ship
23111                                                                          ; means we can repeat the random generation of the
23112                                                                          ; cloud, which is the important bit
23113               
23114               EXL2:
23115 AA80 B3C7  18        ab   rone,ry                    ; INY               ; Increment the index in Y so it points to the next
23116                                                                          ; random number seed to copy
23117               
23118                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y-th byte from the ship line heap
     **** ****     > LD_IND_Y_IDX
0001 AA82 D820  42        movb @XX19,@rtmplb
     AA84 0074     
     AA86 8301     
0002 AA88 D020  30        movb @XX19+1,rtmp
     AA8A 0075     
0003 AA8C 06CF  14        swpb ry
0004 AA8E A00F  18        a    ry,rtmp
0005 AA90 06CF  14        swpb ry
0006 AA92 D350  26        movb *rtmp,RA
                   < elite.a99
23119               
23120                      .eor @CNT                       ; EOR CNT           ; EOR with the vertex index, so the seeds are different
     **** ****     > EOR
0001 AA94 D020  30        movb @CNT,rtmp
     AA96 00A4     
0002 AA98 2B40  18        xor  rtmp,ra
                   < elite.a99
23121                                                                          ; for each vertex
23122               
23123 AA9A DBCD  38        movb ra,@>FFFD(ry)              ; STA &FFFD,Y       ; Y is going from 3 to 6, so this stores the four bytes
     AA9C FFFD     
23124                                                                          ; in memory locations &00, &01, &02 and &03, which are
23125                                                                          ; the memory locations of RAND through RAND+3
23126               
23127 AA9E 028F  22        ci   ry,>06*256                 ; CPY #6            ; Loop back to EXL2 until Y = 6, which means we have
     AAA0 0600     
23128 AAA2 16EE  14        jne  EXL2                       ; BNE EXL2          ; copied four bytes
23129               
23130 AAA4 D3E0  30        movb @U,ry                      ; LDY U             ; Set Y to the number of particles in the explosion for
     AAA6 008F     
23131                                                                          ; each vertex, which we stored in U above. We will now
23132                                                                          ; use this as a loop counter to iterate through all the
23133                                                                          ; particles in the explosion
23134               
23135               EXL4:
23136 AAA8 0200  20        li   rtmp,DORND2                ; JSR DORND2        ; Set ZZ to a random number, making sure the C flag
     AAAA C11E     
23137 AAAC 06A0  32        bl   @jsr                       ;
     AAAE FE28     
23138 AAB0 D80D  30        movb ra,@ZZ                     ; STA ZZ            ; doesn't affect the outcome
     AAB2 0097     
23139               
23140 AAB4 D360  30        movb @K3+1,ra                   ; LDA K3+1          ; Set (A R) = (y_hi y_lo)
     AAB6 00D3     
23141 AAB8 D80D  30        movb ra,@R                      ; STA R             ; = y
     AABA 0091     
23142 AABC D360  30        movb @K3,ra                     ; LDA K3
     AABE 00D2     
23143               
23144 AAC0 0200  20        li   rtmp,EXS1                  ; JSR EXS1          ; Set (A X) = (A R) +/- random * cloud size
     AAC2 AB24     
23145 AAC4 06A0  32        bl   @jsr                       ;
     AAC6 FE28     
23146                                                                          ; = y +/- random * cloud size
23147               
23148 AAC8 1627  14        jne  EX11                       ; BNE EX11          ; If A is non-zero, the particle is off-screen as the
23149                                                                          ; coordinate is bigger than 255), so jump to EX11 to do
23150                                                                          ; the next particle
23151               
23152 AACA 028E  22        ci   rx,(2*Y-1)*256             ; CPX #2*Y-1        ; If X > the y-coordinate of the bottom of the screen,
     AACC BF00     
23153 AACE 1824  14        joc  EX11                       ; BCS EX11          ; the particle is off the bottom of the screen, so jump
23154                                                                          ; to EX11 to do the next particle
23155               
23156                                                                          ; Otherwise X contains a random y-coordinate within the
23157                                                                          ; cloud
23158               
23159 AAD0 D80E  30        movb rx,@Y1                     ; STX Y1            ; Set Y1 = our random y-coordinate within the cloud
     AAD2 0032     
23160               
23161 AAD4 D360  30        movb @K3+3,ra                   ; LDA K3+3          ; Set (A R) = (x_hi x_lo)
     AAD6 00D5     
23162 AAD8 D80D  30        movb ra,@R                      ; STA R
     AADA 0091     
23163 AADC D360  30        movb @K3+2,ra                   ; LDA K3+2
     AADE 00D4     
23164               
23165 AAE0 0200  20        li   rtmp,EXS1                  ; JSR EXS1          ; Set (A X) = (A R) +/- random * cloud size
     AAE2 AB24     
23166 AAE4 06A0  32        bl   @jsr                       ;
     AAE6 FE28     
23167                                                                          ; = x +/- random * cloud size
23168               
23169 AAE8 1606  14        jne  EX4                        ; BNE EX4           ; If A is non-zero, the particle is off-screen as the
23170                                                                          ; coordinate is bigger than 255), so jump to EX11 to do
23171                                                                          ; the next particle
23172               
23173                                                                          ; Otherwise X contains a random x-coordinate within the
23174                                                                          ; cloud
23175               
23176 AAEA D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A = our random y-coordinate within the cloud
     AAEC 0032     
23177               
23178 AAEE 0200  20        li   rtmp,PIXEL                 ; JSR PIXEL         ; Draw a point at screen coordinate (X, A) with the
     AAF0 2804     
23179 AAF2 06A0  32        bl   @jsr                       ;
     AAF4 FE28     
23180                                                                          ; point size determined by the distance in ZZ
23181               
23182               EX4:
23183 AAF6 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter for the next particle
23184               
23185 AAF8 15D7  14        jgt  EXL4                       ; BPL EXL4          ; Loop back to EXL4 until we have done all the particles
23186                                                                          ; in the cloud
23187               
23188 AAFA D3E0  30        movb @CNT,ry                    ; LDY CNT           ; Set Y to the index that points to the next vertex on
     AAFC 00A4     
23189                                                                          ; the ship line heap
23190               
23191 AAFE 93E0  30        cb   @TGT,ry                    ; CPY TGT           ; If Y < TGT, which we set to the explosion count for
     AB00 00A0     
23192 AB02 17AA  14        jnc  EXL5                       ; BCC EXL5          ; this ship (i.e. the number of vertices used as origins
23193                                                                          ; for explosion clouds), loop back to EXL5 to do a cloud
23194                                                                          ; for the next vertex
23195               
23196                      .pla                            ; PLA               ; Restore the current random number seed to RAND+1 that
     **** ****     > PLA
0001 AB04 058A  14        inc  rsp
0002 AB06 D35A  26        movb *rsp,ra
                   < elite.a99
23197 AB08 D80D  30        movb ra,@RAND+1                 ; STA RAND+1        ; we stored at the start of the routine
     AB0A 0001     
23198               
23199 AB0C D360  30        movb @K.+6,ra                   ; LDA K%+6          ; Store the z_lo coordinate for the planet (which will
     AB0E 0906     
23200 AB10 D80D  30        movb ra,@RAND+3                 ; STA RAND+3        ; be pretty random) in the RAND+3 seed
     AB12 0003     
23201               
23202 AB14 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AB16 FE34     
23203               
23204               EX11:
23205 AB18 0200  20        li   rtmp,DORND2                ; JSR DORND2        ; Set A and X to random numbers, making sure the C flag
     AB1A C11E     
23206 AB1C 06A0  32        bl   @jsr                       ;
     AB1E FE28     
23207                                                                          ; doesn't affect the outcome
23208               
23209 AB20 0460  28        b    @EX4                       ; JMP EX4           ; We just skipped a particle, so jump up to EX4 to do
     AB22 AAF6     
23210                                                                          ; the next one
23211               
23212               EXS1:
23213                                                                          ; This routine calculates the following:
23214                                                                          ;
23215                                                                          ; (A X) = (A R) +/- random * cloud size
23216                                                                          ;
23217                                                                          ; returning with the flags set for the high byte in A
23218 AB24 D80D  30        movb ra,@S                      ; STA S             ; Store A in S so we can use it later
     AB26 0092     
23219               
23220 AB28 0200  20        li   rtmp,DORND2                ; JSR DORND2        ; Set A and X to random numbers, making sure the C flag
     AB2A C11E     
23221 AB2C 06A0  32        bl   @jsr                       ;
     AB2E FE28     
23222                                                                          ; doesn't affect the outcome
23223               
23224 AB30 06A0  32        bl   @rola                      ; ROL A             ; Set A = A * 2
     AB32 FE3E     
23225               
23226 AB34 1811  14        joc  EX5                        ; BCS EX5           ; If bit 7 of A was set (50% chance), jump to EX5
23227               
23228 AB36 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set A = A * Q / 256
     AB38 43EC     
23229 AB3A 06A0  32        bl   @jsr                       ;
     AB3C FE28     
23230                                                                          ; = random << 1 * projected cloud size / 256
23231               
23232                      .adc @R,ra                      ; ADC R             ; Set (A X) = (S R) + A
     **** ****     > ADC
0001 AB3E 1701  14        jnc  !
0002 AB40 B347  18        ab   rone,ra
0003               !:
0004 AB42 B360  30        ab   @R,ra
     AB44 0091     
                   < elite.a99
23233 AB46 D38D  18        movb ra,rx                      ; TAX               ; = (S R) + random * projected cloud size
23234                                                                          ;
23235                                                                          ; where S contains the argument A, starting with the low
23236                                                                          ; bytes
23237               
23238 AB48 D360  30        movb @S,ra                      ; LDA S             ; And then the high bytes
     AB4A 0092     
23239                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 AB4C 1701  14        jnc  !
0002 AB4E B347  18        ab   rone,ra
0003               !:
0004 AB50 022D  22        ai   ra,(>00*256)
     AB52 0000     
                   < elite.a99
23240               
23241 AB54 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AB56 FE34     
23242               
23243               EX5:
23244 AB58 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     AB5A 43EC     
23245 AB5C 06A0  32        bl   @jsr                       ;
     AB5E FE28     
23246 AB60 D80D  30        movb ra,@T                      ; STA T             ; = random << 1 * projected cloud size / 256
     AB62 00D1     
23247               
23248 AB64 D360  30        movb @R,ra                      ; LDA R             ; Set (A X) = (S R) - T
     AB66 0091     
23249                      .sbc @T,ra                      ; SBC T             ;
     **** ****     > SBC
0001 AB68 1801  14        joc  !
0002 AB6A 7347  18        sb   rone,ra
0003               !:
0004 AB6C 7360  30        sb   @T,ra
     AB6E 00D1     
                   < elite.a99
23250 AB70 D38D  18        movb ra,rx                      ; TAX               ; where S contains the argument A, starting with the low
23251                                                                          ; bytes
23252               
23253 AB72 D360  30        movb @S,ra                      ; LDA S             ; And then the high bytes
     AB74 0092     
23254                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 AB76 1801  14        joc  !
0002 AB78 7347  18        sb   rone,ra
0003               !:
0004 AB7A 022D  22        ai   ra,-(>00*256)
     AB7C 0000     
                   < elite.a99
23255               
23256 AB7E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AB80 FE34     
23257               
23258               * ******************************************************************************
23259               *
23260               * Name: SOS1
23261               * Type: Subroutine
23262               * Category: Universe
23263               * Summary: Update the missile indicators, set up the planet data block
23264               *
23265               * ------------------------------------------------------------------------------
23266               *
23267               * Update the missile indicators, and set up a data block for the planet, but
23268               * only setting the pitch and roll counters to 127 (no damping).
23269               *
23270               * ******************************************************************************
23271               
23272               SOS1:
23273 AB82 0200  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     AB84 C08C     
23274 AB86 06A0  32        bl   @jsr                       ;
     AB88 FE28     
23275                                                                          ; them are targeted
23276               
23277 AB8A 020D  20        li   ra,>7f*256                 ; LDA #127          ; Set the pitch and roll counters to 127, so that's a
     AB8C 7F00     
23278 AB8E D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; clockwise roll and a diving pitch with no damping, so
     AB90 0070     
23279 AB92 D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; the planet's rotation doesn't slow down
     AB94 0071     
23280               
23281 AB96 D360  30        movb @tek_,ra                   ; LDA tek           ; Set A = 128 or 130 depending on bit 1 of the system's
     AB98 0F1D     
23282 AB9A 024D  22        andi ra,>02*256                 ; AND #%00000010    ; tech level in tek
     AB9C 0200     
23283 AB9E 026D  22        ori  ra,>80*256                 ; ORA #%10000000
     ABA0 8000     
23284               
23285 ABA2 0460  28        b    @NWSHP                     ; JMP NWSHP         ; Add a new planet to our local bubble of universe,
     ABA4 AFC6     
23286                                                                          ; with the planet type defined by A (128 is a planet
23287                                                                          ; with an equator and meridian, 130 is a planet with
23288                                                                          ; a crater)
23289               
23290               * ******************************************************************************
23291               *
23292               * Name: SOLAR
23293               * Type: Subroutine
23294               * Category: Universe
23295               * Summary: Set up various aspects of arriving in a new system
23296               *
23297               * ------------------------------------------------------------------------------
23298               *
23299               * Halve our legal status, update the missile indicators, and set up data blocks
23300               * and slots for the planet and sun.
23301               *
23302               * ******************************************************************************
23303               
23304               SOLAR:
23305                      .lsr @FIST                      ; LSR FIST          ; Halve our legal status in FIST, making us less bad,
     **** ****     > LSR
0001 ABA6 D020  30        movb @FIST,rtmp
     ABA8 0334     
0002 ABAA 0910  18        srl  rtmp,1
0003 ABAC D800  30        movb rtmp,@FIST
     ABAE 0334     
                   < elite.a99
23306                                                                          ; and moving bit 0 into the C flag (so every time we
23307                                                                          ; arrive in a new system, our legal status improves a
23308                                                                          ; bit)
23309               
23310 ABB0 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace, which
     ABB2 C064     
23311 ABB4 06A0  32        bl   @jsr                       ;
     ABB6 FE28     
23312                                                                          ; doesn't affect the C flag
23313               
23314 ABB8 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch s0_hi
     ABBA 0079     
23315               
23316 ABBC 024D  22        andi ra,>07*256                 ; AND #%00000111    ; Extract bits 0-2 (which also happen to determine the
     ABBE 0700     
23317                                                                          ; economy), which will be between 0 and 7
23318               
23319                      .adi (>06*256)                  ; ADC #6            ; Add 6 + C, and divide by 2, to get a result between 3
     **** ****     > ADI
0001 ABC0 1701  14        jnc  !
0002 ABC2 B347  18        ab   rone,ra
0003               !:
0004 ABC4 022D  22        ai   ra,(>06*256)
     ABC6 0600     
                   < elite.a99
23320 ABC8 091D  18        srl  ra,1                       ; LSR A             ; and 7, at the same time shifting bit 0 of the result
23321                                                                          ; of the addition into the C flag
23322               
23323 ABCA D80D  30        movb ra,@INWK+8                 ; STA INWK+8        ; Store the result in z_sign in byte #6
     ABCC 005B     
23324               
23325 ABCE 06A0  32        bl   @rora                      ; ROR A             ; Halve A, rotating in the C flag, which was previously
     ABD0 FE62     
23326 ABD2 D80D  30        movb ra,@INWK+2                 ; STA INWK+2        ; bit 0 of s0_hi + 6 + C, so when this is stored in both
     ABD4 0055     
23327 ABD6 D80D  30        movb ra,@INWK+5                 ; STA INWK+5        ; x_sign and y_sign, it moves the planet to the upper
     ABD8 0058     
23328                                                                          ; right or lower left
23329               
23330 ABDA 0200  20        li   rtmp,SOS1                  ; JSR SOS1          ; Call SOS1 to set up the planet's data block and add it
     ABDC AB82     
23331 ABDE 06A0  32        bl   @jsr                       ;
     ABE0 FE28     
23332                                                                          ; to FRIN, where it will get put in the first slot as
23333                                                                          ; it's the first one to be added to our local bubble of
23334                                                                          ; this new system's universe
23335               
23336 ABE2 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Fetch s1_hi, extract bits 0-2, set bits 0 and 7 and
     ABE4 007B     
23337 ABE6 024D  22        andi ra,>07*256                 ; AND #%00000111    ; store in z_sign, so the sun is behind us at a distance
     ABE8 0700     
23338 ABEA 026D  22        ori  ra,>81*256                 ; ORA #%10000001    ; of 1 to 7
     ABEC 8100     
23339 ABEE D80D  30        movb ra,@INWK+8                 ; STA INWK+8
     ABF0 005B     
23340               
23341 ABF2 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Fetch s2_hi, extract bits 0-1 and store in x_sign and
     ABF4 007D     
23342 ABF6 024D  22        andi ra,>03*256                 ; AND #%00000011    ; y_sign, so the sun is either dead centre in our rear
     ABF8 0300     
23343 ABFA D80D  30        movb ra,@INWK+2                 ; STA INWK+2        ; laser crosshairs, or off to the top left by a distance
     ABFC 0055     
23344 ABFE D80D  30        movb ra,@INWK+1                 ; STA INWK+1        ; of 1 or 2 when we look out the back
     AC00 0054     
23345               
23346 AC02 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the pitch and roll counters to 0 (no rotation)
     AC04 0000     
23347 AC06 D80D  30        movb ra,@INWK+29                ; STA INWK+29
     AC08 0070     
23348 AC0A D80D  30        movb ra,@INWK+30                ; STA INWK+30
     AC0C 0071     
23349               
23350 AC0E 020D  20        li   ra,>81*256                 ; LDA #129          ; Set A = 129, the ship type for the sun
     AC10 8100     
23351               
23352 AC12 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Call NWSHP to set up the sun's data block and add it
     AC14 AFC6     
23353 AC16 06A0  32        bl   @jsr                       ;
     AC18 FE28     
23354                                                                          ; to FRIN, where it will get put in the second slot as
23355                                                                          ; it's the second one to be added to our local bubble
23356                                                                          ; of this new system's universe
23357               
23358               * ******************************************************************************
23359               *
23360               * Name: NWSTARS
23361               * Type: Subroutine
23362               * Category: Stardust
23363               * Summary: Initialise the stardust field
23364               *
23365               * ------------------------------------------------------------------------------
23366               *
23367               * This routine is called when the space view is initialised in routine LOOK1.
23368               *
23369               * ******************************************************************************
23370               
23371               NWSTARS:
23372 AC1A D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to WPSHPS to skip
     AC1C 0096     
23373               * ORA MJ                 \ the initialisation of the SX, SY and SZ tables. The OR
23374 AC1E 1622  14        jne  WPSHPS                     ; BNE WPSHPS        ; instruction is commented out in the original source,
23375                                                                          ; but it would have the effect of also skipping the
23376                                                                          ; initialisation if we had mis-jumped into witchspace
23377               
23378               * ******************************************************************************
23379               *
23380               * Name: nWq
23381               * Type: Subroutine
23382               * Category: Stardust
23383               * Summary: Create a random cloud of stardust
23384               *
23385               * ------------------------------------------------------------------------------
23386               *
23387               * Create a random cloud of stardust containing the correct number of dust
23388               * particles, i.e. NOSTM of them, which is 3 in witchspace and 18 (#NOST) in
23389               * normal space. Also clears the scanner and initialises the LSO block.
23390               *
23391               * This is called by the DEATH routine when it displays our untimely demise.
23392               *
23393               * ******************************************************************************
23394               
23395               nWq:
23396 AC20 D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     AC22 0F33     
23397                                                                          ; we can use it as a counter through all the stardust
23398               
23399               SAL4:
23400 AC24 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     AC26 C120     
23401 AC28 06A0  32        bl   @jsr                       ;
     AC2A FE28     
23402               
23403 AC2C 026D  22        ori  ra,>08*256                 ; ORA #8            ; Set A so that it's at least 8
     AC2E 0800     
23404               
23405 AC30 DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; Store A in the Y-th particle's z_hi coordinate at
     AC32 0EE8     
23406                                                                          ; SZ+Y, so the particle appears in front of us
23407               
23408 AC34 D80D  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the particle's z_hi coordinate
     AC36 0097     
23409               
23410 AC38 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     AC3A C120     
23411 AC3C 06A0  32        bl   @jsr                       ;
     AC3E FE28     
23412               
23413 AC40 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; Store A in the Y-th particle's x_hi coordinate at
     AC42 034C     
23414                                                                          ; SX+Y, so the particle appears in front of us
23415               
23416 AC44 D80D  30        movb ra,@X1                     ; STA X1            ; Set X1 to the particle's x_hi coordinate
     AC46 0031     
23417               
23418 AC48 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     AC4A C120     
23419 AC4C 06A0  32        bl   @jsr                       ;
     AC4E FE28     
23420               
23421 AC50 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; Store A in the Y-th particle's y_hi coordinate at
     AC52 0EC2     
23422                                                                          ; SY+Y, so the particle appears in front of us
23423               
23424 AC54 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 to the particle's y_hi coordinate
     AC56 0032     
23425               
23426 AC58 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ
     AC5A 27B4     
23427 AC5C 06A0  32        bl   @jsr                       ;
     AC5E FE28     
23428               
23429 AC60 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point to the next particle of
23430                                                                          ; stardust
23431               
23432 AC62 16E0  14        jne  SAL4                       ; BNE SAL4          ; Loop back to SAL4 until we have randomised all the
23433                                                                          ; stardust particles
23434               
23435                                                                          ; Fall through into WPSHPS to clear the scanner and
23436                                                                          ; reset the LSO block
23437               
23438               * ******************************************************************************
23439               *
23440               * Name: WPSHPS
23441               * Type: Subroutine
23442               * Category: Dashboard
23443               * Summary: Clear the scanner, reset the ball line and sun line heaps
23444               *
23445               * ------------------------------------------------------------------------------
23446               *
23447               * Remove all ships from the scanner, reset the sun line heap at LSO, and reset
23448               * the ball line heap at LSX2 and LSY2.
23449               *
23450               * ******************************************************************************
23451               
23452               WPSHPS:
23453 AC64 020E  20        li   rx,>00*256                 ; LDX #0            ; Set up a counter in X to work our way through all the
     AC66 0000     
23454                                                                          ; ship slots in FRIN
23455               
23456               WSL1:
23457 AC68 D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the ship type in slot X
     AC6A 0D40     
23458               
23459 AC6C 1336  14        jeq  WS2                        ; BEQ WS2           ; If the slot contains 0 then it is empty and we have
23460                                                                          ; checked all the slots (as they are always shuffled
23461                                                                          ; down in the main loop to close up and gaps), so jump
23462                                                                          ; to WS2 as we are done
23463               
23464 AC6E 1133  14        jlt  WS1                        ; BMI WS1           ; If the slot contains a ship type with bit 7 set, then
23465                                                                          ; it contains the planet or the sun, so jump down to WS1
23466                                                                          ; to skip this slot, as the planet and sun don't appear
23467                                                                          ; on the scanner
23468               
23469 AC70 D80D  30        movb ra,@TYPE                   ; STA TYPE          ; Store the ship type in TYPE
     AC72 009B     
23470               
23471 AC74 0200  20        li   rtmp,GINF                  ; JSR GINF          ; Call GINF to get the address of the data block for
     AC76 AF58     
23472 AC78 06A0  32        bl   @jsr                       ;
     AC7A FE28     
23473                                                                          ; ship slot X and store it in INF
23474               
23475 AC7C 020F  20        li   ry,>1f*256                 ; LDY #31           ; We now want to copy the first 32 bytes from the ship's
     AC7E 1F00     
23476                                                                          ; data block into INWK, so set a counter in Y
23477               
23478               WSL2:
23479                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Copy the Y-th byte from the data block pointed to by
     **** ****     > LD_IND_Y_IDX
0001 AC80 D820  42        movb @INF,@rtmplb
     AC82 0020     
     AC84 8301     
0002 AC86 D020  30        movb @INF+1,rtmp
     AC88 0021     
0003 AC8A 06CF  14        swpb ry
0004 AC8C A00F  18        a    ry,rtmp
0005 AC8E 06CF  14        swpb ry
0006 AC90 D350  26        movb *rtmp,RA
                   < elite.a99
23480 AC92 DBCD  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; INF into the Y-th byte of INWK workspace
     AC94 0053     
23481               
23482 AC96 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point at the next byte
23483               
23484 AC98 15F3  14        jgt  WSL2                       ; BPL WSL2          ; Loop back to WSL2 until we have copied all 32 bytes
23485               
23486 AC9A D80E  30        movb rx,@XSAV                   ; STX XSAV          ; Store the ship slot number in XSAV while we call SCAN
     AC9C 0093     
23487               
23488 AC9E 0200  20        li   rtmp,SCAN                  ; JSR SCAN          ; Call SCAN to plot this ship on the scanner, which will
     ACA0 4D3E     
23489 ACA2 06A0  32        bl   @jsr                       ;
     ACA4 FE28     
23490                                                                          ; remove it as it's plotted with EOR logic
23491               
23492 ACA6 D3A0  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the ship slot number from XSAV into X
     ACA8 0093     
23493               
23494 ACAA 020F  20        li   ry,>1f*256                 ; LDY #31           ; Clear bits 3, 4 and 6 in the ship's byte #31, which
     ACAC 1F00     
23495                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; stops drawing the ship on-screen (bit 3), hides it
     **** ****     > LD_IND_Y_IDX
0001 ACAE D820  42        movb @INF,@rtmplb
     ACB0 0020     
     ACB2 8301     
0002 ACB4 D020  30        movb @INF+1,rtmp
     ACB6 0021     
0003 ACB8 06CF  14        swpb ry
0004 ACBA A00F  18        a    ry,rtmp
0005 ACBC 06CF  14        swpb ry
0006 ACBE D350  26        movb *rtmp,RA
                   < elite.a99
23496 ACC0 024D  22        andi ra,>a7*256                 ; AND #%10100111    ; from the scanner (bit 4) and stops any lasers firing
     ACC2 A700     
23497                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; (bit 6)
     **** ****     > ST_IND_Y_IDX
0001 ACC4 D820  42        movb @INF,@rtmplb
     ACC6 0020     
     ACC8 8301     
0002 ACCA D020  30        movb @INF+1,rtmp
     ACCC 0021     
0003 ACCE 06CF  14        swpb ry
0004 ACD0 A00F  18        a    ry,rtmp
0005 ACD2 06CF  14        swpb ry
0006 ACD4 D40D  30        movb RA,*rtmp
                   < elite.a99
23498               
23499               WS1:
23500 ACD6 B387  18        ab   rone,rx                    ; INX               ; Increment X to point to the next ship slot
23501               
23502 ACD8 16C7  14        jne  WSL1                       ; BNE WSL1          ; Loop back up to process the next slot (this BNE is
23503                                                                          ; effectively a JMP as X will never be zero)
23504               
23505               WS2:
23506 ACDA 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set LSX2 = LSY2 = &FF to clear the ball line heap
     ACDC FF00     
23507 ACDE D80E  30        movb rx,@LSX2                   ; STX LSX2
     ACE0 0E26     
23508 ACE2 D80E  30        movb rx,@LSY2                   ; STX LSY2
     ACE4 0E74     
23509               
23510                                                                          ; Fall through into FLFLLS to reset the LSO block
23511               
23512               * ******************************************************************************
23513               *
23514               * Name: FLFLLS
23515               * Type: Subroutine
23516               * Category: Drawing suns
23517               * Summary: Reset the sun line heap
23518               *
23519               * ------------------------------------------------------------------------------
23520               *
23521               * Reset the sun line heap at LSO by zero-filling it and setting the first byte
23522               * to &FF.
23523               *
23524               * ------------------------------------------------------------------------------
23525               *
23526               * Returns:
23527               *
23528               * A                   A is set to 0
23529               *
23530               * ******************************************************************************
23531               
23532               FLFLLS:
23533 ACE6 020F  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     ACE8 BF00     
23534                                                                          ; view, so this sets Y as a counter for the number of
23535                                                                          ; lines in the space view (i.e. 191), which is also the
23536                                                                          ; number of lines in the LSO block
23537               
23538 ACEA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can zero-fill the LSO block
     ACEC 0000     
23539               
23540               SAL6:
23541 ACEE DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; Set the Y-th byte of the LSO block to 0
     ACF0 0D66     
23542               
23543 ACF2 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter
23544               
23545 ACF4 16FC  14        jne  SAL6                       ; BNE SAL6          ; Loop back until we have filled all the way to LSO+1
23546               
23547 ACF6 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to value of &FF (as we exit the above loop
23548                                                                          ; with Y = 0)
23549               
23550 ACF8 D80F  30        movb ry,@LSX                    ; STY LSX           ; Set the first byte of the LSO block, which has its own
     ACFA 0D66     
23551                                                                          ; label LSX, to &FF, to indicate that the sun line heap
23552                                                                          ; is empty
23553               
23554 ACFC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     ACFE FE34     
23555               
23556               * ******************************************************************************
23557               *
23558               * Name: DET1
23559               * Type: Subroutine
23560               * Category: Drawing the screen
23561               * Summary: Show or hide the dashboard (for when we die)
23562               *
23563               * ------------------------------------------------------------------------------
23564               *
23565               * This routine sets the screen to show the number of text rows given in X.
23566               *
23567               * It is used when we are killed, as reducing the number of rows from the usual
23568               * 31 to 24 has the effect of hiding the dashboard, leaving a monochrome image
23569               * of ship debris and explosion clouds. Increasing the rows back up to 31 makes
23570               * the dashboard reappear, as the dashboard's screen memory doesn't get touched
23571               * by this process.
23572               *
23573               * ------------------------------------------------------------------------------
23574               *
23575               * Arguments:
23576               *
23577               * X                   The number of text rows to display on the screen (24
23578               * will hide the dashboard, 31 will make it reappear)
23579               *
23580               * ------------------------------------------------------------------------------
23581               *
23582               * Returns:
23583               *
23584               * A                   A is set to 6
23585               *
23586               * ******************************************************************************
23587               
23588               DET1:
23589 AD00 020D  20        li   ra,>06*256                 ; LDA #6            ; Set A to 6 so we can update 6845 register R6 below
     AD02 0600     
23590               
23591 AD04 0300  22        limi 0                          ; SEI               ; Disable interrupts so we can update the 6845
     AD06 0000     
23592               
23593 AD08 D80D  38        movb ra,@VIA+>00                ; STA VIA+&00       ; Set 6845 register R6 to the value in X. Register R6
     AD0A FE00     
23594 AD0C D80E  38        movb rx,@VIA+>01                ; STX VIA+&01       ; is the "vertical displayed" register, which sets the
     AD0E FE01     
23595                                                                          ; number of rows shown on the screen
23596               
23597 AD10 0300  22        limi 2                          ; CLI               ; Re-enable interrupts
     AD12 0002     
23598               
23599 AD14 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AD16 FE34     
23600               
23601               * ******************************************************************************
23602               *
23603               * Name: SHD
23604               * Type: Subroutine
23605               * Category: Flight
23606               * Summary: Charge a shield and drain some energy from the energy banks
23607               *
23608               * ------------------------------------------------------------------------------
23609               *
23610               * Charge up a shield, and if it needs charging, drain some energy from the
23611               * energy banks.
23612               *
23613               * ------------------------------------------------------------------------------
23614               *
23615               * Arguments:
23616               *
23617               * X                   The value of the shield to recharge
23618               *
23619               * ******************************************************************************
23620               
23621 AD18 7387  18        sb   rone,rx                    ; DEX               ; Increment the shield value so that it doesn't go past
23622                                                                          ; a maximum of 255
23623               
23624 AD1A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AD1C FE34     
23625               
23626               SHD:
23627 AD1E B387  18        ab   rone,rx                    ; INX               ; Increment the shield value
23628               
23629 AD20 13FD  14        jeq  SHD-2                      ; BEQ SHD-2         ; If the shield value is 0 then this means it was 255
23630                                                                          ; before, which is the maximum value, so jump to SHD-2
23631                                                                          ; to bring it back down to 258 and return
23632               
23633                                                                          ; Otherwise fall through into DENGY to drain our energy
23634                                                                          ; to pay for all this shield charging
23635               
23636               * ******************************************************************************
23637               *
23638               * Name: DENGY
23639               * Type: Subroutine
23640               * Category: Flight
23641               * Summary: Drain some energy from the energy banks
23642               *
23643               * ------------------------------------------------------------------------------
23644               *
23645               * Returns:
23646               *
23647               * Z flag              Set if we have no energy left, clear otherwise
23648               *
23649               * ******************************************************************************
23650               
23651               DENGY:
23652 AD22 7347  18        sb   rone,ra                    ; DEC ENERGY        ; Decrement the energy banks in ENERGY
23653               
23654                      .php                            ; PHP               ; Save the flags on the stack
     **** ****     > PHP
0001 AD24 02C0  12        stst rtmp
0002 AD26 D680  30        movb rtmp,*rsp
0003 AD28 060A  14        dec  rsp
                   < elite.a99
23655               
23656 AD2A 1601  14        jne  B70                        ; BNE B70           ; If the energy levels are not yet zero, skip the
23657                                                                          ; following instruction
23658               
23659 AD2C B347  18        ab   rone,ra                    ; INC ENERGY        ; The minimum allowed energy level is 1, and we just
23660                                                                          ; reached 0, so increment ENERGY back to 1
23661               
23662               B70:
23663                      .plp                            ; PLP               ; Restore the flags from the stack, so we return with
     **** ****     > PLP
0001 AD2E 058A  14        inc  rsp
0002 AD30 D01A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
23664                                                                          ; the Z flag from the DEC instruction above
23665               
23666 AD32 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AD34 FE34     
23667               
23668               * ******************************************************************************
23669               *
23670               * Name: COMPAS
23671               * Type: Subroutine
23672               * Category: Dashboard
23673               * Summary: Update the compass
23674               *
23675               * ******************************************************************************
23676               
23677               COMPAS:
23678 AD36 0200  20        li   rtmp,DOT                   ; JSR DOT           ; Call DOT to redraw (i.e. remove) the current compass
     AD38 AE00     
23679 AD3A 06A0  32        bl   @jsr                       ;
     AD3C FE28     
23680                                                                          ; dot
23681               
23682 AD3E D360  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     AD40 0D55     
23683 AD42 1634  14        jne  SP1                        ; BNE SP1           ; SP1 to draw the space station on the compass
23684               
23685 AD44 0200  20        li   rtmp,SPS1                  ; JSR SPS1          ; Otherwise we need to draw the planet on the compass,
     AD46 CA26     
23686 AD48 06A0  32        bl   @jsr                       ;
     AD4A FE28     
23687                                                                          ; so first call SPS1 to calculate the vector to the
23688                                                                          ; planet and store it in XX15
23689               
23690 AD4C 0460  28        b    @SP2                       ; JMP SP2           ; Jump to SP2 to draw XX15 on the compass, returning
     AD4E ADB4     
23691                                                                          ; from the subroutine using a tail call
23692               
23693               * ******************************************************************************
23694               *
23695               * Name: SPS2
23696               * Type: Subroutine
23697               * Category: Maths (Arithmetic)
23698               * Summary: Calculate (Y X) = A / 10
23699               *
23700               * ------------------------------------------------------------------------------
23701               *
23702               * Calculate the following, where A is a sign-magnitude 8-bit integer and the
23703               * result is a signed 16-bit integer:
23704               *
23705               * (Y X) = A / 10
23706               *
23707               * ------------------------------------------------------------------------------
23708               *
23709               * Returns:
23710               *
23711               * C flag              The C flag is cleared
23712               *
23713               * ******************************************************************************
23714               
23715               SPS2:
23716                      .asla                           ; ASL A             ; Set X = |A| * 2, and set the C flag to the sign bit of
     **** ****     > ASLA
0001 AD50 024D  22        andi ra,>ff00
     AD52 FF00     
0002 AD54 0A1D  18        sla  ra,1
                   < elite.a99
23717 AD56 D38D  18        movb ra,rx                      ; TAX               ; A
23718               
23719 AD58 020D  20        li   ra,>00*256                 ; LDA #0            ; Set Y to have the sign bit from A in bit 7, with the
     AD5A 0000     
23720 AD5C 06A0  32        bl   @rora                      ; ROR A             ; rest of its bits zeroed, so Y now contains the sign of
     AD5E FE62     
23721 AD60 D3CD  18        movb ra,ry                      ; TAY               ; the original argument
23722               
23723 AD62 020D  20        li   ra,>14*256                 ; LDA #20           ; Set Q = 20
     AD64 1400     
23724 AD66 D80D  30        movb ra,@Q                      ; STA Q
     AD68 0090     
23725               
23726 AD6A D34E  18        movb rx,ra                      ; TXA               ; Copy X into A, so A now contains the argument A * 2
23727               
23728 AD6C 0200  20        li   rtmp,DVID4                 ; JSR DVID4         ; Calculate the following:
     AD6E 4664     
23729 AD70 06A0  32        bl   @jsr                       ;
     AD72 FE28     
23730                                                                          ;
23731                                                                          ; P = A / Q
23732                                                                          ; = |argument A| * 2 / 20
23733                                                                          ; = |argument A| / 10
23734               
23735 AD74 D3A0  30        movb @P,rx                      ; LDX P             ; Set X to the result
     AD76 001B     
23736               
23737 AD78 D34F  18        movb ry,ra                      ; TYA               ; If the sign of the original argument A is negative,
23738 AD7A 1104  14        jlt  LL163                      ; BMI LL163         ; jump to LL163 to flip the sign of the result
23739               
23740 AD7C 020F  20        li   ry,>00*256                 ; LDY #0            ; Set the high byte of the result to 0, as the result is
     AD7E 0000     
23741                                                                          ; positive
23742               
23743 AD80 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AD82 FE34     
23744               
23745               LL163:
23746 AD84 020F  20        li   ry,>ff*256                 ; LDY #&FF          ; The result is negative, so set the high byte to &FF
     AD86 FF00     
23747               
23748 AD88 D34E  18        movb rx,ra                      ; TXA               ; Flip the low byte and add 1 to get the negated low
23749                      .eoi (>ff*256)                  ; EOR #&FF          ; byte, using two's complement
     **** ****     > EOI
0001 AD8A 0200  20        li   rtmp,(>FF*256)
     AD8C FF00     
0002 AD8E 2B40  18        xor  rtmp,ra
                   < elite.a99
23750 AD90 D38D  18        movb ra,rx                      ; TAX
23751 AD92 B387  18        ab   rone,rx                    ; INX
23752               
23753 AD94 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AD96 FE34     
23754               
23755               * ******************************************************************************
23756               *
23757               * Name: SPS4
23758               * Type: Subroutine
23759               * Category: Maths (Geometry)
23760               * Summary: Calculate the vector to the space station
23761               *
23762               * ------------------------------------------------------------------------------
23763               *
23764               * Calculate the vector between our ship and the space station and store it in
23765               * XX15.
23766               *
23767               * ******************************************************************************
23768               
23769               SPS4:
23770 AD98 020E  20        li   rx,>08*256                 ; LDX #8            ; First we need to copy the space station's coordinates
     AD9A 0800     
23771                                                                          ; into K3, so set a counter to copy the first 9 bytes
23772                                                                          ; (the 3-byte x, y and z coordinates) from the station's
23773                                                                          ; data block at K% + NI% into K3
23774               
23775               SPL1:
23776 AD9C D36E  34        movb @K.+NI.(rx),ra             ; LDA K%+NI%,X      ; Copy the X-th byte from the station's data block at
     AD9E 0924     
23777 ADA0 DB8D  38        movb ra,@K3(rx)                 ; STA K3,X          ; K% + NI% to the X-th byte of K3
     ADA2 00D2     
23778               
23779 ADA4 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
23780               
23781 ADA6 15FA  14        jgt  SPL1                       ; BPL SPL1          ; Loop back to SPL1 until we have copied all 9 bytes
23782               
23783 ADA8 0460  28        b    @TAS2                      ; JMP TAS2          ; Call TAS2 to build XX15 from K3, returning from the
     ADAA CA4A     
23784                                                                          ; subroutine using a tail call
23785               
23786               * ******************************************************************************
23787               *
23788               * Name: SP1
23789               * Type: Subroutine
23790               * Category: Dashboard
23791               * Summary: Draw the space station on the compass
23792               *
23793               * ******************************************************************************
23794               
23795               SP1:
23796 ADAC 0200  20        li   rtmp,SPS4                  ; JSR SPS4          ; Call SPS4 to calculate the vector to the space station
     ADAE AD98     
23797 ADB0 06A0  32        bl   @jsr                       ;
     ADB2 FE28     
23798                                                                          ; and store it in XX15
23799               
23800                                                                          ; Fall through into SP2 to draw XX15 on the compass
23801               
23802               * ******************************************************************************
23803               *
23804               * Name: SP2
23805               * Type: Subroutine
23806               * Category: Dashboard
23807               * Summary: Draw a dot on the compass, given the planet/station vector
23808               *
23809               * ------------------------------------------------------------------------------
23810               *
23811               * Draw a dot on the compass to represent the planet or station, whose normalised
23812               * vector is in XX15.
23813               *
23814               * XX15 to XX15+2      The normalised vector to the planet or space station,
23815               * stored as x in XX15, y in XX15+1 and z in XX15+2
23816               *
23817               * ******************************************************************************
23818               
23819               SP2:
23820 ADB4 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A to the x-coordinate of the planet or station to
     ADB6 0031     
23821                                                                          ; show on the compass, which will be in the range -96 to
23822                                                                          ; +96 as the vector has been normalised
23823               
23824 ADB8 0200  20        li   rtmp,SPS2                  ; JSR SPS2          ; Set (Y X) = A / 10, so X will be from -9 to +9, which
     ADBA AD50     
23825 ADBC 06A0  32        bl   @jsr                       ;
     ADBE FE28     
23826                                                                          ; is the x-offset from the centre of the compass of the
23827                                                                          ; dot we want to draw. Returns with the C flag clear
23828               
23829 ADC0 D34E  18        movb rx,ra                      ; TXA               ; Set COMX = 195 + X, as 186 is the pixel x-coordinate
23830                      .adi (>c3*256)                  ; ADC #195          ; of the leftmost dot possible on the compass, and X can
     **** ****     > ADI
0001 ADC2 1701  14        jnc  !
0002 ADC4 B347  18        ab   rone,ra
0003               !:
0004 ADC6 022D  22        ai   ra,(>C3*256)
     ADC8 C300     
                   < elite.a99
23831 ADCA D80D  30        movb ra,@COMX                   ; STA COMX          ; be -9, which would be 195 - 9 = 186. This also means
     ADCC 0F16     
23832                                                                          ; that the highest value for COMX is 195 + 9 = 204,
23833                                                                          ; which is the pixel x-coordinate of the rightmost dot
23834                                                                          ; in the compass... but the compass dot is actually two
23835                                                                          ; pixels wide, so the compass dot can overlap the right
23836                                                                          ; edge of the compass, but not the left edge
23837               
23838 ADCE D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A to the y-coordinate of the planet or station to
     ADD0 0032     
23839                                                                          ; show on the compass, which will be in the range -96 to
23840                                                                          ; +96 as the vector has been normalised
23841               
23842 ADD2 0200  20        li   rtmp,SPS2                  ; JSR SPS2          ; Set (Y X) = A / 10, so X will be from -9 to +9, which
     ADD4 AD50     
23843 ADD6 06A0  32        bl   @jsr                       ;
     ADD8 FE28     
23844                                                                          ; is the x-offset from the centre of the compass of the
23845                                                                          ; dot we want to draw. Returns with the C flag clear
23846               
23847 ADDA D80E  30        movb rx,@T                      ; STX T             ; Set COMY = 204 - X, as 203 is the pixel y-coordinate
     ADDC 00D1     
23848 ADDE 020D  20        li   ra,>cc*256                 ; LDA #204          ; of the centre of the compass, the C flag is clear,
     ADE0 CC00     
23849                      .sbc @T,ra                      ; SBC T             ; and the y-axis needs to be flipped around (because
     **** ****     > SBC
0001 ADE2 1801  14        joc  !
0002 ADE4 7347  18        sb   rone,ra
0003               !:
0004 ADE6 7360  30        sb   @T,ra
     ADE8 00D1     
                   < elite.a99
23850 ADEA D80D  30        movb ra,@COMY                   ; STA COMY          ; when the planet or station is above us, and the
     ADEC 0F17     
23851                                                                          ; vector is therefore positive, we want to show the dot
23852                                                                          ; higher up on the compass, which has a smaller pixel
23853                                                                          ; y-coordinate). So this calculation does this:
23854                                                                          ;
23855                                                                          ; COMY = 204 - X - (1 - 0) = 203 - X
23856               
23857 ADEE 020D  20        li   ra,>f0*256                 ; LDA #&F0          ; Set A to a 4-pixel mode 5 byte row in colour 2
     ADF0 F000     
23858                                                                          ; (yellow/white), the colour for when the planet or
23859                                                                          ; station in the compass is in front of us
23860               
23861 ADF2 D3A0  30        movb @XX15+2,rx                 ; LDX XX15+2        ; If the z-coordinate of the XX15 vector is positive,
     ADF4 0033     
23862 ADF6 1502  14        jgt  B71                        ; BPL B71           ; skip the following instruction
23863               
23864 ADF8 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; The z-coordinate of XX15 is negative, so the planet or
     ADFA FF00     
23865                                                                          ; station is behind us and the compass dot should be in
23866                                                                          ; green/cyan, so set A to a 4-pixel mode 5 byte row in
23867                                                                          ; colour 3
23868               
23869               B71:
23870 ADFC D80D  30        movb ra,@COMC                   ; STA COMC          ; Store the compass colour in COMC
     ADFE 0F48     
23871               
23872                                                                          ; Fall through into DOT to draw the dot on the compass
23873               
23874               * ******************************************************************************
23875               *
23876               * Name: DOT
23877               * Type: Subroutine
23878               * Category: Dashboard
23879               * Summary: Draw a dash on the compass
23880               *
23881               * ------------------------------------------------------------------------------
23882               *
23883               * Arguments:
23884               *
23885               * COMX                The screen pixel x-coordinate of the dash
23886               *
23887               * COMY                The screen pixel y-coordinate of the dash
23888               *
23889               * COMC                The colour and thickness of the dash:
23890               *
23891               * * &F0 = a double-height dash in yellow/white, for when
23892               * the object in the compass is in front of us
23893               *
23894               * * &FF = a single-height dash in green/cyan, for when
23895               * the object in the compass is behind us
23896               *
23897               * ******************************************************************************
23898               
23899               DOT:
23900 AE00 D360  30        movb @COMY,ra                   ; LDA COMY          ; Set Y1 = COMY, the y-coordinate of the dash
     AE02 0F17     
23901 AE04 D80D  30        movb ra,@Y1                     ; STA Y1
     AE06 0032     
23902               
23903 AE08 D360  30        movb @COMX,ra                   ; LDA COMX          ; Set X1 = COMX, the x-coordinate of the dash
     AE0A 0F16     
23904 AE0C D80D  30        movb ra,@X1                     ; STA X1
     AE0E 0031     
23905               
23906 AE10 D360  30        movb @COMC,ra                   ; LDA COMC          ; Set COL = COMC, the mode 5 colour byte for the dash
     AE12 0F48     
23907 AE14 D80D  30        movb ra,@COL                    ; STA COL
     AE16 00A2     
23908               
23909 AE18 028D  22        ci   ra,>f0*256                 ; CMP #&F0          ; If COL is &F0 then the planet/station is in front of
     AE1A F000     
23910 AE1C 1605  14        jne  CPIX2                      ; BNE CPIX2         ; us and we want to draw a double-height dash, so if it
23911                                                                          ; isn't &F0 jump to CPIX2 to draw a single-height dash
23912               
23913                                                                          ; Otherwise fall through into CPIX4 to draw a double-
23914                                                                          ; height dash
23915               
23916               * ******************************************************************************
23917               *
23918               * Name: CPIX4
23919               * Type: Subroutine
23920               * Category: Drawing pixels
23921               * Summary: Draw a double-height dot on the dashboard
23922               *
23923               * ------------------------------------------------------------------------------
23924               *
23925               * Draw a double-height mode 5 dot (2 pixels high, 2 pixels wide).
23926               *
23927               * ------------------------------------------------------------------------------
23928               *
23929               * Arguments:
23930               *
23931               * X1                  The screen pixel x-coordinate of the bottom-left corner
23932               * of the dot
23933               *
23934               * Y1                  The screen pixel y-coordinate of the bottom-left corner
23935               * of the dot
23936               *
23937               * COL                 The colour of the dot as a mode 5 character row byte
23938               *
23939               * ******************************************************************************
23940               
23941               CPIX4:
23942 AE1E 0200  20        li   rtmp,CPIX2                 ; JSR CPIX2         ; Call CPIX2 to draw a single-height dash at (X1, Y1)
     AE20 AE28     
23943 AE22 06A0  32        bl   @jsr                       ;
     AE24 FE28     
23944               
23945 AE26 7347  18        sb   rone,ra                    ; DEC Y1            ; Decrement Y1
23946               
23947                                                                          ; Fall through into CPIX2 to draw a second single-height
23948                                                                          ; dash on the pixel row above the first one, to create a
23949                                                                          ; double-height dot
23950               
23951               * ******************************************************************************
23952               *
23953               * Name: CPIX2
23954               * Type: Subroutine
23955               * Category: Drawing pixels
23956               * Summary: Draw a single-height dash on the dashboard
23957               * Deep dive: Drawing colour pixels in mode 5
23958               *
23959               * ------------------------------------------------------------------------------
23960               *
23961               * Draw a single-height mode 5 dash (1 pixel high, 2 pixels wide).
23962               *
23963               * ------------------------------------------------------------------------------
23964               *
23965               * Arguments:
23966               *
23967               * X1                  The screen pixel x-coordinate of the dash
23968               *
23969               * Y1                  The screen pixel y-coordinate of the dash
23970               *
23971               * COL                 The colour of the dash as a mode 5 character row byte
23972               *
23973               * ******************************************************************************
23974               
23975               CPIX2:
23976 AE28 D360  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate into A
     AE2A 0032     
23977               
23978               * .CPIX                  \ This label is commented out in the original source. It
23979                                                                          ; would provide a new entry point with A specifying the
23980                                                                          ; y-coordinate instead of Y1, but it isn't used anywhere
23981               
23982 AE2C D3CD  18        movb ra,ry                      ; TAY               ; Store the y-coordinate in Y
23983               
23984 AE2E 091D  18        srl  ra,1                       ; LSR A             ; Set A = A / 8, so A now contains the character row we
23985 AE30 091D  18        srl  ra,1                       ; LSR A             ; need to draw in (as each character row contains 8
23986 AE32 091D  18        srl  ra,1                       ; LSR A             ; pixel rows)
23987               
23988 AE34 026D  22        ori  ra,>60*256                 ; ORA #&60          ; Each character row in Elite's screen mode takes up one
     AE36 6000     
23989                                                                          ; page in memory (256 bytes), so we now OR with &60 to
23990                                                                          ; get the page containing the dash (see the comments in
23991                                                                          ; routine TT26 for more discussion about calculating
23992                                                                          ; screen memory addresses)
23993               
23994 AE38 D80D  30        movb ra,@SCH                    ; STA SCH           ; Store the screen page in the high byte of SC(1 0)
     AE3A 0008     
23995               
23996 AE3C D360  30        movb @X1,ra                     ; LDA X1            ; Each character block contains 8 pixel rows, so to get
     AE3E 0031     
23997 AE40 024D  22        andi ra,>f8*256                 ; AND #%11111000    ; the address of the first byte in the character block
     AE42 F800     
23998                                                                          ; that we need to draw into, as an offset from the start
23999                                                                          ; of the row, we clear bits 0-2
24000               
24001 AE44 D80D  30        movb ra,@SC                     ; STA SC            ; Store the address of the character block in the low
     AE46 0007     
24002                                                                          ; byte of SC(1 0), so now SC(1 0) points to the
24003                                                                          ; character block we need to draw into
24004               
24005 AE48 D34F  18        movb ry,ra                      ; TYA               ; Set Y to just bits 0-2 of the y-coordinate, which will
24006 AE4A 024D  22        andi ra,>07*256                 ; AND #%00000111    ; be the number of the pixel row we need to draw into
     AE4C 0700     
24007 AE4E D3CD  18        movb ra,ry                      ; TAY               ; within the character block
24008               
24009 AE50 D360  30        movb @X1,ra                     ; LDA X1            ; Copy bits 0-1 of X1 to bits 1-2 of X, and clear the C
     AE52 0031     
24010 AE54 024D  22        andi ra,>06*256                 ; AND #%00000110    ; flag in the process (using the LSR). X will now be
     AE56 0600     
24011 AE58 091D  18        srl  ra,1                       ; LSR A             ; a value between 0 and 3, and will be the pixel number
24012 AE5A D38D  18        movb ra,rx                      ; TAX               ; in the character row for the left pixel in the dash.
24013                                                                          ; This is because each character row is one byte that
24014                                                                          ; contains 4 pixels, but covers 8 screen coordinates, so
24015                                                                          ; this effectively does the division by 2 that we need
24016               
24017 AE5C D36E  34        movb @CTWOS(rx),ra              ; LDA CTWOS,X       ; Fetch a mode 5 1-pixel byte with the pixel position
     AE5E 226D     
24018                      .and @COL                       ; AND COL           ; at X, and AND with the colour byte so that pixel takes
     **** ****     > AND
0001 AE60 D020  30        movb @COL,rtmp
     AE62 00A2     
0002 AE64 0540  14        inv  rtmp
0003 AE66 5340  18        szcb rtmp,ra
                   < elite.a99
24019                                                                          ; on the colour we want to draw (i.e. A is acting as a
24020                                                                          ; mask on the colour byte)
24021               
24022                      .eor @SC                        ; EOR (SC),Y        ; Draw the pixel on-screen using EOR logic, so we can
     **** ****     > EOR
0001 AE68 D020  30        movb @SC,rtmp
     AE6A 0007     
0002 AE6C 2B40  18        xor  rtmp,ra
                   < elite.a99
24023                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; remove it later without ruining the background that's
     **** ****     > ST_IND_Y_IDX
0001 AE6E D820  42        movb @SC,@rtmplb
     AE70 0007     
     AE72 8301     
0002 AE74 D020  30        movb @SC+1,rtmp
     AE76 0008     
0003 AE78 06CF  14        swpb ry
0004 AE7A A00F  18        a    ry,rtmp
0005 AE7C 06CF  14        swpb ry
0006 AE7E D40D  30        movb RA,*rtmp
                   < elite.a99
24024                                                                          ; already on-screen
24025               
24026 AE80 D36E  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Fetch a mode 5 1-pixel byte with the pixel position
     AE82 226E     
24027                                                                          ; at X+1, so we can draw the right pixel of the dash
24028               
24029 AE84 150A  14        jgt  CP1                        ; BPL CP1           ; The CTWOS table has an extra row at the end of it that
24030                                                                          ; repeats the first value, %10001000, so if we have not
24031                                                                          ; fetched that value, then the right pixel of the dash
24032                                                                          ; is in the same character block as the left pixel, so
24033                                                                          ; jump to CP1 to draw it
24034               
24035 AE86 D360  30        movb @SC,ra                     ; LDA SC            ; Otherwise the left pixel we drew was at the last
     AE88 0007     
24036                      .adi (>08*256)                  ; ADC #8            ; position of four in this character block, so we add
     **** ****     > ADI
0001 AE8A 1701  14        jnc  !
0002 AE8C B347  18        ab   rone,ra
0003               !:
0004 AE8E 022D  22        ai   ra,(>08*256)
     AE90 0800     
                   < elite.a99
24037 AE92 D80D  30        movb ra,@SC                     ; STA SC            ; 8 to the screen address to move onto the next block
     AE94 0007     
24038                                                                          ; along (as there are 8 bytes in a character block).
24039                                                                          ; The C flag was cleared above, so this ADC is correct
24040               
24041 AE96 D36E  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Re-fetch the mode 5 1-pixel byte, as we just overwrote
     AE98 226E     
24042                                                                          ; A (the byte will still be the fifth byte from the
24043                                                                          ; table, which is correct as we want to draw the
24044                                                                          ; leftmost pixel in the next character along as the
24045                                                                          ; dash's right pixel)
24046               
24047               CP1:
24048                      .and @COL                       ; AND COL           ; Apply the colour mask to the pixel byte, as above
     **** ****     > AND
0001 AE9A D020  30        movb @COL,rtmp
     AE9C 00A2     
0002 AE9E 0540  14        inv  rtmp
0003 AEA0 5340  18        szcb rtmp,ra
                   < elite.a99
24049               
24050                      .eor @SC                        ; EOR (SC),Y        ; Draw the dash's right pixel according to the mask in
     **** ****     > EOR
0001 AEA2 D020  30        movb @SC,rtmp
     AEA4 0007     
0002 AEA6 2B40  18        xor  rtmp,ra
                   < elite.a99
24051                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; A, with the colour in COL, using EOR logic, just as
     **** ****     > ST_IND_Y_IDX
0001 AEA8 D820  42        movb @SC,@rtmplb
     AEAA 0007     
     AEAC 8301     
0002 AEAE D020  30        movb @SC+1,rtmp
     AEB0 0008     
0003 AEB2 06CF  14        swpb ry
0004 AEB4 A00F  18        a    ry,rtmp
0005 AEB6 06CF  14        swpb ry
0006 AEB8 D40D  30        movb RA,*rtmp
                   < elite.a99
24052                                                                          ; above
24053               
24054 AEBA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AEBC FE34     
24055               
24056               * ******************************************************************************
24057               *
24058               * Name: OOPS
24059               * Type: Subroutine
24060               * Category: Flight
24061               * Summary: Take some damage
24062               *
24063               * ------------------------------------------------------------------------------
24064               *
24065               * We just took some damage, so reduce the shields if we have any, or reduce the
24066               * energy levels and potentially take some damage to the cargo if we don't.
24067               *
24068               * ------------------------------------------------------------------------------
24069               *
24070               * Arguments:
24071               *
24072               * A                   The amount of damage to take
24073               *
24074               * INF                 The address of the ship block for the ship that attacked
24075               * us, or the ship that we just ran into
24076               *
24077               * ******************************************************************************
24078               
24079               OOPS:
24080 AEBE D80D  30        movb ra,@T                      ; STA T             ; Store the amount of damage in T
     AEC0 00D1     
24081               
24082 AEC2 020F  20        li   ry,>08*256                 ; LDY #8            ; Fetch byte #8 (z_sign) for the ship attacking us, and
     AEC4 0800     
24083 AEC6 020E  20        li   rx,>00*256                 ; LDX #0            ; set X = 0
     AEC8 0000     
24084                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y
     **** ****     > LD_IND_Y_IDX
0001 AECA D820  42        movb @INF,@rtmplb
     AECC 0020     
     AECE 8301     
0002 AED0 D020  30        movb @INF+1,rtmp
     AED2 0021     
0003 AED4 06CF  14        swpb ry
0004 AED6 A00F  18        a    ry,rtmp
0005 AED8 06CF  14        swpb ry
0006 AEDA D350  26        movb *rtmp,RA
                   < elite.a99
24085               
24086 AEDC 110E  14        jlt  OO1                        ; BMI OO1           ; If A is negative, then we got hit in the rear, so jump
24087                                                                          ; to OO1 to process damage to the aft shield
24088               
24089 AEDE D360  30        movb @FSH,ra                    ; LDA FSH           ; Otherwise the forward shield was damaged, so fetch the
     AEE0 0F11     
24090                      .sbc @T,ra                      ; SBC T             ; shield strength from FSH and subtract the damage in T
     **** ****     > SBC
0001 AEE2 1801  14        joc  !
0002 AEE4 7347  18        sb   rone,ra
0003               !:
0004 AEE6 7360  30        sb   @T,ra
     AEE8 00D1     
                   < elite.a99
24091               
24092 AEEA 1704  14        jnc  OO2                        ; BCC OO2           ; If the C flag is clear then this amount of damage was
24093                                                                          ; too much for the shields, so jump to OO2 to set the
24094                                                                          ; shield level to 0 and start taking damage directly
24095                                                                          ; from the energy banks
24096               
24097 AEEC D80D  30        movb ra,@FSH                    ; STA FSH           ; Store the new value of the forward shield in FSH
     AEEE 0F11     
24098               
24099 AEF0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AEF2 FE34     
24100               
24101               OO2:
24102               * LDX #0                 \ This instruction is commented out in the original
24103                                                                          ; source, and isn't required as X is set to 0 above
24104 AEF4 D80E  30        movb rx,@FSH                    ; STX FSH           ; Set the forward shield to 0
     AEF6 0F11     
24105               
24106 AEF8 170D  14        jnc  OO3                        ; BCC OO3           ; Jump to OO3 to start taking damage directly from the
24107                                                                          ; energy banks (this BCC is effectively a JMP as the C
24108                                                                          ; flag is clear, as we jumped to OO2 with a BCC)
24109               
24110               OO1:
24111 AEFA D360  30        movb @ASH,ra                    ; LDA ASH           ; The aft shield was damaged, so fetch the shield
     AEFC 0F12     
24112                      .sbc @T,ra                      ; SBC T             ; strength from ASH and subtract the damage in T
     **** ****     > SBC
0001 AEFE 1801  14        joc  !
0002 AF00 7347  18        sb   rone,ra
0003               !:
0004 AF02 7360  30        sb   @T,ra
     AF04 00D1     
                   < elite.a99
24113               
24114 AF06 1704  14        jnc  OO5                        ; BCC OO5           ; If the C flag is clear then this amount of damage was
24115                                                                          ; too much for the shields, so jump to OO5 to set the
24116                                                                          ; shield level to 0 and start taking damage directly
24117                                                                          ; from the energy banks
24118               
24119 AF08 D80D  30        movb ra,@ASH                    ; STA ASH           ; Store the new value of the aft shield in ASH
     AF0A 0F12     
24120               
24121 AF0C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AF0E FE34     
24122               
24123               OO5:
24124               * LDX #0                 \ This instruction is commented out in the original
24125                                                                          ; source, and isn't required as X is set to 0 above
24126 AF10 D80E  30        movb rx,@ASH                    ; STX ASH           ; Set the aft shield to 0
     AF12 0F12     
24127               
24128               OO3:
24129                      .adc @ENERGY,ra                 ; ADC ENERGY        ; A is negative and contains the amount by which the
     **** ****     > ADC
0001 AF14 1701  14        jnc  !
0002 AF16 B347  18        ab   rone,ra
0003               !:
0004 AF18 B360  30        ab   @ENERGY,ra
     AF1A 0F13     
                   < elite.a99
24130 AF1C D80D  30        movb ra,@ENERGY                 ; STA ENERGY        ; damage overwhelmed the shields, so this drains the
     AF1E 0F13     
24131                                                                          ; energy banks by that amount (and because the energy
24132                                                                          ; banks are shown over four indicators rather than one,
24133                                                                          ; but with the same value range of 0-255, energy will
24134                                                                          ; appear to drain away four times faster than the
24135                                                                          ; shields did)
24136               
24137 AF20 1301  14        jeq  B72                        ; BEQ B72           ; If we have just run out of energy, skip the next
24138                                                                          ; instruction to jump straight to our death
24139               
24140 AF22 1802  14        joc  B73                        ; BCS B73           ; If the C flag is set, then subtracting the damage from
24141                                                                          ; the energy banks didn't underflow, so we had enough
24142                                                                          ; energy to survive, and we can skip the next
24143                                                                          ; instruction to make a sound and take some damage
24144               
24145               B72:
24146 AF24 0460  28        b    @DEATH                     ; JMP DEATH         ; Otherwise our energy levels are either 0 or negative,
     AF26 C522     
24147                                                                          ; and in either case that means we jump to our DEATH,
24148                                                                          ; returning from the subroutine using a tail call
24149               
24150               B73:
24151 AF28 0200  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; We didn't die, so call EXNO3 to make the sound of a
     AF2A CBDA     
24152 AF2C 06A0  32        bl   @jsr                       ;
     AF2E FE28     
24153                                                                          ; collision
24154               
24155 AF30 0460  28        b    @OUCH                      ; JMP OUCH          ; And jump to OUCH to take damage and return from the
     AF32 CF50     
24156                                                                          ; subroutine using a tail call
24157               
24158               * ******************************************************************************
24159               *
24160               * Name: SPS3
24161               * Type: Subroutine
24162               * Category: Maths (Geometry)
24163               * Summary: Copy a space coordinate from the K% block into K3
24164               *
24165               * ------------------------------------------------------------------------------
24166               *
24167               * Copy one of the planet's coordinates into the corresponding location in the
24168               * temporary variable K3. The high byte and absolute value of the sign byte are
24169               * copied into the first two K3 bytes, and the sign of the sign byte is copied
24170               * into the highest K3 byte.
24171               *
24172               * The comments below are written for copying the planet's x-coordinate into
24173               * K3(2 1 0).
24174               *
24175               * ------------------------------------------------------------------------------
24176               *
24177               * Arguments:
24178               *
24179               * X                   Determines which coordinate to copy, and to where:
24180               *
24181               * * X = 0 copies (x_sign, x_hi) into K3(2 1 0)
24182               *
24183               * * X = 3 copies (y_sign, y_hi) into K3(5 4 3)
24184               *
24185               * * X = 6 copies (z_sign, z_hi) into K3(8 7 6)
24186               *
24187               * ******************************************************************************
24188               
24189               SPS3:
24190 AF34 D36E  34        movb @K.+1(rx),ra               ; LDA K%+1,X        ; Copy x_hi into K3+X
     AF36 0901     
24191 AF38 DB8D  38        movb ra,@K3(rx)                 ; STA K3,X
     AF3A 00D2     
24192               
24193 AF3C D36E  34        movb @K.+2(rx),ra               ; LDA K%+2,X        ; Set A = Y = x_sign
     AF3E 0902     
24194 AF40 D3CD  18        movb ra,ry                      ; TAY
24195               
24196 AF42 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Set K3+1 = |x_sign|
     AF44 7F00     
24197 AF46 DB8D  38        movb ra,@K3+1(rx)               ; STA K3+1,X
     AF48 00D3     
24198               
24199 AF4A D34F  18        movb ry,ra                      ; TYA               ; Set K3+2 = the sign of x_sign
24200 AF4C 024D  22        andi ra,>80*256                 ; AND #%10000000
     AF4E 8000     
24201 AF50 DB8D  38        movb ra,@K3+2(rx)               ; STA K3+2,X
     AF52 00D4     
24202               
24203 AF54 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AF56 FE34     
24204               
24205               * ******************************************************************************
24206               *
24207               * Name: GINF
24208               * Type: Subroutine
24209               * Category: Universe
24210               * Summary: Fetch the address of a ship's data block into INF
24211               *
24212               * ------------------------------------------------------------------------------
24213               *
24214               * Get the address of the data block for ship slot X and store it in INF. This
24215               * address is fetched from the UNIV table, which stores the addresses of the 13
24216               * ship data blocks in workspace K%.
24217               *
24218               * ------------------------------------------------------------------------------
24219               *
24220               * Arguments:
24221               *
24222               * X                   The ship slot number for which we want the data block
24223               * address
24224               *
24225               * ******************************************************************************
24226               
24227               GINF:
24228 AF58 D34E  18        movb rx,ra                      ; TXA               ; Set Y = X * 2
24229                      .asla                           ; ASL A
     **** ****     > ASLA
0001 AF5A 024D  22        andi ra,>ff00
     AF5C FF00     
0002 AF5E 0A1D  18        sla  ra,1
                   < elite.a99
24230 AF60 D3CD  18        movb ra,ry                      ; TAY
24231               
24232 AF62 D36F  34        movb @UNIV(ry),ra               ; LDA UNIV,Y        ; Get the high byte of the address of the X-th ship
     AF64 2243     
24233 AF66 D80D  30        movb ra,@INF                    ; STA INF           ; from UNIV and store it in INF
     AF68 0020     
24234               
24235 AF6A D36F  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y      ; Get the low byte of the address of the X-th ship
     AF6C 2244     
24236 AF6E D80D  30        movb ra,@INF+1                  ; STA INF+1         ; from UNIV and store it in INF
     AF70 0021     
24237               
24238 AF72 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AF74 FE34     
24239               
24240               * ******************************************************************************
24241               *
24242               * Name: NWSPS
24243               * Type: Subroutine
24244               * Category: Universe
24245               * Summary: Add a new space station to our local bubble of universe
24246               *
24247               * ******************************************************************************
24248               
24249               NWSPS:
24250 AF76 0200  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Light up the space station bulb on the dashboard
     AF78 B13E     
24251 AF7A 06A0  32        bl   @jsr                       ;
     AF7C FE28     
24252               
24253 AF7E 020E  20        li   rx,>01*256                 ; LDX #%00000001    ; Set the AI flag in byte #32 to %00000001 (friendly, no
     AF80 0100     
24254 AF82 D80E  30        movb rx,@INWK+32                ; STX INWK+32       ; AI, has an E.C.M.)
     AF84 0073     
24255               
24256 AF86 7387  18        sb   rone,rx                    ; DEX               ; Set pitch counter to 0 (no pitch, roll only)
24257 AF88 D80E  30        movb rx,@INWK+30                ; STX INWK+30
     AF8A 0071     
24258               
24259               * STX INWK+31            \ This instruction is commented out in the original
24260                                                                          ; source. It would set the exploding state and missile
24261                                                                          ; count to 0
24262               
24263 AF8C D80E  30        movb rx,@FRIN+1                 ; STX FRIN+1        ; Set the second slot in the FRIN table to 0, so when we
     AF8E 0D41     
24264                                                                          ; fall through into NWSHP below, the new station that
24265                                                                          ; gets created will go into slot FRIN+1, as this will be
24266                                                                          ; the first empty slot that the routine finds
24267               
24268 AF90 7387  18        sb   rone,rx                    ; DEX               ; Set the roll counter to 255 (maximum anti-clockwise
24269 AF92 D80E  30        movb rx,@INWK+29                ; STX INWK+29       ; roll with no damping)
     AF94 0070     
24270               
24271 AF96 020E  20        li   rx,>0a*256                 ; LDX #10           ; Call NwS1 to flip the sign of nosev_x_hi (byte #10)
     AF98 0A00     
24272 AF9A 0200  20        li   rtmp,NwS1                  ; JSR NwS1
     AF9C B0E8     
24273 AF9E 06A0  32        bl   @jsr                       ;
     AFA0 FE28     
24274               
24275 AFA2 0200  20        li   rtmp,NwS1                  ; JSR NwS1          ; And again to flip the sign of nosev_y_hi (byte #12)
     AFA4 B0E8     
24276 AFA6 06A0  32        bl   @jsr                       ;
     AFA8 FE28     
24277               
24278 AFAA 0200  20        li   rtmp,NwS1                  ; JSR NwS1          ; And again to flip the sign of nosev_z_hi (byte #14)
     AFAC B0E8     
24279 AFAE 06A0  32        bl   @jsr                       ;
     AFB0 FE28     
24280               
24281 AFB2 020D  20        li   ra,((LSO)%256)*256         ; LDA #LO(LSO)      ; Set bytes #33 and #34 to point to LSO for the ship
     AFB4 6600     
24282 AFB6 D80D  30        movb ra,@INWK+33                ; STA INWK+33       ; line heap for the space station
     AFB8 0074     
24283 AFBA 020D  20        li   ra,((LSO)/256)*256         ; LDA #HI(LSO)
     AFBC 0D00     
24284 AFBE D80D  30        movb ra,@INWK+34                ; STA INWK+34
     AFC0 0075     
24285               
24286 AFC2 020D  20        li   ra,(SST)*256               ; LDA #SST          ; Set A to the space station type, and fall through
     AFC4 0800     
24287                                                                          ; into NWSHP to finish adding the space station to the
24288                                                                          ; universe
24289               
24290               * ******************************************************************************
24291               *
24292               * Name: NWSHP
24293               * Type: Subroutine
24294               * Category: Universe
24295               * Summary: Add a new ship to our local bubble of universe
24296               *
24297               * ------------------------------------------------------------------------------
24298               *
24299               * This creates a new block of ship data in the K% workspace, allocates a new
24300               * block in the ship line heap at WP, adds the new ship's type into the first
24301               * empty slot in FRIN, and adds a pointer to the ship data into UNIV. If there
24302               * isn't enough free memory for the new ship, it isn't added.
24303               *
24304               * ------------------------------------------------------------------------------
24305               *
24306               * Arguments:
24307               *
24308               * A                   The type of the ship to add (see variable XX21 for a
24309               * list of ship types)
24310               *
24311               * ------------------------------------------------------------------------------
24312               *
24313               * Returns:
24314               *
24315               * C flag              Set if the ship was successfully added, clear if it
24316               * wasn't (as there wasn't enough free memory)
24317               *
24318               * INF                 Points to the new ship's data block in K%
24319               *
24320               * ******************************************************************************
24321               
24322               NWSHP:
24323 AFC6 D80D  30        movb ra,@T                      ; STA T             ; Store the ship type in location T
     AFC8 00D1     
24324               
24325 AFCA 020E  20        li   rx,>00*256                 ; LDX #0            ; Before we can add a new ship, we need to check
     AFCC 0000     
24326                                                                          ; whether we have an empty slot we can put it in. To do
24327                                                                          ; this, we need to loop through all the slots to look
24328                                                                          ; for an empty one, so set a counter in X that starts
24329                                                                          ; from the first slot at 0. When ships are killed, then
24330                                                                          ; the slots are shuffled down by the KILLSHP routine, so
24331                                                                          ; the first empty slot will always come after the last
24332                                                                          ; filled slot. This allows us to tack the new ship's
24333                                                                          ; data block and ship line heap onto the end of the
24334                                                                          ; existing ship data and heap, as shown in the memory
24335                                                                          ; map below
24336               
24337               NWL1:
24338 AFCE D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Load the ship type for the X-th slot
     AFD0 0D40     
24339               
24340 AFD2 1307  14        jeq  NW1                        ; BEQ NW1           ; If it is zero, then this slot is empty and we can use
24341                                                                          ; it for our new ship, so jump down to NW1
24342               
24343 AFD4 B387  18        ab   rone,rx                    ; INX               ; Otherwise increment X to point to the next slot
24344               
24345 AFD6 028E  22        ci   rx,(NOSH)*256              ; CPX #NOSH         ; If we haven't reached the last slot yet, loop back up
     AFD8 0C00     
24346 AFDA 17F9  14        jnc  NWL1                       ; BCC NWL1          ; to NWL1 to check the next slot (note that this means
24347                                                                          ; only slots from 0 to #NOSH - 1 are populated by this
24348                                                                          ; routine, but there is one more slot reserved in FRIN,
24349                                                                          ; which is used to identify the end of the slot list
24350                                                                          ; when shuffling the slots down in the KILLSHP routine)
24351               
24352               NW3:
24353                      .clc                            ; CLC               ; Otherwise we don't have an empty slot, so we can't
     **** ****     > CLC
0001 AFDC 0A16  18        sla  rzero,1
                   < elite.a99
24354 AFDE 0460  28        b    @rts                       ; RTS               ; add a new ship, so clear the C flag to indicate that
     AFE0 FE34     
24355                                                                          ; we have not managed to create the new ship, and return
24356                                                                          ; from the subroutine
24357               
24358               NW1:
24359                                                                          ; If we get here, then we have found an empty slot at
24360                                                                          ; index X, so we can go ahead and create our new ship.
24361                                                                          ; We do that by creating a ship data block at INWK and,
24362                                                                          ; when we are done, copying the block from INWK into
24363                                                                          ; the K% workspace (specifically, to INF)
24364 AFE2 0200  20        li   rtmp,GINF                  ; JSR GINF          ; Get the address of the data block for ship slot X
     AFE4 AF58     
24365 AFE6 06A0  32        bl   @jsr                       ;
     AFE8 FE28     
24366                                                                          ; (which is in workspace K%) and store it in INF
24367               
24368 AFEA D360  30        movb @T,ra                      ; LDA T             ; If the type of ship that we want to create is
     AFEC 00D1     
24369 AFEE 1165  14        jlt  NW2                        ; BMI NW2           ; negative, then this indicates a planet or sun, so
24370                                                                          ; jump down to NW2, as the next section sets up a ship
24371                                                                          ; data block, which doesn't apply to planets and suns,
24372                                                                          ; as they don't have things like shields, missiles,
24373                                                                          ; vertices and edges
24374               
24375                                                                          ; This is a ship, so first we need to set up various
24376                                                                          ; pointers to the ship blueprint we will need. The
24377                                                                          ; blueprints for each ship type in Elite are stored
24378                                                                          ; in a table at location XX21, so refer to the comments
24379                                                                          ; on that variable for more details on the data we're
24380                                                                          ; about to access
24381               
24382                      .asla                           ; ASL A             ; Set Y = ship type * 2
     **** ****     > ASLA
0001 AFF0 024D  22        andi ra,>ff00
     AFF2 FF00     
0002 AFF4 0A1D  18        sla  ra,1
                   < elite.a99
24383 AFF6 D3CD  18        movb ra,ry                      ; TAY
24384               
24385 AFF8 D36F  34        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; The ship blueprints at XX21 start with a lookup
     AFFA E95C     
24386 AFFC D80D  30        movb ra,@XX0                    ; STA XX0           ; table that points to the individual ship blueprints,
     AFFE 001E     
24387                                                                          ; so this fetches the low byte of this particular ship
24388                                                                          ; type's blueprint and stores it in XX0
24389               
24390 B000 D36F  34        movb @XX21-1(ry),ra             ; LDA XX21-1,Y      ; Fetch the high byte of this particular ship type's
     B002 E95D     
24391 B004 D80D  30        movb ra,@XX0+1                  ; STA XX0+1         ; blueprint and store it in XX0+1, so XX0(1 0) now
     B006 001F     
24392                                                                          ; contains the address of this ship's blueprint
24393               
24394 B008 028F  22        ci   ry,(2*SST)*256             ; CPY #2*SST        ; If the ship type is a space station (SST), then jump
     B00A 1000     
24395 B00C 1338  14        jeq  NW6                        ; BEQ NW6           ; to NW6, skipping the heap space steps below, as the
24396                                                                          ; space station has its own line heap at LSO (which it
24397                                                                          ; shares with the sun)
24398               
24399                                                                          ; We now want to allocate space for a heap that we can
24400                                                                          ; use to store the lines we draw for our new ship (so it
24401                                                                          ; can easily be erased from the screen again). SLSP
24402                                                                          ; points to the start of the current heap space, and we
24403                                                                          ; can extend it downwards with the heap for our new ship
24404                                                                          ; (as the heap space always ends just before the WP
24405                                                                          ; workspace)
24406               
24407 B00E 020F  20        li   ry,>05*256                 ; LDY #5            ; Fetch ship blueprint byte #5, which contains the
     B010 0500     
24408                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; maximum heap size required for plotting the new ship,
     **** ****     > LD_IND_Y_IDX
0001 B012 D820  42        movb @XX0,@rtmplb
     B014 001E     
     B016 8301     
0002 B018 D020  30        movb @XX0+1,rtmp
     B01A 001F     
0003 B01C 06CF  14        swpb ry
0004 B01E A00F  18        a    ry,rtmp
0005 B020 06CF  14        swpb ry
0006 B022 D350  26        movb *rtmp,RA
                   < elite.a99
24409 B024 D80D  30        movb ra,@T1                     ; STA T1            ; and store it in T1
     B026 0006     
24410               
24411 B028 D360  30        movb @SLSP,ra                   ; LDA SLSP          ; Take the 16-bit address in SLSP and subtract T1,
     B02A 0F1E     
24412                      .sec                            ; SEC               ; storing the 16-bit result in INWK(34 33), so this now
     **** ****     > SEC
0001 B02C 0A18  18        sla  rmone,1
                   < elite.a99
24413                      .sbc @T1,ra                     ; SBC T1            ; points to the start of the line heap for our new ship
     **** ****     > SBC
0001 B02E 1801  14        joc  !
0002 B030 7347  18        sb   rone,ra
0003               !:
0004 B032 7360  30        sb   @T1,ra
     B034 0006     
                   < elite.a99
24414 B036 D80D  30        movb ra,@INWK+33                ; STA INWK+33
     B038 0074     
24415 B03A D360  30        movb @SLSP+1,ra                 ; LDA SLSP+1
     B03C 0F1F     
24416                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 B03E 1801  14        joc  !
0002 B040 7347  18        sb   rone,ra
0003               !:
0004 B042 022D  22        ai   ra,-(>00*256)
     B044 0000     
                   < elite.a99
24417 B046 D80D  30        movb ra,@INWK+34                ; STA INWK+34
     B048 0075     
24418               
24419                                                                          ; We now need to check that there is enough free space
24420                                                                          ; for both this new line heap and the new data block
24421                                                                          ; for our ship. In memory, this is the layout of the
24422                                                                          ; ship data blocks and ship line heaps:
24423                                                                          ;
24424                                                                          ; +-----------------------------------+   &0F34
24425                                                                          ; |                                   |
24426                                                                          ; | WP workspace                      |
24427                                                                          ; |                                   |
24428                                                                          ; +-----------------------------------+   &0D40 = WP
24429                                                                          ; |                                   |
24430                                                                          ; | Current ship line heap            |
24431                                                                          ; |                                   |
24432                                                                          ; +-----------------------------------+   SLSP
24433                                                                          ; |                                   |
24434                                                                          ; | Proposed heap for new ship        |
24435                                                                          ; |                                   |
24436                                                                          ; +-----------------------------------+   INWK(34 33)
24437                                                                          ; |                                   |
24438                                                                          ; .                                   .
24439                                                                          ; .                                   .
24440                                                                          ; .                                   .
24441                                                                          ; .                                   .
24442                                                                          ; .                                   .
24443                                                                          ; |                                   |
24444                                                                          ; +-----------------------------------+   INF + NI%
24445                                                                          ; |                                   |
24446                                                                          ; | Proposed data block for new ship  |
24447                                                                          ; |                                   |
24448                                                                          ; +-----------------------------------+   INF
24449                                                                          ; |                                   |
24450                                                                          ; | Existing ship data blocks         |
24451                                                                          ; |                                   |
24452                                                                          ; +-----------------------------------+   &0900 = K%
24453                                                                          ;
24454                                                                          ; So, to work out if we have enough space, we have to
24455                                                                          ; make sure there is room between the end of our new
24456                                                                          ; ship data block at INF + NI%, and the start of the
24457                                                                          ; proposed heap for our new ship at the address we
24458                                                                          ; stored in INWK(34 33). Or, to put it another way, we
24459                                                                          ; and to make sure that:
24460                                                                          ;
24461                                                                          ; INWK(34 33) > INF + NI%
24462                                                                          ;
24463                                                                          ; which is the same as saying:
24464                                                                          ;
24465                                                                          ; INWK+33 - INF > NI%
24466                                                                          ;
24467                                                                          ; because INWK is in zero page, so INWK+34 = 0
24468               
24469 B04A D360  30        movb @INWK+33,ra                ; LDA INWK+33       ; Calculate INWK+33 - INF, again using 16-bit
     B04C 0074     
24470               * SEC                    \ arithmetic, and put the result in (A Y), so the high
24471                      .sbc @INF,ra                    ; SBC INF           ; byte is in A and the low byte in Y. The SEC
     **** ****     > SBC
0001 B04E 1801  14        joc  !
0002 B050 7347  18        sb   rone,ra
0003               !:
0004 B052 7360  30        sb   @INF,ra
     B054 0020     
                   < elite.a99
24472 B056 D3CD  18        movb ra,ry                      ; TAY               ; instruction is commented out in the original source;
24473 B058 D360  30        movb @INWK+34,ra                ; LDA INWK+34       ; as the previous subtraction will never underflow, it
     B05A 0075     
24474                      .sbc @INF+1,ra                  ; SBC INF+1         ; is superfluous
     **** ****     > SBC
0001 B05C 1801  14        joc  !
0002 B05E 7347  18        sb   rone,ra
0003               !:
0004 B060 7360  30        sb   @INF+1,ra
     B062 0021     
                   < elite.a99
24475               
24476 B064 17BB  14        jnc  NW3+1                      ; BCC NW3+1         ; If we have an underflow from the subtraction, then
24477                                                                          ; INF > INWK+33 and we definitely don't have enough
24478                                                                          ; room for this ship, so jump to NW3+1, which returns
24479                                                                          ; from the subroutine (with the C flag already cleared)
24480               
24481 B066 1603  14        jne  NW4                        ; BNE NW4           ; If the subtraction of the high bytes in A is not
24482                                                                          ; zero, and we don't have underflow, then we definitely
24483                                                                          ; have enough space, so jump to NW4 to continue setting
24484                                                                          ; up the new ship
24485               
24486 B068 028F  22        ci   ry,(NI.)*256               ; CPY #NI%          ; Otherwise the high bytes are the same in our
     B06A 2400     
24487 B06C 17B7  14        jnc  NW3+1                      ; BCC NW3+1         ; subtraction, so now we compare the low byte of the
24488                                                                          ; result (which is in Y) with NI%. This is the same as
24489                                                                          ; doing INWK+33 - INF > NI% (see above). If this isn't
24490                                                                          ; true, the C flag will be clear and we don't have
24491                                                                          ; enough space, so we jump to NW3+1, which returns
24492                                                                          ; from the subroutine (with the C flag already cleared)
24493               
24494               NW4:
24495 B06E D360  30        movb @INWK+33,ra                ; LDA INWK+33       ; If we get here then we do have enough space for our
     B070 0074     
24496 B072 D80D  30        movb ra,@SLSP                   ; STA SLSP          ; new ship, so store the new bottom of the ship line
     B074 0F1E     
24497 B076 D360  30        movb @INWK+34,ra                ; LDA INWK+34       ; heap (i.e. INWK+33) in SLSP, doing both the high and
     B078 0075     
24498 B07A D80D  30        movb ra,@SLSP+1                 ; STA SLSP+1        ; low bytes
     B07C 0F1F     
24499               
24500               NW6:
24501 B07E 020F  20        li   ry,>0e*256                 ; LDY #14           ; Fetch ship blueprint byte #14, which contains the
     B080 0E00     
24502                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; ship's energy, and store it in byte #35
     **** ****     > LD_IND_Y_IDX
0001 B082 D820  42        movb @XX0,@rtmplb
     B084 001E     
     B086 8301     
0002 B088 D020  30        movb @XX0+1,rtmp
     B08A 001F     
0003 B08C 06CF  14        swpb ry
0004 B08E A00F  18        a    ry,rtmp
0005 B090 06CF  14        swpb ry
0006 B092 D350  26        movb *rtmp,RA
                   < elite.a99
24503 B094 D80D  30        movb ra,@INWK+35                ; STA INWK+35
     B096 0076     
24504               
24505 B098 020F  20        li   ry,>13*256                 ; LDY #19           ; Fetch ship blueprint byte #19, which contains the
     B09A 1300     
24506                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of missiles and laser power, and AND with %111
     **** ****     > LD_IND_Y_IDX
0001 B09C D820  42        movb @XX0,@rtmplb
     B09E 001E     
     B0A0 8301     
0002 B0A2 D020  30        movb @XX0+1,rtmp
     B0A4 001F     
0003 B0A6 06CF  14        swpb ry
0004 B0A8 A00F  18        a    ry,rtmp
0005 B0AA 06CF  14        swpb ry
0006 B0AC D350  26        movb *rtmp,RA
                   < elite.a99
24507 B0AE 024D  22        andi ra,>07*256                 ; AND #%00000111    ; to extract the number of missiles before storing in
     B0B0 0700     
24508 B0B2 D80D  30        movb ra,@INWK+31                ; STA INWK+31       ; byte #31
     B0B4 0072     
24509               
24510 B0B6 D360  30        movb @T,ra                      ; LDA T             ; Restore the ship type we stored above
     B0B8 00D1     
24511               
24512               NW2:
24513 B0BA DB8D  38        movb ra,@FRIN(rx)               ; STA FRIN,X        ; Store the ship type in the X-th byte of FRIN, so the
     B0BC 0D40     
24514                                                                          ; this slot is now shown as occupied in the index table
24515               
24516 B0BE D38D  18        movb ra,rx                      ; TAX               ; Copy the ship type into X
24517               
24518 B0C0 1101  14        jlt  B74                        ; BMI B74           ; If the ship type is negative (planet or sun), then
24519                                                                          ; skip the following instruction
24520               
24521 B0C2 B347  18        ab   rone,ra                    ; INC MANY,X        ; Increment the total number of ships of type X
24522               
24523               B74:
24524 B0C4 020F  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; The final step is to copy the new ship's data block
     B0C6 2300     
24525                                                                          ; from INWK to INF, so set up a counter for NI% bytes
24526                                                                          ; in Y
24527               
24528               NWL3:
24529 B0C8 D36F  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Load the Y-th byte of INWK and store in the Y-th byte
     B0CA 0053     
24530                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; of the workspace pointed to by INF
     **** ****     > ST_IND_Y_IDX
0001 B0CC D820  42        movb @INF,@rtmplb
     B0CE 0020     
     B0D0 8301     
0002 B0D2 D020  30        movb @INF+1,rtmp
     B0D4 0021     
0003 B0D6 06CF  14        swpb ry
0004 B0D8 A00F  18        a    ry,rtmp
0005 B0DA 06CF  14        swpb ry
0006 B0DC D40D  30        movb RA,*rtmp
                   < elite.a99
24531               
24532 B0DE 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
24533               
24534 B0E0 15F3  14        jgt  NWL3                       ; BPL NWL3          ; Loop back for the next byte until we have copied them
24535                                                                          ; all over
24536               
24537                      .sec                            ; SEC               ; We have successfully created our new ship, so set the
     **** ****     > SEC
0001 B0E2 0A18  18        sla  rmone,1
                   < elite.a99
24538                                                                          ; C flag to indicate success
24539               
24540 B0E4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B0E6 FE34     
24541               
24542               * ******************************************************************************
24543               *
24544               * Name: NwS1
24545               * Type: Subroutine
24546               * Category: Universe
24547               * Summary: Flip the sign and double an INWK byte
24548               *
24549               * ------------------------------------------------------------------------------
24550               *
24551               * Flip the sign of the INWK byte at offset X, and increment X by 2. This is
24552               * used by the space station creation routine at NWSPS.
24553               *
24554               * ------------------------------------------------------------------------------
24555               *
24556               * Arguments:
24557               *
24558               * X                   The offset of the INWK byte to be flipped
24559               *
24560               * ------------------------------------------------------------------------------
24561               *
24562               * Returns:
24563               *
24564               * X                   X is incremented by 2
24565               *
24566               * ******************************************************************************
24567               
24568               NwS1:
24569 B0E8 D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Load the X-th byte of INWK into A and flip bit 7,
     B0EA 0053     
24570                      .eoi (>80*256)                  ; EOR #%10000000    ; storing the result back in the X-th byte of INWK
     **** ****     > EOI
0001 B0EC 0200  20        li   rtmp,(>80*256)
     B0EE 8000     
0002 B0F0 2B40  18        xor  rtmp,ra
                   < elite.a99
24571 B0F2 DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X
     B0F4 0053     
24572               
24573 B0F6 B387  18        ab   rone,rx                    ; INX               ; Add 2 to X
24574 B0F8 B387  18        ab   rone,rx                    ; INX
24575               
24576 B0FA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B0FC FE34     
24577               
24578               * ******************************************************************************
24579               *
24580               * Name: ABORT
24581               * Type: Subroutine
24582               * Category: Dashboard
24583               * Summary: Disarm missiles and update the dashboard indicators
24584               *
24585               * ------------------------------------------------------------------------------
24586               *
24587               * Arguments:
24588               *
24589               * Y                   The new status of the leftmost missile indicator
24590               *
24591               * ******************************************************************************
24592               
24593               ABORT:
24594 B0FE 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set X to &FF, which is the value of MSTG when we have
     B100 FF00     
24595                                                                          ; no target lock for our missile
24596               
24597                                                                          ; Fall through into ABORT2 to set the missile lock to
24598                                                                          ; the value in X, which effectively disarms the missile
24599               
24600               * ******************************************************************************
24601               *
24602               * Name: ABORT2
24603               * Type: Subroutine
24604               * Category: Dashboard
24605               * Summary: Set/unset the lock target for a missile and update the dashboard
24606               *
24607               * ------------------------------------------------------------------------------
24608               *
24609               * Set the lock target for the leftmost missile and update the dashboard.
24610               *
24611               * ------------------------------------------------------------------------------
24612               *
24613               * Arguments:
24614               *
24615               * X                   The slot number of the ship to lock our missile onto, or
24616               * &FF to remove missile lock
24617               *
24618               * Y                   The new colour of the missile indicator:
24619               *
24620               * * &00 = black (no missile)
24621               *
24622               * * &0E = red (armed and locked)
24623               *
24624               * * &E0 = yellow/white (armed)
24625               *
24626               * * &EE = green/cyan (disarmed)
24627               *
24628               * ******************************************************************************
24629               
24630               ABORT2:
24631 B102 D80E  30        movb rx,@MSTG                   ; STX MSTG          ; Store the target of our missile lock in MSTG
     B104 0052     
24632               
24633 B106 D3A0  30        movb @NOMSL,rx                  ; LDX NOMSL         ; Call MSBAR to update the leftmost indicator in the
     B108 0333     
24634 B10A 0200  20        li   rtmp,MSBAR                 ; JSR MSBAR         ; dashboard's missile bar, which returns with Y = 0
     B10C B16A     
24635 B10E 06A0  32        bl   @jsr                       ;
     B110 FE28     
24636               
24637 B112 D80F  30        movb ry,@MSAR                   ; STY MSAR          ; Set MSAR = 0 to indicate that the leftmost missile
     B114 0D5E     
24638                                                                          ; is no longer seeking a target lock
24639               
24640 B116 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B118 FE34     
24641               
24642               * ******************************************************************************
24643               *
24644               * Name: ECBLB2
24645               * Type: Subroutine
24646               * Category: Dashboard
24647               * Summary: Start up the E.C.M. (light up the indicator, start the countdown
24648               * and make the E.C.M. sound)
24649               *
24650               * ******************************************************************************
24651               
24652               ECBLB2:
24653 B11A 020D  20        li   ra,>20*256                 ; LDA #32           ; Set the E.C.M. countdown timer in ECMA to 32
     B11C 2000     
24654 B11E D80D  30        movb ra,@ECMA                   ; STA ECMA
     B120 0030     
24655               
24656                      .asla                           ; ASL A             ; Call the NOISE routine with A = 64 to make the sound
     **** ****     > ASLA
0001 B122 024D  22        andi ra,>ff00
     B124 FF00     
0002 B126 0A1D  18        sla  ra,1
                   < elite.a99
24657 B128 0200  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the E.C.M. being switched on
     B12A CC5C     
24658 B12C 06A0  32        bl   @jsr                       ;
     B12E FE28     
24659               
24660                                                                          ; Fall through into ECBLB to light up the E.C.M. bulb
24661               
24662               * ******************************************************************************
24663               *
24664               * Name: ECBLB
24665               * Type: Subroutine
24666               * Category: Dashboard
24667               * Summary: Light up the E.C.M. indicator bulb ("E") on the dashboard
24668               *
24669               * ******************************************************************************
24670               
24671               ECBLB:
24672 B130 020D  20        li   ra,(7*8)*256               ; LDA #7*8          ; The E.C.M. bulb is in character block number 7
     B132 3800     
24673                                                                          ; with each character taking 8 bytes, so this sets the
24674                                                                          ; low byte of the screen address of the character block
24675                                                                          ; we want to draw to
24676               
24677 B134 020E  20        li   rx,((ECBT)%256)*256        ; LDX #LO(ECBT)     ; Set (Y X) to point to the character definition in
     B136 A200     
24678 B138 020F  20        li   ry,((ECBT)/256)*256        ; LDY #HI(ECBT)     ; ECBT. The LDY has no effect, as we overwrite Y with
     B13A B200     
24679                                                                          ; the jump to BULB-2, which writes the high byte of SPBT
24680                                                                          ; into Y. This works as long as ECBT and SPBT are in
24681                                                                          ; the same page of memory, so perhaps the BNE below got
24682                                                                          ; changed from BULB to BULB-2 so they could remove the
24683                                                                          ; LDY, but for some reason it didn't get culled? Who
24684                                                                          ; knows...
24685               
24686 B13C 1605  14        jne  BULB-2                     ; BNE BULB-2        ; Jump down to BULB-2 (this BNE is effectively a JMP as
24687                                                                          ; A will never be zero)
24688               
24689               * ******************************************************************************
24690               *
24691               * Name: SPBLB
24692               * Type: Subroutine
24693               * Category: Dashboard
24694               * Summary: Light up the space station indicator ("S") on the dashboard
24695               *
24696               * ******************************************************************************
24697               
24698               SPBLB:
24699 B13E 020D  20        li   ra,(24*8)*256              ; LDA #24*8         ; The space station bulb is in character block number 24
     B140 C000     
24700                                                                          ; with each character taking 8 bytes, so this sets the
24701                                                                          ; low byte of the screen address of the character block
24702                                                                          ; we want to draw to
24703               
24704 B142 020E  20        li   rx,((SPBT)%256)*256        ; LDX #LO(SPBT)     ; Set (Y X) to point to the character definition in SPBT
     B144 9F00     
24705 B146 020F  20        li   ry,((SPBT)/256)*256        ; LDY #HI(SPBT)
     B148 B200     
24706               
24707                                                                          ; Fall through into BULB to draw the space station bulb
24708               
24709               * ******************************************************************************
24710               *
24711               * Name: BULB
24712               * Type: Subroutine
24713               * Category: Dashboard
24714               * Summary: Draw an indicator bulb on the dashboard
24715               *
24716               * ------------------------------------------------------------------------------
24717               *
24718               * Arguments:
24719               *
24720               * A                   The y-coordinate of the bulb as a low-byte screen
24721               * address offset within screen page &7D (as both bulbs
24722               * are on this character row in the dashboard)
24723               *
24724               * (Y X)               The address of the character definition of the bulb to
24725               * be drawn (i.e. ECBT for the E.C.M. bulb, or SPBT for the
24726               * space station bulb)
24727               *
24728               * ------------------------------------------------------------------------------
24729               *
24730               * Other entry points:
24731               *
24732               * BULB-2              Set the Y screen address
24733               *
24734               * ******************************************************************************
24735               
24736               BULB:
24737 B14A D80D  30        movb ra,@SC                     ; STA SC            ; Store the low byte of the screen address in SC
     B14C 0007     
24738               
24739 B14E D80E  30        movb rx,@P+1                    ; STX P+1           ; Set P(2 1) = (Y X)
     B150 001C     
24740 B152 D80F  30        movb ry,@P+2                    ; STY P+2
     B154 001D     
24741               
24742 B156 020D  20        li   ra,>7d*256                 ; LDA #&7D          ; Set A to the high byte of the screen address, which is
     B158 7D00     
24743                                                                          ; &7D as the bulbs are both in the character row from
24744                                                                          ; &7D00 to &7DFF
24745               
24746 B15A 0460  28        b    @RREN                      ; JMP RREN          ; Call RREN to print the character definition pointed to
     B15C 3276     
24747                                                                          ; by P(2 1) at the screen address pointed to by (A SC),
24748                                                                          ; returning from the subroutine using a tail call
24749               
24750               * ******************************************************************************
24751               *
24752               * Name: ECBT
24753               * Type: Variable
24754               * Category: Dashboard
24755               * Summary: The character bitmap for the E.C.M. indicator bulb
24756               *
24757               * ------------------------------------------------------------------------------
24758               *
24759               * The character bitmap for the E.C.M. indicator's "E" bulb that gets displayed
24760               * on the dashboard.
24761               *
24762               * The E.C.M. indicator uses the first 5 rows of the space station's "S" bulb
24763               * below, as the bottom 5 rows of the "E" match the top 5 rows of the "S".
24764               *
24765               * Each pixel is in mode 5 colour 2 (%10), which is yellow/white.
24766               *
24767               * ******************************************************************************
24768               
24769               ECBT:
24770 B15E E0              byte >e0                                            ; x x x .
24771 B15F   E0            byte >e0                                            ; x x x .
24772 B160 80              byte >80                                            ; x . . .
24773                                                                          ; x x x .
24774                                                                          ; x x x .
24775                                                                          ; x . . .
24776                                                                          ; x x x .
24777                                                                          ; x x x .
24778               
24779               * ******************************************************************************
24780               *
24781               * Name: SPBT
24782               * Type: Variable
24783               * Category: Dashboard
24784               * Summary: The bitmap definition for the space station indicator bulb
24785               *
24786               * ------------------------------------------------------------------------------
24787               *
24788               * The bitmap definition for the space station indicator's "S" bulb that gets
24789               * displayed on the dashboard.
24790               *
24791               * Each pixel is in mode 5 colour 2 (%10), which is yellow/white.
24792               *
24793               * ******************************************************************************
24794               
24795               SPBT:
24796 B161   E0            byte >e0                                            ; x x x .
24797 B162 E0              byte >e0                                            ; x x x .
24798 B163   80            byte >80                                            ; x . . .
24799 B164 E0              byte >e0                                            ; x x x .
24800 B165   E0            byte >e0                                            ; x x x .
24801 B166 20              byte >20                                            ; . . x .
24802 B167   E0            byte >e0                                            ; x x x .
24803 B168 E0              byte >e0                                            ; x x x .
24804               
24805               * ******************************************************************************
24806               *
24807               * Name: MSBAR
24808               * Type: Subroutine
24809               * Category: Dashboard
24810               * Summary: Draw a specific indicator in the dashboard's missile bar
24811               *
24812               * ------------------------------------------------------------------------------
24813               *
24814               * Each indicator is a rectangle that's 3 pixels wide and 5 pixels high. If the
24815               * indicator is set to black, this effectively removes a missile.
24816               *
24817               * ------------------------------------------------------------------------------
24818               *
24819               * Arguments:
24820               *
24821               * X                   The number of the missile indicator to update (counting
24822               * from right to left, so indicator NOMSL is the leftmost
24823               * indicator)
24824               *
24825               * Y                   The colour of the missile indicator:
24826               *
24827               * * &00 = black (no missile)
24828               *
24829               * * &0E = red (armed and locked)
24830               *
24831               * * &E0 = yellow/white (armed)
24832               *
24833               * * &EE = green/cyan (disarmed)
24834               *
24835               * ------------------------------------------------------------------------------
24836               *
24837               * Returns:
24838               *
24839               * X                   X is preserved
24840               *
24841               * Y                   Y is set to 0
24842               *
24843               * ******************************************************************************
24844               
24845               MSBAR:
24846 B16A D34E  18        movb rx,ra                      ; TXA               ; Set T = X * 8
24847                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B16C 024D  22        andi ra,>ff00
     B16E FF00     
0002 B170 0A1D  18        sla  ra,1
                   < elite.a99
24848                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B172 024D  22        andi ra,>ff00
     B174 FF00     
0002 B176 0A1D  18        sla  ra,1
                   < elite.a99
24849                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B178 024D  22        andi ra,>ff00
     B17A FF00     
0002 B17C 0A1D  18        sla  ra,1
                   < elite.a99
24850 B17E D80D  30        movb ra,@T                      ; STA T
     B180 00D1     
24851               
24852 B182 020D  20        li   ra,>31*256                 ; LDA #49           ; Set SC = 49 - T
     B184 3100     
24853                      .sbc @T,ra                      ; SBC T             ; = 48 + 1 - (X * 8)
     **** ****     > SBC
0001 B186 1801  14        joc  !
0002 B188 7347  18        sb   rone,ra
0003               !:
0004 B18A 7360  30        sb   @T,ra
     B18C 00D1     
                   < elite.a99
24854 B18E D80D  30        movb ra,@SC                     ; STA SC
     B190 0007     
24855               
24856                                                                          ; So the low byte of SC(1 0) contains the row address
24857                                                                          ; for the rightmost missile indicator, made up as
24858                                                                          ; follows:
24859                                                                          ;
24860                                                                          ; * 48 (character block 7, as byte #7 * 8 = 48), the
24861                                                                          ; character block of the rightmost missile
24862                                                                          ;
24863                                                                          ; * 1 (so we start drawing on the second row of the
24864                                                                          ; character block)
24865                                                                          ;
24866                                                                          ; * Move left one character (8 bytes) for each count
24867                                                                          ; of X, so when X = 0 we are drawing the rightmost
24868                                                                          ; missile, for X = 1 we hop to the left by one
24869                                                                          ; character, and so on
24870               
24871 B192 020D  20        li   ra,>7e*256                 ; LDA #&7E          ; Set the high byte of SC(1 0) to &7E, the character row
     B194 7E00     
24872 B196 D80D  30        movb ra,@SCH                    ; STA SCH           ; that contains the missile indicators (i.e. the bottom
     B198 0008     
24873                                                                          ; row of the screen)
24874               
24875 B19A D34F  18        movb ry,ra                      ; TYA               ; Set A to the correct colour, which is a 3-pixel wide
24876                                                                          ; mode 5 character row in the correct colour (for
24877                                                                          ; example, a green block has Y = &EE, or %11101110, so
24878                                                                          ; the missile blocks are 3 pixels wide, with the
24879                                                                          ; fourth pixel on the character row being empty)
24880               
24881 B19C 020F  20        li   ry,>05*256                 ; LDY #5            ; We now want to draw this line five times, so set a
     B19E 0500     
24882                                                                          ; counter in Y
24883               
24884               MBL1:
24885                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the 3-pixel row, and as we do not use EOR logic,
     **** ****     > ST_IND_Y_IDX
0001 B1A0 D820  42        movb @SC,@rtmplb
     B1A2 0007     
     B1A4 8301     
0002 B1A6 D020  30        movb @SC+1,rtmp
     B1A8 0008     
0003 B1AA 06CF  14        swpb ry
0004 B1AC A00F  18        a    ry,rtmp
0005 B1AE 06CF  14        swpb ry
0006 B1B0 D40D  30        movb RA,*rtmp
                   < elite.a99
24886                                                                          ; this will overwrite anything that is already there
24887                                                                          ; (so drawing a black missile will delete what's there)
24888               
24889 B1B2 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter for the next row
24890               
24891 B1B4 16F5  14        jne  MBL1                       ; BNE MBL1          ; Loop back to MBL1 if have more rows to draw
24892               
24893 B1B6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B1B8 FE34     
24894               
24895               * ******************************************************************************
24896               *
24897               * Name: PROJ
24898               * Type: Subroutine
24899               * Category: Maths (Geometry)
24900               * Summary: Project the current ship or planet onto the screen
24901               * Deep dive: Extended screen coordinates
24902               *
24903               * ------------------------------------------------------------------------------
24904               *
24905               * Project the current ship's location or the planet onto the screen, either
24906               * returning the screen coordinates of the projection (if it's on-screen), or
24907               * returning an error via the C flag.
24908               *
24909               * In this context, "on-screen" means that the point is projected into the
24910               * following range:
24911               *
24912               * centre of screen - 1024 < x < centre of screen + 1024
24913               * centre of screen - 1024 < y < centre of screen + 1024
24914               *
24915               * This is to cater for ships (and, more likely, planets and suns) whose centres
24916               * are off-screen but whose edges may still be visible.
24917               *
24918               * The projection calculation is:
24919               *
24920               * K3(1 0) = #X + x / z
24921               * K4(1 0) = #Y + y / z
24922               *
24923               * where #X and #Y are the pixel x-coordinate and y-coordinate of the centre of
24924               * the screen.
24925               *
24926               * ------------------------------------------------------------------------------
24927               *
24928               * Arguments:
24929               *
24930               * INWK                The ship data block for the ship to project on-screen
24931               *
24932               * ------------------------------------------------------------------------------
24933               *
24934               * Returns:
24935               *
24936               * K3(1 0)             The x-coordinate of the ship's projection on-screen
24937               *
24938               * K4(1 0)             The y-coordinate of the ship's projection on-screen
24939               *
24940               * C flag              Set if the ship's projection doesn't fit on the screen,
24941               * clear if it does project onto the screen
24942               *
24943               * A                   Contains K4+1, the high byte of the y-coordinate
24944               *
24945               * ******************************************************************************
24946               
24947               PROJ:
24948 B1BA D360  30        movb @INWK,ra                   ; LDA INWK          ; Set P(1 0) = (x_hi x_lo)
     B1BC 0053     
24949 B1BE D80D  30        movb ra,@P                      ; STA P             ; = x
     B1C0 001B     
24950 B1C2 D360  30        movb @INWK+1,ra                 ; LDA INWK+1
     B1C4 0054     
24951 B1C6 D80D  30        movb ra,@P+1                    ; STA P+1
     B1C8 001C     
24952               
24953 B1CA D360  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Set A = x_sign
     B1CC 0055     
24954               
24955 B1CE 0200  20        li   rtmp,PLS6                  ; JSR PLS6          ; Call PLS6 to calculate:
     B1D0 BBA0     
24956 B1D2 06A0  32        bl   @jsr                       ;
     B1D4 FE28     
24957                                                                          ;
24958                                                                          ; (X K) = (A P+1 P) / (z_sign z_hi z_lo)
24959                                                                          ; = (x_sign x_hi x_lo) / (z_sign z_hi z_lo)
24960                                                                          ; = x / z
24961               
24962 B1D6 1832  14        joc  PL2-1                      ; BCS PL2-1         ; If the C flag is set then the result overflowed and
24963                                                                          ; the coordinate doesn't fit on the screen, so return
24964                                                                          ; from the subroutine with the C flag set (as PL2-1
24965                                                                          ; contains an RTS)
24966               
24967 B1D8 D360  30        movb @K,ra                      ; LDA K             ; Set K3(1 0) = (X K) + #X
     B1DA 003D     
24968                      .adi ((X)*256)                  ; ADC #X            ; = #X + x / z
     **** ****     > ADI
0001 B1DC 1701  14        jnc  !
0002 B1DE B347  18        ab   rone,ra
0003               !:
0004 B1E0 022D  22        ai   ra,((X)*256)
     B1E2 8000     
                   < elite.a99
24969 B1E4 D80D  30        movb ra,@K3                     ; STA K3            ;
     B1E6 00D2     
24970                                                                          ; first doing the low bytes
24971               
24972 B1E8 D34E  18        movb rx,ra                      ; TXA               ; And then the high bytes. #X is the x-coordinate of
24973                      .adi (>00*256)                  ; ADC #0            ; the centre of the space view, so this converts the
     **** ****     > ADI
0001 B1EA 1701  14        jnc  !
0002 B1EC B347  18        ab   rone,ra
0003               !:
0004 B1EE 022D  22        ai   ra,(>00*256)
     B1F0 0000     
                   < elite.a99
24974 B1F2 D80D  30        movb ra,@K3+1                   ; STA K3+1          ; space x-coordinate into a screen x-coordinate
     B1F4 00D3     
24975               
24976 B1F6 D360  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P(1 0) = (y_hi y_lo)
     B1F8 0056     
24977 B1FA D80D  30        movb ra,@P                      ; STA P
     B1FC 001B     
24978 B1FE D360  30        movb @INWK+4,ra                 ; LDA INWK+4
     B200 0057     
24979 B202 D80D  30        movb ra,@P+1                    ; STA P+1
     B204 001C     
24980               
24981 B206 D360  30        movb @INWK+5,ra                 ; LDA INWK+5        ; Set A = -y_sign
     B208 0058     
24982                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 B20A 0200  20        li   rtmp,(>80*256)
     B20C 8000     
0002 B20E 2B40  18        xor  rtmp,ra
                   < elite.a99
24983               
24984 B210 0200  20        li   rtmp,PLS6                  ; JSR PLS6          ; Call PLS6 to calculate:
     B212 BBA0     
24985 B214 06A0  32        bl   @jsr                       ;
     B216 FE28     
24986                                                                          ;
24987                                                                          ; (X K) = (A P+1 P) / (z_sign z_hi z_lo)
24988                                                                          ; = -(y_sign y_hi y_lo) / (z_sign z_hi z_lo)
24989                                                                          ; = -y / z
24990               
24991 B218 1811  14        joc  PL2-1                      ; BCS PL2-1         ; If the C flag is set then the result overflowed and
24992                                                                          ; the coordinate doesn't fit on the screen, so return
24993                                                                          ; from the subroutine with the C flag set (as PL2-1
24994                                                                          ; contains an RTS)
24995               
24996 B21A D360  30        movb @K,ra                      ; LDA K             ; Set K4(1 0) = (X K) + #Y
     B21C 003D     
24997                      .adi ((Y)*256)                  ; ADC #Y            ; = #Y - y / z
     **** ****     > ADI
0001 B21E 1701  14        jnc  !
0002 B220 B347  18        ab   rone,ra
0003               !:
0004 B222 022D  22        ai   ra,((Y)*256)
     B224 6000     
                   < elite.a99
24998 B226 D80D  30        movb ra,@K4                     ; STA K4            ;
     B228 00E0     
24999                                                                          ; first doing the low bytes
25000               
25001 B22A D34E  18        movb rx,ra                      ; TXA               ; And then the high bytes. #Y is the y-coordinate of
25002                      .adi (>00*256)                  ; ADC #0            ; the centre of the space view, so this converts the
     **** ****     > ADI
0001 B22C 1701  14        jnc  !
0002 B22E B347  18        ab   rone,ra
0003               !:
0004 B230 022D  22        ai   ra,(>00*256)
     B232 0000     
                   < elite.a99
25003 B234 D80D  30        movb ra,@K4+1                   ; STA K4+1          ; space x-coordinate into a screen y-coordinate
     B236 00E1     
25004               
25005                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 B238 0A16  18        sla  rzero,1
                   < elite.a99
25006               
25007 B23A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B23C FE34     
25008               
25009               * ******************************************************************************
25010               *
25011               * Name: PL2
25012               * Type: Subroutine
25013               * Category: Drawing planets
25014               * Summary: Remove the planet or sun from the screen
25015               *
25016               * ------------------------------------------------------------------------------
25017               *
25018               * Other entry points:
25019               *
25020               * PL2-1               Contains an RTS
25021               *
25022               * ******************************************************************************
25023               
25024               PL2:
25025 B23E D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Shift bit 0 of the planet/sun's type into the C flag
     B240 009B     
25026 B242 091D  18        srl  ra,1                       ; LSR A
25027               
25028 B244 1802  14        joc  B75                        ; BCS B75           ; If the planet/sun's type has bit 0 clear, then it's
25029                                                                          ; either 128 or 130, which is a planet; meanwhile, the
25030                                                                          ; sun has type 129, which has bit 0 set. So if this is
25031                                                                          ; the sun, skip the following instruction
25032               
25033 B246 0460  28        b    @WPLS2                     ; JMP WPLS2         ; This is the planet, so jump to WPLS2 to remove it from
     B248 B96A     
25034                                                                          ; screen, returning from the subroutine using a tail
25035                                                                          ; call
25036               
25037               B75:
25038 B24A 0460  28        b    @WPLS                      ; JMP WPLS          ; This is the sun, so jump to WPLS to remove it from
     B24C B9DC     
25039                                                                          ; screen, returning from the subroutine using a tail
25040                                                                          ; call
25041               
25042               * ******************************************************************************
25043               *
25044               * Name: PLANET
25045               * Type: Subroutine
25046               * Category: Drawing planets
25047               * Summary: Draw the planet or sun
25048               *
25049               * ------------------------------------------------------------------------------
25050               *
25051               * Arguments:
25052               *
25053               * INWK                The planet or sun's ship data block
25054               *
25055               * ******************************************************************************
25056               
25057               PLANET:
25058 B24E D360  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set A = z_sign (the highest byte in the planet/sun's
     B250 005B     
25059                                                                          ; coordinates)
25060               
25061 B252 11F5  14        jlt  PL2                        ; BMI PL2           ; If A is negative then the planet/sun is behind us, so
25062                                                                          ; jump to PL2 to remove it from the screen, returning
25063                                                                          ; from the subroutine using a tail call
25064               
25065 B254 028D  22        ci   ra,>30*256                 ; CMP #48           ; If A >= 48 then the planet/sun is too far away to be
     B256 3000     
25066 B258 18F2  14        joc  PL2                        ; BCS PL2           ; seen, so jump to PL2 to remove it from the screen,
25067                                                                          ; returning from the subroutine using a tail call
25068               
25069 B25A F360  30        socb @INWK+7,ra                 ; ORA INWK+7        ; Set A to 0 if both z_sign and z_hi are 0
     B25C 005A     
25070               
25071 B25E 13EF  14        jeq  PL2                        ; BEQ PL2           ; If both z_sign and z_hi are 0, then the planet/sun is
25072                                                                          ; too close to be shown, so jump to PL2 to remove it
25073                                                                          ; from the screen, returning from the subroutine using a
25074                                                                          ; tail call
25075               
25076 B260 0200  20        li   rtmp,PROJ                  ; JSR PROJ          ; Project the planet/sun onto the screen, returning the
     B262 B1BA     
25077 B264 06A0  32        bl   @jsr                       ;
     B266 FE28     
25078                                                                          ; centre's coordinates in K3(1 0) and K4(1 0)
25079               
25080 B268 18EA  14        joc  PL2                        ; BCS PL2           ; If the C flag is set by PROJ then the planet/sun is
25081                                                                          ; not visible on-screen, so jump to PL2 to remove it
25082                                                                          ; from the screen, returning from the subroutine using
25083                                                                          ; a tail call
25084               
25085 B26A 020D  20        li   ra,>60*256                 ; LDA #96           ; Set (A P+1 P) = (0 96 0) = 24576
     B26C 6000     
25086 B26E D80D  30        movb ra,@P+1                    ; STA P+1           ;
     B270 001C     
25087 B272 020D  20        li   ra,>00*256                 ; LDA #0            ; This represents the planet/sun's radius at a distance
     B274 0000     
25088 B276 D80D  30        movb ra,@P                      ; STA P             ; of z = 1
     B278 001B     
25089               
25090 B27A 0200  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     B27C 469C     
25091 B27E 06A0  32        bl   @jsr                       ;
     B280 FE28     
25092                                                                          ;
25093                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
25094                                                                          ; = (0 96 0) / z
25095                                                                          ; = 24576 / z
25096                                                                          ;
25097                                                                          ; so K now contains the planet/sun's radius, reduced by
25098                                                                          ; the actual distance to the planet/sun. We know that
25099                                                                          ; K+3 and K+2 will be 0, as the number we are dividing,
25100                                                                          ; (0 96 0), fits into the two bottom bytes, so the
25101                                                                          ; result is actually in K(1 0)
25102               
25103 B282 D360  30        movb @K+1,ra                    ; LDA K+1           ; If the high byte of the reduced radius is zero, jump
     B284 003E     
25104 B286 1304  14        jeq  PL82                       ; BEQ PL82          ; to PL82, as K contains the radius on its own
25105               
25106 B288 020D  20        li   ra,>f8*256                 ; LDA #248          ; Otherwise set K = 248, to round up the radius in
     B28A F800     
25107 B28C D80D  30        movb ra,@K                      ; STA K             ; K(1 0) to the nearest integer (if we consider the low
     B28E 003D     
25108                                                                          ; byte to be the fractional part)
25109               
25110               PL82:
25111 B290 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If the planet/sun's type has bit 0 clear, then it's
     B292 009B     
25112 B294 091D  18        srl  ra,1                       ; LSR A             ; either 128 or 130, which is a planet (the sun has type
25113 B296 1702  14        jnc  PL9                        ; BCC PL9           ; 129, which has bit 0 set). So jump to PL9 to draw the
25114                                                                          ; planet with radius K, returning from the subroutine
25115                                                                          ; using a tail call
25116               
25117 B298 0460  28        b    @SUN                       ; JMP SUN           ; Otherwise jump to SUN to draw the sun with radius K,
     B29A B624     
25118                                                                          ; returning from the subroutine using a tail call
25119               
25120               * ******************************************************************************
25121               *
25122               * Name: PL9 (Part 1 of 3)
25123               * Type: Subroutine
25124               * Category: Drawing planets
25125               * Summary: Draw the planet, with either an equator and meridian, or a crater
25126               *
25127               * ------------------------------------------------------------------------------
25128               *
25129               * Draw the planet with radius K at pixel coordinate (K3, K4), and with either an
25130               * equator and meridian, or a crater.
25131               *
25132               * ------------------------------------------------------------------------------
25133               *
25134               * Arguments:
25135               *
25136               * K(1 0)              The planet's radius
25137               *
25138               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25139               *
25140               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25141               *
25142               * INWK                The planet's ship data block
25143               *
25144               * ******************************************************************************
25145               
25146               PL9:
25147 B29C 0200  20        li   rtmp,WPLS2                 ; JSR WPLS2         ; Call WPLS2 to remove the planet from the screen
     B29E B96A     
25148 B2A0 06A0  32        bl   @jsr                       ;
     B2A2 FE28     
25149               
25150 B2A4 0200  20        li   rtmp,CIRCLE                ; JSR CIRCLE        ; Call CIRCLE to draw the planet's new circle
     B2A6 B85E     
25151 B2A8 06A0  32        bl   @jsr                       ;
     B2AA FE28     
25152               
25153 B2AC 1803  14        joc  PL20                       ; BCS PL20          ; If the call to CIRCLE returned with the C flag set,
25154                                                                          ; then the circle does not fit on-screen, so jump to
25155                                                                          ; PL20 to return from the subroutine
25156               
25157 B2AE D360  30        movb @K+1,ra                    ; LDA K+1           ; If K+1 is zero, jump to PL25 as K(1 0) < 256, so the
     B2B0 003E     
25158 B2B2 1302  14        jeq  PL25                       ; BEQ PL25          ; planet fits on the screen and we can draw meridians or
25159                                                                          ; craters
25160               
25161               PL20:
25162 B2B4 0460  28        b    @rts                       ; RTS               ; The planet doesn't fit on-screen, so return from the
     B2B6 FE34     
25163                                                                          ; subroutine
25164               
25165               PL25:
25166 B2B8 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If the planet type is 128 then it has an equator and
     B2BA 009B     
25167 B2BC 028D  22        ci   ra,>80*256                 ; CMP #128          ; a meridian, so this jumps to PL26 if this is not a
     B2BE 8000     
25168 B2C0 1643  14        jne  PL26                       ; BNE PL26          ; planet with an equator - in other words, if it is a
25169                                                                          ; planet with a crater
25170               
25171                                                                          ; Otherwise this is a planet with an equator and
25172                                                                          ; meridian, so fall through into the following to draw
25173                                                                          ; them
25174               
25175               * ******************************************************************************
25176               *
25177               * Name: PL9 (Part 2 of 3)
25178               * Type: Subroutine
25179               * Category: Drawing planets
25180               * Summary: Draw the planet's equator and meridian
25181               * Deep dive: Drawing meridians and equators
25182               *
25183               * ------------------------------------------------------------------------------
25184               *
25185               * Draw the planet's equator and meridian.
25186               *
25187               * ------------------------------------------------------------------------------
25188               *
25189               * Arguments:
25190               *
25191               * K(1 0)              The planet's radius
25192               *
25193               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25194               *
25195               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25196               *
25197               * INWK                The planet's ship data block
25198               *
25199               * ******************************************************************************
25200               
25201 B2C2 D360  30        movb @K,ra                      ; LDA K             ; If the planet's radius is less than 6, the planet is
     B2C4 003D     
25202 B2C6 028D  22        ci   ra,>06*256                 ; CMP #6            ; too small to show a meridian, so jump to PL20 to
     B2C8 0600     
25203 B2CA 17F4  14        jnc  PL20                       ; BCC PL20          ; return from the subroutine
25204               
25205 B2CC D360  30        movb @INWK+14,ra                ; LDA INWK+14       ; Set P = -nosev_z_hi
     B2CE 0061     
25206                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 B2D0 0200  20        li   rtmp,(>80*256)
     B2D2 8000     
0002 B2D4 2B40  18        xor  rtmp,ra
                   < elite.a99
25207 B2D6 D80D  30        movb ra,@P                      ; STA P
     B2D8 001B     
25208               
25209 B2DA D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z_hi
     B2DC 0067     
25210               
25211 B2DE 0200  20        li   rtmp,PLS4                  ; JSR PLS4          ; Call PLS4 to calculate the following:
     B2E0 BB58     
25212 B2E2 06A0  32        bl   @jsr                       ;
     B2E4 FE28     
25213                                                                          ;
25214                                                                          ; CNT2 = arctan(P / A) / 4
25215                                                                          ; = arctan(-nosev_z_hi / roofv_z_hi) / 4
25216                                                                          ;
25217                                                                          ; and do the following if nosev_z_hi >= 0:
25218                                                                          ;
25219                                                                          ; CNT2 = CNT2 + PI
25220               
25221 B2E6 020E  20        li   rx,>09*256                 ; LDX #9            ; Set X to 9 so the call to PLS1 divides nosev_x
     B2E8 0900     
25222               
25223 B2EA 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B2EC B40C     
25224 B2EE 06A0  32        bl   @jsr                       ;
     B2F0 FE28     
25225 B2F2 D80D  30        movb ra,@K2                     ; STA K2            ;
     B2F4 00AC     
25226 B2F6 D80F  30        movb ry,@XX16                   ; STY XX16          ; (XX16 K2) = nosev_x / z
     B2F8 0009     
25227                                                                          ;
25228                                                                          ; and increment X to point to nosev_y for the next call
25229               
25230 B2FA 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B2FC B40C     
25231 B2FE 06A0  32        bl   @jsr                       ;
     B300 FE28     
25232 B302 D80D  30        movb ra,@K2+1                   ; STA K2+1          ;
     B304 00AD     
25233 B306 D80F  30        movb ry,@XX16+1                 ; STY XX16+1        ; (XX16+1 K2+1) = nosev_y / z
     B308 000A     
25234               
25235 B30A 020E  20        li   rx,>0f*256                 ; LDX #15           ; Set X to 15 so the call to PLS5 divides roofv_x
     B30C 0F00     
25236               
25237 B30E 0200  20        li   rtmp,PLS5                  ; JSR PLS5          ; Call PLS5 to calculate the following:
     B310 BB7C     
25238 B312 06A0  32        bl   @jsr                       ;
     B314 FE28     
25239                                                                          ;
25240                                                                          ; (XX16+2 K2+2) = roofv_x / z
25241                                                                          ;
25242                                                                          ; (XX16+3 K2+3) = roofv_y / z
25243               
25244 B316 0200  20        li   rtmp,PLS2                  ; JSR PLS2          ; Call PLS2 to draw the first meridian
     B318 B44A     
25245 B31A 06A0  32        bl   @jsr                       ;
     B31C FE28     
25246               
25247 B31E D360  30        movb @INWK+14,ra                ; LDA INWK+14       ; Set P = -nosev_z_hi
     B320 0061     
25248                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 B322 0200  20        li   rtmp,(>80*256)
     B324 8000     
0002 B326 2B40  18        xor  rtmp,ra
                   < elite.a99
25249 B328 D80D  30        movb ra,@P                      ; STA P
     B32A 001B     
25250               
25251 B32C D360  30        movb @INWK+26,ra                ; LDA INWK+26       ; Set A = sidev_z_hi, so the second meridian will be at
     B32E 006D     
25252                                                                          ; 90 degrees to the first
25253               
25254 B330 0200  20        li   rtmp,PLS4                  ; JSR PLS4          ; Call PLS4 to calculate the following:
     B332 BB58     
25255 B334 06A0  32        bl   @jsr                       ;
     B336 FE28     
25256                                                                          ;
25257                                                                          ; CNT2 = arctan(P / A) / 4
25258                                                                          ; = arctan(-nosev_z_hi / sidev_z_hi) / 4
25259                                                                          ;
25260                                                                          ; and do the following if nosev_z_hi >= 0:
25261                                                                          ;
25262                                                                          ; CNT2 = CNT2 + PI
25263               
25264 B338 020E  20        li   rx,>15*256                 ; LDX #21           ; Set X to 21 so the call to PLS5 divides sidev_x
     B33A 1500     
25265               
25266 B33C 0200  20        li   rtmp,PLS5                  ; JSR PLS5          ; Call PLS5 to calculate the following:
     B33E BB7C     
25267 B340 06A0  32        bl   @jsr                       ;
     B342 FE28     
25268                                                                          ;
25269                                                                          ; (XX16+2 K2+2) = sidev_x / z
25270                                                                          ;
25271                                                                          ; (XX16+3 K2+3) = sidev_y / z
25272               
25273 B344 0460  28        b    @PLS2                      ; JMP PLS2          ; Jump to PLS2 to draw the second meridian, returning
     B346 B44A     
25274                                                                          ; from the subroutine using a tail call
25275               
25276               * ******************************************************************************
25277               *
25278               * Name: PL9 (Part 3 of 3)
25279               * Type: Subroutine
25280               * Category: Drawing planets
25281               * Summary: Draw the planet's crater
25282               * Deep dive: Drawing craters
25283               *
25284               * ------------------------------------------------------------------------------
25285               *
25286               * Draw the planet's crater.
25287               *
25288               * ------------------------------------------------------------------------------
25289               *
25290               * Arguments:
25291               *
25292               * K(1 0)              The planet's radius
25293               *
25294               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25295               *
25296               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25297               *
25298               * INWK                The planet's ship data block
25299               *
25300               * ******************************************************************************
25301               
25302               PL26:
25303 B348 D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z_hi
     B34A 0067     
25304               
25305 B34C 11B3  14        jlt  PL20                       ; BMI PL20          ; If A is negative, the crater is on the far side of the
25306                                                                          ; planet, so return from the subroutine (as PL2
25307                                                                          ; contains an RTS)
25308               
25309 B34E 020E  20        li   rx,>0f*256                 ; LDX #15           ; Set X = 15, so the following call to PLS3 operates on
     B350 0F00     
25310                                                                          ; roofv
25311               
25312 B352 0200  20        li   rtmp,PLS3                  ; JSR PLS3          ; Call PLS3 to calculate:
     B354 BB0C     
25313 B356 06A0  32        bl   @jsr                       ;
     B358 FE28     
25314                                                                          ;
25315                                                                          ; (Y A P) = 222 * roofv_x / z
25316                                                                          ;
25317                                                                          ; to give the x-coordinate of the crater offset and
25318                                                                          ; increment X to point to roofv_y for the next call
25319               
25320                      .clc                            ; CLC               ; Calculate:
     **** ****     > CLC
0001 B35A 0A16  18        sla  rzero,1
                   < elite.a99
25321                      .adc @K3,ra                     ; ADC K3            ;
     **** ****     > ADC
0001 B35C 1701  14        jnc  !
0002 B35E B347  18        ab   rone,ra
0003               !:
0004 B360 B360  30        ab   @K3,ra
     B362 00D2     
                   < elite.a99
25322 B364 D80D  30        movb ra,@K3                     ; STA K3            ; K3(1 0) = (Y A) + K3(1 0)
     B366 00D2     
25323                                                                          ; = 222 * roofv_x / z + x-coordinate of planet
25324                                                                          ; centre
25325                                                                          ;
25326                                                                          ; starting with the high bytes
25327               
25328 B368 D34F  18        movb ry,ra                      ; TYA               ; And then doing the low bytes, so now K3(1 0) contains
25329                      .adc @K3+1,ra                   ; ADC K3+1          ; the x-coordinate of the crater offset plus the planet
     **** ****     > ADC
0001 B36A 1701  14        jnc  !
0002 B36C B347  18        ab   rone,ra
0003               !:
0004 B36E B360  30        ab   @K3+1,ra
     B370 00D3     
                   < elite.a99
25330 B372 D80D  30        movb ra,@K3+1                   ; STA K3+1          ; centre to give the x-coordinate of the crater's centre
     B374 00D3     
25331               
25332 B376 0200  20        li   rtmp,PLS3                  ; JSR PLS3          ; Call PLS3 to calculate:
     B378 BB0C     
25333 B37A 06A0  32        bl   @jsr                       ;
     B37C FE28     
25334                                                                          ;
25335                                                                          ; (Y A P) = 222 * roofv_y / z
25336                                                                          ;
25337                                                                          ; to give the y-coordinate of the crater offset
25338               
25339 B37E D80D  30        movb ra,@P                      ; STA P             ; Calculate:
     B380 001B     
25340 B382 D360  30        movb @K4,ra                     ; LDA K4            ;
     B384 00E0     
25341                      .sec                            ; SEC               ; K4(1 0) = K4(1 0) - (Y A)
     **** ****     > SEC
0001 B386 0A18  18        sla  rmone,1
                   < elite.a99
25342                      .sbc @P,ra                      ; SBC P             ; = 222 * roofv_y / z - y-coordinate of planet
     **** ****     > SBC
0001 B388 1801  14        joc  !
0002 B38A 7347  18        sb   rone,ra
0003               !:
0004 B38C 7360  30        sb   @P,ra
     B38E 001B     
                   < elite.a99
25343 B390 D80D  30        movb ra,@K4                     ; STA K4            ; centre
     B392 00E0     
25344                                                                          ;
25345                                                                          ; starting with the low bytes
25346               
25347 B394 D80F  30        movb ry,@P                      ; STY P             ; And then doing the low bytes, so now K4(1 0) contains
     B396 001B     
25348 B398 D360  30        movb @K4+1,ra                   ; LDA K4+1          ; the y-coordinate of the crater offset plus the planet
     B39A 00E1     
25349                      .sbc @P,ra                      ; SBC P             ; centre to give the y-coordinate of the crater's centre
     **** ****     > SBC
0001 B39C 1801  14        joc  !
0002 B39E 7347  18        sb   rone,ra
0003               !:
0004 B3A0 7360  30        sb   @P,ra
     B3A2 001B     
                   < elite.a99
25350 B3A4 D80D  30        movb ra,@K4+1                   ; STA K4+1
     B3A6 00E1     
25351               
25352 B3A8 020E  20        li   rx,>09*256                 ; LDX #9            ; Set X = 9, so the following call to PLS1 operates on
     B3AA 0900     
25353                                                                          ; nosev
25354               
25355 B3AC 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B3AE B40C     
25356 B3B0 06A0  32        bl   @jsr                       ;
     B3B2 FE28     
25357                                                                          ;
25358                                                                          ; (Y A) = nosev_x / z
25359                                                                          ;
25360                                                                          ; and increment X to point to nosev_y for the next call
25361               
25362 B3B4 091D  18        srl  ra,1                       ; LSR A             ; Set (XX16 K2) = (Y A) / 2
25363 B3B6 D80D  30        movb ra,@K2                     ; STA K2
     B3B8 00AC     
25364 B3BA D80F  30        movb ry,@XX16                   ; STY XX16
     B3BC 0009     
25365               
25366 B3BE 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B3C0 B40C     
25367 B3C2 06A0  32        bl   @jsr                       ;
     B3C4 FE28     
25368                                                                          ;
25369                                                                          ; (Y A) = nosev_y / z
25370                                                                          ;
25371                                                                          ; and increment X to point to nosev_z for the next call
25372               
25373 B3C6 091D  18        srl  ra,1                       ; LSR A             ; Set (XX16+1 K2+1) = (Y A) / 2
25374 B3C8 D80D  30        movb ra,@K2+1                   ; STA K2+1
     B3CA 00AD     
25375 B3CC D80F  30        movb ry,@XX16+1                 ; STY XX16+1
     B3CE 000A     
25376               
25377 B3D0 020E  20        li   rx,>15*256                 ; LDX #21           ; Set X = 21, so the following call to PLS1 operates on
     B3D2 1500     
25378                                                                          ; sidev
25379               
25380 B3D4 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B3D6 B40C     
25381 B3D8 06A0  32        bl   @jsr                       ;
     B3DA FE28     
25382                                                                          ;
25383                                                                          ; (Y A) = sidev_x / z
25384                                                                          ;
25385                                                                          ; and increment X to point to sidev_y for the next call
25386               
25387 B3DC 091D  18        srl  ra,1                       ; LSR A             ; Set (XX16+2 K2+2) = (Y A) / 2
25388 B3DE D80D  30        movb ra,@K2+2                   ; STA K2+2
     B3E0 00AE     
25389 B3E2 D80F  30        movb ry,@XX16+2                 ; STY XX16+2
     B3E4 000B     
25390               
25391 B3E6 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B3E8 B40C     
25392 B3EA 06A0  32        bl   @jsr                       ;
     B3EC FE28     
25393                                                                          ;
25394                                                                          ; (Y A) = sidev_y / z
25395                                                                          ;
25396                                                                          ; and increment X to point to sidev_z for the next call
25397               
25398 B3EE 091D  18        srl  ra,1                       ; LSR A             ; Set (XX16+3 K2+3) = (Y A) / 2
25399 B3F0 D80D  30        movb ra,@K2+3                   ; STA K2+3
     B3F2 00AF     
25400 B3F4 D80F  30        movb ry,@XX16+3                 ; STY XX16+3
     B3F6 000C     
25401               
25402 B3F8 020D  20        li   ra,>40*256                 ; LDA #64           ; Set TGT = 64, so we draw a full ellipse in the call to
     B3FA 4000     
25403 B3FC D80D  30        movb ra,@TGT                    ; STA TGT           ; PLS22 below
     B3FE 00A0     
25404               
25405 B400 020D  20        li   ra,>00*256                 ; LDA #0            ; Set CNT2 = 0 as we are drawing a full ellipse, so we
     B402 0000     
25406 B404 D80D  30        movb ra,@CNT2                   ; STA CNT2          ; don't need to apply an offset
     B406 00A5     
25407               
25408 B408 0460  28        b    @PLS22                     ; JMP PLS22         ; Jump to PLS22 to draw the crater, returning from the
     B40A B452     
25409                                                                          ; subroutine using a tail call
25410               
25411               * ******************************************************************************
25412               *
25413               * Name: PLS1
25414               * Type: Subroutine
25415               * Category: Drawing planets
25416               * Summary: Calculate (Y A) = nosev_x / z
25417               *
25418               * ------------------------------------------------------------------------------
25419               *
25420               * Calculate the following division of a specified value from one of the
25421               * orientation vectors (in this example, nosev_x):
25422               *
25423               * (Y A) = nosev_x / z
25424               *
25425               * where z is the z-coordinate of the planet from INWK. The result is an 8-bit
25426               * magnitude in A, with maximum value 254, and just a sign bit (bit 7) in Y.
25427               *
25428               * ------------------------------------------------------------------------------
25429               *
25430               * Arguments:
25431               *
25432               * X                   Determines which of the INWK orientation vectors to
25433               * divide:
25434               *
25435               * * X = 9, 11, 13: divides nosev_x, nosev_y, nosev_z
25436               *
25437               * * X = 15, 17, 19: divides roofv_x, roofv_y, roofv_z
25438               *
25439               * * X = 21, 23, 25: divides sidev_x, sidev_y, sidev_z
25440               *
25441               * INWK                The planet's ship data block
25442               *
25443               * ------------------------------------------------------------------------------
25444               *
25445               * Returns:
25446               *
25447               * A                   The result as an 8-bit magnitude with maximum value 254
25448               *
25449               * Y                   The sign of the result in bit 7
25450               *
25451               * K+3                 Also the sign of the result in bit 7
25452               *
25453               * X                   X gets incremented by 2 so it points to the next
25454               * coordinate in this orientation vector (so consecutive
25455               * calls to the routine will start with x, then move onto y
25456               * and then z)
25457               *
25458               * ******************************************************************************
25459               
25460               PLS1:
25461 B40C D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Set P = nosev_x_lo
     B40E 0053     
25462 B410 D80D  30        movb ra,@P                      ; STA P
     B412 001B     
25463               
25464 B414 D36E  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Set P+1 = |nosev_x_hi|
     B416 0054     
25465 B418 024D  22        andi ra,>7f*256                 ; AND #%01111111
     B41A 7F00     
25466 B41C D80D  30        movb ra,@P+1                    ; STA P+1
     B41E 001C     
25467               
25468 B420 D36E  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Set A = sign bit of nosev_x_lo
     B422 0054     
25469 B424 024D  22        andi ra,>80*256                 ; AND #%10000000
     B426 8000     
25470               
25471 B428 0200  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     B42A 469C     
25472 B42C 06A0  32        bl   @jsr                       ;
     B42E FE28     
25473                                                                          ;
25474                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
25475               
25476 B430 D360  30        movb @K,ra                      ; LDA K             ; Fetch the lowest byte of the result into A
     B432 003D     
25477               
25478 B434 D3E0  30        movb @K+1,ry                    ; LDY K+1           ; Fetch the second byte of the result into Y
     B436 003E     
25479               
25480 B438 1302  14        jeq  B76                        ; BEQ B76           ; If the second byte is 0, skip the next instruction
25481               
25482 B43A 020D  20        li   ra,>fe*256                 ; LDA #254          ; The second byte is non-zero, so the result won't fit
     B43C FE00     
25483                                                                          ; into one byte, so set A = 254 as our maximum one-byte
25484                                                                          ; value to return
25485               
25486               B76:
25487 B43E D3E0  30        movb @K+3,ry                    ; LDY K+3           ; Fetch the sign of the result from K+3 into Y
     B440 0040     
25488               
25489 B442 B387  18        ab   rone,rx                    ; INX               ; Add 2 to X so the index points to the next coordinate
25490 B444 B387  18        ab   rone,rx                    ; INX               ; in this orientation vector (so consecutive calls to
25491                                                                          ; the routine will start with x, then move onto y and z)
25492               
25493 B446 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B448 FE34     
25494               
25495               * ******************************************************************************
25496               *
25497               * Name: PLS2
25498               * Type: Subroutine
25499               * Category: Drawing planets
25500               * Summary: Draw a half-ellipse
25501               * Deep dive: Drawing ellipses
25502               * Drawing meridians and equators
25503               *
25504               * ------------------------------------------------------------------------------
25505               *
25506               * Draw a half-ellipse, used for the planet's equator and meridian.
25507               *
25508               * ******************************************************************************
25509               
25510               PLS2:
25511 B44A 020D  20        li   ra,>1f*256                 ; LDA #31           ; Set TGT = 31, so we only draw half an ellipse
     B44C 1F00     
25512 B44E D80D  30        movb ra,@TGT                    ; STA TGT
     B450 00A0     
25513               
25514                                                                          ; Fall through into PLS22 to draw the half-ellipse
25515               
25516               * ******************************************************************************
25517               *
25518               * Name: PLS22
25519               * Type: Subroutine
25520               * Category: Drawing planets
25521               * Summary: Draw an ellipse or half-ellipse
25522               * Deep dive: Drawing ellipses
25523               * Drawing meridians and equators
25524               * Drawing craters
25525               *
25526               * ------------------------------------------------------------------------------
25527               *
25528               * Draw an ellipse or half-ellipse, to be used for the planet's equator and
25529               * meridian (in which case we draw half an ellipse), or crater (in which case we
25530               * draw a full ellipse).
25531               *
25532               * The ellipse is defined by a centre point, plus two conjugate radius vectors,
25533               * u and v, where:
25534               *
25535               * u = [ u_x ]       v = [ v_x ]
25536               * [ u_y ]           [ v_y ]
25537               *
25538               * The individual components of these 2D vectors (i.e. u_x, u_y etc.) are 16-bit
25539               * sign-magnitude numbers, where the high bytes contain only the sign bit (in
25540               * bit 7), with bits 0 to 6 being clear. This means that as we store u_x as
25541               * (XX16 K2), for example, we know that |u_x| = K2.
25542               *
25543               * This routine calls BLINE to draw each line segment in the ellipse, passing the
25544               * coordinates as follows:
25545               *
25546               * K6(1 0) = K3(1 0) + u_x * cos(CNT2) + v_x * sin(CNT2)
25547               *
25548               * K6(3 2) = K4(1 0) - u_y * cos(CNT2) - v_y * sin(CNT2)
25549               *
25550               * The y-coordinates are negated because BLINE expects pixel coordinates but the
25551               * u and v vectors are extracted from the orientation vector. The y-axis runs
25552               * in the opposite direction in 3D space to that on the screen, so we need to
25553               * negate the 3D space coordinates before we can combine them with the ellipse's
25554               * centre coordinates.
25555               *
25556               * ------------------------------------------------------------------------------
25557               *
25558               * Arguments:
25559               *
25560               * K(1 0)              The planet's radius
25561               *
25562               * K3(1 0)             The pixel x-coordinate of the centre of the ellipse
25563               *
25564               * K4(1 0)             The pixel y-coordinate of the centre of the ellipse
25565               *
25566               * (XX16 K2)           The x-component of u (i.e. u_x), where XX16 contains
25567               * just the sign of the sign-magnitude number
25568               *
25569               * (XX16+1 K2+1)       The y-component of u (i.e. u_y), where XX16+1 contains
25570               * just the sign of the sign-magnitude number
25571               *
25572               * (XX16+2 K2+2)       The x-component of v (i.e. v_x), where XX16+2 contains
25573               * just the sign of the sign-magnitude number
25574               *
25575               * (XX16+3 K2+3)       The y-component of v (i.e. v_y), where XX16+3 contains
25576               * just the sign of the sign-magnitude number
25577               *
25578               * TGT                 The number of segments to draw:
25579               *
25580               * * 32 for a half ellipse (a meridian)
25581               *
25582               * * 64 for a full ellipse (a crater)
25583               *
25584               * CNT2                The starting segment for drawing the half-ellipse
25585               *
25586               * ******************************************************************************
25587               
25588               PLS22:
25589 B452 020E  20        li   rx,>00*256                 ; LDX #0            ; Set CNT = 0
     B454 0000     
25590 B456 D80E  30        movb rx,@CNT                    ; STX CNT
     B458 00A4     
25591               
25592 B45A 7387  18        sb   rone,rx                    ; DEX               ; Set FLAG = &FF to start a new line in the ball line
25593 B45C D80E  30        movb rx,@FLAG                   ; STX FLAG          ; heap when calling BLIN below, so the crater or
     B45E 00A3     
25594                                                                          ; meridian is separate from any previous ellipses
25595               
25596               PLL4:
25597 B460 D360  30        movb @CNT2,ra                   ; LDA CNT2          ; Set X = CNT2 mod 32
     B462 00A5     
25598 B464 024D  22        andi ra,>1f*256                 ; AND #31           ;
     B466 1F00     
25599 B468 D38D  18        movb ra,rx                      ; TAX               ; So X is the starting segment, reduced to the range 0
25600                                                                          ; to 32, so as there are 64 segments in the circle, this
25601                                                                          ; reduces the starting angle to 0 to 180 degrees, so we
25602                                                                          ; can use X as an index into the sine table (which only
25603                                                                          ; contains values for segments 0 to 31)
25604                                                                          ;
25605                                                                          ; Also, because CNT2 mod 32 is in the range 0 to 180
25606                                                                          ; degrees, we know that sin(CNT2 mod 32) is always
25607                                                                          ; positive, or to put it another way:
25608                                                                          ;
25609                                                                          ; sin(CNT2 mod 32) = |sin(CNT2)|
25610               
25611 B46A D36E  34        movb @SNE(rx),ra                ; LDA SNE,X         ; Set Q = sin(X)
     B46C 41C6     
25612 B46E D80D  30        movb ra,@Q                      ; STA Q             ; = sin(CNT2 mod 32)
     B470 0090     
25613                                                                          ; = |sin(CNT2)|
25614               
25615 B472 D360  30        movb @K2+2,ra                   ; LDA K2+2          ; Set A = K2+2
     B474 00AE     
25616                                                                          ; = |v_x|
25617               
25618 B476 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     B478 43EC     
25619 B47A 06A0  32        bl   @jsr                       ;
     B47C FE28     
25620 B47E D80D  30        movb ra,@R                      ; STA R             ; = |v_x| * |sin(CNT2)|
     B480 0091     
25621               
25622 B482 D360  30        movb @K2+3,ra                   ; LDA K2+3          ; Set A = K2+3
     B484 00AF     
25623                                                                          ; = |v_y|
25624               
25625 B486 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set K = A * Q / 256
     B488 43EC     
25626 B48A 06A0  32        bl   @jsr                       ;
     B48C FE28     
25627 B48E D80D  30        movb ra,@K                      ; STA K             ; = |v_y| * |sin(CNT2)|
     B490 003D     
25628               
25629 B492 D3A0  30        movb @CNT2,rx                   ; LDX CNT2          ; If CNT2 >= 33 then this sets the C flag, otherwise
     B494 00A5     
25630 B496 028E  22        ci   rx,>21*256                 ; CPX #33           ; it's clear, so this means that:
     B498 2100     
25631                                                                          ;
25632                                                                          ; * C is clear if the segment starts in the first half
25633                                                                          ; of the circle, 0 to 180 degrees
25634                                                                          ;
25635                                                                          ; * C is set if the segment starts in the second half
25636                                                                          ; of the circle, 180 to 360 degrees
25637                                                                          ;
25638                                                                          ; In other words, the C flag contains the sign bit for
25639                                                                          ; sin(CNT2), which is positive for 0 to 180 degrees
25640                                                                          ; and negative for 180 to 360 degrees
25641               
25642 B49A 020D  20        li   ra,>00*256                 ; LDA #0            ; Shift the C flag into the sign bit of XX16+5, so
     B49C 0000     
25643 B49E 06A0  32        bl   @rora                      ; ROR A             ; XX16+5 has the correct sign for sin(CNT2)
     B4A0 FE62     
25644 B4A2 D80D  30        movb ra,@XX16+5                 ; STA XX16+5        ;
     B4A4 000E     
25645                                                                          ; Because we set the following above:
25646                                                                          ;
25647                                                                          ; K = |v_y| * |sin(CNT2)|
25648                                                                          ; R = |v_x| * |sin(CNT2)|
25649                                                                          ;
25650                                                                          ; we can add XX16+5 as the high byte to give us the
25651                                                                          ; following:
25652                                                                          ;
25653                                                                          ; (XX16+5 K) = |v_y| * sin(CNT2)
25654                                                                          ; (XX16+5 R) = |v_x| * sin(CNT2)
25655               
25656 B4A6 D360  30        movb @CNT2,ra                   ; LDA CNT2          ; Set X = (CNT2 + 16) mod 32
     B4A8 00A5     
25657                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 B4AA 0A16  18        sla  rzero,1
                   < elite.a99
25658                      .adi (>10*256)                  ; ADC #16           ; So we can use X as a lookup index into the SNE table
     **** ****     > ADI
0001 B4AC 1701  14        jnc  !
0002 B4AE B347  18        ab   rone,ra
0003               !:
0004 B4B0 022D  22        ai   ra,(>10*256)
     B4B2 1000     
                   < elite.a99
25659 B4B4 024D  22        andi ra,>1f*256                 ; AND #31           ; to get the cosine (as there are 16 segments in a
     B4B6 1F00     
25660 B4B8 D38D  18        movb ra,rx                      ; TAX               ; quarter-circle)
25661                                                                          ;
25662                                                                          ; Also, because the sine table only contains positive
25663                                                                          ; values, we know that sin((CNT2 + 16) mod 32) will
25664                                                                          ; always be positive, or to put it another way:
25665                                                                          ;
25666                                                                          ; sin((CNT2 + 16) mod 32) = |cos(CNT2)|
25667               
25668 B4BA D36E  34        movb @SNE(rx),ra                ; LDA SNE,X         ; Set Q = sin(X)
     B4BC 41C6     
25669 B4BE D80D  30        movb ra,@Q                      ; STA Q             ; = sin((CNT2 + 16) mod 32)
     B4C0 0090     
25670                                                                          ; = |cos(CNT2)|
25671               
25672 B4C2 D360  30        movb @K2+1,ra                   ; LDA K2+1          ; Set A = K2+1
     B4C4 00AD     
25673                                                                          ; = |u_y|
25674               
25675 B4C6 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set K+2 = A * Q / 256
     B4C8 43EC     
25676 B4CA 06A0  32        bl   @jsr                       ;
     B4CC FE28     
25677 B4CE D80D  30        movb ra,@K+2                    ; STA K+2           ; = |u_y| * |cos(CNT2)|
     B4D0 003F     
25678               
25679 B4D2 D360  30        movb @K2,ra                     ; LDA K2            ; Set A = K2
     B4D4 00AC     
25680                                                                          ; = |u_x|
25681               
25682 B4D6 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set P = A * Q / 256
     B4D8 43EC     
25683 B4DA 06A0  32        bl   @jsr                       ;
     B4DC FE28     
25684 B4DE D80D  30        movb ra,@P                      ; STA P             ; = |u_x| * |cos(CNT2)|
     B4E0 001B     
25685                                                                          ;
25686                                                                          ; The call to FMLTU also sets the C flag, so in the
25687                                                                          ; following, ADC #15 adds 16 rather than 15
25688               
25689 B4E2 D360  30        movb @CNT2,ra                   ; LDA CNT2          ; If (CNT2 + 16) mod 64 >= 33 then this sets the C flag,
     B4E4 00A5     
25690                      .adi (>0f*256)                  ; ADC #15           ; otherwise it's clear, so this means that:
     **** ****     > ADI
0001 B4E6 1701  14        jnc  !
0002 B4E8 B347  18        ab   rone,ra
0003               !:
0004 B4EA 022D  22        ai   ra,(>0F*256)
     B4EC 0F00     
                   < elite.a99
25691 B4EE 024D  22        andi ra,>3f*256                 ; AND #63           ;
     B4F0 3F00     
25692 B4F2 028D  22        ci   ra,>21*256                 ; CMP #33           ; * C is clear if the segment starts in the first or
     B4F4 2100     
25693                                                                          ; last quarter of the circle, 0 to 90 degrees or 270
25694                                                                          ; to 360 degrees
25695                                                                          ;
25696                                                                          ; * C is set if the segment starts in the second or
25697                                                                          ; third quarter of the circle, 90 to 270 degrees
25698                                                                          ;
25699                                                                          ; In other words, the C flag contains the sign bit for
25700                                                                          ; cos(CNT2), which is positive for 0 to 90 degrees or
25701                                                                          ; 270 to 360 degrees, and negative for 90 to 270 degrees
25702               
25703 B4F6 020D  20        li   ra,>00*256                 ; LDA #0            ; Shift the C flag into the sign bit of XX16+4, so:
     B4F8 0000     
25704 B4FA 06A0  32        bl   @rora                      ; ROR A             ; XX16+4 has the correct sign for cos(CNT2)
     B4FC FE62     
25705 B4FE D80D  30        movb ra,@XX16+4                 ; STA XX16+4        ;
     B500 000D     
25706                                                                          ; Because we set the following above:
25707                                                                          ;
25708                                                                          ; K+2 = |u_y| * |cos(CNT2)|
25709                                                                          ; P   = |u_x| * |cos(CNT2)|
25710                                                                          ;
25711                                                                          ; we can add XX16+4 as the high byte to give us the
25712                                                                          ; following:
25713                                                                          ;
25714                                                                          ; (XX16+4 K+2) = |u_y| * cos(CNT2)
25715                                                                          ; (XX16+4 P)   = |u_x| * cos(CNT2)
25716               
25717 B502 D360  30        movb @XX16+5,ra                 ; LDA XX16+5        ; Set S = the sign of XX16+2 * XX16+5
     B504 000E     
25718                      .eor @XX16+2                    ; EOR XX16+2        ; = the sign of v_x * XX16+5
     **** ****     > EOR
0001 B506 D020  30        movb @XX16+2,rtmp
     B508 000B     
0002 B50A 2B40  18        xor  rtmp,ra
                   < elite.a99
25719 B50C D80D  30        movb ra,@S                      ; STA S             ;
     B50E 0092     
25720                                                                          ; So because we set this above:
25721                                                                          ;
25722                                                                          ; (XX16+5 R) = |v_x| * sin(CNT2)
25723                                                                          ;
25724                                                                          ; we now have this:
25725                                                                          ;
25726                                                                          ; (S R) = v_x * sin(CNT2)
25727               
25728 B510 D360  30        movb @XX16+4,ra                 ; LDA XX16+4        ; Set A = the sign of XX16 * XX16+4
     B512 000D     
25729                      .eor @XX16                      ; EOR XX16          ; = the sign of u_x * XX16+4
     **** ****     > EOR
0001 B514 D020  30        movb @XX16,rtmp
     B516 0009     
0002 B518 2B40  18        xor  rtmp,ra
                   < elite.a99
25730                                                                          ;
25731                                                                          ; So because we set this above:
25732                                                                          ;
25733                                                                          ; (XX16+4 P)   = |u_x| * cos(CNT2)
25734                                                                          ;
25735                                                                          ; we now have this:
25736                                                                          ;
25737                                                                          ; (A P) = u_x * cos(CNT2)
25738               
25739 B51A 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     B51C 456E     
25740 B51E 06A0  32        bl   @jsr                       ;
     B520 FE28     
25741                                                                          ; = u_x * cos(CNT2) + v_x * sin(CNT2)
25742               
25743 B522 D80D  30        movb ra,@T                      ; STA T             ; Store the high byte in T, so the result is now:
     B524 00D1     
25744                                                                          ;
25745                                                                          ; (T X) = u_x * cos(CNT2) + v_x * sin(CNT2)
25746               
25747 B526 1515  14        jgt  PL42                       ; BPL PL42          ; If the result is positive, jump down to PL42
25748               
25749 B528 D34E  18        movb rx,ra                      ; TXA               ; The result is negative, so we need to negate the
25750                      .eoi (>ff*256)                  ; EOR #%11111111    ; magnitude using two's complement, first doing the low
     **** ****     > EOI
0001 B52A 0200  20        li   rtmp,(>FF*256)
     B52C FF00     
0002 B52E 2B40  18        xor  rtmp,ra
                   < elite.a99
25751                      .clc                            ; CLC               ; byte in X
     **** ****     > CLC
0001 B530 0A16  18        sla  rzero,1
                   < elite.a99
25752                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 B532 1701  14        jnc  !
0002 B534 B347  18        ab   rone,ra
0003               !:
0004 B536 022D  22        ai   ra,(>01*256)
     B538 0100     
                   < elite.a99
25753 B53A D38D  18        movb ra,rx                      ; TAX
25754               
25755 B53C D360  30        movb @T,ra                      ; LDA T             ; And then the high byte in T, making sure to leave the
     B53E 00D1     
25756                      .eoi (>7f*256)                  ; EOR #%01111111    ; sign bit alone
     **** ****     > EOI
0001 B540 0200  20        li   rtmp,(>7F*256)
     B542 7F00     
0002 B544 2B40  18        xor  rtmp,ra
                   < elite.a99
25757                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 B546 1701  14        jnc  !
0002 B548 B347  18        ab   rone,ra
0003               !:
0004 B54A 022D  22        ai   ra,(>00*256)
     B54C 0000     
                   < elite.a99
25758 B54E D80D  30        movb ra,@T                      ; STA T
     B550 00D1     
25759               
25760               PL42:
25761 B552 D34E  18        movb rx,ra                      ; TXA               ; Set K6(1 0) = K3(1 0) + (T X)
25762                      .adc @K3,ra                     ; ADC K3            ;
     **** ****     > ADC
0001 B554 1701  14        jnc  !
0002 B556 B347  18        ab   rone,ra
0003               !:
0004 B558 B360  30        ab   @K3,ra
     B55A 00D2     
                   < elite.a99
25763 B55C D80D  30        movb ra,@K6                     ; STA K6            ; starting with the low bytes
     B55E 0082     
25764               
25765 B560 D360  30        movb @T,ra                      ; LDA T             ; And then doing the high bytes, so we now get:
     B562 00D1     
25766                      .adc @K3+1,ra                   ; ADC K3+1          ;
     **** ****     > ADC
0001 B564 1701  14        jnc  !
0002 B566 B347  18        ab   rone,ra
0003               !:
0004 B568 B360  30        ab   @K3+1,ra
     B56A 00D3     
                   < elite.a99
25767 B56C D80D  30        movb ra,@K6+1                   ; STA K6+1          ; K6(1 0) = K3(1 0) + (T X)
     B56E 0083     
25768                                                                          ; = K3(1 0) + u_x * cos(CNT2)
25769                                                                          ; + v_x * sin(CNT2)
25770                                                                          ;
25771                                                                          ; K3(1 0) is the x-coordinate of the centre of the
25772                                                                          ; ellipse, so we now have the correct x-coordinate for
25773                                                                          ; our ellipse segment that we can pass to BLINE below
25774               
25775 B570 D360  30        movb @K,ra                      ; LDA K             ; Set R = K = |v_y| * sin(CNT2)
     B572 003D     
25776 B574 D80D  30        movb ra,@R                      ; STA R
     B576 0091     
25777               
25778 B578 D360  30        movb @XX16+5,ra                 ; LDA XX16+5        ; Set S = the sign of XX16+3 * XX16+5
     B57A 000E     
25779                      .eor @XX16+3                    ; EOR XX16+3        ; = the sign of v_y * XX16+5
     **** ****     > EOR
0001 B57C D020  30        movb @XX16+3,rtmp
     B57E 000C     
0002 B580 2B40  18        xor  rtmp,ra
                   < elite.a99
25780 B582 D80D  30        movb ra,@S                      ; STA S             ;
     B584 0092     
25781                                                                          ; So because we set this above:
25782                                                                          ;
25783                                                                          ; (XX16+5 K) = |v_y| * sin(CNT2)
25784                                                                          ;
25785                                                                          ; and we just set R = K, we now have this:
25786                                                                          ;
25787                                                                          ; (S R) = v_y * sin(CNT2)
25788               
25789 B586 D360  30        movb @K+2,ra                    ; LDA K+2           ; Set P = K+2 = |u_y| * cos(CNT2)
     B588 003F     
25790 B58A D80D  30        movb ra,@P                      ; STA P
     B58C 001B     
25791               
25792 B58E D360  30        movb @XX16+4,ra                 ; LDA XX16+4        ; Set A = the sign of XX16+1 * XX16+4
     B590 000D     
25793                      .eor @XX16+1                    ; EOR XX16+1        ; = the sign of u_y * XX16+4
     **** ****     > EOR
0001 B592 D020  30        movb @XX16+1,rtmp
     B594 000A     
0002 B596 2B40  18        xor  rtmp,ra
                   < elite.a99
25794                                                                          ;
25795                                                                          ; So because we set this above:
25796                                                                          ;
25797                                                                          ; (XX16+4 K+2) = |u_y| * cos(CNT2)
25798                                                                          ;
25799                                                                          ; and we just set P = K+2, we now have this:
25800                                                                          ;
25801                                                                          ; (A P) = u_y * cos(CNT2)
25802               
25803 B598 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     B59A 456E     
25804 B59C 06A0  32        bl   @jsr                       ;
     B59E FE28     
25805                                                                          ; =  u_y * cos(CNT2) + v_y * sin(CNT2)
25806               
25807                      .eoi (>80*256)                  ; EOR #%10000000    ; Store the negated high byte in T, so the result is
     **** ****     > EOI
0001 B5A0 0200  20        li   rtmp,(>80*256)
     B5A2 8000     
0002 B5A4 2B40  18        xor  rtmp,ra
                   < elite.a99
25808 B5A6 D80D  30        movb ra,@T                      ; STA T             ; now:
     B5A8 00D1     
25809                                                                          ;
25810                                                                          ; (T X) = - u_y * cos(CNT2) - v_y * sin(CNT2)
25811                                                                          ;
25812                                                                          ; This negation is necessary because BLINE expects us
25813                                                                          ; to pass pixel coordinates, where y-coordinates get
25814                                                                          ; larger as we go down the screen; u_y and v_y, on the
25815                                                                          ; other hand, are extracted from the orientation
25816                                                                          ; vectors, where y-coordinates get larger as we go up
25817                                                                          ; in space, so to rectify this we need to negate the
25818                                                                          ; result in (T X) before we can add it to the
25819                                                                          ; y-coordinate of the ellipse's centre in BLINE
25820               
25821 B5AA 1515  14        jgt  PL43                       ; BPL PL43          ; If the result is positive, jump down to PL43
25822               
25823 B5AC D34E  18        movb rx,ra                      ; TXA               ; The result is negative, so we need to negate the
25824                      .eoi (>ff*256)                  ; EOR #%11111111    ; magnitude using two's complement, first doing the low
     **** ****     > EOI
0001 B5AE 0200  20        li   rtmp,(>FF*256)
     B5B0 FF00     
0002 B5B2 2B40  18        xor  rtmp,ra
                   < elite.a99
25825                      .clc                            ; CLC               ; byte in X
     **** ****     > CLC
0001 B5B4 0A16  18        sla  rzero,1
                   < elite.a99
25826                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 B5B6 1701  14        jnc  !
0002 B5B8 B347  18        ab   rone,ra
0003               !:
0004 B5BA 022D  22        ai   ra,(>01*256)
     B5BC 0100     
                   < elite.a99
25827 B5BE D38D  18        movb ra,rx                      ; TAX
25828               
25829 B5C0 D360  30        movb @T,ra                      ; LDA T             ; And then the high byte in T, making sure to leave the
     B5C2 00D1     
25830                      .eoi (>7f*256)                  ; EOR #%01111111    ; sign bit alone
     **** ****     > EOI
0001 B5C4 0200  20        li   rtmp,(>7F*256)
     B5C6 7F00     
0002 B5C8 2B40  18        xor  rtmp,ra
                   < elite.a99
25831                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 B5CA 1701  14        jnc  !
0002 B5CC B347  18        ab   rone,ra
0003               !:
0004 B5CE 022D  22        ai   ra,(>00*256)
     B5D0 0000     
                   < elite.a99
25832 B5D2 D80D  30        movb ra,@T                      ; STA T
     B5D4 00D1     
25833               
25834               PL43:
25835                                                                          ; We now call BLINE to draw the ellipse line segment
25836                                                                          ;
25837                                                                          ; The first few instructions of BLINE do the following:
25838                                                                          ;
25839                                                                          ; K6(3 2) = K4(1 0) + (T X)
25840                                                                          ;
25841                                                                          ; which gives:
25842                                                                          ;
25843                                                                          ; K6(3 2) = K4(1 0) - u_y * cos(CNT2)
25844                                                                          ; - v_y * sin(CNT2)
25845                                                                          ;
25846                                                                          ; K4(1 0) is the pixel y-coordinate of the centre of the
25847                                                                          ; ellipse, so this gives us the correct y-coordinate for
25848                                                                          ; our ellipse segment (we already calculated the
25849                                                                          ; x-coordinate in K3(1 0) above)
25850 B5D6 0200  20        li   rtmp,BLINE                 ; JSR BLINE         ; Call BLINE to draw this segment, which also returns
     B5D8 288E     
25851 B5DA 06A0  32        bl   @jsr                       ;
     B5DC FE28     
25852                                                                          ; the updated value of CNT in A
25853               
25854 B5DE 9360  30        cb   @TGT,ra                    ; CMP TGT           ; If CNT > TGT then jump to PL40 to stop drawing the
     B5E0 00A0     
25855 B5E2 1301  14        jeq  B77                        ; BEQ B77           ; ellipse (which is how we draw half-ellipses)
25856 B5E4 180D  14        joc  PL40                       ; BCS PL40
25857               
25858               B77:
25859 B5E6 D360  30        movb @CNT2,ra                   ; LDA CNT2          ; Set CNT2 = (CNT2 + STP) mod 64
     B5E8 00A5     
25860                      .clc                            ; CLC
     **** ****     > CLC
0001 B5EA 0A16  18        sla  rzero,1
                   < elite.a99
25861                      .adc @STP,ra                    ; ADC STP
     **** ****     > ADC
0001 B5EC 1701  14        jnc  !
0002 B5EE B347  18        ab   rone,ra
0003               !:
0004 B5F0 B360  30        ab   @STP,ra
     B5F2 00A6     
                   < elite.a99
25862 B5F4 024D  22        andi ra,>3f*256                 ; AND #63
     B5F6 3F00     
25863 B5F8 D80D  30        movb ra,@CNT2                   ; STA CNT2
     B5FA 00A5     
25864               
25865 B5FC 0460  28        b    @PLL4                      ; JMP PLL4          ; Jump back to PLL4 to draw the next segment
     B5FE B460     
25866               
25867               PL40:
25868 B600 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B602 FE34     
25869               
25870               * ******************************************************************************
25871               *
25872               * Name: SUN (Part 1 of 4)
25873               * Type: Subroutine
25874               * Category: Drawing suns
25875               * Summary: Draw the sun: Set up all the variables needed to draw the sun
25876               * Deep dive: Drawing the sun
25877               *
25878               * ------------------------------------------------------------------------------
25879               *
25880               * Draw a new sun with radius K at pixel coordinate (K3, K4), removing the old
25881               * sun if there is one. This routine is used to draw the sun, as well as the
25882               * star systems on the Short-range Chart.
25883               *
25884               * The first part sets up all the variables needed to draw the new sun.
25885               *
25886               * ------------------------------------------------------------------------------
25887               *
25888               * Arguments:
25889               *
25890               * K                   The new sun's radius
25891               *
25892               * K3(1 0)             Pixel x-coordinate of the centre of the new sun
25893               *
25894               * K4(1 0)             Pixel y-coordinate of the centre of the new sun
25895               *
25896               * SUNX(1 0)           The x-coordinate of the vertical centre axis of the old
25897               * sun (the one currently on-screen)
25898               *
25899               * ******************************************************************************
25900               
25901 B604 0460  28        b    @WPLS                      ; JMP WPLS          ; Jump to WPLS to remove the old sun from the screen. We
     B606 B9DC     
25902                                                                          ; only get here via the BCS just after the SUN entry
25903                                                                          ; point below, when there is no new sun to draw
25904               
25905               PLF3:
25906                                                                          ; This is called from below to negate X and set A to
25907                                                                          ; &FF, for when the new sun's centre is off the bottom
25908                                                                          ; of the screen (so we don't need to draw its bottom
25909                                                                          ; half)
25910                                                                          ;
25911                                                                          ; This happens when the y-coordinate of the centre of
25912                                                                          ; the sun is bigger than the y-coordinate of the bottom
25913                                                                          ; of the space view
25914 B608 D34E  18        movb rx,ra                      ; TXA               ; Negate X using two's complement, so X = ~X + 1
25915                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 B60A 0200  20        li   rtmp,(>FF*256)
     B60C FF00     
0002 B60E 2B40  18        xor  rtmp,ra
                   < elite.a99
25916                      .clc                            ; CLC
     **** ****     > CLC
0001 B610 0A16  18        sla  rzero,1
                   < elite.a99
25917                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 B612 1701  14        jnc  !
0002 B614 B347  18        ab   rone,ra
0003               !:
0004 B616 022D  22        ai   ra,(>01*256)
     B618 0100     
                   < elite.a99
25918 B61A D38D  18        movb ra,rx                      ; TAX
25919               
25920               PLF17:
25921                                                                          ; This is called from below to set A to &FF, for when
25922                                                                          ; the new sun's centre is right on the bottom of the
25923                                                                          ; screen (so we don't need to draw its bottom half)
25924 B61C 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A = &FF
     B61E FF00     
25925               
25926 B620 0460  28        b    @PLF5                      ; JMP PLF5          ; Jump to PLF5
     B622 B6AC     
25927               
25928               SUN:
25929 B624 020D  20        li   ra,>01*256                 ; LDA #1            ; Set LSX = 1 to indicate the sun line heap is about to
     B626 0100     
25930 B628 D80D  30        movb ra,@LSX                    ; STA LSX           ; be filled up
     B62A 0D66     
25931               
25932 B62C 0200  20        li   rtmp,CHKON                 ; JSR CHKON         ; Call CHKON to check whether any part of the new sun's
     B62E BA80     
25933 B630 06A0  32        bl   @jsr                       ;
     B632 FE28     
25934                                                                          ; circle appears on-screen, and if it does, set P(2 1)
25935                                                                          ; to the maximum y-coordinate of the new sun on-screen
25936               
25937 B634 18E7  14        joc  PLF3-3                     ; BCS PLF3-3        ; If CHKON set the C flag then the new sun's circle does
25938                                                                          ; not appear on-screen, so jump to WPLS (via the JMP at
25939                                                                          ; the top of this routine) to remove the sun from the
25940                                                                          ; screen, returning from the subroutine using a tail
25941                                                                          ; call
25942               
25943 B636 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     B638 0000     
25944               
25945 B63A D3A0  30        movb @K,rx                      ; LDX K             ; Set X = K = radius of the new sun
     B63C 003D     
25946               
25947 B63E 028E  22        ci   rx,>60*256                 ; CPX #96           ; If X >= 96, set the C flag and rotate it into bit 0
     B640 6000     
25948 B642 06A0  32        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     B644 FE3E     
25949               
25950 B646 028E  22        ci   rx,>28*256                 ; CPX #40           ; If X >= 40, set the C flag and rotate it into bit 0
     B648 2800     
25951 B64A 06A0  32        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     B64C FE3E     
25952               
25953 B64E 028E  22        ci   rx,>10*256                 ; CPX #16           ; If X >= 16, set the C flag and rotate it into bit 0
     B650 1000     
25954 B652 06A0  32        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     B654 FE3E     
25955               
25956                                                                          ; By now, A contains the following:
25957                                                                          ;
25958                                                                          ; * If radius is 96-255 then A = %111 = 7
25959                                                                          ;
25960                                                                          ; * If radius is 40-95  then A = %11  = 3
25961                                                                          ;
25962                                                                          ; * If radius is 16-39  then A = %1   = 1
25963                                                                          ;
25964                                                                          ; * If radius is 0-15   then A = %0   = 0
25965                                                                          ;
25966                                                                          ; The value of A determines the size of the new sun's
25967                                                                          ; ragged fringes - the bigger the sun, the bigger the
25968                                                                          ; fringes
25969               
25970               PLF18:
25971 B656 D80D  30        movb ra,@CNT                    ; STA CNT           ; Store the fringe size in CNT
     B658 00A4     
25972               
25973                                                                          ; We now calculate the highest pixel y-coordinate of the
25974                                                                          ; new sun, given that P(2 1) contains the 16-bit maximum
25975                                                                          ; y-coordinate of the new sun on-screen
25976               
25977 B65A 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     B65C BF00     
25978                                                                          ; view, so this sets Y to the y-coordinate of the bottom
25979                                                                          ; of the space view
25980               
25981 B65E D3A0  30        movb @P+2,rx                    ; LDX P+2           ; If P+2 is non-zero, the maximum y-coordinate is off
     B660 001D     
25982 B662 1608  14        jne  PLF2                       ; BNE PLF2          ; the bottom of the screen, so skip to PLF2 with A set
25983                                                                          ; to the y-coordinate of the bottom of the space view
25984               
25985 B664 9360  30        cb   @P+1,ra                    ; CMP P+1           ; If A < P+1, the maximum y-coordinate is underneath the
     B666 001C     
25986 B668 1705  14        jnc  PLF2                       ; BCC PLF2          ; dashboard, so skip to PLF2 with A set to the
25987                                                                          ; y-coordinate of the bottom of the space view
25988               
25989 B66A D360  30        movb @P+1,ra                    ; LDA P+1           ; Set A = P+1, the low byte of the maximum y-coordinate
     B66C 001C     
25990                                                                          ; of the sun on-screen
25991               
25992 B66E 1602  14        jne  PLF2                       ; BNE PLF2          ; If A is non-zero, skip to PLF2 as it contains the
25993                                                                          ; value we are after
25994               
25995 B670 020D  20        li   ra,>01*256                 ; LDA #1            ; Otherwise set A = 1, the top line of the screen
     B672 0100     
25996               
25997               PLF2:
25998 B674 D80D  30        movb ra,@TGT                    ; STA TGT           ; Set TGT to A, the maximum y-coordinate of the sun on
     B676 00A0     
25999                                                                          ; screen
26000               
26001                                                                          ; We now calculate the number of lines we need to draw
26002                                                                          ; and the direction in which we need to draw them, both
26003                                                                          ; from the centre of the new sun
26004               
26005 B678 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set (A X) = y-coordinate of bottom of screen - K4(1 0)
     B67A BF00     
26006                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 B67C 0A18  18        sla  rmone,1
                   < elite.a99
26007                      .sbc @K4,ra                     ; SBC K4            ; Starting with the low bytes
     **** ****     > SBC
0001 B67E 1801  14        joc  !
0002 B680 7347  18        sb   rone,ra
0003               !:
0004 B682 7360  30        sb   @K4,ra
     B684 00E0     
                   < elite.a99
26008 B686 D38D  18        movb ra,rx                      ; TAX
26009               
26010 B688 020D  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so (A X) now contains
     B68A 0000     
26011                      .sbc @K4+1,ra                   ; SBC K4+1          ; the number of lines between the centre of the sun and
     **** ****     > SBC
0001 B68C 1801  14        joc  !
0002 B68E 7347  18        sb   rone,ra
0003               !:
0004 B690 7360  30        sb   @K4+1,ra
     B692 00E1     
                   < elite.a99
26012                                                                          ; the bottom of the screen. If it is positive then the
26013                                                                          ; centre of the sun is above the bottom of the screen,
26014                                                                          ; if it is negative then the centre of the sun is below
26015                                                                          ; the bottom of the screen
26016               
26017 B694 11B9  14        jlt  PLF3                       ; BMI PLF3          ; If A < 0, then this means the new sun's centre is off
26018                                                                          ; the bottom of the screen, so jump up to PLF3 to negate
26019                                                                          ; the height in X (so it becomes positive), set A to &FF
26020                                                                          ; and jump down to PLF5
26021               
26022 B696 1606  14        jne  PLF4                       ; BNE PLF4          ; If A > 0, then the new sun's centre is at least a full
26023                                                                          ; screen above the bottom of the space view, so jump
26024                                                                          ; down to PLF4 to set X = radius and A = 0
26025               
26026 B698 B387  18        ab   rone,rx                    ; INX               ; Set the flags depending on the value of X
26027 B69A 7387  18        sb   rone,rx                    ; DEX
26028               
26029 B69C 13BF  14        jeq  PLF17                      ; BEQ PLF17         ; If X = 0 (we already know A = 0 by this point) then
26030                                                                          ; jump up to PLF17 to set A to &FF before jumping down
26031                                                                          ; to PLF5
26032               
26033 B69E 93A0  30        cb   @K,rx                      ; CPX K             ; If X < the radius in K, jump down to PLF5, so if
     B6A0 003D     
26034 B6A2 1704  14        jnc  PLF5                       ; BCC PLF5          ; X >= the radius in K, we set X = radius and A = 0
26035               
26036               PLF4:
26037 B6A4 D3A0  30        movb @K,rx                      ; LDX K             ; Set X to the radius
     B6A6 003D     
26038               
26039 B6A8 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     B6AA 0000     
26040               
26041               PLF5:
26042 B6AC D80E  30        movb rx,@V                      ; STX V             ; Store the height in V
     B6AE 0022     
26043               
26044 B6B0 D80D  30        movb ra,@V+1                    ; STA V+1           ; Store the direction in V+1
     B6B2 0023     
26045               
26046 B6B4 D360  30        movb @K,ra                      ; LDA K             ; Set (A P) = K * K
     B6B6 003D     
26047 B6B8 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2
     B6BA 436E     
26048 B6BC 06A0  32        bl   @jsr                       ;
     B6BE FE28     
26049               
26050 B6C0 D80D  30        movb ra,@K2+1                   ; STA K2+1          ; Set K2(1 0) = (A P) = K * K
     B6C2 00AD     
26051 B6C4 D360  30        movb @P,ra                      ; LDA P
     B6C6 001B     
26052 B6C8 D80D  30        movb ra,@K2                     ; STA K2
     B6CA 00AC     
26053               
26054                                                                          ; By the time we get here, the variables should be set
26055                                                                          ; up as shown in the header for part 3 below
26056               
26057               * ******************************************************************************
26058               *
26059               * Name: SUN (Part 2 of 4)
26060               * Type: Subroutine
26061               * Category: Drawing suns
26062               * Summary: Draw the sun: Start from the bottom of the screen and erase the
26063               * old sun line by line
26064               * Deep dive: Drawing the sun
26065               *
26066               * ------------------------------------------------------------------------------
26067               *
26068               * This part erases the old sun, starting at the bottom of the screen and working
26069               * upwards until we reach the bottom of the new sun.
26070               *
26071               * ******************************************************************************
26072               
26073 B6CC 020F  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; Set Y = y-coordinate of the bottom of the screen,
     B6CE BF00     
26074                                                                          ; which we use as a counter in the following routine to
26075                                                                          ; redraw the old sun
26076               
26077 B6D0 D360  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     B6D2 0028     
26078 B6D4 D80D  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     B6D6 0026     
26079 B6D8 D360  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     B6DA 0029     
26080 B6DC D80D  30        movb ra,@YY+1                   ; STA YY+1
     B6DE 0027     
26081               
26082               PLFL2:
26083 B6E0 93E0  30        cb   @TGT,ry                    ; CPY TGT           ; If Y = TGT, we have reached the line where we will
     B6E2 00A0     
26084 B6E4 1309  14        jeq  PLFL                       ; BEQ PLFL          ; start drawing the new sun, so there is no need to
26085                                                                          ; keep erasing the old one, so jump down to PLFL
26086               
26087 B6E6 D36F  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     B6E8 0D66     
26088                                                                          ; gives us the half-width of the old sun's line on this
26089                                                                          ; line of the screen
26090               
26091 B6EA 1304  14        jeq  PLF13                      ; BEQ PLF13         ; If A = 0, skip the following call to HLOIN2 as there
26092                                                                          ; is no sun line on this line of the screen
26093               
26094 B6EC 0200  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     B6EE 260E     
26095 B6F0 06A0  32        bl   @jsr                       ;
     B6F2 FE28     
26096                                                                          ; with centre point YY(1 0) and half-width A, and remove
26097                                                                          ; the line from the sun line heap once done
26098               
26099               PLF13:
26100 B6F4 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
26101               
26102 B6F6 16F4  14        jne  PLFL2                      ; BNE PLFL2         ; Loop back for the next line in the line heap until
26103                                                                          ; we have either gone through the entire heap, or
26104                                                                          ; reached the bottom row of the new sun
26105               
26106               * ******************************************************************************
26107               *
26108               * Name: SUN (Part 3 of 4)
26109               * Type: Subroutine
26110               * Category: Drawing suns
26111               * Summary: Draw the sun: Continue to move up the screen, drawing the new sun
26112               * line by line
26113               * Deep dive: Drawing the sun
26114               *
26115               * ------------------------------------------------------------------------------
26116               *
26117               * This part draws the new sun. By the time we get to this point, the following
26118               * variables should have been set up by parts 1 and 2:
26119               *
26120               * ------------------------------------------------------------------------------
26121               *
26122               * Arguments:
26123               *
26124               * V                   As we draw lines for the new sun, V contains the
26125               * vertical distance between the line we're drawing and the
26126               * centre of the new sun. As we draw lines and move up the
26127               * screen, we either decrement (bottom half) or increment
26128               * (top half) this value. See the deep dive on "Drawing the
26129               * sun" to see a diagram that shows V in action
26130               *
26131               * V+1                 This determines which half of the new sun we are drawing
26132               * as we work our way up the screen, line by line:
26133               *
26134               * * 0 means we are drawing the bottom half, so the lines
26135               * get wider as we work our way up towards the centre,
26136               * at which point we will move into the top half, and
26137               * V+1 will switch to &FF
26138               *
26139               * * &FF means we are drawing the top half, so the lines
26140               * get smaller as we work our way up, away from the
26141               * centre
26142               *
26143               * TGT                 The maximum y-coordinate of the new sun on-screen (i.e.
26144               * the screen y-coordinate of the bottom row of the new
26145               * sun)
26146               *
26147               * CNT                 The fringe size of the new sun
26148               *
26149               * K2(1 0)             The new sun's radius squared, i.e. K^2
26150               *
26151               * Y                   The y-coordinate of the bottom row of the new sun
26152               *
26153               * ******************************************************************************
26154               
26155               PLFL:
26156 B6F8 D360  30        movb @V,ra                      ; LDA V             ; Set (T P) = V * V
     B6FA 0022     
26157 B6FC 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; = V^2
     B6FE 436E     
26158 B700 06A0  32        bl   @jsr                       ;
     B702 FE28     
26159 B704 D80D  30        movb ra,@T                      ; STA T
     B706 00D1     
26160               
26161 B708 D360  30        movb @K2,ra                     ; LDA K2            ; Set (R Q) = K^2 - V^2
     B70A 00AC     
26162                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 B70C 0A18  18        sla  rmone,1
                   < elite.a99
26163                      .sbc @P,ra                      ; SBC P             ; First calculating the low bytes
     **** ****     > SBC
0001 B70E 1801  14        joc  !
0002 B710 7347  18        sb   rone,ra
0003               !:
0004 B712 7360  30        sb   @P,ra
     B714 001B     
                   < elite.a99
26164 B716 D80D  30        movb ra,@Q                      ; STA Q
     B718 0090     
26165               
26166 B71A D360  30        movb @K2+1,ra                   ; LDA K2+1          ; And then doing the high bytes
     B71C 00AD     
26167                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 B71E 1801  14        joc  !
0002 B720 7347  18        sb   rone,ra
0003               !:
0004 B722 7360  30        sb   @T,ra
     B724 00D1     
                   < elite.a99
26168 B726 D80D  30        movb ra,@R                      ; STA R
     B728 0091     
26169               
26170 B72A D80F  30        movb ry,@Y1                     ; STY Y1            ; Store Y in Y1, so we can restore it after the call to
     B72C 0032     
26171                                                                          ; LL5
26172               
26173 B72E 0200  20        li   rtmp,LL5                   ; JSR LL5           ; Set Q = SQRT(R Q)
     B730 D376     
26174 B732 06A0  32        bl   @jsr                       ;
     B734 FE28     
26175                                                                          ; = SQRT(K^2 - V^2)
26176                                                                          ;
26177                                                                          ; So Q contains the half-width of the new sun's line at
26178                                                                          ; height V from the sun's centre - in other words, it
26179                                                                          ; contains the half-width of the sun's line on the
26180                                                                          ; current pixel row Y
26181               
26182 B736 D3E0  30        movb @Y1,ry                     ; LDY Y1            ; Restore Y from Y1
     B738 0032     
26183               
26184 B73A 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     B73C C120     
26185 B73E 06A0  32        bl   @jsr                       ;
     B740 FE28     
26186               
26187                      .and @CNT                       ; AND CNT           ; Reduce A to a random number in the range 0 to CNT,
     **** ****     > AND
0001 B742 D020  30        movb @CNT,rtmp
     B744 00A4     
0002 B746 0540  14        inv  rtmp
0003 B748 5340  18        szcb rtmp,ra
                   < elite.a99
26188                                                                          ; where CNT is the fringe size of the new sun
26189               
26190                      .clc                            ; CLC               ; Set A = A + Q
     **** ****     > CLC
0001 B74A 0A16  18        sla  rzero,1
                   < elite.a99
26191                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 B74C 1701  14        jnc  !
0002 B74E B347  18        ab   rone,ra
0003               !:
0004 B750 B360  30        ab   @Q,ra
     B752 0090     
                   < elite.a99
26192                                                                          ; So A now contains the half-width of the sun on row
26193                                                                          ; V, plus a random variation based on the fringe size
26194               
26195 B754 1702  14        jnc  PLF44                      ; BCC PLF44         ; If the above addition did not overflow, skip the
26196                                                                          ; following instruction
26197               
26198 B756 020D  20        li   ra,>ff*256                 ; LDA #255          ; The above overflowed, so set the value of A to 255
     B758 FF00     
26199               
26200                                                                          ; So A contains the half-width of the new sun on pixel
26201                                                                          ; line Y, changed by a random amount within the size of
26202                                                                          ; the sun's fringe
26203               
26204               PLF44:
26205 B75A D3AF  34        movb @LSO(ry),rx                ; LDX LSO,Y         ; Set X to the line heap value for the old sun's line
     B75C 0D66     
26206                                                                          ; at row Y
26207               
26208 B75E DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; Store the half-width of the new row Y line in the line
     B760 0D66     
26209                                                                          ; heap
26210               
26211 B762 1346  14        jeq  PLF11                      ; BEQ PLF11         ; If X = 0 then there was no sun line on pixel row Y, so
26212                                                                          ; jump to PLF11
26213               
26214 B764 D360  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     B766 0028     
26215 B768 D80D  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     B76A 0026     
26216 B76C D360  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     B76E 0029     
26217 B770 D80D  30        movb ra,@YY+1                   ; STA YY+1
     B772 0027     
26218               
26219 B774 D34E  18        movb rx,ra                      ; TXA               ; Transfer the line heap value for the old sun's line
26220                                                                          ; from X into A
26221               
26222 B776 0200  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     B778 BA12     
26223 B77A 06A0  32        bl   @jsr                       ;
     B77C FE28     
26224                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26225                                                                          ; the line for the old sun
26226               
26227 B77E D360  30        movb @X1,ra                     ; LDA X1            ; Store X1 and X2, the ends of the line for the old sun,
     B780 0031     
26228 B782 D80D  30        movb ra,@XX                     ; STA XX            ; in XX and XX+1
     B784 0024     
26229 B786 D360  30        movb @X2,ra                     ; LDA X2
     B788 0033     
26230 B78A D80D  30        movb ra,@XX+1                   ; STA XX+1
     B78C 0025     
26231               
26232 B78E D360  30        movb @K3,ra                     ; LDA K3            ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
     B790 00D2     
26233 B792 D80D  30        movb ra,@YY                     ; STA YY            ; of the new sun
     B794 0026     
26234 B796 D360  30        movb @K3+1,ra                   ; LDA K3+1
     B798 00D3     
26235 B79A D80D  30        movb ra,@YY+1                   ; STA YY+1
     B79C 0027     
26236               
26237 B79E D36F  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the half-width of the new row Y line from the
     B7A0 0D66     
26238                                                                          ; line heap (which we stored above)
26239               
26240 B7A2 0200  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     B7A4 BA12     
26241 B7A6 06A0  32        bl   @jsr                       ;
     B7A8 FE28     
26242                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26243                                                                          ; the line for the new sun
26244               
26245 B7AA 180C  14        joc  PLF23                      ; BCS PLF23         ; If the C flag is set, the new line doesn't fit on the
26246                                                                          ; screen, so jump to PLF23 to just draw the old line
26247                                                                          ; without drawing the new one
26248               
26249                                                                          ; At this point the old line is from XX to XX+1 and the
26250                                                                          ; new line is from X1 to X2, and both fit on-screen. We
26251                                                                          ; now want to remove the old line and draw the new one.
26252                                                                          ; We could do this by simply drawing the old one then
26253                                                                          ; drawing the new one, but instead Elite does this by
26254                                                                          ; drawing first from X1 to XX and then from X2 to XX+1,
26255                                                                          ; which you can see in action by looking at all the
26256                                                                          ; permutations below of the four points on the line and
26257                                                                          ; imagining what happens if you draw from X1 to XX and
26258                                                                          ; X2 to XX+1 using EOR logic. The six possible
26259                                                                          ; permutations are as follows, along with the result of
26260                                                                          ; drawing X1 to XX and then X2 to XX+1:
26261                                                                          ;
26262                                                                          ; X1    X2    XX____XX+1      ->      +__+  +  +
26263                                                                          ;
26264                                                                          ; X1    XX____X2____XX+1      ->      +__+__+  +
26265                                                                          ;
26266                                                                          ; X1    XX____XX+1  X2        ->      +__+__+__+
26267                                                                          ;
26268                                                                          ; XX____X1____XX+1  X2        ->      +  +__+__+
26269                                                                          ;
26270                                                                          ; XX____XX+1  X1    X2        ->      +  +  +__+
26271                                                                          ;
26272                                                                          ; XX____X1____X2____XX+1      ->      +  +__+  +
26273                                                                          ;
26274                                                                          ; They all end up with a line between X1 and X2, which
26275                                                                          ; is what we want. There's probably a mathematical proof
26276                                                                          ; of why this works somewhere, but the above is probably
26277                                                                          ; easier to follow.
26278                                                                          ;
26279                                                                          ; We can draw from X1 to XX and X2 to XX+1 by swapping
26280                                                                          ; XX and X2 and drawing from X1 to X2, and then drawing
26281                                                                          ; from XX to XX+1, so let's do this now
26282               
26283 B7AC D360  30        movb @X2,ra                     ; LDA X2            ; Swap XX and X2
     B7AE 0033     
26284 B7B0 D3A0  30        movb @XX,rx                     ; LDX XX
     B7B2 0024     
26285 B7B4 D80E  30        movb rx,@X2                     ; STX X2
     B7B6 0033     
26286 B7B8 D80D  30        movb ra,@XX                     ; STA XX
     B7BA 0024     
26287               
26288 B7BC 0200  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1)
     B7BE 2622     
26289 B7C0 06A0  32        bl   @jsr                       ;
     B7C2 FE28     
26290               
26291               PLF23:
26292                                                                          ; If we jump here from the BCS above when there is no
26293                                                                          ; new line this will just draw the old line
26294 B7C4 D360  30        movb @XX,ra                     ; LDA XX            ; Set X1 = XX
     B7C6 0024     
26295 B7C8 D80D  30        movb ra,@X1                     ; STA X1
     B7CA 0031     
26296               
26297 B7CC D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X2 = XX+1
     B7CE 0025     
26298 B7D0 D80D  30        movb ra,@X2                     ; STA X2
     B7D2 0033     
26299               
26300               PLF16:
26301 B7D4 0200  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1)
     B7D6 2622     
26302 B7D8 06A0  32        bl   @jsr                       ;
     B7DA FE28     
26303               
26304               PLF6:
26305 B7DC 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the line number in Y to move to the line
26306                                                                          ; above
26307               
26308 B7DE 1334  14        jeq  PLF8                       ; BEQ PLF8          ; If we have reached the top of the screen, jump to PLF8
26309                                                                          ; as we are done drawing (the top line of the screen is
26310                                                                          ; the border, so we don't draw there)
26311               
26312 B7E0 D360  30        movb @V+1,ra                    ; LDA V+1           ; If V+1 is non-zero then we are doing the top half of
     B7E2 0023     
26313 B7E4 1617  14        jne  PLF10                      ; BNE PLF10         ; the new sun, so jump down to PLF10 to increment V and
26314                                                                          ; decrease the width of the line we draw
26315               
26316 B7E6 7347  18        sb   rone,ra                    ; DEC V             ; Decrement V, the height of the sun that we use to work
26317                                                                          ; out the width, so this makes the line get wider, as we
26318                                                                          ; move up towards the sun's centre
26319               
26320 B7E8 1687  14        jne  PLFL                       ; BNE PLFL          ; If V is non-zero, jump back up to PLFL to do the next
26321                                                                          ; screen line up
26322               
26323 B7EA 7347  18        sb   rone,ra                    ; DEC V+1           ; Otherwise V is 0 and we have reached the centre of the
26324                                                                          ; sun, so decrement V+1 to -1 so we start incrementing V
26325                                                                          ; each time, thus doing the top half of the new sun
26326               
26327               PLFLS:
26328 B7EC 0460  28        b    @PLFL                      ; JMP PLFL          ; Jump back up to PLFL to do the next screen line up
     B7EE B6F8     
26329               
26330               PLF11:
26331                                                                          ; If we get here then there is no old sun line on this
26332                                                                          ; line, so we can just draw the new sun's line
26333 B7F0 D3A0  30        movb @K3,rx                     ; LDX K3            ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
     B7F2 00D2     
26334 B7F4 D80E  30        movb rx,@YY                     ; STX YY            ; of the new sun's line
     B7F6 0026     
26335 B7F8 D3A0  30        movb @K3+1,rx                   ; LDX K3+1
     B7FA 00D3     
26336 B7FC D80E  30        movb rx,@YY+1                   ; STX YY+1
     B7FE 0027     
26337               
26338 B800 0200  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     B802 BA12     
26339 B804 06A0  32        bl   @jsr                       ;
     B806 FE28     
26340                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26341                                                                          ; the line for the new sun
26342               
26343 B808 17E5  14        jnc  PLF16                      ; BCC PLF16         ; If the line is on-screen, jump up to PLF16 to draw the
26344                                                                          ; line and loop round for the next line up
26345               
26346 B80A 020D  20        li   ra,>00*256                 ; LDA #0            ; The line is not on-screen, so set the line heap for
     B80C 0000     
26347 B80E DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; line Y to 0, which means there is no sun line here
     B810 0D66     
26348               
26349 B812 13E4  14        jeq  PLF6                       ; BEQ PLF6          ; Jump up to PLF6 to loop round for the next line up
26350                                                                          ; (this BEQ is effectively a JMP as A is always zero)
26351               
26352               PLF10:
26353 B814 D3A0  30        movb @V,rx                      ; LDX V             ; Increment V, the height of the sun that we use to work
     B816 0022     
26354 B818 B387  18        ab   rone,rx                    ; INX               ; out the width, so this makes the line get narrower, as
26355 B81A D80E  30        movb rx,@V                      ; STX V             ; we move up and away from the sun's centre
     B81C 0022     
26356               
26357 B81E 93A0  30        cb   @K,rx                      ; CPX K             ; If V <= the radius of the sun, we still have lines to
     B820 003D     
26358 B822 17E4  14        jnc  PLFLS                      ; BCC PLFLS         ; draw, so jump up to PLFL (via PLFLS) to do the next
26359 B824 13E3  14        jeq  PLFLS                      ; BEQ PLFLS         ; screen line up
26360               
26361               * ******************************************************************************
26362               *
26363               * Name: SUN (Part 4 of 4)
26364               * Type: Subroutine
26365               * Category: Drawing suns
26366               * Summary: Draw the sun: Continue to the top of the screen, erasing the old
26367               * sun line by line
26368               * Deep dive: Drawing the sun
26369               *
26370               * ------------------------------------------------------------------------------
26371               *
26372               * This part erases any remaining traces of the old sun, now that we have drawn
26373               * all the way to the top of the new sun.
26374               *
26375               * ------------------------------------------------------------------------------
26376               *
26377               * Other entry points:
26378               *
26379               * RTS2                Contains an RTS
26380               *
26381               * ******************************************************************************
26382               
26383 B826 D360  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     B828 0028     
26384 B82A D80D  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     B82C 0026     
26385 B82E D360  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     B830 0029     
26386 B832 D80D  30        movb ra,@YY+1                   ; STA YY+1
     B834 0027     
26387               
26388               PLFL3:
26389 B836 D36F  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     B838 0D66     
26390                                                                          ; gives us the half-width of the old sun's line on this
26391                                                                          ; line of the screen
26392               
26393 B83A 1304  14        jeq  PLF9                       ; BEQ PLF9          ; If A = 0, skip the following call to HLOIN2 as there
26394                                                                          ; is no sun line on this line of the screen
26395               
26396 B83C 0200  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     B83E 260E     
26397 B840 06A0  32        bl   @jsr                       ;
     B842 FE28     
26398                                                                          ; with centre point YY(1 0) and half-width A, and remove
26399                                                                          ; the line from the sun line heap once done
26400               
26401               PLF9:
26402 B844 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the line number in Y to move to the line
26403                                                                          ; above
26404               
26405 B846 16F7  14        jne  PLFL3                      ; BNE PLFL3         ; Jump up to PLFL3 to redraw the next line up, until we
26406                                                                          ; have reached the top of the screen
26407               
26408               PLF8:
26409                                                                          ; If we get here, we have successfully made it from the
26410                                                                          ; bottom line of the screen to the top, and the old sun
26411                                                                          ; has been replaced by the new one
26412                      .clc                            ; CLC               ; Clear the C flag to indicate success in drawing the
     **** ****     > CLC
0001 B848 0A16  18        sla  rzero,1
                   < elite.a99
26413                                                                          ; sun
26414               
26415 B84A D360  30        movb @K3,ra                     ; LDA K3            ; Set SUNX(1 0) = K3(1 0)
     B84C 00D2     
26416 B84E D80D  30        movb ra,@SUNX                   ; STA SUNX
     B850 0028     
26417 B852 D360  30        movb @K3+1,ra                   ; LDA K3+1
     B854 00D3     
26418 B856 D80D  30        movb ra,@SUNX+1                 ; STA SUNX+1
     B858 0029     
26419               
26420               RTS2:
26421 B85A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B85C FE34     
26422               
26423               * ******************************************************************************
26424               *
26425               * Name: CIRCLE
26426               * Type: Subroutine
26427               * Category: Drawing circles
26428               * Summary: Draw a circle for the planet
26429               * Deep dive: Drawing circles
26430               *
26431               * ------------------------------------------------------------------------------
26432               *
26433               * Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
26434               * planet's main outline.
26435               *
26436               * ------------------------------------------------------------------------------
26437               *
26438               * Arguments:
26439               *
26440               * K                   The planet's radius
26441               *
26442               * K3(1 0)             Pixel x-coordinate of the centre of the planet
26443               *
26444               * K4(1 0)             Pixel y-coordinate of the centre of the planet
26445               *
26446               * ******************************************************************************
26447               
26448               CIRCLE:
26449 B85E 0200  20        li   rtmp,CHKON                 ; JSR CHKON         ; Call CHKON to check whether the circle fits on-screen
     B860 BA80     
26450 B862 06A0  32        bl   @jsr                       ;
     B864 FE28     
26451               
26452 B866 18F9  14        joc  RTS2                       ; BCS RTS2          ; If CHKON set the C flag then the circle does not fit
26453                                                                          ; on-screen, so return from the subroutine (as RTS2
26454                                                                          ; contains an RTS)
26455               
26456 B868 020D  20        li   ra,>00*256                 ; LDA #0            ; Set LSX2 = 0 to indicate that the ball line heap is
     B86A 0000     
26457 B86C D80D  30        movb ra,@LSX2                   ; STA LSX2          ; not empty, as we are about to fill it
     B86E 0E26     
26458               
26459 B870 D3A0  30        movb @K,rx                      ; LDX K             ; Set X = K = radius
     B872 003D     
26460               
26461 B874 020D  20        li   ra,>08*256                 ; LDA #8            ; Set A = 8
     B876 0800     
26462               
26463 B878 028E  22        ci   rx,>08*256                 ; CPX #8            ; If the radius < 8, skip to PL89
     B87A 0800     
26464 B87C 1705  14        jnc  PL89                       ; BCC PL89
26465               
26466 B87E 091D  18        srl  ra,1                       ; LSR A             ; Halve A so A = 4
26467               
26468 B880 028E  22        ci   rx,>3c*256                 ; CPX #60           ; If the radius < 60, skip to PL89
     B882 3C00     
26469 B884 1701  14        jnc  PL89                       ; BCC PL89
26470               
26471 B886 091D  18        srl  ra,1                       ; LSR A             ; Halve A so A = 2
26472               
26473               PL89:
26474 B888 D80D  30        movb ra,@STP                    ; STA STP           ; Set STP = A. STP is the step size for the circle, so
     B88A 00A6     
26475                                                                          ; the above sets a smaller step size for bigger circles
26476               
26477                                                                          ; Fall through into CIRCLE2 to draw the circle with the
26478                                                                          ; correct step size
26479               
26480               * ******************************************************************************
26481               *
26482               * Name: CIRCLE2
26483               * Type: Subroutine
26484               * Category: Drawing circles
26485               * Summary: Draw a circle (for the planet or chart)
26486               * Deep dive: Drawing circles
26487               *
26488               * ------------------------------------------------------------------------------
26489               *
26490               * Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
26491               * planet and the chart circles.
26492               *
26493               * ------------------------------------------------------------------------------
26494               *
26495               * Arguments:
26496               *
26497               * STP                 The step size for the circle
26498               *
26499               * K                   The circle's radius
26500               *
26501               * K3(1 0)             Pixel x-coordinate of the centre of the circle
26502               *
26503               * K4(1 0)             Pixel y-coordinate of the centre of the circle
26504               *
26505               * ------------------------------------------------------------------------------
26506               *
26507               * Returns:
26508               *
26509               * C flag              The C flag is cleared
26510               *
26511               * ******************************************************************************
26512               
26513               CIRCLE2:
26514 B88C 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set FLAG = &FF to reset the ball line heap in the call
     B88E FF00     
26515 B890 D80E  30        movb rx,@FLAG                   ; STX FLAG          ; to the BLINE routine below
     B892 00A3     
26516               
26517 B894 B387  18        ab   rone,rx                    ; INX               ; Set CNT = 0, our counter that goes up to 64, counting
26518 B896 D80E  30        movb rx,@CNT                    ; STX CNT           ; segments in our circle
     B898 00A4     
26519               
26520               PLL3:
26521 B89A D360  30        movb @CNT,ra                    ; LDA CNT           ; Set A = CNT
     B89C 00A4     
26522               
26523 B89E 0200  20        li   rtmp,FMLTU2                ; JSR FMLTU2        ; Call FMLTU2 to calculate:
     B8A0 43DA     
26524 B8A2 06A0  32        bl   @jsr                       ;
     B8A4 FE28     
26525                                                                          ;
26526                                                                          ; A = K * sin(A)
26527                                                                          ; = K * sin(CNT)
26528               
26529 B8A6 020E  20        li   rx,>00*256                 ; LDX #0            ; Set T = 0, so we have the following:
     B8A8 0000     
26530 B8AA D80E  30        movb rx,@T                      ; STX T             ;
     B8AC 00D1     
26531                                                                          ; (T A) = K * sin(CNT)
26532                                                                          ;
26533                                                                          ; which is the x-coordinate of the circle for this count
26534               
26535 B8AE D3A0  30        movb @CNT,rx                    ; LDX CNT           ; If CNT < 33 then jump to PL37, as this is the right
     B8B0 00A4     
26536 B8B2 028E  22        ci   rx,>21*256                 ; CPX #33           ; half of the circle and the sign of the x-coordinate is
     B8B4 2100     
26537 B8B6 1712  14        jnc  PL37                       ; BCC PL37          ; correct
26538               
26539                      .eoi (>ff*256)                  ; EOR #%11111111    ; This is the left half of the circle, so we want to
     **** ****     > EOI
0001 B8B8 0200  20        li   rtmp,(>FF*256)
     B8BA FF00     
0002 B8BC 2B40  18        xor  rtmp,ra
                   < elite.a99
26540                      .adi (>00*256)                  ; ADC #0            ; flip the sign of the x-coordinate in (T A) using two's
     **** ****     > ADI
0001 B8BE 1701  14        jnc  !
0002 B8C0 B347  18        ab   rone,ra
0003               !:
0004 B8C2 022D  22        ai   ra,(>00*256)
     B8C4 0000     
                   < elite.a99
26541 B8C6 D38D  18        movb ra,rx                      ; TAX               ; complement, so we start with the low byte and store it
26542                                                                          ; in X (the ADC adds 1 as we know the C flag is set)
26543               
26544 B8C8 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; And then we flip the high byte in T
     B8CA FF00     
26545                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 B8CC 1701  14        jnc  !
0002 B8CE B347  18        ab   rone,ra
0003               !:
0004 B8D0 022D  22        ai   ra,(>00*256)
     B8D2 0000     
                   < elite.a99
26546 B8D4 D80D  30        movb ra,@T                      ; STA T
     B8D6 00D1     
26547               
26548 B8D8 D34E  18        movb rx,ra                      ; TXA               ; Finally, we restore the low byte from X, so we have
26549                                                                          ; now negated the x-coordinate in (T A)
26550               
26551                      .clc                            ; CLC               ; Clear the C flag so we can do some more addition below
     **** ****     > CLC
0001 B8DA 0A16  18        sla  rzero,1
                   < elite.a99
26552               
26553               PL37:
26554                      .adc @K3,ra                     ; ADC K3            ; We now calculate the following:
     **** ****     > ADC
0001 B8DC 1701  14        jnc  !
0002 B8DE B347  18        ab   rone,ra
0003               !:
0004 B8E0 B360  30        ab   @K3,ra
     B8E2 00D2     
                   < elite.a99
26555 B8E4 D80D  30        movb ra,@K6                     ; STA K6            ;
     B8E6 0082     
26556                                                                          ; K6(1 0) = (T A) + K3(1 0)
26557                                                                          ;
26558                                                                          ; to add the coordinates of the centre to our circle
26559                                                                          ; point, starting with the low bytes
26560               
26561 B8E8 D360  30        movb @K3+1,ra                   ; LDA K3+1          ; And then doing the high bytes, so we now have:
     B8EA 00D3     
26562                      .adc @T,ra                      ; ADC T             ;
     **** ****     > ADC
0001 B8EC 1701  14        jnc  !
0002 B8EE B347  18        ab   rone,ra
0003               !:
0004 B8F0 B360  30        ab   @T,ra
     B8F2 00D1     
                   < elite.a99
26563 B8F4 D80D  30        movb ra,@K6+1                   ; STA K6+1          ; K6(1 0) = K * sin(CNT) + K3(1 0)
     B8F6 0083     
26564                                                                          ;
26565                                                                          ; which is the result we want for the x-coordinate
26566               
26567 B8F8 D360  30        movb @CNT,ra                    ; LDA CNT           ; Set A = CNT + 16
     B8FA 00A4     
26568                      .clc                            ; CLC
     **** ****     > CLC
0001 B8FC 0A16  18        sla  rzero,1
                   < elite.a99
26569                      .adi (>10*256)                  ; ADC #16
     **** ****     > ADI
0001 B8FE 1701  14        jnc  !
0002 B900 B347  18        ab   rone,ra
0003               !:
0004 B902 022D  22        ai   ra,(>10*256)
     B904 1000     
                   < elite.a99
26570               
26571 B906 0200  20        li   rtmp,FMLTU2                ; JSR FMLTU2        ; Call FMLTU2 to calculate:
     B908 43DA     
26572 B90A 06A0  32        bl   @jsr                       ;
     B90C FE28     
26573                                                                          ;
26574                                                                          ; A = K * sin(A)
26575                                                                          ; = K * sin(CNT + 16)
26576                                                                          ; = K * cos(CNT)
26577               
26578 B90E D38D  18        movb ra,rx                      ; TAX               ; Set X = A
26579                                                                          ; = K * cos(CNT)
26580               
26581 B910 020D  20        li   ra,>00*256                 ; LDA #0            ; Set T = 0, so we have the following:
     B912 0000     
26582 B914 D80D  30        movb ra,@T                      ; STA T             ;
     B916 00D1     
26583                                                                          ; (T X) = K * cos(CNT)
26584                                                                          ;
26585                                                                          ; which is the y-coordinate of the circle for this count
26586               
26587 B918 D360  30        movb @CNT,ra                    ; LDA CNT           ; Set A = (CNT + 15) mod 64
     B91A 00A4     
26588                      .adi (>0f*256)                  ; ADC #15
     **** ****     > ADI
0001 B91C 1701  14        jnc  !
0002 B91E B347  18        ab   rone,ra
0003               !:
0004 B920 022D  22        ai   ra,(>0F*256)
     B922 0F00     
                   < elite.a99
26589 B924 024D  22        andi ra,>3f*256                 ; AND #63
     B926 3F00     
26590               
26591 B928 028D  22        ci   ra,>21*256                 ; CMP #33           ; If A < 33 (i.e. CNT is 0-16 or 48-64) then jump to
     B92A 2100     
26592 B92C 1712  14        jnc  PL38                       ; BCC PL38          ; PL38, as this is the bottom half of the circle and the
26593                                                                          ; sign of the y-coordinate is correct
26594               
26595 B92E D34E  18        movb rx,ra                      ; TXA               ; This is the top half of the circle, so we want to
26596                      .eoi (>ff*256)                  ; EOR #%11111111    ; flip the sign of the y-coordinate in (T X) using two's
     **** ****     > EOI
0001 B930 0200  20        li   rtmp,(>FF*256)
     B932 FF00     
0002 B934 2B40  18        xor  rtmp,ra
                   < elite.a99
26597                      .adi (>00*256)                  ; ADC #0            ; complement, so we start with the low byte in X (the
     **** ****     > ADI
0001 B936 1701  14        jnc  !
0002 B938 B347  18        ab   rone,ra
0003               !:
0004 B93A 022D  22        ai   ra,(>00*256)
     B93C 0000     
                   < elite.a99
26598 B93E D38D  18        movb ra,rx                      ; TAX               ; ADC adds 1 as we know the C flag is set)
26599               
26600 B940 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; And then we flip the high byte in T, so we have
     B942 FF00     
26601                      .adi (>00*256)                  ; ADC #0            ; now negated the y-coordinate in (T X)
     **** ****     > ADI
0001 B944 1701  14        jnc  !
0002 B946 B347  18        ab   rone,ra
0003               !:
0004 B948 022D  22        ai   ra,(>00*256)
     B94A 0000     
                   < elite.a99
26602 B94C D80D  30        movb ra,@T                      ; STA T
     B94E 00D1     
26603               
26604                      .clc                            ; CLC               ; Clear the C flag so the addition at the start of BLINE
     **** ****     > CLC
0001 B950 0A16  18        sla  rzero,1
                   < elite.a99
26605                                                                          ; will work
26606               
26607               PL38:
26608 B952 0200  20        li   rtmp,BLINE                 ; JSR BLINE         ; Call BLINE to draw this segment, which also increases
     B954 288E     
26609 B956 06A0  32        bl   @jsr                       ;
     B958 FE28     
26610                                                                          ; CNT by STP, the step size
26611               
26612 B95A 028D  22        ci   ra,>41*256                 ; CMP #65           ; If CNT >= 65 then skip the next instruction
     B95C 4100     
26613 B95E 1802  14        joc  B78                        ; BCS B78
26614               
26615 B960 0460  28        b    @PLL3                      ; JMP PLL3          ; Jump back for the next segment
     B962 B89A     
26616               
26617               B78:
26618                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 B964 0A16  18        sla  rzero,1
                   < elite.a99
26619               
26620 B966 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B968 FE34     
26621               
26622               * ******************************************************************************
26623               *
26624               * Name: WPLS2
26625               * Type: Subroutine
26626               * Category: Drawing planets
26627               * Summary: Remove the planet from the screen
26628               * Deep dive: The ball line heap
26629               *
26630               * ------------------------------------------------------------------------------
26631               *
26632               * We do this by redrawing it using the lines stored in the ball line heap when
26633               * the planet was originally drawn by the BLINE routine.
26634               *
26635               * ******************************************************************************
26636               
26637               WPLS2:
26638 B96A D3E0  30        movb @LSX2,ry                   ; LDY LSX2          ; If LSX2 is non-zero (which indicates the ball line
     B96C 0E26     
26639 B96E 162C  14        jne  WP1                        ; BNE WP1           ; heap is empty), jump to WP1 to reset the line heap
26640                                                                          ; without redrawing the planet
26641               
26642                                                                          ; Otherwise Y is now 0, so we can use it as a counter to
26643                                                                          ; loop through the lines in the line heap, redrawing
26644                                                                          ; each one to remove the planet from the screen, before
26645                                                                          ; resetting the line heap once we are done
26646               
26647               WPL1:
26648 B970 93E0  30        cb   @LSP,ry                    ; CPY LSP           ; If Y >= LSP then we have reached the end of the line
     B972 0077     
26649 B974 1829  14        joc  WP1                        ; BCS WP1           ; heap and have finished redrawing the planet (as LSP
26650                                                                          ; points to the end of the heap), so jump to WP1 to
26651                                                                          ; reset the line heap, returning from the subroutine
26652                                                                          ; using a tail call
26653               
26654 B976 D36F  34        movb @LSY2(ry),ra               ; LDA LSY2,Y        ; Set A to the y-coordinate of the current heap entry
     B978 0E74     
26655               
26656 B97A 028D  22        ci   ra,>ff*256                 ; CMP #&FF          ; If the y-coordinate is &FF, this indicates that the
     B97C FF00     
26657 B97E 1318  14        jeq  WP2                        ; BEQ WP2           ; next point in the heap denotes the start of a line
26658                                                                          ; segment, so jump to WP2 to put it into (X1, Y1)
26659               
26660 B980 D80D  30        movb ra,@Y2                     ; STA Y2            ; Set (X2, Y2) to the x- and y-coordinates from the
     B982 0034     
26661 B984 D36F  34        movb @LSX2(ry),ra               ; LDA LSX2,Y        ; heap
     B986 0E26     
26662 B988 D80D  30        movb ra,@X2                     ; STA X2
     B98A 0033     
26663               
26664 B98C 0200  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2)
     B98E 2272     
26665 B990 06A0  32        bl   @jsr                       ;
     B992 FE28     
26666               
26667 B994 B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
26668               
26669 B996 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP is non-zero then we swapped the coordinates
     B998 00A1     
26670 B99A 16EA  14        jne  WPL1                       ; BNE WPL1          ; when filling the heap in BLINE, so loop back WPL1
26671                                                                          ; for the next point in the heap
26672               
26673 B99C D360  30        movb @X2,ra                     ; LDA X2            ; Swap (X1, Y1) and (X2, Y2), so the next segment will
     B99E 0033     
26674 B9A0 D80D  30        movb ra,@X1                     ; STA X1            ; be drawn from the current (X2, Y2) to the next point
     B9A2 0031     
26675 B9A4 D360  30        movb @Y2,ra                     ; LDA Y2            ; in the heap
     B9A6 0034     
26676 B9A8 D80D  30        movb ra,@Y1                     ; STA Y1
     B9AA 0032     
26677               
26678 B9AC 0460  28        b    @WPL1                      ; JMP WPL1          ; Loop back to WPL1 for the next point in the heap
     B9AE B970     
26679               
26680               WP2:
26681 B9B0 B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
26682               
26683 B9B2 D36F  34        movb @LSX2(ry),ra               ; LDA LSX2,Y        ; Set (X1, Y1) to the x- and y-coordinates from the
     B9B4 0E26     
26684 B9B6 D80D  30        movb ra,@X1                     ; STA X1            ; heap
     B9B8 0031     
26685 B9BA D36F  34        movb @LSY2(ry),ra               ; LDA LSY2,Y
     B9BC 0E74     
26686 B9BE D80D  30        movb ra,@Y1                     ; STA Y1
     B9C0 0032     
26687               
26688 B9C2 B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
26689               
26690 B9C4 0460  28        b    @WPL1                      ; JMP WPL1          ; Loop back to WPL1 for the next point in the heap
     B9C6 B970     
26691               
26692               * ******************************************************************************
26693               *
26694               * Name: WP1
26695               * Type: Subroutine
26696               * Category: Drawing planets
26697               * Summary: Reset the ball line heap
26698               *
26699               * ******************************************************************************
26700               
26701               WP1:
26702 B9C8 020D  20        li   ra,>01*256                 ; LDA #1            ; Set LSP = 1 to reset the ball line heap pointer
     B9CA 0100     
26703 B9CC D80D  30        movb ra,@LSP                    ; STA LSP
     B9CE 0077     
26704               
26705 B9D0 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set LSX2 = &FF to indicate the ball line heap is empty
     B9D2 FF00     
26706 B9D4 D80D  30        movb ra,@LSX2                   ; STA LSX2
     B9D6 0E26     
26707               
26708 B9D8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B9DA FE34     
26709               
26710               * ******************************************************************************
26711               *
26712               * Name: WPLS
26713               * Type: Subroutine
26714               * Category: Drawing suns
26715               * Summary: Remove the sun from the screen
26716               * Deep dive: Drawing the sun
26717               *
26718               * ------------------------------------------------------------------------------
26719               *
26720               * We do this by redrawing it using the lines stored in the sun line heap when
26721               * the sun was originally drawn by the SUN routine.
26722               *
26723               * ------------------------------------------------------------------------------
26724               *
26725               * Arguments:
26726               *
26727               * SUNX(1 0)           The x-coordinate of the vertical centre axis of the sun
26728               *
26729               * ------------------------------------------------------------------------------
26730               *
26731               * Other entry points:
26732               *
26733               * WPLS-1              Contains an RTS
26734               *
26735               * ******************************************************************************
26736               
26737               WPLS:
26738 B9DC D360  30        movb @LSX,ra                    ; LDA LSX           ; If LSX < 0, the sun line heap is empty, so return from
     B9DE 0D66     
26739 B9E0 11FC  14        jlt  WPLS-1                     ; BMI WPLS-1        ; the subroutine (as WPLS-1 contains an RTS)
26740               
26741 B9E2 D360  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     B9E4 0028     
26742 B9E6 D80D  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the sun that's currently on
     B9E8 0026     
26743 B9EA D360  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; screen
     B9EC 0029     
26744 B9EE D80D  30        movb ra,@YY+1                   ; STA YY+1
     B9F0 0027     
26745               
26746 B9F2 020F  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     B9F4 BF00     
26747                                                                          ; view, so this sets Y as a counter for the number of
26748                                                                          ; lines in the space view (i.e. 191), which is also the
26749                                                                          ; number of lines in the LSO block
26750               
26751               WPL2:
26752 B9F6 D36F  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     B9F8 0D66     
26753                                                                          ; gives us the half-width of the sun's line on this line
26754                                                                          ; of the screen
26755               
26756 B9FA 1304  14        jeq  B79                        ; BEQ B79           ; If A = 0, skip the following call to HLOIN2 as there
26757                                                                          ; is no sun line on this line of the screen
26758               
26759 B9FC 0200  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     B9FE 260E     
26760 BA00 06A0  32        bl   @jsr                       ;
     BA02 FE28     
26761                                                                          ; with centre point YY(1 0) and half-width A, and remove
26762                                                                          ; the line from the sun line heap once done
26763               
26764               B79:
26765 BA04 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
26766               
26767 BA06 16F7  14        jne  WPL2                       ; BNE WPL2          ; Loop back for the next line in the line heap until
26768                                                                          ; we have gone through the entire heap
26769               
26770 BA08 73C7  18        sb   rone,ry                    ; DEY               ; This sets Y to &FF, as we end the loop with Y = 0
26771               
26772 BA0A D80F  30        movb ry,@LSX                    ; STY LSX           ; Set LSX to &FF to indicate the sun line heap is empty
     BA0C 0D66     
26773               
26774 BA0E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BA10 FE34     
26775               
26776               * ******************************************************************************
26777               *
26778               * Name: EDGES
26779               * Type: Subroutine
26780               * Category: Drawing lines
26781               * Summary: Draw a horizontal line given a centre and a half-width
26782               *
26783               * ------------------------------------------------------------------------------
26784               *
26785               * Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
26786               * centre x-coordinate YY(1 0), and length A in either direction from the centre
26787               * (so a total line length of 2 * A). In other words, this line:
26788               *
26789               * X1             YY(1 0)             X2
26790               * +-----------------+-----------------+
26791               * <- A ->           <- A ->
26792               *
26793               * The resulting line gets clipped to the edges of the screen, if needed. If the
26794               * calculation doesn't overflow, we return with the C flag clear, otherwise the C
26795               * flag gets set to indicate failure and the Y-th LSO entry gets set to 0.
26796               *
26797               * ------------------------------------------------------------------------------
26798               *
26799               * Arguments:
26800               *
26801               * A                   The half-length of the line
26802               *
26803               * YY(1 0)             The centre x-coordinate
26804               *
26805               * ------------------------------------------------------------------------------
26806               *
26807               * Returns:
26808               *
26809               * C flag              Clear if the line fits on-screen, set if it doesn't
26810               *
26811               * X1, X2              The x-coordinates of the clipped line
26812               *
26813               * LSO+Y               If the line doesn't fit, LSO+Y is set to 0
26814               *
26815               * Y                   Y is preserved
26816               *
26817               * ******************************************************************************
26818               
26819               EDGES:
26820 BA12 D80D  30        movb ra,@T                      ; STA T             ; Set T to the line's half-length in argument A
     BA14 00D1     
26821               
26822                      .clc                            ; CLC               ; We now calculate:
     **** ****     > CLC
0001 BA16 0A16  18        sla  rzero,1
                   < elite.a99
26823                      .adc @YY,ra                     ; ADC YY            ;
     **** ****     > ADC
0001 BA18 1701  14        jnc  !
0002 BA1A B347  18        ab   rone,ra
0003               !:
0004 BA1C B360  30        ab   @YY,ra
     BA1E 0026     
                   < elite.a99
26824 BA20 D80D  30        movb ra,@X2                     ; STA X2            ; (A X2) = YY(1 0) + A
     BA22 0033     
26825                                                                          ;
26826                                                                          ; to set X2 to the x-coordinate of the right end of the
26827                                                                          ; line, starting with the low bytes
26828               
26829 BA24 D360  30        movb @YY+1,ra                   ; LDA YY+1          ; And then adding the high bytes
     BA26 0027     
26830                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 BA28 1701  14        jnc  !
0002 BA2A B347  18        ab   rone,ra
0003               !:
0004 BA2C 022D  22        ai   ra,(>00*256)
     BA2E 0000     
                   < elite.a99
26831               
26832 BA30 1120  14        jlt  ED1                        ; BMI ED1           ; If the addition is negative then the calculation has
26833                                                                          ; overflowed, so jump to ED1 to return a failure
26834               
26835 BA32 1304  14        jeq  B80                        ; BEQ B80           ; If the high byte A from the result is 0, skip the
26836                                                                          ; next two instructions, as the result already fits on
26837                                                                          ; the screen
26838               
26839 BA34 020D  20        li   ra,>fe*256                 ; LDA #254          ; The high byte is positive and non-zero, so we went
     BA36 FE00     
26840 BA38 D80D  30        movb ra,@X2                     ; STA X2            ; past the right edge of the screen, so clip X2 to the
     BA3A 0033     
26841                                                                          ; x-coordinate of the right edge of the screen
26842               
26843               B80:
26844 BA3C D360  30        movb @YY,ra                     ; LDA YY            ; We now calculate:
     BA3E 0026     
26845                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 BA40 0A18  18        sla  rmone,1
                   < elite.a99
26846                      .sbc @T,ra                      ; SBC T             ; (A X1) = YY(1 0) - argument A
     **** ****     > SBC
0001 BA42 1801  14        joc  !
0002 BA44 7347  18        sb   rone,ra
0003               !:
0004 BA46 7360  30        sb   @T,ra
     BA48 00D1     
                   < elite.a99
26847 BA4A D80D  30        movb ra,@X1                     ; STA X1            ;
     BA4C 0031     
26848                                                                          ; to set X1 to the x-coordinate of the left end of the
26849                                                                          ; line, starting with the low bytes
26850               
26851 BA4E D360  30        movb @YY+1,ra                   ; LDA YY+1          ; And then subtracting the high bytes
     BA50 0027     
26852                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 BA52 1801  14        joc  !
0002 BA54 7347  18        sb   rone,ra
0003               !:
0004 BA56 022D  22        ai   ra,-(>00*256)
     BA58 0000     
                   < elite.a99
26853               
26854 BA5A 1603  14        jne  ED3                        ; BNE ED3           ; If the high byte subtraction is non-zero, then skip
26855                                                                          ; to ED3
26856               
26857                      .clc                            ; CLC               ; Otherwise the high byte of the subtraction was zero,
     **** ****     > CLC
0001 BA5C 0A16  18        sla  rzero,1
                   < elite.a99
26858                                                                          ; so the line fits on-screen and we clear the C flag to
26859                                                                          ; indicate success
26860               
26861 BA5E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BA60 FE34     
26862               
26863               ED3:
26864 BA62 1507  14        jgt  ED1                        ; BPL ED1           ; If the addition is positive then the calculation has
26865                                                                          ; underflowed, so jump to ED1 to return a failure
26866               
26867 BA64 020D  20        li   ra,>02*256                 ; LDA #2            ; The high byte is negative and non-zero, so we went
     BA66 0200     
26868 BA68 D80D  30        movb ra,@X1                     ; STA X1            ; past the left edge of the screen, so clip X1 to the
     BA6A 0031     
26869                                                                          ; x-coordinate of the left edge of the screen
26870               
26871                      .clc                            ; CLC               ; The line does fit on-screen, so clear the C flag to
     **** ****     > CLC
0001 BA6C 0A16  18        sla  rzero,1
                   < elite.a99
26872                                                                          ; indicate success
26873               
26874 BA6E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BA70 FE34     
26875               
26876               ED1:
26877 BA72 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the Y-th byte of the LSO block to 0
     BA74 0000     
26878 BA76 DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y
     BA78 0D66     
26879               
26880                      .sec                            ; SEC               ; The line does not fit on the screen, so set the C flag
     **** ****     > SEC
0001 BA7A 0A18  18        sla  rmone,1
                   < elite.a99
26881                                                                          ; to indicate this result
26882               
26883 BA7C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BA7E FE34     
26884               
26885               * ******************************************************************************
26886               *
26887               * Name: CHKON
26888               * Type: Subroutine
26889               * Category: Drawing circles
26890               * Summary: Check whether any part of a circle appears on the extended screen
26891               *
26892               * ------------------------------------------------------------------------------
26893               *
26894               * Arguments:
26895               *
26896               * K                   The circle's radius
26897               *
26898               * K3(1 0)             Pixel x-coordinate of the centre of the circle
26899               *
26900               * K4(1 0)             Pixel y-coordinate of the centre of the circle
26901               *
26902               * ------------------------------------------------------------------------------
26903               *
26904               * Returns:
26905               *
26906               * C flag              Clear if any part of the circle appears on-screen, set
26907               * if none of the circle appears on-screen
26908               *
26909               * (A X)               Minimum y-coordinate of the circle on-screen (i.e. the
26910               * y-coordinate of the top edge of the circle)
26911               *
26912               * P(2 1)              Maximum y-coordinate of the circle on-screen (i.e. the
26913               * y-coordinate of the bottom edge of the circle)
26914               *
26915               * ******************************************************************************
26916               
26917               CHKON:
26918 BA80 D360  30        movb @K3,ra                     ; LDA K3            ; Set A = K3 + K
     BA82 00D2     
26919                      .clc                            ; CLC
     **** ****     > CLC
0001 BA84 0A16  18        sla  rzero,1
                   < elite.a99
26920                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 BA86 1701  14        jnc  !
0002 BA88 B347  18        ab   rone,ra
0003               !:
0004 BA8A B360  30        ab   @K,ra
     BA8C 003D     
                   < elite.a99
26921               
26922 BA8E D360  30        movb @K3+1,ra                   ; LDA K3+1          ; Set A = K3+1 + 0 + any carry from above, so this
     BA90 00D3     
26923                      .adi (>00*256)                  ; ADC #0            ; effectively sets A to the high byte of K3(1 0) + K:
     **** ****     > ADI
0001 BA92 1701  14        jnc  !
0002 BA94 B347  18        ab   rone,ra
0003               !:
0004 BA96 022D  22        ai   ra,(>00*256)
     BA98 0000     
                   < elite.a99
26924                                                                          ;
26925                                                                          ; (A ?) = K3(1 0) + K
26926                                                                          ;
26927                                                                          ; so A is the high byte of the x-coordinate of the right
26928                                                                          ; edge of the circle
26929               
26930 BA9A 1135  14        jlt  PL21                       ; BMI PL21          ; If A is negative then the right edge of the circle is
26931                                                                          ; to the left of the screen, so jump to PL21 to set the
26932                                                                          ; C flag and return from the subroutine, as the whole
26933                                                                          ; circle is off-screen to the left
26934               
26935 BA9C D360  30        movb @K3,ra                     ; LDA K3            ; Set A = K3 - K
     BA9E 00D2     
26936                      .sec                            ; SEC
     **** ****     > SEC
0001 BAA0 0A18  18        sla  rmone,1
                   < elite.a99
26937                      .sbc @K,ra                      ; SBC K
     **** ****     > SBC
0001 BAA2 1801  14        joc  !
0002 BAA4 7347  18        sb   rone,ra
0003               !:
0004 BAA6 7360  30        sb   @K,ra
     BAA8 003D     
                   < elite.a99
26938               
26939 BAAA D360  30        movb @K3+1,ra                   ; LDA K3+1          ; Set A = K3+1 - 0 - any carry from above, so this
     BAAC 00D3     
26940                      .sbi (>00*256)                  ; SBC #0            ; effectively sets A to the high byte of K3(1 0) - K:
     **** ****     > SBI
0001 BAAE 1801  14        joc  !
0002 BAB0 7347  18        sb   rone,ra
0003               !:
0004 BAB2 022D  22        ai   ra,-(>00*256)
     BAB4 0000     
                   < elite.a99
26941                                                                          ;
26942                                                                          ; (A ?) = K3(1 0) - K
26943                                                                          ;
26944                                                                          ; so A is the high byte of the x-coordinate of the left
26945                                                                          ; edge of the circle
26946               
26947 BAB6 1101  14        jlt  PL31                       ; BMI PL31          ; If A is negative then the left edge of the circle is
26948                                                                          ; to the left of the screen, and we already know the
26949                                                                          ; right edge is either on-screen or off-screen to the
26950                                                                          ; right, so skip to PL31 to move on to the y-coordinate
26951                                                                          ; checks, as at least part of the circle is on-screen in
26952                                                                          ; terms of the x-axis
26953               
26954 BAB8 1626  14        jne  PL21                       ; BNE PL21          ; If A is non-zero, then the left edge of the circle is
26955                                                                          ; to the right of the screen, so jump to PL21 to set the
26956                                                                          ; C flag and return from the subroutine, as the whole
26957                                                                          ; circle is off-screen to the right
26958               
26959               PL31:
26960 BABA D360  30        movb @K4,ra                     ; LDA K4            ; Set P+1 = K4 + K
     BABC 00E0     
26961                      .clc                            ; CLC
     **** ****     > CLC
0001 BABE 0A16  18        sla  rzero,1
                   < elite.a99
26962                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 BAC0 1701  14        jnc  !
0002 BAC2 B347  18        ab   rone,ra
0003               !:
0004 BAC4 B360  30        ab   @K,ra
     BAC6 003D     
                   < elite.a99
26963 BAC8 D80D  30        movb ra,@P+1                    ; STA P+1
     BACA 001C     
26964               
26965 BACC D360  30        movb @K4+1,ra                   ; LDA K4+1          ; Set A = K4+1 + 0 + any carry from above, so this
     BACE 00E1     
26966                      .adi (>00*256)                  ; ADC #0            ; does the following:
     **** ****     > ADI
0001 BAD0 1701  14        jnc  !
0002 BAD2 B347  18        ab   rone,ra
0003               !:
0004 BAD4 022D  22        ai   ra,(>00*256)
     BAD6 0000     
                   < elite.a99
26967                                                                          ;
26968                                                                          ; (A P+1) = K4(1 0) + K
26969                                                                          ;
26970                                                                          ; so A is the high byte of the y-coordinate of the
26971                                                                          ; bottom edge of the circle
26972               
26973 BAD8 1116  14        jlt  PL21                       ; BMI PL21          ; If A is negative then the bottom edge of the circle is
26974                                                                          ; above the top of the screen, so jump to PL21 to set
26975                                                                          ; the C flag and return from the subroutine, as the
26976                                                                          ; whole circle is off-screen to the top
26977               
26978 BADA D80D  30        movb ra,@P+2                    ; STA P+2           ; Store the high byte in P+2, so now we have:
     BADC 001D     
26979                                                                          ;
26980                                                                          ; P(2 1) = K4(1 0) + K
26981                                                                          ;
26982                                                                          ; i.e. the maximum y-coordinate of the circle on-screen
26983                                                                          ; (which we return)
26984               
26985 BADE D360  30        movb @K4,ra                     ; LDA K4            ; Set X = K4 - K
     BAE0 00E0     
26986                      .sec                            ; SEC
     **** ****     > SEC
0001 BAE2 0A18  18        sla  rmone,1
                   < elite.a99
26987                      .sbc @K,ra                      ; SBC K
     **** ****     > SBC
0001 BAE4 1801  14        joc  !
0002 BAE6 7347  18        sb   rone,ra
0003               !:
0004 BAE8 7360  30        sb   @K,ra
     BAEA 003D     
                   < elite.a99
26988 BAEC D38D  18        movb ra,rx                      ; TAX
26989               
26990 BAEE D360  30        movb @K4+1,ra                   ; LDA K4+1          ; Set A = K4+1 - 0 - any carry from above, so this
     BAF0 00E1     
26991                      .sbi (>00*256)                  ; SBC #0            ; does the following:
     **** ****     > SBI
0001 BAF2 1801  14        joc  !
0002 BAF4 7347  18        sb   rone,ra
0003               !:
0004 BAF6 022D  22        ai   ra,-(>00*256)
     BAF8 0000     
                   < elite.a99
26992                                                                          ;
26993                                                                          ; (A X) = K4(1 0) - K
26994                                                                          ;
26995                                                                          ; so A is the high byte of the y-coordinate of the top
26996                                                                          ; edge of the circle
26997               
26998 BAFA 1179  14        jlt  PL44                       ; BMI PL44          ; If A is negative then the top edge of the circle is
26999                                                                          ; above the top of the screen, and we already know the
27000                                                                          ; bottom edge is either on-screen or below the bottom
27001                                                                          ; of the screen, so skip to PL44 to clear the C flag and
27002                                                                          ; return from the subroutine using a tail call, as part
27003                                                                          ; of the circle definitely appears on-screen
27004               
27005 BAFC 1604  14        jne  PL21                       ; BNE PL21          ; If A is non-zero, then the top edge of the circle is
27006                                                                          ; below the bottom of the screen, so jump to PL21 to set
27007                                                                          ; the C flag and return from the subroutine, as the
27008                                                                          ; whole circle is off-screen to the bottom
27009               
27010 BAFE 028E  22        ci   rx,(2*Y-1)*256             ; CPX #2*Y-1        ; If we get here then A is zero, which means the top
     BB00 BF00     
27011                                                                          ; edge of the circle is within the screen boundary, so
27012                                                                          ; now we need to check whether it is in the space view
27013                                                                          ; (in which case it is on-screen) or the dashboard (in
27014                                                                          ; which case the top of the circle is hidden by the
27015                                                                          ; dashboard, so the circle isn't on-screen). We do this
27016                                                                          ; by checking the low byte of the result in X against
27017                                                                          ; 2 * #Y - 1, and returning the C flag from this
27018                                                                          ; comparison. The constant #Y is the y-coordinate of the
27019                                                                          ; mid-point of the space view, so 2 * #Y - 1, the
27020                                                                          ; y-coordinate of the bottom pixel row of the space
27021                                                                          ; view. So this does the following:
27022                                                                          ;
27023                                                                          ; * The C flag is set if coordinate (A X) is below the
27024                                                                          ; bottom row of the space view, i.e. the top edge of
27025                                                                          ; the circle is hidden by the dashboard
27026                                                                          ;
27027                                                                          ; * The C flag is clear if coordinate (A X) is above
27028                                                                          ; the bottom row of the space view, i.e. the top
27029                                                                          ; edge of the circle is on-screen
27030               
27031 BB02 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BB04 FE34     
27032               
27033               * ******************************************************************************
27034               *
27035               * Name: PL21
27036               * Type: Subroutine
27037               * Category: Drawing planets
27038               * Summary: Return from a planet/sun-drawing routine with a failure flag
27039               *
27040               * ------------------------------------------------------------------------------
27041               *
27042               * Set the C flag and return from the subroutine. This is used to return from a
27043               * planet- or sun-drawing routine with the C flag indicating an overflow in the
27044               * calculation.
27045               *
27046               * ******************************************************************************
27047               
27048               PL21:
27049                      .sec                            ; SEC               ; Set the C flag to indicate an overflow
     **** ****     > SEC
0001 BB06 0A18  18        sla  rmone,1
                   < elite.a99
27050               
27051 BB08 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BB0A FE34     
27052               
27053               * ******************************************************************************
27054               *
27055               * Name: PLS3
27056               * Type: Subroutine
27057               * Category: Drawing planets
27058               * Summary: Calculate (Y A P) = 222 * roofv_x / z
27059               *
27060               * ------------------------------------------------------------------------------
27061               *
27062               * Calculate the following, with X determining the vector to use:
27063               *
27064               * (Y A P) = 222 * roofv_x / z
27065               *
27066               * though in reality only (Y A) is used.
27067               *
27068               * Although the code below supports a range of values of X, in practice the
27069               * routine is only called with X = 15, and then again after X has been
27070               * incremented to 17. So the values calculated by PLS1 use roofv_x first, then
27071               * roofv_y. The comments below refer to roofv_x, for the first call.
27072               *
27073               * ------------------------------------------------------------------------------
27074               *
27075               * Arguments:
27076               *
27077               * X                   Determines which of the INWK orientation vectors to
27078               * divide:
27079               *
27080               * * X = 15: divides roofv_x
27081               *
27082               * * X = 17: divides roofv_y
27083               *
27084               * ------------------------------------------------------------------------------
27085               *
27086               * Returns:
27087               *
27088               * X                   X gets incremented by 2 so it points to the next
27089               * coordinate in this orientation vector (so consecutive
27090               * calls to the routine will start with x, then move onto y
27091               * and then z)
27092               *
27093               * ******************************************************************************
27094               
27095               PLS3:
27096 BB0C 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     BB0E B40C     
27097 BB10 06A0  32        bl   @jsr                       ;
     BB12 FE28     
27098 BB14 D80D  30        movb ra,@P                      ; STA P             ;
     BB16 001B     
27099                                                                          ; P = |roofv_x / z|
27100                                                                          ; K+3 = sign of roofv_x / z
27101                                                                          ;
27102                                                                          ; and increment X to point to roofv_y for the next call
27103               
27104 BB18 020D  20        li   ra,>de*256                 ; LDA #222          ; Set Q = 222, the offset to the crater
     BB1A DE00     
27105 BB1C D80D  30        movb ra,@Q                      ; STA Q
     BB1E 0090     
27106               
27107 BB20 D80E  30        movb rx,@U                      ; STX U             ; Store the vector index X in U for retrieval after the
     BB22 008F     
27108                                                                          ; call to MULTU
27109               
27110 BB24 0200  20        li   rtmp,MULTU                 ; JSR MULTU         ; Call MULTU to calculate
     BB26 4392     
27111 BB28 06A0  32        bl   @jsr                       ;
     BB2A FE28     
27112                                                                          ;
27113                                                                          ; (A P) = P * Q
27114                                                                          ; = 222 * |roofv_x / z|
27115               
27116 BB2C D3A0  30        movb @U,rx                      ; LDX U             ; Restore the vector index from U into X
     BB2E 008F     
27117               
27118 BB30 D3E0  30        movb @K+3,ry                    ; LDY K+3           ; If the sign of the result in K+3 is positive, skip to
     BB32 0040     
27119 BB34 150D  14        jgt  PL12                       ; BPL PL12          ; PL12 to return with Y = 0
27120               
27121                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise the result should be negative, so negate the
     **** ****     > EOI
0001 BB36 0200  20        li   rtmp,(>FF*256)
     BB38 FF00     
0002 BB3A 2B40  18        xor  rtmp,ra
                   < elite.a99
27122                      .clc                            ; CLC               ; high byte of the result using two's complement with
     **** ****     > CLC
0001 BB3C 0A16  18        sla  rzero,1
                   < elite.a99
27123                      .adi (>01*256)                  ; ADC #1            ; A = ~A + 1
     **** ****     > ADI
0001 BB3E 1701  14        jnc  !
0002 BB40 B347  18        ab   rone,ra
0003               !:
0004 BB42 022D  22        ai   ra,(>01*256)
     BB44 0100     
                   < elite.a99
27124               
27125 BB46 1304  14        jeq  PL12                       ; BEQ PL12          ; If A = 0, jump to PL12 to return with (Y A) = 0
27126               
27127 BB48 020F  20        li   ry,>ff*256                 ; LDY #&FF          ; Set Y = &FF to be a negative high byte
     BB4A FF00     
27128               
27129 BB4C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BB4E FE34     
27130               
27131               PL12:
27132 BB50 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0 to be a positive high byte
     BB52 0000     
27133               
27134 BB54 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BB56 FE34     
27135               
27136               * ******************************************************************************
27137               *
27138               * Name: PLS4
27139               * Type: Subroutine
27140               * Category: Drawing planets
27141               * Summary: Calculate CNT2 = arctan(P / A) / 4
27142               *
27143               * ------------------------------------------------------------------------------
27144               *
27145               * Calculate the following:
27146               *
27147               * CNT2 = arctan(P / A) / 4
27148               *
27149               * and do the following if nosev_z_hi >= 0:
27150               *
27151               * CNT2 = CNT2 + 32
27152               *
27153               * which is the equivalent of adding 180 degrees to the result (or PI radians),
27154               * as there are 64 segments in a full circle.
27155               *
27156               * This routine is called with the following arguments when calculating the
27157               * equator and meridian for planets:
27158               *
27159               * * A = roofv_z_hi, P = -nosev_z_hi
27160               *
27161               * * A = sidev_z_hi, P = -nosev_z_hi
27162               *
27163               * So it calculates the angle between the planet's orientation vectors, in the
27164               * z-axis.
27165               *
27166               * ******************************************************************************
27167               
27168               PLS4:
27169 BB58 D80D  30        movb ra,@Q                      ; STA Q             ; Set Q = A
     BB5A 0090     
27170               
27171 BB5C 0200  20        li   rtmp,ARCTAN                ; JSR ARCTAN        ; Call ARCTAN to calculate:
     BB5E 482A     
27172 BB60 06A0  32        bl   @jsr                       ;
     BB62 FE28     
27173                                                                          ;
27174                                                                          ; A = arctan(P / Q)
27175                                                                          ; arctan(P / A)
27176                                                                          ;
27177                                                                          ; The result in A will be in the range 0 to 128, which
27178                                                                          ; represents an angle of 0 to 180 degrees (or 0 to PI
27179                                                                          ; radians)
27180               
27181 BB64 D3A0  30        movb @INWK+14,rx                ; LDX INWK+14       ; If nosev_z_hi is negative, skip the following
     BB66 0061     
27182 BB68 1103  14        jlt  B81                        ; BMI B81           ; instruction to leave the angle in A as a positive
27183                                                                          ; integer in the range 0 to 128 (so when we calculate
27184                                                                          ; CNT2 below, it will be in the right half of the
27185                                                                          ; anti-clockwise arc that we describe when drawing
27186                                                                          ; circles, i.e. from 6 o'clock, through 3 o'clock and
27187                                                                          ; on to 12 o'clock)
27188               
27189                      .eoi (>80*256)                  ; EOR #%10000000    ; If we get here then nosev_z_hi is positive, so flip
     **** ****     > EOI
0001 BB6A 0200  20        li   rtmp,(>80*256)
     BB6C 8000     
0002 BB6E 2B40  18        xor  rtmp,ra
                   < elite.a99
27190                                                                          ; bit 7 of the angle in A, which is the same as adding
27191                                                                          ; 128 to give a result in the range 129 to 256 (i.e. 129
27192                                                                          ; to 0), or 180 to 360 degrees (so when we calculate
27193                                                                          ; CNT2 below, it will be in the left half of the
27194                                                                          ; anti-clockwise arc that we describe when drawing
27195                                                                          ; circles, i.e. from 12 o'clock, through 9 o'clock and
27196                                                                          ; on to 6 o'clock)
27197               
27198               B81:
27199 BB70 091D  18        srl  ra,1                       ; LSR A             ; Set CNT2 = A / 4
27200 BB72 091D  18        srl  ra,1                       ; LSR A
27201 BB74 D80D  30        movb ra,@CNT2                   ; STA CNT2
     BB76 00A5     
27202               
27203 BB78 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BB7A FE34     
27204               
27205               * ******************************************************************************
27206               *
27207               * Name: PLS5
27208               * Type: Subroutine
27209               * Category: Drawing planets
27210               * Summary: Calculate roofv_x / z and roofv_y / z
27211               *
27212               * ------------------------------------------------------------------------------
27213               *
27214               * Calculate the following divisions of a specified value from one of the
27215               * orientation vectors (in this example, roofv):
27216               *
27217               * (XX16+2 K2+2) = roofv_x / z
27218               *
27219               * (XX16+3 K2+3) = roofv_y / z
27220               *
27221               * ------------------------------------------------------------------------------
27222               *
27223               * Arguments:
27224               *
27225               * X                   Determines which of the INWK orientation vectors to
27226               * divide:
27227               *
27228               * * X = 15: divides roofv_x and roofv_y
27229               *
27230               * * X = 21: divides sidev_x and sidev_y
27231               *
27232               * INWK                The planet's ship data block
27233               *
27234               * ******************************************************************************
27235               
27236               PLS5:
27237 BB7C 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     BB7E B40C     
27238 BB80 06A0  32        bl   @jsr                       ;
     BB82 FE28     
27239 BB84 D80D  30        movb ra,@K2+2                   ; STA K2+2          ;
     BB86 00AE     
27240 BB88 D80F  30        movb ry,@XX16+2                 ; STY XX16+2        ; K+2    = |roofv_x / z|
     BB8A 000B     
27241                                                                          ; XX16+2 = sign of roofv_x / z
27242                                                                          ;
27243                                                                          ; i.e. (XX16+2 K2+2) = roofv_x / z
27244                                                                          ;
27245                                                                          ; and increment X to point to roofv_y for the next call
27246               
27247 BB8C 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     BB8E B40C     
27248 BB90 06A0  32        bl   @jsr                       ;
     BB92 FE28     
27249 BB94 D80D  30        movb ra,@K2+3                   ; STA K2+3          ;
     BB96 00AF     
27250 BB98 D80F  30        movb ry,@XX16+3                 ; STY XX16+3        ; K+3    = |roofv_y / z|
     BB9A 000C     
27251                                                                          ; XX16+3 = sign of roofv_y / z
27252                                                                          ;
27253                                                                          ; i.e. (XX16+3 K2+3) = roofv_y / z
27254                                                                          ;
27255                                                                          ; and increment X to point to roofv_z for the next call
27256               
27257 BB9C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BB9E FE34     
27258               
27259               * ******************************************************************************
27260               *
27261               * Name: PLS6
27262               * Type: Subroutine
27263               * Category: Drawing planets
27264               * Summary: Calculate (X K) = (A P+1 P) / (z_sign z_hi z_lo)
27265               *
27266               * ------------------------------------------------------------------------------
27267               *
27268               * Calculate the following:
27269               *
27270               * (X K) = (A P+1 P) / (z_sign z_hi z_lo)
27271               *
27272               * returning an overflow in the C flag if the result is >= 1024.
27273               *
27274               * ------------------------------------------------------------------------------
27275               *
27276               * Arguments:
27277               *
27278               * INWK                The planet or sun's ship data block
27279               *
27280               * ------------------------------------------------------------------------------
27281               *
27282               * Returns:
27283               *
27284               * C flag              Set if the result >= 1024, clear otherwise
27285               *
27286               * ------------------------------------------------------------------------------
27287               *
27288               * Other entry points:
27289               *
27290               * PL44                Clear the C flag and return from the subroutine
27291               *
27292               * ******************************************************************************
27293               
27294               PLS6:
27295 BBA0 0200  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     BBA2 469C     
27296 BBA4 06A0  32        bl   @jsr                       ;
     BBA6 FE28     
27297                                                                          ;
27298                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
27299               
27300 BBA8 D360  30        movb @K+3,ra                    ; LDA K+3           ; Set A = |K+3| OR K+2
     BBAA 0040     
27301 BBAC 024D  22        andi ra,>7f*256                 ; AND #%01111111
     BBAE 7F00     
27302 BBB0 F360  30        socb @K+2,ra                    ; ORA K+2
     BBB2 003F     
27303               
27304 BBB4 16A8  14        jne  PL21                       ; BNE PL21          ; If A is non-zero then the two high bytes of K(3 2 1 0)
27305                                                                          ; are non-zero, so jump to PL21 to set the C flag and
27306                                                                          ; return from the subroutine
27307               
27308                                                                          ; We can now just consider K(1 0), as we know the top
27309                                                                          ; two bytes of K(3 2 1 0) are both 0
27310               
27311 BBB6 D3A0  30        movb @K+1,rx                    ; LDX K+1           ; Set X = K+1, so now (X K) contains the result in
     BBB8 003E     
27312                                                                          ; K(1 0), which is the format we want to return the
27313                                                                          ; result in
27314               
27315 BBBA 028E  22        ci   rx,>04*256                 ; CPX #4            ; If the high byte of K(1 0) >= 4 then the result is
     BBBC 0400     
27316 BBBE 1818  14        joc  PL6                        ; BCS PL6           ; >= 1024, so return from the subroutine with the C flag
27317                                                                          ; set to indicate an overflow (as PL6 contains an RTS)
27318               
27319 BBC0 D360  30        movb @K+3,ra                    ; LDA K+3           ; Fetch the sign of the result from K+3 (which we know
     BBC2 0040     
27320                                                                          ; has zeroes in bits 0-6, so this just fetches the sign)
27321               
27322               * CLC                    \ This instruction is commented out in the original
27323                                                                          ; source. It would have no effect as we know the C flag
27324                                                                          ; is already clear, as we skipped past the BCS above
27325               
27326 BBC4 1515  14        jgt  PL6                        ; BPL PL6           ; If the sign bit is clear and the result is positive,
27327                                                                          ; then the result is already correct, so return from
27328                                                                          ; the subroutine with the C flag clear to indicate
27329                                                                          ; success (as PL6 contains an RTS)
27330               
27331 BBC6 D360  30        movb @K,ra                      ; LDA K             ; Otherwise we need to negate the result, which we do
     BBC8 003D     
27332                      .eoi (>ff*256)                  ; EOR #%11111111    ; using two's complement, starting with the low byte:
     **** ****     > EOI
0001 BBCA 0200  20        li   rtmp,(>FF*256)
     BBCC FF00     
0002 BBCE 2B40  18        xor  rtmp,ra
                   < elite.a99
27333                      .adi (>01*256)                  ; ADC #1            ;
     **** ****     > ADI
0001 BBD0 1701  14        jnc  !
0002 BBD2 B347  18        ab   rone,ra
0003               !:
0004 BBD4 022D  22        ai   ra,(>01*256)
     BBD6 0100     
                   < elite.a99
27334 BBD8 D80D  30        movb ra,@K                      ; STA K             ; K = ~K + 1
     BBDA 003D     
27335               
27336 BBDC D34E  18        movb rx,ra                      ; TXA               ; And then the high byte:
27337                      .eoi (>ff*256)                  ; EOR #%11111111    ;
     **** ****     > EOI
0001 BBDE 0200  20        li   rtmp,(>FF*256)
     BBE0 FF00     
0002 BBE2 2B40  18        xor  rtmp,ra
                   < elite.a99
27338                      .adi (>00*256)                  ; ADC #0            ; X = ~X
     **** ****     > ADI
0001 BBE4 1701  14        jnc  !
0002 BBE6 B347  18        ab   rone,ra
0003               !:
0004 BBE8 022D  22        ai   ra,(>00*256)
     BBEA 0000     
                   < elite.a99
27339 BBEC D38D  18        movb ra,rx                      ; TAX
27340               
27341               PL44:
27342                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 BBEE 0A16  18        sla  rzero,1
                   < elite.a99
27343               
27344               PL6:
27345 BBF0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BBF2 FE34     
27346               
27347               * ******************************************************************************
27348               *
27349               * Name: TT17
27350               * Type: Subroutine
27351               * Category: Keyboard
27352               * Summary: Scan the keyboard for cursor key or joystick movement
27353               *
27354               * ------------------------------------------------------------------------------
27355               *
27356               * Scan the keyboard and joystick for cursor key or stick movement, and return
27357               * the result as deltas (changes) in x- and y-coordinates as follows:
27358               *
27359               * * For joystick, X and Y are integers between -2 and +2 depending on how far
27360               * the stick has moved
27361               *
27362               * * For keyboard, X and Y are integers between -1 and +1 depending on which
27363               * keys are pressed
27364               *
27365               * ------------------------------------------------------------------------------
27366               *
27367               * Returns:
27368               *
27369               * A                   The key pressed, if the arrow keys were used
27370               *
27371               * X                   Change in the x-coordinate according to the cursor keys
27372               * being pressed or joystick movement, as an integer (see
27373               * above)
27374               *
27375               * Y                   Change in the y-coordinate according to the cursor keys
27376               * being pressed or joystick movement, as an integer (see
27377               * above)
27378               *
27379               * ******************************************************************************
27380               
27381               TT17:
27382 BBF4 0200  20        li   rtmp,DOKEY                 ; JSR DOKEY         ; Scan the keyboard for flight controls and pause keys,
     BBF6 CDB6     
27383 BBF8 06A0  32        bl   @jsr                       ;
     BBFA FE28     
27384                                                                          ; (or the equivalent on joystick) and update the key
27385                                                                          ; logger, setting KL to the key pressed
27386               
27387 BBFC D360  30        movb @JSTK,ra                   ; LDA JSTK          ; If the joystick is not configured, jump down to TJ1,
     BBFE 0F50     
27388 BC00 132D  14        jeq  TJ1                        ; BEQ TJ1           ; otherwise we move the cursor with the joystick
27389               
27390 BC02 D360  30        movb @JSTX,ra                   ; LDA JSTX          ; Fetch the joystick roll, ranging from 1 to 255 with
     BC04 009C     
27391                                                                          ; 128 as the centre point
27392               
27393                      .eoi (>ff*256)                  ; EOR #&FF          ; Flip the sign so A = -JSTX, because the joystick roll
     **** ****     > EOI
0001 BC06 0200  20        li   rtmp,(>FF*256)
     BC08 FF00     
0002 BC0A 2B40  18        xor  rtmp,ra
                   < elite.a99
27394                                                                          ; works in the opposite way to moving a cursor on-screen
27395                                                                          ; in terms of left and right
27396               
27397 BC0C 0200  20        li   rtmp,TJS1                  ; JSR TJS1          ; Call TJS1 just below to set A to a value between -2
     BC0E BC1C     
27398 BC10 06A0  32        bl   @jsr                       ;
     BC12 FE28     
27399                                                                          ; and +2 depending on the joystick roll value (moving
27400                                                                          ; the stick sideways)
27401               
27402 BC14 D34F  18        movb ry,ra                      ; TYA               ; Copy Y to A
27403               
27404 BC16 D38D  18        movb ra,rx                      ; TAX               ; Copy A to X, so X contains the joystick roll value
27405               
27406 BC18 D360  30        movb @JSTY,ra                   ; LDA JSTY          ; Fetch the joystick pitch, ranging from 1 to 255 with
     BC1A 009D     
27407                                                                          ; 128 as the centre point, and fall through into TJS1 to
27408                                                                          ; set Y to the joystick pitch value (moving the stick up
27409                                                                          ; and down)
27410               
27411               TJS1:
27412 BC1C D3CD  18        movb ra,ry                      ; TAY               ; Store A in Y
27413               
27414 BC1E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the result, A = 0
     BC20 0000     
27415               
27416 BC22 028F  22        ci   ry,>10*256                 ; CPY #16           ; If Y >= 16 set the C flag, so A = A - 1
     BC24 1000     
27417                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 BC26 1801  14        joc  !
0002 BC28 7347  18        sb   rone,ra
0003               !:
0004 BC2A 022D  22        ai   ra,-(>00*256)
     BC2C 0000     
                   < elite.a99
27418               
27419               * CPY #&20               \ These instructions are commented out in the original
27420               * SBC #0                 \ source, but they would make the joystick move the
27421                                                                          ; cursor faster by increasing the range of Y by -1 to +1
27422               
27423 BC2E 028F  22        ci   ry,>40*256                 ; CPY #64           ; If Y >= 64 set the C flag, so A = A - 1
     BC30 4000     
27424                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 BC32 1801  14        joc  !
0002 BC34 7347  18        sb   rone,ra
0003               !:
0004 BC36 022D  22        ai   ra,-(>00*256)
     BC38 0000     
                   < elite.a99
27425               
27426 BC3A 028F  22        ci   ry,>c0*256                 ; CPY #192          ; If Y >= 192 set the C flag, so A = A + 1
     BC3C C000     
27427                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 BC3E 1701  14        jnc  !
0002 BC40 B347  18        ab   rone,ra
0003               !:
0004 BC42 022D  22        ai   ra,(>00*256)
     BC44 0000     
                   < elite.a99
27428               
27429 BC46 028F  22        ci   ry,>e0*256                 ; CPY #224          ; If Y >= 224 set the C flag, so A = A + 1
     BC48 E000     
27430                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 BC4A 1701  14        jnc  !
0002 BC4C B347  18        ab   rone,ra
0003               !:
0004 BC4E 022D  22        ai   ra,(>00*256)
     BC50 0000     
                   < elite.a99
27431               
27432               * CPY #&F0               \ These instructions are commented out in the original
27433               * ADC #0                 \ source, but they would make the joystick move the
27434                                                                          ; cursor faster by increasing the range of Y by -1 to +1
27435               
27436 BC52 D3CD  18        movb ra,ry                      ; TAY               ; Copy the value of A into Y
27437               
27438 BC54 D360  30        movb @KL,ra                     ; LDA KL            ; Set A to the value of KL (the key pressed)
     BC56 0041     
27439               
27440 BC58 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BC5A FE34     
27441               
27442               TJ1:
27443 BC5C D360  30        movb @KL,ra                     ; LDA KL            ; Set A to the value of KL (the key pressed)
     BC5E 0041     
27444               
27445 BC60 020E  20        li   rx,>00*256                 ; LDX #0            ; Set the initial values for the results, X = Y = 0,
     BC62 0000     
27446 BC64 020F  20        li   ry,>00*256                 ; LDY #0            ; which we now increase or decrease appropriately
     BC66 0000     
27447               
27448 BC68 028D  22        ci   ra,>19*256                 ; CMP #&19          ; If left arrow was pressed, set X = X - 1
     BC6A 1900     
27449 BC6C 1601  14        jne  B82                        ; BNE B82
27450 BC6E 7387  18        sb   rone,rx                    ; DEX
27451               
27452               B82:
27453 BC70 028D  22        ci   ra,>79*256                 ; CMP #&79          ; If right arrow was pressed, set X = X + 1
     BC72 7900     
27454 BC74 1601  14        jne  B83                        ; BNE B83
27455 BC76 B387  18        ab   rone,rx                    ; INX
27456               
27457               B83:
27458 BC78 028D  22        ci   ra,>39*256                 ; CMP #&39          ; If up arrow was pressed, set Y = Y + 1
     BC7A 3900     
27459 BC7C 1601  14        jne  B84                        ; BNE B84
27460 BC7E B3C7  18        ab   rone,ry                    ; INY
27461               
27462               B84:
27463 BC80 028D  22        ci   ra,>29*256                 ; CMP #&29          ; If down arrow was pressed, set Y = Y - 1
     BC82 2900     
27464 BC84 1601  14        jne  B85                        ; BNE B85
27465 BC86 73C7  18        sb   rone,ry                    ; DEY
27466               
27467               B85:
27468 BC88 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BC8A FE34     
27469               
27470               * ******************************************************************************
27471               *
27472               * Name: ping
27473               * Type: Subroutine
27474               * Category: Universe
27475               * Summary: Set the selected system to the current system
27476               *
27477               * ******************************************************************************
27478               
27479               ping_:
27480 BC8C 020E  20        li   rx,>01*256                 ; LDX #1            ; We want to copy the X- and Y-coordinates of the
     BC8E 0100     
27481                                                                          ; current system in (QQ0, QQ1) to the selected system's
27482                                                                          ; coordinates in (QQ9, QQ10), so set up a counter to
27483                                                                          ; copy two bytes
27484               
27485               pl1_:
27486 BC90 D36E  34        movb @QQ0(rx),ra                ; LDA QQ0,X         ; Load byte X from the current system in QQ0/QQ1
     BC92 0301     
27487               
27488 BC94 DB8D  38        movb ra,@QQ9(rx)                ; STA QQ9,X         ; Store byte X in the selected system in QQ9/QQ10
     BC96 0F31     
27489               
27490 BC98 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
27491               
27492 BC9A 15FA  14        jgt  pl1_                       ; BPL pl1           ; Loop back for the next byte to copy
27493               
27494 BC9C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BC9E FE34     
27495               
27496               * ******************************************************************************
27497               *
27498               * Save ELTE.bin
27499               *
27500               * ******************************************************************************
27501               
27502                      ; PRINT "ELITE E"
27503                      ; PRINT "Assembled at ", ~CODE_E%
27504                      ; PRINT "Ends at ", ~P%
27505                      ; PRINT "Code size is ", ~(P% - CODE_E%)
27506                      ; PRINT "Execute at ", ~LOAD%
27507                      ; PRINT "Reload at ", ~LOAD_E%
27508               
27509                      ; PRINT "S.ELTE ", ~CODE_E%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_E%
27510                      ; SAVE "3-assembled-output/ELTE.bin", CODE_E%, P%, LOAD%
27511               
27512               * ******************************************************************************
27513               *
27514               * ELITE F FILE
27515               *
27516               * Produces the binary file ELTF.bin that gets loaded by elite-bcfs.asm.
27517               *
27518               * ******************************************************************************
27519               
27520               CODE_F.:
27521                      equ $
27522               
27523               LOAD_F.:
27524                      equ LOAD. + $ - CODE.
27525               
27526               * ******************************************************************************
27527               *
27528               * Name: KS3
27529               * Type: Subroutine
27530               * Category: Universe
27531               * Summary: Set the SLSP ship line heap pointer after shuffling ship slots
27532               *
27533               * ------------------------------------------------------------------------------
27534               *
27535               * The final part of the KILLSHP routine, called after we have shuffled the ship
27536               * slots and sorted out our missiles. This simply sets SLSP to the new bottom of
27537               * the ship line heap.
27538               *
27539               * ------------------------------------------------------------------------------
27540               *
27541               * Arguments:
27542               *
27543               * P(1 0)              Points to the ship line heap of the ship in the last
27544               * occupied slot (i.e. it points to the bottom of the
27545               * descending heap)
27546               *
27547               * ******************************************************************************
27548               
27549               KS3:
27550 BCA0 D360  30        movb @P,ra                      ; LDA P             ; After shuffling the ship slots, P(1 0) will point to
     BCA2 001B     
27551 BCA4 D80D  30        movb ra,@SLSP                   ; STA SLSP          ; the new bottom of the ship line heap, so store this in
     BCA6 0F1E     
27552 BCA8 D360  30        movb @P+1,ra                    ; LDA P+1           ; SLSP(1 0), which stores the bottom of the heap
     BCAA 001C     
27553 BCAC D80D  30        movb ra,@SLSP+1                 ; STA SLSP+1
     BCAE 0F1F     
27554               
27555 BCB0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BCB2 FE34     
27556               
27557               * ******************************************************************************
27558               *
27559               * Name: KS1
27560               * Type: Subroutine
27561               * Category: Universe
27562               * Summary: Remove the current ship from our local bubble of universe
27563               *
27564               * ------------------------------------------------------------------------------
27565               *
27566               * Part 12 of the main flight loop calls this routine to remove the ship that is
27567               * currently being analysed by the flight loop. Once the ship is removed, it
27568               * jumps back to MAL1 to rejoin the main flight loop, with X pointing to the
27569               * same slot that we just cleared (and which now contains the next ship in the
27570               * local bubble of universe).
27571               *
27572               * ------------------------------------------------------------------------------
27573               *
27574               * Arguments:
27575               *
27576               * XX0                 The address of the blueprint for this ship
27577               *
27578               * INF                 The address of the data block for this ship
27579               *
27580               * ******************************************************************************
27581               
27582               KS1:
27583 BCB4 D3A0  30        movb @XSAV,rx                   ; LDX XSAV          ; Store the current ship's slot number in XSAV
     BCB6 0093     
27584               
27585 BCB8 0200  20        li   rtmp,KILLSHP               ; JSR KILLSHP       ; Call KILLSHP to remove the ship in slot X from our
     BCBA BD88     
27586 BCBC 06A0  32        bl   @jsr                       ;
     BCBE FE28     
27587                                                                          ; local bubble of universe
27588               
27589 BCC0 D3A0  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the current ship's slot number from XSAV,
     BCC2 0093     
27590                                                                          ; which now points to the next ship in the bubble
27591               
27592 BCC4 0460  24        b    @MAL1                      ; JMP MAL1          ; Jump to MAL1 to rejoin the main flight loop at the
     BCC6 118C     
27593                                                                          ; start of the ship analysis loop
27594               
27595               * ******************************************************************************
27596               *
27597               * Name: KS4
27598               * Type: Subroutine
27599               * Category: Universe
27600               * Summary: Remove the space station and replace it with the sun
27601               *
27602               * ******************************************************************************
27603               
27604               KS4:
27605 BCC8 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     BCCA C064     
27606 BCCC 06A0  32        bl   @jsr                       ;
     BCCE FE28     
27607               
27608 BCD0 0200  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Reset the LSO block, returns with A = 0
     BCD2 ACE6     
27609 BCD4 06A0  32        bl   @jsr                       ;
     BCD6 FE28     
27610               
27611 BCD8 D80D  30        movb ra,@FRIN+1                 ; STA FRIN+1        ; Set the second slot in the FRIN table to 0, which
     BCDA 0D41     
27612                                                                          ; sets this slot to empty, so when we call NWSHP below
27613                                                                          ; the new sun that gets created will go into FRIN+1
27614               
27615 BCDC D80D  30        movb ra,@SSPR                   ; STA SSPR          ; Set the "space station present" flag to 0, as we are
     BCDE 0D55     
27616                                                                          ; no longer in the space station's safe zone
27617               
27618 BCE0 0200  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Call SPBLB to redraw the space station bulb, which
     BCE2 B13E     
27619 BCE4 06A0  32        bl   @jsr                       ;
     BCE6 FE28     
27620                                                                          ; will erase it from the dashboard
27621               
27622 BCE8 020D  20        li   ra,>06*256                 ; LDA #6            ; Set the sun's y_sign to 6
     BCEA 0600     
27623 BCEC D80D  30        movb ra,@INWK+5                 ; STA INWK+5
     BCEE 0058     
27624               
27625 BCF0 020D  20        li   ra,>81*256                 ; LDA #129          ; Set A = 129, the ship type for the sun
     BCF2 8100     
27626               
27627 BCF4 0460  28        b    @NWSHP                     ; JMP NWSHP         ; Call NWSHP to set up the sun's data block and add it
     BCF6 AFC6     
27628                                                                          ; to FRIN, where it will get put in the second slot as
27629                                                                          ; we just cleared out the second slot, and the first
27630                                                                          ; slot is already taken by the planet
27631               
27632               * ******************************************************************************
27633               *
27634               * Name: KS2
27635               * Type: Subroutine
27636               * Category: Universe
27637               * Summary: Check the local bubble for missiles with target lock
27638               *
27639               * ------------------------------------------------------------------------------
27640               *
27641               * Check the local bubble of universe to see if there are any missiles with
27642               * target lock in the vicinity. If there are, then check their targets; if we
27643               * just removed their target in the KILLSHP routine, then switch off their AI so
27644               * they just drift in space, otherwise update their targets to reflect the newly
27645               * shuffled slot numbers.
27646               *
27647               * This is called from KILLSHP once the slots have been shuffled down, following
27648               * the removal of a ship.
27649               *
27650               * ------------------------------------------------------------------------------
27651               *
27652               * Arguments:
27653               *
27654               * XX4                 The slot number of the ship we removed just before
27655               * calling this routine
27656               *
27657               * ******************************************************************************
27658               
27659               KS2:
27660 BCF8 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; We want to go through the ships in our local bubble
     BCFA FF00     
27661                                                                          ; and pick out all the missiles, so set X to &FF to
27662                                                                          ; use as a counter
27663               
27664               KSL4:
27665 BCFC B387  18        ab   rone,rx                    ; INX               ; Increment the counter (so it starts at 0 on the first
27666                                                                          ; iteration)
27667               
27668 BCFE D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; If slot X is empty then we have worked our way through
     BD00 0D40     
27669 BD02 13CE  14        jeq  KS3                        ; BEQ KS3           ; all the slots, so jump to KS3 to stop looking
27670               
27671 BD04 028D  22        ci   ra,(MSL)*256               ; CMP #MSL          ; If the slot does not contain a missile, loop back to
     BD06 0900     
27672 BD08 16F9  14        jne  KSL4                       ; BNE KSL4          ; KSL4 to check the next slot
27673               
27674                                                                          ; We have found a slot containing a missile, so now we
27675                                                                          ; want to check whether it has target lock
27676               
27677 BD0A D34E  18        movb rx,ra                      ; TXA               ; Set Y = X * 2 and fetch the Y-th address from UNIV
27678                      .asla                           ; ASL A             ; and store it in SC and SC+1 - in other words, set
     **** ****     > ASLA
0001 BD0C 024D  22        andi ra,>ff00
     BD0E FF00     
0002 BD10 0A1D  18        sla  ra,1
                   < elite.a99
27679 BD12 D3CD  18        movb ra,ry                      ; TAY               ; SC(1 0) to point to the missile's ship data block
27680 BD14 D36F  34        movb @UNIV(ry),ra               ; LDA UNIV,Y
     BD16 2243     
27681 BD18 D80D  30        movb ra,@SC                     ; STA SC
     BD1A 0007     
27682 BD1C D36F  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y
     BD1E 2244     
27683 BD20 D80D  30        movb ra,@SC+1                   ; STA SC+1
     BD22 0008     
27684               
27685 BD24 020F  20        li   ry,>20*256                 ; LDY #32           ; Fetch byte #32 from the missile's ship data (AI)
     BD26 2000     
27686                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y
     **** ****     > LD_IND_Y_IDX
0001 BD28 D820  42        movb @SC,@rtmplb
     BD2A 0007     
     BD2C 8301     
0002 BD2E D020  30        movb @SC+1,rtmp
     BD30 0008     
0003 BD32 06CF  14        swpb ry
0004 BD34 A00F  18        a    ry,rtmp
0005 BD36 06CF  14        swpb ry
0006 BD38 D350  26        movb *rtmp,RA
                   < elite.a99
27687               
27688 BD3A 15E0  14        jgt  KSL4                       ; BPL KSL4          ; If bit 7 of byte #32 is clear, then the missile is
27689                                                                          ; dumb and has no AI, so loop back to KSL4 to move on
27690                                                                          ; to the next slot
27691               
27692 BD3C 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Otherwise this missile has AI, so clear bit 7 and
     BD3E 7F00     
27693 BD40 091D  18        srl  ra,1                       ; LSR A             ; shift right to set the C flag to the missile's "is
27694                                                                          ; locked" flag, and A to the target's slot number
27695               
27696 BD42 9360  30        cb   @XX4,ra                    ; CMP XX4           ; If this missile's target is less than XX4, then the
     BD44 00A7     
27697 BD46 17DA  14        jnc  KSL4                       ; BCC KSL4          ; target's slot isn't being shuffled down, so jump to
27698                                                                          ; KSL4 to move on to the next slot
27699               
27700 BD48 1313  14        jeq  KS6                        ; BEQ KS6           ; If this missile was locked onto the ship that we just
27701                                                                          ; removed in KILLSHP, jump to KS6 to stop the missile
27702                                                                          ; from continuing to hunt it down
27703               
27704                      .sbi (>01*256)                  ; SBC #1            ; Otherwise this missile is locked and has AI enabled,
     **** ****     > SBI
0001 BD4A 1801  14        joc  !
0002 BD4C 7347  18        sb   rone,ra
0003               !:
0004 BD4E 022D  22        ai   ra,-(>01*256)
     BD50 FF00     
                   < elite.a99
27705                                                                          ; and its target will have moved down a slot, so
27706                                                                          ; subtract 1 from the target number (we know C is set
27707                                                                          ; from the BCC above)
27708               
27709                      .asla                           ; ASL A             ; Shift the target number left by 1, so it's in bits
     **** ****     > ASLA
0001 BD52 024D  22        andi ra,>ff00
     BD54 FF00     
0002 BD56 0A1D  18        sla  ra,1
                   < elite.a99
27710                                                                          ; 1-6 once again, and also set bit 0 to 1, as the C
27711                                                                          ; flag is still set, so this makes sure the missile is
27712                                                                          ; still set to being locked
27713               
27714 BD58 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7, so the missile's AI is enabled
     BD5A 8000     
27715               
27716                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Update the missile's AI flag to the value in A
     **** ****     > ST_IND_Y_IDX
0001 BD5C D820  42        movb @SC,@rtmplb
     BD5E 0007     
     BD60 8301     
0002 BD62 D020  30        movb @SC+1,rtmp
     BD64 0008     
0003 BD66 06CF  14        swpb ry
0004 BD68 A00F  18        a    ry,rtmp
0005 BD6A 06CF  14        swpb ry
0006 BD6C D40D  30        movb RA,*rtmp
                   < elite.a99
27717               
27718 BD6E 16C6  14        jne  KSL4                       ; BNE KSL4          ; Loop back to KSL4 to move on to the next slot (this
27719                                                                          ; BNE is effectively a JMP as A will never be zero)
27720               
27721               KS6:
27722 BD70 020D  20        li   ra,>00*256                 ; LDA #0            ; The missile's target lock just got removed, so set the
     BD72 0000     
27723                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; AI flag to 0 to make it dumb and not locked
     **** ****     > ST_IND_Y_IDX
0001 BD74 D820  42        movb @SC,@rtmplb
     BD76 0007     
     BD78 8301     
0002 BD7A D020  30        movb @SC+1,rtmp
     BD7C 0008     
0003 BD7E 06CF  14        swpb ry
0004 BD80 A00F  18        a    ry,rtmp
0005 BD82 06CF  14        swpb ry
0006 BD84 D40D  30        movb RA,*rtmp
                   < elite.a99
27724               
27725 BD86 13BA  14        jeq  KSL4                       ; BEQ KSL4          ; Loop back to KSL4 to move on to the next slot (this
27726                                                                          ; BEQ is effectively a JMP as A is always zero)
27727               
27728               * ******************************************************************************
27729               *
27730               * Name: KILLSHP
27731               * Type: Subroutine
27732               * Category: Universe
27733               * Summary: Remove a ship from our local bubble of universe
27734               *
27735               * ------------------------------------------------------------------------------
27736               *
27737               * Remove the ship in slot X from our local bubble of universe. This happens
27738               * when we kill a ship, collide with a ship and destroy it, or when a ship moves
27739               * outside our local bubble.
27740               *
27741               * We also use this routine when we move out of range of the space station, in
27742               * which case we replace it with the sun.
27743               *
27744               * When removing a ship, this creates a gap in the ship slots at FRIN, so we
27745               * shuffle all the later slots down to close the gap. We also shuffle the ship
27746               * data blocks at K% and ship line heap at WP, to reclaim all the memory that
27747               * the removed ship used to occupy.
27748               *
27749               * ------------------------------------------------------------------------------
27750               *
27751               * Arguments:
27752               *
27753               * X                   The slot number of the ship to remove
27754               *
27755               * XX0                 The address of the blueprint for the ship to remove
27756               *
27757               * INF                 The address of the data block for the ship to remove
27758               *
27759               * ******************************************************************************
27760               
27761               KILLSHP:
27762 BD88 D80E  30        movb rx,@XX4                    ; STX XX4           ; Store the slot number of the ship to remove in XX4
     BD8A 00A7     
27763               
27770               
27771 BD8C 93A0  30        cb   @MSTG,rx                   ; CPX MSTG          ; Check whether this slot matches the slot number in
     BD8E 0052     
27772                                                                          ; MSTG, which is the target of our missile lock
27773                                                                          ;
27774                                                                          ; This instructions saves two bytes of memory over the
27775                                                                          ; LDA and CMP-based code in the source disc version, as
27776                                                                          ; CPX MSTG is a two-byte opcode, while LDA MSTG and
27777                                                                          ; CMP XX4 take up four bytes between them (the code does
27778                                                                          ; the same thing)
27779               
27781               
27782 BD90 160C  14        jne  KS5                        ; BNE KS5           ; If our missile is not locked on this ship, jump to KS5
27783               
27784 BD92 020F  20        li   ry,>ee*256                 ; LDY #&EE          ; Otherwise we need to remove our missile lock, so call
     BD94 EE00     
27785 BD96 0200  20        li   rtmp,ABORT                 ; JSR ABORT         ; ABORT to disarm the missile and update the missile
     BD98 B0FE     
27786 BD9A 06A0  32        bl   @jsr                       ;
     BD9C FE28     
27787                                                                          ; indicators on the dashboard to green/cyan (Y = &EE)
27788               
27789 BD9E 020D  20        li   ra,>c8*256                 ; LDA #200          ; Print recursive token 40 ("TARGET LOST") as an
     BDA0 C800     
27790 BDA2 0200  20        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     BDA4 CF0E     
27791 BDA6 06A0  32        bl   @jsr                       ;
     BDA8 FE28     
27792               
27793               KS5:
27794 BDAA D3E0  30        movb @XX4,ry                    ; LDY XX4           ; Restore the slot number of the ship to remove into Y
     BDAC 00A7     
27795               
27796 BDAE D3AF  34        movb @FRIN(ry),rx               ; LDX FRIN,Y        ; Fetch the contents of the slot, which contains the
     BDB0 0D40     
27797                                                                          ; ship type
27798               
27799 BDB2 028E  22        ci   rx,(SST)*256               ; CPX #SST          ; If this is the space station, then jump to KS4 to
     BDB4 0800     
27800 BDB6 1388  14        jeq  KS4                        ; BEQ KS4           ; replace the space station with the sun
27801               
27802 BDB8 7347  18        sb   rone,ra                    ; DEC MANY,X        ; Decrease the number of this type of ship in our little
27803                                                                          ; bubble, which is stored in MANY+X (where X is the ship
27804                                                                          ; type)
27805               
27806 BDBA D3A0  30        movb @XX4,rx                    ; LDX XX4           ; Restore the slot number of the ship to remove into X
     BDBC 00A7     
27807               
27808                                                                          ; We now want to remove this ship and reclaim all the
27809                                                                          ; memory that it uses. Removing the ship will leave a
27810                                                                          ; gap in three places, which we need to close up:
27811                                                                          ;
27812                                                                          ; * The ship slots in FRIN
27813                                                                          ;
27814                                                                          ; * The ship data blocks in K%
27815                                                                          ;
27816                                                                          ; * The descending ship line heap at WP down
27817                                                                          ;
27818                                                                          ; The rest of this routine closes up these gaps by
27819                                                                          ; looping through all the occupied ship slots after the
27820                                                                          ; slot we are removing, one by one, and shuffling each
27821                                                                          ; ship's slot, data block and line heap down to close
27822                                                                          ; up the gaps left by the removed ship. As part of this,
27823                                                                          ; we have to make sure we update any address pointers
27824                                                                          ; so they point to the newly shuffled data blocks and
27825                                                                          ; line heaps
27826                                                                          ;
27827                                                                          ; In the following, when shuffling a ship's data down
27828                                                                          ; into the preceding empty slot, we call the ship that
27829                                                                          ; we are shuffling down the "source", and we call the
27830                                                                          ; empty slot we are shuffling it into the "destination"
27831                                                                          ;
27832                                                                          ; Before we start looping through the ships we need to
27833                                                                          ; shuffle down, we need to set up some variables to
27834                                                                          ; point to the source and destination line heaps
27835               
27836 BDBE 020F  20        li   ry,>05*256                 ; LDY #5            ; Fetch byte #5 of the removed ship's blueprint into A,
     BDC0 0500     
27837                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; which gives the ship's maximum heap size for the ship
     **** ****     > LD_IND_Y_IDX
0001 BDC2 D820  42        movb @XX0,@rtmplb
     BDC4 001E     
     BDC6 8301     
0002 BDC8 D020  30        movb @XX0+1,rtmp
     BDCA 001F     
0003 BDCC 06CF  14        swpb ry
0004 BDCE A00F  18        a    ry,rtmp
0005 BDD0 06CF  14        swpb ry
0006 BDD2 D350  26        movb *rtmp,RA
                   < elite.a99
27838                                                                          ; we are removing (i.e. the size of the gap in the heap
27839                                                                          ; created by the ship removal)
27840               
27841                                                                          ; INF currently contains the ship data for the ship we
27842                                                                          ; are removing, and INF(34 33) contains the address of
27843                                                                          ; the bottom of the ship's heap, so we can calculate
27844                                                                          ; the address of the top of the heap by adding the heap
27845                                                                          ; size to this address
27846               
27847 BDD4 020F  20        li   ry,>21*256                 ; LDY #33           ; First we add A and the address in INF+33, to get the
     BDD6 2100     
27848                      .clc                            ; CLC               ; low byte of the top of the heap, which we store in P
     **** ****     > CLC
0001 BDD8 0A16  18        sla  rzero,1
                   < elite.a99
27849                      .adc_ind_y_idx @INF,ra          ; ADC (INF),Y
     **** ****     > ADC_IND_Y_IDX
0001 BDDA 04CD  14        clr  ra
0002 BDDC 1701  14        jnc  !
0003 BDDE B347  18        ab   rone,ra
0004               !:
0005 BDE0 D820  42        movb @INF,@rtmplb
     BDE2 0020     
     BDE4 8301     
0006 BDE6 D020  30        movb @INF+1,rtmp
     BDE8 0021     
0007 BDEA 06CF  14        swpb ry
0008 BDEC A00F  18        a    ry,rtmp
0009 BDEE 06CF  14        swpb ry
0010 BDF0 B350  26        ab   *rtmp,ra
                   < elite.a99
27850 BDF2 D80D  30        movb ra,@P                      ; STA P
     BDF4 001B     
27851               
27852 BDF6 B3C7  18        ab   rone,ry                    ; INY               ; And next we add A and the address in INF+34, with any
27853                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; carry from the previous addition, to get the high byte
     **** ****     > LD_IND_Y_IDX
0001 BDF8 D820  42        movb @INF,@rtmplb
     BDFA 0020     
     BDFC 8301     
0002 BDFE D020  30        movb @INF+1,rtmp
     BE00 0021     
0003 BE02 06CF  14        swpb ry
0004 BE04 A00F  18        a    ry,rtmp
0005 BE06 06CF  14        swpb ry
0006 BE08 D350  26        movb *rtmp,RA
                   < elite.a99
27854                      .adi (>00*256)                  ; ADC #0            ; of the top of the heap, which we store in P+1, so
     **** ****     > ADI
0001 BE0A 1701  14        jnc  !
0002 BE0C B347  18        ab   rone,ra
0003               !:
0004 BE0E 022D  22        ai   ra,(>00*256)
     BE10 0000     
                   < elite.a99
27855 BE12 D80D  30        movb ra,@P+1                    ; STA P+1           ; P(1 0) points to the top of this ship's heap
     BE14 001C     
27856               
27857                                                                          ; Now, we're ready to start looping through the ships
27858                                                                          ; we want to move, moving the slots, data blocks and
27859                                                                          ; line heap from the source to the destination. In the
27860                                                                          ; following, we set up SC to point to the source data,
27861                                                                          ; and INF (which currently points to the removed ship's
27862                                                                          ; data that we can now overwrite) points to the
27863                                                                          ; destination
27864                                                                          ;
27865                                                                          ; So P(1 0) now points to the top of the line heap for
27866                                                                          ; the destination
27867               
27868               KSL1:
27869 BE16 B387  18        ab   rone,rx                    ; INX               ; On entry, X points to the empty slot we want to
27870                                                                          ; shuffle the next ship into (the destination), so
27871                                                                          ; this increment points X to the next slot - i.e. the
27872                                                                          ; source slot we want to shuffle down
27873               
27874 BE18 D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Copy the contents of the source slot into the
     BE1A 0D40     
27875 BE1C DB8D  38        movb ra,@FRIN-1(rx)             ; STA FRIN-1,X      ; destination slot
     BE1E 0D3F     
27876               
27877 BE20 1602  14        jne  FIX009                     ; BNE FIX009        ; If the slot we just shuffled down contains 0, then
27878 BE22 0460  28        b    @KS2                       ; JMP KS2           ; the source slot is empty and we are done shuffling,
     BE24 BCF8     
27879                                                                          ; so jump to KS2 to move on to processing missiles
27880               FIX009:
27881                      .asla                           ; ASL A             ; Otherwise we have a source ship to shuffle down into
     **** ****     > ASLA
0001 BE26 024D  22        andi ra,>ff00
     BE28 FF00     
0002 BE2A 0A1D  18        sla  ra,1
                   < elite.a99
27882 BE2C D3CD  18        movb ra,ry                      ; TAY               ; the destination, so set Y = A * 2 so it can act as an
27883                                                                          ; index into the two-byte ship blueprint lookup table
27884                                                                          ; at XX21 for the source ship
27885               
27886 BE2E D36F  34        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; Set SC(0 1) to point to the blueprint data for the
     BE30 E95C     
27887 BE32 D80D  30        movb ra,@SC                     ; STA SC            ; source ship
     BE34 0007     
27888 BE36 D36F  34        movb @XX21-1(ry),ra             ; LDA XX21-1,Y
     BE38 E95D     
27889 BE3A D80D  30        movb ra,@SC+1                   ; STA SC+1
     BE3C 0008     
27890               
27891 BE3E 020F  20        li   ry,>05*256                 ; LDY #5            ; Fetch blueprint byte #5 for the source ship, which
     BE40 0500     
27892                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; gives us its maximum heap size, and store it in T
     **** ****     > LD_IND_Y_IDX
0001 BE42 D820  42        movb @SC,@rtmplb
     BE44 0007     
     BE46 8301     
0002 BE48 D020  30        movb @SC+1,rtmp
     BE4A 0008     
0003 BE4C 06CF  14        swpb ry
0004 BE4E A00F  18        a    ry,rtmp
0005 BE50 06CF  14        swpb ry
0006 BE52 D350  26        movb *rtmp,RA
                   < elite.a99
27893 BE54 D80D  30        movb ra,@T                      ; STA T
     BE56 00D1     
27894               
27895                                                                          ; We now subtract T from P(1 0), so P(1 0) will point to
27896                                                                          ; the bottom of the line heap for the destination
27897                                                                          ; (which we will use later when closing up the gap in
27898                                                                          ; the heap space)
27899               
27900 BE58 D360  30        movb @P,ra                      ; LDA P             ; First, we subtract the low bytes
     BE5A 001B     
27901                      .sec                            ; SEC
     **** ****     > SEC
0001 BE5C 0A18  18        sla  rmone,1
                   < elite.a99
27902                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 BE5E 1801  14        joc  !
0002 BE60 7347  18        sb   rone,ra
0003               !:
0004 BE62 7360  30        sb   @T,ra
     BE64 00D1     
                   < elite.a99
27903 BE66 D80D  30        movb ra,@P                      ; STA P
     BE68 001B     
27904               
27905 BE6A D360  30        movb @P+1,ra                    ; LDA P+1           ; And then we do the high bytes, for which we subtract
     BE6C 001C     
27906                      .sbi (>00*256)                  ; SBC #0            ; 0 to include any carry, so this is effectively doing
     **** ****     > SBI
0001 BE6E 1801  14        joc  !
0002 BE70 7347  18        sb   rone,ra
0003               !:
0004 BE72 022D  22        ai   ra,-(>00*256)
     BE74 0000     
                   < elite.a99
27907 BE76 D80D  30        movb ra,@P+1                    ; STA P+1           ; P(1 0) = P(1 0) - (0 T)
     BE78 001C     
27908               
27909                                                                          ; Next, we want to set SC(1 0) to point to the source
27910                                                                          ; ship's data block
27911               
27912 BE7A D34E  18        movb rx,ra                      ; TXA               ; Set Y = X * 2 so it can act as an index into the
27913                      .asla                           ; ASL A             ; two-byte lookup table at UNIV, which contains the
     **** ****     > ASLA
0001 BE7C 024D  22        andi ra,>ff00
     BE7E FF00     
0002 BE80 0A1D  18        sla  ra,1
                   < elite.a99
27914 BE82 D3CD  18        movb ra,ry                      ; TAY               ; addresses of the ship data blocks. In this case we are
27915                                                                          ; multiplying X by 2, and X contains the source ship's
27916                                                                          ; slot number so Y is now an index for the source ship's
27917                                                                          ; entry in UNIV
27918               
27919 BE84 D36F  34        movb @UNIV(ry),ra               ; LDA UNIV,Y        ; Set SC(1 0) to the address of the data block for the
     BE86 2243     
27920 BE88 D80D  30        movb ra,@SC                     ; STA SC            ; source ship
     BE8A 0007     
27921 BE8C D36F  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y
     BE8E 2244     
27922 BE90 D80D  30        movb ra,@SC+1                   ; STA SC+1
     BE92 0008     
27923               
27924                                                                          ; We have now set up our variables as follows:
27925                                                                          ;
27926                                                                          ; SC(1 0) points to the source's ship data block
27927                                                                          ;
27928                                                                          ; INF(1 0) points to the destination's ship data block
27929                                                                          ;
27930                                                                          ; P(1 0) points to the destination's line heap
27931                                                                          ;
27932                                                                          ; so let's start copying data from the source to the
27933                                                                          ; destination
27934               
27935 BE94 020F  20        li   ry,>23*256                 ; LDY #35           ; We are going to be using Y as a counter for the 36
     BE96 2300     
27936                                                                          ; bytes of ship data we want to copy from the source
27937                                                                          ; to the destination, so we set it to 35 to start things
27938                                                                          ; off, and will decrement Y for each byte we copy
27939               
27940                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; Fetch byte #35 of the source's ship data block at SC,
     **** ****     > LD_IND_Y_IDX
0001 BE98 D820  42        movb @SC,@rtmplb
     BE9A 0007     
     BE9C 8301     
0002 BE9E D020  30        movb @SC+1,rtmp
     BEA0 0008     
0003 BEA2 06CF  14        swpb ry
0004 BEA4 A00F  18        a    ry,rtmp
0005 BEA6 06CF  14        swpb ry
0006 BEA8 D350  26        movb *rtmp,RA
                   < elite.a99
27941                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; and store it in byte #35 of the destination's block
     **** ****     > ST_IND_Y_IDX
0001 BEAA D820  42        movb @INF,@rtmplb
     BEAC 0020     
     BEAE 8301     
0002 BEB0 D020  30        movb @INF+1,rtmp
     BEB2 0021     
0003 BEB4 06CF  14        swpb ry
0004 BEB6 A00F  18        a    ry,rtmp
0005 BEB8 06CF  14        swpb ry
0006 BEBA D40D  30        movb RA,*rtmp
                   < elite.a99
27942                                                                          ; at INF, so that's the ship's energy copied from the
27943                                                                          ; source to the destination. One down, quite a few to
27944                                                                          ; go...
27945               
27946 BEBC 73C7  18        sb   rone,ry                    ; DEY               ; Fetch byte #34 of the source ship, which is the
27947                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; high byte of the source ship's line heap, and store
     **** ****     > LD_IND_Y_IDX
0001 BEBE D820  42        movb @SC,@rtmplb
     BEC0 0007     
     BEC2 8301     
0002 BEC4 D020  30        movb @SC+1,rtmp
     BEC6 0008     
0003 BEC8 06CF  14        swpb ry
0004 BECA A00F  18        a    ry,rtmp
0005 BECC 06CF  14        swpb ry
0006 BECE D350  26        movb *rtmp,RA
                   < elite.a99
27948 BED0 D80D  30        movb ra,@K+1                    ; STA K+1           ; in K+1
     BED2 003E     
27949               
27950 BED4 D360  30        movb @P+1,ra                    ; LDA P+1           ; Set the low byte of the destination's heap pointer
     BED6 001C     
27951                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; to P+1
     **** ****     > ST_IND_Y_IDX
0001 BED8 D820  42        movb @INF,@rtmplb
     BEDA 0020     
     BEDC 8301     
0002 BEDE D020  30        movb @INF+1,rtmp
     BEE0 0021     
0003 BEE2 06CF  14        swpb ry
0004 BEE4 A00F  18        a    ry,rtmp
0005 BEE6 06CF  14        swpb ry
0006 BEE8 D40D  30        movb RA,*rtmp
                   < elite.a99
27952               
27953 BEEA 73C7  18        sb   rone,ry                    ; DEY               ; Fetch byte #33 of the source ship, which is the
27954                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; low byte of the source ship's heap, and store in K
     **** ****     > LD_IND_Y_IDX
0001 BEEC D820  42        movb @SC,@rtmplb
     BEEE 0007     
     BEF0 8301     
0002 BEF2 D020  30        movb @SC+1,rtmp
     BEF4 0008     
0003 BEF6 06CF  14        swpb ry
0004 BEF8 A00F  18        a    ry,rtmp
0005 BEFA 06CF  14        swpb ry
0006 BEFC D350  26        movb *rtmp,RA
                   < elite.a99
27955 BEFE D80D  30        movb ra,@K                      ; STA K             ; so now we have the following:
     BF00 003D     
27956                                                                          ;
27957                                                                          ; K(1 0) points to the source's line heap
27958               
27959 BF02 D360  30        movb @P,ra                      ; LDA P             ; Set the low byte of the destination's heap pointer
     BF04 001B     
27960                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; to P, so now the destination's heap pointer is to
     **** ****     > ST_IND_Y_IDX
0001 BF06 D820  42        movb @INF,@rtmplb
     BF08 0020     
     BF0A 8301     
0002 BF0C D020  30        movb @INF+1,rtmp
     BF0E 0021     
0003 BF10 06CF  14        swpb ry
0004 BF12 A00F  18        a    ry,rtmp
0005 BF14 06CF  14        swpb ry
0006 BF16 D40D  30        movb RA,*rtmp
                   < elite.a99
27961                                                                          ; P(1 0), so that's the heap pointer in bytes #33 and
27962                                                                          ; #34 done
27963               
27964 BF18 73C7  18        sb   rone,ry                    ; DEY               ; Luckily, we can just copy the rest of the source's
27965                                                                          ; ship data block into the destination, as there are no
27966                                                                          ; more address pointers, so first we decrement our
27967                                                                          ; counter in Y to point to the next byte (the AI flag)
27968                                                                          ; in byte #32) and then start looping
27969               
27970               KSL2:
27971                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; Copy the Y-th byte of the source to the Y-th byte of
     **** ****     > LD_IND_Y_IDX
0001 BF1A D820  42        movb @SC,@rtmplb
     BF1C 0007     
     BF1E 8301     
0002 BF20 D020  30        movb @SC+1,rtmp
     BF22 0008     
0003 BF24 06CF  14        swpb ry
0004 BF26 A00F  18        a    ry,rtmp
0005 BF28 06CF  14        swpb ry
0006 BF2A D350  26        movb *rtmp,RA
                   < elite.a99
27972                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; the destination
     **** ****     > ST_IND_Y_IDX
0001 BF2C D820  42        movb @INF,@rtmplb
     BF2E 0020     
     BF30 8301     
0002 BF32 D020  30        movb @INF+1,rtmp
     BF34 0021     
0003 BF36 06CF  14        swpb ry
0004 BF38 A00F  18        a    ry,rtmp
0005 BF3A 06CF  14        swpb ry
0006 BF3C D40D  30        movb RA,*rtmp
                   < elite.a99
27973               
27974 BF3E 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter
27975               
27976 BF40 15EC  14        jgt  KSL2                       ; BPL KSL2          ; Loop back to KSL2 to copy the next byte until we have
27977                                                                          ; copied the whole block
27978               
27979                                                                          ; We have now shuffled the ship's slot and the ship's
27980                                                                          ; data block, so we only have the heap data itself to do
27981               
27982 BF42 D360  30        movb @SC,ra                     ; LDA SC            ; First, we copy SC into INF, so when we loop round
     BF44 0007     
27983 BF46 D80D  30        movb ra,@INF                    ; STA INF           ; again, INF will correctly point to the destination for
     BF48 0020     
27984 BF4A D360  30        movb @SC+1,ra                   ; LDA SC+1          ; the next iteration
     BF4C 0008     
27985 BF4E D80D  30        movb ra,@INF+1                  ; STA INF+1
     BF50 0021     
27986               
27987 BF52 D3E0  30        movb @T,ry                      ; LDY T             ; Now we want to move the contents of the heap, as all
     BF54 00D1     
27988                                                                          ; we did above was to update the pointers, so first
27989                                                                          ; we set a counter in Y that is initially set to T
27990                                                                          ; (which we set above to the maximum heap size for the
27991                                                                          ; source ship)
27992                                                                          ;
27993                                                                          ; As a reminder, we have already set the following:
27994                                                                          ;
27995                                                                          ; K(1 0) points to the source's line heap
27996                                                                          ;
27997                                                                          ; P(1 0) points to the destination's line heap
27998                                                                          ;
27999                                                                          ; so we can move the heap data by simply copying the
28000                                                                          ; correct number of bytes from K(1 0) to P(1 0)
28001               KSL3:
28002 BF56 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter
28003               
28004                      .ld_ind_y_idx @K,ra             ; LDA (K),Y         ; Copy the Y-th byte of the source heap at K(1 0) to
     **** ****     > LD_IND_Y_IDX
0001 BF58 D820  42        movb @K,@rtmplb
     BF5A 003D     
     BF5C 8301     
0002 BF5E D020  30        movb @K+1,rtmp
     BF60 003E     
0003 BF62 06CF  14        swpb ry
0004 BF64 A00F  18        a    ry,rtmp
0005 BF66 06CF  14        swpb ry
0006 BF68 D350  26        movb *rtmp,RA
                   < elite.a99
28005                      .st_ind_y_idx @P,ra             ; STA (P),Y         ; the destination heap at P(1 0)
     **** ****     > ST_IND_Y_IDX
0001 BF6A D820  42        movb @P,@rtmplb
     BF6C 001B     
     BF6E 8301     
0002 BF70 D020  30        movb @P+1,rtmp
     BF72 001C     
0003 BF74 06CF  14        swpb ry
0004 BF76 A00F  18        a    ry,rtmp
0005 BF78 06CF  14        swpb ry
0006 BF7A D40D  30        movb RA,*rtmp
                   < elite.a99
28006               
28007 BF7C D34F  18        movb ry,ra                      ; TYA               ; Loop back to KSL3 to copy the next byte, until we
28008 BF7E 16EB  14        jne  KSL3                       ; BNE KSL3          ; have done them all
28009               
28010 BF80 1602  14        jne  FIX010                     ; BNE FIX010        ; We have now shuffled everything down one slot, so
28011 BF82 0460  28        b    @KSL1                      ; JMP KSL1          ; jump back up to KSL1 to see if there is another slot
     BF84 BE16     
28012                                                                          ; that needs shuffling down (this BEQ is effectively a
28013                                                                          ; JMP as A will always be zero)
28014               FIX010:
28015               * ******************************************************************************
28016               *
28017               * Name: SFX
28018               * Type: Variable
28019               * Category: Sound
28020               * Summary: Sound data
28021               *
28022               * ------------------------------------------------------------------------------
28023               *
28024               * Sound data. To make a sound, the NOS1 routine copies the four relevant sound
28025               * bytes to XX16, and NO3 then makes the sound. The sound numbers are shown in
28026               * the table, and are always multiples of 8. Generally, sounds are made by
28027               * calling the NOISE routine with the sound number in A.
28028               *
28029               * These bytes are passed to OSWORD 7, and are the equivalents to the parameters
28030               * passed to the SOUND keyword in BASIC. The parameters therefore have these
28031               * meanings:
28032               *
28033               * channel/flush, amplitude (or envelope number if 1-4), pitch, duration
28034               *
28035               * For the channel/flush parameter, the high nibble of the low byte is the flush
28036               * control (where a flush control of 0 queues the sound, and a flush control of
28037               * 1 makes the sound instantly), while the low nibble of the low byte is the
28038               * channel number. When written in hexadecimal, the first figure gives the flush
28039               * control, while the second is the channel (so &13 indicates flush control = 1
28040               * and channel = 3).
28041               *
28042               * So when we call NOISE with A = 40 to make a long, low beep, then this is
28043               * effectively what the NOISE routine does:
28044               *
28045               * SOUND &13, &F4, &0C, &08
28046               *
28047               * which makes a sound with flush control 1 on channel 3, and with amplitude &F4
28048               * (-12), pitch &0C (2) and duration &08 (8). Meanwhile, to make the hyperspace
28049               * sound, the NOISE routine does this:
28050               *
28051               * SOUND &10, &02, &60, &10
28052               *
28053               * which makes a sound with flush control 1 on channel 0, using envelope 2,
28054               * and with pitch &60 (96) and duration &10 (16). The four sound envelopes (1-4)
28055               * are set up by the loading process.
28056               *
28057               * ******************************************************************************
28058                      equ  $
28059               SFX:
28060 BF86 1201            byte >12,>01,>00,>10                                ; 0  - Lasers fired by us
     BF88 0010     
28061 BF8A 1202            byte >12,>02,>2c,>08                                ; 8  - We're being hit by lasers
     BF8C 2C08     
28062 BF8E 1103            byte >11,>03,>f0,>18                                ; 16 - We died 1 / We made a hit or kill 2
     BF90 F018     
28063 BF92 10F1            byte >10,>f1,>07,>1a                                ; 24 - We died 2 / We made a hit or kill 1
     BF94 071A     
28064 BF96 03F1            byte >03,>f1,>bc,>01                                ; 32 - Short, high beep
     BF98 BC01     
28065 BF9A 13F4            byte >13,>f4,>0c,>08                                ; 40 - Long, low beep
     BF9C 0C08     
28066 BF9E 10F1            byte >10,>f1,>06,>0c                                ; 48 - Missile launched / Ship launched from station
     BFA0 060C     
28067 BFA2 1002            byte >10,>02,>60,>10                                ; 56 - Hyperspace drive engaged
     BFA4 6010     
28068 BFA6 1304            byte >13,>04,>c2,>ff                                ; 64 - E.C.M. on
     BFA8 C2FF     
28069 BFAA 1300            byte >13,>00,>00,>00                                ; 72 - E.C.M. off
     BFAC 0000     
28070               
28071               * ******************************************************************************
28072               *
28073               * Name: RESET
28074               * Type: Subroutine
28075               * Category: Start and end
28076               * Summary: Reset most variables
28077               *
28078               * ------------------------------------------------------------------------------
28079               *
28080               * Reset our ship and various controls, recharge shields and energy, and then
28081               * fall through into RES2 to reset the stardust and the ship workspace at INWK.
28082               *
28083               * In this subroutine, this means zero-filling the following locations:
28084               *
28085               * * Pages &9, &A, &B, &C and &D
28086               *
28087               * * BETA to BETA+6, which covers the following:
28088               *
28089               * * BETA, BET1 - Set pitch to 0
28090               *
28091               * * XC, YC - Set text cursor to (0, 0)
28092               *
28093               * * QQ22 - Set hyperspace counters to 0
28094               *
28095               * * ECMA - Turn E.C.M. off
28096               *
28097               * It also sets QQ12 to &FF, to indicate we are docked, recharges the shields and
28098               * energy banks, and then falls through into RES2.
28099               *
28100               * ------------------------------------------------------------------------------
28101               *
28102               * Other entry points:
28103               *
28104               * RES4                Reset the shields and energy banks, then fall through
28105               * into RES2 to reset the stardust and the ship workspace
28106               * at INWK
28107               *
28108               * ******************************************************************************
28109               
28110               RESET:
28111 BFAE 0200  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     BFB0 C8B2     
28112 BFB2 06A0  32        bl   @jsr                       ;
     BFB4 FE28     
28113                                                                          ; the ship data blocks, the ship line heap, the ship
28114                                                                          ; slots for the local bubble of universe, and various
28115                                                                          ; flight and ship status variables
28116               
28117 BFB6 020E  20        li   rx,>06*256                 ; LDX #6            ; Set up a counter for zeroing BETA through BETA+6
     BFB8 0600     
28118               
28119               SAL3:
28120 BFBA DB8D  38        movb ra,@BETA(rx)               ; STA BETA,X        ; Zero the X-th byte after BETA
     BFBC 002A     
28121               
28122 BFBE 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
28123               
28124 BFC0 15FC  14        jgt  SAL3                       ; BPL SAL3          ; Loop back for the next byte to zero
28125               
28126 BFC2 D80E  30        movb rx,@QQ12                   ; STX QQ12          ; X is now negative - i.e. &FF - so this sets QQ12 to
     BFC4 009F     
28127                                                                          ; &FF to indicate we are docked
28128               
28129                                                                          ; We now fall through into RES4 to restore shields and
28130                                                                          ; energy, and reset the stardust and ship workspace at
28131                                                                          ; INWK
28132               
28133               RES4:
28134 BFC6 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to &FF so we can fill up the shields and energy
     BFC8 FF00     
28135                                                                          ; bars with a full charge
28136               
28137 BFCA 020E  20        li   rx,>02*256                 ; LDX #2            ; We're now going to recharge both shields and the
     BFCC 0200     
28138                                                                          ; energy bank, which live in the three bytes at FSH,
28139                                                                          ; ASH (FSH+1) and ENERGY (FSH+2), so set a loop counter
28140                                                                          ; in X for 3 bytes
28141               
28142               REL5:
28143 BFCE DB8D  38        movb ra,@FSH(rx)                ; STA FSH,X         ; Set the X-th byte of FSH to &FF to charge up that
     BFD0 0F11     
28144                                                                          ; shield/bank
28145               
28146 BFD2 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
28147               
28148 BFD4 15FC  14        jgt  REL5                       ; BPL REL5          ; Loop back to REL5 until we have recharged both shields
28149                                                                          ; and the energy bank
28150               
28151                                                                          ; Fall through into RES2 to reset the stardust and ship
28152                                                                          ; workspace at INWK
28153               
28154               * ******************************************************************************
28155               *
28156               * Name: RES2
28157               * Type: Subroutine
28158               * Category: Start and end
28159               * Summary: Reset a number of flight variables and workspaces
28160               *
28161               * ------------------------------------------------------------------------------
28162               *
28163               * This is called after we launch from a space station, arrive in a new system
28164               * after hyperspace, launch an escape pod, or die a cold, lonely death in the
28165               * depths of space.
28166               *
28167               * ------------------------------------------------------------------------------
28168               *
28169               * Returns:
28170               *
28171               * Y                   Y is set to &FF
28172               *
28173               * ******************************************************************************
28174               
28175               RES2:
28176 BFD6 020D  20        li   ra,(NOST)*256              ; LDA #NOST         ; Reset NOSTM, the number of stardust particles, to the
     BFD8 1200     
28177 BFDA D80D  30        movb ra,@NOSTM                  ; STA NOSTM         ; maximum allowed (18)
     BFDC 0F33     
28178               
28179 BFDE 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Reset LSX2 and LSY2, the ball line heaps used by the
     BFE0 FF00     
28180 BFE2 D80E  30        movb rx,@LSX2                   ; STX LSX2          ; BLINE routine for drawing circles, to &FF, to set the
     BFE4 0E26     
28181 BFE6 D80E  30        movb rx,@LSY2                   ; STX LSY2          ; heap to empty
     BFE8 0E74     
28182               
28183 BFEA D80E  30        movb rx,@MSTG                   ; STX MSTG          ; Reset MSTG, the missile target, to &FF (no target)
     BFEC 0052     
28184               
28185 BFEE 020D  20        li   ra,>80*256                 ; LDA #128          ; Set the current pitch rate to the mid-point, 128
     BFF0 8000     
28186 BFF2 D80D  30        movb ra,@JSTY                   ; STA JSTY
     BFF4 009D     
28187               
28188 BFF6 D80D  30        movb ra,@ALP2                   ; STA ALP2          ; Reset ALP2 (roll sign) and BET2 (pitch sign)
     BFF8 0088     
28189 BFFA D80D  30        movb ra,@BET2                   ; STA BET2          ; to negative, i.e. pitch and roll negative
     BFFC 008A     
28190               
28191                      .asla                           ; ASL A             ; This sets A to 0
     **** ****     > ASLA
0001 BFFE 024D  22        andi ra,>ff00
     C000 FF00     
0002 C002 0A1D  18        sla  ra,1
                   < elite.a99
28192               
28193 C004 D80D  30        movb ra,@ALP2+1                 ; STA ALP2+1        ; Reset ALP2+1 (flipped roll sign) and BET2+1 (flipped
     C006 0089     
28194 C008 D80D  30        movb ra,@BET2+1                 ; STA BET2+1        ; pitch sign) to positive, i.e. pitch and roll negative
     C00A 008B     
28195               
28196 C00C D80D  30        movb ra,@MCNT                   ; STA MCNT          ; Reset MCNT (the main loop counter) to 0
     C00E 0099     
28197               
28198 C010 020D  20        li   ra,>03*256                 ; LDA #3            ; Reset DELTA (speed) to 3
     C012 0300     
28199 C014 D80D  30        movb ra,@DELTA                  ; STA DELTA
     C016 008C     
28200               
28201 C018 D80D  30        movb ra,@ALPHA                  ; STA ALPHA         ; Reset ALPHA (roll angle alpha) to 3
     C01A 009E     
28202               
28203 C01C D80D  30        movb ra,@ALP1                   ; STA ALP1          ; Reset ALP1 (magnitude of roll angle alpha) to 3
     C01E 0087     
28204               
28205 C020 D360  30        movb @SSPR,ra                   ; LDA SSPR          ; Fetch the "space station present" flag, and if we are
     C022 0D55     
28206 C024 1304  14        jeq  B86                        ; BEQ B86           ; not inside the safe zone, skip the next instruction
28207               
28208 C026 0200  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Light up the space station bulb on the dashboard
     C028 B13E     
28209 C02A 06A0  32        bl   @jsr                       ;
     C02C FE28     
28210               
28211               B86:
28212 C02E D360  30        movb @ECMA,ra                   ; LDA ECMA          ; Fetch the E.C.M. status flag, and if E.C.M. is off,
     C030 0030     
28213 C032 1304  14        jeq  yu_                        ; BEQ yu            ; skip the next instruction
28214               
28215 C034 0200  20        li   rtmp,ECMOF                 ; JSR ECMOF         ; Turn off the E.C.M. sound
     C036 CBC0     
28216 C038 06A0  32        bl   @jsr                       ;
     C03A FE28     
28217               
28218               yu_:
28219 C03C 0200  20        li   rtmp,WPSHPS                ; JSR WPSHPS        ; Wipe all ships from the scanner
     C03E AC64     
28220 C040 06A0  32        bl   @jsr                       ;
     C042 FE28     
28221               
28222 C044 0200  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     C046 C8B2     
28223 C048 06A0  32        bl   @jsr                       ;
     C04A FE28     
28224                                                                          ; the ship data blocks, the ship line heap, the ship
28225                                                                          ; slots for the local bubble of universe, and various
28226                                                                          ; flight and ship status variables
28227               
28228 C04C 020D  20        li   ra,((WP.-1)%256)*256       ; LDA #LO(WP%-1)    ; We have reset the ship line heap, so we now point
     C04E 3F00     
28229 C050 D80D  30        movb ra,@SLSP                   ; STA SLSP          ; SLSP to the byte before the WP workspace to indicate
     C052 0F1E     
28230 C054 020D  20        li   ra,((WP.-1)/256)*256       ; LDA #HI(WP%-1)    ; that the heap is empty
     C056 0D00     
28231 C058 D80D  30        movb ra,@SLSP+1                 ; STA SLSP+1
     C05A 0F1F     
28232               
28233 C05C 0200  20        li   rtmp,DIALS                 ; JSR DIALS         ; Update the dashboard
     C05E 32CA     
28234 C060 06A0  32        bl   @jsr                       ;
     C062 FE28     
28235               
28236                                                                          ; Finally, fall through into ZINF to reset the INWK
28237                                                                          ; ship workspace
28238               
28239               * ******************************************************************************
28240               *
28241               * Name: ZINF
28242               * Type: Subroutine
28243               * Category: Universe
28244               * Summary: Reset the INWK workspace and orientation vectors
28245               * Deep dive: Orientation vectors
28246               *
28247               * ------------------------------------------------------------------------------
28248               *
28249               * Zero-fill the INWK ship workspace and reset the orientation vectors, with
28250               * nosev pointing out of the screen, towards us.
28251               *
28252               * ------------------------------------------------------------------------------
28253               *
28254               * Returns:
28255               *
28256               * Y                   Y is set to &FF
28257               *
28258               * ******************************************************************************
28259               
28260               ZINF:
28261 C064 020F  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; There are NI% bytes in the INWK workspace, so set a
     C066 2300     
28262                                                                          ; counter in Y so we can loop through them
28263               
28264 C068 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can zero-fill the workspace
     C06A 0000     
28265               
28266               ZI1:
28267 C06C DBCD  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; Zero the Y-th byte of the INWK workspace
     C06E 0053     
28268               
28269 C070 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
28270               
28271 C072 15FC  14        jgt  ZI1                        ; BPL ZI1           ; Loop back for the next byte, ending when we have
28272                                                                          ; zero-filled the last byte at INWK, which leaves Y
28273                                                                          ; with a value of &FF
28274               
28275                                                                          ; Finally, we reset the orientation vectors as follows:
28276                                                                          ;
28277                                                                          ; sidev = (1,  0,  0)
28278                                                                          ; roofv = (0,  1,  0)
28279                                                                          ; nosev = (0,  0, -1)
28280                                                                          ;
28281                                                                          ; 96 * 256 (&6000) represents 1 in the orientation
28282                                                                          ; vectors, while -96 * 256 (&E000) represents -1. We
28283                                                                          ; already set the vectors to zero above, so we just
28284                                                                          ; need to set up the high bytes of the diagonal values
28285                                                                          ; and we're done. The negative nosev makes the ship
28286                                                                          ; point towards us, as the z-axis points into the screen
28287               
28288 C074 020D  20        li   ra,>60*256                 ; LDA #96           ; Set A to represent a 1 (in vector terms)
     C076 6000     
28289               
28290 C078 D80D  30        movb ra,@INWK+18                ; STA INWK+18       ; Set byte #18 = roofv_y_hi = 96 = 1
     C07A 0065     
28291               
28292 C07C D80D  30        movb ra,@INWK+22                ; STA INWK+22       ; Set byte #22 = sidev_x_hi = 96 = 1
     C07E 0069     
28293               
28294 C080 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Flip the sign of A to represent a -1
     C082 8000     
28295               
28296 C084 D80D  30        movb ra,@INWK+14                ; STA INWK+14       ; Set byte #14 = nosev_z_hi = -96 = -1
     C086 0061     
28297               
28298 C088 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C08A FE34     
28299               
28300               * ******************************************************************************
28301               *
28302               * Name: msblob
28303               * Type: Subroutine
28304               * Category: Dashboard
28305               * Summary: Display the dashboard's missile indicators in green
28306               *
28307               * ------------------------------------------------------------------------------
28308               *
28309               * Display the dashboard's missile indicators, with all the missiles reset to
28310               * green/cyan (i.e. not armed or locked).
28311               *
28312               * ******************************************************************************
28313               
28314               msblob_:
28315 C08C 020E  20        li   rx,>04*256                 ; LDX #4            ; Set up a loop counter in X to count through all four
     C08E 0400     
28316                                                                          ; missile indicators
28317               
28318               ss_:
28319 C090 93A0  30        cb   @NOMSL,rx                  ; CPX NOMSL         ; If the counter is equal to the number of missiles,
     C092 0333     
28320 C094 130A  14        jeq  SAL8                       ; BEQ SAL8          ; jump down to SAL8 to draw the remaining missiles, as
28321                                                                          ; the rest of them are present and should be drawn in
28322                                                                          ; green/cyan
28323               
28324 C096 020F  20        li   ry,>00*256                 ; LDY #0            ; Draw the missile indicator at position X in black
     C098 0000     
28325 C09A 0200  20        li   rtmp,MSBAR                 ; JSR MSBAR
     C09C B16A     
28326 C09E 06A0  32        bl   @jsr                       ;
     C0A0 FE28     
28327               
28328 C0A2 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter to point to the next missile
28329               
28330 C0A4 16F5  14        jne  ss_                        ; BNE ss            ; Loop back to ss if we still have missiles to draw
28331               
28332 C0A6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C0A8 FE34     
28333               
28334               SAL8:
28335 C0AA 020F  20        li   ry,>ee*256                 ; LDY #&EE          ; Draw the missile indicator at position X in green/cyan
     C0AC EE00     
28336 C0AE 0200  20        li   rtmp,MSBAR                 ; JSR MSBAR
     C0B0 B16A     
28337 C0B2 06A0  32        bl   @jsr                       ;
     C0B4 FE28     
28338               
28339 C0B6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter to point to the next missile
28340               
28341 C0B8 16F8  14        jne  SAL8                       ; BNE SAL8          ; Loop back to SAL8 if we still have missiles to draw
28342               
28343 C0BA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C0BC FE34     
28344               
28345               * ******************************************************************************
28346               *
28347               * Name: me2
28348               * Type: Subroutine
28349               * Category: Flight
28350               * Summary: Remove an in-flight message from the space view
28351               *
28352               * ******************************************************************************
28353               
28354               me2_:
28355 C0BE D360  30        movb @MCH,ra                    ; LDA MCH           ; Fetch the token number of the current message into A
     C0C0 0F10     
28356               
28357 C0C2 0200  20        li   rtmp,MESS                  ; JSR MESS          ; Call MESS to print the token, which will remove it
     C0C4 CF0E     
28358 C0C6 06A0  32        bl   @jsr                       ;
     C0C8 FE28     
28359                                                                          ; from the screen as printing uses EOR logic
28360               
28361 C0CA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the delay in DLY to 0, so any new in-flight
     C0CC 0000     
28362 C0CE D80D  30        movb ra,@DLY                    ; STA DLY           ; messages will be shown instantly
     C0D0 0D64     
28363               
28364 C0D2 0460  28        b    @me3_                      ; JMP me3           ; Jump back into the main spawning loop at me3
     C0D4 C18E     
28365               
28366               * ******************************************************************************
28367               *
28368               * Name: Ze
28369               * Type: Subroutine
28370               * Category: Universe
28371               * Summary: Initialise the INWK workspace to a hostile ship
28372               * Deep dive: Fixing ship positions
28373               *
28374               * ------------------------------------------------------------------------------
28375               *
28376               * Specifically, this routine does the following:
28377               *
28378               * * Reset the INWK ship workspace
28379               *
28380               * * Set the ship to a fair distance away in all axes, in front of us but
28381               * randomly up or down, left or right
28382               *
28383               * * Give the ship a 4% chance of having E.C.M.
28384               *
28385               * * Set the ship to hostile, with AI enabled
28386               *
28387               * This routine also sets A, X, T1 and the C flag to random values.
28388               *
28389               * Note that because this routine uses the value of X returned by DORND, and X
28390               * contains the value of A returned by the previous call to DORND, this routine
28391               * does not necessarily set the new ship to a totally random location. See the
28392               * deep dive on "Fixing ship positions" for details.
28393               *
28394               * ******************************************************************************
28395               
28396               Ze:
28397 C0D6 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     C0D8 C064     
28398 C0DA 06A0  32        bl   @jsr                       ;
     C0DC FE28     
28399               
28400 C0DE 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C0E0 C120     
28401 C0E2 06A0  32        bl   @jsr                       ;
     C0E4 FE28     
28402               
28403 C0E6 D80D  30        movb ra,@T1                     ; STA T1            ; Store A in T1
     C0E8 0006     
28404               
28405 C0EA 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign of A and store in x_sign
     C0EC 8000     
28406 C0EE D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     C0F0 0055     
28407               
28408 C0F2 D34E  18        movb rx,ra                      ; TXA               ; Extract the sign of X and store in y_sign
28409 C0F4 024D  22        andi ra,>80*256                 ; AND #%10000000
     C0F6 8000     
28410 C0F8 D80D  30        movb ra,@INWK+5                 ; STA INWK+5
     C0FA 0058     
28411               
28412 C0FC 020D  20        li   ra,>20*256                 ; LDA #32           ; Set x_hi = y_hi = z_hi = 32, a fair distance away
     C0FE 2000     
28413 C100 D80D  30        movb ra,@INWK+1                 ; STA INWK+1
     C102 0054     
28414 C104 D80D  30        movb ra,@INWK+4                 ; STA INWK+4
     C106 0057     
28415 C108 D80D  30        movb ra,@INWK+7                 ; STA INWK+7
     C10A 005A     
28416               
28417 C10C D34E  18        movb rx,ra                      ; TXA               ; Set the C flag if X >= 245 (4% chance)
28418 C10E 028D  22        ci   ra,>f5*256                 ; CMP #245
     C110 F500     
28419               
28420 C112 06A0  32        bl   @rola                      ; ROL A             ; Set bit 0 of A to the C flag (i.e. there's a 4%
     C114 FE3E     
28421                                                                          ; chance of this ship having E.C.M.)
28422               
28423 C116 026D  22        ori  ra,>c0*256                 ; ORA #%11000000    ; Set bits 6 and 7 of A, so the ship is hostile (bit 6
     C118 C000     
28424                                                                          ; and has AI (bit 7)
28425               
28426 C11A D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; Store A in the AI flag of this ship
     C11C 0073     
28427               
28428                                                                          ; Fall through into DORND2 to set A, X and the C flag
28429                                                                          ; randomly
28430               
28431               * ******************************************************************************
28432               *
28433               * Name: DORND
28434               * Type: Subroutine
28435               * Category: Maths (Arithmetic)
28436               * Summary: Generate random numbers
28437               * Deep dive: Generating random numbers
28438               * Fixing ship positions
28439               *
28440               * ------------------------------------------------------------------------------
28441               *
28442               * Set A and X to random numbers (though note that X is set to the random number
28443               * that was returned in A the last time DORND was called).
28444               *
28445               * The C and V flags are also set randomly.
28446               *
28447               * If we want to generate a repeatable sequence of random numbers, when
28448               * generating explosion clouds, for example, then we call DORND2 to ensure that
28449               * the value of the C flag on entry doesn't affect the outcome, as otherwise we
28450               * might not get the same sequence of numbers if the C flag changes.
28451               *
28452               * ------------------------------------------------------------------------------
28453               *
28454               * Other entry points:
28455               *
28456               * DORND2              Make sure the C flag doesn't affect the outcome
28457               *
28458               * ******************************************************************************
28459               
28460               DORND2:
28461                      .clc                            ; CLC               ; Clear the C flag so the value of the C flag on entry
     **** ****     > CLC
0001 C11E 0A16  18        sla  rzero,1
                   < elite.a99
28462                                                                          ; doesn't affect the outcome
28463               
28464               DORND:
28465 C120 D360  30        movb @RAND,ra                   ; LDA RAND          ; Calculate the next two values f2 and f3 in the feeder
     C122 0000     
28466 C124 06A0  32        bl   @rola                      ; ROL A             ; sequence:
     C126 FE3E     
28467 C128 D38D  18        movb ra,rx                      ; TAX               ;
28468                      .adc @RAND+2,ra                 ; ADC RAND+2        ; * f2 = (f1 << 1) mod 256 + C flag on entry
     **** ****     > ADC
0001 C12A 1701  14        jnc  !
0002 C12C B347  18        ab   rone,ra
0003               !:
0004 C12E B360  30        ab   @RAND+2,ra
     C130 0002     
                   < elite.a99
28469 C132 D80D  30        movb ra,@RAND                   ; STA RAND          ; * f3 = f0 + f2 + (1 if bit 7 of f1 is set)
     C134 0000     
28470 C136 D80E  30        movb rx,@RAND+2                 ; STX RAND+2        ; * C flag is set according to the f3 calculation
     C138 0002     
28471               
28472 C13A D360  30        movb @RAND+1,ra                 ; LDA RAND+1        ; Calculate the next value m2 in the main sequence:
     C13C 0001     
28473 C13E D38D  18        movb ra,rx                      ; TAX               ;
28474                      .adc @RAND+3,ra                 ; ADC RAND+3        ; * A = m2 = m0 + m1 + C flag from feeder calculation
     **** ****     > ADC
0001 C140 1701  14        jnc  !
0002 C142 B347  18        ab   rone,ra
0003               !:
0004 C144 B360  30        ab   @RAND+3,ra
     C146 0003     
                   < elite.a99
28475 C148 D80D  30        movb ra,@RAND+1                 ; STA RAND+1        ; * X = m1
     C14A 0001     
28476 C14C D80E  30        movb rx,@RAND+3                 ; STX RAND+3        ; * C and V flags set according to the m2 calculation
     C14E 0003     
28477               
28478 C150 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C152 FE34     
28479               
28480               * ******************************************************************************
28481               *
28482               * Name: Main game loop (Part 1 of 6)
28483               * Type: Subroutine
28484               * Category: Main loop
28485               * Summary: Spawn a trader (a peaceful Cobra Mk III)
28486               * Deep dive: Program flow of the main game loop
28487               * Ship data blocks
28488               *
28489               * ------------------------------------------------------------------------------
28490               *
28491               * This is part of the main game loop. This is where the core loop of the game
28492               * lives, and it's in two parts. The shorter loop (just parts 5 and 6) is
28493               * iterated when we are docked, while the entire loop from part 1 to 6 iterates
28494               * if we are in space.
28495               *
28496               * This section covers the following:
28497               *
28498               * * Spawn a trader, i.e. a Cobra Mk III that isn't hostile, with a 50% chance
28499               * of it having a missile, a 50% chance of it having an E.C.M., a speed
28500               * between 16 and 31, and a gentle clockwise roll
28501               *
28502               * We call this from within the main loop, with A set to a random number.
28503               *
28504               * ******************************************************************************
28505               
28506               MTT4:
28507 C154 091D  18        srl  ra,1                       ; LSR A             ; Clear bit 7 of our random number in A and set the C
28508                                                                          ; flag to bit 0 of A, which is random
28509               
28510 C156 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; Store this in the ship's AI flag, so this ship does
     C158 0073     
28511                                                                          ; not have AI
28512               
28513 C15A D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; Store A in the ship's roll counter, giving it a
     C15C 0070     
28514                                                                          ; clockwise roll (as bit 7 is clear), and a 1 in 127
28515                                                                          ; chance of it having no damping
28516               
28517 C15E 0204  20        li   rarg1,INWK+31              ; ROL INWK+31       ; Set bit 0 of the ship's missile count randomly (as the
     C160 0072     
28518 C162 06A0  32        bl   @rol                       ;
     C164 FE4E     
28519                                                                          ; C flag was set), giving the ship either no missiles or
28520                                                                          ; one missile
28521               
28522 C166 024D  22        andi ra,>1f*256                 ; AND #31           ; Set the ship speed to our random number, set to a
     C168 1F00     
28523 C16A 026D  22        ori  ra,>10*256                 ; ORA #16           ; minimum of 16 and a maximum of 31
     C16C 1000     
28524 C16E D80D  30        movb ra,@INWK+27                ; STA INWK+27
     C170 006E     
28525               
28526 C172 020D  20        li   ra,(CYL)*256               ; LDA #CYL          ; Add a new Cobra Mk III to the local bubble and fall
     C174 0700     
28527 C176 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; through into the main game loop again
     C178 AFC6     
28528 C17A 06A0  32        bl   @jsr                       ;
     C17C FE28     
28529               
28530               * ******************************************************************************
28531               *
28532               * Name: Main game loop (Part 2 of 6)
28533               * Type: Subroutine
28534               * Category: Main loop
28535               * Summary: Call the main flight loop, and potentially spawn a trader, an
28536               * asteroid, or a cargo canister
28537               * Deep dive: Program flow of the main game loop
28538               * Ship data blocks
28539               * Fixing ship positions
28540               *
28541               * ------------------------------------------------------------------------------
28542               *
28543               * This section covers the following:
28544               *
28545               * * Call M% to do the main flight loop
28546               *
28547               * * Potentially spawn a trader, asteroid or cargo canister
28548               *
28549               * ------------------------------------------------------------------------------
28550               *
28551               * Other entry points:
28552               *
28553               * TT100               The entry point for the start of the main game loop,
28554               * which calls the main flight loop and the moves into the
28555               * spawning routine
28556               *
28557               * me3                 Used by me2 to jump back into the main game loop after
28558               * printing an in-flight message
28559               *
28560               * ******************************************************************************
28561               
28562               TT100:
28563 C17E 0200  20        li   rtmp,M.                    ; JSR M%            ; Call M% to iterate through the main flight loop
     C180 0F52     
28564 C182 06A0  32        bl   @jsr                       ;
     C184 FE28     
28565               
28566 C186 7347  18        sb   rone,ra                    ; DEC DLY           ; Decrement the delay counter in DLY, so any in-flight
28567                                                                          ; messages get removed once the counter reaches zero
28568               
28569 C188 139A  14        jeq  me2_                       ; BEQ me2           ; If DLY is now 0, jump to me2 to remove any in-flight
28570                                                                          ; message from the space view, and once done, return to
28571                                                                          ; me3 below, skipping the following two instructions
28572               
28573 C18A 1501  14        jgt  me3_                       ; BPL me3           ; If DLY is positive, jump to me3 to skip the next
28574                                                                          ; instruction
28575               
28576 C18C B347  18        ab   rone,ra                    ; INC DLY           ; If we get here, DLY is negative, so we have gone too
28577                                                                          ; and need to increment DLY back to 0
28578               
28579               me3_:
28580 C18E 7347  18        sb   rone,ra                    ; DEC MCNT          ; Decrement the main loop counter in MCNT
28581               
28582 C190 1302  14        jeq  B87                        ; BEQ B87           ; If the counter has reached zero, which it will do
28583                                                                          ; every 256 main loops, skip the next JMP instruction
28584                                                                          ; (or to put it another way, if the counter hasn't
28585                                                                          ; reached zero, jump down to MLOOP, skipping all the
28586                                                                          ; following checks)
28587               
28588               ytq_:
28589 C192 0460  28        b    @MLOOP                     ; JMP MLOOP         ; Jump down to MLOOP to do some end-of-loop tidying and
     C194 C31A     
28590                                                                          ; restart the main loop
28591               
28592                                                                          ; We only get here once every 256 iterations of the
28593                                                                          ; main loop. If we aren't in witchspace and don't
28594                                                                          ; already have 3 or more asteroids in our local bubble,
28595                                                                          ; then this section has a 13% chance of spawning
28596                                                                          ; something benign (the other 87% of the time we jump
28597                                                                          ; down to consider spawning cops, pirates and bounty
28598                                                                          ; hunters)
28599                                                                          ;
28600                                                                          ; If we are in that 13%, then 50% of the time this will
28601                                                                          ; be a Cobra Mk III trader, and the other 50% of the
28602                                                                          ; time it will either be an asteroid (98.5% chance) or,
28603                                                                          ; very rarely, a cargo canister (1.5% chance)
28604               
28605               B87:
28606 C196 D360  30        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace following a mis-jump, skip the
     C198 0D5C     
28607 C19A 16FB  14        jne  ytq_                       ; BNE ytq           ; following by jumping down to MLOOP (via ytq above)
28608               
28609 C19C 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C19E C120     
28610 C1A0 06A0  32        bl   @jsr                       ;
     C1A2 FE28     
28611               
28612 C1A4 028D  22        ci   ra,>23*256                 ; CMP #35           ; If A >= 35 (87% chance), jump down to MTT1 to skip
     C1A6 2300     
28613 C1A8 184F  14        joc  MTT1                       ; BCS MTT1          ; the spawning of an asteroid or cargo canister and
28614                                                                          ; potentially spawn something else
28615               
28616 C1AA D360  30        movb @MANY+AST,ra               ; LDA MANY+AST      ; If we already have 3 or more asteroids in the local
     C1AC 0D57     
28617 C1AE 028D  22        ci   ra,>03*256                 ; CMP #3            ; bubble, jump down to MTT1 to skip the following and
     C1B0 0300     
28618 C1B2 184A  14        joc  MTT1                       ; BCS MTT1          ; potentially spawn something else
28619               
28620 C1B4 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     C1B6 C064     
28621 C1B8 06A0  32        bl   @jsr                       ;
     C1BA FE28     
28622               
28623 C1BC 020D  20        li   ra,>26*256                 ; LDA #38           ; Set z_hi = 38 (far away)
     C1BE 2600     
28624 C1C0 D80D  30        movb ra,@INWK+7                 ; STA INWK+7
     C1C2 005A     
28625               
28626 C1C4 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A, X and C flag to random numbers
     C1C6 C120     
28627 C1C8 06A0  32        bl   @jsr                       ;
     C1CA FE28     
28628               
28629 C1CC D80D  30        movb ra,@INWK                   ; STA INWK          ; Set x_lo = random
     C1CE 0053     
28630               
28631 C1D0 D80E  30        movb rx,@INWK+3                 ; STX INWK+3        ; Set y_lo = random
     C1D2 0056     
28632                                                                          ;
28633                                                                          ; Note that because we use the value of X returned by
28634                                                                          ; DORND, and X contains the value of A returned by the
28635                                                                          ; previous call to DORND, this does not set the new ship
28636                                                                          ; to a totally random location. See the deep dive on
28637                                                                          ; "Fixing ship positions" for details
28638               
28639 C1D4 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Set x_sign = bit 7 of x_lo
     C1D6 8000     
28640 C1D8 D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     C1DA 0055     
28641               
28642 C1DC D34E  18        movb rx,ra                      ; TXA               ; Set y_sign = bit 7 of y_lo
28643 C1DE 024D  22        andi ra,>80*256                 ; AND #%10000000
     C1E0 8000     
28644 C1E2 D80D  30        movb ra,@INWK+5                 ; STA INWK+5
     C1E4 0058     
28645               
28646 C1E6 0204  20        li   rarg1,INWK+1               ; ROL INWK+1        ; Set bit 1 of x_hi to the C flag, which is random, so
     C1E8 0054     
28647 C1EA 06A0  32        bl   @rol                       ;
     C1EC FE4E     
28648 C1EE 0204  20        li   rarg1,INWK+1               ; ROL INWK+1        ; this randomly moves us off-centre by 512 (as if x_hi
     C1F0 0054     
28649 C1F2 06A0  32        bl   @rol                       ;
     C1F4 FE4E     
28650                                                                          ; is %00000010, then (x_hi x_lo) is 512 + x_lo)
28651               
28652 C1F6 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A, X and V flag to random numbers
     C1F8 C120     
28653 C1FA 06A0  32        bl   @jsr                       ;
     C1FC FE28     
28654               
28655                      .bvs MTT4                       ; BVS MTT4          ; If V flag is set (50% chance), jump up to MTT4 to
     **** ****     > BVS
0001 C1FE 1801  14        joc  !
0002 C200 10A9  14        jmp  MTT4
0003               !:
                   < elite.a99
28656                                                                          ; spawn a trader
28657               
28658 C202 026D  22        ori  ra,>6f*256                 ; ORA #%01101111    ; Take the random number in A and set bits 0-3 and 5-6,
     C204 6F00     
28659 C206 D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; so the result has a 50% chance of being positive or
     C208 0070     
28660                                                                          ; negative, and a 50% chance of bits 0-6 being 127.
28661                                                                          ; Storing this number in the roll counter therefore
28662                                                                          ; gives our new ship a fast roll speed with a 50%
28663                                                                          ; chance of having no damping, plus a 50% chance of
28664                                                                          ; rolling clockwise or anti-clockwise
28665               
28666 C20A D360  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump
     C20C 0D55     
28667 C20E 161C  14        jne  MTT1                       ; BNE MTT1          ; down to MTT1 to skip the following and potentially
28668                                                                          ; spawn something else
28669               
28670 C210 D34E  18        movb rx,ra                      ; TXA               ; Set A to the random X we set above, which we haven't
28671 C212 1807  14        joc  MTT2                       ; BCS MTT2          ; used yet, and if the C flag is set (50% chance) jump
28672                                                                          ; down to MTT2 to skip the following
28673               
28674 C214 024D  22        andi ra,>1f*256                 ; AND #31           ; Set the ship speed to our random number, set to a
     C216 1F00     
28675 C218 026D  22        ori  ra,>10*256                 ; ORA #16           ; minimum of 16 and a maximum of 31
     C21A 1000     
28676 C21C D80D  30        movb ra,@INWK+27                ; STA INWK+27
     C21E 006E     
28677               
28678 C220 1704  14        jnc  MTT3                       ; BCC MTT3          ; Jump down to MTT3, skipping the following (this BCC
28679                                                                          ; is effectively a JMP as we know the C flag is clear,
28680                                                                          ; having passed through the BCS above)
28681               
28682               MTT2:
28683 C222 026D  22        ori  ra,>7f*256                 ; ORA #%01111111    ; Set bits 0-6 of A to 127, leaving bit 7 as random, so
     C224 7F00     
28684 C226 D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; storing this number in the pitch counter means we have
     C228 0071     
28685                                                                          ; full pitch with no damping, with a 50% chance of
28686                                                                          ; pitching up or down
28687               
28688               MTT3:
28689 C22A 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C22C C120     
28690 C22E 06A0  32        bl   @jsr                       ;
     C230 FE28     
28691               
28692 C232 028D  22        ci   ra,>05*256                 ; CMP #5            ; Set A to the ship number of an asteroid, and keep
     C234 0500     
28693 C236 020D  20        li   ra,(AST)*256               ; LDA #AST          ; this value for 98.5% of the time (i.e. if random
     C238 0A00     
28694 C23A 1802  14        joc  B88                        ; BCS B88           ; A >= 5 then skip the following instruction)
28695               
28696 C23C 020D  20        li   ra,(OIL)*256               ; LDA #OIL          ; Set A to the ship number of a cargo canister
     C23E 0B00     
28697               
28698               B88:
28699 C240 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Add our new asteroid or canister to the universe
     C242 AFC6     
28700 C244 06A0  32        bl   @jsr                       ;
     C246 FE28     
28701               
28702               * ******************************************************************************
28703               *
28704               * Name: Main game loop (Part 3 of 6)
28705               * Type: Subroutine
28706               * Category: Main loop
28707               * Summary: Potentially spawn a cop, particularly if we've been bad
28708               * Deep dive: Program flow of the main game loop
28709               * Ship data blocks
28710               * Fixing ship positions
28711               *
28712               * ------------------------------------------------------------------------------
28713               *
28714               * This section covers the following:
28715               *
28716               * * Potentially spawn a cop (in a Viper), very rarely if we have been good,
28717               * more often if have been naughty, and very often if we have been properly
28718               * bad
28719               *
28720               * ******************************************************************************
28721               
28722               MTT1:
28723 C248 D360  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station's safe zone, jump
     C24A 0D55     
28724 C24C 1666  14        jne  MLOOP                      ; BNE MLOOP         ; to MLOOP to skip the following
28725               
28726 C24E 0200  20        li   rtmp,BAD                   ; JSR BAD           ; Call BAD to work out how much illegal contraband we
     C250 C4DA     
28727 C252 06A0  32        bl   @jsr                       ;
     C254 FE28     
28728                                                                          ; are carrying in our hold (A is up to 40 for a
28729                                                                          ; standard hold crammed with contraband, up to 70 for
28730                                                                          ; an extended cargo hold full of narcotics and slaves)
28731               
28732                      .asla                           ; ASL A             ; Double A to a maximum of 80 or 140
     **** ****     > ASLA
0001 C256 024D  22        andi ra,>ff00
     C258 FF00     
0002 C25A 0A1D  18        sla  ra,1
                   < elite.a99
28733               
28734 C25C D3A0  30        movb @MANY+COPS,rx              ; LDX MANY+COPS     ; If there are no cops in the local bubble, skip the
     C25E 0D4F     
28735 C260 1302  14        jeq  B89                        ; BEQ B89           ; next instruction
28736               
28737 C262 F360  30        socb @FIST,ra                   ; ORA FIST          ; There are cops in the vicinity and we've got a hold
     C264 0334     
28738                                                                          ; full of jail time, so OR the value in A with FIST to
28739                                                                          ; get a new value that is at least as high as both
28740                                                                          ; values, to reflect the fact that they have almost
28741                                                                          ; certainly scanned our ship
28742               
28743               B89:
28744 C266 D80D  30        movb ra,@T                      ; STA T             ; Store our badness level in T
     C268 00D1     
28745               
28746 C26A 0200  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     C26C C0D6     
28747 C26E 06A0  32        bl   @jsr                       ;
     C270 FE28     
28748                                                                          ; ship, and set A and X to random values
28749                                                                          ;
28750                                                                          ; Note that because Ze uses the value of X returned by
28751                                                                          ; DORND, and X contains the value of A returned by the
28752                                                                          ; previous call to DORND, this does not set the new ship
28753                                                                          ; to a totally random location. See the deep dive on
28754                                                                          ; "Fixing ship positions" for details
28755               
28756 C272 9360  30        cb   @T,ra                      ; CMP T             ; If the random value in A >= our badness level, which
     C274 00D1     
28757 C276 1806  14        joc  B90                        ; BCS B90           ; will be the case unless we have been really, really
28758                                                                          ; bad, then skip the following two instructions (so
28759                                                                          ; if we are really bad, there's a higher chance of
28760                                                                          ; spawning a cop, otherwise we got away with it, for
28761                                                                          ; now)
28762               
28763 C278 020D  20        li   ra,(COPS)*256              ; LDA #COPS         ; Add a new police ship to the local bubble
     C27A 0200     
28764 C27C 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP
     C27E AFC6     
28765 C280 06A0  32        bl   @jsr                       ;
     C282 FE28     
28766               
28767               B90:
28768 C284 D360  30        movb @MANY+COPS,ra              ; LDA MANY+COPS     ; If we now have at least one cop in the local bubble,
     C286 0D4F     
28769 C288 1648  14        jne  MLOOP                      ; BNE MLOOP         ; jump down to MLOOP, otherwise fall through into the
28770                                                                          ; next part to look at spawning something else
28771               
28772               * ******************************************************************************
28773               *
28774               * Name: Main game loop (Part 4 of 6)
28775               * Type: Subroutine
28776               * Category: Main loop
28777               * Summary: Potentially spawn a lone bounty hunter, a Thargoid, or up to four
28778               * pirates
28779               * Deep dive: Program flow of the main game loop
28780               * Ship data blocks
28781               * Fixing ship positions
28782               *
28783               * ------------------------------------------------------------------------------
28784               *
28785               * This section covers the following:
28786               *
28787               * * Potentially spawn (35% chance) either a lone bounty hunter (a Mamba,
28788               * Python or Cobra Mk III), a Thargoid, or a group of up to 4 pirates
28789               * (Sidewinders and/or Mambas)
28790               *
28791               * ******************************************************************************
28792               
28793 C28A 7347  18        sb   rone,ra                    ; DEC EV            ; Decrement EV, the extra vessels spawning delay, and
28794 C28C 1546  14        jgt  MLOOP                      ; BPL MLOOP         ; jump to MLOOP if it is still positive, so we only
28795                                                                          ; do the following when the EV counter runs down
28796               
28797 C28E B347  18        ab   rone,ra                    ; INC EV            ; EV is negative, so bump it up again, setting it back
28798                                                                          ; to 0
28799               
28800 C290 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C292 C120     
28801 C294 06A0  32        bl   @jsr                       ;
     C296 FE28     
28802               
28803 C298 D3E0  30        movb @gov_,ry                   ; LDY gov           ; If the government of this system is 0 (anarchy), jump
     C29A 0F1C     
28804 C29C 1308  14        jeq  LABEL_2                    ; BEQ LABEL_2       ; straight to LABEL_2 to start spawning pirates or a
28805                                                                          ; lone bounty hunter
28806               
28807 C29E 028D  22        ci   ra,>5a*256                 ; CMP #90           ; If the random number in A >= 90 (65% chance), jump to
     C2A0 5A00     
28808 C2A2 183B  14        joc  MLOOP                      ; BCS MLOOP         ; MLOOP to stop spawning (so there's a 35% chance of
28809                                                                          ; spawning pirates or a lone bounty hunter)
28810               
28811 C2A4 024D  22        andi ra,>07*256                 ; AND #7            ; Reduce the random number in A to the range 0-7, and
     C2A6 0700     
28812 C2A8 9360  30        cb   @gov_,ra                   ; CMP gov           ; if A is less than government of this system, jump
     C2AA 0F1C     
28813 C2AC 1736  14        jnc  MLOOP                      ; BCC MLOOP         ; to MLOOP to stop spawning (so safer governments with
28814                                                                          ; larger gov numbers have a greater chance of jumping
28815                                                                          ; out, which is another way of saying that more
28816                                                                          ; dangerous systems spawn pirates and bounty hunters
28817                                                                          ; more often)
28818               
28819               LABEL_2:
28820                                                                          ; Now to spawn a lone bounty hunter, a Thargoid or a
28821                                                                          ; group of pirates
28822 C2AE 0200  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     C2B0 C0D6     
28823 C2B2 06A0  32        bl   @jsr                       ;
     C2B4 FE28     
28824                                                                          ; ship, and set A and X to random values
28825                                                                          ;
28826                                                                          ; Note that because Ze uses the value of X returned by
28827                                                                          ; DORND, and X contains the value of A returned by the
28828                                                                          ; previous call to DORND, this does not set the new ship
28829                                                                          ; to a totally random location. See the deep dive on
28830                                                                          ; "Fixing ship positions" for details
28831               
28832 C2B6 028D  22        ci   ra,>c8*256                 ; CMP #200          ; If the random number in A >= 200 (13% chance), jump
     C2B8 C800     
28833 C2BA 181B  14        joc  mt1_                       ; BCS mt1           ; to mt1 to spawn pirates, otherwise keep going to
28834                                                                          ; spawn a lone bounty hunter or a Thargoid
28835               
28836 C2BC B347  18        ab   rone,ra                    ; INC EV            ; Increase the extra vessels spawning counter, to
28837                                                                          ; prevent the next attempt to spawn extra vessels
28838               
28839 C2BE 024D  22        andi ra,>03*256                 ; AND #3            ; Set A = Y = random number in the range 3-6, which
     C2C0 0300     
28840                      .adi (>03*256)                  ; ADC #3            ; we will use to determine the type of ship
     **** ****     > ADI
0001 C2C2 1701  14        jnc  !
0002 C2C4 B347  18        ab   rone,ra
0003               !:
0004 C2C6 022D  22        ai   ra,(>03*256)
     C2C8 0300     
                   < elite.a99
28841 C2CA D3CD  18        movb ra,ry                      ; TAY
28842               
28843                                                                          ; We now build the AI flag for this ship in A
28844               
28845 C2CC D34E  18        movb rx,ra                      ; TXA               ; First, copy the random number in X to A
28846               
28847 C2CE 028D  22        ci   ra,>c8*256                 ; CMP #200          ; First, set the C flag if X >= 200 (22% chance)
     C2D0 C800     
28848               
28849 C2D2 06A0  32        bl   @rola                      ; ROL A             ; Set bit 0 of A to the C flag (i.e. there's a 22%
     C2D4 FE3E     
28850                                                                          ; chance of this ship having E.C.M.)
28851               
28852 C2D6 026D  22        ori  ra,>c0*256                 ; ORA #%11000000    ; Set bits 6 and 7 of A, so the ship is hostile (bit 6)
     C2D8 C000     
28853                                                                          ; and has AI (bit 7)
28854               
28855 C2DA 028F  22        ci   ry,>06*256                 ; CPY #6            ; If Y = 6 (i.e. a Thargoid), jump down to the tha
     C2DC 0600     
28856 C2DE 1347  14        jeq  tha_                       ; BEQ tha           ; routine in part 6 to decide whether or not to spawn it
28857                                                                          ; (where there's a 22% chance of this happening)
28858               
28859 C2E0 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; Store A in the AI flag of this ship
     C2E2 0073     
28860               
28861 C2E4 D34F  18        movb ry,ra                      ; TYA               ; Add a new ship of type Y to the local bubble, so
28862 C2E6 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; that's a Mamba, Cobra Mk III or Python
     C2E8 AFC6     
28863 C2EA 06A0  32        bl   @jsr                       ;
     C2EC FE28     
28864               
28865               mj1_:
28866 C2EE 0460  28        b    @MLOOP                     ; JMP MLOOP         ; Jump down to MLOOP, as we are done spawning ships
     C2F0 C31A     
28867               
28868               mt1_:
28869 C2F2 024D  22        andi ra,>03*256                 ; AND #3            ; It's time to spawn a group of pirates, so set A to a
     C2F4 0300     
28870                                                                          ; random number in the range 0-3, which will be the
28871                                                                          ; loop counter for spawning pirates below (so we will
28872                                                                          ; spawn 1-4 pirates)
28873               
28874 C2F6 D80D  30        movb ra,@EV                     ; STA EV            ; Delay further spawnings by this number
     C2F8 0D63     
28875               
28876 C2FA D80D  30        movb ra,@XX13                   ; STA XX13          ; Store the number in XX13, the pirate counter
     C2FC 0098     
28877               
28878               mt3_:
28879 C2FE 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C300 C120     
28880 C302 06A0  32        bl   @jsr                       ;
     C304 FE28     
28881               
28882 C306 024D  22        andi ra,>03*256                 ; AND #3            ; Set A to a random number in the range 0-3
     C308 0300     
28883               
28884 C30A 026D  22        ori  ra,>01*256                 ; ORA #1            ; Set A to %01 or %11 (Sidewinder or Mamba)
     C30C 0100     
28885               
28886 C30E 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Try adding a new ship of type A to the local bubble
     C310 AFC6     
28887 C312 06A0  32        bl   @jsr                       ;
     C314 FE28     
28888               
28889 C316 7347  18        sb   rone,ra                    ; DEC XX13          ; Decrement the pirate counter
28890               
28891 C318 15F2  14        jgt  mt3_                       ; BPL mt3           ; If we need more pirates, loop back up to mt3,
28892                                                                          ; otherwise we are done spawning, so fall through into
28893                                                                          ; the end of the main loop at MLOOP
28894               
28895               * ******************************************************************************
28896               *
28897               * Name: Main game loop (Part 5 of 6)
28898               * Type: Subroutine
28899               * Category: Main loop
28900               * Summary: Cool down lasers, make calls to update the dashboard
28901               * Deep dive: Program flow of the main game loop
28902               * The dashboard indicators
28903               *
28904               * ------------------------------------------------------------------------------
28905               *
28906               * This is the first half of the minimal game loop, which we iterate when we are
28907               * docked. This section covers the following:
28908               *
28909               * * Cool down lasers
28910               *
28911               * * Make calls to update the dashboard
28912               *
28913               * ------------------------------------------------------------------------------
28914               *
28915               * Other entry points:
28916               *
28917               * MLOOP               The entry point for the main game loop. This entry point
28918               * comes after the call to the main flight loop and
28919               * spawning routines, so it marks the start of the main
28920               * game loop for when we are docked (as we don't need to
28921               * call the main flight loop or spawning routines if we
28922               * aren't in space)
28923               *
28924               * ******************************************************************************
28925               
28926               MLOOP:
28927 C31A 020D  20        li   ra,>01*256                 ; LDA #%00000001    ; Set 6522 System VIA interrupt enable register IER
     C31C 0100     
28928 C31E D80D  38        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. disable the CA2 interrupt,
     C320 FE4E     
28929                                                                          ; which comes from the keyboard)
28930               
28931 C322 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set the stack pointer to &01FF, which is the standard
     C324 FF00     
28932 C326 D80E  30        movb rx,@rsplb                  ; TXS               ; location for the 6502 stack, so this instruction
     C328 8315     
28933                                                                          ; effectively resets the stack
28934               
28935 C32A D3A0  30        movb @GNTMP,rx                  ; LDX GNTMP         ; If the laser temperature in GNTMP is non-zero,
     C32C 0D61     
28936 C32E 1301  14        jeq  EE20                       ; BEQ EE20          ; decrement it (i.e. cool it down a bit)
28937 C330 7347  18        sb   rone,ra                    ; DEC GNTMP
28938               
28939               EE20:
28940 C332 0200  20        li   rtmp,DIALS                 ; JSR DIALS         ; Call DIALS to update the dashboard
     C334 32CA     
28941 C336 06A0  32        bl   @jsr                       ;
     C338 FE28     
28942               
28943 C33A D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is a space view, skip the following four
     C33C 0096     
28944 C33E 130A  14        jeq  B91                        ; BEQ B91           ; instructions (i.e. jump to JSR TT17 below)
28945               
28946                      .and @PATG                      ; AND PATG          ; If PATG = &FF (author names are shown on start-up)
     **** ****     > AND
0001 C340 D020  30        movb @PATG,rtmp
     C342 0F4C     
0002 C344 0540  14        inv  rtmp
0003 C346 5340  18        szcb rtmp,ra
                   < elite.a99
28947 C348 091D  18        srl  ra,1                       ; LSR A             ; and bit 0 of QQ11 is 1 (the current view is type 1),
28948 C34A 1804  14        joc  B91                        ; BCS B91           ; then skip the following instruction
28949               
28950 C34C 0200  20        li   rtmp,DELAY-5               ; JSR DELAY-5       ; Delay for 8 vertical syncs (8/50 = 0.16 seconds), to
     C34E 4CAF     
28951 C350 06A0  32        bl   @jsr                       ;
     C352 FE28     
28952                                                                          ; slow the main loop down a bit
28953               
28954               B91:
28955 C354 0200  20        li   rtmp,TT17                  ; JSR TT17          ; Scan the keyboard for the cursor keys or joystick,
     C356 BBF4     
28956 C358 06A0  32        bl   @jsr                       ;
     C35A FE28     
28957                                                                          ; returning the cursor's delta values in X and Y and
28958                                                                          ; the key pressed in A
28959               
28960               * ******************************************************************************
28961               *
28962               * Name: Main game loop (Part 6 of 6)
28963               * Type: Subroutine
28964               * Category: Main loop
28965               * Summary: Process non-flight key presses (red function keys, docked keys)
28966               * Deep dive: Program flow of the main game loop
28967               *
28968               * ------------------------------------------------------------------------------
28969               *
28970               * This is the second half of the minimal game loop, which we iterate when we are
28971               * docked. This section covers the following:
28972               *
28973               * * Process more key presses (red function keys, docked keys etc.)
28974               *
28975               * It also supports joining the main loop with a key already "pressed", so we can
28976               * jump into the main game loop to perform a specific action. In practice, this
28977               * is used when we enter the docking bay in BAY to display Status Mode (red key
28978               * f8), and when we finish buying or selling cargo in BAY2 to jump to the
28979               * Inventory (red key f9).
28980               *
28981               * ------------------------------------------------------------------------------
28982               *
28983               * Other entry points:
28984               *
28985               * FRCE                The entry point for the main game loop if we want to
28986               * jump straight to a specific screen, by pretending to
28987               * "press" a key, in which case A contains the internal key
28988               * number of the key we want to "press"
28989               *
28990               * tha                 Consider spawning a Thargoid (22% chance)
28991               *
28992               * ******************************************************************************
28993               
28994               FRCE:
28995 C35C 0200  20        li   rtmp,TT102                 ; JSR TT102         ; Call TT102 to process the key pressed in A
     C35E C388     
28996 C360 06A0  32        bl   @jsr                       ;
     C362 FE28     
28997               
28998 C364 D360  30        movb @QQ12,ra                   ; LDA QQ12          ; Fetch the docked flag from QQ12 into A
     C366 009F     
28999               
29000 C368 16D8  14        jne  MLOOP                      ; BNE MLOOP         ; If we are docked, loop back up to MLOOP just above
29001                                                                          ; to restart the main loop, but skipping all the flight
29002                                                                          ; and spawning code in the top part of the main loop
29003               
29004 C36A 0460  28        b    @TT100                     ; JMP TT100         ; Otherwise jump to TT100 to restart the main loop from
     C36C C17E     
29005                                                                          ; the start
29006               
29007               tha_:
29008 C36E 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C370 C120     
29009 C372 06A0  32        bl   @jsr                       ;
     C374 FE28     
29010               
29011 C376 028D  22        ci   ra,>c8*256                 ; CMP #200          ; If A < 200 (78% chance), skip the next instruction
     C378 C800     
29012 C37A 1704  14        jnc  B92                        ; BCC B92
29013               
29014 C37C 0200  20        li   rtmp,GTHG                  ; JSR GTHG          ; Call GTHG to spawn a Thargoid ship and a Thargon
     C37E A000     
29015 C380 06A0  32        bl   @jsr                       ;
     C382 FE28     
29016                                                                          ; companion
29017               
29018               B92:
29019 C384 0460  28        b    @MLOOP                     ; JMP MLOOP         ; Jump back into the main loop at MLOOP, which is just
     C386 C31A     
29020                                                                          ; after the ship-spawning section
29021               
29022               * ******************************************************************************
29023               *
29024               * Name: TT102
29025               * Type: Subroutine
29026               * Category: Keyboard
29027               * Summary: Process function key, save key, hyperspace and chart key presses
29028               * and update the hyperspace counter
29029               *
29030               * ------------------------------------------------------------------------------
29031               *
29032               * Process function key presses, plus "@" (save commander), "H" (hyperspace),
29033               * "D" (show distance to system) and "O" (move chart cursor back to current
29034               * system). We can also pass cursor position deltas in X and Y to indicate that
29035               * the cursor keys or joystick have been used (i.e. the values that are returned
29036               * by routine TT17).
29037               *
29038               * ------------------------------------------------------------------------------
29039               *
29040               * Arguments:
29041               *
29042               * A                   The internal key number of the key pressed (see p.142 of
29043               * the Advanced User Guide for a list of internal key
29044               * numbers)
29045               *
29046               * X                   The amount to move the crosshairs in the x-axis
29047               *
29048               * Y                   The amount to move the crosshairs in the y-axis
29049               *
29050               * ------------------------------------------------------------------------------
29051               *
29052               * Other entry points:
29053               *
29054               * T95                 Print the distance to the selected system
29055               *
29056               * ******************************************************************************
29057               
29058               TT102:
29059 C388 028D  22        ci   ra,(f8_)*256               ; CMP #f8           ; If red key f8 was pressed, jump to STATUS to show the
     C38A 7600     
29060 C38C 1602  14        jne  B93                        ; BNE B93           ; Status Mode screen, returning from the subroutine
29061 C38E 0460  28        b    @STATUS                    ; JMP STATUS        ; using a tail call
     C390 2E76     
29062               
29063               B93:
29064 C392 028D  22        ci   ra,(f4_)*256               ; CMP #f4           ; If red key f4 was pressed, jump to TT22 to show the
     C394 1400     
29065 C396 1602  14        jne  B94                        ; BNE B94           ; Long-range Chart, returning from the subroutine using
29066 C398 0460  28        b    @TT22                      ; JMP TT22          ; a tail call
     C39A 5332     
29067               
29068               B94:
29069 C39C 028D  22        ci   ra,(f5_)*256               ; CMP #f5           ; If red key f5 was pressed, jump to TT23 to show the
     C39E 7400     
29070 C3A0 1602  14        jne  B95                        ; BNE B95           ; Short-range Chart, returning from the subroutine using
29071 C3A2 0460  28        b    @TT23                      ; JMP TT23          ; a tail call
     C3A4 59EA     
29072               
29073               B95:
29074 C3A6 028D  22        ci   ra,(f6_)*256               ; CMP #f6           ; If red key f6 was pressed, call TT111 to select the
     C3A8 7500     
29075 C3AA 1606  14        jne  TT92                       ; BNE TT92          ; system nearest to galactic coordinates (QQ9, QQ10)
29076 C3AC 0200  20        li   rtmp,TT111                 ; JSR TT111         ; (the location of the chart crosshairs) and jump to
     C3AE 5B78     
29077 C3B0 06A0  32        bl   @jsr                       ;
     C3B2 FE28     
29078 C3B4 0460  28        b    @TT25                      ; JMP TT25          ; TT25 to show the Data on System screen, returning
     C3B6 4FCA     
29079                                                                          ; from the subroutine using a tail call
29080               
29081               TT92:
29082 C3B8 028D  22        ci   ra,(f9_)*256               ; CMP #f9           ; If red key f9 was pressed, jump to TT213 to show the
     C3BA 7700     
29083 C3BC 1602  14        jne  B96                        ; BNE B96           ; Inventory screen, returning from the subroutine
29084 C3BE 0460  28        b    @TT213                     ; JMP TT213         ; using a tail call
     C3C0 5838     
29085               
29086               B96:
29087 C3C2 028D  22        ci   ra,(f7_)*256               ; CMP #f7           ; If red key f7 was pressed, jump to TT167 to show the
     C3C4 1600     
29088 C3C6 1602  14        jne  B97                        ; BNE B97           ; Market Price screen, returning from the subroutine
29089 C3C8 0460  28        b    @TT167                     ; JMP TT167         ; using a tail call
     C3CA 5F5C     
29090               
29091               B97:
29092 C3CC 028D  22        ci   ra,(f0_)*256               ; CMP #f0           ; If red key f0 was pressed, jump to TT110 to launch our
     C3CE 2000     
29093 C3D0 1602  14        jne  fvw_                       ; BNE fvw           ; ship (if docked), returning from the subroutine using
29094 C3D2 0460  28        b    @TT110                     ; JMP TT110         ; a tail call
     C3D4 A10A     
29095               
29096               fvw_:
29097                      .bit @QQ12                      ; BIT QQ12          ; If bit 7 of QQ12 is clear (i.e. we are not docked, but
     **** ****     > BIT
0001 C3D6 D020  30        movb @QQ12,rtmp
     C3D8 009F     
0002 C3DA 0540  14        inv  rtmp
0003 C3DC D047  18        movb rone,rtmp2
0004 C3DE 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
29098 C3E0 1514  14        jgt  INSP                       ; BPL INSP          ; in space), jump to INSP to skip the following checks
29099                                                                          ; for f1-f3 and "@" (save commander file) key presses
29100               
29101 C3E2 028D  22        ci   ra,(f3_)*256               ; CMP #f3           ; If red key f3 was pressed, jump to EQSHP to show the
     C3E4 7300     
29102 C3E6 1602  14        jne  B98                        ; BNE B98           ; Equip Ship screen, returning from the subroutine using
29103 C3E8 0460  28        b    @EQSHP                     ; JMP EQSHP         ; a tail call
     C3EA A23C     
29104               
29105               B98:
29106 C3EC 028D  22        ci   ra,(f1_)*256               ; CMP #f1           ; If red key f1 was pressed, jump to TT219 to show the
     C3EE 7100     
29107 C3F0 1602  14        jne  B99                        ; BNE B99           ; Buy Cargo screen, returning from the subroutine using
29108 C3F2 0460  28        b    @TT219                     ; JMP TT219         ; a tail call
     C3F4 5536     
29109               
29110               B99:
29111 C3F6 028D  22        ci   ra,>47*256                 ; CMP #&47          ; If "@" was pressed, jump to SVE to save the commander
     C3F8 4700     
29112 C3FA 1602  14        jne  B100                       ; BNE B100          ; file, returning from the subroutine using a tail call
29113 C3FC 0460  28        b    @SVE                       ; JMP SVE
     C3FE C8F0     
29114               
29115               B100:
29116 C400 028D  22        ci   ra,(f2_)*256               ; CMP #f2           ; If red key f2 was pressed, jump to TT208 to show the
     C402 7200     
29117 C404 160D  14        jne  LABEL_3                    ; BNE LABEL_3       ; Sell Cargo screen, returning from the subroutine using
29118 C406 0460  28        b    @TT208                     ; JMP TT208         ; a tail call
     C408 5714     
29119               
29120               INSP:
29121 C40A 028D  22        ci   ra,(f1_)*256               ; CMP #f1           ; If the key pressed is < red key f1 or > red key f3,
     C40C 7100     
29122 C40E 1708  14        jnc  LABEL_3                    ; BCC LABEL_3       ; jump to LABEL_3 (so only do the following if the key
29123 C410 028D  22        ci   ra,(f3_+1)*256             ; CMP #f3+1         ; pressed is f1, f2 or f3)
     C412 7400     
29124 C414 1805  14        joc  LABEL_3                    ; BCS LABEL_3
29125               
29126 C416 024D  22        andi ra,>03*256                 ; AND #3            ; If we get here then we are either in space, or we are
     C418 0300     
29127 C41A D38D  18        movb ra,rx                      ; TAX               ; docked and none of f1-f3 were pressed, so we can now
29128 C41C 0460  28        b    @LOOK1                     ; JMP LOOK1         ; process f1-f3 with their in-flight functions, i.e.
     C41E 4B78     
29129                                                                          ; switching space views
29130                                                                          ;
29131                                                                          ; A will contain &71, &72 or &73 (for f1, f2 or f3), so
29132                                                                          ; set X to the last digit (1, 2 or 3) and jump to LOOK1
29133                                                                          ; to switch to view X (rear, left or right), returning
29134                                                                          ; from the subroutine using a tail call
29135               
29136               LABEL_3:
29137 C420 028D  22        ci   ra,>54*256                 ; CMP #&54          ; If "H" was pressed, jump to hyp to do a hyperspace
     C422 5400     
29138 C424 1602  14        jne  B101                       ; BNE B101          ; jump (if we are in space), returning from the
29139 C426 0460  28        b    @hyp_                      ; JMP hyp           ; subroutine using a tail call
     C428 5CEC     
29140               
29141               B101:
29142 C42A 028D  22        ci   ra,>32*256                 ; CMP #&32          ; If "D" was pressed, jump to T95 to print the distance
     C42C 3200     
29143 C42E 133B  14        jeq  T95                        ; BEQ T95           ; to a system (if we are in one of the chart screens)
29144               
29145 C430 D80D  30        movb ra,@T1                     ; STA T1            ; Store A (the key that's been pressed) in T1
     C432 0006     
29146               
29147 C434 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is a chart (QQ11 = 64 or 128),
     C436 0096     
29148 C438 024D  22        andi ra,>c0*256                 ; AND #%11000000    ; keep going, otherwise jump down to TT107 to skip the
     C43A C000     
29149 C43C 1318  14        jeq  TT107                      ; BEQ TT107         ; following
29150               
29151 C43E D360  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; If the on-screen hyperspace counter is non-zero,
     C440 002F     
29152 C442 1615  14        jne  TT107                      ; BNE TT107         ; then we are already counting down, so jump to TT107
29153                                                                          ; to skip the following
29154               
29155 C444 D360  30        movb @T1,ra                     ; LDA T1            ; Restore the original value of A (the key that's been
     C446 0006     
29156                                                                          ; pressed) from T1
29157               
29158 C448 028D  22        ci   ra,>36*256                 ; CMP #&36          ; If "O" was pressed, do the following three jumps,
     C44A 3600     
29159 C44C 160C  14        jne  ee2_                       ; BNE ee2           ; otherwise skip to ee2 to continue
29160               
29161 C44E 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     C450 5932     
29162 C452 06A0  32        bl   @jsr                       ;
     C454 FE28     
29163                                                                          ; which will erase the crosshairs currently there
29164               
29165 C456 0200  20        li   rtmp,ping_                 ; JSR ping          ; Set the target system to the current system (which
     C458 BC8C     
29166 C45A 06A0  32        bl   @jsr                       ;
     C45C FE28     
29167                                                                          ; will move the location in (QQ9, QQ10) to the current
29168                                                                          ; home system
29169               
29170 C45E 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     C460 5932     
29171 C462 06A0  32        bl   @jsr                       ;
     C464 FE28     
29172                                                                          ; which will draw the crosshairs at our current home
29173                                                                          ; system
29174               
29175               ee2_:
29176 C466 0200  20        li   rtmp,TT16                  ; JSR TT16          ; Call TT16 to move the crosshairs by the amount in X
     C468 58CE     
29177 C46A 06A0  32        bl   @jsr                       ;
     C46C FE28     
29178                                                                          ; and Y, which were passed to this subroutine as
29179                                                                          ; arguments
29180               
29181               TT107:
29182 C46E D360  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; If the on-screen hyperspace counter is zero, return
     C470 002F     
29183 C472 1317  14        jeq  t95_                       ; BEQ t95           ; from the subroutine (as t95 contains an RTS), as we
29184                                                                          ; are not currently counting down to a hyperspace jump
29185               
29186 C474 7347  18        sb   rone,ra                    ; DEC QQ22          ; Decrement the internal hyperspace counter
29187               
29188 C476 1615  14        jne  t95_                       ; BNE t95           ; If the internal hyperspace counter is still non-zero,
29189                                                                          ; then we are still counting down, so return from the
29190                                                                          ; subroutine (as t95 contains an RTS)
29191               
29192                                                                          ; If we get here then the internal hyperspace counter
29193                                                                          ; has just reached zero and it wasn't zero before, so
29194                                                                          ; we need to reduce the on-screen counter and update
29195                                                                          ; the screen. We do this by first printing the next
29196                                                                          ; number in the countdown sequence, and then printing
29197                                                                          ; the old number, which will erase the old number
29198                                                                          ; and display the new one because printing uses EOR
29199                                                                          ; logic
29200               
29201 C478 D3A0  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Set X = the on-screen hyperspace counter - 1
     C47A 002F     
29202 C47C 7387  18        sb   rone,rx                    ; DEX               ; (i.e. the next number in the sequence)
29203               
29204 C47E 0200  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1)
     C480 5DF6     
29205 C482 06A0  32        bl   @jsr                       ;
     C484 FE28     
29206               
29207 C486 020D  20        li   ra,>05*256                 ; LDA #5            ; Reset the internal hyperspace counter to 5
     C488 0500     
29208 C48A D80D  30        movb ra,@QQ22                   ; STA QQ22
     C48C 002E     
29209               
29210 C48E D3A0  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Set X = the on-screen hyperspace counter (i.e. the
     C490 002F     
29211                                                                          ; current number in the sequence, which is already
29212                                                                          ; shown on-screen)
29213               
29214 C492 0200  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1),
     C494 5DF6     
29215 C496 06A0  32        bl   @jsr                       ;
     C498 FE28     
29216                                                                          ; i.e. print the hyperspace countdown in the top-left
29217                                                                          ; corner
29218               
29219 C49A 7347  18        sb   rone,ra                    ; DEC QQ22+1        ; Decrement the on-screen hyperspace countdown
29220               
29221 C49C 1602  14        jne  t95_                       ; BNE t95           ; If the countdown is not yet at zero, return from the
29222                                                                          ; subroutine (as t95 contains an RTS)
29223               
29224 C49E 0460  28        b    @TT18                      ; JMP TT18          ; Otherwise the countdown has finished, so jump to TT18
     C4A0 A088     
29225                                                                          ; to do a hyperspace jump, returning from the subroutine
29226                                                                          ; using a tail call
29227               
29228               t95_:
29229 C4A2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C4A4 FE34     
29230               
29231               T95:
29232                                                                          ; If we get here, "D" was pressed, so we need to show
29233                                                                          ; the distance to the selected system (if we are in a
29234                                                                          ; chart view)
29235 C4A6 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is a chart (QQ11 = 64 or 128),
     C4A8 0096     
29236 C4AA 024D  22        andi ra,>c0*256                 ; AND #%11000000    ; keep going, otherwise return from the subroutine (as
     C4AC C000     
29237 C4AE 13F9  14        jeq  t95_                       ; BEQ t95           ; t95 contains an RTS)
29238               
29239 C4B0 0200  20        li   rtmp,hm_                   ; JSR hm            ; Call hm to move the crosshairs to the target system
     C4B2 4CC4     
29240 C4B4 06A0  32        bl   @jsr                       ;
     C4B6 FE28     
29241                                                                          ; in (QQ9, QQ10), returning with A = 0
29242               
29243 C4B8 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; Set QQ17 = 0 to switch to ALL CAPS
     C4BA 007E     
29244               
29245 C4BC 0200  20        li   rtmp,cpl_                  ; JSR cpl           ; Print control code 3 (the selected system name)
     C4BE A5C4     
29246 C4C0 06A0  32        bl   @jsr                       ;
     C4C2 FE28     
29247               
29248 C4C4 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     C4C6 8000     
29249 C4C8 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     C4CA 007E     
29250               
29251 C4CC 020D  20        li   ra,>01*256                 ; LDA #1            ; Move the text cursor to column 1 and down one line
     C4CE 0100     
29252 C4D0 D80D  30        movb ra,@XC                     ; STA XC            ; (in other words, to the start of the next line)
     C4D2 002C     
29253 C4D4 B347  18        ab   rone,ra                    ; INC YC
29254               
29255 C4D6 0460  28        b    @TT146                     ; JMP TT146         ; Print the distance to the selected system and return
     C4D8 4F62     
29256                                                                          ; from the subroutine using a tail call
29257               
29258               * ******************************************************************************
29259               *
29260               * Name: BAD
29261               * Type: Subroutine
29262               * Category: Status
29263               * Summary: Calculate how bad we have been
29264               *
29265               * ------------------------------------------------------------------------------
29266               *
29267               * Work out how bad we are from the amount of contraband in our hold. The
29268               * formula is:
29269               *
29270               * (slaves + narcotics) * 2 + firearms
29271               *
29272               * so slaves and narcotics are twice as illegal as firearms. The value in FIST
29273               * (our legal status) is set to at least this value whenever we launch from a
29274               * space station, and a FIST of 50 or more gives us fugitive status, so leaving a
29275               * station carrying 25 tonnes of slaves/narcotics, or 50 tonnes of firearms
29276               * across multiple trips, is enough to make us a fugitive.
29277               *
29278               * ------------------------------------------------------------------------------
29279               *
29280               * Returns:
29281               *
29282               * A                   A value that determines how bad we are from the amount
29283               * of contraband in our hold
29284               *
29285               * ******************************************************************************
29286               
29287               BAD:
29288 C4DA D360  30        movb @QQ20+3,ra                 ; LDA QQ20+3        ; Set A to the number of tonnes of slaves in the hold
     C4DC 031A     
29289               
29290                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 C4DE 0A16  18        sla  rzero,1
                   < elite.a99
29291                                                                          ; C flag affecting the result
29292               
29293                      .adc @QQ20+6,ra                 ; ADC QQ20+6        ; Add the number of tonnes of narcotics in the hold
     **** ****     > ADC
0001 C4E0 1701  14        jnc  !
0002 C4E2 B347  18        ab   rone,ra
0003               !:
0004 C4E4 B360  30        ab   @QQ20+6,ra
     C4E6 031D     
                   < elite.a99
29294               
29295                      .asla                           ; ASL A             ; Double the result and add the number of tonnes of
     **** ****     > ASLA
0001 C4E8 024D  22        andi ra,>ff00
     C4EA FF00     
0002 C4EC 0A1D  18        sla  ra,1
                   < elite.a99
29296                      .adc @QQ20+10,ra                ; ADC QQ20+10       ; firearms in the hold
     **** ****     > ADC
0001 C4EE 1701  14        jnc  !
0002 C4F0 B347  18        ab   rone,ra
0003               !:
0004 C4F2 B360  30        ab   @QQ20+10,ra
     C4F4 0321     
                   < elite.a99
29297               
29298 C4F6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C4F8 FE34     
29299               
29300               * ******************************************************************************
29301               *
29302               * Name: FAROF
29303               * Type: Subroutine
29304               * Category: Maths (Geometry)
29305               * Summary: Compare x_hi, y_hi and z_hi with 224
29306               *
29307               * ------------------------------------------------------------------------------
29308               *
29309               * Compare x_hi, y_hi and z_hi with 224, and set the C flag if all three <= 224,
29310               * otherwise clear the C flag.
29311               *
29312               * ------------------------------------------------------------------------------
29313               *
29314               * Returns:
29315               *
29316               * C flag              Set if x_hi <= 224 and y_hi <= 224 and z_hi <= 224
29317               *
29318               * Clear otherwise (i.e. if any one of them are bigger than
29319               * 224)
29320               *
29321               * ******************************************************************************
29322               
29323               FAROF:
29324 C4FA 020D  20        li   ra,>e0*256                 ; LDA #224          ; Set A = 224 and fall through into FAROF2 to do the
     C4FC E000     
29325                                                                          ; comparison
29326               
29327               * ******************************************************************************
29328               *
29329               * Name: FAROF2
29330               * Type: Subroutine
29331               * Category: Maths (Geometry)
29332               * Summary: Compare x_hi, y_hi and z_hi with A
29333               *
29334               * ------------------------------------------------------------------------------
29335               *
29336               * Compare x_hi, y_hi and z_hi with A, and set the C flag if all three <= A,
29337               * otherwise clear the C flag.
29338               *
29339               * ------------------------------------------------------------------------------
29340               *
29341               * Returns:
29342               *
29343               * C flag              Set if x_hi <= A and y_hi <= A and z_hi <= A
29344               *
29345               * Clear otherwise (i.e. if any one of them are bigger than
29346               * A)
29347               *
29348               * ******************************************************************************
29349               
29350               FAROF2:
29351 C4FE 9360  30        cb   @INWK+1,ra                 ; CMP INWK+1        ; If A < x_hi, C will be clear so jump to MA34 to
     C500 0054     
29352 C502 1705  14        jnc  MA34                       ; BCC MA34          ; return from the subroutine with C clear, otherwise
29353                                                                          ; C will be set so move on to the next one
29354               
29355 C504 9360  30        cb   @INWK+4,ra                 ; CMP INWK+4        ; If A < y_hi, C will be clear so jump to MA34 to
     C506 0057     
29356 C508 1702  14        jnc  MA34                       ; BCC MA34          ; return from the subroutine with C clear, otherwise
29357                                                                          ; C will be set so move on to the next one
29358               
29359 C50A 9360  30        cb   @INWK+7,ra                 ; CMP INWK+7        ; If A < z_hi, C will be clear, otherwise C will be set
     C50C 005A     
29360               
29361               MA34:
29362 C50E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C510 FE34     
29363               
29364               * ******************************************************************************
29365               *
29366               * Name: MAS4
29367               * Type: Subroutine
29368               * Category: Maths (Geometry)
29369               * Summary: Calculate a cap on the maximum distance to a ship
29370               *
29371               * ------------------------------------------------------------------------------
29372               *
29373               * Logical OR the value in A with the high bytes of the ship's position (x_hi,
29374               * y_hi and z_hi).
29375               *
29376               * ------------------------------------------------------------------------------
29377               *
29378               * Returns:
29379               *
29380               * A                   A OR x_hi OR y_hi OR z_hi
29381               *
29382               * ******************************************************************************
29383               
29384               MAS4:
29385 C512 F360  30        socb @INWK+1,ra                 ; ORA INWK+1        ; OR A with x_hi, y_hi and z_hi
     C514 0054     
29386 C516 F360  30        socb @INWK+4,ra                 ; ORA INWK+4
     C518 0057     
29387 C51A F360  30        socb @INWK+7,ra                 ; ORA INWK+7
     C51C 005A     
29388               
29389 C51E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C520 FE34     
29390               
29391               * ******************************************************************************
29392               *
29393               * Name: DEATH
29394               * Type: Subroutine
29395               * Category: Start and end
29396               * Summary: Display the death screen
29397               *
29398               * ------------------------------------------------------------------------------
29399               *
29400               * We have been killed, so display the chaos of our destruction above a "GAME
29401               * OVER" sign, and clean up the mess ready for the next attempt.
29402               *
29403               * ******************************************************************************
29404               
29405               DEATH:
29406 C522 0200  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of us dying
     C524 CBDA     
29407 C526 06A0  32        bl   @jsr                       ;
     C528 FE28     
29408               
29409 C52A 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     C52C BFD6     
29410 C52E 06A0  32        bl   @jsr                       ;
     C530 FE28     
29411               
29412                      .asl @DELTA                     ; ASL DELTA         ; Divide our speed in DELTA by 4
     **** ****     > ASL
0001 C532 D020  30        movb @DELTA,rtmp
     C534 008C     
0002 C536 0240  22        andi rtmp,>ff00
     C538 FF00     
0003 C53A 0A10  18        sla  rtmp,1
0004 C53C D800  30        movb rtmp,@DELTA
     C53E 008C     
                   < elite.a99
29413                      .asl @DELTA                     ; ASL DELTA
     **** ****     > ASL
0001 C540 D020  30        movb @DELTA,rtmp
     C542 008C     
0002 C544 0240  22        andi rtmp,>ff00
     C546 FF00     
0003 C548 0A10  18        sla  rtmp,1
0004 C54A D800  30        movb rtmp,@DELTA
     C54C 008C     
                   < elite.a99
29414               
29415 C54E 020E  20        li   rx,>18*256                 ; LDX #24           ; Set the screen to only show 24 text rows, which hides
     C550 1800     
29416 C552 0200  20        li   rtmp,DET1                  ; JSR DET1          ; the dashboard, setting A to 6 in the process
     C554 AD00     
29417 C556 06A0  32        bl   @jsr                       ;
     C558 FE28     
29418               
29419 C55A 0200  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     C55C 4BDE     
29420 C55E 06A0  32        bl   @jsr                       ;
     C560 FE28     
29421                                                                          ; and set the current view type in QQ11 to 6 (death
29422                                                                          ; screen)
29423               
29424 C562 0200  20        li   rtmp,BOX                   ; JSR BOX           ; Call BOX to redraw the same white border (BOX is part
     C564 4C1E     
29425 C566 06A0  32        bl   @jsr                       ;
     C568 FE28     
29426                                                                          ; of TT66), which removes the border as it is drawn
29427                                                                          ; using EOR logic
29428               
29429 C56A 0200  20        li   rtmp,nWq                   ; JSR nWq           ; Create a cloud of stardust containing the correct
     C56C AC20     
29430 C56E 06A0  32        bl   @jsr                       ;
     C570 FE28     
29431                                                                          ; number of dust particles (i.e. NOSTM of them)
29432               
29433 C572 020D  20        li   ra,>0c*256                 ; LDA #12           ; Move the text cursor to column 12 on row 12
     C574 0C00     
29434 C576 D80D  30        movb ra,@YC                     ; STA YC
     C578 002D     
29435 C57A D80D  30        movb ra,@XC                     ; STA XC
     C57C 002C     
29436               
29437 C57E 020D  20        li   ra,>92*256                 ; LDA #146          ; Print recursive token 146 ("{all caps}GAME OVER")
     C580 9200     
29438 C582 0200  20        li   rtmp,ex_                   ; JSR ex
     C584 A802     
29439 C586 06A0  32        bl   @jsr                       ;
     C588 FE28     
29440               
29441               D1:
29442 C58A 0200  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     C58C C0D6     
29443 C58E 06A0  32        bl   @jsr                       ;
     C590 FE28     
29444                                                                          ; ship, and set A and X to random values
29445               
29446 C592 091D  18        srl  ra,1                       ; LSR A             ; Set A = A / 4, so A is now between 0 and 63, and
29447 C594 091D  18        srl  ra,1                       ; LSR A             ; store in byte #0 (x_lo)
29448 C596 D80D  30        movb ra,@INWK                   ; STA INWK
     C598 0053     
29449               
29450 C59A 020F  20        li   ry,>00*256                 ; LDY #0            ; Set the following to 0: the current view in QQ11
     C59C 0000     
29451 C59E D80F  30        movb ry,@QQ11                   ; STY QQ11          ; (space view), x_hi, y_hi, z_hi and the AI flag (no AI
     C5A0 0096     
29452 C5A2 D80F  30        movb ry,@INWK+1                 ; STY INWK+1        ; or E.C.M. and not hostile)
     C5A4 0054     
29453 C5A6 D80F  30        movb ry,@INWK+4                 ; STY INWK+4
     C5A8 0057     
29454 C5AA D80F  30        movb ry,@INWK+7                 ; STY INWK+7
     C5AC 005A     
29455 C5AE D80F  30        movb ry,@INWK+32                ; STY INWK+32
     C5B0 0073     
29456               
29457 C5B2 73C7  18        sb   rone,ry                    ; DEY               ; Set Y = 255
29458               
29459 C5B4 D80F  30        movb ry,@MCNT                   ; STY MCNT          ; Reset the main loop counter to 255, so all timer-based
     C5B6 0099     
29460                                                                          ; calls will be stopped
29461               
29462 C5B8 D80F  30        movb ry,@LASCT                  ; STY LASCT         ; Set the laser count to 255 to act as a counter in the
     C5BA 0D60     
29463                                                                          ; D2 loop below, so this setting determines how long the
29464                                                                          ; death animation lasts (it's 5.1 seconds, as LASCT is
29465                                                                          ; decremented every vertical sync, or 50 times a second,
29466                                                                          ; and 255 / 50 = 5.1)
29467               
29468                      .eoi (>2a*256)                  ; EOR #%00101010    ; Flip bits 1, 3 and 5 in A (x_lo) to get another number
     **** ****     > EOI
0001 C5BC 0200  20        li   rtmp,(>2A*256)
     C5BE 2A00     
0002 C5C0 2B40  18        xor  rtmp,ra
                   < elite.a99
29469 C5C2 D80D  30        movb ra,@INWK+3                 ; STA INWK+3        ; between 48 and 63, and store in byte #3 (y_lo)
     C5C4 0056     
29470               
29471 C5C6 026D  22        ori  ra,>50*256                 ; ORA #%01010000    ; Set bits 4 and 6 of A to bump it up to between 112 and
     C5C8 5000     
29472 C5CA D80D  30        movb ra,@INWK+6                 ; STA INWK+6        ; 127, and store in byte #6 (z_lo)
     C5CC 0059     
29473               
29474 C5CE D34E  18        movb rx,ra                      ; TXA               ; Set A to the random number in X and keep bits 0-3 and
29475 C5D0 024D  22        andi ra,>8f*256                 ; AND #%10001111    ; the sign in bit 7 to get a number between -15 and +15,
     C5D2 8F00     
29476 C5D4 D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; and store in byte #29 (roll counter) to give our ship
     C5D6 0070     
29477                                                                          ; a gentle roll with damping
29478               
29479 C5D8 06A0  32        bl   @rora                      ; ROR A             ; The C flag is randomly set from the above call to Ze,
     C5DA FE62     
29480 C5DC 024D  22        andi ra,>87*256                 ; AND #%10000111    ; so this sets A to a number between -7 and +7, which
     C5DE 8700     
29481 C5E0 D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; we store in byte #30 (the pitch counter) to give our
     C5E2 0071     
29482                                                                          ; ship a very gentle pitch with damping
29483               
29484                      .php                            ; PHP               ; Store the processor flags
     **** ****     > PHP
0001 C5E4 02C0  12        stst rtmp
0002 C5E6 D680  30        movb rtmp,*rsp
0003 C5E8 060A  14        dec  rsp
                   < elite.a99
29485               
29486 C5EA 020E  20        li   rx,(OIL)*256               ; LDX #OIL          ; Call fq1 with X set to #OIL, which adds a new cargo
     C5EC 0B00     
29487 C5EE 0200  20        li   rtmp,fq1_                  ; JSR fq1           ; canister to our local bubble of universe and points it
     C5F0 3CA8     
29488 C5F2 06A0  32        bl   @jsr                       ;
     C5F4 FE28     
29489                                                                          ; away from us with double DELTA speed (i.e. 6, as DELTA
29490                                                                          ; was set to 3 by the call to RES2 above). INF is set to
29491                                                                          ; point to the canister's ship data block in K%
29492               
29493                      .plp                            ; PLP               ; Restore the processor flags, including our random C
     **** ****     > PLP
0001 C5F6 058A  14        inc  rsp
0002 C5F8 D01A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
29494                                                                          ; flag from before
29495               
29496 C5FA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 of A to our random C flag and store in byte
     C5FC 0000     
29497 C5FE 06A0  32        bl   @rora                      ; ROR A             ; #31 of the ship's data block, so this has a 50% chance
     C600 FE62     
29498 C602 020F  20        li   ry,>1f*256                 ; LDY #31           ; of marking our new canister as being killed (so it
     C604 1F00     
29499                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; will explode)
     **** ****     > ST_IND_Y_IDX
0001 C606 D820  42        movb @INF,@rtmplb
     C608 0020     
     C60A 8301     
0002 C60C D020  30        movb @INF+1,rtmp
     C60E 0021     
0003 C610 06CF  14        swpb ry
0004 C612 A00F  18        a    ry,rtmp
0005 C614 06CF  14        swpb ry
0006 C616 D40D  30        movb RA,*rtmp
                   < elite.a99
29500               
29501 C618 D360  30        movb @FRIN+3,ra                 ; LDA FRIN+3        ; The call we made to RES2 before we entered the loop at
     C61A 0D43     
29502 C61C 13B6  14        jeq  D1                         ; BEQ D1            ; D1 will have reset all the ship slots at FRIN, so this
29503                                                                          ; checks to see if the fourth slot is empty, and if it
29504                                                                          ; is we loop back to D1 to add another canister, until
29505                                                                          ; we have added four of them
29506               
29507 C61E 0200  20        li   rtmp,U.                    ; JSR U%            ; Clear the key logger, which also sets A = 0
     C620 CDA2     
29508 C622 06A0  32        bl   @jsr                       ;
     C624 FE28     
29509               
29510 C626 D80D  30        movb ra,@DELTA                  ; STA DELTA         ; Set our speed in DELTA to 0, as we aren't going
     C628 008C     
29511                                                                          ; anywhere any more
29512               
29513               D2:
29514 C62A 0200  20        li   rtmp,M.                    ; JSR M%            ; Call the M% routine to do the main flight loop once,
     C62C 0F52     
29515 C62E 06A0  32        bl   @jsr                       ;
     C630 FE28     
29516                                                                          ; which will display our exploding canister scene and
29517                                                                          ; move everything about
29518               
29519 C632 D360  30        movb @LASCT,ra                  ; LDA LASCT         ; Loop back to D2 to run the main flight loop until
     C634 0D60     
29520 C636 16F9  14        jne  D2                         ; BNE D2            ; LASCT reaches zero (which will take 5.1 seconds, as
29521                                                                          ; explained above)
29522               
29523 C638 020E  20        li   rx,>1f*256                 ; LDX #31           ; Set the screen to show all 31 text rows, which shows
     C63A 1F00     
29524 C63C 0200  20        li   rtmp,DET1                  ; JSR DET1          ; the dashboard
     C63E AD00     
29525 C640 06A0  32        bl   @jsr                       ;
     C642 FE28     
29526               
29527                                                                          ; Fall through into DEATH2 to reset and restart the game
29528               
29529               * ******************************************************************************
29530               *
29531               * Name: DEATH2
29532               * Type: Subroutine
29533               * Category: Start and end
29534               * Summary: Reset most of the game and restart from the title screen
29535               *
29536               * ------------------------------------------------------------------------------
29537               *
29538               * This routine is called following death, and when the game is quit by pressing
29539               * ESCAPE when paused.
29540               *
29541               * ******************************************************************************
29542               
29543               DEATH2:
29544 C644 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     C646 BFD6     
29545 C648 06A0  32        bl   @jsr                       ;
     C64A FE28     
29546                                                                          ; and fall through into the entry code for the game
29547                                                                          ; to restart from the title screen
29548               
29549               * ******************************************************************************
29550               *
29551               * Name: TT170
29552               * Type: Subroutine
29553               * Category: Start and end
29554               * Summary: Main entry point for the Elite game code
29555               * Deep dive: Program flow of the main game loop
29556               *
29557               * ------------------------------------------------------------------------------
29558               *
29559               * This is the main entry point for the main game code.
29560               *
29561               * ******************************************************************************
29562               
29563               TT170:
29564 C64C 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set the stack pointer to &01FF, which is the standard
     C64E FF00     
29565 C650 D80E  30        movb rx,@rsplb                  ; TXS               ; location for the 6502 stack, so this instruction
     C652 8315     
29566                                                                          ; effectively resets the stack. We need to do this
29567                                                                          ; because the loader code in elite-loader.asm pushes
29568                                                                          ; code onto the stack, and this effectively removes that
29569                                                                          ; code so we start afresh
29570               
29571                                                                          ; Fall through into BR1 to start the game
29572               
29573               * ******************************************************************************
29574               *
29575               * Name: BR1 (Part 1 of 2)
29576               * Type: Subroutine
29577               * Category: Start and end
29578               * Summary: Show the "Load New Commander (Y/N)?" screen and start the game
29579               *
29580               * ------------------------------------------------------------------------------
29581               *
29582               * BRKV is set to point to BR1 by the loading process.
29583               *
29584               * ******************************************************************************
29585               
29586               BR1:
29587 C654 020E  20        li   rx,>03*256                 ; LDX #3            ; Set XC = 3 (set text cursor to column 3)
     C656 0300     
29588 C658 D80E  30        movb rx,@XC                     ; STX XC
     C65A 002C     
29589               
29590 C65C 0200  20        li   rtmp,FX200                 ; JSR FX200         ; Disable the ESCAPE key and clear memory if the BREAK
     C65E CA16     
29591 C660 06A0  32        bl   @jsr                       ;
     C662 FE28     
29592                                                                          ; key is pressed (*FX 200,3)
29593               
29594 C664 020E  20        li   rx,(CYL)*256               ; LDX #CYL          ; Call TITLE to show a rotating Cobra Mk III (#CYL) and
     C666 0700     
29595 C668 020D  20        li   ra,>80*256                 ; LDA #128          ; token 128 ("  LOAD NEW COMMANDER (Y/N)?{crlf}{crlf}"),
     C66A 8000     
29596 C66C 0200  20        li   rtmp,TITLE                 ; JSR TITLE         ; returning with the internal number of the key pressed
     C66E C714     
29597 C670 06A0  32        bl   @jsr                       ;
     C672 FE28     
29598                                                                          ; in A
29599               
29600 C674 028D  22        ci   ra,>44*256                 ; CMP #&44          ; Did we press "Y"? If not, jump to QU5, otherwise
     C676 4400     
29601 C678 1610  14        jne  QU5                        ; BNE QU5           ; continue on to load a new commander
29602               
29603               * BR1                    \ These instructions are commented out in the original
29604               * LDX #3                 \ source. This block starts with the same *FX call as
29605               * STX XC                 \ above, then clears the screen, calls a routine to
29606               * JSR FX200              \ flush the keyboard buffer (FLKB) that isn't present
29607               * LDA #1                 \ in the cassette version but is in other versions,
29608               * JSR TT66               \ and then it displays "LOAD NEW COMMANDER (Y/N)?" and
29609               * JSR FLKB               \ lists the current cargo, before falling straight into
29610               * LDA #14                \ the load routine below, whether or not we have
29611               * JSR TT214              \ pressed "Y". This may be a bit of testing code, as the
29612               * BCC QU5                \ first line is a commented label, BR1, which is where
29613                                                                          ; BRKV points, so when this is uncommented, pressing
29614                                                                          ; the BREAK key should jump straight to the load screen
29615               
29616 C67A 0200  20        li   rtmp,GTNME                 ; JSR GTNME         ; We want to load a new commander, so we need to get
     C67C C858     
29617 C67E 06A0  32        bl   @jsr                       ;
     C680 FE28     
29618                                                                          ; the commander name to load
29619               
29620 C682 0200  20        li   rtmp,LOD                   ; JSR LOD           ; We then call the LOD subroutine to load the commander
     C684 C9D0     
29621 C686 06A0  32        bl   @jsr                       ;
     C688 FE28     
29622                                                                          ; file to address NA%+8, which is where we store the
29623                                                                          ; commander save file
29624               
29625 C68A 0200  20        li   rtmp,TRNME                 ; JSR TRNME         ; Once loaded, we copy the commander name to NA%
     C68C C834     
29626 C68E 06A0  32        bl   @jsr                       ;
     C690 FE28     
29627               
29628 C692 0200  20        li   rtmp,TTX66                 ; JSR TTX66         ; And we clear the top part of the screen and draw a
     C694 4BE2     
29629 C696 06A0  32        bl   @jsr                       ;
     C698 FE28     
29630                                                                          ; white border
29631               
29632               * ******************************************************************************
29633               *
29634               * Name: QU5
29635               * Type: Subroutine
29636               * Category: Start and end
29637               * Summary: Reset the current commander data block to the last saved commander
29638               *
29639               * ******************************************************************************
29640               
29641               QU5:
29642                                                                          ; By the time we get here, the correct commander name
29643                                                                          ; is at NA% and the correct commander data is at NA%+8.
29644                                                                          ; Specifically:
29645                                                                          ;
29646                                                                          ; * If we loaded a commander file, then the name and
29647                                                                          ; data from that file will be at NA% and NA%+8
29648                                                                          ;
29649                                                                          ; * If this is a brand new game, then NA% will contain
29650                                                                          ; the default starting commander name ("JAMESON")
29651                                                                          ; and NA%+8 will contain the default commander data
29652                                                                          ;
29653                                                                          ; * If this is not a new game (because they died or
29654                                                                          ; quit) and we didn't want to load a commander file,
29655                                                                          ; then NA% will contain the last saved commander
29656                                                                          ; name, and NA%+8 the last saved commander data. If
29657                                                                          ; the game has never been saved, this will still be
29658                                                                          ; the default commander
29659               * JSR TTX66              \ This instruction is commented out in the original
29660                                                                          ; source; it clears the screen and draws a border
29661 C69A 020E  20        li   rx,(NT.)*256               ; LDX #NT%          ; The size of the commander data block is NT% bytes,
     C69C 4B00     
29662                                                                          ; and it starts at NA%+8, so we need to copy the data
29663                                                                          ; from the "last saved" buffer at NA%+8 to the current
29664                                                                          ; commander workspace at TP. So we set up a counter in X
29665                                                                          ; for the NT% bytes that we want to copy
29666               
29667               QUL1:
29668 C69E D36E  34        movb @NA.+7(rx),ra              ; LDA NA%+7,X       ; Copy the X-th byte of NA%+7 to the X-th byte of TP-1,
     C6A0 21F3     
29669 C6A2 DB8D  38        movb ra,@TP-1(rx)               ; STA TP-1,X        ; (the -1 is because X is counting down from NT% to 1)
     C6A4 02FF     
29670               
29671 C6A6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
29672               
29673 C6A8 16FA  14        jne  QUL1                       ; BNE QUL1          ; Loop back for the next byte of the commander data
29674                                                                          ; block
29675               
29676 C6AA D80E  30        movb rx,@QQ11                   ; STX QQ11          ; X is 0 by the end of the above loop, so this sets QQ11
     C6AC 0096     
29677                                                                          ; to 0, which means we will be showing a view without a
29678                                                                          ; boxed title at the top (i.e. we're going to use the
29679                                                                          ; screen layout of a space view in the following)
29680               
29681                                                                          ; If the commander check below fails, we keep jumping
29682                                                                          ; back to here to crash the game with an infinite loop
29683               
29684               B102:
29685 C6AE 0200  20        li   rtmp,CHECK                 ; JSR CHECK         ; Call the CHECK subroutine to calculate the checksum
     C6B0 C816     
29686 C6B2 06A0  32        bl   @jsr                       ;
     C6B4 FE28     
29687                                                                          ; for the current commander block at NA%+8 and put it
29688                                                                          ; in A
29689               
29690 C6B6 9360  34        cb   @CHK,ra                    ; CMP CHK           ; Test the calculated checksum against CHK
     C6B8 2242     
29691               
29693               
29694 C6BA 1000  14        nop                             ; NOP               ; If we have disabled checksums, then ignore the result
29695 C6BC 1000  14        nop                             ; NOP               ; of the comparison and fall through into the next part
29696               
29705               
29706                                                                          ; The checksum CHK is correct, so now we check whether
29707                                                                          ; CHK2 = CHK EOR A9, and if this check fails, bit 7 of
29708                                                                          ; the competition flags at COK gets set, to indicate
29709                                                                          ; to Acornsoft via the competition code that there has
29710                                                                          ; been some hacking going on with this competition entry
29711               
29712                      .eoi (>a9*256)                  ; EOR #&A9          ; X = checksum EOR &A9
     **** ****     > EOI
0001 C6BE 0200  20        li   rtmp,(>A9*256)
     C6C0 A900     
0002 C6C2 2B40  18        xor  rtmp,ra
                   < elite.a99
29713 C6C4 D38D  18        movb ra,rx                      ; TAX
29714               
29715 C6C6 D360  30        movb @COK,ra                    ; LDA COK           ; Set A to the competition flags in COK
     C6C8 030E     
29716               
29717 C6CA 93A0  34        cb   @CHK2,rx                   ; CPX CHK2          ; If X = CHK2, then skip the next instruction
     C6CC 2241     
29718 C6CE 1302  14        jeq  tZ                         ; BEQ tZ
29719               
29720 C6D0 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 of A to indicate this commander file has
     C6D2 8000     
29721                                                                          ; been tampered with
29722               
29723               tZ:
29724 C6D4 026D  22        ori  ra,>02*256                 ; ORA #%00000010    ; Set bit 1 of A to denote that this is the cassette
     C6D6 0200     
29725                                                                          ; version
29726               
29727 C6D8 D80D  30        movb ra,@COK                    ; STA COK           ; Store the updated competition flags in COK
     C6DA 030E     
29728               
29729               * ******************************************************************************
29730               *
29731               * Name: BR1 (Part 2 of 2)
29732               * Type: Subroutine
29733               * Category: Start and end
29734               * Summary: Show the "Press Fire or Space, Commander" screen and start the
29735               * game
29736               *
29737               * ------------------------------------------------------------------------------
29738               *
29739               * BRKV is set to point to BR1 by the loading process.
29740               *
29741               * ******************************************************************************
29742               
29743 C6DC 0200  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     C6DE C08C     
29744 C6E0 06A0  32        bl   @jsr                       ;
     C6E2 FE28     
29745                                                                          ; them are targeted
29746               
29747 C6E4 020D  20        li   ra,>93*256                 ; LDA #147          ; Call TITLE to show a rotating Mamba (#3) and token
     C6E6 9300     
29748 C6E8 020E  20        li   rx,>03*256                 ; LDX #3            ; 147 ("PRESS FIRE OR SPACE,COMMANDER.{crlf}{crlf}"),
     C6EA 0300     
29749 C6EC 0200  20        li   rtmp,TITLE                 ; JSR TITLE         ; returning with the internal number of the key pressed
     C6EE C714     
29750 C6F0 06A0  32        bl   @jsr                       ;
     C6F2 FE28     
29751                                                                          ; in A
29752               
29753 C6F4 0200  20        li   rtmp,ping_                 ; JSR ping          ; Set the target system coordinates (QQ9, QQ10) to the
     C6F6 BC8C     
29754 C6F8 06A0  32        bl   @jsr                       ;
     C6FA FE28     
29755                                                                          ; current system coordinates (QQ0, QQ1) we just loaded
29756               
29757 C6FC 0200  20        li   rtmp,hyp1_                 ; JSR hyp1          ; Arrive in the system closest to (QQ9, QQ10)
     C6FE 5FE8     
29758 C700 06A0  32        bl   @jsr                       ;
     C702 FE28     
29759               
29760                                                                          ; Fall through into the docking bay routine below
29761               
29762               * ******************************************************************************
29763               *
29764               * Name: BAY
29765               * Type: Subroutine
29766               * Category: Status
29767               * Summary: Go to the docking bay (i.e. show the Status Mode screen)
29768               *
29769               * ------------------------------------------------------------------------------
29770               *
29771               * We end up here after the start-up process (load commander etc.), as well as
29772               * after a successful save, an escape pod launch, a successful docking, the end
29773               * of a cargo sell, and various errors (such as not having enough cash, entering
29774               * too many items when buying, trying to fit an item to your ship when you
29775               * already have it, running out of cargo space, and so on).
29776               *
29777               * ******************************************************************************
29778               
29779               BAY:
29780 C704 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set QQ12 = &FF (the docked flag) to indicate that we
     C706 FF00     
29781 C708 D80D  30        movb ra,@QQ12                   ; STA QQ12          ; are docked
     C70A 009F     
29782               
29783 C70C 020D  20        li   ra,(f8_)*256               ; LDA #f8           ; Jump into the main loop at FRCE, setting the key
     C70E 7600     
29784 C710 0460  28        b    @FRCE                      ; JMP FRCE          ; that's "pressed" to red key f8 (so we show the Status
     C712 C35C     
29785                                                                          ; Mode screen)
29786               
29787               * ******************************************************************************
29788               *
29789               * Name: TITLE
29790               * Type: Subroutine
29791               * Category: Start and end
29792               * Summary: Display a title screen with a rotating ship and prompt
29793               *
29794               * ------------------------------------------------------------------------------
29795               *
29796               * Display the title screen, with a rotating ship and a text token at the bottom
29797               * of the screen.
29798               *
29799               * ------------------------------------------------------------------------------
29800               *
29801               * Arguments:
29802               *
29803               * A                   The number of the recursive token to show below the
29804               * rotating ship (see variable QQ18 for details of
29805               * recursive tokens)
29806               *
29807               * X                   The type of the ship to show (see variable XX21 for a
29808               * list of ship types)
29809               *
29810               * ------------------------------------------------------------------------------
29811               *
29812               * Returns:
29813               *
29814               * X                   If a key is being pressed, X contains the internal key
29815               * number, otherwise it contains 0
29816               *
29817               * ******************************************************************************
29818               
29819               TITLE:
29820                      .pha                            ; PHA               ; Store the token number on the stack for later
     **** ****     > PHA
0001 C714 D68D  30        movb ra,*rsp
0002 C716 060A  14        dec  rsp
                   < elite.a99
29821               
29822 C718 D80E  30        movb rx,@TYPE                   ; STX TYPE          ; Store the ship type in location TYPE
     C71A 009B     
29823               
29824 C71C 0200  20        li   rtmp,RESET                 ; JSR RESET         ; Reset our ship so we can use it for the rotating
     C71E BFAE     
29825 C720 06A0  32        bl   @jsr                       ;
     C722 FE28     
29826                                                                          ; title ship
29827               
29828 C724 020D  20        li   ra,>01*256                 ; LDA #1            ; Clear the top part of the screen, draw a white border,
     C726 0100     
29829 C728 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 1
     C72A 4BDE     
29830 C72C 06A0  32        bl   @jsr                       ;
     C72E FE28     
29831               
29832 C730 7347  18        sb   rone,ra                    ; DEC QQ11          ; Decrement QQ11 to 0, so from here on we are using a
29833                                                                          ; space view
29834               
29835 C732 020D  20        li   ra,>60*256                 ; LDA #96           ; Set nosev_z hi = 96 (96 is the value of unity in the
     C734 6000     
29836 C736 D80D  30        movb ra,@INWK+14                ; STA INWK+14       ; rotation vector)
     C738 0061     
29837               
29838               * LSR A                  \ This instruction is commented out in the original
29839                                                                          ; source. It would halve the value of z_hi to 48, so the
29840                                                                          ; ship would start off closer to the viewer
29841               
29842 C73A D80D  30        movb ra,@INWK+7                 ; STA INWK+7        ; Set z_hi, the high byte of the ship's z-coordinate,
     C73C 005A     
29843                                                                          ; to 96, which is the distance at which the rotating
29844                                                                          ; ship starts out before coming towards us
29845               
29846 C73E 020E  20        li   rx,>7f*256                 ; LDX #127          ; Set roll counter = 127, so don't dampen the roll and
     C740 7F00     
29847 C742 D80E  30        movb rx,@INWK+29                ; STX INWK+29       ; make the roll direction clockwise
     C744 0070     
29848               
29849 C746 D80E  30        movb rx,@INWK+30                ; STX INWK+30       ; Set pitch counter = 127, so don't dampen the pitch and
     C748 0071     
29850                                                                          ; set the pitch direction to dive
29851               
29852 C74A B387  18        ab   rone,rx                    ; INX               ; Set QQ17 to 128 (so bit 7 is set) to switch to
29853 C74C D80E  30        movb rx,@QQ17                   ; STX QQ17          ; Sentence Case, with the next letter printing in upper
     C74E 007E     
29854                                                                          ; case
29855               
29856 C750 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Set up a new ship, using the ship type in TYPE
     C752 009B     
29857 C754 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP
     C756 AFC6     
29858 C758 06A0  32        bl   @jsr                       ;
     C75A FE28     
29859               
29860 C75C 020F  20        li   ry,>06*256                 ; LDY #6            ; Move the text cursor to column 6
     C75E 0600     
29861 C760 D80F  30        movb ry,@XC                     ; STY XC
     C762 002C     
29862               
29863 C764 0200  20        li   rtmp,DELAY                 ; JSR DELAY         ; Delay for 6 vertical syncs (6/50 = 0.12 seconds)
     C766 4CB4     
29864 C768 06A0  32        bl   @jsr                       ;
     C76A FE28     
29865               
29866 C76C 020D  20        li   ra,>1e*256                 ; LDA #30           ; Print recursive token 144 ("---- E L I T E ----")
     C76E 1E00     
29867 C770 0200  20        li   rtmp,plf_                  ; JSR plf           ; followed by a newline
     C772 A6D0     
29868 C774 06A0  32        bl   @jsr                       ;
     C776 FE28     
29869               
29870 C778 020F  20        li   ry,>06*256                 ; LDY #6            ; Move the text cursor to column 6 again
     C77A 0600     
29871 C77C D80F  30        movb ry,@XC                     ; STY XC
     C77E 002C     
29872               
29873 C780 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a row
29874               
29875 C782 D360  30        movb @PATG,ra                   ; LDA PATG          ; If PATG = 0, skip the following two lines, which
     C784 0F4C     
29876 C786 1306  14        jeq  awe_                       ; BEQ awe           ; print the author credits (PATG can be toggled by
29877                                                                          ; pausing the game and pressing "X")
29878               
29879 C788 020D  20        li   ra,>fe*256                 ; LDA #254          ; Print recursive token 94 ("BY D.BRABEN & I.BELL")
     C78A FE00     
29880 C78C 0200  20        li   rtmp,TT27                  ; JSR TT27
     C78E A6E8     
29881 C790 06A0  32        bl   @jsr                       ;
     C792 FE28     
29882               
29883               awe_:
29884 C794 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     C796 4CE2     
29885 C798 06A0  32        bl   @jsr                       ;
     C79A FE28     
29886                                                                          ; and move the text cursor to column 1 on row 21, i.e.
29887                                                                          ; the start of the top row of the three bottom rows.
29888                                                                          ; It also returns with Y = 0
29889               
29890 C79C D80F  30        movb ry,@DELTA                  ; STY DELTA         ; Set DELTA = 0 (i.e. ship speed = 0)
     C79E 008C     
29891               
29892 C7A0 D80F  30        movb ry,@JSTK                   ; STY JSTK          ; Set JSTK = 0 (i.e. keyboard, not joystick)
     C7A2 0F50     
29893               
29894                      .pla                            ; PLA               ; Restore the recursive token number we stored on the
     **** ****     > PLA
0001 C7A4 058A  14        inc  rsp
0002 C7A6 D35A  26        movb *rsp,ra
                   < elite.a99
29895 C7A8 0200  20        li   rtmp,ex_                   ; JSR ex            ; stack at the start of this subroutine, and print that
     C7AA A802     
29896 C7AC 06A0  32        bl   @jsr                       ;
     C7AE FE28     
29897                                                                          ; token
29898               
29899 C7B0 020D  20        li   ra,>94*256                 ; LDA #148          ; Set A to recursive token 148
     C7B2 9400     
29900               
29901 C7B4 020E  20        li   rx,>07*256                 ; LDX #7            ; Move the text cursor to column 7
     C7B6 0700     
29902 C7B8 D80E  30        movb rx,@XC                     ; STX XC
     C7BA 002C     
29903               
29904 C7BC 0200  20        li   rtmp,ex_                   ; JSR ex            ; Print recursive token 148 ("(C) ACORNSOFT 1984")
     C7BE A802     
29905 C7C0 06A0  32        bl   @jsr                       ;
     C7C2 FE28     
29906               
29907               TLL2:
29908 C7C4 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; If z_hi (the ship's distance) is 1, jump to TL1 to
     C7C6 005A     
29909 C7C8 028D  22        ci   ra,>01*256                 ; CMP #1            ; skip the following decrement
     C7CA 0100     
29910 C7CC 1301  14        jeq  TL1                        ; BEQ TL1
29911               
29912 C7CE 7347  18        sb   rone,ra                    ; DEC INWK+7        ; Decrement the ship's distance, to bring the ship
29913                                                                          ; a bit closer to us
29914               
29915               TL1:
29916 C7D0 0200  20        li   rtmp,MVEIT                 ; JSR MVEIT         ; Move the ship in space according to the orientation
     C7D2 17FE     
29917 C7D4 06A0  32        bl   @jsr                       ;
     C7D6 FE28     
29918                                                                          ; vectors and the new value in z_hi
29919               
29920 C7D8 020D  20        li   ra,>80*256                 ; LDA #128          ; Set z_lo = 128, so the closest the ship gets to us is
     C7DA 8000     
29921 C7DC D80D  30        movb ra,@INWK+6                 ; STA INWK+6        ; z_hi = 1, z_lo = 128, or 256 + 128 = 384
     C7DE 0059     
29922               
29923                      .asla                           ; ASL A             ; Set A = 0
     **** ****     > ASLA
0001 C7E0 024D  22        andi ra,>ff00
     C7E2 FF00     
0002 C7E4 0A1D  18        sla  ra,1
                   < elite.a99
29924               
29925 C7E6 D80D  30        movb ra,@INWK                   ; STA INWK          ; Set x_lo = 0, so the ship remains in the screen centre
     C7E8 0053     
29926               
29927 C7EA D80D  30        movb ra,@INWK+3                 ; STA INWK+3        ; Set y_lo = 0, so the ship remains in the screen centre
     C7EC 0056     
29928               
29929 C7EE 0200  20        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to display the ship
     C7F0 D574     
29930 C7F2 06A0  32        bl   @jsr                       ;
     C7F4 FE28     
29931               
29932 C7F6 7347  18        sb   rone,ra                    ; DEC MCNT          ; Decrement the main loop counter
29933               
29934 C7F8 D360  34        movb @VIA+>40,ra                ; LDA VIA+&40       ; Read 6522 System VIA input register IRB (SHEILA &40)
     C7FA FE40     
29935               
29936 C7FC 024D  22        andi ra,>10*256                 ; AND #%00010000    ; Bit 4 of IRB (PB4) is clear if joystick 1's fire
     C7FE 1000     
29937                                                                          ; button is pressed, otherwise it is set, so AND'ing
29938                                                                          ; the value of IRB with %10000 extracts this bit
29939               
29940               * TAX                    \ This instruction is commented out in the original
29941                                                                          ; source; it would have no effect, as the comparison
29942                                                                          ; flags are already set by the AND, and the value of X
29943                                                                          ; is not used anywhere
29944               
29945 C800 1307  14        jeq  TL2                        ; BEQ TL2           ; If the joystick fire button is pressed, jump to TL2
29946               
29947 C802 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press
     C804 CBA0     
29948 C806 06A0  32        bl   @jsr                       ;
     C808 FE28     
29949               
29950 C80A 13DC  14        jeq  TLL2                       ; BEQ TLL2          ; If no key was pressed, loop back up to move/rotate
29951                                                                          ; the ship and check again for a key press
29952               
29953 C80C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C80E FE34     
29954               
29955               TL2:
29956 C810 7347  18        sb   rone,ra                    ; DEC JSTK          ; Joystick fire button was pressed, so set JSTK to &FF
29957                                                                          ; (it was set to 0 above), to disable keyboard and
29958                                                                          ; enable joysticks
29959               
29960 C812 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C814 FE34     
29961               
29962               * ******************************************************************************
29963               *
29964               * Name: CHECK
29965               * Type: Subroutine
29966               * Category: Save and load
29967               * Summary: Calculate the checksum for the last saved commander data block
29968               * Deep dive: Commander save files
29969               *
29970               * ------------------------------------------------------------------------------
29971               *
29972               * The checksum for the last saved commander data block is saved as part of the
29973               * commander file, in two places (CHK AND CHK2), to protect against file
29974               * tampering. This routine calculates the checksum and returns it in A.
29975               *
29976               * This algorithm is also implemented in elite-checksum.py.
29977               *
29978               * ------------------------------------------------------------------------------
29979               *
29980               * Returns:
29981               *
29982               * A                   The checksum for the last saved commander data block
29983               *
29984               * ******************************************************************************
29985               
29986               CHECK:
29987 C816 020E  20        li   rx,(NT.-2)*256             ; LDX #NT%-2        ; Set X to the size of the commander data block, less
     C818 4900     
29988                                                                          ; 2 (to omit the checksum bytes and the save count)
29989               
29990                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 C81A 0A16  18        sla  rzero,1
                   < elite.a99
29991                                                                          ; C flag affecting the result
29992               
29993 C81C D34E  18        movb rx,ra                      ; TXA               ; Seed the checksum calculation by setting A to the
29994                                                                          ; size of the commander data block, less 2
29995               
29996                                                                          ; We now loop through the commander data block,
29997                                                                          ; starting at the end and looping down to the start
29998                                                                          ; (so at the start of this loop, the X-th byte is the
29999                                                                          ; last byte of the commander data block, i.e. the save
30000                                                                          ; count)
30001               
30002               QUL2:
30003                      .adc @NA.+7(rx),ra              ; ADC NA%+7,X       ; Add the X-1-th byte of the data block to A, plus the
     **** ****     > ADC
0001 C81E 1701  14        jnc  !
0002 C820 B347  18        ab   rone,ra
0003               !:
0004 C822 B36E  34        ab   @NA.+7(RX),ra
     C824 21F3     
                   < elite.a99
30004                                                                          ; C flag
30005               
30006                      .eor @NA.+8(rx)                 ; EOR NA%+8,X       ; EOR A with the X-th byte of the data block
     **** ****     > EOR
0001 C826 D02E  34        movb @NA.+8(RX),rtmp
     C828 21F4     
0002 C82A 2B40  18        xor  rtmp,ra
                   < elite.a99
30007               
30008 C82C 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30009               
30010 C82E 16F7  14        jne  QUL2                       ; BNE QUL2          ; Loop back for the next byte in the calculation, until
30011                                                                          ; we have added byte #0 and EOR'd with byte #1 of the
30012                                                                          ; data block
30013               
30014 C830 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C832 FE34     
30015               
30016               * ******************************************************************************
30017               *
30018               * Name: TRNME
30019               * Type: Subroutine
30020               * Category: Save and load
30021               * Summary: Copy the last saved commander's name from INWK to NA%
30022               *
30023               * ******************************************************************************
30024               
30025               TRNME:
30026 C834 020E  20        li   rx,>07*256                 ; LDX #7            ; The commander's name can contain a maximum of 7
     C836 0700     
30027                                                                          ; characters, and is terminated by a carriage return,
30028                                                                          ; so set up a counter in X to copy 8 characters
30029               
30030               GTL1:
30031 C838 D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Copy the X-th byte of INWK to the X-th byte of NA%
     C83A 0053     
30032 C83C DB8D  38        movb ra,@NA.(rx)                ; STA NA%,X
     C83E 21EC     
30033               
30034 C840 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30035               
30036 C842 15FA  14        jgt  GTL1                       ; BPL GTL1          ; Loop back until we have copied all 8 bytes
30037               
30038                                                                          ; Fall through into TR1 to copy the name back from NA%
30039                                                                          ; to INWK. This isn't necessary as the name is already
30040                                                                          ; there, but it does save one byte, as we don't need an
30041                                                                          ; RTS here
30042               
30043               * ******************************************************************************
30044               *
30045               * Name: TR1
30046               * Type: Subroutine
30047               * Category: Save and load
30048               * Summary: Copy the last saved commander's name from NA% to INWK
30049               *
30050               * ******************************************************************************
30051               
30052               TR1:
30053 C844 020E  20        li   rx,>07*256                 ; LDX #7            ; The commander's name can contain a maximum of 7
     C846 0700     
30054                                                                          ; characters, and is terminated by a carriage return,
30055                                                                          ; so set up a counter in X to copy 8 characters
30056               
30057               GTL2:
30058 C848 D36E  34        movb @NA.(rx),ra                ; LDA NA%,X         ; Copy the X-th byte of NA% to the X-th byte of INWK
     C84A 21EC     
30059 C84C DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X
     C84E 0053     
30060               
30061 C850 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30062               
30063 C852 15FA  14        jgt  GTL2                       ; BPL GTL2          ; Loop back until we have copied all 8 bytes
30064               
30065 C854 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C856 FE34     
30066               
30067               * ******************************************************************************
30068               *
30069               * Name: GTNME
30070               * Type: Subroutine
30071               * Category: Save and load
30072               * Summary: Fetch the name of a commander file to save or load
30073               *
30074               * ------------------------------------------------------------------------------
30075               *
30076               * Get the commander's name for loading or saving a commander file. The name is
30077               * stored in the INWK workspace and is terminated by a return character (13).
30078               *
30079               * If ESCAPE is pressed or a blank name is entered, then the name stored is set
30080               * to the name from the last saved commander block.
30081               *
30082               * ------------------------------------------------------------------------------
30083               *
30084               * Returns:
30085               *
30086               * INWK                The commander name entered, terminated by a return
30087               * character (13)
30088               *
30089               * ******************************************************************************
30090               
30091               GTNME:
30092 C858 020D  20        li   ra,>01*256                 ; LDA #1            ; Clear the top part of the screen, draw a white border,
     C85A 0100     
30093 C85C 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 1
     C85E 4BDE     
30094 C860 06A0  32        bl   @jsr                       ;
     C862 FE28     
30095               
30096 C864 020D  20        li   ra,>7b*256                 ; LDA #123          ; Print recursive token 123 ("{crlf}COMMANDER'S NAME? ")
     C866 7B00     
30097 C868 0200  20        li   rtmp,TT27                  ; JSR TT27
     C86A A6E8     
30098 C86C 06A0  32        bl   @jsr                       ;
     C86E FE28     
30099               
30100 C870 0200  20        li   rtmp,DEL8                  ; JSR DEL8          ; Wait for 8/50 of a second (0.16 seconds)
     C872 4CB0     
30101 C874 06A0  32        bl   @jsr                       ;
     C876 FE28     
30102               
30103 C878 020D  20        li   ra,>81*256                 ; LDA #%10000001    ; Clear 6522 System VIA interrupt enable register IER
     C87A 8100     
30104 C87C D80D  38        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
     C87E FE4E     
30105                                                                          ; which comes from the keyboard)
30106               
30107 C880 020D  20        li   ra,>0f*256                 ; LDA #15           ; Call OSBYTE with A = 15 (flush all buffers)
     C882 0F00     
30108 C884 D38D  18        movb ra,rx                      ; TAX
30109 C886 0200  20        li   rtmp,OSBYTE                ; JSR OSBYTE
     C888 FE22     
30110 C88A 06A0  32        bl   @jsr                       ;
     C88C FE28     
30111               
30112 C88E 020E  20        li   rx,((RLINE)%256)*256       ; LDX #LO(RLINE)    ; Set (Y X) to point to the RLINE parameter block
     C890 5400     
30113 C892 020F  20        li   ry,((RLINE)/256)*256       ; LDY #HI(RLINE)    ; configuration block below
     C894 C900     
30114               
30115 C896 020D  20        li   ra,>00*256                 ; LDA #0            ; Call OSWORD with A = 0 to read a line from the current
     C898 0000     
30116 C89A 0200  20        li   rtmp,OSWORD                ; JSR OSWORD        ; input stream (i.e. the keyboard)
     C89C FE24     
30117 C89E 06A0  32        bl   @jsr                       ;
     C8A0 FE28     
30118               
30119               * LDA #%00000001         \ These instructions are commented out in the original
30120               * STA VIA+&4E            \ source, but they would set 6522 System VIA interrupt
30121                                                                          ; enable register IER (SHEILA &4E) bit 1 (i.e. disable
30122                                                                          ; the CA2 interrupt, which comes from the keyboard)
30123               
30124 C8A2 18D0  14        joc  TR1                        ; BCS TR1           ; The C flag will be set if we pressed ESCAPE when
30125                                                                          ; entering the name, in which case jump to TR1 to copy
30126                                                                          ; the last saved commander's name from NA% to INWK
30127                                                                          ; and return from the subroutine there
30128               
30129 C8A4 D34F  18        movb ry,ra                      ; TYA               ; The OSWORD call returns the length of the commander's
30130                                                                          ; name in Y, so transfer this to A
30131               
30132 C8A6 13CE  14        jeq  TR1                        ; BEQ TR1           ; If A = 0, no name was entered, so jump to TR1 to copy
30133                                                                          ; the last saved commander's name from NA% to INWK
30134                                                                          ; and return from the subroutine there
30135               
30136 C8A8 0460  28        b    @TT67                      ; JMP TT67          ; We have a name, so jump to TT67 to print a newline
     C8AA 4FA6     
30137                                                                          ; and return from the subroutine using a tail call
30138               
30139               * ******************************************************************************
30140               *
30141               * Name: RLINE
30142               * Type: Variable
30143               * Category: Text
30144               * Summary: The OSWORD configuration block used to fetch a line of text from
30145               * the keyboard
30146               *
30147               * ******************************************************************************
30148               
30149               RLINE:
30150 C8AC 0053            data INWK                                           ; The address to store the input, so the commander's
30151                                                                          ; name will be stored in INWK as it is typed
30152               
30153 C8AE 07              byte >07                                            ; Maximum line length = 7, as that's the maximum size
30154                                                                          ; for a commander's name
30155               
30156 C8AF   21            byte '!'                                            ; Allow ASCII characters from "!" through to "z" in
30157 C8B0 7A              byte 'z'                                            ; the name
30158               
30159               * ******************************************************************************
30160               *
30161               * Name: ZERO
30162               * Type: Subroutine
30163               * Category: Utility routines
30164               * Summary: Zero-fill pages &9, &A, &B, &C and &D
30165               *
30166               * ------------------------------------------------------------------------------
30167               *
30168               * This resets the following workspaces to zero:
30169               *
30170               * * The ship data blocks ascending from K% at &0900
30171               *
30172               * * The ship line heap descending from WP at &0D40
30173               *
30174               * * WP workspace variables from FRIN to de, which include the ship slots for
30175               * the local bubble of universe, and various flight and ship status variables
30176               * (only a portion of the LSX/LSO sun line heap is cleared)
30177               *
30178               * ******************************************************************************
30179               
30180               ZERO:
30181 C8B2 020E  20        li   rx,>0d*256                 ; LDX #&D           ; Point X to page &D
     C8B4 0D00     
30182               
30183               ZEL:
30184 C8B6 0200  20        li   rtmp,ZES1                  ; JSR ZES1          ; Call ZES1 to zero-fill the page in X
     C8B8 C8C6     
30185 C8BA 06A0  32        bl   @jsr                       ;
     C8BC FE28     
30186               
30187 C8BE 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to point to the next page
30188               
30189 C8C0 028E  22        ci   rx,>09*256                 ; CPX #9            ; If X is > 9 (i.e. is &A, &B or &C), then loop back
     C8C2 0900     
30190 C8C4 16F8  14        jne  ZEL                        ; BNE ZEL           ; up to clear the next page
30191               
30192                                                                          ; Then fall through into ZES1 with X set to 9, so we
30193                                                                          ; clear page &9 too
30194               
30195               * ******************************************************************************
30196               *
30197               * Name: ZES1
30198               * Type: Subroutine
30199               * Category: Utility routines
30200               * Summary: Zero-fill the page whose number is in X
30201               *
30202               * ------------------------------------------------------------------------------
30203               *
30204               * Arguments:
30205               *
30206               * X                   The page we want to zero-fill
30207               *
30208               * ******************************************************************************
30209               
30210               ZES1:
30211 C8C6 020F  20        li   ry,>00*256                 ; LDY #0            ; If we set Y = SC = 0 and fall through into ZES2
     C8C8 0000     
30212 C8CA D80F  30        movb ry,@SC                     ; STY SC            ; below, then we will zero-fill 255 bytes starting from
     C8CC 0007     
30213                                                                          ; SC - in other words, we will zero-fill the whole of
30214                                                                          ; page X
30215               
30216               * ******************************************************************************
30217               *
30218               * Name: ZES2
30219               * Type: Subroutine
30220               * Category: Utility routines
30221               * Summary: Zero-fill a specific page
30222               *
30223               * ------------------------------------------------------------------------------
30224               *
30225               * Zero-fill from address (X SC) + Y to (X SC) + &FF.
30226               *
30227               * ------------------------------------------------------------------------------
30228               *
30229               * Arguments:
30230               *
30231               * X                   The high byte (i.e. the page) of the starting point of
30232               * the zero-fill
30233               *
30234               * Y                   The offset from (X SC) where we start zeroing, counting
30235               * up to &FF
30236               *
30237               * SC                  The low byte (i.e. the offset into the page) of the
30238               * starting point of the zero-fill
30239               *
30240               * ------------------------------------------------------------------------------
30241               *
30242               * Returns:
30243               *
30244               * Z flag              Z flag is set
30245               *
30246               * ******************************************************************************
30247               
30248               ZES2:
30249 C8CE 020D  20        li   ra,>00*256                 ; LDA #0            ; Load A with the byte we want to fill the memory block
     C8D0 0000     
30250                                                                          ; with - i.e. zero
30251               
30252 C8D2 D80E  30        movb rx,@SC+1                   ; STX SC+1          ; We want to zero-fill page X, so store this in the
     C8D4 0008     
30253                                                                          ; high byte of SC, so the 16-bit address in SC and
30254                                                                          ; SC+1 is now pointing to the SC-th byte of page X
30255               
30256               ZEL1:
30257                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Zero the Y-th byte of the block pointed to by SC,
     **** ****     > ST_IND_Y_IDX
0001 C8D6 D820  42        movb @SC,@rtmplb
     C8D8 0007     
     C8DA 8301     
0002 C8DC D020  30        movb @SC+1,rtmp
     C8DE 0008     
0003 C8E0 06CF  14        swpb ry
0004 C8E2 A00F  18        a    ry,rtmp
0005 C8E4 06CF  14        swpb ry
0006 C8E6 D40D  30        movb RA,*rtmp
                   < elite.a99
30258                                                                          ; so that's effectively the Y-th byte before SC
30259               
30260 C8E8 B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter
30261               
30262 C8EA 16F5  14        jne  ZEL1                       ; BNE ZEL1          ; Loop back to zero the next byte
30263               
30264 C8EC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C8EE FE34     
30265               
30266               * ******************************************************************************
30267               *
30268               * Name: SVE
30269               * Type: Subroutine
30270               * Category: Save and load
30271               * Summary: Save the commander file
30272               * Deep dive: Commander save files
30273               * The competition code
30274               *
30275               * ******************************************************************************
30276               
30277               SVE:
30278 C8F0 0200  20        li   rtmp,GTNME                 ; JSR GTNME         ; Clear the screen and ask for the commander filename
     C8F2 C858     
30279 C8F4 06A0  32        bl   @jsr                       ;
     C8F6 FE28     
30280                                                                          ; to save, storing the name at INWK
30281               
30282 C8F8 0200  20        li   rtmp,TRNME                 ; JSR TRNME         ; Transfer the commander filename from INWK to NA%
     C8FA C834     
30283 C8FC 06A0  32        bl   @jsr                       ;
     C8FE FE28     
30284               
30285 C900 0200  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     C902 C8B2     
30286 C904 06A0  32        bl   @jsr                       ;
     C906 FE28     
30287                                                                          ; the ship data blocks, the ship line heap, the ship
30288                                                                          ; slots for the local bubble of universe, and various
30289                                                                          ; flight and ship status variables
30290               
30291                      .lsr @SVC                       ; LSR SVC           ; Halve the save count value in SVC
     **** ****     > LSR
0001 C908 D020  30        movb @SVC,rtmp
     C90A 0349     
0002 C90C 0910  18        srl  rtmp,1
0003 C90E D800  30        movb rtmp,@SVC
     C910 0349     
                   < elite.a99
30292               
30293 C912 020E  20        li   rx,(NT.)*256               ; LDX #NT%          ; We now want to copy the current commander data block
     C914 4B00     
30294                                                                          ; from location TP to the last saved commander block at
30295                                                                          ; NA%+8, so set a counter in X to copy the NT% bytes in
30296                                                                          ; the commander data block
30297                                                                          ;
30298                                                                          ; We also want to copy the data block to another
30299                                                                          ; location &0B00, which is normally used for the ship
30300                                                                          ; lines heap
30301               
30302               SVL1:
30303 C916 D36E  34        movb @TP(rx),ra                 ; LDA TP,X          ; Copy the X-th byte of TP to the X-th byte of &0B00
     C918 0300     
30304 C91A DB8D  38        movb ra,@>0B00(rx)              ; STA &0B00,X       ; and NA%+8
     C91C 0B00     
30305 C91E DB8D  38        movb ra,@NA.+8(rx)              ; STA NA%+8,X
     C920 21F4     
30306               
30307 C922 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30308               
30309 C924 15F8  14        jgt  SVL1                       ; BPL SVL1          ; Loop back until we have copied all the bytes in the
30310                                                                          ; commander data block
30311               
30312 C926 0200  20        li   rtmp,CHECK                 ; JSR CHECK         ; Call CHECK to calculate the checksum for the last
     C928 C816     
30313 C92A 06A0  32        bl   @jsr                       ;
     C92C FE28     
30314                                                                          ; saved commander and return it in A
30315               
30316 C92E D80D  38        movb ra,@CHK                    ; STA CHK           ; Store the checksum in CHK, which is at the end of the
     C930 2242     
30317                                                                          ; last saved commander block
30318               
30319                      .pha                            ; PHA               ; Store the checksum on the stack
     **** ****     > PHA
0001 C932 D68D  30        movb ra,*rsp
0002 C934 060A  14        dec  rsp
                   < elite.a99
30320               
30321 C936 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set K = checksum with bit 7 set
     C938 8000     
30322 C93A D80D  30        movb ra,@K                      ; STA K
     C93C 003D     
30323               
30324                      .eor @COK                       ; EOR COK           ; Set K+2 = K EOR COK (the competition flags)
     **** ****     > EOR
0001 C93E D020  30        movb @COK,rtmp
     C940 030E     
0002 C942 2B40  18        xor  rtmp,ra
                   < elite.a99
30325 C944 D80D  30        movb ra,@K+2                    ; STA K+2
     C946 003F     
30326               
30327                      .eor @CASH+2                    ; EOR CASH+2        ; Set K+1 = K+2 EOR CASH+2 (the third cash byte)
     **** ****     > EOR
0001 C948 D020  30        movb @CASH+2,rtmp
     C94A 030B     
0002 C94C 2B40  18        xor  rtmp,ra
                   < elite.a99
30328 C94E D80D  30        movb ra,@K+1                    ; STA K+1
     C950 003E     
30329               
30330                      .eoi (>5a*256)                  ; EOR #&5A          ; Set K+3 = K+1 EOR &5A EOR TALLY+1 (the high byte of
     **** ****     > EOI
0001 C952 0200  20        li   rtmp,(>5A*256)
     C954 5A00     
0002 C956 2B40  18        xor  rtmp,ra
                   < elite.a99
30331                      .eor @TALLY+1                   ; EOR TALLY+1       ; the kill tally)
     **** ****     > EOR
0001 C958 D020  30        movb @TALLY+1,rtmp
     C95A 0348     
0002 C95C 2B40  18        xor  rtmp,ra
                   < elite.a99
30332 C95E D80D  30        movb ra,@K+3                    ; STA K+3
     C960 0040     
30333               
30334 C962 0200  20        li   rtmp,BPRNT                 ; JSR BPRNT         ; Print the competition number stored in K to K+3. The
     C964 301C     
30335 C966 06A0  32        bl   @jsr                       ;
     C968 FE28     
30336                                                                          ; value of U might affect how this is printed, and as
30337                                                                          ; it's a temporary variable in zero page that isn't
30338                                                                          ; reset by ZERO, it might have any value, but as the
30339                                                                          ; competition code is a 10-digit number, this just means
30340                                                                          ; it may or may not have an extra space of padding
30341               
30342 C96A 0200  20        li   rtmp,TT67                  ; JSR TT67          ; Call TT67 twice to print two newlines
     C96C 4FA6     
30343 C96E 06A0  32        bl   @jsr                       ;
     C970 FE28     
30344 C972 0200  20        li   rtmp,TT67                  ; JSR TT67
     C974 4FA6     
30345 C976 06A0  32        bl   @jsr                       ;
     C978 FE28     
30346               
30347                      .pla                            ; PLA               ; Restore the checksum from the stack
     **** ****     > PLA
0001 C97A 058A  14        inc  rsp
0002 C97C D35A  26        movb *rsp,ra
                   < elite.a99
30348               
30349 C97E D80D  30        movb ra,@>0B00+NT.              ; STA &0B00+NT%     ; Store the checksum in the last byte of the save file
     C980 0B4B     
30350                                                                          ; at &0B00 (the equivalent of CHK in the last saved
30351                                                                          ; block)
30352               
30353                      .eoi (>a9*256)                  ; EOR #&A9          ; Store the checksum EOR &A9 in CHK2, the penultimate
     **** ****     > EOI
0001 C982 0200  20        li   rtmp,(>A9*256)
     C984 A900     
0002 C986 2B40  18        xor  rtmp,ra
                   < elite.a99
30354 C988 D80D  38        movb ra,@CHK2                   ; STA CHK2          ; byte of the last saved commander block
     C98A 2241     
30355               
30356 C98C D80D  30        movb ra,@>0AFF+NT.              ; STA &0AFF+NT%     ; Store the checksum EOR &A9 in the penultimate byte of
     C98E 0B4A     
30357                                                                          ; the save file at &0B00 (the equivalent of CHK2 in the
30358                                                                          ; last saved block)
30359               
30360 C990 020F  20        li   ry,>0b*256                 ; LDY #&B           ; Set up an OSFILE block at &0C00, containing:
     C992 0B00     
30361 C994 D80F  30        movb ry,@>0C0B                  ; STY &0C0B         ;
     C996 0C0B     
30362 C998 B3C7  18        ab   rone,ry                    ; INY               ; Start address for save = &00000B00 in &0C0A to &0C0D
30363 C99A D80F  30        movb ry,@>0C0F                  ; STY &0C0F         ;
     C99C 0C0F     
30364                                                                          ; End address for save = &00000C00 in &0C0E to &0C11
30365                                                                          ;
30366                                                                          ; Y is left containing &C which we use below
30367               
30368 C99E 020D  20        li   ra,>81*256                 ; LDA #%10000001    ; Clear 6522 System VIA interrupt enable register IER
     C9A0 8100     
30369 C9A2 D80D  38        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
     C9A4 FE4E     
30370                                                                          ; which comes from the keyboard)
30371               
30372 C9A6 B347  18        ab   rone,ra                    ; INC SVN           ; Increment SVN to indicate we are about to start saving
30373               
30374 C9A8 020D  20        li   ra,>00*256                 ; LDA #0            ; Call QUS1 with A = 0, Y = &C to save the commander
     C9AA 0000     
30375 C9AC 0200  20        li   rtmp,QUS1                  ; JSR QUS1          ; file with the filename we copied to INWK at the start
     C9AE C9C0     
30376 C9B0 06A0  32        bl   @jsr                       ;
     C9B2 FE28     
30377                                                                          ; of this routine
30378               
30379 C9B4 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0 for storing in SVN below
     C9B6 0000     
30380               
30381               * STX VIA+&4E            \ This instruction is commented out in the original
30382                                                                          ; source. It would affect the 6522 System VIA interrupt
30383                                                                          ; enable register IER (SHEILA &4E) if any of bits 0-6
30384                                                                          ; of X were set, but they aren't, so this instruction
30385                                                                          ; would have no effect anyway
30386               
30387               * DEX                    \ This instruction is commented out in the original
30388                                                                          ; source. It would end up setting SVN to &FF, which
30389                                                                          ; affects the logic in the IRQ1 handler
30390               
30391 C9B8 D80E  38        movb rx,@SVN                    ; STX SVN           ; Set SVN to 0 to indicate we are done saving
     C9BA F439     
30392               
30393 C9BC 0460  28        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show Status Mode)
     C9BE C704     
30394               
30395               * ******************************************************************************
30396               *
30397               * Name: QUS1
30398               * Type: Subroutine
30399               * Category: Save and load
30400               * Summary: Save or load the commander file
30401               * Deep dive: Commander save files
30402               *
30403               * ------------------------------------------------------------------------------
30404               *
30405               * The filename should be stored at INWK, terminated with a carriage return (13).
30406               * The routine should be called with Y set to &C.
30407               *
30408               * ------------------------------------------------------------------------------
30409               *
30410               * Arguments:
30411               *
30412               * A                   File operation to be performed. Can be one of the
30413               * following:
30414               *
30415               * * 0 (save file)
30416               *
30417               * * &FF (load file)
30418               *
30419               * Y                   Points to the page number containing the OSFILE block,
30420               * which must be &C because that's where the pointer to the
30421               * filename in INWK is stored below (by the STX &0C00
30422               * instruction)
30423               *
30424               * ******************************************************************************
30425               
30426               QUS1:
30427 C9C0 020E  20        li   rx,(INWK)*256              ; LDX #INWK         ; Store a pointer to INWK at the start of the block at
     C9C2 5300     
30428 C9C4 D80E  30        movb rx,@>0C00                  ; STX &0C00         ; &0C00, storing #INWK in the low byte because INWK is
     C9C6 0C00     
30429                                                                          ; in zero page
30430               
30431 C9C8 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X to 0 so (Y X) = &0C00
     C9CA 0000     
30432               
30433 C9CC 0460  28        b    @OSFILE                    ; JMP OSFILE        ; Jump to OSFILE to do the file operation specified in
     C9CE FE26     
30434                                                                          ; &0C00 (i.e. save or load a file depending on the value
30435                                                                          ; of A), returning from the subroutine using a tail call
30436               
30437               * ******************************************************************************
30438               *
30439               * Name: LOD
30440               * Type: Subroutine
30441               * Category: Save and load
30442               * Summary: Load a commander file
30443               *
30444               * ------------------------------------------------------------------------------
30445               *
30446               * The filename should be stored at INWK, terminated with a carriage return (13).
30447               *
30448               * ******************************************************************************
30449               
30450               LOD:
30451 C9D0 020E  20        li   rx,>02*256                 ; LDX #2            ; Enable the ESCAPE key and clear memory if the BREAK
     C9D2 0200     
30452 C9D4 0200  20        li   rtmp,FX200                 ; JSR FX200         ; key is pressed (*FX 200,2)
     C9D6 CA16     
30453 C9D8 06A0  32        bl   @jsr                       ;
     C9DA FE28     
30454               
30455 C9DC 0200  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     C9DE C8B2     
30456 C9E0 06A0  32        bl   @jsr                       ;
     C9E2 FE28     
30457                                                                          ; the ship data blocks, the ship line heap, the ship
30458                                                                          ; slots for the local bubble of universe, and various
30459                                                                          ; flight and ship status variables
30460               
30461 C9E4 020F  20        li   ry,>0b*256                 ; LDY #&B           ; Set up an OSFILE block at &0C00, containing:
     C9E6 0B00     
30462 C9E8 D80F  30        movb ry,@>0C03                  ; STY &0C03         ;
     C9EA 0C03     
30463 C9EC B347  18        ab   rone,ra                    ; INC &0C0B         ; Load address = &00000B00 in &0C02 to &0C05
30464                                                                          ;
30465                                                                          ; Length of file = &00000100 in &0C0A to &0C0D
30466               
30467 C9EE B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to &C, which we use next
30468               
30469 C9F0 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Call QUS1 with A = &FF, Y = &C to load the commander
     C9F2 FF00     
30470 C9F4 0200  20        li   rtmp,QUS1                  ; JSR QUS1          ; file to address &0B00
     C9F6 C9C0     
30471 C9F8 06A0  32        bl   @jsr                       ;
     C9FA FE28     
30472               
30473 C9FC D360  30        movb @>0B00,ra                  ; LDA &0B00         ; If the first byte of the loaded file has bit 7 set,
     C9FE 0B00     
30474 CA00 1112  14        jlt  SPS1+1                     ; BMI SPS1+1        ; jump to SPS+1, which is the second byte of an LDA #0
30475                                                                          ; instruction, i.e. a BRK instruction, which will force
30476                                                                          ; an interrupt to call the address in BRKV, which is set
30477                                                                          ; to BR1... so this instruction restarts the game from
30478                                                                          ; the title screen. Valid commander files for the
30479                                                                          ; cassette version of Elite only have 0 for the first
30480                                                                          ; byte, as there are no missions in this version, so
30481                                                                          ; having bit 7 set is invalid anyway
30482               
30483 CA02 020E  20        li   rx,(NT.)*256               ; LDX #NT%          ; We have successfully loaded the commander file at
     CA04 4B00     
30484                                                                          ; &0B00, so now we want to copy it to the last saved
30485                                                                          ; commander data block at NA%+8, so we set up a counter
30486                                                                          ; in X to copy NT% bytes
30487               
30488               LOL1:
30489 CA06 D36E  34        movb @>0B00(rx),ra              ; LDA &0B00,X       ; Copy the X-th byte of &0B00 to the X-th byte of NA%+8
     CA08 0B00     
30490 CA0A DB8D  38        movb ra,@NA.+8(rx)              ; STA NA%+8,X
     CA0C 21F4     
30491               
30492 CA0E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30493               
30494 CA10 15FA  14        jgt  LOL1                       ; BPL LOL1          ; Loop back until we have copied all NT% bytes
30495               
30496 CA12 020E  20        li   rx,>03*256                 ; LDX #3            ; Fall through into FX200 to disable the ESCAPE key and
     CA14 0300     
30497                                                                          ; clear memory if the BREAK key is pressed (*FX 200,3)
30498                                                                          ; and return from the subroutine there
30499               
30500               * ******************************************************************************
30501               *
30502               * Name: FX200
30503               * Type: Subroutine
30504               * Category: Utility routines
30505               * Summary: Set the behaviour of the ESCAPE and BREAK keys
30506               *
30507               * ------------------------------------------------------------------------------
30508               *
30509               * This is the equivalent of a *FX 200 command, which controls the behaviour of
30510               * the ESCAPE and BREAK keys.
30511               *
30512               * ------------------------------------------------------------------------------
30513               *
30514               * Arguments:
30515               *
30516               * X                   Controls the behaviour as follows:
30517               *
30518               * * 0 = Enable ESCAPE key
30519               * Normal BREAK key action
30520               *
30521               * * 1 = Disable ESCAPE key
30522               * Normal BREAK key action
30523               *
30524               * * 2 = Enable ESCAPE key
30525               * Clear memory if the BREAK key is pressed
30526               *
30527               * * 3 = Disable ESCAPE key
30528               * Clear memory if the BREAK key is pressed
30529               *
30530               * ******************************************************************************
30531               
30532               FX200:
30533 CA16 020F  20        li   ry,>00*256                 ; LDY #0            ; Call OSBYTE 200 with Y = 0, so the new value is set to
     CA18 0000     
30534 CA1A 020D  20        li   ra,>c8*256                 ; LDA #200          ; X, and return from the subroutine using a tail call
     CA1C C800     
30535 CA1E 0460  28        b    @OSBYTE                    ; JMP OSBYTE
     CA20 FE22     
30536               
30537 CA22 0460  28        b    @rts                       ; RTS               ; This instruction has no effect, as we already returned
     CA24 FE34     
30538                                                                          ; from the subroutine
30539               
30540               * ******************************************************************************
30541               *
30542               * Name: SPS1
30543               * Type: Subroutine
30544               * Category: Maths (Geometry)
30545               * Summary: Calculate the vector to the planet and store it in XX15
30546               *
30547               * ------------------------------------------------------------------------------
30548               *
30549               * Other entry points:
30550               *
30551               * SPS1+1              A BRK instruction
30552               *
30553               * ******************************************************************************
30554               
30555               SPS1:
30556 CA26 020E  20        li   rx,>00*256                 ; LDX #0            ; Copy the two high bytes of the planet's x-coordinate
     CA28 0000     
30557 CA2A 0200  20        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(2 1 0), separating out the sign bit into K3+2
     CA2C AF34     
30558 CA2E 06A0  32        bl   @jsr                       ;
     CA30 FE28     
30559               
30560 CA32 020E  20        li   rx,>03*256                 ; LDX #3            ; Copy the two high bytes of the planet's y-coordinate
     CA34 0300     
30561 CA36 0200  20        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(5 4 3), separating out the sign bit into K3+5
     CA38 AF34     
30562 CA3A 06A0  32        bl   @jsr                       ;
     CA3C FE28     
30563               
30564 CA3E 020E  20        li   rx,>06*256                 ; LDX #6            ; Copy the two high bytes of the planet's z-coordinate
     CA40 0600     
30565 CA42 0200  20        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(8 7 6), separating out the sign bit into K3+8
     CA44 AF34     
30566 CA46 06A0  32        bl   @jsr                       ;
     CA48 FE28     
30567               
30568                                                                          ; Fall through into TAS2 to build XX15 from K3
30569               
30570               * ******************************************************************************
30571               *
30572               * Name: TAS2
30573               * Type: Subroutine
30574               * Category: Maths (Geometry)
30575               * Summary: Normalise the three-coordinate vector in K3
30576               *
30577               * ------------------------------------------------------------------------------
30578               *
30579               * Normalise the vector in K3, which has 16-bit values and separate sign bits,
30580               * and store the normalised version in XX15 as a signed 8-bit vector.
30581               *
30582               * A normalised vector (also known as a unit vector) has length 1, so this
30583               * routine takes an existing vector in K3 and scales it so the length of the
30584               * new vector is 1. This is used in two places: when drawing the compass, and
30585               * when applying AI tactics to ships.
30586               *
30587               * We do this in two stages. This stage shifts the 16-bit vector coordinates in
30588               * K3 to the left as far as they will go without losing any bits off the end, so
30589               * we can then take the high bytes and use them as the most accurate 8-bit vector
30590               * to normalise. Then the next stage (in routine NORM) does the normalisation.
30591               *
30592               * ------------------------------------------------------------------------------
30593               *
30594               * Arguments:
30595               *
30596               * K3(2 1 0)           The 16-bit x-coordinate as (x_sign x_hi x_lo), where
30597               * x_sign is just bit 7
30598               *
30599               * K3(5 4 3)           The 16-bit y-coordinate as (y_sign y_hi y_lo), where
30600               * y_sign is just bit 7
30601               *
30602               * K3(8 7 6)           The 16-bit z-coordinate as (z_sign z_hi z_lo), where
30603               * z_sign is just bit 7
30604               *
30605               * ------------------------------------------------------------------------------
30606               *
30607               * Returns:
30608               *
30609               * XX15                The normalised vector, with:
30610               *
30611               * * The x-coordinate in XX15
30612               *
30613               * * The y-coordinate in XX15+1
30614               *
30615               * * The z-coordinate in XX15+2
30616               *
30617               * ------------------------------------------------------------------------------
30618               *
30619               * Other entry points:
30620               *
30621               * TA2                 Calculate the length of the vector in XX15 (ignoring the
30622               * low coordinates), returning it in Q
30623               *
30624               * ******************************************************************************
30625               
30626               TAS2:
30627 CA4A D360  30        movb @K3,ra                     ; LDA K3            ; OR the three low bytes and 1 to get a byte that has
     CA4C 00D2     
30628 CA4E F360  30        socb @K3+3,ra                   ; ORA K3+3          ; a 1 wherever any of the three low bytes has a 1
     CA50 00D5     
30629 CA52 F360  30        socb @K3+6,ra                   ; ORA K3+6          ; (as well as always having bit 0 set), and store in
     CA54 00D8     
30630 CA56 026D  22        ori  ra,>01*256                 ; ORA #1            ; K3+9
     CA58 0100     
30631 CA5A D80D  30        movb ra,@K3+9                   ; STA K3+9
     CA5C 00DB     
30632               
30633 CA5E D360  30        movb @K3+1,ra                   ; LDA K3+1          ; OR the three high bytes to get a byte in A that has a
     CA60 00D3     
30634 CA62 F360  30        socb @K3+4,ra                   ; ORA K3+4          ; 1 wherever any of the three high bytes has a 1
     CA64 00D6     
30635 CA66 F360  30        socb @K3+7,ra                   ; ORA K3+7
     CA68 00D9     
30636               
30637                                                                          ; (A K3+9) now has a 1 wherever any of the 16-bit
30638                                                                          ; values in K3 has a 1
30639               TAL2:
30640                      .asl @K3+9                      ; ASL K3+9          ; Shift (A K3+9) to the left, so bit 7 of the high byte
     **** ****     > ASL
0001 CA6A D020  30        movb @K3+9,rtmp
     CA6C 00DB     
0002 CA6E 0240  22        andi rtmp,>ff00
     CA70 FF00     
0003 CA72 0A10  18        sla  rtmp,1
0004 CA74 D800  30        movb rtmp,@K3+9
     CA76 00DB     
                   < elite.a99
30641 CA78 06A0  32        bl   @rola                      ; ROL A             ; goes into the C flag
     CA7A FE3E     
30642               
30643 CA7C 1822  14        joc  TA2                        ; BCS TA2           ; If the left shift pushed a 1 out of the end, then we
30644                                                                          ; know that at least one of the coordinates has a 1 in
30645                                                                          ; this position, so jump to TA2 as we can't shift the
30646                                                                          ; values in K3 any further to the left
30647               
30648                      .asl @K3                        ; ASL K3            ; Shift K3(1 0), the x-coordinate, to the left
     **** ****     > ASL
0001 CA7E D020  30        movb @K3,rtmp
     CA80 00D2     
0002 CA82 0240  22        andi rtmp,>ff00
     CA84 FF00     
0003 CA86 0A10  18        sla  rtmp,1
0004 CA88 D800  30        movb rtmp,@K3
     CA8A 00D2     
                   < elite.a99
30649 CA8C 0204  20        li   rarg1,K3+1                 ; ROL K3+1
     CA8E 00D3     
30650 CA90 06A0  32        bl   @rol                       ;
     CA92 FE4E     
30651               
30652                      .asl @K3+3                      ; ASL K3+3          ; Shift K3(4 3), the y-coordinate, to the left
     **** ****     > ASL
0001 CA94 D020  30        movb @K3+3,rtmp
     CA96 00D5     
0002 CA98 0240  22        andi rtmp,>ff00
     CA9A FF00     
0003 CA9C 0A10  18        sla  rtmp,1
0004 CA9E D800  30        movb rtmp,@K3+3
     CAA0 00D5     
                   < elite.a99
30653 CAA2 0204  20        li   rarg1,K3+4                 ; ROL K3+4
     CAA4 00D6     
30654 CAA6 06A0  32        bl   @rol                       ;
     CAA8 FE4E     
30655               
30656                      .asl @K3+6                      ; ASL K3+6          ; Shift K3(6 7), the z-coordinate, to the left
     **** ****     > ASL
0001 CAAA D020  30        movb @K3+6,rtmp
     CAAC 00D8     
0002 CAAE 0240  22        andi rtmp,>ff00
     CAB0 FF00     
0003 CAB2 0A10  18        sla  rtmp,1
0004 CAB4 D800  30        movb rtmp,@K3+6
     CAB6 00D8     
                   < elite.a99
30657 CAB8 0204  20        li   rarg1,K3+7                 ; ROL K3+7
     CABA 00D9     
30658 CABC 06A0  32        bl   @rol                       ;
     CABE FE4E     
30659               
30660 CAC0 17D4  14        jnc  TAL2                       ; BCC TAL2          ; Jump back to TAL2 to do another shift left (this BCC
30661                                                                          ; is effectively a JMP as we know bit 7 of K3+7 is not a
30662                                                                          ; 1, as otherwise bit 7 of A would have been a 1 and we
30663                                                                          ; would have taken the BCS above)
30664               
30665               TA2:
30666 CAC2 D360  30        movb @K3+1,ra                   ; LDA K3+1          ; Fetch the high byte of the x-coordinate from our left-
     CAC4 00D3     
30667 CAC6 091D  18        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
30668 CAC8 F360  30        socb @K3+2,ra                   ; ORA K3+2          ; sign bit in there from the x_sign part of K3, and
     CACA 00D4     
30669 CACC D80D  30        movb ra,@XX15                   ; STA XX15          ; store the resulting signed 8-bit x-coordinate in XX15
     CACE 0031     
30670               
30671 CAD0 D360  30        movb @K3+4,ra                   ; LDA K3+4          ; Fetch the high byte of the y-coordinate from our left-
     CAD2 00D6     
30672 CAD4 091D  18        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
30673 CAD6 F360  30        socb @K3+5,ra                   ; ORA K3+5          ; sign bit in there from the y_sign part of K3, and
     CAD8 00D7     
30674 CADA D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; store the resulting signed 8-bit y-coordinate in
     CADC 0032     
30675                                                                          ; XX15+1
30676               
30677 CADE D360  30        movb @K3+7,ra                   ; LDA K3+7          ; Fetch the high byte of the z-coordinate from our left-
     CAE0 00D9     
30678 CAE2 091D  18        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
30679 CAE4 F360  30        socb @K3+8,ra                   ; ORA K3+8          ; sign bit in there from the z_sign part of K3, and
     CAE6 00DA     
30680 CAE8 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; store the resulting signed 8-bit  z-coordinate in
     CAEA 0033     
30681                                                                          ; XX15+2
30682               
30683                                                                          ; Now we have a signed 8-bit version of the vector K3 in
30684                                                                          ; XX15, so fall through into NORM to normalise it
30685               
30686               * ******************************************************************************
30687               *
30688               * Name: NORM
30689               * Type: Subroutine
30690               * Category: Maths (Geometry)
30691               * Summary: Normalise the three-coordinate vector in XX15
30692               * Deep dive: Tidying orthonormal vectors
30693               * Orientation vectors
30694               *
30695               * ------------------------------------------------------------------------------
30696               *
30697               * We do this by dividing each of the three coordinates by the length of the
30698               * vector, which we can calculate using Pythagoras. Once normalised, 96 (&60) is
30699               * used to represent a value of 1, and 96 with bit 7 set (&E0) is used to
30700               * represent -1. This enables us to represent fractional values of less than 1
30701               * using integers.
30702               *
30703               * ------------------------------------------------------------------------------
30704               *
30705               * Arguments:
30706               *
30707               * XX15                The vector to normalise, with:
30708               *
30709               * * The x-coordinate in XX15
30710               *
30711               * * The y-coordinate in XX15+1
30712               *
30713               * * The z-coordinate in XX15+2
30714               *
30715               * ------------------------------------------------------------------------------
30716               *
30717               * Returns:
30718               *
30719               * XX15                The normalised vector
30720               *
30721               * Q                   The length of the original XX15 vector
30722               *
30723               * ------------------------------------------------------------------------------
30724               *
30725               * Other entry points:
30726               *
30727               * NO1                 Contains an RTS
30728               *
30729               * ******************************************************************************
30730               
30731               NORM:
30732 CAEC D360  30        movb @XX15,ra                   ; LDA XX15          ; Fetch the x-coordinate into A
     CAEE 0031     
30733               
30734 CAF0 0200  20        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = x^2
     CAF2 436A     
30735 CAF4 06A0  32        bl   @jsr                       ;
     CAF6 FE28     
30736               
30737 CAF8 D80D  30        movb ra,@R                      ; STA R             ; Set (R Q) = (A P) = x^2
     CAFA 0091     
30738 CAFC D360  30        movb @P,ra                      ; LDA P
     CAFE 001B     
30739 CB00 D80D  30        movb ra,@Q                      ; STA Q
     CB02 0090     
30740               
30741 CB04 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Fetch the y-coordinate into A
     CB06 0032     
30742               
30743 CB08 0200  20        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = y^2
     CB0A 436A     
30744 CB0C 06A0  32        bl   @jsr                       ;
     CB0E FE28     
30745               
30746 CB10 D80D  30        movb ra,@T                      ; STA T             ; Set (T P) = (A P) = y^2
     CB12 00D1     
30747               
30748 CB14 D360  30        movb @P,ra                      ; LDA P             ; Set (R Q) = (R Q) + (T P) = x^2 + y^2
     CB16 001B     
30749                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 CB18 1701  14        jnc  !
0002 CB1A B347  18        ab   rone,ra
0003               !:
0004 CB1C B360  30        ab   @Q,ra
     CB1E 0090     
                   < elite.a99
30750 CB20 D80D  30        movb ra,@Q                      ; STA Q             ; First, doing the low bytes, Q = Q + P
     CB22 0090     
30751               
30752 CB24 D360  30        movb @T,ra                      ; LDA T             ; And then the high bytes, R = R + T
     CB26 00D1     
30753                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 CB28 1701  14        jnc  !
0002 CB2A B347  18        ab   rone,ra
0003               !:
0004 CB2C B360  30        ab   @R,ra
     CB2E 0091     
                   < elite.a99
30754 CB30 D80D  30        movb ra,@R                      ; STA R
     CB32 0091     
30755               
30756 CB34 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Fetch the z-coordinate into A
     CB36 0033     
30757               
30758 CB38 0200  20        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = z^2
     CB3A 436A     
30759 CB3C 06A0  32        bl   @jsr                       ;
     CB3E FE28     
30760               
30761 CB40 D80D  30        movb ra,@T                      ; STA T             ; Set (T P) = (A P) = z^2
     CB42 00D1     
30762               
30763 CB44 D360  30        movb @P,ra                      ; LDA P             ; Set (R Q) = (R Q) + (T P) = x^2 + y^2 + z^2
     CB46 001B     
30764                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 CB48 1701  14        jnc  !
0002 CB4A B347  18        ab   rone,ra
0003               !:
0004 CB4C B360  30        ab   @Q,ra
     CB4E 0090     
                   < elite.a99
30765 CB50 D80D  30        movb ra,@Q                      ; STA Q             ; First, doing the low bytes, Q = Q + P
     CB52 0090     
30766               
30767 CB54 D360  30        movb @T,ra                      ; LDA T             ; And then the high bytes, R = R + T
     CB56 00D1     
30768                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 CB58 1701  14        jnc  !
0002 CB5A B347  18        ab   rone,ra
0003               !:
0004 CB5C B360  30        ab   @R,ra
     CB5E 0091     
                   < elite.a99
30769 CB60 D80D  30        movb ra,@R                      ; STA R
     CB62 0091     
30770               
30771 CB64 0200  20        li   rtmp,LL5                   ; JSR LL5           ; We now have the following:
     CB66 D376     
30772 CB68 06A0  32        bl   @jsr                       ;
     CB6A FE28     
30773                                                                          ;
30774                                                                          ; (R Q) = x^2 + y^2 + z^2
30775                                                                          ;
30776                                                                          ; so we can call LL5 to use Pythagoras to get:
30777                                                                          ;
30778                                                                          ; Q = SQRT(R Q)
30779                                                                          ; = SQRT(x^2 + y^2 + z^2)
30780                                                                          ;
30781                                                                          ; So Q now contains the length of the vector (x, y, z),
30782                                                                          ; and we can normalise the vector by dividing each of
30783                                                                          ; the coordinates by this value, which we do by calling
30784                                                                          ; routine TIS2. TIS2 returns the divided figure, using
30785                                                                          ; 96 to represent 1 and 96 with bit 7 set for -1
30786               
30787 CB6C D360  30        movb @XX15,ra                   ; LDA XX15          ; Call TIS2 to divide the x-coordinate in XX15 by Q,
     CB6E 0031     
30788 CB70 0200  20        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     CB72 D17A     
30789 CB74 06A0  32        bl   @jsr                       ;
     CB76 FE28     
30790 CB78 D80D  30        movb ra,@XX15                   ; STA XX15
     CB7A 0031     
30791               
30792 CB7C D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Call TIS2 to divide the y-coordinate in XX15+1 by Q,
     CB7E 0032     
30793 CB80 0200  20        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     CB82 D17A     
30794 CB84 06A0  32        bl   @jsr                       ;
     CB86 FE28     
30795 CB88 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     CB8A 0032     
30796               
30797 CB8C D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Call TIS2 to divide the z-coordinate in XX15+2 by Q,
     CB8E 0033     
30798 CB90 0200  20        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     CB92 D17A     
30799 CB94 06A0  32        bl   @jsr                       ;
     CB96 FE28     
30800 CB98 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     CB9A 0033     
30801               
30802               NO1:
30803 CB9C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CB9E FE34     
30804               
30805               * ******************************************************************************
30806               *
30807               * Name: RDKEY
30808               * Type: Subroutine
30809               * Category: Keyboard
30810               * Summary: Scan the keyboard for key presses
30811               *
30812               * ------------------------------------------------------------------------------
30813               *
30814               * Scan the keyboard, starting with internal key number 16 ("Q") and working
30815               * through the set of internal key numbers (see p.142 of the Advanced User Guide
30816               * for a list of internal key numbers).
30817               *
30818               * This routine is effectively the same as OSBYTE 122, though the OSBYTE call
30819               * preserves A, unlike this routine.
30820               *
30821               * ------------------------------------------------------------------------------
30822               *
30823               * Returns:
30824               *
30825               * X                   If a key is being pressed, X contains the internal key
30826               * number, otherwise it contains 0
30827               *
30828               * A                   Contains the same as X
30829               *
30830               * ******************************************************************************
30831               
30832               RDKEY:
30833 CBA0 020E  20        li   rx,>10*256                 ; LDX #16           ; Start the scan with internal key number 16 ("Q")
     CBA2 1000     
30834               
30835               Rd1:
30836 CBA4 0200  20        li   rtmp,DKS4                  ; JSR DKS4          ; Scan the keyboard to see if the key in X is currently
     CBA6 CCD4     
30837 CBA8 06A0  32        bl   @jsr                       ;
     CBAA FE28     
30838                                                                          ; being pressed, returning the result in A and X
30839               
30840 CBAC 1103  14        jlt  Rd2                        ; BMI Rd2           ; Jump to Rd2 if this key is being pressed (in which
30841                                                                          ; case DKS4 will have returned the key number with bit
30842                                                                          ; 7 set, which is negative)
30843               
30844 CBAE B387  18        ab   rone,rx                    ; INX               ; Increment the key number, which was unchanged by the
30845                                                                          ; above call to DKS4
30846               
30847 CBB0 15F9  14        jgt  Rd1                        ; BPL Rd1           ; Loop back to test the next key, ending the loop when
30848                                                                          ; X is negative (i.e. 128)
30849               
30850 CBB2 D34E  18        movb rx,ra                      ; TXA               ; If we get here, nothing is being pressed, so copy X
30851                                                                          ; into A so that X = A = 128 = %10000000
30852               
30853               Rd2:
30854                      .eoi (>80*256)                  ; EOR #%10000000    ; EOR A with #%10000000 to flip bit 7, so A now contains
     **** ****     > EOI
0001 CBB4 0200  20        li   rtmp,(>80*256)
     CBB6 8000     
0002 CBB8 2B40  18        xor  rtmp,ra
                   < elite.a99
30855                                                                          ; 0 if no key has been pressed, or the internal key
30856                                                                          ; number if a key has been pressed
30857               
30858 CBBA D38D  18        movb ra,rx                      ; TAX               ; Copy A into X
30859               
30860 CBBC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CBBE FE34     
30861               
30862               * ******************************************************************************
30863               *
30864               * Name: ECMOF
30865               * Type: Subroutine
30866               * Category: Sound
30867               * Summary: Switch off the E.C.M.
30868               *
30869               * ------------------------------------------------------------------------------
30870               *
30871               * Switch the E.C.M. off, turn off the dashboard bulb and make the sound of the
30872               * E.C.M. switching off).
30873               *
30874               * ******************************************************************************
30875               
30876               ECMOF:
30877 CBC0 020D  20        li   ra,>00*256                 ; LDA #0            ; Set ECMA and ECMP to 0 to indicate that no E.C.M. is
     CBC2 0000     
30878 CBC4 D80D  30        movb ra,@ECMA                   ; STA ECMA          ; currently running
     CBC6 0030     
30879 CBC8 D80D  30        movb ra,@ECMP                   ; STA ECMP
     CBCA 0D5B     
30880               
30881 CBCC 0200  20        li   rtmp,ECBLB                 ; JSR ECBLB         ; Update the E.C.M. indicator bulb on the dashboard
     CBCE B130     
30882 CBD0 06A0  32        bl   @jsr                       ;
     CBD2 FE28     
30883               
30884 CBD4 020D  20        li   ra,>48*256                 ; LDA #72           ; Call the NOISE routine with A = 72 to make the sound
     CBD6 4800     
30885 CBD8 1641  14        jne  NOISE                      ; BNE NOISE         ; of the E.C.M. being turned off and return from the
30886                                                                          ; subroutine using a tail call (this BNE is effectively
30887                                                                          ; a JMP as A will never be zero)
30888               
30889               * ******************************************************************************
30890               *
30891               * Name: EXNO3
30892               * Type: Subroutine
30893               * Category: Sound
30894               * Summary: Make an explosion sound
30895               *
30896               * ------------------------------------------------------------------------------
30897               *
30898               * Make the sound of death in the cold, hard vacuum of space. Apparently, in
30899               * Elite space, everyone can hear you scream.
30900               *
30901               * This routine also makes the sound of a destroyed cargo canister if we don't
30902               * get scooping right, the sound of us colliding with another ship, and the sound
30903               * of us being hit with depleted shields. It is not a good sound to hear.
30904               *
30905               * ******************************************************************************
30906               
30907               EXNO3:
30908 CBDA 020D  20        li   ra,>10*256                 ; LDA #16           ; Call the NOISE routine with A = 16 to make the first
     CBDC 1000     
30909 CBDE 0200  20        li   rtmp,NOISE                 ; JSR NOISE         ; death sound
     CBE0 CC5C     
30910 CBE2 06A0  32        bl   @jsr                       ;
     CBE4 FE28     
30911               
30912 CBE6 020D  20        li   ra,>18*256                 ; LDA #24           ; Call the NOISE routine with A = 24 to make the second
     CBE8 1800     
30913 CBEA 1638  14        jne  NOISE                      ; BNE NOISE         ; death sound and return from the subroutine using a
30914                                                                          ; tail call (this BNE is effectively a JMP as A will
30915                                                                          ; never be zero)
30916               
30917               * ******************************************************************************
30918               *
30919               * Name: SFRMIS
30920               * Type: Subroutine
30921               * Category: Tactics
30922               * Summary: Add an enemy missile to our local bubble of universe
30923               *
30924               * ------------------------------------------------------------------------------
30925               *
30926               * An enemy has fired a missile, so add the missile to our universe if there is
30927               * room, and if there is, make the appropriate warnings and noises.
30928               *
30929               * ******************************************************************************
30930               
30931               SFRMIS:
30932 CBEC 020E  20        li   rx,(MSL)*256               ; LDX #MSL          ; Set X to the ship type of a missile, and call SFS1-2
     CBEE 0900     
30933 CBF0 0200  20        li   rtmp,SFS1-2                ; JSR SFS1-2        ; to add the missile to our universe with an AI flag
     CBF2 3DB0     
30934 CBF4 06A0  32        bl   @jsr                       ;
     CBF6 FE28     
30935                                                                          ; of %11111110 (AI enabled, hostile, no E.C.M.)
30936               
30937 CBF8 17D1  14        jnc  NO1                        ; BCC NO1           ; The C flag will be set if the call to SFS1-2 was a
30938                                                                          ; success, so if it's clear, jump to NO1 to return from
30939                                                                          ; the subroutine (as NO1 contains an RTS)
30940               
30941 CBFA 020D  20        li   ra,>78*256                 ; LDA #120          ; Print recursive token 120 ("INCOMING MISSILE") as an
     CBFC 7800     
30942 CBFE 0200  20        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     CC00 CF0E     
30943 CC02 06A0  32        bl   @jsr                       ;
     CC04 FE28     
30944               
30945 CC06 020D  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     CC08 3000     
30946 CC0A 1628  14        jne  NOISE                      ; BNE NOISE         ; of the missile being launched and return from the
30947                                                                          ; subroutine using a tail call (this BNE is effectively
30948                                                                          ; a JMP as A will never be zero)
30949               
30950               * ******************************************************************************
30951               *
30952               * Name: EXNO2
30953               * Type: Subroutine
30954               * Category: Status
30955               * Summary: Process us making a kill
30956               * Deep dive: Combat rank
30957               *
30958               * ------------------------------------------------------------------------------
30959               *
30960               * We have killed a ship, so increase the kill tally, displaying an iconic
30961               * message of encouragement if the kill total is a multiple of 256, and then
30962               * make a nearby explosion sound.
30963               *
30964               * ******************************************************************************
30965               
30966               EXNO2:
30967 CC0C B347  18        ab   rone,ra                    ; INC TALLY         ; Increment the low byte of the kill count in TALLY
30968               
30969 CC0E 1608  14        jne  EXNO-2                     ; BNE EXNO-2        ; If there is no carry, jump to the LDX #7 below (at
30970                                                                          ; EXNO-2)
30971               
30972 CC10 B347  18        ab   rone,ra                    ; INC TALLY+1       ; Increment the high byte of the kill count in TALLY
30973               
30974 CC12 020D  20        li   ra,>65*256                 ; LDA #101          ; The kill total is a multiple of 256, so it's time
     CC14 6500     
30975 CC16 0200  20        li   rtmp,MESS                  ; JSR MESS          ; for a pat on the back, so print recursive token 101
     CC18 CF0E     
30976 CC1A 06A0  32        bl   @jsr                       ;
     CC1C FE28     
30977                                                                          ; ("RIGHT ON COMMANDER!") as an in-flight message
30978               
30979 CC1E 020E  20        li   rx,>07*256                 ; LDX #7            ; Set X = 7 and fall through into EXNO to make the
     CC20 0700     
30980                                                                          ; sound of a ship exploding
30981               
30982               * ******************************************************************************
30983               *
30984               * Name: EXNO
30985               * Type: Subroutine
30986               * Category: Sound
30987               * Summary: Make the sound of a laser strike or ship explosion
30988               *
30989               * ------------------------------------------------------------------------------
30990               *
30991               * Make the two-part explosion sound of us making a laser strike, or of another
30992               * ship exploding.
30993               *
30994               * The volume of the first explosion is affected by the distance of the ship
30995               * being hit, with more distant ships being quieter. The value in X also affects
30996               * the volume of the first explosion, with a higher X giving a quieter sound
30997               * (so X can be used to differentiate a laser strike from an explosion).
30998               *
30999               * ------------------------------------------------------------------------------
31000               *
31001               * Arguments:
31002               *
31003               * X                   The larger the value of X, the fainter the explosion.
31004               * Allowed values are:
31005               *
31006               * * 7  = explosion is louder (i.e. the ship has just
31007               * exploded)
31008               *
31009               * * 15 = explosion is quieter (i.e. this is just a laser
31010               * strike)
31011               *
31012               * ------------------------------------------------------------------------------
31013               *
31014               * Other entry points:
31015               *
31016               * EXNO-2              Set X = 7 and fall through into EXNO to make the sound
31017               * of a ship exploding
31018               *
31019               * ******************************************************************************
31020               
31021               EXNO:
31022 CC22 D80E  30        movb rx,@T                      ; STX T             ; Store the distance in T
     CC24 00D1     
31023               
31024 CC26 020D  20        li   ra,>18*256                 ; LDA #24           ; Set A = 24 to denote the sound of us making a hit or
     CC28 1800     
31025 CC2A 0200  20        li   rtmp,NOS1                  ; JSR NOS1          ; kill (part 1 of the explosion), and call NOS1 to set
     CC2C CC7A     
31026 CC2E 06A0  32        bl   @jsr                       ;
     CC30 FE28     
31027                                                                          ; up the sound block in XX16
31028               
31029 CC32 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Fetch z_hi, the distance of the ship being hit in
     CC34 005A     
31030 CC36 091D  18        srl  ra,1                       ; LSR A             ; terms of the z-axis (in and out of the screen), and
31031 CC38 091D  18        srl  ra,1                       ; LSR A             ; divide by 4. If z_hi has either bit 6 or 7 set then
31032                                                                          ; that ship is too far away to be shown on the scanner
31033                                                                          ; (as per the SCAN routine), so we know the maximum
31034                                                                          ; z_hi at this point is %00111111, and shifting z_hi
31035                                                                          ; to the right twice gives us a maximum value of
31036                                                                          ; %00001111
31037               
31038                      .and @T                         ; AND T             ; This reduces A to a maximum of X; X can be either
     **** ****     > AND
0001 CC3A D020  30        movb @T,rtmp
     CC3C 00D1     
0002 CC3E 0540  14        inv  rtmp
0003 CC40 5340  18        szcb rtmp,ra
                   < elite.a99
31039                                                                          ; 7 = %0111 or 15 = %1111, so AND'ing with 15 will
31040                                                                          ; not affect A, while AND'ing with 7 will clear bit
31041                                                                          ; 3, reducing the maximum value in A to 7
31042               
31043 CC42 026D  22        ori  ra,>f1*256                 ; ORA #%11110001    ; The SOUND statement's amplitude ranges from 0 (for no
     CC44 F100     
31044                                                                          ; sound) to -15 (full volume), so we can set bits 0 and
31045                                                                          ; 4-7 in A, and keep bits 1-3 from the above to get
31046                                                                          ; a value between -15 (%11110001) and -1 (%11111111),
31047                                                                          ; with lower values of z_hi and argument X leading
31048                                                                          ; to a more negative, or quieter number (so the closer
31049                                                                          ; the ship, i.e. the smaller the value of X, the louder
31050                                                                          ; the sound)
31051               
31052 CC46 D80D  30        movb ra,@XX16+2                 ; STA XX16+2        ; The amplitude byte of the sound block in XX16 is in
     CC48 000B     
31053                                                                          ; byte #3 (where it's the low byte of the amplitude), so
31054                                                                          ; this sets the amplitude to the value in A
31055               
31056 CC4A 0200  20        li   rtmp,NO3                   ; JSR NO3           ; Make the sound from our updated sound block in XX16
     CC4C CC64     
31057 CC4E 06A0  32        bl   @jsr                       ;
     CC50 FE28     
31058               
31059 CC52 020D  20        li   ra,>10*256                 ; LDA #16           ; Set A = 16 to denote we have made a hit or kill
     CC54 1000     
31060                                                                          ; (part 2 of the explosion), and fall through into NOISE
31061                                                                          ; to make the sound
31062               
31063 CC56 2C              byte >2c                                            ; Skip the next instruction by turning it into
31064                                                                          ; &2C &A9 &20, or BIT &20A9, which does nothing apart
31065                                                                          ; from affect the flags
31066               
31067               * ******************************************************************************
31068               *
31069               * Name: BEEP
31070               * Type: Subroutine
31071               * Category: Sound
31072               * Summary: Make a short, high beep
31073               *
31074               * ******************************************************************************
31075               
31076               BEEP:
31077 CC58 020D  20        li   ra,>20*256                 ; LDA #32           ; Set A = 32 to denote a short, high beep, and fall
     CC5A 2000     
31078                                                                          ; through into the NOISE routine to make the sound
31079               
31080               * ******************************************************************************
31081               *
31082               * Name: NOISE
31083               * Type: Subroutine
31084               * Category: Sound
31085               * Summary: Make the sound whose number is in A
31086               *
31087               * ------------------------------------------------------------------------------
31088               *
31089               * Arguments:
31090               *
31091               * A                   The number of the sound to be made. See the
31092               * documentation for variable SFX for a list of sound
31093               * numbers
31094               *
31095               * ******************************************************************************
31096               
31097               NOISE:
31098 CC5C 0200  20        li   rtmp,NOS1                  ; JSR NOS1          ; Set up the sound block in XX16 for the sound in A and
     CC5E CC7A     
31099 CC60 06A0  32        bl   @jsr                       ;
     CC62 FE28     
31100                                                                          ; fall through into NO3 to make the sound
31101               
31102               * ******************************************************************************
31103               *
31104               * Name: NO3
31105               * Type: Subroutine
31106               * Category: Sound
31107               * Summary: Make a sound from a prepared sound block
31108               *
31109               * ------------------------------------------------------------------------------
31110               *
31111               * Make a sound from a prepared sound block in XX16 (if sound is enabled). See
31112               * routine NOS1 for details of preparing the XX16 sound block.
31113               *
31114               * ******************************************************************************
31115               
31116               NO3:
31117 CC64 D3A0  30        movb @DNOIZ,rx                  ; LDX DNOIZ         ; Set X to the DNOIZ configuration setting
     CC66 0F49     
31118               
31119 CC68 1699  14        jne  NO1                        ; BNE NO1           ; If DNOIZ is non-zero, then sound is disabled, so
31120                                                                          ; return from the subroutine (as NO1 contains an RTS)
31121               
31122 CC6A 020E  20        li   rx,((XX16)%256)*256        ; LDX #LO(XX16)     ; Otherwise set (Y X) to point to the sound block in
     CC6C 0900     
31123 CC6E 020F  20        li   ry,((XX16)/256)*256        ; LDY #HI(XX16)     ; XX16
     CC70 0000     
31124               
31125 CC72 020D  20        li   ra,>07*256                 ; LDA #7            ; Call OSWORD 7 to makes the sound, as described in the
     CC74 0700     
31126 CC76 0460  28        b    @OSWORD                    ; JMP OSWORD        ; documentation for variable SFX, and return from the
     CC78 FE24     
31127                                                                          ; subroutine using a tail call
31128               
31129               * ******************************************************************************
31130               *
31131               * Name: NOS1
31132               * Type: Subroutine
31133               * Category: Sound
31134               * Summary: Prepare a sound block
31135               *
31136               * ------------------------------------------------------------------------------
31137               *
31138               * Copy four sound bytes from SFX into XX16, interspersing them with null bytes,
31139               * with Y indicating the sound number to copy (from the values in the sound
31140               * table at SFX). So, for example, if we call this routine with A = 40 (long,
31141               * low beep), the following bytes will be set in XX16 to XX16+7:
31142               *
31143               * &13 &00 &F4 &00 &0C &00 &08 &00
31144               *
31145               * This block will be passed to OSWORD 7 to make the sound, which expects the
31146               * four sound attributes as 16-bit big-endian values - in other words, with the
31147               * low byte first. So the above block would pass the values &0013, &00F4, &000C
31148               * and &0008 to the SOUND statement when used with OSWORD 7, or:
31149               *
31150               * SOUND &13, &F4, &0C, &08
31151               *
31152               * as the high bytes are always zero.
31153               *
31154               * ------------------------------------------------------------------------------
31155               *
31156               * Arguments:
31157               *
31158               * A                   The sound number to copy from SFX to XX16, which is
31159               * always a multiple of 8
31160               *
31161               * ******************************************************************************
31162               
31163               NOS1:
31164 CC7A 091D  18        srl  ra,1                       ; LSR A             ; Divide A by 2, and also clear the C flag, as bit 0 of
31165                                                                          ; A is always zero (as A is a multiple of 8)
31166               
31167                      .adi (>03*256)                  ; ADC #3            ; Set Y = A + 3, so Y now points to the last byte of
     **** ****     > ADI
0001 CC7C 1701  14        jnc  !
0002 CC7E B347  18        ab   rone,ra
0003               !:
0004 CC80 022D  22        ai   ra,(>03*256)
     CC82 0300     
                   < elite.a99
31168 CC84 D3CD  18        movb ra,ry                      ; TAY               ; four within the block of four-byte values
31169               
31170 CC86 020E  20        li   rx,>07*256                 ; LDX #7            ; We want to copy four bytes, spread out into an 8-byte
     CC88 0700     
31171                                                                          ; block, so set a counter in Y to cover 8 bytes
31172               
31173               NOL1:
31174 CC8A 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the X-th byte of XX16 to 0
     CC8C 0000     
31175 CC8E DB8D  38        movb ra,@XX16(rx)               ; STA XX16,X
     CC90 0009     
31176               
31177 CC92 7387  18        sb   rone,rx                    ; DEX               ; Decrement the destination byte pointer
31178               
31179 CC94 D36F  34        movb @SFX(ry),ra                ; LDA SFX,Y         ; Set the X-th byte of XX16 to the value from SFX+Y
     CC96 BF86     
31180 CC98 DB8D  38        movb ra,@XX16(rx)               ; STA XX16,X
     CC9A 0009     
31181               
31182 CC9C 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the source byte pointer again
31183               
31184 CC9E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the destination byte pointer again
31185               
31186 CCA0 15F4  14        jgt  NOL1                       ; BPL NOL1          ; Loop back for the next source byte
31187               
31188 CCA2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CCA4 FE34     
31189               
31190               * ******************************************************************************
31191               *
31192               * Name: KYTB
31193               * Type: Variable
31194               * Category: Keyboard
31195               * Summary: Lookup table for in-flight keyboard controls
31196               * Deep dive: The key logger
31197               *
31198               * ------------------------------------------------------------------------------
31199               *
31200               * Keyboard table for in-flight controls. This table contains the internal key
31201               * codes for the flight keys (see p.142 of the Advanced User Guide for a list of
31202               * internal key numbers).
31203               *
31204               * The pitch, roll, speed and laser keys (i.e. the seven primary flight
31205               * control keys) have bit 7 set, so they have 128 added to their internal
31206               * values. This doesn't appear to be used anywhere.
31207               *
31208               * ******************************************************************************
31209               
31210               KYTB:                                                      ; Point KYTB to the byte before the start of the table
31211                      equ $ - 1
31212               
31213                                                                          ; These are the primary flight controls (pitch, roll,
31214                                                                          ; speed and lasers):
31215               
31216 CCA6 E8              byte >68 + 128                                      ; ?         KYTB+1      Slow down
31217 CCA7   E2            byte >62 + 128                                      ; Space     KYTB+2      Speed up
31218 CCA8 E6              byte >66 + 128                                      ; <         KYTB+3      Roll left
31219 CCA9   E7            byte >67 + 128                                      ; >         KYTB+4      Roll right
31220 CCAA C2              byte >42 + 128                                      ; X         KYTB+5      Pitch up
31221 CCAB   D1            byte >51 + 128                                      ; S         KYTB+6      Pitch down
31222 CCAC C1              byte >41 + 128                                      ; A         KYTB+7      Fire lasers
31223               
31224                                                                          ; These are the secondary flight controls:
31225               
31226 CCAD   60            byte >60                                            ; TAB       KYTB+8      Energy bomb
31227 CCAE 70              byte >70                                            ; ESCAPE    KYTB+9      Launch escape pod
31228 CCAF   23            byte >23                                            ; T         KYTB+10     Arm missile
31229 CCB0 35              byte >35                                            ; U         KYTB+11     Unarm missile
31230 CCB1   65            byte >65                                            ; M         KYTB+12     Fire missile
31231 CCB2 22              byte >22                                            ; E         KYTB+13     E.C.M.
31232 CCB3   45            byte >45                                            ; J         KYTB+14     In-system jump
31233 CCB4 52              byte >52                                            ; C         KYTB+15     Docking computer
31234               
31235               * ******************************************************************************
31236               *
31237               * Name: DKS1
31238               * Type: Subroutine
31239               * Category: Keyboard
31240               * Summary: Scan the keyboard for a flight key
31241               * Deep dive: The key logger
31242               *
31243               * ------------------------------------------------------------------------------
31244               *
31245               * Scan the keyboard for the flight key given in register Y, where Y is the
31246               * offset into the KYTB table above (so we can scan for Space by setting Y to
31247               * 2, for example). If the key is pressed, set the corresponding byte in the
31248               * key logger at KL to &FF.
31249               *
31250               * ------------------------------------------------------------------------------
31251               *
31252               * Arguments:
31253               *
31254               * Y                   The offset into the KYTB table above of the key that we
31255               * want to scan on the keyboard
31256               *
31257               * ******************************************************************************
31258               
31259               DKS1:
31260 CCB6 D3AF  34        movb @KYTB(ry),rx               ; LDX KYTB,Y        ; Get the internal key number from the Y-th byte of the
     CCB8 CCA5     
31261                                                                          ; KYTB table above
31262               
31263 CCBA 0200  20        li   rtmp,DKS4                  ; JSR DKS4          ; Call DKS4, which will set A and X to a negative value
     CCBC CCD4     
31264 CCBE 06A0  32        bl   @jsr                       ;
     CCC0 FE28     
31265                                                                          ; if the key is being pressed
31266               
31267 CCC2 151E  14        jgt  DKS2-1                     ; BPL DKS2-1        ; The key is not being pressed, so return from the
31268                                                                          ; subroutine (as DKS2-1 contains an RTS)
31269               
31270 CCC4 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Store &FF in the Y-th byte of the key logger at KL
     CCC6 FF00     
31271 CCC8 DBCE  38        movb rx,@KL(ry)                 ; STX KL,Y
     CCCA 0041     
31272               
31273 CCCC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CCCE FE34     
31274               
31275               * ******************************************************************************
31276               *
31277               * Name: CTRL
31278               * Type: Subroutine
31279               * Category: Keyboard
31280               * Summary: Scan the keyboard to see if CTRL is currently pressed
31281               *
31282               * ------------------------------------------------------------------------------
31283               *
31284               * Returns:
31285               *
31286               * X                   X = %10000001 (i.e. 129 or -127) if CTRL is being
31287               * pressed
31288               *
31289               * X = 1 if CTRL is not being pressed
31290               *
31291               * A                   Contains the same as X
31292               *
31293               * ******************************************************************************
31294               
31295               CTRL:
31296 CCD0 020E  20        li   rx,>01*256                 ; LDX #1            ; Set X to the internal key number for CTRL and fall
     CCD2 0100     
31297                                                                          ; through to DKS4 to scan the keyboard
31298               
31299               * ******************************************************************************
31300               *
31301               * Name: DKS4
31302               * Type: Subroutine
31303               * Category: Keyboard
31304               * Summary: Scan the keyboard to see if a specific key is being pressed
31305               * Deep dive: The key logger
31306               *
31307               * ------------------------------------------------------------------------------
31308               *
31309               * Arguments:
31310               *
31311               * X                   The internal number of the key to check (see p.142 of
31312               * the Advanced User Guide for a list of internal key
31313               * numbers)
31314               *
31315               * ------------------------------------------------------------------------------
31316               *
31317               * Returns:
31318               *
31319               * A                   If the key in A is being pressed, A contains the
31320               * original argument A, but with bit 7 set (i.e. A + 128).
31321               * If the key in A is not being pressed, the value in A is
31322               * unchanged
31323               *
31324               * X                   Contains the same as A
31325               *
31326               * ******************************************************************************
31327               
31328               DKS4:
31329 CCD4 020D  20        li   ra,>03*256                 ; LDA #%00000011    ; Set A to %00000011, so it's ready to send to SHEILA
     CCD6 0300     
31330                                                                          ; once interrupts have been disabled
31331               
31332 CCD8 0300  22        limi 0                          ; SEI               ; Disable interrupts so we can scan the keyboard
     CCDA 0000     
31333                                                                          ; without being hijacked
31334               
31335 CCDC D80D  38        movb ra,@VIA+>40                ; STA VIA+&40       ; Set 6522 System VIA output register ORB (SHEILA &40)
     CCDE FE40     
31336                                                                          ; to %00000011 to stop auto scan of keyboard
31337               
31338 CCE0 020D  20        li   ra,>7f*256                 ; LDA #%01111111    ; Set 6522 System VIA data direction register DDRA
     CCE2 7F00     
31339 CCE4 D80D  38        movb ra,@VIA+>43                ; STA VIA+&43       ; (SHEILA &43) to %01111111. This sets the A registers
     CCE6 FE43     
31340                                                                          ; (IRA and ORA) so that:
31341                                                                          ;
31342                                                                          ; * Bits 0-6 of ORA will be sent to the keyboard
31343                                                                          ;
31344                                                                          ; * Bit 7 of IRA will be read from the keyboard
31345               
31346 CCE8 D80E  38        movb rx,@VIA+>4F                ; STX VIA+&4F       ; Set 6522 System VIA output register ORA (SHEILA &4F)
     CCEA FE4F     
31347                                                                          ; to X, the key we want to scan for; bits 0-6 will be
31348                                                                          ; sent to the keyboard, of which bits 0-3 determine the
31349                                                                          ; keyboard column, and bits 4-6 the keyboard row
31350               
31351 CCEC D3A0  34        movb @VIA+>4F,rx                ; LDX VIA+&4F       ; Read 6522 System VIA output register IRA (SHEILA &4F)
     CCEE FE4F     
31352                                                                          ; into X; bit 7 is the only bit that will have changed.
31353                                                                          ; If the key is pressed, then bit 7 will be set,
31354                                                                          ; otherwise it will be clear
31355               
31356 CCF0 020D  20        li   ra,>0b*256                 ; LDA #%00001011    ; Set 6522 System VIA output register ORB (SHEILA &40)
     CCF2 0B00     
31357 CCF4 D80D  38        movb ra,@VIA+>40                ; STA VIA+&40       ; to %00001011 to restart auto scan of keyboard
     CCF6 FE40     
31358               
31359 CCF8 0300  22        limi 2                          ; CLI               ; Allow interrupts again
     CCFA 0002     
31360               
31361 CCFC D34E  18        movb rx,ra                      ; TXA               ; Transfer X into A
31362               
31363 CCFE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CD00 FE34     
31364               
31365               * ******************************************************************************
31366               *
31367               * Name: DKS2
31368               * Type: Subroutine
31369               * Category: Keyboard
31370               * Summary: Read the joystick position
31371               *
31372               * ------------------------------------------------------------------------------
31373               *
31374               * Return the value of ADC channel in X (used to read the joystick). The value
31375               * will be inverted if the game has been configured to reverse both joystick
31376               * channels (which can be done by pausing the game and pressing J).
31377               *
31378               * ------------------------------------------------------------------------------
31379               *
31380               * Arguments:
31381               *
31382               * X                   The ADC channel to read:
31383               *
31384               * * 1 = joystick X
31385               *
31386               * * 2 = joystick Y
31387               *
31388               * ------------------------------------------------------------------------------
31389               *
31390               * Returns:
31391               *
31392               * (A X)               The 16-bit value read from channel X, with the value
31393               * inverted if the game has been configured to reverse the
31394               * joystick
31395               *
31396               * ------------------------------------------------------------------------------
31397               *
31398               * Other entry points:
31399               *
31400               * DKS2-1              Contains an RTS
31401               *
31402               * ******************************************************************************
31403               
31404               DKS2:
31405 CD02 020D  20        li   ra,>80*256                 ; LDA #128          ; Call OSBYTE with A = 128 to fetch the 16-bit value
     CD04 8000     
31406 CD06 0200  20        li   rtmp,OSBYTE                ; JSR OSBYTE        ; from ADC channel X, returning (Y X), i.e. the high
     CD08 FE22     
31407 CD0A 06A0  32        bl   @jsr                       ;
     CD0C FE28     
31408                                                                          ; byte in Y and the low byte in X
31409                                                                          ;
31410                                                                          ; * Channel 1 is the x-axis: 0 = right, 65520 = left
31411                                                                          ;
31412                                                                          ; * Channel 2 is the y-axis: 0 = down,  65520 = up
31413               
31414 CD0E D34F  18        movb ry,ra                      ; TYA               ; Copy Y to A, so the result is now in (A X)
31415               
31416                      .eor @JSTE                      ; EOR JSTE          ; The high byte A is now EOR'd with the value in
     **** ****     > EOR
0001 CD10 D020  30        movb @JSTE,rtmp
     CD12 0F4F     
0002 CD14 2B40  18        xor  rtmp,ra
                   < elite.a99
31417                                                                          ; location JSTE, which contains &FF if both joystick
31418                                                                          ; channels are reversed and 0 otherwise (so A now
31419                                                                          ; contains the high byte but inverted, if that's what
31420                                                                          ; the current settings say)
31421               
31422 CD16 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CD18 FE34     
31423               
31424               * ******************************************************************************
31425               *
31426               * Name: DKS3
31427               * Type: Subroutine
31428               * Category: Keyboard
31429               * Summary: Toggle a configuration setting and emit a beep
31430               *
31431               * ------------------------------------------------------------------------------
31432               *
31433               * This is called when the game is paused and a key is pressed that changes the
31434               * game's configuration.
31435               *
31436               * Specifically, this routine toggles the configuration settings for the
31437               * following keys:
31438               *
31439               * * CAPS LOCK toggles keyboard flight damping (&40)
31440               * * A toggles keyboard auto-recentre (&41)
31441               * * X toggles author names on start-up screen (&42)
31442               * * F toggles flashing console bars (&43)
31443               * * Y toggles reverse joystick Y channel (&44)
31444               * * J toggles reverse both joystick channels (&45)
31445               * * K toggles keyboard and joystick (&46)
31446               *
31447               * The numbers in brackets are the internal key numbers (see p.142 of the
31448               * Advanced User Guide for a list of internal key numbers). We pass the key that
31449               * has been pressed in X, and the configuration option to check it against in Y,
31450               * so this routine is typically called in a loop that loops through the various
31451               * configuration options.
31452               *
31453               * ------------------------------------------------------------------------------
31454               *
31455               * Arguments:
31456               *
31457               * X                   The internal number of the key that's been pressed
31458               *
31459               * Y                   The internal number of the configuration key to check
31460               * against, from the list above (i.e. Y must be from &40 to
31461               * &46)
31462               *
31463               * ******************************************************************************
31464               
31465               DKS3:
31466 CD1A D80F  30        movb ry,@T                      ; STY T             ; Store the configuration key argument in T
     CD1C 00D1     
31467               
31468 CD1E 93A0  30        cb   @T,rx                      ; CPX T             ; If X <> Y, jump to Dk3 to return from the subroutine
     CD20 00D1     
31469 CD22 1611  14        jne  Dk3                        ; BNE Dk3
31470               
31471                                                                          ; We have a match between X and Y, so now to toggle
31472                                                                          ; the relevant configuration byte. CAPS LOCK has a key
31473                                                                          ; value of &40 and has its configuration byte at
31474                                                                          ; location DAMP, A has a value of &41 and has its byte
31475                                                                          ; at location DJD, which is DAMP+1, and so on. So we
31476                                                                          ; can toggle the configuration byte by changing the
31477                                                                          ; byte at DAMP + (X - &40), or to put it in indexing
31478                                                                          ; terms, DAMP-&40,X. It's no coincidence that the
31479                                                                          ; game's configuration bytes are set up in this order
31480                                                                          ; and with these keys (and this is also why the sound
31481                                                                          ; on/off keys are dealt with elsewhere, as the internal
31482                                                                          ; key for S and Q are &51 and &10, which don't fit
31483                                                                          ; nicely into this approach)
31484               
31485 CD24 D36E  34        movb @DAMP->40(rx),ra           ; LDA DAMP-&40,X    ; Fetch the byte from DAMP + (X - &40), invert it and
     CD26 0F0A     
31486                      .eoi (>ff*256)                  ; EOR #&FF          ; put it back (0 means no and &FF means yes in the
     **** ****     > EOI
0001 CD28 0200  20        li   rtmp,(>FF*256)
     CD2A FF00     
0002 CD2C 2B40  18        xor  rtmp,ra
                   < elite.a99
31487 CD2E DB8D  38        movb ra,@DAMP->40(rx)           ; STA DAMP-&40,X    ; configuration bytes, so this toggles the setting)
     CD30 0F0A     
31488               
31489 CD32 0200  20        li   rtmp,BELL                  ; JSR BELL          ; Make a beep sound so we know something has happened
     CD34 31BE     
31490 CD36 06A0  32        bl   @jsr                       ;
     CD38 FE28     
31491               
31492 CD3A 0200  20        li   rtmp,DELAY                 ; JSR DELAY         ; Wait for Y vertical syncs (Y is between 64 and 70, so
     CD3C 4CB4     
31493 CD3E 06A0  32        bl   @jsr                       ;
     CD40 FE28     
31494                                                                          ; this is always a bit longer than a second)
31495               
31496 CD42 D3E0  30        movb @T,ry                      ; LDY T             ; Restore the configuration key argument into Y
     CD44 00D1     
31497               
31498               Dk3:
31499 CD46 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CD48 FE34     
31500               
31501               * ******************************************************************************
31502               *
31503               * Name: DKJ1
31504               * Type: Subroutine
31505               * Category: Keyboard
31506               * Summary: Read joystick and flight controls
31507               *
31508               * ------------------------------------------------------------------------------
31509               *
31510               * Specifically, scan the keyboard for the speed up and slow down keys, and read
31511               * the joystick's fire button and X and Y axes, storing the results in the key
31512               * logger and the joystick position variables.
31513               *
31514               * This routine is only called if joysticks are enabled (JSTK = non-zero).
31515               *
31516               * ******************************************************************************
31517               
31518               DKJ1:
31519 CD4A 020F  20        li   ry,>01*256                 ; LDY #1            ; Update the key logger for key 1 in the KYTB table, so
     CD4C 0100     
31520 CD4E 0200  20        li   rtmp,DKS1                  ; JSR DKS1          ; KY1 will be &FF if "?" (slow down) is being pressed
     CD50 CCB6     
31521 CD52 06A0  32        bl   @jsr                       ;
     CD54 FE28     
31522               
31523 CD56 B3C7  18        ab   rone,ry                    ; INY               ; Update the key logger for key 2 in the KYTB table, so
31524 CD58 0200  20        li   rtmp,DKS1                  ; JSR DKS1          ; KY2 will be &FF if Space (speed up) is being pressed
     CD5A CCB6     
31525 CD5C 06A0  32        bl   @jsr                       ;
     CD5E FE28     
31526               
31527 CD60 D360  34        movb @VIA+>40,ra                ; LDA VIA+&40       ; Read 6522 System VIA input register IRB (SHEILA &40)
     CD62 FE40     
31528               
31529 CD64 D38D  18        movb ra,rx                      ; TAX               ; This instruction doesn't seem to have any effect, as
31530                                                                          ; X is overwritten in a few instructions. When the
31531                                                                          ; joystick is checked in a similar way in the TITLE
31532                                                                          ; subroutine for the "Press Fire Or Space,Commander."
31533                                                                          ; stage of the start-up screen, there's another
31534                                                                          ; unnecessary TAX instruction present, but there it's
31535                                                                          ; commented out
31536               
31537 CD66 024D  22        andi ra,>10*256                 ; AND #%00010000    ; Bit 4 of IRB (PB4) is clear if joystick 1's fire
     CD68 1000     
31538                                                                          ; button is pressed, otherwise it is set, so AND'ing
31539                                                                          ; the value of IRB with %10000 extracts this bit
31540               
31541                      .eoi (>10*256)                  ; EOR #%00010000    ; Flip bit 4 so that it's set if the fire button has
     **** ****     > EOI
0001 CD6A 0200  20        li   rtmp,(>10*256)
     CD6C 1000     
0002 CD6E 2B40  18        xor  rtmp,ra
                   < elite.a99
31542 CD70 D80D  30        movb ra,@KY7                    ; STA KY7           ; been pressed, and store the result in the keyboard
     CD72 0048     
31543                                                                          ; logger at location KY7, which is also where the A key
31544                                                                          ; (fire lasers) key is logged
31545               
31546 CD74 020E  20        li   rx,>01*256                 ; LDX #1            ; Call DKS2 to fetch the value of ADC channel 1 (the
     CD76 0100     
31547 CD78 0200  20        li   rtmp,DKS2                  ; JSR DKS2          ; joystick X value) into (A X), and OR A with 1. This
     CD7A CD02     
31548 CD7C 06A0  32        bl   @jsr                       ;
     CD7E FE28     
31549 CD80 026D  22        ori  ra,>01*256                 ; ORA #1            ; ensures that the high byte is at least 1, and then we
     CD82 0100     
31550 CD84 D80D  30        movb ra,@JSTX                   ; STA JSTX          ; store the result in JSTX
     CD86 009C     
31551               
31552 CD88 020E  20        li   rx,>02*256                 ; LDX #2            ; Call DKS2 to fetch the value of ADC channel 2 (the
     CD8A 0200     
31553 CD8C 0200  20        li   rtmp,DKS2                  ; JSR DKS2          ; joystick Y value) into (A X), and EOR A with JSTGY.
     CD8E CD02     
31554 CD90 06A0  32        bl   @jsr                       ;
     CD92 FE28     
31555                      .eor @JSTGY                     ; EOR JSTGY         ; JSTGY will be &FF if the game is configured to
     **** ****     > EOR
0001 CD94 D020  30        movb @JSTGY,rtmp
     CD96 0F4E     
0002 CD98 2B40  18        xor  rtmp,ra
                   < elite.a99
31556 CD9A D80D  30        movb ra,@JSTY                   ; STA JSTY          ; reverse the joystick Y channel, so this EOR does
     CD9C 009D     
31557                                                                          ; exactly that, and then we store the result in JSTY
31558               
31559 CD9E 0460  28        b    @DK4                       ; JMP DK4           ; We are done scanning the joystick flight controls,
     CDA0 CE26     
31560                                                                          ; so jump to DK4 to scan for other keys, using a tail
31561                                                                          ; call so we can return from the subroutine there
31562               
31563               * ******************************************************************************
31564               *
31565               * Name: U%
31566               * Type: Subroutine
31567               * Category: Keyboard
31568               * Summary: Clear the key logger
31569               *
31570               * ------------------------------------------------------------------------------
31571               *
31572               * Returns:
31573               *
31574               * A                   A is set to 0
31575               *
31576               * Y                   Y is set to 0
31577               *
31578               * ******************************************************************************
31579               
31580               U.:
31581 CDA2 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0, as this means "key not pressed" in the
     CDA4 0000     
31582                                                                          ; key logger at KL
31583               
31584 CDA6 020F  20        li   ry,>0f*256                 ; LDY #15           ; We want to clear the 15 key logger locations from
     CDA8 0F00     
31585                                                                          ; KY1 to KY19, so set a counter in Y
31586               
31587               DKL3:
31588 CDAA DBCD  38        movb ra,@KL(ry)                 ; STA KL,Y          ; Store 0 in the Y-th byte of the key logger
     CDAC 0041     
31589               
31590 CDAE 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter
31591               
31592 CDB0 16FC  14        jne  DKL3                       ; BNE DKL3          ; And loop back for the next key, until we have just
31593                                                                          ; KL+1. We don't want to clear the first key logger
31594                                                                          ; location at KL, as the keyboard table at KYTB starts
31595                                                                          ; with offset 1, not 0, so KL is not technically part of
31596                                                                          ; the key logger (it's actually used for logging keys
31597                                                                          ; that don't appear in the keyboard table, and which
31598                                                                          ; therefore don't use the key logger)
31599               
31600 CDB2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CDB4 FE34     
31601               
31602               * ******************************************************************************
31603               *
31604               * Name: DOKEY
31605               * Type: Subroutine
31606               * Category: Keyboard
31607               * Summary: Scan for the seven primary flight controls
31608               * Deep dive: The key logger
31609               * The docking computer
31610               *
31611               * ------------------------------------------------------------------------------
31612               *
31613               * Scan for the seven primary flight controls (or the equivalent on joystick),
31614               * pause and configuration keys, and secondary flight controls, and update the
31615               * key logger accordingly. Specifically:
31616               *
31617               * * If we are on keyboard configuration, clear the key logger and update it
31618               * for the seven primary flight controls, and update the pitch and roll
31619               * rates accordingly.
31620               *
31621               * * If we are on joystick configuration, clear the key logger and jump to
31622               * DKJ1, which reads the joystick equivalents of the primary flight
31623               * controls.
31624               *
31625               * Both options end up at DK4 to scan for other keys, beyond the seven primary
31626               * flight controls.
31627               *
31628               * ******************************************************************************
31629               
31630               DOKEY:
31631 CDB6 0200  20        li   rtmp,U.                    ; JSR U%            ; Call U% to clear the key logger
     CDB8 CDA2     
31632 CDBA 06A0  32        bl   @jsr                       ;
     CDBC FE28     
31633               
31634 CDBE D360  30        movb @JSTK,ra                   ; LDA JSTK          ; If JSTK is non-zero, then we are configured to use
     CDC0 0F50     
31635 CDC2 16C3  14        jne  DKJ1                       ; BNE DKJ1          ; the joystick rather than keyboard, so jump to DKJ1
31636                                                                          ; to read the joystick flight controls, before jumping
31637                                                                          ; to DK4 to scan for pause, configuration and secondary
31638                                                                          ; flight keys
31639               
31640 CDC4 020F  20        li   ry,>07*256                 ; LDY #7            ; We're going to work our way through the primary flight
     CDC6 0700     
31641                                                                          ; control keys (pitch, roll, speed and laser), so set a
31642                                                                          ; counter in Y so we can loop through all 7
31643               
31644               DKL2:
31645 CDC8 0200  20        li   rtmp,DKS1                  ; JSR DKS1          ; Call DKS1 to see if the KYTB key at offset Y is being
     CDCA CCB6     
31646 CDCC 06A0  32        bl   @jsr                       ;
     CDCE FE28     
31647                                                                          ; pressed, and set the key logger accordingly
31648               
31649 CDD0 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
31650               
31651 CDD2 16FA  14        jne  DKL2                       ; BNE DKL2          ; Loop back for the next key, working our way from A at
31652                                                                          ; KYTB+7 down to ? at KYTB+1
31653               
31654 CDD4 D3A0  30        movb @JSTX,rx                   ; LDX JSTX          ; Set X = JSTX, the current roll rate (as shown in the
     CDD6 009C     
31655                                                                          ; RL indicator on the dashboard)
31656               
31657 CDD8 020D  20        li   ra,>07*256                 ; LDA #7            ; Set A to 7, which is the amount we want to alter the
     CDDA 0700     
31658                                                                          ; roll rate by if the roll keys are being pressed
31659               
31660 CDDC D3E0  30        movb @KL+3,ry                   ; LDY KL+3          ; If the "<" key is being pressed, then call the BUMP2
     CDDE 0044     
31661 CDE0 1304  14        jeq  B103                       ; BEQ B103          ; routine to increase the roll rate in X by A
31662 CDE2 0200  20        li   rtmp,BUMP2                 ; JSR BUMP2
     CDE4 47E2     
31663 CDE6 06A0  32        bl   @jsr                       ;
     CDE8 FE28     
31664               
31665               B103:
31666 CDEA D3E0  30        movb @KL+4,ry                   ; LDY KL+4          ; If the ">" key is being pressed, then call the REDU2
     CDEC 0045     
31667 CDEE 1304  14        jeq  B104                       ; BEQ B104          ; routine to decrease the roll rate in X by A, taking
31668 CDF0 0200  20        li   rtmp,REDU2                 ; JSR REDU2         ; the keyboard auto re-centre setting into account
     CDF2 4804     
31669 CDF4 06A0  32        bl   @jsr                       ;
     CDF6 FE28     
31670               
31671               B104:
31672 CDF8 D80E  30        movb rx,@JSTX                   ; STX JSTX          ; Store the updated roll rate in JSTX
     CDFA 009C     
31673               
31674                      .asla                           ; ASL A             ; Double the value of A, to 14
     **** ****     > ASLA
0001 CDFC 024D  22        andi ra,>ff00
     CDFE FF00     
0002 CE00 0A1D  18        sla  ra,1
                   < elite.a99
31675               
31676 CE02 D3A0  30        movb @JSTY,rx                   ; LDX JSTY          ; Set X = JSTY, the current pitch rate (as shown in the
     CE04 009D     
31677                                                                          ; DC indicator on the dashboard)
31678               
31679 CE06 D3E0  30        movb @KL+5,ry                   ; LDY KL+5          ; If the "X" key is being pressed, then call the REDU2
     CE08 0046     
31680 CE0A 1304  14        jeq  B105                       ; BEQ B105          ; routine to decrease the pitch rate in X by A, taking
31681 CE0C 0200  20        li   rtmp,REDU2                 ; JSR REDU2         ; the keyboard auto re-centre setting into account
     CE0E 4804     
31682 CE10 06A0  32        bl   @jsr                       ;
     CE12 FE28     
31683               
31684               B105:
31685 CE14 D3E0  30        movb @KL+6,ry                   ; LDY KL+6          ; If the "S" key is being pressed, then call the BUMP2
     CE16 0047     
31686 CE18 1304  14        jeq  B106                       ; BEQ B106          ; routine to increase the pitch rate in X by A
31687 CE1A 0200  20        li   rtmp,BUMP2                 ; JSR BUMP2
     CE1C 47E2     
31688 CE1E 06A0  32        bl   @jsr                       ;
     CE20 FE28     
31689               
31690               B106:
31691 CE22 D80E  30        movb rx,@JSTY                   ; STX JSTY          ; Store the updated roll rate in JSTY
     CE24 009D     
31692               
31693                                                                          ; Fall through into DK4 to scan for other keys
31694               
31695               * ******************************************************************************
31696               *
31697               * Name: DK4
31698               * Type: Subroutine
31699               * Category: Keyboard
31700               * Summary: Scan for pause, configuration and secondary flight keys
31701               * Deep dive: The key logger
31702               *
31703               * ------------------------------------------------------------------------------
31704               *
31705               * Scan for pause and configuration keys, and if this is a space view, also scan
31706               * for secondary flight controls.
31707               *
31708               * Specifically:
31709               *
31710               * * Scan for the pause button (COPY) and if it's pressed, pause the game and
31711               * process any configuration key presses until the game is unpaused (DELETE)
31712               *
31713               * * If this is a space view, scan for secondary flight keys and update the
31714               * relevant bytes in the key logger
31715               *
31716               * ******************************************************************************
31717               
31718               DK4:
31719 CE26 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     CE28 CBA0     
31720 CE2A 06A0  32        bl   @jsr                       ;
     CE2C FE28     
31721                                                                          ; internal key number in X (or 0 for no key press)
31722               
31723 CE2E D80E  30        movb rx,@KL                     ; STX KL            ; Store X in KL, byte #0 of the key logger
     CE30 0041     
31724               
31725 CE32 028E  22        ci   rx,>69*256                 ; CPX #&69          ; If COPY is not being pressed, jump to DK2 below,
     CE34 6900     
31726 CE36 1626  14        jne  DK2                        ; BNE DK2           ; otherwise let's process the configuration keys
31727               
31728               FREEZE:
31729                                                                          ; COPY is being pressed, so we enter a loop that
31730                                                                          ; listens for configuration keys, and we keep looping
31731                                                                          ; until we detect a DELETE key press. This effectively
31732                                                                          ; pauses the game when COPY is pressed, and unpauses
31733                                                                          ; it when DELETE is pressed
31734 CE38 0200  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     CE3A 4EA2     
31735 CE3C 06A0  32        bl   @jsr                       ;
     CE3E FE28     
31736                                                                          ; screen gets drawn
31737               
31738 CE40 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     CE42 CBA0     
31739 CE44 06A0  32        bl   @jsr                       ;
     CE46 FE28     
31740                                                                          ; internal key number in X (or 0 for no key press)
31741               
31742 CE48 028E  22        ci   rx,>51*256                 ; CPX #&51          ; If "S" is not being pressed, skip to DK6
     CE4A 5100     
31743 CE4C 1604  14        jne  DK6                        ; BNE DK6
31744               
31745 CE4E 020D  20        li   ra,>00*256                 ; LDA #0            ; "S" is being pressed, so set DNOIZ to 0 to turn the
     CE50 0000     
31746 CE52 D80D  30        movb ra,@DNOIZ                  ; STA DNOIZ         ; sound on
     CE54 0F49     
31747               
31748               DK6:
31749 CE56 020F  20        li   ry,>40*256                 ; LDY #&40          ; We now want to loop through the keys that toggle
     CE58 4000     
31750                                                                          ; various settings. These have internal key numbers
31751                                                                          ; between &40 (CAPS LOCK) and &46 ("K"), so we set up
31752                                                                          ; the first key number in Y to act as a loop counter.
31753                                                                          ; See subroutine DKS3 for more details on this
31754               
31755               DKL4:
31756 CE5A 0200  20        li   rtmp,DKS3                  ; JSR DKS3          ; Call DKS3 to scan for the key given in Y, and toggle
     CE5C CD1A     
31757 CE5E 06A0  32        bl   @jsr                       ;
     CE60 FE28     
31758                                                                          ; the relevant setting if it is pressed
31759               
31760 CE62 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next toggle key
31761               
31762 CE64 028F  22        ci   ry,>47*256                 ; CPY #&47          ; The last toggle key is &46 (K), so check whether we
     CE66 4700     
31763                                                                          ; have just done that one
31764               
31765 CE68 16F8  14        jne  DKL4                       ; BNE DKL4          ; If not, loop back to check for the next toggle key
31766               
31767               DK55:
31768 CE6A 028E  22        ci   rx,>10*256                 ; CPX #&10          ; If "Q" is not being pressed, skip to DK7
     CE6C 1000     
31769 CE6E 1602  14        jne  DK7                        ; BNE DK7
31770               
31771 CE70 D80E  30        movb rx,@DNOIZ                  ; STX DNOIZ         ; "Q" is being pressed, so set DNOIZ to X, which is
     CE72 0F49     
31772                                                                          ; non-zero (&10), so this will turn the sound off
31773               
31774               DK7:
31775 CE74 028E  22        ci   rx,>70*256                 ; CPX #&70          ; If ESCAPE is not being pressed, skip over the next
     CE76 7000     
31776 CE78 1602  14        jne  B107                       ; BNE B107          ; instruction
31777               
31778 CE7A 0460  28        b    @DEATH2                    ; JMP DEATH2        ; ESCAPE is being pressed, so jump to DEATH2 to end
     CE7C C644     
31779                                                                          ; the game
31780               
31781               B107:
31782 CE7E 028E  22        ci   rx,>59*256                 ; CPX #&59          ; If DELETE is not being pressed, we are still paused,
     CE80 5900     
31783 CE82 16DA  14        jne  FREEZE                     ; BNE FREEZE        ; so loop back up to keep listening for configuration
31784                                                                          ; keys, otherwise fall through into the rest of the
31785                                                                          ; key detection code, which unpauses the game
31786               
31787               DK2:
31788 CE84 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is non-zero (i.e. not a space
     CE86 0096     
31789 CE88 160F  14        jne  DK5                        ; BNE DK5           ; view), return from the subroutine (as DK5 contains
31790                                                                          ; an RTS)
31791               
31792 CE8A 020F  20        li   ry,>0f*256                 ; LDY #15           ; This is a space view, so now we want to check for all
     CE8C 0F00     
31793                                                                          ; the secondary flight keys. The internal key numbers
31794                                                                          ; are in the keyboard table KYTB from KYTB+8 to
31795                                                                          ; KYTB+15, and their key logger locations are from KL+8
31796                                                                          ; to KL+15. So set a decreasing counter in Y for the
31797                                                                          ; index, starting at 15, so we can loop through them
31798               
31799 CE8E 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to &FF so we can store this in the keyboard
     CE90 FF00     
31800                                                                          ; logger for keys that are being pressed
31801               
31802               DKL1:
31803 CE92 D3AF  34        movb @KYTB(ry),rx               ; LDX KYTB,Y        ; Get the internal key number of the Y-th flight key
     CE94 CCA5     
31804                                                                          ; the KYTB keyboard table
31805               
31806 CE96 93A0  30        cb   @KL,rx                     ; CPX KL            ; We stored the key that's being pressed in KL above,
     CE98 0041     
31807                                                                          ; so check to see if the Y-th flight key is being
31808                                                                          ; pressed
31809               
31810 CE9A 1602  14        jne  DK1                        ; BNE DK1           ; If it is not being pressed, skip to DK1 below
31811               
31812 CE9C DBCD  38        movb ra,@KL(ry)                 ; STA KL,Y          ; The Y-th flight key is being pressed, so set that
     CE9E 0041     
31813                                                                          ; key's location in the key logger to &FF
31814               
31815               DK1:
31816 CEA0 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
31817               
31818 CEA2 028F  22        ci   ry,>07*256                 ; CPY #7            ; Have we just done the last key?
     CEA4 0700     
31819               
31820 CEA6 16F5  14        jne  DKL1                       ; BNE DKL1          ; If not, loop back to process the next key
31821               
31822               DK5:
31823 CEA8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CEAA FE34     
31824               
31825               * ******************************************************************************
31826               *
31827               * Name: TT217
31828               * Type: Subroutine
31829               * Category: Keyboard
31830               * Summary: Scan the keyboard until a key is pressed
31831               *
31832               * ------------------------------------------------------------------------------
31833               *
31834               * Scan the keyboard until a key is pressed, and return the key's ASCII code.
31835               * If, on entry, a key is already being held down, then wait until that key is
31836               * released first (so this routine detects the first key down event following
31837               * the subroutine call).
31838               *
31839               * ------------------------------------------------------------------------------
31840               *
31841               * Returns:
31842               *
31843               * X                   The ASCII code of the key that was pressed
31844               *
31845               * A                   Contains the same as X
31846               *
31847               * Y                   Y is preserved
31848               *
31849               * ------------------------------------------------------------------------------
31850               *
31851               * Other entry points:
31852               *
31853               * out                 Contains an RTS
31854               *
31855               * ******************************************************************************
31856               
31857               TT217:
31858 CEAC D80F  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y in temporary storage, so we can restore it
     CEAE 0094     
31859                                                                          ; later
31860               
31861               t_:
31862 CEB0 0200  20        li   rtmp,DELAY-5               ; JSR DELAY-5       ; Delay for 8 vertical syncs (8/50 = 0.16 seconds) so we
     CEB2 4CAF     
31863 CEB4 06A0  32        bl   @jsr                       ;
     CEB6 FE28     
31864                                                                          ; don't take up too much CPU time while looping round
31865               
31866 CEB8 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     CEBA CBA0     
31867 CEBC 06A0  32        bl   @jsr                       ;
     CEBE FE28     
31868                                                                          ; internal key number in X (or 0 for no key press)
31869               
31870 CEC0 16F7  14        jne  t_                         ; BNE t             ; If a key was already being held down when we entered
31871                                                                          ; this routine, keep looping back up to t, until the
31872                                                                          ; key is released
31873               
31874               t2_:
31875 CEC2 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Any pre-existing key press is now gone, so we can
     CEC4 CBA0     
31876 CEC6 06A0  32        bl   @jsr                       ;
     CEC8 FE28     
31877                                                                          ; start scanning the keyboard again, returning the
31878                                                                          ; internal key number in X (or 0 for no key press)
31879               
31880 CECA 13FB  14        jeq  t2_                        ; BEQ t2            ; Keep looping up to t2 until a key is pressed
31881               
31882 CECC D3CD  18        movb ra,ry                      ; TAY               ; Copy A to Y, so Y contains the internal key number
31883                                                                          ; of the key pressed
31884               
31885                      .ld_ind_y_idx @TRTB.,ra         ; LDA (TRTB%),Y     ; The address in TRTB% points to the MOS key
     **** ****     > LD_IND_Y_IDX
0001 CECE D820  42        movb @TRTB.,@rtmplb
     CED0 0004     
     CED2 8301     
0002 CED4 D020  30        movb @TRTB.+1,rtmp
     CED6 0005     
0003 CED8 06CF  14        swpb ry
0004 CEDA A00F  18        a    ry,rtmp
0005 CEDC 06CF  14        swpb ry
0006 CEDE D350  26        movb *rtmp,RA
                   < elite.a99
31886                                                                          ; translation table, which is used to translate
31887                                                                          ; internal key numbers to ASCII, so this fetches the
31888                                                                          ; key's ASCII code into A
31889               
31890 CEE0 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore the original value of Y we stored above
     CEE2 0094     
31891               
31892 CEE4 D38D  18        movb ra,rx                      ; TAX               ; Copy A into X
31893               
31894               out_:
31895 CEE6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CEE8 FE34     
31896               
31897               * ******************************************************************************
31898               *
31899               * Name: me1
31900               * Type: Subroutine
31901               * Category: Flight
31902               * Summary: Erase an old in-flight message and display a new one
31903               *
31904               * ------------------------------------------------------------------------------
31905               *
31906               * Arguments:
31907               *
31908               * A                   The text token to be printed
31909               *
31910               * X                   Must be set to 0
31911               *
31912               * ******************************************************************************
31913               
31914               me1_:
31915 CEEA D80E  30        movb rx,@DLY                    ; STX DLY           ; Set the message delay in DLY to 0, so any new
     CEEC 0D64     
31916                                                                          ; in-flight messages will be shown instantly
31917               
31918                      .pha                            ; PHA               ; Store the new message token we want to print
     **** ****     > PHA
0001 CEEE D68D  30        movb ra,*rsp
0002 CEF0 060A  14        dec  rsp
                   < elite.a99
31919               
31920 CEF2 D360  30        movb @MCH,ra                    ; LDA MCH           ; Set A to the token number of the message that is
     CEF4 0F10     
31921 CEF6 0200  20        li   rtmp,mes9_                 ; JSR mes9          ; currently on-screen, and call mes9 to print it (which
     CEF8 CF34     
31922 CEFA 06A0  32        bl   @jsr                       ;
     CEFC FE28     
31923                                                                          ; will remove it from the screen, as printing is done
31924                                                                          ; using EOR logic)
31925               
31926                      .pla                            ; PLA               ; Restore the new message token
     **** ****     > PLA
0001 CEFE 058A  14        inc  rsp
0002 CF00 D35A  26        movb *rsp,ra
                   < elite.a99
31927               
31928 CF02 2C              byte >2c                                            ; Fall through into ou2 to print the new message, but
31929                                                                          ; skip the first instruction by turning it into
31930                                                                          ; &2C &A9 &6C, or BIT &6CA9, which does nothing apart
31931                                                                          ; from affect the flags
31932               
31933               * ******************************************************************************
31934               *
31935               * Name: ou2
31936               * Type: Subroutine
31937               * Category: Flight
31938               * Summary: Display "E.C.M.SYSTEM DESTROYED" as an in-flight message
31939               *
31940               * ******************************************************************************
31941               
31942               ou2_:
31943 CF04 020D  20        li   ra,>6c*256                 ; LDA #108          ; Set A to recursive token 108 ("E.C.M.SYSTEM")
     CF06 6C00     
31944               
31945 CF08 2C              byte >2c                                            ; Fall through into ou3 to print the new message, but
31946                                                                          ; skip the first instruction by turning it into
31947                                                                          ; &2C &A9 &6F, or BIT &6FA9, which does nothing apart
31948                                                                          ; from affect the flags
31949               
31950               * ******************************************************************************
31951               *
31952               * Name: ou3
31953               * Type: Subroutine
31954               * Category: Flight
31955               * Summary: Display "FUEL SCOOPS DESTROYED" as an in-flight message
31956               *
31957               * ******************************************************************************
31958               
31959               ou3_:
31960 CF0A 020D  20        li   ra,>6f*256                 ; LDA #111          ; Set A to recursive token 111 ("FUEL SCOOPS")
     CF0C 6F00     
31961               
31962               * ******************************************************************************
31963               *
31964               * Name: MESS
31965               * Type: Subroutine
31966               * Category: Flight
31967               * Summary: Display an in-flight message
31968               *
31969               * ------------------------------------------------------------------------------
31970               *
31971               * Display an in-flight message in capitals at the bottom of the space view,
31972               * erasing any existing in-flight message first.
31973               *
31974               * ------------------------------------------------------------------------------
31975               *
31976               * Arguments:
31977               *
31978               * A                   The text token to be printed
31979               *
31980               * ******************************************************************************
31981               
31982               MESS:
31983 CF0E 020E  20        li   rx,>00*256                 ; LDX #0            ; Set QQ17 = 0 to switch to ALL CAPS
     CF10 0000     
31984 CF12 D80E  30        movb rx,@QQ17                   ; STX QQ17
     CF14 007E     
31985               
31986 CF16 020F  20        li   ry,>09*256                 ; LDY #9            ; Move the text cursor to column 9, row 22, at the
     CF18 0900     
31987 CF1A D80F  30        movb ry,@XC                     ; STY XC            ; bottom middle of the screen, and set Y = 22
     CF1C 002C     
31988 CF1E 020F  20        li   ry,>16*256                 ; LDY #22
     CF20 1600     
31989 CF22 D80F  30        movb ry,@YC                     ; STY YC
     CF24 002D     
31990               
31991 CF26 93A0  30        cb   @DLY,rx                    ; CPX DLY           ; If the message delay in DLY is not zero, jump up to
     CF28 0D64     
31992 CF2A 16DF  14        jne  me1_                       ; BNE me1           ; me1 to erase the current message first (whose token
31993                                                                          ; number will be in MCH)
31994               
31995 CF2C D80F  30        movb ry,@DLY                    ; STY DLY           ; Set the message delay in DLY to 22
     CF2E 0D64     
31996               
31997 CF30 D80D  30        movb ra,@MCH                    ; STA MCH           ; Set MCH to the token we are about to display
     CF32 0F10     
31998               
31999                                                                          ; Fall through into mes9 to print the token in A
32000               
32001               * ******************************************************************************
32002               *
32003               * Name: mes9
32004               * Type: Subroutine
32005               * Category: Flight
32006               * Summary: Print a text token, possibly followed by " DESTROYED"
32007               *
32008               * ------------------------------------------------------------------------------
32009               *
32010               * Print a text token, followed by " DESTROYED" if the destruction flag is set
32011               * (for when a piece of equipment is destroyed).
32012               *
32013               * ******************************************************************************
32014               
32015               mes9_:
32016 CF34 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Call TT27 to print the text token in A
     CF36 A6E8     
32017 CF38 06A0  32        bl   @jsr                       ;
     CF3A FE28     
32018               
32019                      .lsr @de_                       ; LSR de            ; If bit 0 of variable de is clear, return from the
     **** ****     > LSR
0001 CF3C D020  30        movb @DE_,rtmp
     CF3E 0D65     
0002 CF40 0910  18        srl  rtmp,1
0003 CF42 D800  30        movb rtmp,@DE_
     CF44 0D65     
                   < elite.a99
32020 CF46 17CF  14        jnc  out_                       ; BCC out           ; subroutine (as out contains an RTS)
32021               
32022 CF48 020D  20        li   ra,>fd*256                 ; LDA #253          ; Print recursive token 93 (" DESTROYED") and return
     CF4A FD00     
32023 CF4C 0460  28        b    @TT27                      ; JMP TT27          ; from the subroutine using a tail call
     CF4E A6E8     
32024               
32025               * ******************************************************************************
32026               *
32027               * Name: OUCH
32028               * Type: Subroutine
32029               * Category: Flight
32030               * Summary: Potentially lose cargo or equipment following damage
32031               *
32032               * ------------------------------------------------------------------------------
32033               *
32034               * Our shields are dead and we are taking damage, so there is a small chance of
32035               * losing cargo or equipment.
32036               *
32037               * ******************************************************************************
32038               
32039               OUCH:
32040 CF50 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     CF52 C120     
32041 CF54 06A0  32        bl   @jsr                       ;
     CF56 FE28     
32042               
32043 CF58 11C6  14        jlt  out_                       ; BMI out           ; If A < 0 (50% chance), return from the subroutine
32044                                                                          ; (as out contains an RTS)
32045               
32046 CF5A 028E  22        ci   rx,>16*256                 ; CPX #22           ; If X >= 22 (91% chance), return from the subroutine
     CF5C 1600     
32047 CF5E 18C3  14        joc  out_                       ; BCS out           ; (as out contains an RTS)
32048               
32049 CF60 D36E  34        movb @QQ20(rx),ra               ; LDA QQ20,X        ; If we do not have any of item QQ20+X, return from the
     CF62 0317     
32050 CF64 13C0  14        jeq  out_                       ; BEQ out           ; subroutine (as out contains an RTS). X is in the range
32051                                                                          ; 0-21, so this not only checks for cargo, but also for
32052                                                                          ; E.C.M., fuel scoops, energy bomb, energy unit and
32053                                                                          ; docking computer, all of which can be destroyed
32054               
32055 CF66 D360  30        movb @DLY,ra                    ; LDA DLY           ; If there is already an in-flight message on-screen,
     CF68 0D64     
32056 CF6A 16BD  14        jne  out_                       ; BNE out           ; return from the subroutine (as out contains an RTS)
32057               
32058 CF6C 020F  20        li   ry,>03*256                 ; LDY #3            ; Set bit 1 of de, the equipment destruction flag, so
     CF6E 0300     
32059 CF70 D80F  30        movb ry,@de_                    ; STY de            ; that when we call MESS below, " DESTROYED" is appended
     CF72 0D65     
32060                                                                          ; to the in-flight message
32061               
32062 CF74 DB8D  38        movb ra,@QQ20(rx)               ; STA QQ20,X        ; A is 0 (as we didn't branch with the BNE above), so
     CF76 0317     
32063                                                                          ; this sets QQ20+X to 0, which destroys any cargo or
32064                                                                          ; equipment we have of that type
32065               
32066 CF78 028E  22        ci   rx,>11*256                 ; CPX #17           ; If X >= 17 then we just lost a piece of equipment, so
     CF7A 1100     
32067 CF7C 1806  14        joc  ou1_                       ; BCS ou1           ; jump to ou1 to print the relevant message
32068               
32069 CF7E D34E  18        movb rx,ra                      ; TXA               ; Print recursive token 48 + A as an in-flight token,
32070                      .adi (>d0*256)                  ; ADC #208          ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
     **** ****     > ADI
0001 CF80 1701  14        jnc  !
0002 CF82 B347  18        ab   rone,ra
0003               !:
0004 CF84 022D  22        ai   ra,(>D0*256)
     CF86 D000     
                   < elite.a99
32071 CF88 16C2  14        jne  MESS                       ; BNE MESS          ; ITEMS") as the C flag is clear, so this prints the
32072                                                                          ; destroyed item's name, followed by " DESTROYED" (as we
32073                                                                          ; set bit 1 of the de flag above), and returns from the
32074                                                                          ; subroutine using a tail call
32075               
32076               ou1_:
32077 CF8A 13BC  14        jeq  ou2_                       ; BEQ ou2           ; If X = 17, jump to ou2 to print "E.C.M.SYSTEM
32078                                                                          ; DESTROYED" and return from the subroutine using a tail
32079                                                                          ; call
32080               
32081 CF8C 028E  22        ci   rx,>12*256                 ; CPX #18           ; If X = 18, jump to ou3 to print "FUEL SCOOPS
     CF8E 1200     
32082 CF90 13BC  14        jeq  ou3_                       ; BEQ ou3           ; DESTROYED" and return from the subroutine using a tail
32083                                                                          ; call
32084               
32085 CF92 D34E  18        movb rx,ra                      ; TXA               ; Otherwise X is in the range 19 to 21 and the C flag is
32086                      .adi ((113-20)*256)             ; ADC #113-20       ; set (as we got here via a BCS to ou1), so we set A as
     **** ****     > ADI
0001 CF94 1701  14        jnc  !
0002 CF96 B347  18        ab   rone,ra
0003               !:
0004 CF98 022D  22        ai   ra,((113-20)*256)
     CF9A 5D00     
                   < elite.a99
32087                                                                          ; follows:
32088                                                                          ;
32089                                                                          ; A = 113 - 20 + X + C
32090                                                                          ; = 113 - 19 + X
32091                                                                          ; = 113 to 115
32092               
32093 CF9C 16B8  14        jne  MESS                       ; BNE MESS          ; Print recursive token A ("ENERGY BOMB", "ENERGY UNIT"
32094                                                                          ; or "DOCKING COMPUTERS") as an in-flight message,
32095                                                                          ; followed by " DESTROYED", and return from the
32096                                                                          ; subroutine using a tail call
32097               
32098               * ******************************************************************************
32099               *
32100               * Name: QQ16
32101               * Type: Variable
32102               * Category: Text
32103               * Summary: The two-letter token lookup table
32104               * Deep dive: Printing text tokens
32105               *
32106               * ------------------------------------------------------------------------------
32107               *
32108               * Two-letter token lookup table for tokens 128-159. See the deep dive on
32109               * "Printing text tokens" for details of how the two-letter token system works.
32110               *
32111               * ******************************************************************************
32112               
32113               QQ16:
32114 CF9E 414C            text 'AL'                                           ; Token 128
32115 CFA0 4C45            text 'LE'                                           ; Token 129
32116 CFA2 5845            text 'XE'                                           ; Token 130
32117 CFA4 4745            text 'GE'                                           ; Token 131
32118 CFA6 5A41            text 'ZA'                                           ; Token 132
32119 CFA8 4345            text 'CE'                                           ; Token 133
32120 CFAA 4249            text 'BI'                                           ; Token 134
32121 CFAC 534F            text 'SO'                                           ; Token 135
32122 CFAE 5553            text 'US'                                           ; Token 136
32123 CFB0 4553            text 'ES'                                           ; Token 137
32124 CFB2 4152            text 'AR'                                           ; Token 138
32125 CFB4 4D41            text 'MA'                                           ; Token 139
32126 CFB6 494E            text 'IN'                                           ; Token 140
32127 CFB8 4449            text 'DI'                                           ; Token 141
32128 CFBA 5245            text 'RE'                                           ; Token 142
32129 CFBC 413F            text 'A?'                                           ; Token 143
32130 CFBE 4552            text 'ER'                                           ; Token 144
32131 CFC0 4154            text 'AT'                                           ; Token 145
32132 CFC2 454E            text 'EN'                                           ; Token 146
32133 CFC4 4245            text 'BE'                                           ; Token 147
32134 CFC6 5241            text 'RA'                                           ; Token 148
32135 CFC8 4C41            text 'LA'                                           ; Token 149
32136 CFCA 5645            text 'VE'                                           ; Token 150
32137 CFCC 5449            text 'TI'                                           ; Token 151
32138 CFCE 4544            text 'ED'                                           ; Token 152
32139 CFD0 4F52            text 'OR'                                           ; Token 153
32140 CFD2 5155            text 'QU'                                           ; Token 154
32141 CFD4 414E            text 'AN'                                           ; Token 155
32142 CFD6 5445            text 'TE'                                           ; Token 156
32143 CFD8 4953            text 'IS'                                           ; Token 157
32144 CFDA 5249            text 'RI'                                           ; Token 158
32145 CFDC 4F4E            text 'ON'                                           ; Token 159
32146               
32147               * ******************************************************************************
32148               *
32149               * Name: ITEM
32150               * Type: Macro
32151               * Category: Market
32152               * Summary: Macro definition for the market prices table
32153               * Deep dive: Market item prices and availability
32154               *
32155               * ------------------------------------------------------------------------------
32156               *
32157               * The following macro is used to build the market prices table:
32158               *
32159               * ITEM price, factor, units, quantity, mask
32160               *
32161               * It inserts an item into the market prices table at QQ23. See the deep dive on
32162               * "Market item prices and availability" for more information on how the market
32163               * system works.
32164               *
32165               * ------------------------------------------------------------------------------
32166               *
32167               * Arguments:
32168               *
32169               * price               Base price
32170               *
32171               * factor              Economic factor
32172               *
32173               * units               Units: "t", "g" or "k"
32174               *
32175               * quantity            Base quantity
32176               *
32177               * mask                Fluctuations mask
32178               *
32179               * ******************************************************************************
32180               
32181                      ; MACRO ITEM price, factor, units, quantity, mask
32182               
32183                      ; IF factor < 0                 ;
32184                      ; s = 1 << 7                    ;
32185                      ; ELSE                          ;
32186                      ; s = 0                         ;
32187                      ; ENDIF                         ;
32188               
32189                      ; IF units = 't'                ;
32190                      ; u = 0                         ;
32191                      ; ELIF units = 'k'              ;
32192                      ; u = 1 << 5                    ;
32193                      ; ELSE                          ;
32194                      ; u = 1 << 6                    ;
32195                      ; ENDIF                         ;
32196               
32197                      ; e = ABS(factor)               ;
32198               
32199                      ; EQUB price                    ;
32200                      ; EQUB s + u + e                ;
32201                      ; EQUB quantity                 ;
32202                      ; EQUB mask                     ;
32203               
32204                      ; ENDMACRO
32205               
32206               * ******************************************************************************
32207               *
32208               * Name: QQ23
32209               * Type: Variable
32210               * Category: Market
32211               * Summary: Market prices table
32212               *
32213               * ------------------------------------------------------------------------------
32214               *
32215               * Each item has four bytes of data, like this:
32216               *
32217               * Byte #0 = Base price
32218               * Byte #1 = Economic factor in bits 0-4, with the sign in bit 7
32219               * Unit in bits 5-6
32220               * Byte #2 = Base quantity
32221               * Byte #3 = Mask to control price fluctuations
32222               *
32223               * To make it easier for humans to follow, we've defined a macro called ITEM
32224               * that takes the following arguments and builds the four bytes for us:
32225               *
32226               * ITEM base price, economic factor, units, base quantity, mask
32227               *
32228               * So for food, we have the following:
32229               *
32230               * * Base price = 19
32231               * * Economic factor = -2
32232               * * Unit = tonnes
32233               * * Base quantity = 6
32234               * * Mask = %00000001
32235               *
32236               * ******************************************************************************
32237               
32238               QQ23:
32239 CFDE 1382            byte >13, >82, >06, >01                             ; 0 = Food
     CFE0 0601     
32240 CFE2 1481            byte >14, >81, >0a, >03                             ; 1 = Textiles
     CFE4 0A03     
32241 CFE6 4183            byte >41, >83, >02, >07                             ; 2 = Radioactives
     CFE8 0207     
32242 CFEA 2885            byte >28, >85, >e2, >1f                             ; 3 = Slaves
     CFEC E21F     
32243 CFEE 5385            byte >53, >85, >fb, >0f                             ; 4 = Liquor/Wines
     CFF0 FB0F     
32244 CFF2 C408            byte >c4, >08, >36, >03                             ; 5 = Luxuries
     CFF4 3603     
32245 CFF6 EB1D            byte >eb, >1d, >08, >78                             ; 6 = Narcotics
     CFF8 0878     
32246 CFFA 9A0E            byte >9a, >0e, >38, >03                             ; 7 = Computers
     CFFC 3803     
32247 CFFE 7506            byte >75, >06, >28, >07                             ; 8 = Machinery
     D000 2807     
32248 D002 4E01            byte >4e, >01, >11, >1f                             ; 9 = Alloys
     D004 111F     
32249 D006 7C0D            byte >7c, >0d, >1d, >07                             ; 10 = Firearms
     D008 1D07     
32250 D00A B089            byte >b0, >89, >dc, >3f                             ; 11 = Furs
     D00C DC3F     
32251 D00E 2081            byte >20, >81, >35, >03                             ; 12 = Minerals
     D010 3503     
32252 D012 61A1            byte >61, >a1, >42, >07                             ; 13 = Gold
     D014 4207     
32253 D016 ABA2            byte >ab, >a2, >37, >1f                             ; 14 = Platinum
     D018 371F     
32254 D01A 2DC1            byte >2d, >c1, >fa, >0f                             ; 15 = Gem-Stones
     D01C FA0F     
32255 D01E 350F            byte >35, >0f, >c0, >07                             ; 16 = Alien items
     D020 C007     
32256               
32257               * ******************************************************************************
32258               *
32259               * Name: TIDY
32260               * Type: Subroutine
32261               * Category: Maths (Geometry)
32262               * Summary: Orthonormalise the orientation vectors for a ship
32263               * Deep dive: Tidying orthonormal vectors
32264               * Orientation vectors
32265               *
32266               * ------------------------------------------------------------------------------
32267               *
32268               * This routine orthonormalises the orientation vectors for a ship. This means
32269               * making the three orientation vectors orthogonal (perpendicular to each other),
32270               * and normal (so each of the vectors has length 1).
32271               *
32272               * We do this because we use the small angle approximation to rotate these
32273               * vectors in space. It is not completely accurate, so the three vectors tend
32274               * to get stretched over time, so periodically we tidy the vectors with this
32275               * routine to ensure they remain as orthonormal as possible.
32276               *
32277               * ******************************************************************************
32278               
32279               TI2:
32280                                                                          ; Called from below with A = 0, X = 0, Y = 4 when
32281                                                                          ; nosev_x and nosev_y are small, so we assume that
32282                                                                          ; nosev_z is big
32283 D022 D34F  18        movb ry,ra                      ; TYA               ; A = Y = 4
32284 D024 020F  20        li   ry,>02*256                 ; LDY #2
     D026 0200     
32285 D028 0200  20        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 0, Y = 2, A = 4, to set roofv_z =
     D02A D1E2     
32286 D02C 06A0  32        bl   @jsr                       ;
     D02E FE28     
32287 D030 D80D  30        movb ra,@INWK+20                ; STA INWK+20       ; -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
     D032 0067     
32288               
32289 D034 0460  28        b    @TI3                       ; JMP TI3           ; Jump to TI3 to keep tidying
     D036 D0B2     
32290               
32291               TI1:
32292                                                                          ; Called from below with A = 0, Y = 4 when nosev_x is
32293                                                                          ; small
32294 D038 D38D  18        movb ra,rx                      ; TAX               ; Set X = A = 0
32295               
32296 D03A D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A = nosev_y, and if the top two magnitude bits
     D03C 0032     
32297 D03E 024D  22        andi ra,>60*256                 ; AND #%01100000    ; are both clear, jump to TI2 with A = 0, X = 0, Y = 4
     D040 6000     
32298 D042 13EF  14        jeq  TI2                        ; BEQ TI2
32299               
32300 D044 020D  20        li   ra,>02*256                 ; LDA #2            ; Otherwise nosev_y is big, so set up the index values
     D046 0200     
32301                                                                          ; to pass to TIS3
32302               
32303 D048 0200  20        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 0, Y = 4, A = 2, to set roofv_y =
     D04A D1E2     
32304 D04C 06A0  32        bl   @jsr                       ;
     D04E FE28     
32305 D050 D80D  30        movb ra,@INWK+18                ; STA INWK+18       ; -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
     D052 0065     
32306               
32307 D054 0460  28        b    @TI3                       ; JMP TI3           ; Jump to TI3 to keep tidying
     D056 D0B2     
32308               
32309               TIDY:
32310 D058 D360  30        movb @INWK+10,ra                ; LDA INWK+10       ; Set (XX15, XX15+1, XX15+2) = nosev
     D05A 005D     
32311 D05C D80D  30        movb ra,@XX15                   ; STA XX15
     D05E 0031     
32312 D060 D360  30        movb @INWK+12,ra                ; LDA INWK+12
     D062 005F     
32313 D064 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     D066 0032     
32314 D068 D360  30        movb @INWK+14,ra                ; LDA INWK+14
     D06A 0061     
32315 D06C D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     D06E 0033     
32316               
32317 D070 0200  20        li   rtmp,NORM                  ; JSR NORM          ; Call NORM to normalise the vector in XX15, i.e. nosev
     D072 CAEC     
32318 D074 06A0  32        bl   @jsr                       ;
     D076 FE28     
32319               
32320 D078 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set nosev = (XX15, XX15+1, XX15+2)
     D07A 0031     
32321 D07C D80D  30        movb ra,@INWK+10                ; STA INWK+10
     D07E 005D     
32322 D080 D360  30        movb @XX15+1,ra                 ; LDA XX15+1
     D082 0032     
32323 D084 D80D  30        movb ra,@INWK+12                ; STA INWK+12
     D086 005F     
32324 D088 D360  30        movb @XX15+2,ra                 ; LDA XX15+2
     D08A 0033     
32325 D08C D80D  30        movb ra,@INWK+14                ; STA INWK+14
     D08E 0061     
32326               
32327 D090 020F  20        li   ry,>04*256                 ; LDY #4            ; Set Y = 4
     D092 0400     
32328               
32329 D094 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A = nosev_x, and if the top two magnitude bits
     D096 0031     
32330 D098 024D  22        andi ra,>60*256                 ; AND #%01100000    ; are both clear, jump to TI1 with A = 0, Y = 4
     D09A 6000     
32331 D09C 13CD  14        jeq  TI1                        ; BEQ TI1
32332               
32333 D09E 020E  20        li   rx,>02*256                 ; LDX #2            ; Otherwise nosev_x is big, so set up the index values
     D0A0 0200     
32334 D0A2 020D  20        li   ra,>00*256                 ; LDA #0            ; to pass to TIS3
     D0A4 0000     
32335               
32336 D0A6 0200  20        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 2, Y = 4, A = 0, to set roofv_x =
     D0A8 D1E2     
32337 D0AA 06A0  32        bl   @jsr                       ;
     D0AC FE28     
32338 D0AE D80D  30        movb ra,@INWK+16                ; STA INWK+16       ; -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
     D0B0 0063     
32339               
32340               TI3:
32341 D0B2 D360  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set (XX15, XX15+1, XX15+2) = roofv
     D0B4 0063     
32342 D0B6 D80D  30        movb ra,@XX15                   ; STA XX15
     D0B8 0031     
32343 D0BA D360  30        movb @INWK+18,ra                ; LDA INWK+18
     D0BC 0065     
32344 D0BE D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     D0C0 0032     
32345 D0C2 D360  30        movb @INWK+20,ra                ; LDA INWK+20
     D0C4 0067     
32346 D0C6 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     D0C8 0033     
32347               
32348 D0CA 0200  20        li   rtmp,NORM                  ; JSR NORM          ; Call NORM to normalise the vector in XX15, i.e. roofv
     D0CC CAEC     
32349 D0CE 06A0  32        bl   @jsr                       ;
     D0D0 FE28     
32350               
32351 D0D2 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set roofv = (XX15, XX15+1, XX15+2)
     D0D4 0031     
32352 D0D6 D80D  30        movb ra,@INWK+16                ; STA INWK+16
     D0D8 0063     
32353 D0DA D360  30        movb @XX15+1,ra                 ; LDA XX15+1
     D0DC 0032     
32354 D0DE D80D  30        movb ra,@INWK+18                ; STA INWK+18
     D0E0 0065     
32355 D0E2 D360  30        movb @XX15+2,ra                 ; LDA XX15+2
     D0E4 0033     
32356 D0E6 D80D  30        movb ra,@INWK+20                ; STA INWK+20
     D0E8 0067     
32357               
32358 D0EA D360  30        movb @INWK+12,ra                ; LDA INWK+12       ; Set Q = nosev_y
     D0EC 005F     
32359 D0EE D80D  30        movb ra,@Q                      ; STA Q
     D0F0 0090     
32360               
32361 D0F2 D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z
     D0F4 0067     
32362               
32363 D0F6 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_y * roofv_z
     D0F8 4512     
32364 D0FA 06A0  32        bl   @jsr                       ;
     D0FC FE28     
32365               
32366 D0FE D3A0  30        movb @INWK+14,rx                ; LDX INWK+14       ; Set X = nosev_z
     D100 0061     
32367               
32368 D102 D360  30        movb @INWK+18,ra                ; LDA INWK+18       ; Set A = roofv_y
     D104 0065     
32369               
32370 D106 0200  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     D108 4604     
32371 D10A 06A0  32        bl   @jsr                       ;
     D10C FE28     
32372                                                                          ; = (-nosev_z * roofv_y + nosev_y * roofv_z) / 96
32373                                                                          ;
32374                                                                          ; This also sets Q = nosev_z
32375               
32376                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_x = -A
     **** ****     > EOI
0001 D10E 0200  20        li   rtmp,(>80*256)
     D110 8000     
0002 D112 2B40  18        xor  rtmp,ra
                   < elite.a99
32377 D114 D80D  30        movb ra,@INWK+22                ; STA INWK+22       ; = (nosev_z * roofv_y - nosev_y * roofv_z) / 96
     D116 0069     
32378               
32379 D118 D360  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set A = roofv_x
     D11A 0063     
32380               
32381 D11C 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_z * roofv_x
     D11E 4512     
32382 D120 06A0  32        bl   @jsr                       ;
     D122 FE28     
32383               
32384 D124 D3A0  30        movb @INWK+10,rx                ; LDX INWK+10       ; Set X = nosev_x
     D126 005D     
32385               
32386 D128 D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z
     D12A 0067     
32387               
32388 D12C 0200  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     D12E 4604     
32389 D130 06A0  32        bl   @jsr                       ;
     D132 FE28     
32390                                                                          ; = (-nosev_x * roofv_z + nosev_z * roofv_x) / 96
32391                                                                          ;
32392                                                                          ; This also sets Q = nosev_x
32393               
32394                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_y = -A
     **** ****     > EOI
0001 D134 0200  20        li   rtmp,(>80*256)
     D136 8000     
0002 D138 2B40  18        xor  rtmp,ra
                   < elite.a99
32395 D13A D80D  30        movb ra,@INWK+24                ; STA INWK+24       ; = (nosev_x * roofv_z - nosev_z * roofv_x) / 96
     D13C 006B     
32396               
32397 D13E D360  30        movb @INWK+18,ra                ; LDA INWK+18       ; Set A = roofv_y
     D140 0065     
32398               
32399 D142 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_x * roofv_y
     D144 4512     
32400 D146 06A0  32        bl   @jsr                       ;
     D148 FE28     
32401               
32402 D14A D3A0  30        movb @INWK+12,rx                ; LDX INWK+12       ; Set X = nosev_y
     D14C 005F     
32403               
32404 D14E D360  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set A = roofv_x
     D150 0063     
32405               
32406 D152 0200  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     D154 4604     
32407 D156 06A0  32        bl   @jsr                       ;
     D158 FE28     
32408                                                                          ; = (-nosev_y * roofv_x + nosev_x * roofv_y) / 96
32409               
32410                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_z = -A
     **** ****     > EOI
0001 D15A 0200  20        li   rtmp,(>80*256)
     D15C 8000     
0002 D15E 2B40  18        xor  rtmp,ra
                   < elite.a99
32411 D160 D80D  30        movb ra,@INWK+26                ; STA INWK+26       ; = (nosev_y * roofv_x - nosev_x * roofv_y) / 96
     D162 006D     
32412               
32413 D164 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can clear the low bytes of the
     D166 0000     
32414                                                                          ; orientation vectors
32415               
32416 D168 020E  20        li   rx,>0e*256                 ; LDX #14           ; We want to clear the low bytes, so start from sidev_y
     D16A 0E00     
32417                                                                          ; at byte #9+14 (we clear all except sidev_z_lo, though
32418                                                                          ; I suspect this is in error and that X should be 16)
32419               
32420               TIL1:
32421 D16C DB8D  38        movb ra,@INWK+9(rx)             ; STA INWK+9,X      ; Set the low byte in byte #9+X to zero
     D16E 005C     
32422               
32423 D170 7387  18        sb   rone,rx                    ; DEX               ; Set X = X - 2 to jump down to the next low byte
32424 D172 7387  18        sb   rone,rx                    ; DEX
32425               
32426 D174 15FB  14        jgt  TIL1                       ; BPL TIL1          ; Loop back until we have zeroed all the low bytes
32427               
32428 D176 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D178 FE34     
32429               
32430               * ******************************************************************************
32431               *
32432               * Name: TIS2
32433               * Type: Subroutine
32434               * Category: Maths (Arithmetic)
32435               * Summary: Calculate A = A / Q
32436               * Deep dive: Shift-and-subtract division
32437               *
32438               * ------------------------------------------------------------------------------
32439               *
32440               * Calculate the following division, where A is a sign-magnitude number and Q is
32441               * a positive integer:
32442               *
32443               * A = A / Q
32444               *
32445               * The value of A is returned as a sign-magnitude number with 96 representing 1,
32446               * and the maximum value returned is 1 (i.e. 96). This routine is used when
32447               * normalising vectors, where we represent fractions using integers, so this
32448               * gives us an approximation to two decimal places.
32449               *
32450               * ******************************************************************************
32451               
32452               TIS2:
32453 D17A D3CD  18        movb ra,ry                      ; TAY               ; Store the argument A in Y
32454               
32455 D17C 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Strip the sign bit from the argument, so A = |A|
     D17E 7F00     
32456               
32457 D180 9360  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q then jump to TI4 to return a 1 with the
     D182 0090     
32458 D184 1827  14        joc  TI4                        ; BCS TI4           ; correct sign
32459               
32460 D186 020E  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set T to have bits 1-7 set, so we can rotate through 7
     D188 FE00     
32461 D18A D80E  30        movb rx,@T                      ; STX T             ; loop iterations, getting a 1 each time, and then
     D18C 00D1     
32462                                                                          ; getting a 0 on the 8th iteration... and we can also
32463                                                                          ; use T to catch our result bits into bit 0 each time
32464               
32465               TIL2:
32466                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 D18E 024D  22        andi ra,>ff00
     D190 FF00     
0002 D192 0A1D  18        sla  ra,1
                   < elite.a99
32467               
32468 D194 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     D196 0090     
32469 D198 1704  14        jnc  B108                       ; BCC B108
32470               
32471                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 D19A 1801  14        joc  !
0002 D19C 7347  18        sb   rone,ra
0003               !:
0004 D19E 7360  30        sb   @Q,ra
     D1A0 0090     
                   < elite.a99
32472                                                                          ;
32473                                                                          ; Going into this subtraction we know the C flag is
32474                                                                          ; set as we passed through the BCC above, and we also
32475                                                                          ; know that A >= Q, so the C flag will still be set once
32476                                                                          ; we are done
32477               
32478               B108:
32479 D1A2 0204  20        li   rarg1,T                    ; ROL T             ; Rotate the counter in T to the left, and catch the
     D1A4 00D1     
32480 D1A6 06A0  32        bl   @rol                       ;
     D1A8 FE4E     
32481                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
32482                                                                          ; do the subtraction, or 1 if we did)
32483               
32484 D1AA 18F1  14        joc  TIL2                       ; BCS TIL2          ; If we still have set bits in T, loop back to TIL2 to
32485                                                                          ; do the next iteration of 7
32486               
32487                                                                          ; We've done the division and now have a result in the
32488                                                                          ; range 0-255 here, which we need to reduce to the range
32489                                                                          ; 0-96. We can do that by multiplying the result by 3/8,
32490                                                                          ; as 256 * 3/8 = 96
32491               
32492 D1AC D360  30        movb @T,ra                      ; LDA T             ; Set T = T / 4
     D1AE 00D1     
32493 D1B0 091D  18        srl  ra,1                       ; LSR A
32494 D1B2 091D  18        srl  ra,1                       ; LSR A
32495 D1B4 D80D  30        movb ra,@T                      ; STA T
     D1B6 00D1     
32496               
32497 D1B8 091D  18        srl  ra,1                       ; LSR A             ; Set T = T / 8 + T / 4
32498                      .adc @T,ra                      ; ADC T             ; = 3T / 8
     **** ****     > ADC
0001 D1BA 1701  14        jnc  !
0002 D1BC B347  18        ab   rone,ra
0003               !:
0004 D1BE B360  30        ab   @T,ra
     D1C0 00D1     
                   < elite.a99
32499 D1C2 D80D  30        movb ra,@T                      ; STA T
     D1C4 00D1     
32500               
32501 D1C6 D34F  18        movb ry,ra                      ; TYA               ; Fetch the sign bit of the original argument A
32502 D1C8 024D  22        andi ra,>80*256                 ; AND #%10000000
     D1CA 8000     
32503               
32504 D1CC F360  30        socb @T,ra                      ; ORA T             ; Apply the sign bit to T
     D1CE 00D1     
32505               
32506 D1D0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D1D2 FE34     
32507               
32508               TI4:
32509 D1D4 D34F  18        movb ry,ra                      ; TYA               ; Fetch the sign bit of the original argument A
32510 D1D6 024D  22        andi ra,>80*256                 ; AND #%10000000
     D1D8 8000     
32511               
32512 D1DA 026D  22        ori  ra,>60*256                 ; ORA #96           ; Apply the sign bit to 96 (which represents 1)
     D1DC 6000     
32513               
32514 D1DE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D1E0 FE34     
32515               
32516               * ******************************************************************************
32517               *
32518               * Name: TIS3
32519               * Type: Subroutine
32520               * Category: Maths (Arithmetic)
32521               * Summary: Calculate -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
32522               *
32523               * ------------------------------------------------------------------------------
32524               *
32525               * Calculate the following expression:
32526               *
32527               * A = -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
32528               *
32529               * where 1, 2 and 3 are x, y, or z, depending on the values of X, Y and A. This
32530               * routine is called with the following values:
32531               *
32532               * X = 0, Y = 2, A = 4 ->
32533               * A = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
32534               *
32535               * X = 0, Y = 4, A = 2 ->
32536               * A = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
32537               *
32538               * X = 2, Y = 4, A = 0 ->
32539               * A = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
32540               *
32541               * ------------------------------------------------------------------------------
32542               *
32543               * Arguments:
32544               *
32545               * X                   Index 1 (0 = x, 2 = y, 4 = z)
32546               *
32547               * Y                   Index 2 (0 = x, 2 = y, 4 = z)
32548               *
32549               * A                   Index 3 (0 = x, 2 = y, 4 = z)
32550               *
32551               * ******************************************************************************
32552               
32553               TIS3:
32554 D1E2 D80D  30        movb ra,@P+2                    ; STA P+2           ; Store P+2 in A for later
     D1E4 001D     
32555               
32556 D1E6 D36E  34        movb @INWK+10(rx),ra            ; LDA INWK+10,X     ; Set Q = nosev_x_hi (plus X)
     D1E8 005D     
32557 D1EA D80D  30        movb ra,@Q                      ; STA Q
     D1EC 0090     
32558               
32559 D1EE D36E  34        movb @INWK+16(rx),ra            ; LDA INWK+16,X     ; Set A = roofv_x_hi (plus X)
     D1F0 0063     
32560               
32561 D1F2 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A
     D1F4 4512     
32562 D1F6 06A0  32        bl   @jsr                       ;
     D1F8 FE28     
32563                                                                          ; = nosev_x_hi * roofv_x_hi
32564               
32565 D1FA D3AF  34        movb @INWK+10(ry),rx            ; LDX INWK+10,Y     ; Set Q = nosev_x_hi (plus Y)
     D1FC 005D     
32566 D1FE D80E  30        movb rx,@Q                      ; STX Q
     D200 0090     
32567               
32568 D202 D36F  34        movb @INWK+16(ry),ra            ; LDA INWK+16,Y     ; Set A = roofv_x_hi (plus Y)
     D204 0063     
32569               
32570 D206 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     D208 4566     
32571 D20A 06A0  32        bl   @jsr                       ;
     D20C FE28     
32572                                                                          ; = (nosev_x,X * roofv_x,X) +
32573                                                                          ; (nosev_x,Y * roofv_x,Y)
32574               
32575 D20E D80E  30        movb rx,@P                      ; STX P             ; Store low byte of result in P, so result is now in
     D210 001B     
32576                                                                          ; (A P)
32577               
32578 D212 D3E0  30        movb @P+2,ry                    ; LDY P+2           ; Set Q = roofv_x_hi (plus argument A)
     D214 001D     
32579 D216 D3AF  34        movb @INWK+10(ry),rx            ; LDX INWK+10,Y
     D218 005D     
32580 D21A D80E  30        movb rx,@Q                      ; STX Q
     D21C 0090     
32581               
32582                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A
     **** ****     > EOI
0001 D21E 0200  20        li   rtmp,(>80*256)
     D220 8000     
0002 D222 2B40  18        xor  rtmp,ra
                   < elite.a99
32583               
32584                                                                          ; Fall through into DIVDT to do:
32585                                                                          ;
32586                                                                          ; (P+1 A) = (A P) / Q
32587                                                                          ;
32588                                                                          ; = -((nosev_x,X * roofv_x,X) +
32589                                                                          ; (nosev_x,Y * roofv_x,Y))
32590                                                                          ; / nosev_x,A
32591               
32592               * ******************************************************************************
32593               *
32594               * Name: DVIDT
32595               * Type: Subroutine
32596               * Category: Maths (Arithmetic)
32597               * Summary: Calculate (P+1 A) = (A P) / Q
32598               *
32599               * ------------------------------------------------------------------------------
32600               *
32601               * Calculate the following integer division between sign-magnitude numbers:
32602               *
32603               * (P+1 A) = (A P) / Q
32604               *
32605               * This uses the same shift-and-subtract algorithm as TIS2.
32606               *
32607               * ******************************************************************************
32608               
32609               DVIDT:
32610 D224 D80D  30        movb ra,@P+1                    ; STA P+1           ; Set P+1 = A, so P(1 0) = (A P)
     D226 001C     
32611               
32612                      .eor @Q                         ; EOR Q             ; Set T = the sign bit of A EOR Q, so it's 1 if A and Q
     **** ****     > EOR
0001 D228 D020  30        movb @Q,rtmp
     D22A 0090     
0002 D22C 2B40  18        xor  rtmp,ra
                   < elite.a99
32613 D22E 024D  22        andi ra,>80*256                 ; AND #%10000000    ; have different signs, i.e. it's the sign of the result
     D230 8000     
32614 D232 D80D  30        movb ra,@T                      ; STA T             ; of A / Q
     D234 00D1     
32615               
32616 D236 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 for us to build a result
     D238 0000     
32617               
32618 D23A 020E  20        li   rx,>10*256                 ; LDX #16           ; Set a counter in X to count the 16 bits in P(1 0)
     D23C 1000     
32619               
32620                      .asl @P                         ; ASL P             ; Shift P(1 0) left
     **** ****     > ASL
0001 D23E D020  30        movb @P,rtmp
     D240 001B     
0002 D242 0240  22        andi rtmp,>ff00
     D244 FF00     
0003 D246 0A10  18        sla  rtmp,1
0004 D248 D800  30        movb rtmp,@P
     D24A 001B     
                   < elite.a99
32621 D24C 0204  20        li   rarg1,P+1                  ; ROL P+1
     D24E 001C     
32622 D250 06A0  32        bl   @rol                       ;
     D252 FE4E     
32623               
32624                      .asl @Q                         ; ASL Q             ; Clear the sign bit of Q the C flag at the same time
     **** ****     > ASL
0001 D254 D020  30        movb @Q,rtmp
     D256 0090     
0002 D258 0240  22        andi rtmp,>ff00
     D25A FF00     
0003 D25C 0A10  18        sla  rtmp,1
0004 D25E D800  30        movb rtmp,@Q
     D260 0090     
                   < elite.a99
32625                      .lsr @Q                         ; LSR Q
     **** ****     > LSR
0001 D262 D020  30        movb @Q,rtmp
     D264 0090     
0002 D266 0910  18        srl  rtmp,1
0003 D268 D800  30        movb rtmp,@Q
     D26A 0090     
                   < elite.a99
32626               
32627               DVL2:
32628 D26C 06A0  32        bl   @rola                      ; ROL A             ; Shift A to the left
     D26E FE3E     
32629               
32630 D270 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     D272 0090     
32631 D274 1704  14        jnc  B109                       ; BCC B109
32632               
32633                      .sbc @Q,ra                      ; SBC Q             ; Set A = A - Q
     **** ****     > SBC
0001 D276 1801  14        joc  !
0002 D278 7347  18        sb   rone,ra
0003               !:
0004 D27A 7360  30        sb   @Q,ra
     D27C 0090     
                   < elite.a99
32634                                                                          ;
32635                                                                          ; Going into this subtraction we know the C flag is
32636                                                                          ; set as we passed through the BCC above, and we also
32637                                                                          ; know that A >= Q, so the C flag will still be set once
32638                                                                          ; we are done
32639               
32640               B109:
32641 D27E 0204  20        li   rarg1,P                    ; ROL P             ; Rotate P(1 0) to the left, and catch the result bit
     D280 001B     
32642 D282 06A0  32        bl   @rol                       ;
     D284 FE4E     
32643 D286 0204  20        li   rarg1,P+1                  ; ROL P+1           ; into the C flag (which will be a 0 if we didn't
     D288 001C     
32644 D28A 06A0  32        bl   @rol                       ;
     D28C FE4E     
32645                                                                          ; do the subtraction, or 1 if we did)
32646               
32647 D28E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
32648               
32649 D290 16ED  14        jne  DVL2                       ; BNE DVL2          ; Loop back for the next bit until we have done all 16
32650                                                                          ; bits of P(1 0)
32651               
32652 D292 D360  30        movb @P,ra                      ; LDA P             ; Set A = P so the low byte is in the result in A
     D294 001B     
32653               
32654 D296 F360  30        socb @T,ra                      ; ORA T             ; Set A to the correct sign bit that we set in T above
     D298 00D1     
32655               
32656 D29A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D29C FE34     
32657               
32658               * ******************************************************************************
32659               *
32660               * Save ELTF.bin
32661               *
32662               * ******************************************************************************
32663               
32664                      ; PRINT "ELITE F"
32665                      ; PRINT "Assembled at ", ~CODE_F%
32666                      ; PRINT "Ends at ", ~P%
32667                      ; PRINT "Code size is ", ~(P% - CODE_F%)
32668                      ; PRINT "Execute at ", ~LOAD%
32669                      ; PRINT "Reload at ", ~LOAD_F%
32670               
32671                      ; PRINT "S.ELTF ", ~CODE_F%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_F%
32672                      ; SAVE "3-assembled-output/ELTF.bin", CODE_F%, P%, LOAD%
32673               
32674               * ******************************************************************************
32675               *
32676               * ELITE G FILE
32677               *
32678               * Produces the binary file ELTG.bin that gets loaded by elite-bcfs.asm.
32679               *
32680               * ******************************************************************************
32681               
32682               CODE_G.:
32683                      equ $
32684               
32685               LOAD_G.:
32686                      equ LOAD. + $ - CODE.
32687               
32688               * ******************************************************************************
32689               *
32690               * Name: SHPPT
32691               * Type: Subroutine
32692               * Category: Drawing ships
32693               * Summary: Draw a distant ship as a point rather than a full wireframe
32694               *
32695               * ******************************************************************************
32696               
32697               SHPPT:
32698 D29E 0200  20        li   rtmp,EE51                  ; JSR EE51          ; Call EE51 to remove the ship's wireframe from the
     D2A0 D660     
32699 D2A2 06A0  32        bl   @jsr                       ;
     D2A4 FE28     
32700                                                                          ; screen, if there is one
32701               
32702 D2A6 0200  20        li   rtmp,PROJ                  ; JSR PROJ          ; Project the ship onto the screen, returning:
     D2A8 B1BA     
32703 D2AA 06A0  32        bl   @jsr                       ;
     D2AC FE28     
32704                                                                          ;
32705                                                                          ; * K3(1 0) = the screen x-coordinate
32706                                                                          ; * K4(1 0) = the screen y-coordinate
32707                                                                          ; * A = K4+1
32708               
32709 D2AE F360  30        socb @K3+1,ra                   ; ORA K3+1          ; If either of the high bytes of the screen coordinates
     D2B0 00D3     
32710 D2B2 1625  14        jne  nono_                      ; BNE nono          ; are non-zero, jump to nono as the ship is off-screen
32711               
32712 D2B4 D360  30        movb @K4,ra                     ; LDA K4            ; Set A = the y-coordinate of the dot
     D2B6 00E0     
32713               
32714 D2B8 028D  22        ci   ra,(Y*2-2)*256             ; CMP #Y*2-2        ; If the y-coordinate is bigger than the y-coordinate of
     D2BA BE00     
32715 D2BC 1820  14        joc  nono_                      ; BCS nono          ; the bottom of the screen, jump to nono as the ship's
32716                                                                          ; dot is off the bottom of the space view
32717               
32718 D2BE 020F  20        li   ry,>02*256                 ; LDY #2            ; Call Shpt with Y = 2 to set up bytes 1-4 in the ship
     D2C0 0200     
32719 D2C2 0200  20        li   rtmp,Shpt                  ; JSR Shpt          ; lines space, aborting the call to LL9 if the dot is
     D2C4 D312     
32720 D2C6 06A0  32        bl   @jsr                       ;
     D2C8 FE28     
32721                                                                          ; off the side of the screen. This call sets up the
32722                                                                          ; first row of the dot (i.e. a four-pixel dash)
32723               
32724 D2CA 020F  20        li   ry,>06*256                 ; LDY #6            ; Set Y to 6 for the next call to Shpt
     D2CC 0600     
32725               
32726 D2CE D360  30        movb @K4,ra                     ; LDA K4            ; Set A = y-coordinate of dot + 1 (so this is the second
     D2D0 00E0     
32727                      .adi (>01*256)                  ; ADC #1            ; row of the two-pixel-high dot)
     **** ****     > ADI
0001 D2D2 1701  14        jnc  !
0002 D2D4 B347  18        ab   rone,ra
0003               !:
0004 D2D6 022D  22        ai   ra,(>01*256)
     D2D8 0100     
                   < elite.a99
32728                                                                          ;
32729                                                                          ; The addition works as the Shpt routine clears the C
32730                                                                          ; flag
32731               
32732 D2DA 0200  20        li   rtmp,Shpt                  ; JSR Shpt          ; Call Shpt with Y = 6 to set up bytes 5-8 in the ship
     D2DC D312     
32733 D2DE 06A0  32        bl   @jsr                       ;
     D2E0 FE28     
32734                                                                          ; lines space, aborting the call to LL9 if the dot is
32735                                                                          ; off the side of the screen. This call sets up the
32736                                                                          ; second row of the dot (i.e. another four-pixel dash,
32737                                                                          ; on the row below the first one)
32738               
32739 D2E2 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; Set bit 3 of the ship's byte #31 to record that we
     D2E4 0800     
32740 D2E6 F360  30        socb @XX1+31,ra                 ; ORA XX1+31        ; have now drawn something on-screen for this ship
     D2E8 0072     
32741 D2EA D80D  30        movb ra,@XX1+31                 ; STA XX1+31
     D2EC 0072     
32742               
32743 D2EE 020D  20        li   ra,>08*256                 ; LDA #8            ; Set A = 8 so when we call LL18+2 next, byte #0 of the
     D2F0 0800     
32744                                                                          ; heap gets set to 8, for the 8 bytes we just stuck on
32745                                                                          ; the heap
32746               
32747 D2F2 0460  28        b    @LL81+2                    ; JMP LL81+2        ; Call LL81+2 to draw the ship's dot, returning from the
     D2F4 E3AC     
32748                                                                          ; subroutine using a tail call
32749               
32750                      .pla                            ; PLA               ; Pull the return address from the stack, so the RTS
     **** ****     > PLA
0001 D2F6 058A  14        inc  rsp
0002 D2F8 D35A  26        movb *rsp,ra
                   < elite.a99
32751                      .pla                            ; PLA               ; below actually returns from the subroutine that called
     **** ****     > PLA
0001 D2FA 058A  14        inc  rsp
0002 D2FC D35A  26        movb *rsp,ra
                   < elite.a99
32752                                                                          ; LL9 (as we called SHPPT from LL9 with a JMP)
32753               
32754               nono_:
32755 D2FE 020D  20        li   ra,>f7*256                 ; LDA #%11110111    ; Clear bit 3 of the ship's byte #31 to record that
     D300 F700     
32756                      .and @XX1+31                    ; AND XX1+31        ; nothing is being drawn on-screen for this ship
     **** ****     > AND
0001 D302 D020  30        movb @XX1+31,rtmp
     D304 0072     
0002 D306 0540  14        inv  rtmp
0003 D308 5340  18        szcb rtmp,ra
                   < elite.a99
32757 D30A D80D  30        movb ra,@XX1+31                 ; STA XX1+31
     D30C 0072     
32758               
32759 D30E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D310 FE34     
32760               
32761               Shpt:
32762                                                                          ; This routine sets up four bytes in the ship line heap,
32763                                                                          ; from byte Y-1 to byte Y+2. If the ship's screen point
32764                                                                          ; turns out to be off-screen, then this routine aborts
32765                                                                          ; the entire call to LL9, exiting via nono. The four
32766                                                                          ; bytes define a horizontal 4-pixel dash, for either the
32767                                                                          ; top or the bottom of the ship's dot
32768                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store A in byte Y of the ship line heap (i.e. Y1)
     **** ****     > ST_IND_Y_IDX
0001 D312 D820  42        movb @XX19,@rtmplb
     D314 0074     
     D316 8301     
0002 D318 D020  30        movb @XX19+1,rtmp
     D31A 0075     
0003 D31C 06CF  14        swpb ry
0004 D31E A00F  18        a    ry,rtmp
0005 D320 06CF  14        swpb ry
0006 D322 D40D  30        movb RA,*rtmp
                   < elite.a99
32769               
32770 D324 B3C7  18        ab   rone,ry                    ; INY               ; Store A in byte Y+2 of the ship line heap (i.e. Y2)
32771 D326 B3C7  18        ab   rone,ry                    ; INY
32772                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 D328 D820  42        movb @XX19,@rtmplb
     D32A 0074     
     D32C 8301     
0002 D32E D020  30        movb @XX19+1,rtmp
     D330 0075     
0003 D332 06CF  14        swpb ry
0004 D334 A00F  18        a    ry,rtmp
0005 D336 06CF  14        swpb ry
0006 D338 D40D  30        movb RA,*rtmp
                   < elite.a99
32773               
32774 D33A D360  30        movb @K3,ra                     ; LDA K3            ; Set A = screen x-coordinate of the ship dot
     D33C 00D2     
32775               
32776 D33E 73C7  18        sb   rone,ry                    ; DEY               ; Store A in byte Y+1 of the ship line heap (i.e. X2)
32777                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 D340 D820  42        movb @XX19,@rtmplb
     D342 0074     
     D344 8301     
0002 D346 D020  30        movb @XX19+1,rtmp
     D348 0075     
0003 D34A 06CF  14        swpb ry
0004 D34C A00F  18        a    ry,rtmp
0005 D34E 06CF  14        swpb ry
0006 D350 D40D  30        movb RA,*rtmp
                   < elite.a99
32778               
32779                      .adi (>03*256)                  ; ADC #3            ; Set A = screen x-coordinate of the ship dot + 3
     **** ****     > ADI
0001 D352 1701  14        jnc  !
0002 D354 B347  18        ab   rone,ra
0003               !:
0004 D356 022D  22        ai   ra,(>03*256)
     D358 0300     
                   < elite.a99
32780               
32781 D35A 18D0  14        joc  nono_-2                    ; BCS nono-2        ; If the addition pushed the dot off the right side of
32782                                                                          ; the screen, jump to nono-2 to return from the parent
32783                                                                          ; subroutine early (i.e. LL9). This works because we
32784                                                                          ; called Shpt from above with a JSR, so nono-2 removes
32785                                                                          ; that return address from the stack, leaving the next
32786                                                                          ; return address exposed. LL9 called SHPPT with a JMP,
32787                                                                          ; so the next return address is the one that was put on
32788                                                                          ; the stack by the original call to LL9. So the RTS in
32789                                                                          ; nono will actually return us from the original call
32790                                                                          ; to LL9, thus aborting the entire drawing process
32791               
32792 D35C 73C7  18        sb   rone,ry                    ; DEY               ; Store A in byte Y-1 of the ship line heap (i.e. X1)
32793 D35E 73C7  18        sb   rone,ry                    ; DEY
32794                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 D360 D820  42        movb @XX19,@rtmplb
     D362 0074     
     D364 8301     
0002 D366 D020  30        movb @XX19+1,rtmp
     D368 0075     
0003 D36A 06CF  14        swpb ry
0004 D36C A00F  18        a    ry,rtmp
0005 D36E 06CF  14        swpb ry
0006 D370 D40D  30        movb RA,*rtmp
                   < elite.a99
32795               
32796 D372 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D374 FE34     
32797               
32798               * ******************************************************************************
32799               *
32800               * Name: LL5
32801               * Type: Subroutine
32802               * Category: Maths (Arithmetic)
32803               * Summary: Calculate Q = SQRT(R Q)
32804               * Deep dive: Calculating square roots
32805               *
32806               * ------------------------------------------------------------------------------
32807               *
32808               * Calculate the following square root:
32809               *
32810               * Q = SQRT(R Q)
32811               *
32812               * ******************************************************************************
32813               
32814               LL5:
32815 D376 D3E0  30        movb @R,ry                      ; LDY R             ; Set (Y S) = (R Q)
     D378 0091     
32816 D37A D360  30        movb @Q,ra                      ; LDA Q
     D37C 0090     
32817 D37E D80D  30        movb ra,@S                      ; STA S
     D380 0092     
32818               
32819                                                                          ; So now to calculate Q = SQRT(Y S)
32820               
32821 D382 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0, to hold the remainder
     D384 0000     
32822               
32823 D386 D80E  30        movb rx,@Q                      ; STX Q             ; Set Q = 0, to hold the result
     D388 0090     
32824               
32825 D38A 020D  20        li   ra,>08*256                 ; LDA #8            ; Set T = 8, to use as a loop counter
     D38C 0800     
32826 D38E D80D  30        movb ra,@T                      ; STA T
     D390 00D1     
32827               
32828               LL6:
32829 D392 93A0  30        cb   @Q,rx                      ; CPX Q             ; If X < Q, jump to LL7
     D394 0090     
32830 D396 1710  14        jnc  LL7                        ; BCC LL7
32831               
32832 D398 1603  14        jne  LL8                        ; BNE LL8           ; If X > Q, jump to LL8
32833               
32834 D39A 028F  22        ci   ry,>40*256                 ; CPY #64           ; If Y < 64, jump to LL7 with the C flag clear,
     D39C 4000     
32835 D39E 170C  14        jnc  LL7                        ; BCC LL7           ; otherwise fall through into LL8 with the C flag set
32836               
32837               LL8:
32838 D3A0 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y - 64
32839                      .sbi (>40*256)                  ; SBC #64           ;
     **** ****     > SBI
0001 D3A2 1801  14        joc  !
0002 D3A4 7347  18        sb   rone,ra
0003               !:
0004 D3A6 022D  22        ai   ra,-(>40*256)
     D3A8 C000     
                   < elite.a99
32840 D3AA D3CD  18        movb ra,ry                      ; TAY               ; This subtraction will work as we know C is set from
32841                                                                          ; the BCC above, and the result will not underflow as we
32842                                                                          ; already checked that Y >= 64, so the C flag is also
32843                                                                          ; set for the next subtraction
32844               
32845 D3AC D34E  18        movb rx,ra                      ; TXA               ; Set X = X - Q
32846                      .sbc @Q,ra                      ; SBC Q
     **** ****     > SBC
0001 D3AE 1801  14        joc  !
0002 D3B0 7347  18        sb   rone,ra
0003               !:
0004 D3B2 7360  30        sb   @Q,ra
     D3B4 0090     
                   < elite.a99
32847 D3B6 D38D  18        movb ra,rx                      ; TAX
32848               
32849               LL7:
32850 D3B8 0204  20        li   rarg1,Q                    ; ROL Q             ; Shift the result in Q to the left, shifting the C flag
     D3BA 0090     
32851 D3BC 06A0  32        bl   @rol                       ;
     D3BE FE4E     
32852                                                                          ; into bit 0 and bit 7 into the C flag
32853               
32854                      .asl @S                         ; ASL S             ; Shift the dividend in (Y S) to the left, inserting
     **** ****     > ASL
0001 D3C0 D020  30        movb @S,rtmp
     D3C2 0092     
0002 D3C4 0240  22        andi rtmp,>ff00
     D3C6 FF00     
0003 D3C8 0A10  18        sla  rtmp,1
0004 D3CA D800  30        movb rtmp,@S
     D3CC 0092     
                   < elite.a99
32855 D3CE D34F  18        movb ry,ra                      ; TYA               ; bit 7 from above into bit 0
32856 D3D0 06A0  32        bl   @rola                      ; ROL A
     D3D2 FE3E     
32857 D3D4 D3CD  18        movb ra,ry                      ; TAY
32858               
32859 D3D6 D34E  18        movb rx,ra                      ; TXA               ; Shift the remainder in X to the left
32860 D3D8 06A0  32        bl   @rola                      ; ROL A
     D3DA FE3E     
32861 D3DC D38D  18        movb ra,rx                      ; TAX
32862               
32863                      .asl @S                         ; ASL S             ; Shift the dividend in (Y S) to the left
     **** ****     > ASL
0001 D3DE D020  30        movb @S,rtmp
     D3E0 0092     
0002 D3E2 0240  22        andi rtmp,>ff00
     D3E4 FF00     
0003 D3E6 0A10  18        sla  rtmp,1
0004 D3E8 D800  30        movb rtmp,@S
     D3EA 0092     
                   < elite.a99
32864 D3EC D34F  18        movb ry,ra                      ; TYA
32865 D3EE 06A0  32        bl   @rola                      ; ROL A
     D3F0 FE3E     
32866 D3F2 D3CD  18        movb ra,ry                      ; TAY
32867               
32868 D3F4 D34E  18        movb rx,ra                      ; TXA               ; Shift the remainder in X to the left
32869 D3F6 06A0  32        bl   @rola                      ; ROL A
     D3F8 FE3E     
32870 D3FA D38D  18        movb ra,rx                      ; TAX
32871               
32872 D3FC 7347  18        sb   rone,ra                    ; DEC T             ; Decrement the loop counter
32873               
32874 D3FE 16C9  14        jne  LL6                        ; BNE LL6           ; Loop back to LL6 until we have done 8 loops
32875               
32876 D400 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D402 FE34     
32877               
32878               * ******************************************************************************
32879               *
32880               * Name: LL28
32881               * Type: Subroutine
32882               * Category: Maths (Arithmetic)
32883               * Summary: Calculate R = 256 * A / Q
32884               * Deep dive: Shift-and-subtract division
32885               *
32886               * ------------------------------------------------------------------------------
32887               *
32888               * Calculate the following, where A < Q:
32889               *
32890               * R = 256 * A / Q
32891               *
32892               * This is a sister routine to LL61, which does the division when A >= Q.
32893               *
32894               * If A >= Q then 255 is returned and the C flag is set to indicate an overflow
32895               * (the C flag is clear if the division was a success).
32896               *
32897               * The result is returned in one byte as the result of the division multiplied
32898               * by 256, so we can return fractional results using integers.
32899               *
32900               * This routine uses the same shift-and-subtract algorithm that's documented in
32901               * TIS2, but it leaves the fractional result in the integer range 0-255.
32902               *
32903               * ------------------------------------------------------------------------------
32904               *
32905               * Returns:
32906               *
32907               * C flag              Set if the answer is too big for one byte, clear if the
32908               * division was a success
32909               *
32910               * ------------------------------------------------------------------------------
32911               *
32912               * Other entry points:
32913               *
32914               * LL28+4              Skips the A >= Q check and always returns with C flag
32915               * cleared, so this can be called if we know the division
32916               * will work
32917               *
32918               * LL31                Skips the A >= Q check and does not set the R counter,
32919               * so this can be used for jumping straight into the
32920               * division loop if R is already set to 254 and we know the
32921               * division will work
32922               *
32923               * ******************************************************************************
32924               
32925               LL28:
32926 D404 9360  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, then the answer will not fit in one byte,
     D406 0090     
32927 D408 1822  14        joc  LL2                        ; BCS LL2           ; so jump to LL2 to return 255
32928               
32929 D40A 020E  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set R to have bits 1-7 set, so we can rotate through 7
     D40C FE00     
32930 D40E D80E  30        movb rx,@R                      ; STX R             ; loop iterations, getting a 1 each time, and then
     D410 0091     
32931                                                                          ; getting a 0 on the 8th iteration... and we can also
32932                                                                          ; use R to catch our result bits into bit 0 each time
32933               
32934               LL31:
32935                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 D412 024D  22        andi ra,>ff00
     D414 FF00     
0002 D416 0A1D  18        sla  ra,1
                   < elite.a99
32936               
32937 D418 180E  14        joc  LL29                       ; BCS LL29          ; If bit 7 of A was set, then jump straight to the
32938                                                                          ; subtraction
32939               
32940 D41A 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q, skip the following subtraction
     D41C 0090     
32941 D41E 1704  14        jnc  B110                       ; BCC B110
32942               
32943                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 D420 1801  14        joc  !
0002 D422 7347  18        sb   rone,ra
0003               !:
0004 D424 7360  30        sb   @Q,ra
     D426 0090     
                   < elite.a99
32944               
32945               B110:
32946 D428 0204  20        li   rarg1,R                    ; ROL R             ; Rotate the counter in R to the left, and catch the
     D42A 0091     
32947 D42C 06A0  32        bl   @rol                       ;
     D42E FE4E     
32948                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
32949                                                                          ; do the subtraction, or 1 if we did)
32950               
32951 D430 18F0  14        joc  LL31                       ; BCS LL31          ; If we still have set bits in R, loop back to LL31 to
32952                                                                          ; do the next iteration of 7
32953               
32954 D432 0460  28        b    @rts                       ; RTS               ; R left with remainder of division
     D434 FE34     
32955               
32956               LL29:
32957                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 D436 1801  14        joc  !
0002 D438 7347  18        sb   rone,ra
0003               !:
0004 D43A 7360  30        sb   @Q,ra
     D43C 0090     
                   < elite.a99
32958               
32959                      .sec                            ; SEC               ; Set the C flag to rotate into the result in R
     **** ****     > SEC
0001 D43E 0A18  18        sla  rmone,1
                   < elite.a99
32960               
32961 D440 0204  20        li   rarg1,R                    ; ROL R             ; Rotate the counter in R to the left, and catch the
     D442 0091     
32962 D444 06A0  32        bl   @rol                       ;
     D446 FE4E     
32963                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
32964                                                                          ; do the subtraction, or 1 if we did)
32965               
32966 D448 18E4  14        joc  LL31                       ; BCS LL31          ; If we still have set bits in R, loop back to LL31 to
32967                                                                          ; do the next iteration of 7
32968               
32969 D44A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine with R containing the
     D44C FE34     
32970                                                                          ; remainder of the division
32971               
32972               LL2:
32973 D44E 020D  20        li   ra,>ff*256                 ; LDA #255          ; The division is very close to 1, so return the closest
     D450 FF00     
32974 D452 D80D  30        movb ra,@R                      ; STA R             ; possible answer to 256, i.e. R = 255
     D454 0091     
32975               
32976 D456 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D458 FE34     
32977               
32978               * ******************************************************************************
32979               *
32980               * Name: LL38
32981               * Type: Subroutine
32982               * Category: Maths (Arithmetic)
32983               * Summary: Calculate (S A) = (S R) + (A Q)
32984               *
32985               * ------------------------------------------------------------------------------
32986               *
32987               * Calculate the following between sign-magnitude numbers:
32988               *
32989               * (S A) = (S R) + (A Q)
32990               *
32991               * where the sign bytes only contain the sign bits, not magnitudes.
32992               *
32993               * ------------------------------------------------------------------------------
32994               *
32995               * Returns:
32996               *
32997               * C flag              Set if the addition overflowed, clear otherwise
32998               *
32999               * ******************************************************************************
33000               
33001               LL38:
33002                      .eor @S                         ; EOR S             ; If the sign of A * S is negative, skip to LL35, as
     **** ****     > EOR
0001 D45A D020  30        movb @S,rtmp
     D45C 0092     
0002 D45E 2B40  18        xor  rtmp,ra
                   < elite.a99
33003 D460 1109  14        jlt  LL39                       ; BMI LL39          ; A and S have different signs so we need to subtract
33004               
33005 D462 D360  30        movb @Q,ra                      ; LDA Q             ; Otherwise set A = R + Q, which is the result we need,
     D464 0090     
33006                      .clc                            ; CLC               ; as S already contains the correct sign
     **** ****     > CLC
0001 D466 0A16  18        sla  rzero,1
                   < elite.a99
33007                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 D468 1701  14        jnc  !
0002 D46A B347  18        ab   rone,ra
0003               !:
0004 D46C B360  30        ab   @R,ra
     D46E 0091     
                   < elite.a99
33008               
33009 D470 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D472 FE34     
33010               
33011               LL39:
33012 D474 D360  30        movb @R,ra                      ; LDA R             ; Set A = R - Q
     D476 0091     
33013                      .sec                            ; SEC
     **** ****     > SEC
0001 D478 0A18  18        sla  rmone,1
                   < elite.a99
33014                      .sbc @Q,ra                      ; SBC Q
     **** ****     > SBC
0001 D47A 1801  14        joc  !
0002 D47C 7347  18        sb   rone,ra
0003               !:
0004 D47E 7360  30        sb   @Q,ra
     D480 0090     
                   < elite.a99
33015               
33016 D482 1701  14        jnc  B111                       ; BCC B111          ; If the subtraction underflowed, skip the next two
33017                                                                          ; instructions so we can negate the result
33018               
33019                      .clc                            ; CLC               ; Otherwise the result is correct, and S contains the
     **** ****     > CLC
0001 D484 0A16  18        sla  rzero,1
                   < elite.a99
33020                                                                          ; correct sign of the result as R is the dominant side
33021                                                                          ; of the subtraction, so clear the C flag
33022               
33023               B111:
33024 D486 0460  28        b    @rts                       ; RTS               ; And return from the subroutine
     D488 FE34     
33025               
33026                                                                          ; If we get here we need to negate both the result and
33027                                                                          ; the sign in S, as both are the wrong sign
33028               
33029                      .pha                            ; PHA               ; Store the result of the subtraction on the stack
     **** ****     > PHA
0001 D48A D68D  30        movb ra,*rsp
0002 D48C 060A  14        dec  rsp
                   < elite.a99
33030               
33031 D48E D360  30        movb @S,ra                      ; LDA S             ; Flip the sign of S
     D490 0092     
33032                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 D492 0200  20        li   rtmp,(>80*256)
     D494 8000     
0002 D496 2B40  18        xor  rtmp,ra
                   < elite.a99
33033 D498 D80D  30        movb ra,@S                      ; STA S
     D49A 0092     
33034               
33035                      .pla                            ; PLA               ; Restore the subtraction result into A
     **** ****     > PLA
0001 D49C 058A  14        inc  rsp
0002 D49E D35A  26        movb *rsp,ra
                   < elite.a99
33036               
33037                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A using two's complement, i.e.
     **** ****     > EOI
0001 D4A0 0200  20        li   rtmp,(>FF*256)
     D4A2 FF00     
0002 D4A4 2B40  18        xor  rtmp,ra
                   < elite.a99
33038                      .adi (>01*256)                  ; ADC #1            ; set A = ~A + 1
     **** ****     > ADI
0001 D4A6 1701  14        jnc  !
0002 D4A8 B347  18        ab   rone,ra
0003               !:
0004 D4AA 022D  22        ai   ra,(>01*256)
     D4AC 0100     
                   < elite.a99
33039               
33040 D4AE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D4B0 FE34     
33041               
33042               * ******************************************************************************
33043               *
33044               * Name: LL51
33045               * Type: Subroutine
33046               * Category: Maths (Geometry)
33047               * Summary: Calculate the dot product of XX15 and XX16
33048               *
33049               * ------------------------------------------------------------------------------
33050               *
33051               * Calculate the following dot products:
33052               *
33053               * XX12(1 0) = XX15(5 0) . XX16(5 0)
33054               * XX12(3 2) = XX15(5 0) . XX16(11 6)
33055               * XX12(5 4) = XX15(5 0) . XX16(12 17)
33056               *
33057               * storing the results as sign-magnitude numbers in XX12 through XX12+5.
33058               *
33059               * When called from part 5 of LL9, XX12 contains the vector [x y z] to the ship
33060               * we're drawing, and XX16 contains the orientation vectors, so it returns:
33061               *
33062               * [ x ]   [ sidev_x ]         [ x ]   [ roofv_x ]         [ x ]   [ nosev_x ]
33063               * [ y ] . [ sidev_y ]         [ y ] . [ roofv_y ]         [ y ] . [ nosev_y ]
33064               * [ z ]   [ sidev_z ]         [ z ]   [ roofv_z ]         [ z ]   [ nosev_z ]
33065               *
33066               * When called from part 6 of LL9, XX12 contains the vector [x y z] of the vertex
33067               * we're analysing, and XX16 contains the transposed orientation vectors with
33068               * each of them containing the x, y and z elements of the original vectors, so it
33069               * ------------------------------------------------------------------------------
33070               *
33071               * Returns:
33072               *
33073               * [ x ]   [ sidev_x ]         [ x ]   [ sidev_y ]         [ x ]   [ sidev_z ]
33074               * [ y ] . [ roofv_x ]         [ y ] . [ roofv_y ]         [ y ] . [ roofv_z ]
33075               * [ z ]   [ nosev_x ]         [ z ]   [ nosev_y ]         [ z ]   [ nosev_z ]
33076               *
33077               * ------------------------------------------------------------------------------
33078               *
33079               * Arguments:
33080               *
33081               * XX15(1 0)           The ship (or vertex)'s x-coordinate as (x_sign x_lo)
33082               *
33083               * XX15(3 2)           The ship (or vertex)'s y-coordinate as (y_sign y_lo)
33084               *
33085               * XX15(5 4)           The ship (or vertex)'s z-coordinate as (z_sign z_lo)
33086               *
33087               * XX16 to XX16+5      The scaled sidev (or _x) vector, with:
33088               *
33089               * * x, y, z magnitudes in XX16, XX16+2, XX16+4
33090               *
33091               * * x, y, z signs in XX16+1, XX16+3, XX16+5
33092               *
33093               * XX16+6 to XX16+11   The scaled roofv (or _y) vector, with:
33094               *
33095               * * x, y, z magnitudes in XX16+6, XX16+8, XX16+10
33096               *
33097               * * x, y, z signs in XX16+7, XX16+9, XX16+11
33098               *
33099               * XX16+12 to XX16+17  The scaled nosev (or _z) vector, with:
33100               *
33101               * * x, y, z magnitudes in XX16+12, XX16+14, XX16+16
33102               *
33103               * * x, y, z signs in XX16+13, XX16+15, XX16+17
33104               *
33105               * ------------------------------------------------------------------------------
33106               *
33107               * Returns:
33108               *
33109               * XX12(1 0)           The dot product of [x y z] vector with the sidev (or _x)
33110               * vector, with the sign in XX12+1 and magnitude in XX12
33111               *
33112               * XX12(3 2)           The dot product of [x y z] vector with the roofv (or _y)
33113               * vector, with the sign in XX12+3 and magnitude in XX12+2
33114               *
33115               * XX12(5 4)           The dot product of [x y z] vector with the nosev (or _z)
33116               * vector, with the sign in XX12+5 and magnitude in XX12+4
33117               *
33118               * ******************************************************************************
33119               
33120               LL51:
33121 D4B2 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0, which will contain the offset of the vector
     D4B4 0000     
33122                                                                          ; to use in the calculation, increasing by 6 for each
33123                                                                          ; new vector
33124               
33125 D4B6 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0, which will contain the offset of the
     D4B8 0000     
33126                                                                          ; result bytes in XX12, increasing by 2 for each new
33127                                                                          ; result
33128               
33129               ll51_:
33130 D4BA D360  30        movb @XX15,ra                   ; LDA XX15          ; Set Q = x_lo
     D4BC 0031     
33131 D4BE D80D  30        movb ra,@Q                      ; STA Q
     D4C0 0090     
33132               
33133 D4C2 D36E  34        movb @XX16(rx),ra               ; LDA XX16,X        ; Set A = |sidev_x|
     D4C4 0009     
33134               
33135 D4C6 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     D4C8 43EC     
33136 D4CA 06A0  32        bl   @jsr                       ;
     D4CC FE28     
33137 D4CE D80D  30        movb ra,@T                      ; STA T             ; = |sidev_x| * x_lo / 256
     D4D0 00D1     
33138               
33139 D4D2 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set S to the sign of x_sign * sidev_x
     D4D4 0032     
33140                      .eor @XX16+1(rx)                ; EOR XX16+1,X
     **** ****     > EOR
0001 D4D6 D02E  34        movb @XX16+1(RX),rtmp
     D4D8 000A     
0002 D4DA 2B40  18        xor  rtmp,ra
                   < elite.a99
33141 D4DC D80D  30        movb ra,@S                      ; STA S
     D4DE 0092     
33142               
33143 D4E0 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set Q = y_lo
     D4E2 0033     
33144 D4E4 D80D  30        movb ra,@Q                      ; STA Q
     D4E6 0090     
33145               
33146 D4E8 D36E  34        movb @XX16+2(rx),ra             ; LDA XX16+2,X      ; Set A = |sidev_y|
     D4EA 000B     
33147               
33148 D4EC 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q / 256
     D4EE 43EC     
33149 D4F0 06A0  32        bl   @jsr                       ;
     D4F2 FE28     
33150 D4F4 D80D  30        movb ra,@Q                      ; STA Q             ; = |sidev_y| * y_lo / 256
     D4F6 0090     
33151               
33152 D4F8 D360  30        movb @T,ra                      ; LDA T             ; Set R = T
     D4FA 00D1     
33153 D4FC D80D  30        movb ra,@R                      ; STA R             ; = |sidev_x| * x_lo / 256
     D4FE 0091     
33154               
33155 D500 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set A to the sign of y_sign * sidev_y
     D502 0034     
33156                      .eor @XX16+3(rx)                ; EOR XX16+3,X
     **** ****     > EOR
0001 D504 D02E  34        movb @XX16+3(RX),rtmp
     D506 000C     
0002 D508 2B40  18        xor  rtmp,ra
                   < elite.a99
33157               
33158 D50A 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S T) = (S R) + (A Q)
     D50C D45A     
33159 D50E 06A0  32        bl   @jsr                       ;
     D510 FE28     
33160 D512 D80D  30        movb ra,@T                      ; STA T             ; = |sidev_x| * x_lo + |sidev_y| * y_lo
     D514 00D1     
33161               
33162 D516 D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set Q = z_lo
     D518 0035     
33163 D51A D80D  30        movb ra,@Q                      ; STA Q
     D51C 0090     
33164               
33165 D51E D36E  34        movb @XX16+4(rx),ra             ; LDA XX16+4,X      ; Set A = |sidev_z|
     D520 000D     
33166               
33167 D522 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q / 256
     D524 43EC     
33168 D526 06A0  32        bl   @jsr                       ;
     D528 FE28     
33169 D52A D80D  30        movb ra,@Q                      ; STA Q             ; = |sidev_z| * z_lo / 256
     D52C 0090     
33170               
33171 D52E D360  30        movb @T,ra                      ; LDA T             ; Set R = T
     D530 00D1     
33172 D532 D80D  30        movb ra,@R                      ; STA R             ; = |sidev_x| * x_lo + |sidev_y| * y_lo
     D534 0091     
33173               
33174 D536 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A to the sign of z_sign * sidev_z
     D538 0036     
33175                      .eor @XX16+5(rx)                ; EOR XX16+5,X
     **** ****     > EOR
0001 D53A D02E  34        movb @XX16+5(RX),rtmp
     D53C 000E     
0002 D53E 2B40  18        xor  rtmp,ra
                   < elite.a99
33176               
33177 D540 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     D542 D45A     
33178 D544 06A0  32        bl   @jsr                       ;
     D546 FE28     
33179                                                                          ; = |sidev_x| * x_lo + |sidev_y| * y_lo
33180                                                                          ; + |sidev_z| * z_lo
33181               
33182 D548 DBCD  38        movb ra,@XX12(ry)               ; STA XX12,Y        ; Store the result in XX12+Y(1 0)
     D54A 0037     
33183 D54C D360  30        movb @S,ra                      ; LDA S
     D54E 0092     
33184 D550 DBCD  38        movb ra,@XX12+1(ry)             ; STA XX12+1,Y
     D552 0038     
33185               
33186 D554 B3C7  18        ab   rone,ry                    ; INY               ; Set Y = Y + 2
33187 D556 B3C7  18        ab   rone,ry                    ; INY
33188               
33189 D558 D34E  18        movb rx,ra                      ; TXA               ; Set X = X + 6
33190                      .clc                            ; CLC
     **** ****     > CLC
0001 D55A 0A16  18        sla  rzero,1
                   < elite.a99
33191                      .adi (>06*256)                  ; ADC #6
     **** ****     > ADI
0001 D55C 1701  14        jnc  !
0002 D55E B347  18        ab   rone,ra
0003               !:
0004 D560 022D  22        ai   ra,(>06*256)
     D562 0600     
                   < elite.a99
33192 D564 D38D  18        movb ra,rx                      ; TAX
33193               
33194 D566 028D  22        ci   ra,>11*256                 ; CMP #17           ; If X < 17, loop back to ll51 for the next vector
     D568 1100     
33195 D56A 17A7  14        jnc  ll51_                      ; BCC ll51
33196               
33197 D56C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D56E FE34     
33198               
33199               * ******************************************************************************
33200               *
33201               * Name: LL9 (Part 1 of 12)
33202               * Type: Subroutine
33203               * Category: Drawing ships
33204               * Summary: Draw ship: Check if ship is exploding, check if ship is in front
33205               * Deep dive: Drawing ships
33206               *
33207               * ------------------------------------------------------------------------------
33208               *
33209               * This routine draws the current ship on the screen. This part checks to see if
33210               * the ship is exploding, or if it should start exploding, and if it does it sets
33211               * things up accordingly.
33212               *
33213               * It also does some basic checks to see if we can see the ship, and if not it
33214               * removes it from the screen.
33215               *
33216               * In this code, XX1 is used to point to the current ship's data block at INWK
33217               * (the two labels are interchangeable).
33218               *
33219               * ------------------------------------------------------------------------------
33220               *
33221               * Arguments:
33222               *
33223               * XX1                 XX1 shares its location with INWK, which contains the
33224               * zero-page copy of the data block for this ship from the
33225               * K% workspace
33226               *
33227               * INF                 The address of the data block for this ship in workspace
33228               * K%
33229               *
33230               * XX19(1 0)           XX19(1 0) shares its location with INWK(34 33), which
33231               * contains the ship line heap address pointer
33232               *
33233               * XX0                 The address of the blueprint for this ship
33234               *
33235               * ------------------------------------------------------------------------------
33236               *
33237               * Other entry points:
33238               *
33239               * EE51                Remove the current ship from the screen, called from
33240               * SHPPT before drawing the ship as a point
33241               *
33242               * ******************************************************************************
33243               
33244               LL25:
33245 D570 0460  28        b    @PLANET                    ; JMP PLANET        ; Jump to the PLANET routine, returning from the
     D572 B24E     
33246                                                                          ; subroutine using a tail call
33247               
33248               LL9:
33249 D574 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is negative then this indicates a
     D576 009B     
33250 D578 11FB  14        jlt  LL25                       ; BMI LL25          ; planet or sun, so jump to PLANET via LL25 above
33251               
33252 D57A 020D  20        li   ra,>1f*256                 ; LDA #31           ; Set XX4 = 31 to store the ship's distance for later
     D57C 1F00     
33253 D57E D80D  30        movb ra,@XX4                    ; STA XX4           ; comparison with the visibility distance. We will
     D580 00A7     
33254                                                                          ; update this value below with the actual ship's
33255                                                                          ; distance if it turns out to be visible on-screen
33256               
33257 D582 020D  20        li   ra,>20*256                 ; LDA #%00100000    ; If bit 5 of the ship's byte #31 is set, then the ship
     D584 2000     
33258                      .bit @XX1+31                    ; BIT XX1+31        ; is currently exploding, so jump down to EE28
     **** ****     > BIT
0001 D586 D020  30        movb @XX1+31,rtmp
     D588 0072     
0002 D58A 0540  14        inv  rtmp
0003 D58C D047  18        movb rone,rtmp2
0004 D58E 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
33259 D590 1657  14        jne  EE28                       ; BNE EE28
33260               
33261 D592 1556  14        jgt  EE28                       ; BPL EE28          ; If bit 7 of the ship's byte #31 is clear then the ship
33262                                                                          ; has not just been killed, so jump down to EE28
33263               
33264                                                                          ; Otherwise bit 5 is clear and bit 7 is set, so the ship
33265                                                                          ; is not yet exploding but it has been killed, so we
33266                                                                          ; need to start an explosion
33267               
33268 D594 F360  30        socb @XX1+31,ra                 ; ORA XX1+31        ; Clear bits 6 and 7 of the ship's byte #31, to stop the
     D596 0072     
33269 D598 024D  22        andi ra,>3f*256                 ; AND #%00111111    ; ship from firing its laser and to mark it as no longer
     D59A 3F00     
33270 D59C D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; having just been killed
     D59E 0072     
33271               
33272 D5A0 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the ship's acceleration in byte #31 to 0, updating
     D5A2 0000     
33273 D5A4 020F  20        li   ry,>1c*256                 ; LDY #28           ; the byte in the workspace K% data block so we don't
     D5A6 1C00     
33274                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; have to copy it back from INWK later
     **** ****     > ST_IND_Y_IDX
0001 D5A8 D820  42        movb @INF,@rtmplb
     D5AA 0020     
     D5AC 8301     
0002 D5AE D020  30        movb @INF+1,rtmp
     D5B0 0021     
0003 D5B2 06CF  14        swpb ry
0004 D5B4 A00F  18        a    ry,rtmp
0005 D5B6 06CF  14        swpb ry
0006 D5B8 D40D  30        movb RA,*rtmp
                   < elite.a99
33275               
33276 D5BA 020F  20        li   ry,>1e*256                 ; LDY #30           ; Set the ship's pitch counter in byte #30 to 0, to stop
     D5BC 1E00     
33277                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; the ship from pitching
     **** ****     > ST_IND_Y_IDX
0001 D5BE D820  42        movb @INF,@rtmplb
     D5C0 0020     
     D5C2 8301     
0002 D5C4 D020  30        movb @INF+1,rtmp
     D5C6 0021     
0003 D5C8 06CF  14        swpb ry
0004 D5CA A00F  18        a    ry,rtmp
0005 D5CC 06CF  14        swpb ry
0006 D5CE D40D  30        movb RA,*rtmp
                   < elite.a99
33278               
33279 D5D0 0200  20        li   rtmp,EE51                  ; JSR EE51          ; Call EE51 to remove the ship from the screen
     D5D2 D660     
33280 D5D4 06A0  32        bl   @jsr                       ;
     D5D6 FE28     
33281               
33282                                                                          ; We now need to set up a new explosion cloud. We
33283                                                                          ; initialise it with a size of 18 (which gets increased
33284                                                                          ; by 4 every time the cloud gets redrawn), and the
33285                                                                          ; explosion count (i.e. the number of particles in the
33286                                                                          ; explosion), which go into bytes 1 and 2 of the ship
33287                                                                          ; line heap. See DOEXP for more details of explosion
33288                                                                          ; clouds
33289               
33290 D5D8 020F  20        li   ry,>01*256                 ; LDY #1            ; Set byte #1 of the ship line heap to 18, the initial
     D5DA 0100     
33291 D5DC 020D  20        li   ra,>12*256                 ; LDA #18           ; size of the explosion cloud
     D5DE 1200     
33292                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 D5E0 D820  42        movb @XX19,@rtmplb
     D5E2 0074     
     D5E4 8301     
0002 D5E6 D020  30        movb @XX19+1,rtmp
     D5E8 0075     
0003 D5EA 06CF  14        swpb ry
0004 D5EC A00F  18        a    ry,rtmp
0005 D5EE 06CF  14        swpb ry
0006 D5F0 D40D  30        movb RA,*rtmp
                   < elite.a99
33293               
33294 D5F2 020F  20        li   ry,>07*256                 ; LDY #7            ; Fetch byte #7 from the ship's blueprint, which
     D5F4 0700     
33295                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; determines the explosion count (i.e. the number of
     **** ****     > LD_IND_Y_IDX
0001 D5F6 D820  42        movb @XX0,@rtmplb
     D5F8 001E     
     D5FA 8301     
0002 D5FC D020  30        movb @XX0+1,rtmp
     D5FE 001F     
0003 D600 06CF  14        swpb ry
0004 D602 A00F  18        a    ry,rtmp
0005 D604 06CF  14        swpb ry
0006 D606 D350  26        movb *rtmp,RA
                   < elite.a99
33296 D608 020F  20        li   ry,>02*256                 ; LDY #2            ; vertices used as origins for explosion clouds), and
     D60A 0200     
33297                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; store it in byte #2 of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 D60C D820  42        movb @XX19,@rtmplb
     D60E 0074     
     D610 8301     
0002 D612 D020  30        movb @XX19+1,rtmp
     D614 0075     
0003 D616 06CF  14        swpb ry
0004 D618 A00F  18        a    ry,rtmp
0005 D61A 06CF  14        swpb ry
0006 D61C D40D  30        movb RA,*rtmp
                   < elite.a99
33298               
33299               * LDA XX1+32             \ These instructions are commented out in the original
33300               * AND #&7F               \ source
33301               
33302                                                                          ; The following loop sets bytes 3-6 of the of the ship
33303                                                                          ; line heap to random numbers
33304               
33305               EE55:
33306 D61E B3C7  18        ab   rone,ry                    ; INY               ; Increment Y (so the loop starts at 3)
33307               
33308 D620 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     D622 C120     
33309 D624 06A0  32        bl   @jsr                       ;
     D626 FE28     
33310               
33311                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store A in the Y-th byte of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 D628 D820  42        movb @XX19,@rtmplb
     D62A 0074     
     D62C 8301     
0002 D62E D020  30        movb @XX19+1,rtmp
     D630 0075     
0003 D632 06CF  14        swpb ry
0004 D634 A00F  18        a    ry,rtmp
0005 D636 06CF  14        swpb ry
0006 D638 D40D  30        movb RA,*rtmp
                   < elite.a99
33312               
33313 D63A 028F  22        ci   ry,>06*256                 ; CPY #6            ; Loop back until we have randomised the 6th byte
     D63C 0600     
33314 D63E 16EF  14        jne  EE55                       ; BNE EE55
33315               
33316               EE28:
33317 D640 D360  30        movb @XX1+8,ra                  ; LDA XX1+8         ; Set A = z_sign
     D642 005B     
33318               
33319               EE49:
33320 D644 151E  14        jgt  LL10                       ; BPL LL10          ; If A is positive, i.e. the ship is in front of us,
33321                                                                          ; jump down to LL10
33322               
33323               LL14:
33324                                                                          ; The following removes the ship from the screen by
33325                                                                          ; redrawing it (or, if it is exploding, by redrawing the
33326                                                                          ; explosion cloud). We call it when the ship is no
33327                                                                          ; longer on-screen, is too far away to be fully drawn,
33328                                                                          ; and so on
33329 D646 D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     D648 0072     
33330 D64A 024D  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE51
     D64C 2000     
33331 D64E 1308  14        jeq  EE51                       ; BEQ EE51          ; to redraw its wireframe
33332               
33333 D650 D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; The ship is exploding, so clear bit 3 of the ship's
     D652 0072     
33334 D654 024D  22        andi ra,>f7*256                 ; AND #%11110111    ; byte #31 to denote that the ship is no longer being
     D656 F700     
33335 D658 D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; drawn on-screen
     D65A 0072     
33336               
33337 D65C 0460  28        b    @DOEXP                     ; JMP DOEXP         ; Jump to DOEXP to display the explosion cloud, which
     D65E A8AC     
33338                                                                          ; will remove it from the screen, returning from the
33339                                                                          ; subroutine using a tail call
33340               
33341               EE51:
33342 D660 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; If bit 3 of the ship's byte #31 is clear, then there
     D662 0800     
33343                      .bit @XX1+31                    ; BIT XX1+31        ; is already nothing being shown for this ship, so
     **** ****     > BIT
0001 D664 D020  30        movb @XX1+31,rtmp
     D666 0072     
0002 D668 0540  14        inv  rtmp
0003 D66A D047  18        movb rone,rtmp2
0004 D66C 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
33344 D66E 1308  14        jeq  LL10-1                     ; BEQ LL10-1        ; return from the subroutine (as LL10-1 contains an RTS)
33345               
33346                      .eor @XX1+31                    ; EOR XX1+31        ; Otherwise flip bit 3 of byte #31 and store it (which
     **** ****     > EOR
0001 D670 D020  30        movb @XX1+31,rtmp
     D672 0072     
0002 D674 2B40  18        xor  rtmp,ra
                   < elite.a99
33347 D676 D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; clears bit 3 as we know it was set before the EOR), so
     D678 0072     
33348                                                                          ; this sets this ship as no longer being drawn on-screen
33349               
33350 D67A 0460  28        b    @LL155                     ; JMP LL155         ; Jump to LL155 to draw the ship, which removes it from
     D67C E3C4     
33351                                                                          ; the screen, returning from the subroutine using a
33352                                                                          ; tail call
33353               
33354               * .LL24                  \ This label is commented out in the original source,
33355                                                                          ; and was presumably used to label the RTS which is
33356                                                                          ; actually called by LL10-1 above, not LL24
33357               
33358 D67E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D680 FE34     
33359               
33360               * ******************************************************************************
33361               *
33362               * Name: LL9 (Part 2 of 12)
33363               * Type: Subroutine
33364               * Category: Drawing ships
33365               * Summary: Draw ship: Check if ship is in field of view, close enough to draw
33366               * Deep dive: Drawing ships
33367               *
33368               * ------------------------------------------------------------------------------
33369               *
33370               * This part checks whether the ship is in our field of view, and whether it is
33371               * close enough to be fully drawn (if not, we jump to SHPPT to draw it as a dot).
33372               *
33373               * ------------------------------------------------------------------------------
33374               *
33375               * Other entry points:
33376               *
33377               * LL10-1              Contains an RTS
33378               *
33379               * ******************************************************************************
33380               
33381               LL10:
33382 D682 D360  30        movb @XX1+7,ra                  ; LDA XX1+7         ; Set A = z_hi
     D684 005A     
33383               
33384 D686 028D  22        ci   ra,>c0*256                 ; CMP #192          ; If A >= 192 then the ship is a long way away, so jump
     D688 C000     
33385 D68A 18DD  14        joc  LL14                       ; BCS LL14          ; to LL14 to remove the ship from the screen
33386               
33387 D68C D360  30        movb @XX1,ra                    ; LDA XX1           ; If x_lo >= z_lo, set the C flag, otherwise clear it
     D68E 0053     
33388 D690 9360  30        cb   @XX1+6,ra                  ; CMP XX1+6
     D692 0059     
33389               
33390 D694 D360  30        movb @XX1+1,ra                  ; LDA XX1+1         ; Set A = x_hi - z_hi using the carry from the low
     D696 0054     
33391                      .sbc @XX1+7,ra                  ; SBC XX1+7         ; bytes, which sets the C flag as if we had done a full
     **** ****     > SBC
0001 D698 1801  14        joc  !
0002 D69A 7347  18        sb   rone,ra
0003               !:
0004 D69C 7360  30        sb   @XX1+7,ra
     D69E 005A     
                   < elite.a99
33392                                                                          ; two-byte subtraction (x_hi x_lo) - (z_hi z_lo)
33393               
33394 D6A0 18D2  14        joc  LL14                       ; BCS LL14          ; If the C flag is set then x >= z, so the ship is
33395                                                                          ; further to the side than it is in front of us, so it's
33396                                                                          ; outside our viewing angle of 45 degrees, and we jump
33397                                                                          ; to LL14 to remove it from the screen
33398               
33399 D6A2 D360  30        movb @XX1+3,ra                  ; LDA XX1+3         ; If y_lo >= z_lo, set the C flag, otherwise clear it
     D6A4 0056     
33400 D6A6 9360  30        cb   @XX1+6,ra                  ; CMP XX1+6
     D6A8 0059     
33401               
33402 D6AA D360  30        movb @XX1+4,ra                  ; LDA XX1+4         ; Set A = y_hi - z_hi using the carry from the low
     D6AC 0057     
33403                      .sbc @XX1+7,ra                  ; SBC XX1+7         ; bytes, which sets the C flag as if we had done a full
     **** ****     > SBC
0001 D6AE 1801  14        joc  !
0002 D6B0 7347  18        sb   rone,ra
0003               !:
0004 D6B2 7360  30        sb   @XX1+7,ra
     D6B4 005A     
                   < elite.a99
33404                                                                          ; two-byte subtraction (y_hi y_lo) - (z_hi z_lo)
33405               
33406 D6B6 18C7  14        joc  LL14                       ; BCS LL14          ; If the C flag is set then y >= z, so the ship is
33407                                                                          ; further above us than it is in front of us, so it's
33408                                                                          ; outside our viewing angle of 45 degrees, and we jump
33409                                                                          ; to LL14 to remove it from the screen
33410               
33411 D6B8 020F  20        li   ry,>06*256                 ; LDY #6            ; Fetch byte #6 from the ship's blueprint into X, which
     D6BA 0600     
33412                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; is the number * 4 of the vertex used for the ship's
     **** ****     > LD_IND_Y_IDX
0001 D6BC D820  42        movb @XX0,@rtmplb
     D6BE 001E     
     D6C0 8301     
0002 D6C2 D020  30        movb @XX0+1,rtmp
     D6C4 001F     
0003 D6C6 06CF  14        swpb ry
0004 D6C8 A00F  18        a    ry,rtmp
0005 D6CA 06CF  14        swpb ry
0006 D6CC D350  26        movb *rtmp,RA
                   < elite.a99
33413 D6CE D38D  18        movb ra,rx                      ; TAX               ; laser
33414               
33415 D6D0 020D  20        li   ra,>ff*256                 ; LDA #255          ; Set bytes X and X+1 of the XX3 heap to 255. We're
     D6D2 FF00     
33416 D6D4 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; going to use XX3 to store the screen coordinates of
     D6D6 0100     
33417 D6D8 DB8D  38        movb ra,@XX3+1(rx)              ; STA XX3+1,X       ; all the visible vertices of this ship, so setting the
     D6DA 0101     
33418                                                                          ; laser vertex to 255 means that if we don't update this
33419                                                                          ; vertex with its screen coordinates in parts 6 and 7,
33420                                                                          ; this vertex's entry in the XX3 heap will still be 255,
33421                                                                          ; which we can check in part 9 to see if the laser
33422                                                                          ; vertex is visible (and therefore whether we should
33423                                                                          ; draw laser lines if the ship is firing on us)
33424               
33425 D6DC D360  30        movb @XX1+6,ra                  ; LDA XX1+6         ; Set (A T) = (z_hi z_lo)
     D6DE 0059     
33426 D6E0 D80D  30        movb ra,@T                      ; STA T
     D6E2 00D1     
33427 D6E4 D360  30        movb @XX1+7,ra                  ; LDA XX1+7
     D6E6 005A     
33428               
33429 D6E8 091D  18        srl  ra,1                       ; LSR A             ; Set (A T) = (A T) / 8
33430 D6EA 0204  20        li   rarg1,T                    ; ROR T
     D6EC 00D1     
33431 D6EE 06A0  32        bl   @ror                       ;
     D6F0 FE7A     
33432 D6F2 091D  18        srl  ra,1                       ; LSR A
33433 D6F4 0204  20        li   rarg1,T                    ; ROR T
     D6F6 00D1     
33434 D6F8 06A0  32        bl   @ror                       ;
     D6FA FE7A     
33435 D6FC 091D  18        srl  ra,1                       ; LSR A
33436 D6FE 0204  20        li   rarg1,T                    ; ROR T
     D700 00D1     
33437 D702 06A0  32        bl   @ror                       ;
     D704 FE7A     
33438               
33439 D706 091D  18        srl  ra,1                       ; LSR A             ; If A >> 4 is non-zero, i.e. z_hi >= 16, jump to LL13
33440 D708 160A  14        jne  LL13                       ; BNE LL13          ; as the ship is possibly far away enough to be shown as
33441                                                                          ; a dot
33442               
33443 D70A D360  30        movb @T,ra                      ; LDA T             ; Otherwise the C flag contains the previous bit 0 of A,
     D70C 00D1     
33444 D70E 06A0  32        bl   @rora                      ; ROR A             ; which could have been set, so rotate A right four
     D710 FE62     
33445 D712 091D  18        srl  ra,1                       ; LSR A             ; times so it's in the form %000xxxxx, i.e. z_hi reduced
33446 D714 091D  18        srl  ra,1                       ; LSR A             ; to a maximum value of 31
33447 D716 091D  18        srl  ra,1                       ; LSR A
33448               
33449 D718 D80D  30        movb ra,@XX4                    ; STA XX4           ; Store A in XX4, which is now the distance of the ship
     D71A 00A7     
33450                                                                          ; we can use for visibility testing
33451               
33452 D71C 1517  14        jgt  LL17                       ; BPL LL17          ; Jump down to LL17 (this BPL is effectively a JMP as we
33453                                                                          ; know bit 7 of A is definitely clear)
33454               
33455               LL13:
33456                                                                          ; If we get here then the ship is possibly far enough
33457                                                                          ; away to be shown as a dot
33458 D71E 020F  20        li   ry,>0d*256                 ; LDY #13           ; Fetch byte #13 from the ship's blueprint, which gives
     D720 0D00     
33459                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the ship's visibility distance, beyond which we show
     **** ****     > LD_IND_Y_IDX
0001 D722 D820  42        movb @XX0,@rtmplb
     D724 001E     
     D726 8301     
0002 D728 D020  30        movb @XX0+1,rtmp
     D72A 001F     
0003 D72C 06CF  14        swpb ry
0004 D72E A00F  18        a    ry,rtmp
0005 D730 06CF  14        swpb ry
0006 D732 D350  26        movb *rtmp,RA
                   < elite.a99
33460                                                                          ; the ship as a dot
33461               
33462 D734 9360  30        cb   @XX1+7,ra                  ; CMP XX1+7         ; If z_hi <= the visibility distance, skip to LL17 to
     D736 005A     
33463 D738 1809  14        joc  LL17                       ; BCS LL17          ; draw the ship fully, rather than as a dot, as it is
33464                                                                          ; closer than the visibility distance
33465               
33466 D73A 020D  20        li   ra,>20*256                 ; LDA #%00100000    ; If bit 5 of the ship's byte #31 is set, then the
     D73C 2000     
33467                      .and @XX1+31                    ; AND XX1+31        ; ship is currently exploding, so skip to LL17 to draw
     **** ****     > AND
0001 D73E D020  30        movb @XX1+31,rtmp
     D740 0072     
0002 D742 0540  14        inv  rtmp
0003 D744 5340  18        szcb rtmp,ra
                   < elite.a99
33468 D746 1602  14        jne  LL17                       ; BNE LL17          ; the ship's explosion cloud
33469               
33470 D748 0460  28        b    @SHPPT                     ; JMP SHPPT         ; Otherwise jump to SHPPT to draw the ship as a dot,
     D74A D29E     
33471                                                                          ; returning from the subroutine using a tail call
33472               
33473               * ******************************************************************************
33474               *
33475               * Name: LL9 (Part 3 of 12)
33476               * Type: Subroutine
33477               * Category: Drawing ships
33478               * Summary: Draw ship: Set up orientation vector, ship coordinate variables
33479               * Deep dive: Drawing ships
33480               *
33481               * ------------------------------------------------------------------------------
33482               *
33483               * This part sets up the following variable blocks:
33484               *
33485               * * XX16 contains the orientation vectors, divided to normalise them
33486               *
33487               * * XX18 contains the ship's x, y and z coordinates in space
33488               *
33489               * ******************************************************************************
33490               
33491               LL17:
33492 D74C 020E  20        li   rx,>05*256                 ; LDX #5            ; First we copy the three orientation vectors into XX16,
     D74E 0500     
33493                                                                          ; so set up a counter in X for the 6 bytes in each
33494                                                                          ; vector
33495               
33496               LL15:
33497 D750 D36E  34        movb @XX1+21(rx),ra             ; LDA XX1+21,X      ; Copy the X-th byte of sidev to the X-th byte of XX16
     D752 0068     
33498 D754 DB8D  38        movb ra,@XX16(rx)               ; STA XX16,X
     D756 0009     
33499               
33500 D758 D36E  34        movb @XX1+15(rx),ra             ; LDA XX1+15,X      ; Copy the X-th byte of roofv to XX16+6 to the X-th byte
     D75A 0062     
33501 D75C DB8D  38        movb ra,@XX16+6(rx)             ; STA XX16+6,X      ; of XX16+6
     D75E 000F     
33502               
33503 D760 D36E  34        movb @XX1+9(rx),ra              ; LDA XX1+9,X       ; Copy the X-th byte of nosev to XX16+12 to the X-th
     D762 005C     
33504 D764 DB8D  38        movb ra,@XX16+12(rx)            ; STA XX16+12,X     ; byte of XX16+12
     D766 0015     
33505               
33506 D768 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
33507               
33508 D76A 15F2  14        jgt  LL15                       ; BPL LL15          ; Loop back to copy the next byte of each vector, until
33509                                                                          ; we have the following:
33510                                                                          ;
33511                                                                          ; * XX16(1 0) = sidev_x
33512                                                                          ; * XX16(3 2) = sidev_y
33513                                                                          ; * XX16(5 4) = sidev_z
33514                                                                          ;
33515                                                                          ; * XX16(7 6) = roofv_x
33516                                                                          ; * XX16(9 8) = roofv_y
33517                                                                          ; * XX16(11 10) = roofv_z
33518                                                                          ;
33519                                                                          ; * XX16(13 12) = nosev_x
33520                                                                          ; * XX16(15 14) = nosev_y
33521                                                                          ; * XX16(17 16) = nosev_z
33522               
33523 D76C 020D  20        li   ra,>c5*256                 ; LDA #197          ; Set Q = 197
     D76E C500     
33524 D770 D80D  30        movb ra,@Q                      ; STA Q
     D772 0090     
33525               
33526 D774 020F  20        li   ry,>10*256                 ; LDY #16           ; Set Y to be a counter that counts down by 2 each time,
     D776 1000     
33527                                                                          ; starting with 16, then 14, 12 and so on. We use this
33528                                                                          ; to work through each of the coordinates in each of the
33529                                                                          ; orientation vectors
33530               
33531               LL21:
33532 D778 D36F  34        movb @XX16(ry),ra               ; LDA XX16,Y        ; Set A = the low byte of the vector coordinate, e.g.
     D77A 0009     
33533                                                                          ; nosev_z_lo when Y = 16
33534               
33535                      .asla                           ; ASL A             ; Shift bit 7 into the C flag
     **** ****     > ASLA
0001 D77C 024D  22        andi ra,>ff00
     D77E FF00     
0002 D780 0A1D  18        sla  ra,1
                   < elite.a99
33536               
33537 D782 D36F  34        movb @XX16+1(ry),ra             ; LDA XX16+1,Y      ; Set A = the high byte of the vector coordinate, e.g.
     D784 000A     
33538                                                                          ; nosev_z_hi when Y = 16
33539               
33540 D786 06A0  32        bl   @rola                      ; ROL A             ; Rotate A left, incorporating the C flag, so A now
     D788 FE3E     
33541                                                                          ; contains the original high byte, doubled, and without
33542                                                                          ; a sign bit, e.g. A = |nosev_z_hi| * 2
33543               
33544 D78A 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     D78C D404     
33545 D78E 06A0  32        bl   @jsr                       ;
     D790 FE28     
33546                                                                          ;
33547                                                                          ; R = 256 * A / Q
33548                                                                          ;
33549                                                                          ; so, for nosev, this would be:
33550                                                                          ;
33551                                                                          ; R = 256 * |nosev_z_hi| * 2 / 197
33552                                                                          ; = 2.6 * |nosev_z_hi|
33553               
33554 D792 D3A0  30        movb @R,rx                      ; LDX R             ; Store R in the low byte's location, so we can keep the
     D794 0091     
33555 D796 DBCE  38        movb rx,@XX16(ry)               ; STX XX16,Y        ; old, unscaled high byte intact for the sign
     D798 0009     
33556               
33557 D79A 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter twice
33558 D79C 73C7  18        sb   rone,ry                    ; DEY
33559               
33560 D79E 15EC  14        jgt  LL21                       ; BPL LL21          ; Loop back for the next vector coordinate until we have
33561                                                                          ; divided them all
33562               
33563                                                                          ; By this point, the vectors have been turned into
33564                                                                          ; scaled magnitudes, so we have the following:
33565                                                                          ;
33566                                                                          ; * XX16   = scaled |sidev_x|
33567                                                                          ; * XX16+2 = scaled |sidev_y|
33568                                                                          ; * XX16+4 = scaled |sidev_z|
33569                                                                          ;
33570                                                                          ; * XX16+6  = scaled |roofv_x|
33571                                                                          ; * XX16+8  = scaled |roofv_y|
33572                                                                          ; * XX16+10 = scaled |roofv_z|
33573                                                                          ;
33574                                                                          ; * XX16+12 = scaled |nosev_x|
33575                                                                          ; * XX16+14 = scaled |nosev_y|
33576                                                                          ; * XX16+16 = scaled |nosev_z|
33577               
33578 D7A0 020E  20        li   rx,>08*256                 ; LDX #8            ; Next we copy the ship's coordinates into XX18, so set
     D7A2 0800     
33579                                                                          ; up a counter in X for 9 bytes
33580               
33581               ll91_:
33582 D7A4 D36E  34        movb @XX1(rx),ra                ; LDA XX1,X         ; Copy the X-th byte from XX1 to XX18
     D7A6 0053     
33583 D7A8 DB8D  38        movb ra,@XX18(rx)               ; STA XX18,X
     D7AA 007E     
33584               
33585 D7AC 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
33586               
33587 D7AE 15FA  14        jgt  ll91_                      ; BPL ll91          ; Loop back for the next byte until we have copied all
33588                                                                          ; three coordinates
33589               
33590                                                                          ; So we now have the following:
33591                                                                          ;
33592                                                                          ; * XX18(2 1 0) = (x_sign x_hi x_lo)
33593                                                                          ;
33594                                                                          ; * XX18(5 4 3) = (y_sign y_hi y_lo)
33595                                                                          ;
33596                                                                          ; * XX18(8 7 6) = (z_sign z_hi z_lo)
33597               
33598 D7B0 020D  20        li   ra,>ff*256                 ; LDA #255          ; Set the 15th byte of XX2 to 255, so that face 15 is
     D7B2 FF00     
33599 D7B4 D80D  30        movb ra,@XX2+15                 ; STA XX2+15        ; always visible. No ship definitions actually have this
     D7B6 00E1     
33600                                                                          ; number of faces, but this allows us to force a vertex
33601                                                                          ; to always be visible by associating it with face 15
33602                                                                          ; (see the ship blueprints for the Cobra Mk III at
33603                                                                          ; SHIP_COBRA_MK_3 and the asteroid at SHIP_ASTEROID for
33604                                                                          ; examples of vertices that are associated with face 15)
33605               
33606 D7B8 020F  20        li   ry,>0c*256                 ; LDY #12           ; Set Y = 12 to point to the ship blueprint byte #12,
     D7BA 0C00     
33607               
33608 D7BC D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     D7BE 0072     
33609 D7C0 024D  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE29
     D7C2 2000     
33610 D7C4 1317  14        jeq  EE29                       ; BEQ EE29          ; to skip the following
33611               
33612                                                                          ; Otherwise we fall through to set up the visibility
33613                                                                          ; block for an exploding ship
33614               
33615               * ******************************************************************************
33616               *
33617               * Name: LL9 (Part 4 of 12)
33618               * Type: Subroutine
33619               * Category: Drawing ships
33620               * Summary: Draw ship: Set visibility for exploding ship (all faces visible)
33621               * Deep dive: Drawing ships
33622               *
33623               * ------------------------------------------------------------------------------
33624               *
33625               * This part sets up the visibility block in XX2 for a ship that is exploding.
33626               *
33627               * The XX2 block consists of one byte for each face in the ship's blueprint,
33628               * which holds the visibility of that face. Because the ship is exploding, we
33629               * want to set all the faces to be visible. A value of 255 in the visibility
33630               * table means the face is visible, so the following code sets each face to 255
33631               * and then skips over the face visibility calculations that we would apply to a
33632               * non-exploding ship.
33633               *
33634               * ******************************************************************************
33635               
33636                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; Fetch byte #12 of the ship's blueprint, which contains
     **** ****     > LD_IND_Y_IDX
0001 D7C6 D820  42        movb @XX0,@rtmplb
     D7C8 001E     
     D7CA 8301     
0002 D7CC D020  30        movb @XX0+1,rtmp
     D7CE 001F     
0003 D7D0 06CF  14        swpb ry
0004 D7D2 A00F  18        a    ry,rtmp
0005 D7D4 06CF  14        swpb ry
0006 D7D6 D350  26        movb *rtmp,RA
                   < elite.a99
33637                                                                          ; the number of faces * 4
33638               
33639 D7D8 091D  18        srl  ra,1                       ; LSR A             ; Set X = A / 4
33640 D7DA 091D  18        srl  ra,1                       ; LSR A             ; = the number of faces
33641 D7DC D38D  18        movb ra,rx                      ; TAX
33642               
33643 D7DE 020D  20        li   ra,>ff*256                 ; LDA #255          ; Set A = 255
     D7E0 FF00     
33644               
33645               EE30:
33646 D7E2 DB8D  38        movb ra,@XX2(rx)                ; STA XX2,X         ; Set the X-th byte of XX2 to 255
     D7E4 00D2     
33647               
33648 D7E6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
33649               
33650 D7E8 15FC  14        jgt  EE30                       ; BPL EE30          ; Loop back for the next byte until there is one byte
33651                                                                          ; set to 255 for each face
33652               
33653 D7EA B387  18        ab   rone,rx                    ; INX               ; Set XX4 = 0 for the distance value we use to test
33654 D7EC D80E  30        movb rx,@XX4                    ; STX XX4           ; for visibility, so we always shows everything
     D7EE 00A7     
33655               
33656               LL41:
33657 D7F0 0460  28        b    @LL42                      ; JMP LL42          ; Jump to LL42 to skip the face visibility calculations
     D7F2 DB98     
33658                                                                          ; as we don't need to do them now we've set up the XX2
33659                                                                          ; block for the explosion
33660               
33661               * ******************************************************************************
33662               *
33663               * Name: LL9 (Part 5 of 12)
33664               * Type: Subroutine
33665               * Category: Drawing ships
33666               * Summary: Draw ship: Calculate the visibility of each of the ship's faces
33667               * Deep dive: Drawing ships
33668               * Back-face culling
33669               *
33670               * ******************************************************************************
33671               
33672               EE29:
33673                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; We set Y to 12 above before jumping down to EE29, so
     **** ****     > LD_IND_Y_IDX
0001 D7F4 D820  42        movb @XX0,@rtmplb
     D7F6 001E     
     D7F8 8301     
0002 D7FA D020  30        movb @XX0+1,rtmp
     D7FC 001F     
0003 D7FE 06CF  14        swpb ry
0004 D800 A00F  18        a    ry,rtmp
0005 D802 06CF  14        swpb ry
0006 D804 D350  26        movb *rtmp,RA
                   < elite.a99
33674                                                                          ; this fetches byte #12 of the ship's blueprint, which
33675                                                                          ; contains the number of faces * 4
33676               
33677 D806 13F4  14        jeq  LL41                       ; BEQ LL41          ; If there are no faces in this ship, jump to LL42 (via
33678                                                                          ; LL41) to skip the face visibility calculations
33679               
33680 D808 D80D  30        movb ra,@XX20                   ; STA XX20          ; Set A = the number of faces * 4
     D80A 00A8     
33681               
33682 D80C 020F  20        li   ry,>12*256                 ; LDY #18           ; Fetch byte #18 of the ship's blueprint, which contains
     D80E 1200     
33683                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the factor by which we scale the face normals, into X
     **** ****     > LD_IND_Y_IDX
0001 D810 D820  42        movb @XX0,@rtmplb
     D812 001E     
     D814 8301     
0002 D816 D020  30        movb @XX0+1,rtmp
     D818 001F     
0003 D81A 06CF  14        swpb ry
0004 D81C A00F  18        a    ry,rtmp
0005 D81E 06CF  14        swpb ry
0006 D820 D350  26        movb *rtmp,RA
                   < elite.a99
33684 D822 D38D  18        movb ra,rx                      ; TAX
33685               
33686 D824 D360  30        movb @XX18+7,ra                 ; LDA XX18+7        ; Set A = z_hi
     D826 0085     
33687               
33688               LL90:
33689 D828 D3CD  18        movb ra,ry                      ; TAY               ; Set Y = z_hi
33690               
33691 D82A 131A  14        jeq  LL91                       ; BEQ LL91          ; If z_hi = 0 then jump to LL91
33692               
33693                                                                          ; The following is a loop that jumps back to LL90+3,
33694                                                                          ; i.e. here. LL90 is only used for this loop, so it's a
33695                                                                          ; bit of a strange use of the label here
33696               
33697 D82C B387  18        ab   rone,rx                    ; INX               ; Increment the scale factor in X
33698               
33699                      .lsr @XX18+4                    ; LSR XX18+4        ; Divide (y_hi y_lo) by 2
     **** ****     > LSR
0001 D82E D020  30        movb @XX18+4,rtmp
     D830 0082     
0002 D832 0910  18        srl  rtmp,1
0003 D834 D800  30        movb rtmp,@XX18+4
     D836 0082     
                   < elite.a99
33700 D838 0204  20        li   rarg1,XX18+3               ; ROR XX18+3
     D83A 0081     
33701 D83C 06A0  32        bl   @ror                       ;
     D83E FE7A     
33702               
33703                      .lsr @XX18+1                    ; LSR XX18+1        ; Divide (x_hi x_lo) by 2
     **** ****     > LSR
0001 D840 D020  30        movb @XX18+1,rtmp
     D842 007F     
0002 D844 0910  18        srl  rtmp,1
0003 D846 D800  30        movb rtmp,@XX18+1
     D848 007F     
                   < elite.a99
33704 D84A 0204  20        li   rarg1,XX18                 ; ROR XX18
     D84C 007E     
33705 D84E 06A0  32        bl   @ror                       ;
     D850 FE7A     
33706               
33707 D852 091D  18        srl  ra,1                       ; LSR A             ; Divide (z_hi z_lo) by 2 (as A contains z_hi)
33708 D854 0204  20        li   rarg1,XX18+6               ; ROR XX18+6
     D856 0084     
33709 D858 06A0  32        bl   @ror                       ;
     D85A FE7A     
33710               
33711 D85C D3CD  18        movb ra,ry                      ; TAY               ; Set Y = z_hi
33712               
33713 D85E 16E5  14        jne  LL90+3                     ; BNE LL90+3        ; If Y is non-zero, loop back to LL90+3 to divide the
33714                                                                          ; three coordinates until z_hi is 0
33715               
33716               LL91:
33717                                                                          ; By this point z_hi is 0 and X contains the number of
33718                                                                          ; right shifts we had to do, plus the scale factor from
33719                                                                          ; the blueprint
33720 D860 D80E  30        movb rx,@XX17                   ; STX XX17          ; Store the updated scale factor in XX17
     D862 0095     
33721               
33722 D864 D360  30        movb @XX18+8,ra                 ; LDA XX18+8        ; Set XX15+5 = z_sign
     D866 0086     
33723 D868 D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     D86A 0036     
33724               
33725 D86C D360  30        movb @XX18,ra                   ; LDA XX18          ; Set XX15(1 0) = (x_sign x_lo)
     D86E 007E     
33726 D870 D80D  30        movb ra,@XX15                   ; STA XX15
     D872 0031     
33727 D874 D360  30        movb @XX18+2,ra                 ; LDA XX18+2
     D876 0080     
33728 D878 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     D87A 0032     
33729               
33730 D87C D360  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set XX15(3 2) = (y_sign y_lo)
     D87E 0081     
33731 D880 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     D882 0033     
33732 D884 D360  30        movb @XX18+5,ra                 ; LDA XX18+5
     D886 0083     
33733 D888 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     D88A 0034     
33734               
33735 D88C D360  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set XX15+4 = z_lo, so now XX15(5 4) = (z_sign z_lo)
     D88E 0084     
33736 D890 D80D  30        movb ra,@XX15+4                 ; STA XX15+4
     D892 0035     
33737               
33738 D894 0200  20        li   rtmp,LL51                  ; JSR LL51          ; Call LL51 to set XX12 to the dot products of XX15 and
     D896 D4B2     
33739 D898 06A0  32        bl   @jsr                       ;
     D89A FE28     
33740                                                                          ; XX16, which we'll call dot_sidev, dot_roofv and
33741                                                                          ; dot_nosev:
33742                                                                          ;
33743                                                                          ; XX12(1 0) = [x y z] . sidev
33744                                                                          ; = (dot_sidev_sign dot_sidev_lo)
33745                                                                          ; = dot_sidev
33746                                                                          ;
33747                                                                          ; XX12(3 2) = [x y z] . roofv
33748                                                                          ; = (dot_roofv_sign dot_roofv_lo)
33749                                                                          ; = dot_roofv
33750                                                                          ;
33751                                                                          ; XX12(5 4) = [x y z] . nosev
33752                                                                          ; = (dot_nosev_sign dot_nosev_lo)
33753                                                                          ; = dot_nosev
33754               
33755 D89C D360  30        movb @XX12,ra                   ; LDA XX12          ; Set XX18(2 0) = dot_sidev
     D89E 0037     
33756 D8A0 D80D  30        movb ra,@XX18                   ; STA XX18
     D8A2 007E     
33757 D8A4 D360  30        movb @XX12+1,ra                 ; LDA XX12+1
     D8A6 0038     
33758 D8A8 D80D  30        movb ra,@XX18+2                 ; STA XX18+2
     D8AA 0080     
33759               
33760 D8AC D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set XX18(5 3) = dot_roofv
     D8AE 0039     
33761 D8B0 D80D  30        movb ra,@XX18+3                 ; STA XX18+3
     D8B2 0081     
33762 D8B4 D360  30        movb @XX12+3,ra                 ; LDA XX12+3
     D8B6 003A     
33763 D8B8 D80D  30        movb ra,@XX18+5                 ; STA XX18+5
     D8BA 0083     
33764               
33765 D8BC D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set XX18(8 6) = dot_nosev
     D8BE 003B     
33766 D8C0 D80D  30        movb ra,@XX18+6                 ; STA XX18+6
     D8C2 0084     
33767 D8C4 D360  30        movb @XX12+5,ra                 ; LDA XX12+5
     D8C6 003C     
33768 D8C8 D80D  30        movb ra,@XX18+8                 ; STA XX18+8
     D8CA 0086     
33769               
33770 D8CC 020F  20        li   ry,>04*256                 ; LDY #4            ; Fetch byte #4 of the ship's blueprint, which contains
     D8CE 0400     
33771                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the low byte of the offset to the faces data
     **** ****     > LD_IND_Y_IDX
0001 D8D0 D820  42        movb @XX0,@rtmplb
     D8D2 001E     
     D8D4 8301     
0002 D8D6 D020  30        movb @XX0+1,rtmp
     D8D8 001F     
0003 D8DA 06CF  14        swpb ry
0004 D8DC A00F  18        a    ry,rtmp
0005 D8DE 06CF  14        swpb ry
0006 D8E0 D350  26        movb *rtmp,RA
                   < elite.a99
33772               
33773                      .clc                            ; CLC               ; Set V = low byte faces offset + XX0
     **** ****     > CLC
0001 D8E2 0A16  18        sla  rzero,1
                   < elite.a99
33774                      .adc @XX0,ra                    ; ADC XX0
     **** ****     > ADC
0001 D8E4 1701  14        jnc  !
0002 D8E6 B347  18        ab   rone,ra
0003               !:
0004 D8E8 B360  30        ab   @XX0,ra
     D8EA 001E     
                   < elite.a99
33775 D8EC D80D  30        movb ra,@V                      ; STA V
     D8EE 0022     
33776               
33777 D8F0 020F  20        li   ry,>11*256                 ; LDY #17           ; Fetch byte #17 of the ship's blueprint, which contains
     D8F2 1100     
33778                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the high byte of the offset to the faces data
     **** ****     > LD_IND_Y_IDX
0001 D8F4 D820  42        movb @XX0,@rtmplb
     D8F6 001E     
     D8F8 8301     
0002 D8FA D020  30        movb @XX0+1,rtmp
     D8FC 001F     
0003 D8FE 06CF  14        swpb ry
0004 D900 A00F  18        a    ry,rtmp
0005 D902 06CF  14        swpb ry
0006 D904 D350  26        movb *rtmp,RA
                   < elite.a99
33779               
33780                      .adc @XX0+1,ra                  ; ADC XX0+1         ; Set V+1 = high byte faces offset + XX0+1
     **** ****     > ADC
0001 D906 1701  14        jnc  !
0002 D908 B347  18        ab   rone,ra
0003               !:
0004 D90A B360  30        ab   @XX0+1,ra
     D90C 001F     
                   < elite.a99
33781 D90E D80D  30        movb ra,@V+1                    ; STA V+1           ;
     D910 0023     
33782                                                                          ; So V(1 0) now points to the start of the faces data
33783                                                                          ; for this ship
33784               
33785 D912 020F  20        li   ry,>00*256                 ; LDY #0            ; We're now going to loop through all the faces for this
     D914 0000     
33786                                                                          ; ship, so set a counter in Y, starting from 0, which we
33787                                                                          ; will increment by 4 each loop to step through the
33788                                                                          ; four bytes of data for each face
33789               
33790               LL86:
33791                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this face into A, so:
     **** ****     > LD_IND_Y_IDX
0001 D916 D820  42        movb @V,@rtmplb
     D918 0022     
     D91A 8301     
0002 D91C D020  30        movb @V+1,rtmp
     D91E 0023     
0003 D920 06CF  14        swpb ry
0004 D922 A00F  18        a    ry,rtmp
0005 D924 06CF  14        swpb ry
0006 D926 D350  26        movb *rtmp,RA
                   < elite.a99
33792                                                                          ;
33793                                                                          ; A = %xyz vvvvv, where:
33794                                                                          ;
33795                                                                          ; * Bits 0-4 = visibility distance, beyond which the
33796                                                                          ; face is always shown
33797                                                                          ;
33798                                                                          ; * Bits 7-5 = the sign bits of normal_x, normal_y
33799                                                                          ; and normal_z
33800               
33801 D928 D80D  30        movb ra,@XX12+1                 ; STA XX12+1        ; Store byte #0 in XX12+1, so XX12+1 now has the sign of
     D92A 0038     
33802                                                                          ; normal_x
33803               
33804 D92C 024D  22        andi ra,>1f*256                 ; AND #%00011111    ; Extract bits 0-4 to give the visibility distance
     D92E 1F00     
33805               
33806 D930 9360  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 <= the visibility distance, where XX4 contains
     D932 00A7     
33807 D934 1810  14        joc  LL87                       ; BCS LL87          ; the ship's z-distance reduced to 0-31 (which we set in
33808                                                                          ; part 2), skip to LL87 as this face is close enough
33809                                                                          ; that we have to test its visibility using the face
33810                                                                          ; normals
33811               
33812                                                                          ; Otherwise this face is within range and is therefore
33813                                                                          ; always shown
33814               
33815 D936 D34F  18        movb ry,ra                      ; TYA               ; Set X = Y / 4
33816 D938 091D  18        srl  ra,1                       ; LSR A             ; = the number of this face * 4 /4
33817 D93A 091D  18        srl  ra,1                       ; LSR A             ; = the number of this face
33818 D93C D38D  18        movb ra,rx                      ; TAX
33819               
33820 D93E 020D  20        li   ra,>ff*256                 ; LDA #255          ; Set the X-th byte of XX2 to 255 to denote that this
     D940 FF00     
33821 D942 DB8D  38        movb ra,@XX2(rx)                ; STA XX2,X         ; face is visible
     D944 00D2     
33822               
33823 D946 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y + 4 to point to the next face
33824                      .adi (>04*256)                  ; ADC #4
     **** ****     > ADI
0001 D948 1701  14        jnc  !
0002 D94A B347  18        ab   rone,ra
0003               !:
0004 D94C 022D  22        ai   ra,(>04*256)
     D94E 0400     
                   < elite.a99
33825 D950 D3CD  18        movb ra,ry                      ; TAY
33826               
33827 D952 0460  28        b    @LL88                      ; JMP LL88          ; Jump down to LL88 to skip the following, as we don't
     D954 DB8E     
33828                                                                          ; need to test the face normals
33829               
33830               LL87:
33831 D956 D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Fetch byte #0 for this face into A
     D958 0038     
33832               
33833                      .asla                           ; ASL A             ; Shift A left and store it, so XX12+3 now has the sign
     **** ****     > ASLA
0001 D95A 024D  22        andi ra,>ff00
     D95C FF00     
0002 D95E 0A1D  18        sla  ra,1
                   < elite.a99
33834 D960 D80D  30        movb ra,@XX12+3                 ; STA XX12+3        ; of normal_y
     D962 003A     
33835               
33836                      .asla                           ; ASL A             ; Shift A left and store it, so XX12+5 now has the sign
     **** ****     > ASLA
0001 D964 024D  22        andi ra,>ff00
     D966 FF00     
0002 D968 0A1D  18        sla  ra,1
                   < elite.a99
33837 D96A D80D  30        movb ra,@XX12+5                 ; STA XX12+5        ; of normal_z
     D96C 003C     
33838               
33839 D96E B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
33840               
33841                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this face and store in XX12, so
     **** ****     > LD_IND_Y_IDX
0001 D970 D820  42        movb @V,@rtmplb
     D972 0022     
     D974 8301     
0002 D976 D020  30        movb @V+1,rtmp
     D978 0023     
0003 D97A 06CF  14        swpb ry
0004 D97C A00F  18        a    ry,rtmp
0005 D97E 06CF  14        swpb ry
0006 D980 D350  26        movb *rtmp,RA
                   < elite.a99
33842 D982 D80D  30        movb ra,@XX12                   ; STA XX12          ; XX12 = normal_x
     D984 0037     
33843               
33844 D986 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
33845               
33846                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this face and store in XX12+2, so
     **** ****     > LD_IND_Y_IDX
0001 D988 D820  42        movb @V,@rtmplb
     D98A 0022     
     D98C 8301     
0002 D98E D020  30        movb @V+1,rtmp
     D990 0023     
0003 D992 06CF  14        swpb ry
0004 D994 A00F  18        a    ry,rtmp
0005 D996 06CF  14        swpb ry
0006 D998 D350  26        movb *rtmp,RA
                   < elite.a99
33847 D99A D80D  30        movb ra,@XX12+2                 ; STA XX12+2        ; XX12+2 = normal_y
     D99C 0039     
33848               
33849 D99E B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
33850               
33851                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this face and store in XX12+4, so
     **** ****     > LD_IND_Y_IDX
0001 D9A0 D820  42        movb @V,@rtmplb
     D9A2 0022     
     D9A4 8301     
0002 D9A6 D020  30        movb @V+1,rtmp
     D9A8 0023     
0003 D9AA 06CF  14        swpb ry
0004 D9AC A00F  18        a    ry,rtmp
0005 D9AE 06CF  14        swpb ry
0006 D9B0 D350  26        movb *rtmp,RA
                   < elite.a99
33852 D9B2 D80D  30        movb ra,@XX12+4                 ; STA XX12+4        ; XX12+4 = normal_z
     D9B4 003B     
33853               
33854                                                                          ; So we now have:
33855                                                                          ;
33856                                                                          ; XX12(1 0) = (normal_x_sign normal_x)
33857                                                                          ;
33858                                                                          ; XX12(3 2) = (normal_y_sign normal_y)
33859                                                                          ;
33860                                                                          ; XX12(5 4) = (normal_z_sign normal_z)
33861               
33862 D9B6 D3A0  30        movb @XX17,rx                   ; LDX XX17          ; If XX17 < 4 then jump to LL92, otherwise we stored a
     D9B8 0095     
33863 D9BA 028E  22        ci   rx,>04*256                 ; CPX #4            ; larger scale factor above
     D9BC 0400     
33864 D9BE 172B  14        jnc  LL92                       ; BCC LL92
33865               
33866               LL143:
33867 D9C0 D360  30        movb @XX18,ra                   ; LDA XX18          ; Set XX15(1 0) = XX18(2 0)
     D9C2 007E     
33868 D9C4 D80D  30        movb ra,@XX15                   ; STA XX15          ; = dot_sidev
     D9C6 0031     
33869 D9C8 D360  30        movb @XX18+2,ra                 ; LDA XX18+2
     D9CA 0080     
33870 D9CC D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     D9CE 0032     
33871               
33872 D9D0 D360  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set XX15(3 2) = XX18(5 3)
     D9D2 0081     
33873 D9D4 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; = dot_roofv
     D9D6 0033     
33874 D9D8 D360  30        movb @XX18+5,ra                 ; LDA XX18+5
     D9DA 0083     
33875 D9DC D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     D9DE 0034     
33876               
33877 D9E0 D360  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set XX15(5 4) = XX18(8 6)
     D9E2 0084     
33878 D9E4 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; = dot_nosev
     D9E6 0035     
33879 D9E8 D360  30        movb @XX18+8,ra                 ; LDA XX18+8
     D9EA 0086     
33880 D9EC D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     D9EE 0036     
33881               
33882 D9F0 0460  28        b    @LL89                      ; JMP LL89          ; Jump down to LL89
     D9F2 DADA     
33883               
33884               ovflw_:
33885                                                                          ; If we get here then the addition below overflowed, so
33886                                                                          ; we halve the dot products and normal vector
33887                      .lsr @XX18                      ; LSR XX18          ; Divide dot_sidev_lo by 2, so dot_sidev = dot_sidev / 2
     **** ****     > LSR
0001 D9F4 D020  30        movb @XX18,rtmp
     D9F6 007E     
0002 D9F8 0910  18        srl  rtmp,1
0003 D9FA D800  30        movb rtmp,@XX18
     D9FC 007E     
                   < elite.a99
33888               
33889                      .lsr @XX18+6                    ; LSR XX18+6        ; Divide dot_nosev_lo by 2, so dot_nosev = dot_nosev / 2
     **** ****     > LSR
0001 D9FE D020  30        movb @XX18+6,rtmp
     DA00 0084     
0002 DA02 0910  18        srl  rtmp,1
0003 DA04 D800  30        movb rtmp,@XX18+6
     DA06 0084     
                   < elite.a99
33890               
33891                      .lsr @XX18+3                    ; LSR XX18+3        ; Divide dot_roofv_lo by 2, so dot_roofv = dot_roofv / 2
     **** ****     > LSR
0001 DA08 D020  30        movb @XX18+3,rtmp
     DA0A 0081     
0002 DA0C 0910  18        srl  rtmp,1
0003 DA0E D800  30        movb rtmp,@XX18+3
     DA10 0081     
                   < elite.a99
33892               
33893 DA12 020E  20        li   rx,>01*256                 ; LDX #1            ; Set X = 1 so when we fall through into LL92, we divide
     DA14 0100     
33894                                                                          ; the normal vector by 2 as well
33895               
33896               LL92:
33897                                                                          ; We jump here from above with the scale factor in X,
33898                                                                          ; and now we apply it by scaling the normal vector down
33899                                                                          ; by a factor of 2^X (i.e. divide by 2^X)
33900 DA16 D360  30        movb @XX12,ra                   ; LDA XX12          ; Set XX15 = normal_x
     DA18 0037     
33901 DA1A D80D  30        movb ra,@XX15                   ; STA XX15
     DA1C 0031     
33902               
33903 DA1E D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set XX15+2 = normal_y
     DA20 0039     
33904 DA22 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     DA24 0033     
33905               
33906 DA26 D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set A = normal_z
     DA28 003B     
33907               
33908               LL93:
33909 DA2A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the scale factor in X
33910               
33911 DA2C 110D  14        jlt  LL94                       ; BMI LL94          ; If X was 0 before the decrement, there is no scaling
33912                                                                          ; to do, so jump to LL94 to exit the loop
33913               
33914                      .lsr @XX15                      ; LSR XX15          ; Set XX15 = XX15 / 2
     **** ****     > LSR
0001 DA2E D020  30        movb @XX15,rtmp
     DA30 0031     
0002 DA32 0910  18        srl  rtmp,1
0003 DA34 D800  30        movb rtmp,@XX15
     DA36 0031     
                   < elite.a99
33915                                                                          ; = normal_x / 2
33916               
33917                      .lsr @XX15+2                    ; LSR XX15+2        ; Set XX15+2 = XX15+2 / 2
     **** ****     > LSR
0001 DA38 D020  30        movb @XX15+2,rtmp
     DA3A 0033     
0002 DA3C 0910  18        srl  rtmp,1
0003 DA3E D800  30        movb rtmp,@XX15+2
     DA40 0033     
                   < elite.a99
33918                                                                          ; = normal_y / 2
33919               
33920 DA42 091D  18        srl  ra,1                       ; LSR A             ; Set A = A / 2
33921                                                                          ; = normal_z / 2
33922               
33923 DA44 7387  18        sb   rone,rx                    ; DEX               ; Decrement the scale factor in X
33924               
33925 DA46 15F2  14        jgt  LL93+3                     ; BPL LL93+3        ; If we have more scaling to do, loop back up to the
33926                                                                          ; first LSR above until the normal vector is scaled down
33927               
33928               LL94:
33929 DA48 D80D  30        movb ra,@R                      ; STA R             ; Set R = normal_z
     DA4A 0091     
33930               
33931 DA4C D360  30        movb @XX12+5,ra                 ; LDA XX12+5        ; Set S = normal_z_sign
     DA4E 003C     
33932 DA50 D80D  30        movb ra,@S                      ; STA S
     DA52 0092     
33933               
33934 DA54 D360  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set Q = dot_nosev_lo
     DA56 0084     
33935 DA58 D80D  30        movb ra,@Q                      ; STA Q
     DA5A 0090     
33936               
33937 DA5C D360  30        movb @XX18+8,ra                 ; LDA XX18+8        ; Set A = dot_nosev_sign
     DA5E 0086     
33938               
33939 DA60 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     DA62 D45A     
33940 DA64 06A0  32        bl   @jsr                       ;
     DA66 FE28     
33941                                                                          ; = normal_z + dot_nosev
33942                                                                          ;
33943                                                                          ; setting the sign of the result in S
33944               
33945 DA68 18C5  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
33946                                                                          ; both the normal vector and dot products by 2 and try
33947                                                                          ; again
33948               
33949 DA6A D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; Set XX15(5 4) = (S A)
     DA6C 0035     
33950 DA6E D360  30        movb @S,ra                      ; LDA S             ; = normal_z + dot_nosev
     DA70 0092     
33951 DA72 D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     DA74 0036     
33952               
33953 DA76 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set R = normal_x
     DA78 0031     
33954 DA7A D80D  30        movb ra,@R                      ; STA R
     DA7C 0091     
33955               
33956 DA7E D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set S = normal_x_sign
     DA80 0038     
33957 DA82 D80D  30        movb ra,@S                      ; STA S
     DA84 0092     
33958               
33959 DA86 D360  30        movb @XX18,ra                   ; LDA XX18          ; Set Q = dot_sidev_lo
     DA88 007E     
33960 DA8A D80D  30        movb ra,@Q                      ; STA Q
     DA8C 0090     
33961               
33962 DA8E D360  30        movb @XX18+2,ra                 ; LDA XX18+2        ; Set A = dot_sidev_sign
     DA90 0080     
33963               
33964 DA92 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     DA94 D45A     
33965 DA96 06A0  32        bl   @jsr                       ;
     DA98 FE28     
33966                                                                          ; = normal_x + dot_sidev
33967                                                                          ;
33968                                                                          ; setting the sign of the result in S
33969               
33970 DA9A 18AC  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
33971                                                                          ; both the normal vector and dot products by 2 and try
33972                                                                          ; again
33973               
33974 DA9C D80D  30        movb ra,@XX15                   ; STA XX15          ; Set XX15(1 0) = (S A)
     DA9E 0031     
33975 DAA0 D360  30        movb @S,ra                      ; LDA S             ; = normal_x + dot_sidev
     DAA2 0092     
33976 DAA4 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     DAA6 0032     
33977               
33978 DAA8 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set R = normal_y
     DAAA 0033     
33979 DAAC D80D  30        movb ra,@R                      ; STA R
     DAAE 0091     
33980               
33981 DAB0 D360  30        movb @XX12+3,ra                 ; LDA XX12+3        ; Set S = normal_y_sign
     DAB2 003A     
33982 DAB4 D80D  30        movb ra,@S                      ; STA S
     DAB6 0092     
33983               
33984 DAB8 D360  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set Q = dot_roofv_lo
     DABA 0081     
33985 DABC D80D  30        movb ra,@Q                      ; STA Q
     DABE 0090     
33986               
33987 DAC0 D360  30        movb @XX18+5,ra                 ; LDA XX18+5        ; Set A = dot_roofv_sign
     DAC2 0083     
33988               
33989 DAC4 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     DAC6 D45A     
33990 DAC8 06A0  32        bl   @jsr                       ;
     DACA FE28     
33991                                                                          ; = normal_y + dot_roofv
33992               
33993 DACC 1893  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
33994                                                                          ; both the normal vector and dot products by 2 and try
33995                                                                          ; again
33996               
33997 DACE D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15(3 2) = (S A)
     DAD0 0033     
33998 DAD2 D360  30        movb @S,ra                      ; LDA S             ; = normal_y + dot_roofv
     DAD4 0092     
33999 DAD6 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     DAD8 0034     
34000               
34001               LL89:
34002                                                                          ; When we get here, we have set up the following:
34003                                                                          ;
34004                                                                          ; XX15(1 0) = normal_x + dot_sidev
34005                                                                          ; = normal_x + [x y z] . sidev
34006                                                                          ;
34007                                                                          ; XX15(3 2) = normal_y + dot_roofv
34008                                                                          ; = normal_y + [x y z] . roofv
34009                                                                          ;
34010                                                                          ; XX15(5 4) = normal_z + dot_nosev
34011                                                                          ; = normal_z + [x y z] . nosev
34012                                                                          ;
34013                                                                          ; and:
34014                                                                          ;
34015                                                                          ; XX12(1 0) = (normal_x_sign normal_x)
34016                                                                          ;
34017                                                                          ; XX12(3 2) = (normal_y_sign normal_y)
34018                                                                          ;
34019                                                                          ; XX12(5 4) = (normal_z_sign normal_z)
34020                                                                          ;
34021                                                                          ; We now calculate the dot product XX12 . XX15 to tell
34022                                                                          ; us whether or not this face is visible
34023 DADA D360  30        movb @XX12,ra                   ; LDA XX12          ; Set Q = XX12
     DADC 0037     
34024 DADE D80D  30        movb ra,@Q                      ; STA Q
     DAE0 0090     
34025               
34026 DAE2 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A = XX15
     DAE4 0031     
34027               
34028 DAE6 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     DAE8 43EC     
34029 DAEA 06A0  32        bl   @jsr                       ;
     DAEC FE28     
34030 DAEE D80D  30        movb ra,@T                      ; STA T             ; = XX15 * XX12 / 256
     DAF0 00D1     
34031               
34032 DAF2 D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set S = sign of XX15(1 0) * XX12(1 0), so:
     DAF4 0038     
34033                      .eor @XX15+1                    ; EOR XX15+1        ;
     **** ****     > EOR
0001 DAF6 D020  30        movb @XX15+1,rtmp
     DAF8 0032     
0002 DAFA 2B40  18        xor  rtmp,ra
                   < elite.a99
34034 DAFC D80D  30        movb ra,@S                      ; STA S             ; (S T) = XX15(1 0) * XX12(1 0) / 256
     DAFE 0092     
34035               
34036 DB00 D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set Q = XX12+2
     DB02 0039     
34037 DB04 D80D  30        movb ra,@Q                      ; STA Q
     DB06 0090     
34038               
34039 DB08 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set A = XX15+2
     DB0A 0033     
34040               
34041 DB0C 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q
     DB0E 43EC     
34042 DB10 06A0  32        bl   @jsr                       ;
     DB12 FE28     
34043 DB14 D80D  30        movb ra,@Q                      ; STA Q             ; = XX15+2 * XX12+2 / 256
     DB16 0090     
34044               
34045 DB18 D360  30        movb @T,ra                      ; LDA T             ; Set T = R, so now:
     DB1A 00D1     
34046 DB1C D80D  30        movb ra,@R                      ; STA R             ;
     DB1E 0091     
34047                                                                          ; (S R) = XX15(1 0) * XX12(1 0) / 256
34048               
34049 DB20 D360  30        movb @XX12+3,ra                 ; LDA XX12+3        ; Set A = sign of XX15+3 * XX12+3, so:
     DB22 003A     
34050                      .eor @XX15+3                    ; EOR XX15+3        ;
     **** ****     > EOR
0001 DB24 D020  30        movb @XX15+3,rtmp
     DB26 0034     
0002 DB28 2B40  18        xor  rtmp,ra
                   < elite.a99
34051                                                                          ; (A Q) = XX15(3 2) * XX12(3 2) / 256
34052               
34053 DB2A 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S T) = (S R) + (A Q)
     DB2C D45A     
34054 DB2E 06A0  32        bl   @jsr                       ;
     DB30 FE28     
34055 DB32 D80D  30        movb ra,@T                      ; STA T             ; =   XX15(1 0) * XX12(1 0) / 256
     DB34 00D1     
34056                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34057               
34058 DB36 D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set Q = XX12+4
     DB38 003B     
34059 DB3A D80D  30        movb ra,@Q                      ; STA Q
     DB3C 0090     
34060               
34061 DB3E D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set A = XX15+4
     DB40 0035     
34062               
34063 DB42 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q
     DB44 43EC     
34064 DB46 06A0  32        bl   @jsr                       ;
     DB48 FE28     
34065 DB4A D80D  30        movb ra,@Q                      ; STA Q             ; = XX15+4 * XX12+4 / 256
     DB4C 0090     
34066               
34067 DB4E D360  30        movb @T,ra                      ; LDA T             ; Set T = R, so now:
     DB50 00D1     
34068 DB52 D80D  30        movb ra,@R                      ; STA R             ;
     DB54 0091     
34069                                                                          ; (S R) =   XX15(1 0) * XX12(1 0) / 256
34070                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34071               
34072 DB56 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A = sign of XX15+5 * XX12+5, so:
     DB58 0036     
34073                      .eor @XX12+5                    ; EOR XX12+5        ;
     **** ****     > EOR
0001 DB5A D020  30        movb @XX12+5,rtmp
     DB5C 003C     
0002 DB5E 2B40  18        xor  rtmp,ra
                   < elite.a99
34074                                                                          ; (A Q) = XX15(5 4) * XX12(5 4) / 256
34075               
34076 DB60 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     DB62 D45A     
34077 DB64 06A0  32        bl   @jsr                       ;
     DB66 FE28     
34078                                                                          ; =   XX15(1 0) * XX12(1 0) / 256
34079                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34080                                                                          ; + XX15(5 4) * XX12(5 4) / 256
34081               
34082                      .pha                            ; PHA               ; Push the result A onto the stack, so the stack now
     **** ****     > PHA
0001 DB68 D68D  30        movb ra,*rsp
0002 DB6A 060A  14        dec  rsp
                   < elite.a99
34083                                                                          ; contains the dot product XX12 . XX15
34084               
34085 DB6C D34F  18        movb ry,ra                      ; TYA               ; Set X = Y / 4
34086 DB6E 091D  18        srl  ra,1                       ; LSR A             ; = the number of this face * 4 /4
34087 DB70 091D  18        srl  ra,1                       ; LSR A             ; = the number of this face
34088 DB72 D38D  18        movb ra,rx                      ; TAX
34089               
34090                      .pla                            ; PLA               ; Pull the dot product off the stack into A
     **** ****     > PLA
0001 DB74 058A  14        inc  rsp
0002 DB76 D35A  26        movb *rsp,ra
                   < elite.a99
34091               
34092                      .bit @S                         ; BIT S             ; If bit 7 of S is set, i.e. the dot product is
     **** ****     > BIT
0001 DB78 D020  30        movb @S,rtmp
     DB7A 0092     
0002 DB7C 0540  14        inv  rtmp
0003 DB7E D047  18        movb rone,rtmp2
0004 DB80 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
34093 DB82 1102  14        jlt  B112                       ; BMI B112          ; negative, then this face is visible as its normal is
34094                                                                          ; pointing towards us, so skip the following instruction
34095               
34096 DB84 020D  20        li   ra,>00*256                 ; LDA #0            ; Otherwise the face is not visible, so set A = 0 so we
     DB86 0000     
34097                                                                          ; can store this to mean "not visible"
34098               
34099               B112:
34100 DB88 DB8D  38        movb ra,@XX2(rx)                ; STA XX2,X         ; Store the face's visibility in the X-th byte of XX2
     DB8A 00D2     
34101               
34102 DB8C B3C7  18        ab   rone,ry                    ; INY               ; Above we incremented Y to point to byte #3, so this
34103                                                                          ; increments Y to point to byte #4, i.e. byte #0 of the
34104                                                                          ; next face
34105               
34106               LL88:
34107 DB8E 93E0  30        cb   @XX20,ry                   ; CPY XX20          ; If Y >= XX20, the number of faces * 4, jump down to
     DB90 00A8     
34108 DB92 1802  14        joc  LL42                       ; BCS LL42          ; LL42 to move on to the
34109               
34110 DB94 0460  28        b    @LL86                      ; JMP LL86          ; Otherwise loop back to LL86 to work out the visibility
     DB96 D916     
34111                                                                          ; of the next face
34112               
34113               * ******************************************************************************
34114               *
34115               * Name: LL9 (Part 6 of 12)
34116               * Type: Subroutine
34117               * Category: Drawing ships
34118               * Summary: Draw ship: Calculate the visibility of each of the ship's vertices
34119               * Deep dive: Drawing ships
34120               * Calculating vertex coordinates
34121               *
34122               * ------------------------------------------------------------------------------
34123               *
34124               * This section calculates the visibility of each of the ship's vertices, and for
34125               * those that are visible, it starts the process of calculating the screen
34126               * coordinates of each vertex
34127               *
34128               * ******************************************************************************
34129               
34130               LL42:
34131                                                                          ; The first task is to set up the inverse matrix, ready
34132                                                                          ; for us to send to the dot product routine at LL51.
34133                                                                          ; Back up in part 3, we set up the following variables:
34134                                                                          ;
34135                                                                          ; * XX16(1 0) = sidev_x
34136                                                                          ; * XX16(3 2) = sidev_y
34137                                                                          ; * XX16(5 4) = sidev_z
34138                                                                          ;
34139                                                                          ; * XX16(7 6) = roofv_x
34140                                                                          ; * XX16(9 8) = roofv_y
34141                                                                          ; * XX16(11 10) = roofv_z
34142                                                                          ;
34143                                                                          ; * XX16(13 12) = nosev_x
34144                                                                          ; * XX16(15 14) = nosev_y
34145                                                                          ; * XX16(17 16) = nosev_z
34146                                                                          ;
34147                                                                          ; and we then scaled the vectors to give the following:
34148                                                                          ;
34149                                                                          ; * XX16   = scaled |sidev_x|
34150                                                                          ; * XX16+2 = scaled |sidev_y|
34151                                                                          ; * XX16+4 = scaled |sidev_z|
34152                                                                          ;
34153                                                                          ; * XX16+6  = scaled |roofv_x|
34154                                                                          ; * XX16+8  = scaled |roofv_y|
34155                                                                          ; * XX16+10 = scaled |roofv_z|
34156                                                                          ;
34157                                                                          ; * XX16+12 = scaled |nosev_x|
34158                                                                          ; * XX16+14 = scaled |nosev_y|
34159                                                                          ; * XX16+16 = scaled |nosev_z|
34160                                                                          ;
34161                                                                          ; We now need to rearrange these locations so they
34162                                                                          ; effectively transpose the matrix into its inverse
34163 DB98 D3E0  30        movb @XX16+2,ry                 ; LDY XX16+2        ; Set XX16+2 = XX16+6 = scaled |roofv_x|
     DB9A 000B     
34164 DB9C D3A0  30        movb @XX16+3,rx                 ; LDX XX16+3        ; Set XX16+3 = XX16+7 = roofv_x_hi
     DB9E 000C     
34165 DBA0 D360  30        movb @XX16+6,ra                 ; LDA XX16+6        ; Set XX16+6 = XX16+2 = scaled |sidev_y|
     DBA2 000F     
34166 DBA4 D80D  30        movb ra,@XX16+2                 ; STA XX16+2        ; Set XX16+7 = XX16+3 = sidev_y_hi
     DBA6 000B     
34167 DBA8 D360  30        movb @XX16+7,ra                 ; LDA XX16+7
     DBAA 0010     
34168 DBAC D80D  30        movb ra,@XX16+3                 ; STA XX16+3
     DBAE 000C     
34169 DBB0 D80F  30        movb ry,@XX16+6                 ; STY XX16+6
     DBB2 000F     
34170 DBB4 D80E  30        movb rx,@XX16+7                 ; STX XX16+7
     DBB6 0010     
34171               
34172 DBB8 D3E0  30        movb @XX16+4,ry                 ; LDY XX16+4        ; Set XX16+4 = XX16+12 = scaled |nosev_x|
     DBBA 000D     
34173 DBBC D3A0  30        movb @XX16+5,rx                 ; LDX XX16+5        ; Set XX16+5 = XX16+13 = nosev_x_hi
     DBBE 000E     
34174 DBC0 D360  30        movb @XX16+12,ra                ; LDA XX16+12       ; Set XX16+12 = XX16+4 = scaled |sidev_z|
     DBC2 0015     
34175 DBC4 D80D  30        movb ra,@XX16+4                 ; STA XX16+4        ; Set XX16+13 = XX16+5 = sidev_z_hi
     DBC6 000D     
34176 DBC8 D360  30        movb @XX16+13,ra                ; LDA XX16+13
     DBCA 0016     
34177 DBCC D80D  30        movb ra,@XX16+5                 ; STA XX16+5
     DBCE 000E     
34178 DBD0 D80F  30        movb ry,@XX16+12                ; STY XX16+12
     DBD2 0015     
34179 DBD4 D80E  30        movb rx,@XX16+13                ; STX XX16+13
     DBD6 0016     
34180               
34181 DBD8 D3E0  30        movb @XX16+10,ry                ; LDY XX16+10       ; Set XX16+10 = XX16+14 = scaled |nosev_y|
     DBDA 0013     
34182 DBDC D3A0  30        movb @XX16+11,rx                ; LDX XX16+11       ; Set XX16+11 = XX16+15 = nosev_y_hi
     DBDE 0014     
34183 DBE0 D360  30        movb @XX16+14,ra                ; LDA XX16+14       ; Set XX16+14 = XX16+10 = scaled |roofv_z|
     DBE2 0017     
34184 DBE4 D80D  30        movb ra,@XX16+10                ; STA XX16+10       ; Set XX16+15 = XX16+11 = roofv_z
     DBE6 0013     
34185 DBE8 D360  30        movb @XX16+15,ra                ; LDA XX16+15
     DBEA 0018     
34186 DBEC D80D  30        movb ra,@XX16+11                ; STA XX16+11
     DBEE 0014     
34187 DBF0 D80F  30        movb ry,@XX16+14                ; STY XX16+14
     DBF2 0017     
34188 DBF4 D80E  30        movb rx,@XX16+15                ; STX XX16+15
     DBF6 0018     
34189               
34190                                                                          ; So now we have the following sign-magnitude variables
34191                                                                          ; containing parts of the scaled orientation vectors:
34192                                                                          ;
34193                                                                          ; XX16(1 0)   = scaled sidev_x
34194                                                                          ; XX16(3 2)   = scaled roofv_x
34195                                                                          ; XX16(5 4)   = scaled nosev_x
34196                                                                          ;
34197                                                                          ; XX16(7 6)   = scaled sidev_y
34198                                                                          ; XX16(9 8)   = scaled roofv_y
34199                                                                          ; XX16(11 10) = scaled nosev_y
34200                                                                          ;
34201                                                                          ; XX16(13 12) = scaled sidev_z
34202                                                                          ; XX16(15 14) = scaled roofv_z
34203                                                                          ; XX16(17 16) = scaled nosev_z
34204                                                                          ;
34205                                                                          ; which is what we want, as the various vectors are now
34206                                                                          ; arranged so we can use LL51 to multiply by the
34207                                                                          ; transpose (i.e. the inverse of the matrix)
34208               
34209 DBF8 020F  20        li   ry,>08*256                 ; LDY #8            ; Fetch byte #8 of the ship's blueprint, which is the
     DBFA 0800     
34210                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of vertices * 8, and store it in XX20
     **** ****     > LD_IND_Y_IDX
0001 DBFC D820  42        movb @XX0,@rtmplb
     DBFE 001E     
     DC00 8301     
0002 DC02 D020  30        movb @XX0+1,rtmp
     DC04 001F     
0003 DC06 06CF  14        swpb ry
0004 DC08 A00F  18        a    ry,rtmp
0005 DC0A 06CF  14        swpb ry
0006 DC0C D350  26        movb *rtmp,RA
                   < elite.a99
34211 DC0E D80D  30        movb ra,@XX20                   ; STA XX20
     DC10 00A8     
34212               
34213                                                                          ; We now set V(1 0) = XX0(1 0) + 20, so V(1 0) points
34214                                                                          ; to byte #20 of the ship's blueprint, which is always
34215                                                                          ; where the vertex data starts (i.e. just after the 20
34216                                                                          ; byte block that define the ship's characteristics)
34217               
34218 DC12 D360  30        movb @XX0,ra                    ; LDA XX0           ; We start with the low bytes
     DC14 001E     
34219                      .clc                            ; CLC
     **** ****     > CLC
0001 DC16 0A16  18        sla  rzero,1
                   < elite.a99
34220                      .adi (>14*256)                  ; ADC #20
     **** ****     > ADI
0001 DC18 1701  14        jnc  !
0002 DC1A B347  18        ab   rone,ra
0003               !:
0004 DC1C 022D  22        ai   ra,(>14*256)
     DC1E 1400     
                   < elite.a99
34221 DC20 D80D  30        movb ra,@V                      ; STA V
     DC22 0022     
34222               
34223 DC24 D360  30        movb @XX0+1,ra                  ; LDA XX0+1         ; And then do the high bytes
     DC26 001F     
34224                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 DC28 1701  14        jnc  !
0002 DC2A B347  18        ab   rone,ra
0003               !:
0004 DC2C 022D  22        ai   ra,(>00*256)
     DC2E 0000     
                   < elite.a99
34225 DC30 D80D  30        movb ra,@V+1                    ; STA V+1
     DC32 0023     
34226               
34227 DC34 020F  20        li   ry,>00*256                 ; LDY #0            ; We are about to step through all the vertices, using
     DC36 0000     
34228                                                                          ; Y as a counter. There are six data bytes for each
34229                                                                          ; vertex, so we will increment Y by 6 for each iteration
34230                                                                          ; so it can act as an offset from V(1 0) to the current
34231                                                                          ; vertex's data
34232               
34233 DC38 D80F  30        movb ry,@CNT                    ; STY CNT           ; Set CNT = 0, which we will use as a pointer to the
     DC3A 00A4     
34234                                                                          ; heap at XX3, starting it at zero so the heap starts
34235                                                                          ; out empty
34236               
34237               LL48:
34238 DC3C D80F  30        movb ry,@XX17                   ; STY XX17          ; Set XX17 = Y, so XX17 now contains the offset of the
     DC3E 0095     
34239                                                                          ; current vertex's data
34240               
34241                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this vertex into XX15, so:
     **** ****     > LD_IND_Y_IDX
0001 DC40 D820  42        movb @V,@rtmplb
     DC42 0022     
     DC44 8301     
0002 DC46 D020  30        movb @V+1,rtmp
     DC48 0023     
0003 DC4A 06CF  14        swpb ry
0004 DC4C A00F  18        a    ry,rtmp
0005 DC4E 06CF  14        swpb ry
0006 DC50 D350  26        movb *rtmp,RA
                   < elite.a99
34242 DC52 D80D  30        movb ra,@XX15                   ; STA XX15          ;
     DC54 0031     
34243                                                                          ; XX15 = magnitude of the vertex's x-coordinate
34244               
34245 DC56 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
34246               
34247                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this vertex into XX15+2, so:
     **** ****     > LD_IND_Y_IDX
0001 DC58 D820  42        movb @V,@rtmplb
     DC5A 0022     
     DC5C 8301     
0002 DC5E D020  30        movb @V+1,rtmp
     DC60 0023     
0003 DC62 06CF  14        swpb ry
0004 DC64 A00F  18        a    ry,rtmp
0005 DC66 06CF  14        swpb ry
0006 DC68 D350  26        movb *rtmp,RA
                   < elite.a99
34248 DC6A D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ;
     DC6C 0033     
34249                                                                          ; XX15+2 = magnitude of the vertex's y-coordinate
34250               
34251 DC6E B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
34252               
34253                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this vertex into XX15+4, so:
     **** ****     > LD_IND_Y_IDX
0001 DC70 D820  42        movb @V,@rtmplb
     DC72 0022     
     DC74 8301     
0002 DC76 D020  30        movb @V+1,rtmp
     DC78 0023     
0003 DC7A 06CF  14        swpb ry
0004 DC7C A00F  18        a    ry,rtmp
0005 DC7E 06CF  14        swpb ry
0006 DC80 D350  26        movb *rtmp,RA
                   < elite.a99
34254 DC82 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ;
     DC84 0035     
34255                                                                          ; XX15+4 = magnitude of the vertex's z-coordinate
34256               
34257 DC86 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
34258               
34259                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this vertex into T, so:
     **** ****     > LD_IND_Y_IDX
0001 DC88 D820  42        movb @V,@rtmplb
     DC8A 0022     
     DC8C 8301     
0002 DC8E D020  30        movb @V+1,rtmp
     DC90 0023     
0003 DC92 06CF  14        swpb ry
0004 DC94 A00F  18        a    ry,rtmp
0005 DC96 06CF  14        swpb ry
0006 DC98 D350  26        movb *rtmp,RA
                   < elite.a99
34260 DC9A D80D  30        movb ra,@T                      ; STA T             ;
     DC9C 00D1     
34261                                                                          ; T = %xyz vvvvv, where:
34262                                                                          ;
34263                                                                          ; * Bits 0-4 = visibility distance, beyond which the
34264                                                                          ; vertex is not shown
34265                                                                          ;
34266                                                                          ; * Bits 7-5 = the sign bits of x, y and z
34267               
34268 DC9E 024D  22        andi ra,>1f*256                 ; AND #%00011111    ; Extract bits 0-4 to get the visibility distance
     DCA0 1F00     
34269               
34270 DCA2 9360  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 > the visibility distance, where XX4 contains
     DCA4 00A7     
34271 DCA6 1738  14        jnc  LL49-3                     ; BCC LL49-3        ; the ship's z-distance reduced to 0-31 (which we set in
34272                                                                          ; part 2), then this vertex is too far away to be
34273                                                                          ; visible, so jump down to LL50 (via the JMP instruction
34274                                                                          ; in LL49-3) to move on to the next vertex
34275               
34276 DCA8 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #4
34277               
34278                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #4 for this vertex into P, so:
     **** ****     > LD_IND_Y_IDX
0001 DCAA D820  42        movb @V,@rtmplb
     DCAC 0022     
     DCAE 8301     
0002 DCB0 D020  30        movb @V+1,rtmp
     DCB2 0023     
0003 DCB4 06CF  14        swpb ry
0004 DCB6 A00F  18        a    ry,rtmp
0005 DCB8 06CF  14        swpb ry
0006 DCBA D350  26        movb *rtmp,RA
                   < elite.a99
34279 DCBC D80D  30        movb ra,@P                      ; STA P             ;
     DCBE 001B     
34280                                                                          ; P = %ffff ffff, where:
34281                                                                          ;
34282                                                                          ; * Bits 0-3 = the number of face 1
34283                                                                          ;
34284                                                                          ; * Bits 4-7 = the number of face 2
34285               
34286 DCC0 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     DCC2 0F00     
34287 DCC4 D38D  18        movb ra,rx                      ; TAX
34288               
34289 DCC6 D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     DCC8 00D2     
34290 DCCA 1628  14        jne  LL49                       ; BNE LL49          ; face 1 is visible, so jump to LL49
34291               
34292 DCCC D360  30        movb @P,ra                      ; LDA P             ; Fetch byte #4 for this vertex into A
     DCCE 001B     
34293               
34294 DCD0 091D  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 2
34295 DCD2 091D  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
34296 DCD4 091D  18        srl  ra,1                       ; LSR A
34297 DCD6 091D  18        srl  ra,1                       ; LSR A
34298 DCD8 D38D  18        movb ra,rx                      ; TAX
34299               
34300 DCDA D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     DCDC 00D2     
34301 DCDE 161E  14        jne  LL49                       ; BNE LL49          ; face 2 is visible, so jump to LL49
34302               
34303 DCE0 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #5
34304               
34305                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #5 for this vertex into P, so:
     **** ****     > LD_IND_Y_IDX
0001 DCE2 D820  42        movb @V,@rtmplb
     DCE4 0022     
     DCE6 8301     
0002 DCE8 D020  30        movb @V+1,rtmp
     DCEA 0023     
0003 DCEC 06CF  14        swpb ry
0004 DCEE A00F  18        a    ry,rtmp
0005 DCF0 06CF  14        swpb ry
0006 DCF2 D350  26        movb *rtmp,RA
                   < elite.a99
34306 DCF4 D80D  30        movb ra,@P                      ; STA P             ;
     DCF6 001B     
34307                                                                          ; P = %ffff ffff, where:
34308                                                                          ;
34309                                                                          ; * Bits 0-3 = the number of face 3
34310                                                                          ;
34311                                                                          ; * Bits 4-7 = the number of face 4
34312               
34313 DCF8 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     DCFA 0F00     
34314 DCFC D38D  18        movb ra,rx                      ; TAX
34315               
34316 DCFE D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     DD00 00D2     
34317 DD02 160C  14        jne  LL49                       ; BNE LL49          ; face 3 is visible, so jump to LL49
34318               
34319 DD04 D360  30        movb @P,ra                      ; LDA P             ; Fetch byte #5 for this vertex into A
     DD06 001B     
34320               
34321 DD08 091D  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 4
34322 DD0A 091D  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
34323 DD0C 091D  18        srl  ra,1                       ; LSR A
34324 DD0E 091D  18        srl  ra,1                       ; LSR A
34325 DD10 D38D  18        movb ra,rx                      ; TAX
34326               
34327 DD12 D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     DD14 00D2     
34328 DD16 1602  14        jne  LL49                       ; BNE LL49          ; face 4 is visible, so jump to LL49
34329               
34330 DD18 0460  28        b    @LL50                      ; JMP LL50          ; If we get here then none of the four faces associated
     DD1A E064     
34331                                                                          ; with this vertex are visible, so this vertex is also
34332                                                                          ; not visible, so jump to LL50 to move on to the next
34333                                                                          ; vertex
34334               
34335               LL49:
34336 DD1C D360  30        movb @T,ra                      ; LDA T             ; Fetch byte #5 for this vertex into A and store it, so
     DD1E 00D1     
34337 DD20 D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; XX15+1 now has the sign of the vertex's x-coordinate
     DD22 0032     
34338               
34339                      .asla                           ; ASL A             ; Shift A left and store it, so XX15+3 now has the sign
     **** ****     > ASLA
0001 DD24 024D  22        andi ra,>ff00
     DD26 FF00     
0002 DD28 0A1D  18        sla  ra,1
                   < elite.a99
34340 DD2A D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; of the vertex's y-coordinate
     DD2C 0034     
34341               
34342                      .asla                           ; ASL A             ; Shift A left and store it, so XX15+5 now has the sign
     **** ****     > ASLA
0001 DD2E 024D  22        andi ra,>ff00
     DD30 FF00     
0002 DD32 0A1D  18        sla  ra,1
                   < elite.a99
34343 DD34 D80D  30        movb ra,@XX15+5                 ; STA XX15+5        ; of the vertex's z-coordinate
     DD36 0036     
34344               
34345                                                                          ; By this point we have the following:
34346                                                                          ;
34347                                                                          ; XX15(1 0) = vertex x-coordinate
34348                                                                          ; XX15(3 2) = vertex y-coordinate
34349                                                                          ; XX15(5 4) = vertex z-coordinate
34350                                                                          ;
34351                                                                          ; XX16(1 0)   = scaled sidev_x
34352                                                                          ; XX16(3 2)   = scaled roofv_x
34353                                                                          ; XX16(5 4)   = scaled nosev_x
34354                                                                          ;
34355                                                                          ; XX16(7 6)   = scaled sidev_y
34356                                                                          ; XX16(9 8)   = scaled roofv_y
34357                                                                          ; XX16(11 10) = scaled nosev_y
34358                                                                          ;
34359                                                                          ; XX16(13 12) = scaled sidev_z
34360                                                                          ; XX16(15 14) = scaled roofv_z
34361                                                                          ; XX16(17 16) = scaled nosev_z
34362               
34363 DD38 0200  20        li   rtmp,LL51                  ; JSR LL51          ; Call LL51 to set XX12 to the dot products of XX15 and
     DD3A D4B2     
34364 DD3C 06A0  32        bl   @jsr                       ;
     DD3E FE28     
34365                                                                          ; XX16, as follows:
34366                                                                          ;
34367                                                                          ; XX12(1 0) = [ x y z ] . [ sidev_x roofv_x nosev_x ]
34368                                                                          ;
34369                                                                          ; XX12(3 2) = [ x y z ] . [ sidev_y roofv_y nosev_y ]
34370                                                                          ;
34371                                                                          ; XX12(5 4) = [ x y z ] . [ sidev_z roofv_z nosev_z ]
34372                                                                          ;
34373                                                                          ; XX12 contains the vector from the ship's centre to
34374                                                                          ; the vertex, transformed from the orientation vector
34375                                                                          ; space to the universe orientated around our ship. So
34376                                                                          ; we can refer to this vector below, let's call it
34377                                                                          ; vertv, so:
34378                                                                          ;
34379                                                                          ; vertv_x = [ x y z ] . [ sidev_x roofv_x nosev_x ]
34380                                                                          ;
34381                                                                          ; vertv_y = [ x y z ] . [ sidev_y roofv_y nosev_y ]
34382                                                                          ;
34383                                                                          ; vertv_z = [ x y z ] . [ sidev_z roofv_z nosev_z ]
34384                                                                          ;
34385                                                                          ; To finish the calculation, we now want to calculate:
34386                                                                          ;
34387                                                                          ; vertv + [ x y z ]
34388                                                                          ;
34389                                                                          ; So let's start with the vertv_x + x
34390               
34391 DD40 D360  30        movb @XX1+2,ra                  ; LDA XX1+2         ; Set A = x_sign of the ship's location
     DD42 0055     
34392               
34393 DD44 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 = x_sign
     DD46 0033     
34394               
34395                      .eor @XX12+1                    ; EOR XX12+1        ; If the sign of x_sign * the sign of vertv_x is
     **** ****     > EOR
0001 DD48 D020  30        movb @XX12+1,rtmp
     DD4A 0038     
0002 DD4C 2B40  18        xor  rtmp,ra
                   < elite.a99
34396 DD4E 1113  14        jlt  LL52                       ; BMI LL52          ; negative (i.e. they have different signs), skip to
34397                                                                          ; LL52
34398               
34399                      .clc                            ; CLC               ; Set XX15(2 1 0) = XX1(2 1 0) + XX12(1 0)
     **** ****     > CLC
0001 DD50 0A16  18        sla  rzero,1
                   < elite.a99
34400 DD52 D360  30        movb @XX12,ra                   ; LDA XX12          ; = (x_sign x_hi x_lo) + vertv_x
     DD54 0037     
34401                      .adc @XX1,ra                    ; ADC XX1           ;
     **** ****     > ADC
0001 DD56 1701  14        jnc  !
0002 DD58 B347  18        ab   rone,ra
0003               !:
0004 DD5A B360  30        ab   @XX1,ra
     DD5C 0053     
                   < elite.a99
34402 DD5E D80D  30        movb ra,@XX15                   ; STA XX15          ; Starting with the low bytes
     DD60 0031     
34403               
34404 DD62 D360  30        movb @XX1+1,ra                  ; LDA XX1+1         ; And then doing the high bytes (we can add 0 here as
     DD64 0054     
34405                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_x is 0)
     **** ****     > ADI
0001 DD66 1701  14        jnc  !
0002 DD68 B347  18        ab   rone,ra
0003               !:
0004 DD6A 022D  22        ai   ra,(>00*256)
     DD6C 0000     
                   < elite.a99
34406 DD6E D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     DD70 0032     
34407               
34408 DD72 0460  28        b    @LL53                      ; JMP LL53          ; We've added the x-coordinates, so jump to LL53 to do
     DD74 DDC6     
34409                                                                          ; the y-coordinates
34410               
34411               LL52:
34412                                                                          ; If we get here then x_sign and vertv_x have different
34413                                                                          ; signs, so we need to subtract them to get the result
34414 DD76 D360  30        movb @XX1,ra                    ; LDA XX1           ; Set XX15(2 1 0) = XX1(2 1 0) - XX12(1 0)
     DD78 0053     
34415                      .sec                            ; SEC               ; = (x_sign x_hi x_lo) - vertv_x
     **** ****     > SEC
0001 DD7A 0A18  18        sla  rmone,1
                   < elite.a99
34416                      .sbc @XX12,ra                   ; SBC XX12          ;
     **** ****     > SBC
0001 DD7C 1801  14        joc  !
0002 DD7E 7347  18        sb   rone,ra
0003               !:
0004 DD80 7360  30        sb   @XX12,ra
     DD82 0037     
                   < elite.a99
34417 DD84 D80D  30        movb ra,@XX15                   ; STA XX15          ; Starting with the low bytes
     DD86 0031     
34418               
34419 DD88 D360  30        movb @XX1+1,ra                  ; LDA XX1+1         ; And then doing the high bytes (we can subtract 0 here
     DD8A 0054     
34420                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_x is 0)
     **** ****     > SBI
0001 DD8C 1801  14        joc  !
0002 DD8E 7347  18        sb   rone,ra
0003               !:
0004 DD90 022D  22        ai   ra,-(>00*256)
     DD92 0000     
                   < elite.a99
34421 DD94 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     DD96 0032     
34422               
34423 DD98 1816  14        joc  LL53                       ; BCS LL53          ; If the subtraction didn't underflow, then the sign of
34424                                                                          ; the result is the same sign as x_sign, and that's what
34425                                                                          ; we want, so we can jump down to LL53 to do the
34426                                                                          ; y-coordinates
34427               
34428                      .eoi (>ff*256)                  ; EOR #%11111111    ; Otherwise we need to negate the result using two's
     **** ****     > EOI
0001 DD9A 0200  20        li   rtmp,(>FF*256)
     DD9C FF00     
0002 DD9E 2B40  18        xor  rtmp,ra
                   < elite.a99
34429 DDA0 D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; complement, so first we flip the bits of the high byte
     DDA2 0032     
34430               
34431 DDA4 020D  20        li   ra,>01*256                 ; LDA #1            ; And then subtract the low byte from 1
     DDA6 0100     
34432                      .sbc @XX15,ra                   ; SBC XX15
     **** ****     > SBC
0001 DDA8 1801  14        joc  !
0002 DDAA 7347  18        sb   rone,ra
0003               !:
0004 DDAC 7360  30        sb   @XX15,ra
     DDAE 0031     
                   < elite.a99
34433 DDB0 D80D  30        movb ra,@XX15                   ; STA XX15
     DDB2 0031     
34434               
34435 DDB4 1701  14        jnc  B113                       ; BCC B113          ; If the above subtraction underflowed then we need to
34436 DDB6 B347  18        ab   rone,ra                    ; INC XX15+1        ; bump the high byte of the result up by 1
34437               
34438               B113:
34439 DDB8 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; And now we flip the sign of the result to get the
     DDBA 0033     
34440                      .eoi (>80*256)                  ; EOR #%10000000    ; correct result
     **** ****     > EOI
0001 DDBC 0200  20        li   rtmp,(>80*256)
     DDBE 8000     
0002 DDC0 2B40  18        xor  rtmp,ra
                   < elite.a99
34441 DDC2 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     DDC4 0033     
34442               
34443               LL53:
34444                                                                          ; Now for the y-coordinates, vertv_y + y
34445 DDC6 D360  30        movb @XX1+5,ra                  ; LDA XX1+5         ; Set A = y_sign of the ship's location
     DDC8 0058     
34446               
34447 DDCA D80D  30        movb ra,@XX15+5                 ; STA XX15+5        ; Set XX15+5 = y_sign
     DDCC 0036     
34448               
34449                      .eor @XX12+3                    ; EOR XX12+3        ; If the sign of y_sign * the sign of vertv_y is
     **** ****     > EOR
0001 DDCE D020  30        movb @XX12+3,rtmp
     DDD0 003A     
0002 DDD2 2B40  18        xor  rtmp,ra
                   < elite.a99
34450 DDD4 1113  14        jlt  LL54                       ; BMI LL54          ; negative (i.e. they have different signs), skip to
34451                                                                          ; LL54
34452               
34453                      .clc                            ; CLC               ; Set XX15(5 4 3) = XX1(5 4 3) + XX12(3 2)
     **** ****     > CLC
0001 DDD6 0A16  18        sla  rzero,1
                   < elite.a99
34454 DDD8 D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; = (y_sign y_hi y_lo) + vertv_y
     DDDA 0039     
34455                      .adc @XX1+3,ra                  ; ADC XX1+3         ;
     **** ****     > ADC
0001 DDDC 1701  14        jnc  !
0002 DDDE B347  18        ab   rone,ra
0003               !:
0004 DDE0 B360  30        ab   @XX1+3,ra
     DDE2 0056     
                   < elite.a99
34456 DDE4 D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; Starting with the low bytes
     DDE6 0034     
34457               
34458 DDE8 D360  30        movb @XX1+4,ra                  ; LDA XX1+4         ; And then doing the high bytes (we can add 0 here as
     DDEA 0057     
34459                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_y is 0)
     **** ****     > ADI
0001 DDEC 1701  14        jnc  !
0002 DDEE B347  18        ab   rone,ra
0003               !:
0004 DDF0 022D  22        ai   ra,(>00*256)
     DDF2 0000     
                   < elite.a99
34460 DDF4 D80D  30        movb ra,@XX15+4                 ; STA XX15+4
     DDF6 0035     
34461               
34462 DDF8 0460  28        b    @LL55                      ; JMP LL55          ; We've added the y-coordinates, so jump to LL55 to do
     DDFA DE52     
34463                                                                          ; the z-coordinates
34464               
34465               LL54:
34466                                                                          ; If we get here then y_sign and vertv_y have different
34467                                                                          ; signs, so we need to subtract them to get the result
34468 DDFC D360  30        movb @XX1+3,ra                  ; LDA XX1+3         ; Set XX15(5 4 3) = XX1(5 4 3) - XX12(3 2)
     DDFE 0056     
34469                      .sec                            ; SEC               ; = (y_sign y_hi y_lo) - vertv_y
     **** ****     > SEC
0001 DE00 0A18  18        sla  rmone,1
                   < elite.a99
34470                      .sbc @XX12+2,ra                 ; SBC XX12+2        ;
     **** ****     > SBC
0001 DE02 1801  14        joc  !
0002 DE04 7347  18        sb   rone,ra
0003               !:
0004 DE06 7360  30        sb   @XX12+2,ra
     DE08 0039     
                   < elite.a99
34471 DE0A D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; Starting with the low bytes
     DE0C 0034     
34472               
34473 DE0E D360  30        movb @XX1+4,ra                  ; LDA XX1+4         ; And then doing the high bytes (we can subtract 0 here
     DE10 0057     
34474                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_z is 0)
     **** ****     > SBI
0001 DE12 1801  14        joc  !
0002 DE14 7347  18        sb   rone,ra
0003               !:
0004 DE16 022D  22        ai   ra,-(>00*256)
     DE18 0000     
                   < elite.a99
34475 DE1A D80D  30        movb ra,@XX15+4                 ; STA XX15+4
     DE1C 0035     
34476               
34477 DE1E 1819  14        joc  LL55                       ; BCS LL55          ; If the subtraction didn't underflow, then the sign of
34478                                                                          ; the result is the same sign as y_sign, and that's what
34479                                                                          ; we want, so we can jump down to LL55 to do the
34480                                                                          ; z-coordinates
34481               
34482                      .eoi (>ff*256)                  ; EOR #%11111111    ; Otherwise we need to negate the result using two's
     **** ****     > EOI
0001 DE20 0200  20        li   rtmp,(>FF*256)
     DE22 FF00     
0002 DE24 2B40  18        xor  rtmp,ra
                   < elite.a99
34483 DE26 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; complement, so first we flip the bits of the high byte
     DE28 0035     
34484               
34485 DE2A D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; And then flip the bits of the low byte and add 1
     DE2C 0034     
34486                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 DE2E 0200  20        li   rtmp,(>FF*256)
     DE30 FF00     
0002 DE32 2B40  18        xor  rtmp,ra
                   < elite.a99
34487                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 DE34 1701  14        jnc  !
0002 DE36 B347  18        ab   rone,ra
0003               !:
0004 DE38 022D  22        ai   ra,(>01*256)
     DE3A 0100     
                   < elite.a99
34488 DE3C D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     DE3E 0034     
34489               
34490 DE40 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; And now we flip the sign of the result to get the
     DE42 0036     
34491                      .eoi (>80*256)                  ; EOR #%10000000    ; correct result
     **** ****     > EOI
0001 DE44 0200  20        li   rtmp,(>80*256)
     DE46 8000     
0002 DE48 2B40  18        xor  rtmp,ra
                   < elite.a99
34492 DE4A D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     DE4C 0036     
34493               
34494 DE4E 1701  14        jnc  LL55                       ; BCC LL55          ; If the above subtraction underflowed then we need to
34495 DE50 B347  18        ab   rone,ra                    ; INC XX15+4        ; bump the high byte of the result up by 1
34496               
34497               LL55:
34498                                                                          ; Now for the z-coordinates, vertv_z + z
34499 DE52 D360  30        movb @XX12+5,ra                 ; LDA XX12+5        ; If vertv_z_hi is negative, jump down to LL56
     DE54 003C     
34500 DE56 1151  14        jlt  LL56                       ; BMI LL56
34501               
34502 DE58 D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set (U T) = XX1(7 6) + XX12(5 4)
     DE5A 003B     
34503                      .clc                            ; CLC               ; = (z_hi z_lo) + vertv_z
     **** ****     > CLC
0001 DE5C 0A16  18        sla  rzero,1
                   < elite.a99
34504                      .adc @XX1+6,ra                  ; ADC XX1+6         ;
     **** ****     > ADC
0001 DE5E 1701  14        jnc  !
0002 DE60 B347  18        ab   rone,ra
0003               !:
0004 DE62 B360  30        ab   @XX1+6,ra
     DE64 0059     
                   < elite.a99
34505 DE66 D80D  30        movb ra,@T                      ; STA T             ; Starting with the low bytes
     DE68 00D1     
34506               
34507 DE6A D360  30        movb @XX1+7,ra                  ; LDA XX1+7         ; And then doing the high bytes (we can add 0 here as
     DE6C 005A     
34508                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_y is 0)
     **** ****     > ADI
0001 DE6E 1701  14        jnc  !
0002 DE70 B347  18        ab   rone,ra
0003               !:
0004 DE72 022D  22        ai   ra,(>00*256)
     DE74 0000     
                   < elite.a99
34509 DE76 D80D  30        movb ra,@U                      ; STA U
     DE78 008F     
34510               
34511 DE7A 0460  28        b    @LL57                      ; JMP LL57          ; We've added the z-coordinates, so jump to LL57
     DE7C DF3A     
34512               
34513                                                                          ; The adding process is continued in part 7, after a
34514                                                                          ; couple of subroutines that we don't need quite yet
34515               
34516               * ******************************************************************************
34517               *
34518               * Name: LL61
34519               * Type: Subroutine
34520               * Category: Maths (Arithmetic)
34521               * Summary: Calculate (U R) = 256 * A / Q
34522               *
34523               * ------------------------------------------------------------------------------
34524               *
34525               * Calculate the following, where A >= Q:
34526               *
34527               * (U R) = 256 * A / Q
34528               *
34529               * This is a sister routine to LL28, which does the division when A < Q.
34530               *
34531               * ******************************************************************************
34532               
34533               LL61:
34534 DE7E D3A0  30        movb @Q,rx                      ; LDX Q             ; If Q = 0, jump down to LL84 to return a division
     DE80 0090     
34535 DE82 131F  14        jeq  LL84                       ; BEQ LL84          ; error
34536               
34537                                                                          ; The LL28 routine returns A / Q, but only if A < Q. In
34538                                                                          ; our case A >= Q, but we still want to use the LL28
34539                                                                          ; routine, so we halve A until it's less than Q, call
34540                                                                          ; the division routine, and then double A by the same
34541                                                                          ; number of times
34542               
34543 DE84 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0 to count the number of times we halve A
     DE86 0000     
34544               
34545               LL63:
34546 DE88 091D  18        srl  ra,1                       ; LSR A             ; Halve A by shifting right
34547               
34548 DE8A B387  18        ab   rone,rx                    ; INX               ; Increment X
34549               
34550 DE8C 9360  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, loop back to LL63 to halve it again
     DE8E 0090     
34551 DE90 18FB  14        joc  LL63                       ; BCS LL63
34552               
34553 DE92 D80E  30        movb rx,@S                      ; STX S             ; Otherwise store the number of times we halved A in S
     DE94 0092     
34554               
34555 DE96 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     DE98 D404     
34556 DE9A 06A0  32        bl   @jsr                       ;
     DE9C FE28     
34557                                                                          ;
34558                                                                          ; R = 256 * A / Q
34559                                                                          ;
34560                                                                          ; which we can do now as A < Q
34561               
34562 DE9E D3A0  30        movb @S,rx                      ; LDX S             ; Otherwise restore the number of times we halved A
     DEA0 0092     
34563                                                                          ; above into X
34564               
34565 DEA2 D360  30        movb @R,ra                      ; LDA R             ; Set A = our division result
     DEA4 0091     
34566               
34567               LL64:
34568                      .asla                           ; ASL A             ; Double (U A) by shifting left
     **** ****     > ASLA
0001 DEA6 024D  22        andi ra,>ff00
     DEA8 FF00     
0002 DEAA 0A1D  18        sla  ra,1
                   < elite.a99
34569 DEAC 0204  20        li   rarg1,U                    ; ROL U
     DEAE 008F     
34570 DEB0 06A0  32        bl   @rol                       ;
     DEB2 FE4E     
34571               
34572 DEB4 1106  14        jlt  LL84                       ; BMI LL84          ; If bit 7 of U is set, the doubling has overflowed, so
34573                                                                          ; jump to LL84 to return a division error
34574               
34575 DEB6 7387  18        sb   rone,rx                    ; DEX               ; Decrement X
34576               
34577 DEB8 16F6  14        jne  LL64                       ; BNE LL64          ; If X is not yet zero then we haven't done as many
34578                                                                          ; doublings as we did halvings earlier, so loop back for
34579                                                                          ; another doubling
34580               
34581 DEBA D80D  30        movb ra,@R                      ; STA R             ; Store the low byte of the division result in R
     DEBC 0091     
34582               
34583 DEBE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DEC0 FE34     
34584               
34585               LL84:
34586 DEC2 020D  20        li   ra,>32*256                 ; LDA #50           ; If we get here then either we tried to divide by 0, or
     DEC4 3200     
34587 DEC6 D80D  30        movb ra,@R                      ; STA R             ; the result overflowed, so we set U and R to 50
     DEC8 0091     
34588 DECA D80D  30        movb ra,@U                      ; STA U
     DECC 008F     
34589               
34590 DECE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DED0 FE34     
34591               
34592               * ******************************************************************************
34593               *
34594               * Name: LL62
34595               * Type: Subroutine
34596               * Category: Maths (Arithmetic)
34597               * Summary: Calculate 128 - (U R)
34598               *
34599               * ------------------------------------------------------------------------------
34600               *
34601               * Calculate the following for a positive sign-magnitude number (U R):
34602               *
34603               * 128 - (U R)
34604               *
34605               * and then store the result, low byte then high byte, on the end of the heap at
34606               * XX3, where X points to the first free byte on the heap. Return by jumping down
34607               * to LL66.
34608               *
34609               * ------------------------------------------------------------------------------
34610               *
34611               * Returns:
34612               *
34613               * X                   X is incremented by 1
34614               *
34615               * ******************************************************************************
34616               
34617               LL62:
34618 DED2 020D  20        li   ra,>80*256                 ; LDA #128          ; Calculate 128 - (U R), starting with the low bytes
     DED4 8000     
34619                      .sec                            ; SEC
     **** ****     > SEC
0001 DED6 0A18  18        sla  rmone,1
                   < elite.a99
34620                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 DED8 1801  14        joc  !
0002 DEDA 7347  18        sb   rone,ra
0003               !:
0004 DEDC 7360  30        sb   @R,ra
     DEDE 0091     
                   < elite.a99
34621               
34622 DEE0 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DEE2 0100     
34623                                                                          ; the heap at XX3
34624               
34625 DEE4 B387  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34626                                                                          ; byte
34627               
34628 DEE6 020D  20        li   ra,>00*256                 ; LDA #0            ; And then subtract the high bytes
     DEE8 0000     
34629                      .sbc @U,ra                      ; SBC U
     **** ****     > SBC
0001 DEEA 1801  14        joc  !
0002 DEEC 7347  18        sb   rone,ra
0003               !:
0004 DEEE 7360  30        sb   @U,ra
     DEF0 008F     
                   < elite.a99
34630               
34631 DEF2 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DEF4 0100     
34632                                                                          ; the heap at XX3
34633               
34634 DEF6 0460  28        b    @LL66                      ; JMP LL66          ; Jump down to LL66
     DEF8 DFD6     
34635               
34636               * ******************************************************************************
34637               *
34638               * Name: LL9 (Part 7 of 12)
34639               * Type: Subroutine
34640               * Category: Drawing ships
34641               * Summary: Draw ship: Calculate the visibility of each of the ship's vertices
34642               * Deep dive: Drawing ships
34643               * Calculating vertex coordinates
34644               *
34645               * ------------------------------------------------------------------------------
34646               *
34647               * This section continues the coordinate adding from part 6 by finishing off the
34648               * calculation that we started above:
34649               *
34650               * [ sidev_x roofv_x nosev_x ]   [ x ]   [ x ]
34651               * vector to vertex = [ sidev_y roofv_y nosev_y ] . [ y ] + [ y ]
34652               * [ sidev_z roofv_z nosev_z ]   [ z ]   [ z ]
34653               *
34654               * The gets stored as follows, in sign-magnitude values with the magnitudes
34655               * fitting into the low bytes:
34656               *
34657               * XX15(2 0)           [ x y z ] . [ sidev_x roofv_x nosev_x ] + [ x y z ]
34658               *
34659               * XX15(5 3)           [ x y z ] . [ sidev_y roofv_y nosev_y ] + [ x y z ]
34660               *
34661               * (U T)               [ x y z ] . [ sidev_z roofv_z nosev_z ] + [ x y z ]
34662               *
34663               * Finally, because this vector is from our ship to the vertex, and we are at the
34664               * origin, this vector is the same as the coordinates of the vertex. In other
34665               * words, we have just worked out:
34666               *
34667               * XX15(2 0)           x-coordinate of the current vertex
34668               *
34669               * XX15(5 3)           y-coordinate of the current vertex
34670               *
34671               * (U T)               z-coordinate of the current vertex
34672               *
34673               * ******************************************************************************
34674               
34675               LL56:
34676 DEFA D360  30        movb @XX1+6,ra                  ; LDA XX1+6         ; Set (U T) = XX1(7 6) - XX12(5 4)
     DEFC 0059     
34677                      .sec                            ; SEC               ; = (z_hi z_lo) - vertv_z
     **** ****     > SEC
0001 DEFE 0A18  18        sla  rmone,1
                   < elite.a99
34678                      .sbc @XX12+4,ra                 ; SBC XX12+4        ;
     **** ****     > SBC
0001 DF00 1801  14        joc  !
0002 DF02 7347  18        sb   rone,ra
0003               !:
0004 DF04 7360  30        sb   @XX12+4,ra
     DF06 003B     
                   < elite.a99
34679 DF08 D80D  30        movb ra,@T                      ; STA T             ; Starting with the low bytes
     DF0A 00D1     
34680               
34681 DF0C D360  30        movb @XX1+7,ra                  ; LDA XX1+7         ; And then doing the high bytes (we can subtract 0 here
     DF0E 005A     
34682                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_z is 0)
     **** ****     > SBI
0001 DF10 1801  14        joc  !
0002 DF12 7347  18        sb   rone,ra
0003               !:
0004 DF14 022D  22        ai   ra,-(>00*256)
     DF16 0000     
                   < elite.a99
34683 DF18 D80D  30        movb ra,@U                      ; STA U
     DF1A 008F     
34684               
34685 DF1C 1706  14        jnc  LL140                      ; BCC LL140         ; If the subtraction just underflowed, skip to LL140 to
34686                                                                          ; set (U T) to the minimum value of 4
34687               
34688 DF1E 160D  14        jne  LL57                       ; BNE LL57          ; If U is non-zero, jump down to LL57
34689               
34690 DF20 D360  30        movb @T,ra                      ; LDA T             ; If T >= 4, jump down to LL57
     DF22 00D1     
34691 DF24 028D  22        ci   ra,>04*256                 ; CMP #4
     DF26 0400     
34692 DF28 1808  14        joc  LL57                       ; BCS LL57
34693               
34694               LL140:
34695 DF2A 020D  20        li   ra,>00*256                 ; LDA #0            ; If we get here then either (U T) < 4 or the
     DF2C 0000     
34696 DF2E D80D  30        movb ra,@U                      ; STA U             ; subtraction underflowed, so set (U T) = 4
     DF30 008F     
34697 DF32 020D  20        li   ra,>04*256                 ; LDA #4
     DF34 0400     
34698 DF36 D80D  30        movb ra,@T                      ; STA T
     DF38 00D1     
34699               
34700               LL57:
34701                                                                          ; By this point we have our results, so now to scale
34702                                                                          ; the 16-bit results down into 8-bit values
34703 DF3A D360  30        movb @U,ra                      ; LDA U             ; If the high bytes of the result are all zero, we are
     DF3C 008F     
34704 DF3E F360  30        socb @XX15+1,ra                 ; ORA XX15+1        ; done, so jump down to LL60 for the next stage
     DF40 0032     
34705 DF42 F360  30        socb @XX15+4,ra                 ; ORA XX15+4
     DF44 0035     
34706 DF46 131D  14        jeq  LL60                       ; BEQ LL60
34707               
34708                      .lsr @XX15+1                    ; LSR XX15+1        ; Shift XX15(1 0) to the right
     **** ****     > LSR
0001 DF48 D020  30        movb @XX15+1,rtmp
     DF4A 0032     
0002 DF4C 0910  18        srl  rtmp,1
0003 DF4E D800  30        movb rtmp,@XX15+1
     DF50 0032     
                   < elite.a99
34709 DF52 0204  20        li   rarg1,XX15                 ; ROR XX15
     DF54 0031     
34710 DF56 06A0  32        bl   @ror                       ;
     DF58 FE7A     
34711               
34712                      .lsr @XX15+4                    ; LSR XX15+4        ; Shift XX15(4 3) to the right
     **** ****     > LSR
0001 DF5A D020  30        movb @XX15+4,rtmp
     DF5C 0035     
0002 DF5E 0910  18        srl  rtmp,1
0003 DF60 D800  30        movb rtmp,@XX15+4
     DF62 0035     
                   < elite.a99
34713 DF64 0204  20        li   rarg1,XX15+3               ; ROR XX15+3
     DF66 0034     
34714 DF68 06A0  32        bl   @ror                       ;
     DF6A FE7A     
34715               
34716                      .lsr @U                         ; LSR U             ; Shift (U T) to the right
     **** ****     > LSR
0001 DF6C D020  30        movb @U,rtmp
     DF6E 008F     
0002 DF70 0910  18        srl  rtmp,1
0003 DF72 D800  30        movb rtmp,@U
     DF74 008F     
                   < elite.a99
34717 DF76 0204  20        li   rarg1,T                    ; ROR T
     DF78 00D1     
34718 DF7A 06A0  32        bl   @ror                       ;
     DF7C FE7A     
34719               
34720 DF7E 0460  28        b    @LL57                      ; JMP LL57          ; Jump back to LL57 to see if we can shift the result
     DF80 DF3A     
34721                                                                          ; any more
34722               
34723               * ******************************************************************************
34724               *
34725               * Name: LL9 (Part 8 of 12)
34726               * Type: Subroutine
34727               * Category: Drawing ships
34728               * Summary: Draw ship: Calculate the screen coordinates of visible vertices
34729               * Deep dive: Drawing ships
34730               *
34731               * ------------------------------------------------------------------------------
34732               *
34733               * This section projects the coordinate of the vertex into screen coordinates and
34734               * stores them on the XX3 heap. By the end of this part, the XX3 heap contains
34735               * four bytes containing the 16-bit screen coordinates of the current vertex, in
34736               * the order: x_lo, x_hi, y_lo, y_hi.
34737               *
34738               * When we reach here, we are looping through the vertices, and we've just worked
34739               * out the coordinates of the vertex in our normal coordinate system, as follows
34740               *
34741               * XX15(2 0)           (x_sign x_lo) = x-coordinate of the current vertex
34742               *
34743               * XX15(5 3)           (y_sign y_lo) = y-coordinate of the current vertex
34744               *
34745               * (U T)               (z_sign z_lo) = z-coordinate of the current vertex
34746               *
34747               * Note that U is always zero when we get to this point, as the vertex is always
34748               * in front of us (so it has a positive z-coordinate, into the screen).
34749               *
34750               * ------------------------------------------------------------------------------
34751               *
34752               * Other entry points:
34753               *
34754               * LL70+1              Contains an RTS (as the first byte of an LDA
34755               * instruction)
34756               *
34757               * LL66                A re-entry point into the ship-drawing routine, used by
34758               * the LL62 routine to store 128 - (U R) on the XX3 heap
34759               *
34760               * ******************************************************************************
34761               
34762               LL60:
34763 DF82 D360  30        movb @T,ra                      ; LDA T             ; Set Q = z_lo
     DF84 00D1     
34764 DF86 D80D  30        movb ra,@Q                      ; STA Q
     DF88 0090     
34765               
34766 DF8A D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A = x_lo
     DF8C 0031     
34767               
34768 DF8E 9360  30        cb   @Q,ra                      ; CMP Q             ; If x_lo < z_lo jump to LL69
     DF90 0090     
34769 DF92 1706  14        jnc  LL69                       ; BCC LL69
34770               
34771 DF94 0200  20        li   rtmp,LL61                  ; JSR LL61          ; Call LL61 to calculate:
     DF96 DE7E     
34772 DF98 06A0  32        bl   @jsr                       ;
     DF9A FE28     
34773                                                                          ;
34774                                                                          ; (U R) = 256 * A / Q
34775                                                                          ; = 256 * x / z
34776                                                                          ;
34777                                                                          ; which we can do as x >= z
34778               
34779 DF9C 0460  28        b    @LL65                      ; JMP LL65          ; Jump to LL65 to skip the division for x_lo < z_lo
     DF9E DFA8     
34780               
34781               LL69:
34782 DFA0 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     DFA2 D404     
34783 DFA4 06A0  32        bl   @jsr                       ;
     DFA6 FE28     
34784                                                                          ;
34785                                                                          ; R = 256 * A / Q
34786                                                                          ; = 256 * x / z
34787                                                                          ;
34788                                                                          ; Because x < z, the result fits into one byte, and we
34789                                                                          ; also know that U = 0, so (U R) also contains the
34790                                                                          ; result
34791               
34792               LL65:
34793                                                                          ; At this point we have:
34794                                                                          ;
34795                                                                          ; (U R) = x / z
34796                                                                          ;
34797                                                                          ; so (U R) contains the vertex's x-coordinate projected
34798                                                                          ; on screen
34799                                                                          ;
34800                                                                          ; The next task is to convert (U R) to a pixel screen
34801                                                                          ; coordinate and stick it on the XX3 heap.
34802                                                                          ;
34803                                                                          ; We start with the x-coordinate. To convert the
34804                                                                          ; x-coordinate to a screen pixel we add 128, the
34805                                                                          ; x-coordinate of the centre of the screen, because the
34806                                                                          ; projected value is relative to an origin at the centre
34807                                                                          ; of the screen, but the origin of the screen pixels is
34808                                                                          ; at the top-left of the screen
34809 DFA8 D3A0  30        movb @CNT,rx                    ; LDX CNT           ; Fetch the pointer to the end of the XX3 heap from CNT
     DFAA 00A4     
34810                                                                          ; into X
34811               
34812 DFAC D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If x_sign is negative, jump up to LL62, which will
     DFAE 0033     
34813 DFB0 1190  14        jlt  LL62                       ; BMI LL62          ; store 128 - (U R) on the XX3 heap and return by
34814                                                                          ; jumping down to LL66 below
34815               
34816 DFB2 D360  30        movb @R,ra                      ; LDA R             ; Calculate 128 + (U R), starting with the low bytes
     DFB4 0091     
34817                      .clc                            ; CLC
     **** ****     > CLC
0001 DFB6 0A16  18        sla  rzero,1
                   < elite.a99
34818                      .adi (>80*256)                  ; ADC #128
     **** ****     > ADI
0001 DFB8 1701  14        jnc  !
0002 DFBA B347  18        ab   rone,ra
0003               !:
0004 DFBC 022D  22        ai   ra,(>80*256)
     DFBE 8000     
                   < elite.a99
34819               
34820 DFC0 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DFC2 0100     
34821                                                                          ; the heap at XX3
34822               
34823 DFC4 B387  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34824                                                                          ; byte
34825               
34826 DFC6 D360  30        movb @U,ra                      ; LDA U             ; And then add the high bytes
     DFC8 008F     
34827                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 DFCA 1701  14        jnc  !
0002 DFCC B347  18        ab   rone,ra
0003               !:
0004 DFCE 022D  22        ai   ra,(>00*256)
     DFD0 0000     
                   < elite.a99
34828               
34829 DFD2 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     DFD4 0100     
34830                                                                          ; the heap at XX3
34831               
34832               LL66:
34833                                                                          ; We've just stored the screen x-coordinate of the
34834                                                                          ; vertex on the XX3 heap, so now for the y-coordinate
34835 DFD6 D34E  18        movb rx,ra                      ; TXA               ; Store the heap pointer in X on the stack (at this
34836                      .pha                            ; PHA               ; it points to the last entry on the heap, not the first
     **** ****     > PHA
0001 DFD8 D68D  30        movb ra,*rsp
0002 DFDA 060A  14        dec  rsp
                   < elite.a99
34837                                                                          ; free byte)
34838               
34839 DFDC 020D  20        li   ra,>00*256                 ; LDA #0            ; Set U = 0
     DFDE 0000     
34840 DFE0 D80D  30        movb ra,@U                      ; STA U
     DFE2 008F     
34841               
34842 DFE4 D360  30        movb @T,ra                      ; LDA T             ; Set Q = z_lo
     DFE6 00D1     
34843 DFE8 D80D  30        movb ra,@Q                      ; STA Q
     DFEA 0090     
34844               
34845 DFEC D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set A = y_lo
     DFEE 0034     
34846               
34847 DFF0 9360  30        cb   @Q,ra                      ; CMP Q             ; If y_lo < z_lo jump to LL67
     DFF2 0090     
34848 DFF4 171A  14        jnc  LL67                       ; BCC LL67
34849               
34850 DFF6 0200  20        li   rtmp,LL61                  ; JSR LL61          ; Call LL61 to calculate:
     DFF8 DE7E     
34851 DFFA 06A0  32        bl   @jsr                       ;
     DFFC FE28     
34852                                                                          ;
34853                                                                          ; (U R) = 256 * A / Q
34854                                                                          ; = 256 * y / z
34855                                                                          ;
34856                                                                          ; which we can do as y >= z
34857               
34858 DFFE 0460  28        b    @LL68                      ; JMP LL68          ; Jump to LL68 to skip the division for y_lo < z_lo
     E000 E032     
34859               
34860               LL70:
34861                                                                          ; This gets called from below when y_sign is negative
34862 E002 020D  20        li   ra,(Y)*256                 ; LDA #Y            ; Calculate #Y + (U R), starting with the low bytes
     E004 6000     
34863                      .clc                            ; CLC
     **** ****     > CLC
0001 E006 0A16  18        sla  rzero,1
                   < elite.a99
34864                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 E008 1701  14        jnc  !
0002 E00A B347  18        ab   rone,ra
0003               !:
0004 E00C B360  30        ab   @R,ra
     E00E 0091     
                   < elite.a99
34865               
34866 E010 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     E012 0100     
34867                                                                          ; the heap at XX3
34868               
34869 E014 B387  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34870                                                                          ; byte
34871               
34872 E016 020D  20        li   ra,>00*256                 ; LDA #0            ; And then add the high bytes
     E018 0000     
34873                      .adc @U,ra                      ; ADC U
     **** ****     > ADC
0001 E01A 1701  14        jnc  !
0002 E01C B347  18        ab   rone,ra
0003               !:
0004 E01E B360  30        ab   @U,ra
     E020 008F     
                   < elite.a99
34874               
34875 E022 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     E024 0100     
34876                                                                          ; the heap at XX3
34877               
34878 E026 0460  28        b    @LL50                      ; JMP LL50          ; Jump to LL50 to move on to the next vertex
     E028 E064     
34879               
34880               LL67:
34881 E02A 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     E02C D404     
34882 E02E 06A0  32        bl   @jsr                       ;
     E030 FE28     
34883                                                                          ;
34884                                                                          ; R = 256 * A / Q
34885                                                                          ; = 256 * y / z
34886                                                                          ;
34887                                                                          ; Because y < z, the result fits into one byte, and we
34888                                                                          ; also know that U = 0, so (U R) also contains the
34889                                                                          ; result
34890               
34891               LL68:
34892                                                                          ; At this point we have:
34893                                                                          ;
34894                                                                          ; (U R) = y / z
34895                                                                          ;
34896                                                                          ; so (U R) contains the vertex's y-coordinate projected
34897                                                                          ; on screen
34898                                                                          ;
34899                                                                          ; We now want to convert this to a screen y-coordinate
34900                                                                          ; and stick it on the XX3 heap, much like we did with
34901                                                                          ; the x-coordinate above. Again, we convert the
34902                                                                          ; coordinate by adding or subtracting the y-coordinate
34903                                                                          ; of the centre of the screen, which is in the constant
34904                                                                          ; #Y, but this time we do the opposite, as a positive
34905                                                                          ; projected y-coordinate, i.e. up the space y-axis and
34906                                                                          ; up the screen, converts to a low y-coordinate, which
34907                                                                          ; is the opposite way round to the x-coordinates
34908                      .pla                            ; PLA               ; Restore the heap pointer from the stack into X
     **** ****     > PLA
0001 E032 058A  14        inc  rsp
0002 E034 D35A  26        movb *rsp,ra
                   < elite.a99
34909 E036 D38D  18        movb ra,rx                      ; TAX
34910               
34911 E038 B387  18        ab   rone,rx                    ; INX               ; When we stored the heap pointer, it pointed to the
34912                                                                          ; last entry on the heap, not the first free byte, so we
34913                                                                          ; increment it so it does point to the next free byte
34914               
34915 E03A D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; If y_sign is negative, jump up to LL70, which will
     E03C 0036     
34916 E03E 11E1  14        jlt  LL70                       ; BMI LL70          ; store #Y + (U R) on the XX3 heap and return by jumping
34917                                                                          ; down to LL50 below
34918               
34919 E040 020D  20        li   ra,(Y)*256                 ; LDA #Y            ; Calculate #Y - (U R), starting with the low bytes
     E042 6000     
34920                      .sec                            ; SEC
     **** ****     > SEC
0001 E044 0A18  18        sla  rmone,1
                   < elite.a99
34921                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 E046 1801  14        joc  !
0002 E048 7347  18        sb   rone,ra
0003               !:
0004 E04A 7360  30        sb   @R,ra
     E04C 0091     
                   < elite.a99
34922               
34923 E04E DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     E050 0100     
34924                                                                          ; the heap at XX3
34925               
34926 E052 B387  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34927                                                                          ; byte
34928               
34929 E054 020D  20        li   ra,>00*256                 ; LDA #0            ; And then subtract the high bytes
     E056 0000     
34930                      .sbc @U,ra                      ; SBC U
     **** ****     > SBC
0001 E058 1801  14        joc  !
0002 E05A 7347  18        sb   rone,ra
0003               !:
0004 E05C 7360  30        sb   @U,ra
     E05E 008F     
                   < elite.a99
34931               
34932 E060 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     E062 0100     
34933                                                                          ; the heap at XX3
34934               
34935               LL50:
34936                                                                          ; By the time we get here, the XX3 heap contains four
34937                                                                          ; bytes containing the screen coordinates of the current
34938                                                                          ; vertex, in the order: x_lo, x_hi, y_lo, y_hi
34939                      .clc                            ; CLC               ; Set CNT = CNT + 4, so the heap pointer points to the
     **** ****     > CLC
0001 E064 0A16  18        sla  rzero,1
                   < elite.a99
34940 E066 D360  30        movb @CNT,ra                    ; LDA CNT           ; next free byte on the heap
     E068 00A4     
34941                      .adi (>04*256)                  ; ADC #4
     **** ****     > ADI
0001 E06A 1701  14        jnc  !
0002 E06C B347  18        ab   rone,ra
0003               !:
0004 E06E 022D  22        ai   ra,(>04*256)
     E070 0400     
                   < elite.a99
34942 E072 D80D  30        movb ra,@CNT                    ; STA CNT
     E074 00A4     
34943               
34944 E076 D360  30        movb @XX17,ra                   ; LDA XX17          ; Set A to the offset of the current vertex's data,
     E078 0095     
34945                                                                          ; which we set in part 6
34946               
34947                      .adi (>06*256)                  ; ADC #6            ; Set Y = A + 6, so Y now points to the data for the
     **** ****     > ADI
0001 E07A 1701  14        jnc  !
0002 E07C B347  18        ab   rone,ra
0003               !:
0004 E07E 022D  22        ai   ra,(>06*256)
     E080 0600     
                   < elite.a99
34948 E082 D3CD  18        movb ra,ry                      ; TAY               ; next vertex
34949               
34950 E084 1805  14        joc  LL72                       ; BCS LL72          ; If the addition just overflowed, meaning we just tried
34951                                                                          ; to access vertex #43, jump to LL72, as the maximum
34952                                                                          ; number of vertices allowed is 42
34953               
34954 E086 9360  30        cb   @XX20,ra                   ; CMP XX20          ; If Y >= number of vertices * 6 (which we stored in
     E088 00A8     
34955 E08A 1802  14        joc  LL72                       ; BCS LL72          ; XX20 in part 6), jump to LL72, as we have processed
34956                                                                          ; all the vertices for this ship
34957               
34958 E08C 0460  28        b    @LL48                      ; JMP LL48          ; Loop back to LL48 in part 6 to calculate visibility
     E08E DC3C     
34959                                                                          ; and screen coordinates for the next vertex
34960               
34961               * ******************************************************************************
34962               *
34963               * Name: LL9 (Part 9 of 12)
34964               * Type: Subroutine
34965               * Category: Drawing ships
34966               * Summary: Draw ship: Draw laser beams if the ship is firing its laser at us
34967               * Deep dive: Drawing ships
34968               *
34969               * ------------------------------------------------------------------------------
34970               *
34971               * This part sets things up so we can loop through the edges in the next part. It
34972               * also adds a line to the ship line heap, if the ship is firing at us.
34973               *
34974               * When we get here, the heap at XX3 contains all the visible vertex screen
34975               * coordinates.
34976               *
34977               * ******************************************************************************
34978               
34979               LL72:
34980 E090 D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     E092 0072     
34981 E094 024D  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE31
     E096 2000     
34982 E098 1308  14        jeq  EE31                       ; BEQ EE31
34983               
34984 E09A D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; The ship is exploding, so set bit 3 of the ship's byte
     E09C 0072     
34985 E09E 026D  22        ori  ra,>08*256                 ; ORA #%00001000    ; #31 to denote that we are drawing something on-screen
     E0A0 0800     
34986 E0A2 D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; for this ship
     E0A4 0072     
34987               
34988 E0A6 0460  28        b    @DOEXP                     ; JMP DOEXP         ; Jump to DOEXP to display the explosion cloud,
     E0A8 A8AC     
34989                                                                          ; returning from the subroutine using a tail call
34990               
34991               EE31:
34992 E0AA 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; If bit 3 of the ship's byte #31 is clear, then there
     E0AC 0800     
34993                      .bit @XX1+31                    ; BIT XX1+31        ; is nothing already being shown for this ship, so skip
     **** ****     > BIT
0001 E0AE D020  30        movb @XX1+31,rtmp
     E0B0 0072     
0002 E0B2 0540  14        inv  rtmp
0003 E0B4 D047  18        movb rone,rtmp2
0004 E0B6 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
34994 E0B8 1306  14        jeq  LL74                       ; BEQ LL74          ; to LL74 as we don't need to erase anything from the
34995                                                                          ; screen
34996               
34997 E0BA 0200  20        li   rtmp,LL155                 ; JSR LL155         ; Otherwise call LL155 to draw the existing ship, which
     E0BC E3C4     
34998 E0BE 06A0  32        bl   @jsr                       ;
     E0C0 FE28     
34999                                                                          ; removes it from the screen
35000               
35001 E0C2 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; Set bit 3 of A so the next instruction sets bit 3 of
     E0C4 0800     
35002                                                                          ; the ship's byte #31 to denote that we are drawing
35003                                                                          ; something on-screen for this ship
35004               
35005               LL74:
35006 E0C6 F360  30        socb @XX1+31,ra                 ; ORA XX1+31        ; Apply bit 3 of A to the ship's byte #31, so if there
     E0C8 0072     
35007 E0CA D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; was no ship already on screen, the bit is clear,
     E0CC 0072     
35008                                                                          ; otherwise it is set
35009               
35010 E0CE 020F  20        li   ry,>09*256                 ; LDY #9            ; Fetch byte #9 of the ship's blueprint, which is the
     E0D0 0900     
35011                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of edges, and store it in XX20
     **** ****     > LD_IND_Y_IDX
0001 E0D2 D820  42        movb @XX0,@rtmplb
     E0D4 001E     
     E0D6 8301     
0002 E0D8 D020  30        movb @XX0+1,rtmp
     E0DA 001F     
0003 E0DC 06CF  14        swpb ry
0004 E0DE A00F  18        a    ry,rtmp
0005 E0E0 06CF  14        swpb ry
0006 E0E2 D350  26        movb *rtmp,RA
                   < elite.a99
35012 E0E4 D80D  30        movb ra,@XX20                   ; STA XX20
     E0E6 00A8     
35013               
35014 E0E8 020F  20        li   ry,>00*256                 ; LDY #0            ; We are about to step through all the edges, using Y
     E0EA 0000     
35015                                                                          ; as a counter
35016               
35017 E0EC D80F  30        movb ry,@U                      ; STY U             ; Set U = 0 (though we increment it to 1 below)
     E0EE 008F     
35018               
35019 E0F0 D80F  30        movb ry,@XX17                   ; STY XX17          ; Set XX17 = 0, which we are going to use as a counter
     E0F2 0095     
35020                                                                          ; for stepping through the ship's edges
35021               
35022 E0F4 B347  18        ab   rone,ra                    ; INC U             ; We are going to start calculating the lines we need to
35023                                                                          ; draw for this ship, and will store them in the ship
35024                                                                          ; line heap, using U to point to the end of the heap, so
35025                                                                          ; we start by setting U = 1
35026               
35027                      .bit @XX1+31                    ; BIT XX1+31        ; If bit 6 of the ship's byte #31 is clear, then the
     **** ****     > BIT
0001 E0F6 D020  30        movb @XX1+31,rtmp
     E0F8 0072     
0002 E0FA 0540  14        inv  rtmp
0003 E0FC D047  18        movb rone,rtmp2
0004 E0FE 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
35028 E100 196F  14        jno  LL170                      ; BVC LL170         ; ship is not firing its lasers, so jump to LL170 to
35029                                                                          ; skip the drawing of laser lines
35030               
35031                                                                          ; The ship is firing its laser at us, so we need to draw
35032                                                                          ; the laser lines
35033               
35034 E102 D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; Clear bit 6 of the ship's byte #31 so the ship doesn't
     E104 0072     
35035 E106 024D  22        andi ra,>bf*256                 ; AND #%10111111    ; keep firing endlessly
     E108 BF00     
35036 E10A D80D  30        movb ra,@XX1+31                 ; STA XX1+31
     E10C 0072     
35037               
35038 E10E 020F  20        li   ry,>06*256                 ; LDY #6            ; Fetch byte #6 of the ship's blueprint, which is the
     E110 0600     
35039                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number * 4 of the vertex where the ship has its lasers
     **** ****     > LD_IND_Y_IDX
0001 E112 D820  42        movb @XX0,@rtmplb
     E114 001E     
     E116 8301     
0002 E118 D020  30        movb @XX0+1,rtmp
     E11A 001F     
0003 E11C 06CF  14        swpb ry
0004 E11E A00F  18        a    ry,rtmp
0005 E120 06CF  14        swpb ry
0006 E122 D350  26        movb *rtmp,RA
                   < elite.a99
35040               
35041 E124 D3CD  18        movb ra,ry                      ; TAY               ; Put the vertex number into Y, where it can act as an
35042                                                                          ; index into list of vertex screen coordinates we added
35043                                                                          ; to the XX3 heap
35044               
35045 E126 D3AF  34        movb @XX3(ry),rx                ; LDX XX3,Y         ; Fetch the x_lo coordinate of the laser vertex from the
     E128 0100     
35046 E12A D80E  30        movb rx,@XX15                   ; STX XX15          ; XX3 heap into XX15
     E12C 0031     
35047               
35048 E12E B387  18        ab   rone,rx                    ; INX               ; If X = 255 then the laser vertex is not visible, as
35049 E130 1357  14        jeq  LL170                      ; BEQ LL170         ; the value we stored in part 2 wasn't overwritten by
35050                                                                          ; the vertex calculation in part 6 and 7, so jump to
35051                                                                          ; LL170 to skip drawing the laser lines
35052               
35053                                                                          ; We now build a laser beam from the ship's laser vertex
35054                                                                          ; towards our ship, as follows:
35055                                                                          ;
35056                                                                          ; XX15(1 0) = laser vertex x-coordinate
35057                                                                          ;
35058                                                                          ; XX15(3 2) = laser vertex y-coordinate
35059                                                                          ;
35060                                                                          ; XX15(5 4) = x-coordinate of the end of the beam
35061                                                                          ;
35062                                                                          ; XX12(1 0) = y-coordinate of the end of the beam
35063                                                                          ;
35064                                                                          ; The end of the laser beam will be positioned to look
35065                                                                          ; good, rather than being directly aimed at us, as
35066                                                                          ; otherwise we would only see a flashing point of light
35067                                                                          ; as they unleashed their attack
35068               
35069 E132 D3AF  34        movb @XX3+1(ry),rx              ; LDX XX3+1,Y       ; Fetch the x_hi coordinate of the laser vertex from the
     E134 0101     
35070 E136 D80E  30        movb rx,@XX15+1                 ; STX XX15+1        ; XX3 heap into XX15+1
     E138 0032     
35071               
35072 E13A B387  18        ab   rone,rx                    ; INX               ; If X = 255 then the laser vertex is not visible, as
35073 E13C 1351  14        jeq  LL170                      ; BEQ LL170         ; the value we stored in part 2 wasn't overwritten by
35074                                                                          ; a vertex calculation in part 6 and 7, so jump to LL170
35075                                                                          ; to skip drawing the laser beam
35076               
35077 E13E D3AF  34        movb @XX3+2(ry),rx              ; LDX XX3+2,Y       ; Fetch the y_lo coordinate of the laser vertex from the
     E140 0102     
35078 E142 D80E  30        movb rx,@XX15+2                 ; STX XX15+2        ; XX3 heap into XX15+2
     E144 0033     
35079               
35080 E146 D3AF  34        movb @XX3+3(ry),rx              ; LDX XX3+3,Y       ; Fetch the y_hi coordinate of the laser vertex from the
     E148 0103     
35081 E14A D80E  30        movb rx,@XX15+3                 ; STX XX15+3        ; XX3 heap into XX15+3
     E14C 0034     
35082               
35083 E14E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set XX15(5 4) = 0, so their laser beam fires to the
     E150 0000     
35084 E152 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; left edge of the screen
     E154 0035     
35085 E156 D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     E158 0036     
35086               
35087 E15A D80D  30        movb ra,@XX12+1                 ; STA XX12+1        ; Set XX12(1 0) = the ship's z_lo coordinate, which will
     E15C 0038     
35088 E15E D360  30        movb @XX1+6,ra                  ; LDA XX1+6         ; effectively make the vertical position of the end of
     E160 0059     
35089 E162 D80D  30        movb ra,@XX12                   ; STA XX12          ; the laser beam move around as the ship moves in space
     E164 0037     
35090               
35091 E166 D360  30        movb @XX1+2,ra                  ; LDA XX1+2         ; If the ship's x_sign is positive, skip the next
     E168 0055     
35092 E16A 1501  14        jgt  B114                       ; BPL B114          ; instruction
35093               
35094 E16C 7347  18        sb   rone,ra                    ; DEC XX15+4        ; The ship's x_sign is negative (i.e. it's on the left
35095                                                                          ; side of the screen), so switch the laser beam so it
35096                                                                          ; goes to the right edge of the screen by decrementing
35097                                                                          ; XX15(5 4) to 255
35098               
35099               B114:
35100 E16E 0200  20        li   rtmp,LL145                 ; JSR LL145         ; Call LL145 to see if the laser beam needs to be
     E170 E6E8     
35101 E172 06A0  32        bl   @jsr                       ;
     E174 FE28     
35102                                                                          ; clipped to fit on-screen, returning the clipped line's
35103                                                                          ; end-points in (X1, Y1) and (X2, Y2)
35104               
35105 E176 1834  14        joc  LL170                      ; BCS LL170         ; If the C flag is set then the line is not visible on
35106                                                                          ; screen, so jump to LL170 so we don't store this line
35107                                                                          ; in the ship line heap
35108               
35109 E178 D3E0  30        movb @U,ry                      ; LDY U             ; Fetch the ship line heap pointer, which points to the
     E17A 008F     
35110                                                                          ; next free byte on the heap, into Y
35111               
35112 E17C D360  30        movb @XX15,ra                   ; LDA XX15          ; Add X1 to the end of the heap
     E17E 0031     
35113                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E180 D820  42        movb @XX19,@rtmplb
     E182 0074     
     E184 8301     
0002 E186 D020  30        movb @XX19+1,rtmp
     E188 0075     
0003 E18A 06CF  14        swpb ry
0004 E18C A00F  18        a    ry,rtmp
0005 E18E 06CF  14        swpb ry
0006 E190 D40D  30        movb RA,*rtmp
                   < elite.a99
35114               
35115 E192 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35116               
35117 E194 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Add Y1 to the end of the heap
     E196 0032     
35118                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E198 D820  42        movb @XX19,@rtmplb
     E19A 0074     
     E19C 8301     
0002 E19E D020  30        movb @XX19+1,rtmp
     E1A0 0075     
0003 E1A2 06CF  14        swpb ry
0004 E1A4 A00F  18        a    ry,rtmp
0005 E1A6 06CF  14        swpb ry
0006 E1A8 D40D  30        movb RA,*rtmp
                   < elite.a99
35119               
35120 E1AA B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35121               
35122 E1AC D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Add X2 to the end of the heap
     E1AE 0033     
35123                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E1B0 D820  42        movb @XX19,@rtmplb
     E1B2 0074     
     E1B4 8301     
0002 E1B6 D020  30        movb @XX19+1,rtmp
     E1B8 0075     
0003 E1BA 06CF  14        swpb ry
0004 E1BC A00F  18        a    ry,rtmp
0005 E1BE 06CF  14        swpb ry
0006 E1C0 D40D  30        movb RA,*rtmp
                   < elite.a99
35124               
35125 E1C2 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35126               
35127 E1C4 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Add Y2 to the end of the heap
     E1C6 0034     
35128                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E1C8 D820  42        movb @XX19,@rtmplb
     E1CA 0074     
     E1CC 8301     
0002 E1CE D020  30        movb @XX19+1,rtmp
     E1D0 0075     
0003 E1D2 06CF  14        swpb ry
0004 E1D4 A00F  18        a    ry,rtmp
0005 E1D6 06CF  14        swpb ry
0006 E1D8 D40D  30        movb RA,*rtmp
                   < elite.a99
35129               
35130 E1DA B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35131               
35132 E1DC D80F  30        movb ry,@U                      ; STY U             ; Store the updated ship line heap pointer in U
     E1DE 008F     
35133               
35134               * ******************************************************************************
35135               *
35136               * Name: LL9 (Part 10 of 12)
35137               * Type: Subroutine
35138               * Category: Drawing ships
35139               * Summary: Draw ship: Calculate the visibility of each of the ship's edges
35140               * Deep dive: Drawing ships
35141               *
35142               * ------------------------------------------------------------------------------
35143               *
35144               * This part calculates which edges are visible - in other words, which lines we
35145               * should draw - and clips them to fit on the screen.
35146               *
35147               * When we get here, the heap at XX3 contains all the visible vertex screen
35148               * coordinates.
35149               *
35150               * ******************************************************************************
35151               
35152               LL170:
35153 E1E0 020F  20        li   ry,>03*256                 ; LDY #3            ; Fetch byte #3 of the ship's blueprint, which contains
     E1E2 0300     
35154                      .clc                            ; CLC               ; the low byte of the offset to the edges data
     **** ****     > CLC
0001 E1E4 0A16  18        sla  rzero,1
                   < elite.a99
35155                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y
     **** ****     > LD_IND_Y_IDX
0001 E1E6 D820  42        movb @XX0,@rtmplb
     E1E8 001E     
     E1EA 8301     
0002 E1EC D020  30        movb @XX0+1,rtmp
     E1EE 001F     
0003 E1F0 06CF  14        swpb ry
0004 E1F2 A00F  18        a    ry,rtmp
0005 E1F4 06CF  14        swpb ry
0006 E1F6 D350  26        movb *rtmp,RA
                   < elite.a99
35156               
35157                      .adc @XX0,ra                    ; ADC XX0           ; Set V = low byte edges offset + XX0
     **** ****     > ADC
0001 E1F8 1701  14        jnc  !
0002 E1FA B347  18        ab   rone,ra
0003               !:
0004 E1FC B360  30        ab   @XX0,ra
     E1FE 001E     
                   < elite.a99
35158 E200 D80D  30        movb ra,@V                      ; STA V
     E202 0022     
35159               
35160 E204 020F  20        li   ry,>10*256                 ; LDY #16           ; Fetch byte #16 of the ship's blueprint, which contains
     E206 1000     
35161                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the high byte of the offset to the edges data
     **** ****     > LD_IND_Y_IDX
0001 E208 D820  42        movb @XX0,@rtmplb
     E20A 001E     
     E20C 8301     
0002 E20E D020  30        movb @XX0+1,rtmp
     E210 001F     
0003 E212 06CF  14        swpb ry
0004 E214 A00F  18        a    ry,rtmp
0005 E216 06CF  14        swpb ry
0006 E218 D350  26        movb *rtmp,RA
                   < elite.a99
35162               
35163                      .adc @XX0+1,ra                  ; ADC XX0+1         ; Set V+1 = high byte edges offset + XX0+1
     **** ****     > ADC
0001 E21A 1701  14        jnc  !
0002 E21C B347  18        ab   rone,ra
0003               !:
0004 E21E B360  30        ab   @XX0+1,ra
     E220 001F     
                   < elite.a99
35164 E222 D80D  30        movb ra,@V+1                    ; STA V+1           ;
     E224 0023     
35165                                                                          ; So V(1 0) now points to the start of the edges data
35166                                                                          ; for this ship
35167               
35168 E226 020F  20        li   ry,>05*256                 ; LDY #5            ; Fetch byte #5 of the ship's blueprint, which contains
     E228 0500     
35169                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the maximum heap size for plotting the ship (which is
     **** ****     > LD_IND_Y_IDX
0001 E22A D820  42        movb @XX0,@rtmplb
     E22C 001E     
     E22E 8301     
0002 E230 D020  30        movb @XX0+1,rtmp
     E232 001F     
0003 E234 06CF  14        swpb ry
0004 E236 A00F  18        a    ry,rtmp
0005 E238 06CF  14        swpb ry
0006 E23A D350  26        movb *rtmp,RA
                   < elite.a99
35170 E23C D80D  30        movb ra,@T1                     ; STA T1            ; 1 + 4 * the maximum number of visible edges) and store
     E23E 0006     
35171                                                                          ; it in T1
35172               
35173 E240 D3E0  30        movb @XX17,ry                   ; LDY XX17          ; Set Y to the edge counter in XX17
     E242 0095     
35174               
35175               LL75:
35176                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this edge, which contains the
     **** ****     > LD_IND_Y_IDX
0001 E244 D820  42        movb @V,@rtmplb
     E246 0022     
     E248 8301     
0002 E24A D020  30        movb @V+1,rtmp
     E24C 0023     
0003 E24E 06CF  14        swpb ry
0004 E250 A00F  18        a    ry,rtmp
0005 E252 06CF  14        swpb ry
0006 E254 D350  26        movb *rtmp,RA
                   < elite.a99
35177                                                                          ; visibility distance for this edge, beyond which the
35178                                                                          ; edge is not shown
35179               
35180 E256 9360  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 > the visibility distance, where XX4 contains
     E258 00A7     
35181 E25A 1802  14        joc  FIX011                     ; BCS FIX011        ; the ship's z-distance reduced to 0-31 (which we set in
35182 E25C 0460  28        b    @LL78                      ; JMP LL78          ; part 2), then this edge is too far away to be visible,
     E25E E382     
35183                                                                          ; so jump down to LL78 to move on to the next edge
35184               FIX011:
35185 E260 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
35186               
35187                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this edge into A, so:
     **** ****     > LD_IND_Y_IDX
0001 E262 D820  42        movb @V,@rtmplb
     E264 0022     
     E266 8301     
0002 E268 D020  30        movb @V+1,rtmp
     E26A 0023     
0003 E26C 06CF  14        swpb ry
0004 E26E A00F  18        a    ry,rtmp
0005 E270 06CF  14        swpb ry
0006 E272 D350  26        movb *rtmp,RA
                   < elite.a99
35188                                                                          ;
35189                                                                          ; A = %ffff ffff, where:
35190                                                                          ;
35191                                                                          ; * Bits 0-3 = the number of face 1
35192                                                                          ;
35193                                                                          ; * Bits 4-7 = the number of face 2
35194               
35195 E274 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
35196               
35197 E276 D80D  30        movb ra,@P                      ; STA P             ; Store byte #1 into P
     E278 001B     
35198               
35199 E27A 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     E27C 0F00     
35200 E27E D38D  18        movb ra,rx                      ; TAX
35201               
35202 E280 D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     E282 00D2     
35203 E284 160A  14        jne  LL79                       ; BNE LL79          ; face 1 is visible, so jump to LL79
35204               
35205 E286 D360  30        movb @P,ra                      ; LDA P             ; Fetch byte #1 for this edge into A
     E288 001B     
35206               
35207 E28A 091D  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 2
35208 E28C 091D  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
35209 E28E 091D  18        srl  ra,1                       ; LSR A
35210 E290 091D  18        srl  ra,1                       ; LSR A
35211 E292 D38D  18        movb ra,rx                      ; TAX
35212               
35213 E294 D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is zero then we decided in part 5 that
     E296 00D2     
35214 E298 1374  14        jeq  LL78                       ; BEQ LL78          ; face 2 is hidden, so jump to LL78
35215               
35216               LL79:
35217                                                                          ; We now build the screen line for this edge, as
35218                                                                          ; follows:
35219                                                                          ;
35220                                                                          ; XX15(1 0) = start x-coordinate
35221                                                                          ;
35222                                                                          ; XX15(3 2) = start y-coordinate
35223                                                                          ;
35224                                                                          ; XX15(5 4) = end x-coordinate
35225                                                                          ;
35226                                                                          ; XX12(1 0) = end y-coordinate
35227                                                                          ;
35228                                                                          ; We can then pass this to the line clipping routine
35229                                                                          ; before storing the resulting line in the ship line
35230                                                                          ; heap
35231                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this edge into X, which contains
     **** ****     > LD_IND_Y_IDX
0001 E29A D820  42        movb @V,@rtmplb
     E29C 0022     
     E29E 8301     
0002 E2A0 D020  30        movb @V+1,rtmp
     E2A2 0023     
0003 E2A4 06CF  14        swpb ry
0004 E2A6 A00F  18        a    ry,rtmp
0005 E2A8 06CF  14        swpb ry
0006 E2AA D350  26        movb *rtmp,RA
                   < elite.a99
35232 E2AC D38D  18        movb ra,rx                      ; TAX               ; the number of the vertex at the start of the edge
35233               
35234 E2AE B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
35235               
35236                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this edge into Q, which contains
     **** ****     > LD_IND_Y_IDX
0001 E2B0 D820  42        movb @V,@rtmplb
     E2B2 0022     
     E2B4 8301     
0002 E2B6 D020  30        movb @V+1,rtmp
     E2B8 0023     
0003 E2BA 06CF  14        swpb ry
0004 E2BC A00F  18        a    ry,rtmp
0005 E2BE 06CF  14        swpb ry
0006 E2C0 D350  26        movb *rtmp,RA
                   < elite.a99
35237 E2C2 D80D  30        movb ra,@Q                      ; STA Q             ; the number of the vertex at the end of the edge
     E2C4 0090     
35238               
35239 E2C6 D36E  34        movb @XX3+1(rx),ra              ; LDA XX3+1,X       ; Fetch the x_hi coordinate of the edge's start vertex
     E2C8 0101     
35240 E2CA D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; from the XX3 heap into XX15+1
     E2CC 0032     
35241               
35242 E2CE D36E  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Fetch the x_lo coordinate of the edge's start vertex
     E2D0 0100     
35243 E2D2 D80D  30        movb ra,@XX15                   ; STA XX15          ; from the XX3 heap into XX15
     E2D4 0031     
35244               
35245 E2D6 D36E  34        movb @XX3+2(rx),ra              ; LDA XX3+2,X       ; Fetch the y_lo coordinate of the edge's start vertex
     E2D8 0102     
35246 E2DA D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; from the XX3 heap into XX15+2
     E2DC 0033     
35247               
35248 E2DE D36E  34        movb @XX3+3(rx),ra              ; LDA XX3+3,X       ; Fetch the y_hi coordinate of the edge's start vertex
     E2E0 0103     
35249 E2E2 D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; from the XX3 heap into XX15+3
     E2E4 0034     
35250               
35251 E2E6 D3A0  30        movb @Q,rx                      ; LDX Q             ; Set X to the number of the vertex at the end of the
     E2E8 0090     
35252                                                                          ; edge, which we stored in Q
35253               
35254 E2EA D36E  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Fetch the x_lo coordinate of the edge's end vertex
     E2EC 0100     
35255 E2EE D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; from the XX3 heap into XX15+4
     E2F0 0035     
35256               
35257 E2F2 D36E  34        movb @XX3+3(rx),ra              ; LDA XX3+3,X       ; Fetch the y_hi coordinate of the edge's end vertex
     E2F4 0103     
35258 E2F6 D80D  30        movb ra,@XX12+1                 ; STA XX12+1        ; from the XX3 heap into XX12+1
     E2F8 0038     
35259               
35260 E2FA D36E  34        movb @XX3+2(rx),ra              ; LDA XX3+2,X       ; Fetch the y_lo coordinate of the edge's end vertex
     E2FC 0102     
35261 E2FE D80D  30        movb ra,@XX12                   ; STA XX12          ; from the XX3 heap into XX12
     E300 0037     
35262               
35263 E302 D36E  34        movb @XX3+1(rx),ra              ; LDA XX3+1,X       ; Fetch the x_hi coordinate of the edge's end vertex
     E304 0101     
35264 E306 D80D  30        movb ra,@XX15+5                 ; STA XX15+5        ; from the XX3 heap into XX15+5
     E308 0036     
35265               
35266 E30A 0200  20        li   rtmp,LL147                 ; JSR LL147         ; Call LL147 to see if the new line segment needs to be
     E30C E6F4     
35267 E30E 06A0  32        bl   @jsr                       ;
     E310 FE28     
35268                                                                          ; clipped to fit on-screen, returning the clipped line's
35269                                                                          ; end-points in (X1, Y1) and (X2, Y2)
35270               
35271 E312 1837  14        joc  LL78                       ; BCS LL78          ; If the C flag is set then the line is not visible on
35272                                                                          ; screen, so jump to LL78 so we don't store this line
35273                                                                          ; in the ship line heap
35274               
35275               * ******************************************************************************
35276               *
35277               * Name: LL9 (Part 11 of 12)
35278               * Type: Subroutine
35279               * Category: Drawing ships
35280               * Summary: Draw ship: Add all visible edges to the ship line heap
35281               * Deep dive: Drawing ships
35282               *
35283               * ------------------------------------------------------------------------------
35284               *
35285               * This part adds all the visible edges to the ship line heap, so we can draw
35286               * them in part 12.
35287               *
35288               * Other entry points:
35289               *
35290               * LL81+2              Draw the contents of the ship line heap, used to draw
35291               * the ship as a dot from SHPPT
35292               *
35293               * ******************************************************************************
35294               
35295               LL80:
35296 E314 D3E0  30        movb @U,ry                      ; LDY U             ; Fetch the ship line heap pointer, which points to the
     E316 008F     
35297                                                                          ; next free byte on the heap, into Y
35298               
35299 E318 D360  30        movb @XX15,ra                   ; LDA XX15          ; Add X1 to the end of the heap
     E31A 0031     
35300                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E31C D820  42        movb @XX19,@rtmplb
     E31E 0074     
     E320 8301     
0002 E322 D020  30        movb @XX19+1,rtmp
     E324 0075     
0003 E326 06CF  14        swpb ry
0004 E328 A00F  18        a    ry,rtmp
0005 E32A 06CF  14        swpb ry
0006 E32C D40D  30        movb RA,*rtmp
                   < elite.a99
35301               
35302 E32E B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35303               
35304 E330 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Add Y1 to the end of the heap
     E332 0032     
35305                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E334 D820  42        movb @XX19,@rtmplb
     E336 0074     
     E338 8301     
0002 E33A D020  30        movb @XX19+1,rtmp
     E33C 0075     
0003 E33E 06CF  14        swpb ry
0004 E340 A00F  18        a    ry,rtmp
0005 E342 06CF  14        swpb ry
0006 E344 D40D  30        movb RA,*rtmp
                   < elite.a99
35306               
35307 E346 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35308               
35309 E348 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Add X2 to the end of the heap
     E34A 0033     
35310                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E34C D820  42        movb @XX19,@rtmplb
     E34E 0074     
     E350 8301     
0002 E352 D020  30        movb @XX19+1,rtmp
     E354 0075     
0003 E356 06CF  14        swpb ry
0004 E358 A00F  18        a    ry,rtmp
0005 E35A 06CF  14        swpb ry
0006 E35C D40D  30        movb RA,*rtmp
                   < elite.a99
35311               
35312 E35E B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35313               
35314 E360 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Add Y2 to the end of the heap
     E362 0034     
35315                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E364 D820  42        movb @XX19,@rtmplb
     E366 0074     
     E368 8301     
0002 E36A D020  30        movb @XX19+1,rtmp
     E36C 0075     
0003 E36E 06CF  14        swpb ry
0004 E370 A00F  18        a    ry,rtmp
0005 E372 06CF  14        swpb ry
0006 E374 D40D  30        movb RA,*rtmp
                   < elite.a99
35316               
35317 E376 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35318               
35319 E378 D80F  30        movb ry,@U                      ; STY U             ; Store the updated ship line heap pointer in U
     E37A 008F     
35320               
35321 E37C 93E0  30        cb   @T1,ry                     ; CPY T1            ; If Y >= T1 then we have reached the maximum number of
     E37E 0006     
35322 E380 1814  14        joc  LL81                       ; BCS LL81          ; edge lines that we can store in the ship line heap, so
35323                                                                          ; skip to LL81 so we don't loop back for the next edge
35324               
35325               LL78:
35326 E382 B347  18        ab   rone,ra                    ; INC XX17          ; Increment the edge counter to point to the next edge
35327               
35328 E384 D3E0  30        movb @XX17,ry                   ; LDY XX17          ; If Y >= XX20, which contains the number of edges in
     E386 0095     
35329 E388 93E0  30        cb   @XX20,ry                   ; CPY XX20          ; the blueprint, jump to LL81 as we have processed all
     E38A 00A8     
35330 E38C 180E  14        joc  LL81                       ; BCS LL81          ; the edges and don't need to loop back for the next one
35331               
35332 E38E 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y to point to byte #0 again, ready for the next
     E390 0000     
35333                                                                          ; edge
35334               
35335 E392 D360  30        movb @V,ra                      ; LDA V             ; Increment V by 4 so V(1 0) points to the data for the
     E394 0022     
35336                      .adi (>04*256)                  ; ADC #4            ; next edge
     **** ****     > ADI
0001 E396 1701  14        jnc  !
0002 E398 B347  18        ab   rone,ra
0003               !:
0004 E39A 022D  22        ai   ra,(>04*256)
     E39C 0400     
                   < elite.a99
35337 E39E D80D  30        movb ra,@V                      ; STA V
     E3A0 0022     
35338               
35339 E3A2 1701  14        jnc  ll81_                      ; BCC ll81          ; If the above addition didn't overflow, jump to ll81 to
35340                                                                          ; skip the following instruction
35341               
35342 E3A4 B347  18        ab   rone,ra                    ; INC V+1           ; Otherwise increment the high byte of V(1 0), as we
35343                                                                          ; just moved the V(1 0) pointer past a page boundary
35344               
35345               ll81_:
35346 E3A6 0460  28        b    @LL75                      ; JMP LL75          ; Loop back to LL75 to process the next edge
     E3A8 E244     
35347               
35348               LL81:
35349                                                                          ; We have finished adding lines to the ship line heap,
35350                                                                          ; so now we need to set the first byte of the heap to
35351                                                                          ; the number of bytes stored there
35352 E3AA D360  30        movb @U,ra                      ; LDA U             ; Fetch the ship line heap pointer from U into A, which
     E3AC 008F     
35353                                                                          ; points to the end of the heap, and therefore contains
35354                                                                          ; the heap size
35355               
35356 E3AE 020F  20        li   ry,>00*256                 ; LDY #0            ; Store A as the first byte of the ship line heap, so
     E3B0 0000     
35357                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; the heap is now correctly set up
     **** ****     > ST_IND_Y_IDX
0001 E3B2 D820  42        movb @XX19,@rtmplb
     E3B4 0074     
     E3B6 8301     
0002 E3B8 D020  30        movb @XX19+1,rtmp
     E3BA 0075     
0003 E3BC 06CF  14        swpb ry
0004 E3BE A00F  18        a    ry,rtmp
0005 E3C0 06CF  14        swpb ry
0006 E3C2 D40D  30        movb RA,*rtmp
                   < elite.a99
35358               
35359               * ******************************************************************************
35360               *
35361               * Name: LL9 (Part 12 of 12)
35362               * Type: Subroutine
35363               * Category: Drawing ships
35364               * Summary: Draw ship: Draw all the visible edges from the ship line heap
35365               * Deep dive: Drawing ships
35366               *
35367               * ------------------------------------------------------------------------------
35368               *
35369               * This part draws the lines in the ship line heap, which is used both to draw
35370               * the ship, and to remove it from the screen.
35371               *
35372               * ******************************************************************************
35373               
35374               LL155:
35375 E3C4 020F  20        li   ry,>00*256                 ; LDY #0            ; Fetch the first byte from the ship line heap into A,
     E3C6 0000     
35376                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; which contains the number of bytes in the heap
     **** ****     > LD_IND_Y_IDX
0001 E3C8 D820  42        movb @XX19,@rtmplb
     E3CA 0074     
     E3CC 8301     
0002 E3CE D020  30        movb @XX19+1,rtmp
     E3D0 0075     
0003 E3D2 06CF  14        swpb ry
0004 E3D4 A00F  18        a    ry,rtmp
0005 E3D6 06CF  14        swpb ry
0006 E3D8 D350  26        movb *rtmp,RA
                   < elite.a99
35377               
35378 E3DA D80D  30        movb ra,@XX20                   ; STA XX20          ; Store the heap size in XX20
     E3DC 00A8     
35379               
35380 E3DE 028D  22        ci   ra,>04*256                 ; CMP #4            ; If the heap size is less than 4, there is nothing to
     E3E0 0400     
35381 E3E2 1739  14        jnc  LL118-1                    ; BCC LL118-1       ; draw, so return from the subroutine (as LL118-1
35382                                                                          ; contains an RTS)
35383               
35384 E3E4 B3C7  18        ab   rone,ry                    ; INY               ; Set Y = 1, which we will use as an index into the ship
35385                                                                          ; line heap, starting at byte #1 (as byte #0 contains
35386                                                                          ; the heap size)
35387               
35388               LL27:
35389                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the X1 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 E3E6 D820  42        movb @XX19,@rtmplb
     E3E8 0074     
     E3EA 8301     
0002 E3EC D020  30        movb @XX19+1,rtmp
     E3EE 0075     
0003 E3F0 06CF  14        swpb ry
0004 E3F2 A00F  18        a    ry,rtmp
0005 E3F4 06CF  14        swpb ry
0006 E3F6 D350  26        movb *rtmp,RA
                   < elite.a99
35390 E3F8 D80D  30        movb ra,@XX15                   ; STA XX15          ; it in XX15
     E3FA 0031     
35391               
35392 E3FC B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35393               
35394                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y1 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 E3FE D820  42        movb @XX19,@rtmplb
     E400 0074     
     E402 8301     
0002 E404 D020  30        movb @XX19+1,rtmp
     E406 0075     
0003 E408 06CF  14        swpb ry
0004 E40A A00F  18        a    ry,rtmp
0005 E40C 06CF  14        swpb ry
0006 E40E D350  26        movb *rtmp,RA
                   < elite.a99
35395 E410 D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; it in XX15+1
     E412 0032     
35396               
35397 E414 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35398               
35399                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the X2 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 E416 D820  42        movb @XX19,@rtmplb
     E418 0074     
     E41A 8301     
0002 E41C D020  30        movb @XX19+1,rtmp
     E41E 0075     
0003 E420 06CF  14        swpb ry
0004 E422 A00F  18        a    ry,rtmp
0005 E424 06CF  14        swpb ry
0006 E426 D350  26        movb *rtmp,RA
                   < elite.a99
35400 E428 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; it in XX15+2
     E42A 0033     
35401               
35402 E42C B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35403               
35404                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y2 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 E42E D820  42        movb @XX19,@rtmplb
     E430 0074     
     E432 8301     
0002 E434 D020  30        movb @XX19+1,rtmp
     E436 0075     
0003 E438 06CF  14        swpb ry
0004 E43A A00F  18        a    ry,rtmp
0005 E43C 06CF  14        swpb ry
0006 E43E D350  26        movb *rtmp,RA
                   < elite.a99
35405 E440 D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; it in XX15+3
     E442 0034     
35406               
35407 E444 0200  20        li   rtmp,LL30                  ; JSR LL30          ; Draw a line from (X1, Y1) to (X2, Y2)
     E446 2272     
35408 E448 06A0  32        bl   @jsr                       ;
     E44A FE28     
35409               
35410 E44C B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35411               
35412 E44E 93E0  30        cb   @XX20,ry                   ; CPY XX20          ; If the heap counter is less than the size of the heap,
     E450 00A8     
35413 E452 17C9  14        jnc  LL27                       ; BCC LL27          ; loop back to LL27 to draw the next line from the heap
35414               
35415               * .LL82                  \ This label is commented out in the original source
35416               
35417 E454 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E456 FE34     
35418               
35419               * ******************************************************************************
35420               *
35421               * Name: LL118
35422               * Type: Subroutine
35423               * Category: Drawing lines
35424               * Summary: Move a point along a line until it is on-screen
35425               * Deep dive: Line-clipping
35426               *
35427               * ------------------------------------------------------------------------------
35428               *
35429               * Given a point (x1, y1), a gradient and a direction of slope, move the point
35430               * along the line until it is on-screen, so this effectively clips the (x1, y1)
35431               * end of a line to be on the screen.
35432               *
35433               * See the deep dive on "Line-clipping" for more details.
35434               *
35435               * ------------------------------------------------------------------------------
35436               *
35437               * Arguments:
35438               *
35439               * XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
35440               *
35441               * XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
35442               *
35443               * XX12+2              The line's gradient * 256 (so 1.0 = 256)
35444               *
35445               * XX12+3              The direction of slope:
35446               *
35447               * * Positive (bit 7 clear) = top left to bottom right
35448               *
35449               * * Negative (bit 7 set) = top right to bottom left
35450               *
35451               * T                   The gradient of slope:
35452               *
35453               * * 0 if it's a shallow slope
35454               *
35455               * * &FF if it's a steep slope
35456               *
35457               * ------------------------------------------------------------------------------
35458               *
35459               * Returns:
35460               *
35461               * XX15                x1 as an 8-bit coordinate
35462               *
35463               * XX15+2              y1 as an 8-bit coordinate
35464               *
35465               * ------------------------------------------------------------------------------
35466               *
35467               * Other entry points:
35468               *
35469               * LL118-1             Contains an RTS
35470               *
35471               * ******************************************************************************
35472               
35473               LL118:
35474 E458 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If x1_hi is positive, jump down to LL119 to skip the
     E45A 0032     
35475 E45C 151C  14        jgt  LL119                      ; BPL LL119         ; following
35476               
35477 E45E D80D  30        movb ra,@S                      ; STA S             ; Otherwise x1_hi is negative, i.e. off the left of the
     E460 0092     
35478                                                                          ; screen, so set S = x1_hi
35479               
35480 E462 0200  20        li   rtmp,LL120                 ; JSR LL120         ; Call LL120 to calculate:
     E464 E574     
35481 E466 06A0  32        bl   @jsr                       ;
     E468 FE28     
35482                                                                          ;
35483                                                                          ; (Y X) = (S x1_lo) * XX12+2      if T = 0
35484                                                                          ; = x1 * gradient
35485                                                                          ;
35486                                                                          ; (Y X) = (S x1_lo) / XX12+2      if T <> 0
35487                                                                          ; = x1 / gradient
35488                                                                          ;
35489                                                                          ; with the sign of (Y X) set to the opposite of the
35490                                                                          ; line's direction of slope
35491               
35492 E46A D34E  18        movb rx,ra                      ; TXA               ; Set y1 = y1 + (Y X)
35493                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E46C 0A16  18        sla  rzero,1
                   < elite.a99
35494                      .adc @XX15+2,ra                 ; ADC XX15+2        ; starting with the low bytes
     **** ****     > ADC
0001 E46E 1701  14        jnc  !
0002 E470 B347  18        ab   rone,ra
0003               !:
0004 E472 B360  30        ab   @XX15+2,ra
     E474 0033     
                   < elite.a99
35495 E476 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     E478 0033     
35496               
35497 E47A D34F  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35498                      .adc @XX15+3,ra                 ; ADC XX15+3
     **** ****     > ADC
0001 E47C 1701  14        jnc  !
0002 E47E B347  18        ab   rone,ra
0003               !:
0004 E480 B360  30        ab   @XX15+3,ra
     E482 0034     
                   < elite.a99
35499 E484 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E486 0034     
35500               
35501 E488 020D  20        li   ra,>00*256                 ; LDA #0            ; Set x1 = 0
     E48A 0000     
35502 E48C D80D  30        movb ra,@XX15                   ; STA XX15
     E48E 0031     
35503 E490 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E492 0032     
35504               
35505 E494 D38D  18        movb ra,rx                      ; TAX               ; Set X = 0 so the next instruction becomes a JMP
35506               
35507               LL119:
35508 E496 131D  14        jeq  LL134                      ; BEQ LL134         ; If x1_hi = 0 then jump down to LL134 to skip the
35509                                                                          ; following, as the x-coordinate is already on-screen
35510                                                                          ; (as 0 <= (x_hi x_lo) <= 255)
35511               
35512 E498 D80D  30        movb ra,@S                      ; STA S             ; Otherwise x1_hi is positive, i.e. x1 >= 256 and off
     E49A 0092     
35513 E49C 7347  18        sb   rone,ra                    ; DEC S             ; the right side of the screen, so set S = x1_hi - 1
35514               
35515 E49E 0200  20        li   rtmp,LL120                 ; JSR LL120         ; Call LL120 to calculate:
     E4A0 E574     
35516 E4A2 06A0  32        bl   @jsr                       ;
     E4A4 FE28     
35517                                                                          ;
35518                                                                          ; (Y X) = (S x1_lo) * XX12+2      if T = 0
35519                                                                          ; = (x1 - 256) * gradient
35520                                                                          ;
35521                                                                          ; (Y X) = (S x1_lo) / XX12+2      if T <> 0
35522                                                                          ; = (x1 - 256) / gradient
35523                                                                          ;
35524                                                                          ; with the sign of (Y X) set to the opposite of the
35525                                                                          ; line's direction of slope
35526               
35527 E4A6 D34E  18        movb rx,ra                      ; TXA               ; Set y1 = y1 + (Y X)
35528                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E4A8 0A16  18        sla  rzero,1
                   < elite.a99
35529                      .adc @XX15+2,ra                 ; ADC XX15+2        ; starting with the low bytes
     **** ****     > ADC
0001 E4AA 1701  14        jnc  !
0002 E4AC B347  18        ab   rone,ra
0003               !:
0004 E4AE B360  30        ab   @XX15+2,ra
     E4B0 0033     
                   < elite.a99
35530 E4B2 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     E4B4 0033     
35531               
35532 E4B6 D34F  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35533                      .adc @XX15+3,ra                 ; ADC XX15+3
     **** ****     > ADC
0001 E4B8 1701  14        jnc  !
0002 E4BA B347  18        ab   rone,ra
0003               !:
0004 E4BC B360  30        ab   @XX15+3,ra
     E4BE 0034     
                   < elite.a99
35534 E4C0 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E4C2 0034     
35535               
35536 E4C4 020E  20        li   rx,>ff*256                 ; LDX #255          ; Set x1 = 255
     E4C6 FF00     
35537 E4C8 D80E  30        movb rx,@XX15                   ; STX XX15
     E4CA 0031     
35538 E4CC B387  18        ab   rone,rx                    ; INX
35539 E4CE D80E  30        movb rx,@XX15+1                 ; STX XX15+1
     E4D0 0032     
35540               
35541               LL134:
35542                                                                          ; We have moved the point so the x-coordinate is on
35543                                                                          ; screen (i.e. in the range 0-255), so now for the
35544                                                                          ; y-coordinate
35545 E4D2 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; If y1_hi is positive, jump down to LL119 to skip
     E4D4 0034     
35546 E4D6 151F  14        jgt  LL135                      ; BPL LL135         ; the following
35547               
35548 E4D8 D80D  30        movb ra,@S                      ; STA S             ; Otherwise y1_hi is negative, i.e. off the top of the
     E4DA 0092     
35549                                                                          ; screen, so set S = y1_hi
35550               
35551 E4DC D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set R = y1_lo
     E4DE 0033     
35552 E4E0 D80D  30        movb ra,@R                      ; STA R
     E4E2 0091     
35553               
35554 E4E4 0200  20        li   rtmp,LL123                 ; JSR LL123         ; Call LL123 to calculate:
     E4E6 E600     
35555 E4E8 06A0  32        bl   @jsr                       ;
     E4EA FE28     
35556                                                                          ;
35557                                                                          ; (Y X) = (S R) / XX12+2      if T = 0
35558                                                                          ; = y1 / gradient
35559                                                                          ;
35560                                                                          ; (Y X) = (S R) * XX12+2      if T <> 0
35561                                                                          ; = y1 * gradient
35562                                                                          ;
35563                                                                          ; with the sign of (Y X) set to the opposite of the
35564                                                                          ; line's direction of slope
35565               
35566 E4EC D34E  18        movb rx,ra                      ; TXA               ; Set x1 = x1 + (Y X)
35567                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E4EE 0A16  18        sla  rzero,1
                   < elite.a99
35568                      .adc @XX15,ra                   ; ADC XX15          ; starting with the low bytes
     **** ****     > ADC
0001 E4F0 1701  14        jnc  !
0002 E4F2 B347  18        ab   rone,ra
0003               !:
0004 E4F4 B360  30        ab   @XX15,ra
     E4F6 0031     
                   < elite.a99
35569 E4F8 D80D  30        movb ra,@XX15                   ; STA XX15
     E4FA 0031     
35570               
35571 E4FC D34F  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35572                      .adc @XX15+1,ra                 ; ADC XX15+1
     **** ****     > ADC
0001 E4FE 1701  14        jnc  !
0002 E500 B347  18        ab   rone,ra
0003               !:
0004 E502 B360  30        ab   @XX15+1,ra
     E504 0032     
                   < elite.a99
35573 E506 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E508 0032     
35574               
35575 E50A 020D  20        li   ra,>00*256                 ; LDA #0            ; Set y1 = 0
     E50C 0000     
35576 E50E D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     E510 0033     
35577 E512 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E514 0034     
35578               
35579               LL135:
35580               * BNE LL139              \ This instruction is commented out in the original
35581                                                                          ; source
35582 E516 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set (S R) = (y1_hi y1_lo) - screen height
     E518 0033     
35583                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 E51A 0A18  18        sla  rmone,1
                   < elite.a99
35584                      .sbi ((Y*2)*256)                ; SBC #Y*2          ; starting with the low bytes
     **** ****     > SBI
0001 E51C 1801  14        joc  !
0002 E51E 7347  18        sb   rone,ra
0003               !:
0004 E520 022D  22        ai   ra,-((Y*2)*256)
     E522 4000     
                   < elite.a99
35585 E524 D80D  30        movb ra,@R                      ; STA R
     E526 0091     
35586               
35587 E528 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; And then subtracting the high bytes
     E52A 0034     
35588                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 E52C 1801  14        joc  !
0002 E52E 7347  18        sb   rone,ra
0003               !:
0004 E530 022D  22        ai   ra,-(>00*256)
     E532 0000     
                   < elite.a99
35589 E534 D80D  30        movb ra,@S                      ; STA S
     E536 0092     
35590               
35591 E538 171B  14        jnc  LL136                      ; BCC LL136         ; If the subtraction underflowed, i.e. if y1 < screen
35592                                                                          ; height, then y1 is already on-screen, so jump to LL136
35593                                                                          ; to return from the subroutine, as we are done
35594               
35595               LL139:
35596                                                                          ; If we get here then y1 >= screen height, i.e. off the
35597                                                                          ; bottom of the screen
35598 E53A 0200  20        li   rtmp,LL123                 ; JSR LL123         ; Call LL123 to calculate:
     E53C E600     
35599 E53E 06A0  32        bl   @jsr                       ;
     E540 FE28     
35600                                                                          ;
35601                                                                          ; (Y X) = (S R) / XX12+2      if T = 0
35602                                                                          ; = (y1 - screen height) / gradient
35603                                                                          ;
35604                                                                          ; (Y X) = (S R) * XX12+2      if T <> 0
35605                                                                          ; = (y1 - screen height) * gradient
35606                                                                          ;
35607                                                                          ; with the sign of (Y X) set to the opposite of the
35608                                                                          ; line's direction of slope
35609               
35610 E542 D34E  18        movb rx,ra                      ; TXA               ; Set x1 = x1 + (Y X)
35611                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E544 0A16  18        sla  rzero,1
                   < elite.a99
35612                      .adc @XX15,ra                   ; ADC XX15          ; starting with the low bytes
     **** ****     > ADC
0001 E546 1701  14        jnc  !
0002 E548 B347  18        ab   rone,ra
0003               !:
0004 E54A B360  30        ab   @XX15,ra
     E54C 0031     
                   < elite.a99
35613 E54E D80D  30        movb ra,@XX15                   ; STA XX15
     E550 0031     
35614               
35615 E552 D34F  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35616                      .adc @XX15+1,ra                 ; ADC XX15+1
     **** ****     > ADC
0001 E554 1701  14        jnc  !
0002 E556 B347  18        ab   rone,ra
0003               !:
0004 E558 B360  30        ab   @XX15+1,ra
     E55A 0032     
                   < elite.a99
35617 E55C D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E55E 0032     
35618               
35619 E560 020D  20        li   ra,(Y*2-1)*256             ; LDA #Y*2-1        ; Set y1 = 2 * #Y - 1. The constant #Y is 96, the
     E562 BF00     
35620 E564 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; y-coordinate of the mid-point of the space view, so
     E566 0033     
35621 E568 020D  20        li   ra,>00*256                 ; LDA #0            ; this sets Y2 to 191, the y-coordinate of the bottom
     E56A 0000     
35622 E56C D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; pixel row of the space view
     E56E 0034     
35623               
35624               LL136:
35625 E570 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E572 FE34     
35626               
35627               * ******************************************************************************
35628               *
35629               * Name: LL120
35630               * Type: Subroutine
35631               * Category: Maths (Arithmetic)
35632               * Summary: Calculate (Y X) = (S x1_lo) * XX12+2 or (S x1_lo) / XX12+2
35633               *
35634               * ------------------------------------------------------------------------------
35635               *
35636               * Calculate the following:
35637               *
35638               * * If T = 0, this is a shallow slope, so calculate (Y X) = (S x1_lo) * XX12+2
35639               *
35640               * * If T <> 0, this is a steep slope, so calculate (Y X) = (S x1_lo) / XX12+2
35641               *
35642               * giving (Y X) the opposite sign to the slope direction in XX12+3.
35643               *
35644               * ------------------------------------------------------------------------------
35645               *
35646               * Arguments:
35647               *
35648               * T                   The gradient of slope:
35649               *
35650               * * 0 if it's a shallow slope
35651               *
35652               * * &FF if it's a steep slope
35653               *
35654               * ------------------------------------------------------------------------------
35655               *
35656               * Other entry points:
35657               *
35658               * LL122               Calculate (Y X) = (S R) * Q and set the sign to the
35659               * opposite of the top byte on the stack
35660               *
35661               * ******************************************************************************
35662               
35663               LL120:
35664 E574 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set R = x1_lo
     E576 0031     
35665 E578 D80D  30        movb ra,@R                      ; STA R
     E57A 0091     
35666               
35667               * .LL120                 \ This label is commented out in the original source
35668               
35669 E57C 0200  20        li   rtmp,LL129                 ; JSR LL129         ; Call LL129 to do the following:
     E57E E6A0     
35670 E580 06A0  32        bl   @jsr                       ;
     E582 FE28     
35671                                                                          ;
35672                                                                          ; Q = XX12+2
35673                                                                          ; = line gradient
35674                                                                          ;
35675                                                                          ; A = S EOR XX12+3
35676                                                                          ; = S EOR slope direction
35677                                                                          ;
35678                                                                          ; (S R) = |S R|
35679                                                                          ;
35680                                                                          ; So A contains the sign of S * slope direction
35681               
35682                      .pha                            ; PHA               ; Store A on the stack so we can use it later
     **** ****     > PHA
0001 E584 D68D  30        movb ra,*rsp
0002 E586 060A  14        dec  rsp
                   < elite.a99
35683               
35684 E588 D3A0  30        movb @T,rx                      ; LDX T             ; If T is non-zero, then it's a steep slope, so jump
     E58A 00D1     
35685 E58C 1642  14        jne  LL121                      ; BNE LL121         ; down to LL121 to calculate this instead:
35686                                                                          ;
35687                                                                          ; (Y X) = (S R) / Q
35688               
35689               LL122:
35690                                                                          ; The following calculates:
35691                                                                          ;
35692                                                                          ; (Y X) = (S R) * Q
35693                                                                          ;
35694                                                                          ; using the same shift-and-add algorithm that's
35695                                                                          ; documented in MULT1
35696 E58E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     E590 0000     
35697               
35698 E592 D38D  18        movb ra,rx                      ; TAX               ; Set (Y X) = 0 so we can start building the answer here
35699 E594 D3CD  18        movb ra,ry                      ; TAY
35700               
35701                      .lsr @S                         ; LSR S             ; Shift (S R) to the right, so we extract bit 0 of (S R)
     **** ****     > LSR
0001 E596 D020  30        movb @S,rtmp
     E598 0092     
0002 E59A 0910  18        srl  rtmp,1
0003 E59C D800  30        movb rtmp,@S
     E59E 0092     
                   < elite.a99
35702 E5A0 0204  20        li   rarg1,R                    ; ROR R             ; into the C flag
     E5A2 0091     
35703 E5A4 06A0  32        bl   @ror                       ;
     E5A6 FE7A     
35704               
35705                      .asl @Q                         ; ASL Q             ; Shift Q to the left, catching bit 7 in the C flag
     **** ****     > ASL
0001 E5A8 D020  30        movb @Q,rtmp
     E5AA 0090     
0002 E5AC 0240  22        andi rtmp,>ff00
     E5AE FF00     
0003 E5B0 0A10  18        sla  rtmp,1
0004 E5B2 D800  30        movb rtmp,@Q
     E5B4 0090     
                   < elite.a99
35706               
35707 E5B6 170D  14        jnc  LL126                      ; BCC LL126         ; If C (i.e. the next bit from Q) is clear, do not do
35708                                                                          ; the addition for this bit of Q, and instead skip to
35709                                                                          ; LL126 to just do the shifts
35710               
35711               LL125:
35712 E5B8 D34E  18        movb rx,ra                      ; TXA               ; Set (Y X) = (Y X) + (S R)
35713                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E5BA 0A16  18        sla  rzero,1
                   < elite.a99
35714                      .adc @R,ra                      ; ADC R             ; starting with the low bytes
     **** ****     > ADC
0001 E5BC 1701  14        jnc  !
0002 E5BE B347  18        ab   rone,ra
0003               !:
0004 E5C0 B360  30        ab   @R,ra
     E5C2 0091     
                   < elite.a99
35715 E5C4 D38D  18        movb ra,rx                      ; TAX
35716               
35717 E5C6 D34F  18        movb ry,ra                      ; TYA               ; And then doing the high bytes
35718                      .adc @S,ra                      ; ADC S
     **** ****     > ADC
0001 E5C8 1701  14        jnc  !
0002 E5CA B347  18        ab   rone,ra
0003               !:
0004 E5CC B360  30        ab   @S,ra
     E5CE 0092     
                   < elite.a99
35719 E5D0 D3CD  18        movb ra,ry                      ; TAY
35720               
35721               LL126:
35722                      .lsr @S                         ; LSR S             ; Shift (S R) to the right
     **** ****     > LSR
0001 E5D2 D020  30        movb @S,rtmp
     E5D4 0092     
0002 E5D6 0910  18        srl  rtmp,1
0003 E5D8 D800  30        movb rtmp,@S
     E5DA 0092     
                   < elite.a99
35723 E5DC 0204  20        li   rarg1,R                    ; ROR R
     E5DE 0091     
35724 E5E0 06A0  32        bl   @ror                       ;
     E5E2 FE7A     
35725               
35726                      .asl @Q                         ; ASL Q             ; Shift Q to the left, catching bit 7 in the C flag
     **** ****     > ASL
0001 E5E4 D020  30        movb @Q,rtmp
     E5E6 0090     
0002 E5E8 0240  22        andi rtmp,>ff00
     E5EA FF00     
0003 E5EC 0A10  18        sla  rtmp,1
0004 E5EE D800  30        movb rtmp,@Q
     E5F0 0090     
                   < elite.a99
35727               
35728 E5F2 18E2  14        joc  LL125                      ; BCS LL125         ; If C (i.e. the next bit from Q) is set, loop back to
35729                                                                          ; LL125 to do the addition for this bit of Q
35730               
35731 E5F4 16EE  14        jne  LL126                      ; BNE LL126         ; If Q has not yet run out of set bits, loop back to
35732                                                                          ; LL126 to do the "shift" part of shift-and-add until
35733                                                                          ; we have done additions for all the set bits in Q, to
35734                                                                          ; give us our multiplication result
35735               
35736                      .pla                            ; PLA               ; Restore A, which we calculated above, from the stack
     **** ****     > PLA
0001 E5F6 058A  14        inc  rsp
0002 E5F8 D35A  26        movb *rsp,ra
                   < elite.a99
35737               
35738 E5FA 153E  14        jgt  LL133                      ; BPL LL133         ; If A is positive jump to LL133 to negate (Y X) and
35739                                                                          ; return from the subroutine using a tail call
35740               
35741 E5FC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E5FE FE34     
35742               
35743               * ******************************************************************************
35744               *
35745               * Name: LL123
35746               * Type: Subroutine
35747               * Category: Maths (Arithmetic)
35748               * Summary: Calculate (Y X) = (S R) / XX12+2 or (S R) * XX12+2
35749               *
35750               * ------------------------------------------------------------------------------
35751               *
35752               * Calculate the following:
35753               *
35754               * * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2
35755               *
35756               * * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2
35757               *
35758               * giving (Y X) the opposite sign to the slope direction in XX12+3.
35759               *
35760               * ------------------------------------------------------------------------------
35761               *
35762               * Arguments:
35763               *
35764               * XX12+2              The line's gradient * 256 (so 1.0 = 256)
35765               *
35766               * XX12+3              The direction of slope:
35767               *
35768               * * Bit 7 clear means top left to bottom right
35769               *
35770               * * Bit 7 set means top right to bottom left
35771               *
35772               * T                   The gradient of slope:
35773               *
35774               * * 0 if it's a shallow slope
35775               *
35776               * * &FF if it's a steep slope
35777               *
35778               * ------------------------------------------------------------------------------
35779               *
35780               * Other entry points:
35781               *
35782               * LL121               Calculate (Y X) = (S R) / Q and set the sign to the
35783               * opposite of the top byte on the stack
35784               *
35785               * LL133               Negate (Y X) and return from the subroutine
35786               *
35787               * LL128               Contains an RTS
35788               *
35789               * ******************************************************************************
35790               
35791               LL123:
35792 E600 0200  20        li   rtmp,LL129                 ; JSR LL129         ; Call LL129 to do the following:
     E602 E6A0     
35793 E604 06A0  32        bl   @jsr                       ;
     E606 FE28     
35794                                                                          ;
35795                                                                          ; Q = XX12+2
35796                                                                          ; = line gradient
35797                                                                          ;
35798                                                                          ; A = S EOR XX12+3
35799                                                                          ; = S EOR slope direction
35800                                                                          ;
35801                                                                          ; (S R) = |S R|
35802                                                                          ;
35803                                                                          ; So A contains the sign of S * slope direction
35804               
35805                      .pha                            ; PHA               ; Store A on the stack so we can use it later
     **** ****     > PHA
0001 E608 D68D  30        movb ra,*rsp
0002 E60A 060A  14        dec  rsp
                   < elite.a99
35806               
35807 E60C D3A0  30        movb @T,rx                      ; LDX T             ; If T is non-zero, then it's a steep slope, so jump up
     E60E 00D1     
35808 E610 16BE  14        jne  LL122                      ; BNE LL122         ; to LL122 to calculate this instead:
35809                                                                          ;
35810                                                                          ; (Y X) = (S R) * Q
35811               
35812               LL121:
35813                                                                          ; The following calculates:
35814                                                                          ;
35815                                                                          ; (Y X) = (S R) / Q
35816                                                                          ;
35817                                                                          ; using the same shift-and-subtract algorithm that's
35818                                                                          ; documented in TIS2
35819 E612 020D  20        li   ra,>ff*256                 ; LDA #%11111111    ; Set Y = %11111111
     E614 FF00     
35820 E616 D3CD  18        movb ra,ry                      ; TAY
35821               
35822                      .asla                           ; ASL A             ; Set X = %11111110
     **** ****     > ASLA
0001 E618 024D  22        andi ra,>ff00
     E61A FF00     
0002 E61C 0A1D  18        sla  ra,1
                   < elite.a99
35823 E61E D38D  18        movb ra,rx                      ; TAX
35824               
35825                                                                          ; This sets (Y X) = %1111111111111110, so we can rotate
35826                                                                          ; through 15 loop iterations, getting a 1 each time, and
35827                                                                          ; then getting a 0 on the 16th iteration... and we can
35828                                                                          ; also use it to catch our result bits into bit 0 each
35829                                                                          ; time
35830               
35831               LL130:
35832                      .asl @R                         ; ASL R             ; Shift (S R) to the left
     **** ****     > ASL
0001 E620 D020  30        movb @R,rtmp
     E622 0091     
0002 E624 0240  22        andi rtmp,>ff00
     E626 FF00     
0003 E628 0A10  18        sla  rtmp,1
0004 E62A D800  30        movb rtmp,@R
     E62C 0091     
                   < elite.a99
35833 E62E 0204  20        li   rarg1,S                    ; ROL S
     E630 0092     
35834 E632 06A0  32        bl   @rol                       ;
     E634 FE4E     
35835               
35836 E636 D360  30        movb @S,ra                      ; LDA S             ; Set A = S
     E638 0092     
35837               
35838 E63A 1803  14        joc  LL131                      ; BCS LL131         ; If bit 7 of S was set, then jump straight to the
35839                                                                          ; subtraction
35840               
35841 E63C 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q (i.e. S < Q), skip the following subtractions
     E63E 0090     
35842 E640 170F  14        jnc  LL132                      ; BCC LL132
35843               
35844               LL131:
35845                      .sbc @Q,ra                      ; SBC Q             ; A >= Q (i.e. S >= Q) so set:
     **** ****     > SBC
0001 E642 1801  14        joc  !
0002 E644 7347  18        sb   rone,ra
0003               !:
0004 E646 7360  30        sb   @Q,ra
     E648 0090     
                   < elite.a99
35846 E64A D80D  30        movb ra,@S                      ; STA S             ;
     E64C 0092     
35847                                                                          ; S = (A R) - Q
35848                                                                          ; = (S R) - Q
35849                                                                          ;
35850                                                                          ; starting with the low bytes (we know the C flag is
35851                                                                          ; set so the subtraction will be correct)
35852               
35853 E64E D360  30        movb @R,ra                      ; LDA R             ; And then doing the high bytes
     E650 0091     
35854                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 E652 1801  14        joc  !
0002 E654 7347  18        sb   rone,ra
0003               !:
0004 E656 022D  22        ai   ra,-(>00*256)
     E658 0000     
                   < elite.a99
35855 E65A D80D  30        movb ra,@R                      ; STA R
     E65C 0091     
35856               
35857                      .sec                            ; SEC               ; Set the C flag to rotate into the result in (Y X)
     **** ****     > SEC
0001 E65E 0A18  18        sla  rmone,1
                   < elite.a99
35858               
35859               LL132:
35860 E660 D34E  18        movb rx,ra                      ; TXA               ; Rotate the counter in (Y X) to the left, and catch the
35861 E662 06A0  32        bl   @rola                      ; ROL A             ; result bit into bit 0 (which will be a 0 if we didn't
     E664 FE3E     
35862 E666 D38D  18        movb ra,rx                      ; TAX               ; do the subtraction, or 1 if we did)
35863 E668 D34F  18        movb ry,ra                      ; TYA
35864 E66A 06A0  32        bl   @rola                      ; ROL A
     E66C FE3E     
35865 E66E D3CD  18        movb ra,ry                      ; TAY
35866               
35867 E670 18D7  14        joc  LL130                      ; BCS LL130         ; If we still have set bits in (Y X), loop back to LL130
35868                                                                          ; to do the next iteration of 15, until we have done the
35869                                                                          ; whole division
35870               
35871                      .pla                            ; PLA               ; Restore A, which we calculated above, from the stack
     **** ****     > PLA
0001 E672 058A  14        inc  rsp
0002 E674 D35A  26        movb *rsp,ra
                   < elite.a99
35872               
35873 E676 1112  14        jlt  LL128                      ; BMI LL128         ; If A is negative jump to LL128 to return from the
35874                                                                          ; subroutine with (Y X) as is
35875               
35876               LL133:
35877 E678 D34E  18        movb rx,ra                      ; TXA               ; Otherwise negate (Y X) using two's complement by first
35878                      .eoi (>ff*256)                  ; EOR #%11111111    ; setting the low byte to ~X + 1
     **** ****     > EOI
0001 E67A 0200  20        li   rtmp,(>FF*256)
     E67C FF00     
0002 E67E 2B40  18        xor  rtmp,ra
                   < elite.a99
35879               * CLC                    \
35880                      .adi (>01*256)                  ; ADC #1            ; The CLC instruction is commented out in the original
     **** ****     > ADI
0001 E680 1701  14        jnc  !
0002 E682 B347  18        ab   rone,ra
0003               !:
0004 E684 022D  22        ai   ra,(>01*256)
     E686 0100     
                   < elite.a99
35881 E688 D38D  18        movb ra,rx                      ; TAX               ; source. It would have no effect as we know the C flag
35882                                                                          ; is clear from when we passed through the BCS above
35883               
35884 E68A D34F  18        movb ry,ra                      ; TYA               ; Then set the high byte to ~Y + C
35885                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 E68C 0200  20        li   rtmp,(>FF*256)
     E68E FF00     
0002 E690 2B40  18        xor  rtmp,ra
                   < elite.a99
35886                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 E692 1701  14        jnc  !
0002 E694 B347  18        ab   rone,ra
0003               !:
0004 E696 022D  22        ai   ra,(>00*256)
     E698 0000     
                   < elite.a99
35887 E69A D3CD  18        movb ra,ry                      ; TAY
35888               
35889               LL128:
35890 E69C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E69E FE34     
35891               
35892               * ******************************************************************************
35893               *
35894               * Name: LL129
35895               * Type: Subroutine
35896               * Category: Maths (Arithmetic)
35897               * Summary: Calculate Q = XX12+2, A = S EOR XX12+3 and (S R) = |S R|
35898               *
35899               * ------------------------------------------------------------------------------
35900               *
35901               * Do the following, in this order:
35902               *
35903               * Q = XX12+2
35904               *
35905               * A = S EOR XX12+3
35906               *
35907               * (S R) = |S R|
35908               *
35909               * This sets up the variables required above to calculate (S R) / XX12+2 and give
35910               * the result the opposite sign to XX13+3.
35911               *
35912               * ******************************************************************************
35913               
35914               LL129:
35915 E6A0 D3A0  30        movb @XX12+2,rx                 ; LDX XX12+2        ; Set Q = XX12+2
     E6A2 0039     
35916 E6A4 D80E  30        movb rx,@Q                      ; STX Q
     E6A6 0090     
35917               
35918 E6A8 D360  30        movb @S,ra                      ; LDA S             ; If S is positive, jump to LL127
     E6AA 0092     
35919 E6AC 1518  14        jgt  LL127                      ; BPL LL127
35920               
35921 E6AE 020D  20        li   ra,>00*256                 ; LDA #0            ; Otherwise set R = -R
     E6B0 0000     
35922                      .sec                            ; SEC
     **** ****     > SEC
0001 E6B2 0A18  18        sla  rmone,1
                   < elite.a99
35923                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 E6B4 1801  14        joc  !
0002 E6B6 7347  18        sb   rone,ra
0003               !:
0004 E6B8 7360  30        sb   @R,ra
     E6BA 0091     
                   < elite.a99
35924 E6BC D80D  30        movb ra,@R                      ; STA R
     E6BE 0091     
35925               
35926 E6C0 D360  30        movb @S,ra                      ; LDA S             ; Push S onto the stack
     E6C2 0092     
35927                      .pha                            ; PHA
     **** ****     > PHA
0001 E6C4 D68D  30        movb ra,*rsp
0002 E6C6 060A  14        dec  rsp
                   < elite.a99
35928               
35929                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set S = ~S + 1 + C
     **** ****     > EOI
0001 E6C8 0200  20        li   rtmp,(>FF*256)
     E6CA FF00     
0002 E6CC 2B40  18        xor  rtmp,ra
                   < elite.a99
35930                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 E6CE 1701  14        jnc  !
0002 E6D0 B347  18        ab   rone,ra
0003               !:
0004 E6D2 022D  22        ai   ra,(>00*256)
     E6D4 0000     
                   < elite.a99
35931 E6D6 D80D  30        movb ra,@S                      ; STA S
     E6D8 0092     
35932               
35933                      .pla                            ; PLA               ; Pull the original, negative S from the stack into A
     **** ****     > PLA
0001 E6DA 058A  14        inc  rsp
0002 E6DC D35A  26        movb *rsp,ra
                   < elite.a99
35934               
35935               LL127:
35936                      .eor @XX12+3                    ; EOR XX12+3        ; Set A = original argument S EOR'd with XX12+3
     **** ****     > EOR
0001 E6DE D020  30        movb @XX12+3,rtmp
     E6E0 003A     
0002 E6E2 2B40  18        xor  rtmp,ra
                   < elite.a99
35937               
35938 E6E4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E6E6 FE34     
35939               
35940               * ******************************************************************************
35941               *
35942               * Name: LL145 (Part 1 of 4)
35943               * Type: Subroutine
35944               * Category: Drawing lines
35945               * Summary: Clip line: Work out which end-points are on-screen, if any
35946               * Deep dive: Line-clipping
35947               * Extended screen coordinates
35948               *
35949               * ------------------------------------------------------------------------------
35950               *
35951               * This routine clips the line from (x1, y1) to (x2, y2) so it fits on-screen, or
35952               * returns an error if it can't be clipped to fit. The arguments are 16-bit
35953               * coordinates, and the clipped line is returned using 8-bit screen coordinates.
35954               *
35955               * This part sets XX13 to reflect which of the two points are on-screen and
35956               * off-screen.
35957               *
35958               * ------------------------------------------------------------------------------
35959               *
35960               * Arguments:
35961               *
35962               * XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
35963               *
35964               * XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
35965               *
35966               * XX15(5 4)           x2 as a 16-bit coordinate (x2_hi x2_lo)
35967               *
35968               * XX12(1 0)           y2 as a 16-bit coordinate (y2_hi y2_lo)
35969               *
35970               * ------------------------------------------------------------------------------
35971               *
35972               * Returns:
35973               *
35974               * (X1, Y1)            Screen coordinate of the start of the clipped line
35975               *
35976               * (X2, Y2)            Screen coordinate of the end of the clipped line
35977               *
35978               * C flag              Clear if the clipped line fits on-screen, set if it
35979               * doesn't
35980               *
35981               * XX13                The state of the original coordinates on-screen:
35982               *
35983               * * 0   = (x2, y2) on-screen
35984               *
35985               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
35986               *
35987               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
35988               *
35989               * So XX13 is non-zero if the end of the line was clipped,
35990               * meaning the next line sent to BLINE can't join onto the
35991               * end but has to start a new segment
35992               *
35993               * SWAP                The swap status of the returned coordinates:
35994               *
35995               * * &FF if we swapped the values of (x1, y1) and
35996               * (x2, y2) as part of the clipping process
35997               *
35998               * * 0 if the coordinates are still in the same order
35999               *
36000               * Y                   Y is preserved
36001               *
36002               * ------------------------------------------------------------------------------
36003               *
36004               * Other entry points:
36005               *
36006               * LL147               Don't initialise the values in SWAP or A
36007               *
36008               * ******************************************************************************
36009               
36010               LL145:
36011 E6E8 020D  20        li   ra,>00*256                 ; LDA #0            ; Set SWAP = 0
     E6EA 0000     
36012 E6EC D80D  30        movb ra,@SWAP                   ; STA SWAP
     E6EE 00A1     
36013               
36014 E6F0 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A = x2_hi
     E6F2 0036     
36015               
36016               LL147:
36017 E6F4 020E  20        li   rx,(Y*2-1)*256             ; LDX #Y*2-1        ; Set X = #Y * 2 - 1. The constant #Y is 96, the
     E6F6 BF00     
36018                                                                          ; y-coordinate of the mid-point of the space view, so
36019                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
36020                                                                          ; pixel row of the space view
36021               
36022 E6F8 F360  30        socb @XX12+1,ra                 ; ORA XX12+1        ; If one or both of x2_hi and y2_hi are non-zero, jump
     E6FA 0038     
36023 E6FC 1605  14        jne  LL107                      ; BNE LL107         ; to LL107 to skip the following, leaving X at 191
36024               
36025 E6FE 93A0  30        cb   @XX12,rx                   ; CPX XX12          ; If y2_lo > the y-coordinate of the bottom of screen
     E700 0037     
36026 E702 1702  14        jnc  LL107                      ; BCC LL107         ; then (x2, y2) is off the bottom of the screen, so skip
36027                                                                          ; the following instruction, leaving X at 191
36028               
36029 E704 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0
     E706 0000     
36030               
36031               LL107:
36032 E708 D80E  30        movb rx,@XX13                   ; STX XX13          ; Set XX13 = X, so we have:
     E70A 0098     
36033                                                                          ;
36034                                                                          ; * XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen
36035                                                                          ;
36036                                                                          ; * XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo
36037                                                                          ; is off the bottom of the screen
36038                                                                          ;
36039                                                                          ; In other words, XX13 is 191 if (x2, y2) is off-screen,
36040                                                                          ; otherwise it is 0
36041               
36042 E70C D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If one or both of x1_hi and y1_hi are non-zero, jump
     E70E 0032     
36043 E710 F360  30        socb @XX15+3,ra                 ; ORA XX15+3        ; to LL83
     E712 0034     
36044 E714 161F  14        jne  LL83                       ; BNE LL83
36045               
36046 E716 020D  20        li   ra,(Y*2-1)*256             ; LDA #Y*2-1        ; If y1_lo > the y-coordinate of the bottom of screen
     E718 BF00     
36047 E71A 9360  30        cb   @XX15+2,ra                 ; CMP XX15+2        ; then (x1, y1) is off the bottom of the screen, so jump
     E71C 0033     
36048 E71E 171A  14        jnc  LL83                       ; BCC LL83          ; to LL83
36049               
36050                                                                          ; If we get here, (x1, y1) is on-screen
36051               
36052 E720 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 is non-zero, i.e. (x2, y2) is off-screen, jump
     E722 0098     
36053 E724 1612  14        jne  LL108                      ; BNE LL108         ; to LL108 to halve it before continuing at LL83
36054               
36055                                                                          ; If we get here, the high bytes are all zero, which
36056                                                                          ; means the x-coordinates are < 256 and therefore fit on
36057                                                                          ; screen, and neither coordinate is off the bottom of
36058                                                                          ; the screen. That means both coordinates are already on
36059                                                                          ; screen, so we don't need to do any clipping, all we
36060                                                                          ; need to do is move the low bytes into (X1, Y1) and
36061                                                                          ; X2, Y2) and return
36062               
36063               LL146:
36064                                                                          ; If we get here then we have clipped our line to the
36065                                                                          ; screen edge (if we had to clip it at all), so we move
36066                                                                          ; the low bytes from (x1, y1) and (x2, y2) into (X1, Y1)
36067                                                                          ; and (X2, Y2), remembering that they share locations
36068                                                                          ; with XX15:
36069                                                                          ;
36070                                                                          ; X1 = XX15
36071                                                                          ; Y1 = XX15+1
36072                                                                          ; X2 = XX15+2
36073                                                                          ; Y2 = XX15+3
36074                                                                          ;
36075                                                                          ; X1 already contains x1_lo, so now we do the rest
36076 E726 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set Y1 (aka XX15+1) = y1_lo
     E728 0033     
36077 E72A D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E72C 0032     
36078               
36079 E72E D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set X2 (aka XX15+2) = x2_lo
     E730 0035     
36080 E732 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     E734 0033     
36081               
36082 E736 D360  30        movb @XX12,ra                   ; LDA XX12          ; Set Y2 (aka XX15+3) = y2_lo
     E738 0037     
36083 E73A D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E73C 0034     
36084               
36085                      .clc                            ; CLC               ; Clear the C flag as the clipped line fits on-screen
     **** ****     > CLC
0001 E73E 0A16  18        sla  rzero,1
                   < elite.a99
36086               
36087 E740 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E742 FE34     
36088               
36089               LL109:
36090                      .sec                            ; SEC               ; Set the C flag to indicate the clipped line does not
     **** ****     > SEC
0001 E744 0A18  18        sla  rmone,1
                   < elite.a99
36091                                                                          ; fit on-screen
36092               
36093 E746 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E748 FE34     
36094               
36095               LL108:
36096                      .lsr @XX13                      ; LSR XX13          ; If we get here then (x2, y2) is off-screen and XX13 is
     **** ****     > LSR
0001 E74A D020  30        movb @XX13,rtmp
     E74C 0098     
0002 E74E 0910  18        srl  rtmp,1
0003 E750 D800  30        movb rtmp,@XX13
     E752 0098     
                   < elite.a99
36097                                                                          ; 191, so shift XX13 right to halve it to 95
36098               
36099               * ******************************************************************************
36100               *
36101               * Name: LL145 (Part 2 of 4)
36102               * Type: Subroutine
36103               * Category: Drawing lines
36104               * Summary: Clip line: Work out if any part of the line is on-screen
36105               * Deep dive: Line-clipping
36106               * Extended screen coordinates
36107               *
36108               * ------------------------------------------------------------------------------
36109               *
36110               * This part does a number of tests to see if the line is on or off the screen.
36111               *
36112               * If we get here then at least one of (x1, y1) and (x2, y2) is off-screen, with
36113               * XX13 set as follows:
36114               *
36115               * * 0   = (x1, y1) off-screen, (x2, y2) on-screen
36116               *
36117               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
36118               *
36119               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
36120               *
36121               * where "off-screen" is defined as having a non-zero high byte in one of the
36122               * coordinates, or in the case of y-coordinates, having a low byte > 191, the
36123               * y-coordinate of the bottom of the space view.
36124               *
36125               * ******************************************************************************
36126               
36127               LL83:
36128 E754 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 < 128 then only one of the points is on-screen
     E756 0098     
36129 E758 1533  14        jgt  LL115                      ; BPL LL115         ; so jump down to LL115 to skip the checks of whether
36130                                                                          ; both points are in the strips to the right or bottom
36131                                                                          ; of the screen
36132               
36133                                                                          ; If we get here, both points are off-screen
36134               
36135 E75A D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If both x1_hi and x2_hi have bit 7 set, jump to LL109
     E75C 0032     
36136                      .and @XX15+5                    ; AND XX15+5        ; to return from the subroutine with the C flag set, as
     **** ****     > AND
0001 E75E D020  30        movb @XX15+5,rtmp
     E760 0036     
0002 E762 0540  14        inv  rtmp
0003 E764 5340  18        szcb rtmp,ra
                   < elite.a99
36137 E766 11EE  14        jlt  LL109                      ; BMI LL109         ; the entire line is above the top of the screen
36138               
36139 E768 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; If both y1_hi and y2_hi have bit 7 set, jump to LL109
     E76A 0034     
36140                      .and @XX12+1                    ; AND XX12+1        ; to return from the subroutine with the C flag set, as
     **** ****     > AND
0001 E76C D020  30        movb @XX12+1,rtmp
     E76E 0038     
0002 E770 0540  14        inv  rtmp
0003 E772 5340  18        szcb rtmp,ra
                   < elite.a99
36141 E774 11E7  14        jlt  LL109                      ; BMI LL109         ; the entire line is to the left of the screen
36142               
36143 E776 D3A0  30        movb @XX15+1,rx                 ; LDX XX15+1        ; Set A = X = x1_hi - 1
     E778 0032     
36144 E77A 7387  18        sb   rone,rx                    ; DEX
36145 E77C D34E  18        movb rx,ra                      ; TXA
36146               
36147 E77E D3A0  30        movb @XX15+5,rx                 ; LDX XX15+5        ; Set XX12+2 = x2_hi - 1
     E780 0036     
36148 E782 7387  18        sb   rone,rx                    ; DEX
36149 E784 D80E  30        movb rx,@XX12+2                 ; STX XX12+2
     E786 0039     
36150               
36151 E788 F360  30        socb @XX12+2,ra                 ; ORA XX12+2        ; If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set,
     E78A 0039     
36152 E78C 15DB  14        jgt  LL109                      ; BPL LL109         ; jump to LL109 to return from the subroutine with the C
36153                                                                          ; flag set, as the line doesn't fit on-screen
36154               
36155 E78E D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If y1_lo < y-coordinate of screen bottom, clear the C
     E790 0033     
36156 E792 028D  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; flag, otherwise set it
     E794 C000     
36157               
36158 E796 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set XX12+2 = y1_hi - (1 - C), so:
     E798 0034     
36159                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 E79A 1801  14        joc  !
0002 E79C 7347  18        sb   rone,ra
0003               !:
0004 E79E 022D  22        ai   ra,-(>00*256)
     E7A0 0000     
                   < elite.a99
36160 E7A2 D80D  30        movb ra,@XX12+2                 ; STA XX12+2        ; * Set XX12+2 = y1_hi - 1 if y1_lo is on-screen
     E7A4 0039     
36161                                                                          ; * Set XX12+2 = y1_hi     otherwise
36162                                                                          ;
36163                                                                          ; We do this subtraction because we are only interested
36164                                                                          ; in trying to move the points up by a screen if that
36165                                                                          ; might move the point into the space view portion of
36166                                                                          ; the screen, i.e. if y1_lo is on-screen
36167               
36168 E7A6 D360  30        movb @XX12,ra                   ; LDA XX12          ; If y2_lo < y-coordinate of screen bottom, clear the C
     E7A8 0037     
36169 E7AA 028D  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; flag, otherwise set it
     E7AC C000     
36170               
36171 E7AE D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set XX12+2 = y2_hi - (1 - C), so:
     E7B0 0038     
36172                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 E7B2 1801  14        joc  !
0002 E7B4 7347  18        sb   rone,ra
0003               !:
0004 E7B6 022D  22        ai   ra,-(>00*256)
     E7B8 0000     
                   < elite.a99
36173                                                                          ; * Set XX12+1 = y2_hi - 1 if y2_lo is on-screen
36174                                                                          ; * Set XX12+1 = y2_hi     otherwise
36175                                                                          ;
36176                                                                          ; We do this subtraction because we are only interested
36177                                                                          ; in trying to move the points up by a screen if that
36178                                                                          ; might move the point into the space view portion of
36179                                                                          ; the screen, i.e. if y1_lo is on-screen
36180               
36181 E7BA F360  30        socb @XX12+2,ra                 ; ORA XX12+2        ; If neither XX12+1 or XX12+2 have bit 7 set, jump to
     E7BC 0039     
36182 E7BE 15C2  14        jgt  LL109                      ; BPL LL109         ; LL109 to return from the subroutine with the C flag
36183                                                                          ; set, as the line doesn't fit on-screen
36184               
36185               * ******************************************************************************
36186               *
36187               * Name: LL145 (Part 3 of 4)
36188               * Type: Subroutine
36189               * Category: Drawing lines
36190               * Summary: Clip line: Calculate the line's gradient
36191               * Deep dive: Line-clipping
36192               * Extended screen coordinates
36193               *
36194               * ******************************************************************************
36195               
36196               LL115:
36197 E7C0 D34F  18        movb ry,ra                      ; TYA               ; Store Y on the stack so we can preserve it through the
36198                      .pha                            ; PHA               ; call to this subroutine
     **** ****     > PHA
0001 E7C2 D68D  30        movb ra,*rsp
0002 E7C4 060A  14        dec  rsp
                   < elite.a99
36199               
36200 E7C6 D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set XX12+2 = x2_lo - x1_lo
     E7C8 0035     
36201                      .sec                            ; SEC
     **** ****     > SEC
0001 E7CA 0A18  18        sla  rmone,1
                   < elite.a99
36202                      .sbc @XX15,ra                   ; SBC XX15
     **** ****     > SBC
0001 E7CC 1801  14        joc  !
0002 E7CE 7347  18        sb   rone,ra
0003               !:
0004 E7D0 7360  30        sb   @XX15,ra
     E7D2 0031     
                   < elite.a99
36203 E7D4 D80D  30        movb ra,@XX12+2                 ; STA XX12+2
     E7D6 0039     
36204               
36205 E7D8 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set XX12+3 = x2_hi - x1_hi
     E7DA 0036     
36206                      .sbc @XX15+1,ra                 ; SBC XX15+1
     **** ****     > SBC
0001 E7DC 1801  14        joc  !
0002 E7DE 7347  18        sb   rone,ra
0003               !:
0004 E7E0 7360  30        sb   @XX15+1,ra
     E7E2 0032     
                   < elite.a99
36207 E7E4 D80D  30        movb ra,@XX12+3                 ; STA XX12+3
     E7E6 003A     
36208               
36209 E7E8 D360  30        movb @XX12,ra                   ; LDA XX12          ; Set XX12+4 = y2_lo - y1_lo
     E7EA 0037     
36210                      .sec                            ; SEC
     **** ****     > SEC
0001 E7EC 0A18  18        sla  rmone,1
                   < elite.a99
36211                      .sbc @XX15+2,ra                 ; SBC XX15+2
     **** ****     > SBC
0001 E7EE 1801  14        joc  !
0002 E7F0 7347  18        sb   rone,ra
0003               !:
0004 E7F2 7360  30        sb   @XX15+2,ra
     E7F4 0033     
                   < elite.a99
36212 E7F6 D80D  30        movb ra,@XX12+4                 ; STA XX12+4
     E7F8 003B     
36213               
36214 E7FA D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set XX12+5 = y2_hi - y1_hi
     E7FC 0038     
36215                      .sbc @XX15+3,ra                 ; SBC XX15+3
     **** ****     > SBC
0001 E7FE 1801  14        joc  !
0002 E800 7347  18        sb   rone,ra
0003               !:
0004 E802 7360  30        sb   @XX15+3,ra
     E804 0034     
                   < elite.a99
36216 E806 D80D  30        movb ra,@XX12+5                 ; STA XX12+5
     E808 003C     
36217               
36218                                                                          ; So we now have:
36219                                                                          ;
36220                                                                          ; delta_x in XX12(3 2)
36221                                                                          ; delta_y in XX12(5 4)
36222                                                                          ;
36223                                                                          ; where the delta is (x1, y1) - (x2, y2))
36224               
36225                      .eor @XX12+3                    ; EOR XX12+3        ; Set S = the sign of delta_x * the sign of delta_y, so
     **** ****     > EOR
0001 E80A D020  30        movb @XX12+3,rtmp
     E80C 003A     
0002 E80E 2B40  18        xor  rtmp,ra
                   < elite.a99
36226 E810 D80D  30        movb ra,@S                      ; STA S             ; if bit 7 of S is set, the deltas have different signs
     E812 0092     
36227               
36228 E814 D360  30        movb @XX12+5,ra                 ; LDA XX12+5        ; If delta_y_hi is positive, jump down to LL110 to skip
     E816 003C     
36229 E818 1511  14        jgt  LL110                      ; BPL LL110         ; the following
36230               
36231 E81A 020D  20        li   ra,>00*256                 ; LDA #0            ; Otherwise flip the sign of delta_y to make it
     E81C 0000     
36232                      .sec                            ; SEC               ; positive, starting with the low bytes
     **** ****     > SEC
0001 E81E 0A18  18        sla  rmone,1
                   < elite.a99
36233                      .sbc @XX12+4,ra                 ; SBC XX12+4
     **** ****     > SBC
0001 E820 1801  14        joc  !
0002 E822 7347  18        sb   rone,ra
0003               !:
0004 E824 7360  30        sb   @XX12+4,ra
     E826 003B     
                   < elite.a99
36234 E828 D80D  30        movb ra,@XX12+4                 ; STA XX12+4
     E82A 003B     
36235               
36236 E82C 020D  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so now:
     E82E 0000     
36237                      .sbc @XX12+5,ra                 ; SBC XX12+5        ;
     **** ****     > SBC
0001 E830 1801  14        joc  !
0002 E832 7347  18        sb   rone,ra
0003               !:
0004 E834 7360  30        sb   @XX12+5,ra
     E836 003C     
                   < elite.a99
36238 E838 D80D  30        movb ra,@XX12+5                 ; STA XX12+5        ; XX12(5 4) = |delta_y|
     E83A 003C     
36239               
36240               LL110:
36241 E83C D360  30        movb @XX12+3,ra                 ; LDA XX12+3        ; If delta_x_hi is positive, jump down to LL111 to skip
     E83E 003A     
36242 E840 150F  14        jgt  LL111                      ; BPL LL111         ; the following
36243               
36244                      .sec                            ; SEC               ; Otherwise flip the sign of delta_x to make it
     **** ****     > SEC
0001 E842 0A18  18        sla  rmone,1
                   < elite.a99
36245 E844 020D  20        li   ra,>00*256                 ; LDA #0            ; positive, starting with the low bytes
     E846 0000     
36246                      .sbc @XX12+2,ra                 ; SBC XX12+2
     **** ****     > SBC
0001 E848 1801  14        joc  !
0002 E84A 7347  18        sb   rone,ra
0003               !:
0004 E84C 7360  30        sb   @XX12+2,ra
     E84E 0039     
                   < elite.a99
36247 E850 D80D  30        movb ra,@XX12+2                 ; STA XX12+2
     E852 0039     
36248               
36249 E854 020D  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so now:
     E856 0000     
36250                      .sbc @XX12+3,ra                 ; SBC XX12+3        ;
     **** ****     > SBC
0001 E858 1801  14        joc  !
0002 E85A 7347  18        sb   rone,ra
0003               !:
0004 E85C 7360  30        sb   @XX12+3,ra
     E85E 003A     
                   < elite.a99
36251                                                                          ; (A XX12+2) = |delta_x|
36252               
36253               LL111:
36254                                                                          ; We now keep halving |delta_x| and |delta_y| until
36255                                                                          ; both of them have zero in their high bytes
36256 E860 D38D  18        movb ra,rx                      ; TAX               ; If |delta_x_hi| is non-zero, skip the following
36257 E862 1603  14        jne  LL112                      ; BNE LL112
36258               
36259 E864 D3A0  30        movb @XX12+5,rx                 ; LDX XX12+5        ; If |delta_y_hi| = 0, jump down to LL113 (as both
     E866 003C     
36260 E868 1310  14        jeq  LL113                      ; BEQ LL113         ; |delta_x_hi| and |delta_y_hi| are 0)
36261               
36262               LL112:
36263 E86A 091D  18        srl  ra,1                       ; LSR A             ; Halve the value of delta_x in (A XX12+2)
36264 E86C 0204  20        li   rarg1,XX12+2               ; ROR XX12+2
     E86E 0039     
36265 E870 06A0  32        bl   @ror                       ;
     E872 FE7A     
36266               
36267                      .lsr @XX12+5                    ; LSR XX12+5        ; Halve the value of delta_y XX12(5 4)
     **** ****     > LSR
0001 E874 D020  30        movb @XX12+5,rtmp
     E876 003C     
0002 E878 0910  18        srl  rtmp,1
0003 E87A D800  30        movb rtmp,@XX12+5
     E87C 003C     
                   < elite.a99
36268 E87E 0204  20        li   rarg1,XX12+4               ; ROR XX12+4
     E880 003B     
36269 E882 06A0  32        bl   @ror                       ;
     E884 FE7A     
36270               
36271 E886 0460  28        b    @LL111                     ; JMP LL111         ; Loop back to LL111
     E888 E860     
36272               
36273               LL113:
36274                                                                          ; By now, the high bytes of both |delta_x| and |delta_y|
36275                                                                          ; are zero
36276 E88A D80E  30        movb rx,@T                      ; STX T             ; We know that X = 0 as that's what we tested with a BEQ
     E88C 00D1     
36277                                                                          ; above, so this sets T = 0
36278               
36279 E88E D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; If delta_x_lo < delta_y_lo, so our line is more
     E890 0039     
36280 E892 9360  30        cb   @XX12+4,ra                 ; CMP XX12+4        ; vertical than horizontal, jump to LL114
     E894 003B     
36281 E896 170A  14        jnc  LL114                      ; BCC LL114
36282               
36283                                                                          ; If we get here then our line is more horizontal than
36284                                                                          ; vertical, so it is a shallow slope
36285               
36286 E898 D80D  30        movb ra,@Q                      ; STA Q             ; Set Q = delta_x_lo
     E89A 0090     
36287               
36288 E89C D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set A = delta_y_lo
     E89E 003B     
36289               
36290 E8A0 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     E8A2 D404     
36291 E8A4 06A0  32        bl   @jsr                       ;
     E8A6 FE28     
36292                                                                          ;
36293                                                                          ; R = 256 * A / Q
36294                                                                          ; = 256 * delta_y_lo / delta_x_lo
36295               
36296 E8A8 0460  28        b    @LL116                     ; JMP LL116         ; Jump to LL116, as we now have the line's gradient in R
     E8AA E8C2     
36297               
36298               LL114:
36299                                                                          ; If we get here then our line is more vertical than
36300                                                                          ; horizontal, so it is a steep slope
36301 E8AC D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set Q = delta_y_lo
     E8AE 003B     
36302 E8B0 D80D  30        movb ra,@Q                      ; STA Q
     E8B2 0090     
36303 E8B4 D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set A = delta_x_lo
     E8B6 0039     
36304               
36305 E8B8 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     E8BA D404     
36306 E8BC 06A0  32        bl   @jsr                       ;
     E8BE FE28     
36307                                                                          ;
36308                                                                          ; R = 256 * A / Q
36309                                                                          ; = 256 * delta_x_lo / delta_y_lo
36310               
36311 E8C0 7347  18        sb   rone,ra                    ; DEC T             ; T was set to 0 above, so this sets T = &FF when our
36312                                                                          ; line is steep
36313               
36314               * ******************************************************************************
36315               *
36316               * Name: LL145 (Part 4 of 4)
36317               * Type: Subroutine
36318               * Category: Drawing lines
36319               * Summary: Clip line: Call the routine in LL188 to do the actual clipping
36320               * Deep dive: Line-clipping
36321               * Extended screen coordinates
36322               *
36323               * ------------------------------------------------------------------------------
36324               *
36325               * This part sets things up to call the routine in LL188, which does the actual
36326               * clipping.
36327               *
36328               * If we get here, then R has been set to the gradient of the line (x1, y1) to
36329               * (x2, y2), with T indicating the gradient of slope:
36330               *
36331               * * 0   = shallow slope (more horizontal than vertical)
36332               *
36333               * * &FF = steep slope (more vertical than horizontal)
36334               *
36335               * and XX13 has been set as follows:
36336               *
36337               * * 0   = (x1, y1) off-screen, (x2, y2) on-screen
36338               *
36339               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
36340               *
36341               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
36342               *
36343               * ******************************************************************************
36344               
36345               LL116:
36346 E8C2 D360  30        movb @R,ra                      ; LDA R             ; Store the gradient in XX12+2
     E8C4 0091     
36347 E8C6 D80D  30        movb ra,@XX12+2                 ; STA XX12+2
     E8C8 0039     
36348               
36349 E8CA D360  30        movb @S,ra                      ; LDA S             ; Store the type of slope in XX12+3, bit 7 clear means
     E8CC 0092     
36350 E8CE D80D  30        movb ra,@XX12+3                 ; STA XX12+3        ; top left to bottom right, bit 7 set means top right to
     E8D0 003A     
36351                                                                          ; bottom left
36352               
36353 E8D2 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 = 0, skip the following instruction
     E8D4 0098     
36354 E8D6 1301  14        jeq  LL138                      ; BEQ LL138
36355               
36356 E8D8 1511  14        jgt  LLX117                     ; BPL LLX117        ; If XX13 is positive, it must be 95. This means
36357                                                                          ; (x1, y1) is on-screen but (x2, y2) isn't, so we jump
36358                                                                          ; to LLX117 to swap the (x1, y1) and (x2, y2)
36359                                                                          ; coordinates around before doing the actual clipping,
36360                                                                          ; because we need to clip (x2, y2) but the clipping
36361                                                                          ; routine at LL118 only clips (x1, y1)
36362               
36363               LL138:
36364                                                                          ; If we get here, XX13 = 0 or 191, so (x1, y1) is
36365                                                                          ; off-screen and needs clipping
36366 E8DA 0200  20        li   rtmp,LL118                 ; JSR LL118         ; Call LL118 to move (x1, y1) along the line onto the
     E8DC E458     
36367 E8DE 06A0  32        bl   @jsr                       ;
     E8E0 FE28     
36368                                                                          ; screen, i.e. clip the line at the (x1, y1) end
36369               
36370 E8E2 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to
     E8E4 0098     
36371 E8E6 152F  14        jgt  LL124                      ; BPL LL124         ; LL124 to return with a successfully clipped line
36372               
36373               LL117:
36374                                                                          ; If we get here, XX13 = 191 (both coordinates are
36375                                                                          ; off-screen)
36376 E8E8 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If either of x1_hi or y1_hi are non-zero, jump to
     E8EA 0032     
36377 E8EC F360  30        socb @XX15+3,ra                 ; ORA XX15+3        ; LL137 to return from the subroutine with the C flag
     E8EE 0034     
36378 E8F0 162F  14        jne  LL137                      ; BNE LL137         ; set, as the line doesn't fit on-screen
36379               
36380 E8F2 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If y1_lo > y-coordinate of the bottom of the screen
     E8F4 0033     
36381 E8F6 028D  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; jump to LL137 to return from the subroutine with the
     E8F8 C000     
36382 E8FA 182A  14        joc  LL137                      ; BCS LL137         ; C flag set, as the line doesn't fit on-screen
36383               
36384               LLX117:
36385                                                                          ; If we get here, XX13 = 95 or 191, and in both cases
36386                                                                          ; (x2, y2) is off-screen, so we now need to swap the
36387                                                                          ; (x1, y1) and (x2, y2) coordinates around before doing
36388                                                                          ; the actual clipping, because we need to clip (x2, y2)
36389                                                                          ; but the clipping routine at LL118 only clips (x1, y1)
36390 E8FC D3A0  30        movb @XX15,rx                   ; LDX XX15          ; Swap x1_lo = x2_lo
     E8FE 0031     
36391 E900 D360  30        movb @XX15+4,ra                 ; LDA XX15+4
     E902 0035     
36392 E904 D80D  30        movb ra,@XX15                   ; STA XX15
     E906 0031     
36393 E908 D80E  30        movb rx,@XX15+4                 ; STX XX15+4
     E90A 0035     
36394               
36395 E90C D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Swap x2_lo = x1_lo
     E90E 0036     
36396 E910 D3A0  30        movb @XX15+1,rx                 ; LDX XX15+1
     E912 0032     
36397 E914 D80E  30        movb rx,@XX15+5                 ; STX XX15+5
     E916 0036     
36398 E918 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E91A 0032     
36399               
36400 E91C D3A0  30        movb @XX15+2,rx                 ; LDX XX15+2        ; Swap y1_lo = y2_lo
     E91E 0033     
36401 E920 D360  30        movb @XX12,ra                   ; LDA XX12
     E922 0037     
36402 E924 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     E926 0033     
36403 E928 D80E  30        movb rx,@XX12                   ; STX XX12
     E92A 0037     
36404               
36405 E92C D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Swap y2_lo = y1_lo
     E92E 0038     
36406 E930 D3A0  30        movb @XX15+3,rx                 ; LDX XX15+3
     E932 0034     
36407 E934 D80E  30        movb rx,@XX12+1                 ; STX XX12+1
     E936 0038     
36408 E938 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E93A 0034     
36409               
36410 E93C 0200  20        li   rtmp,LL118                 ; JSR LL118         ; Call LL118 to move (x1, y1) along the line onto the
     E93E E458     
36411 E940 06A0  32        bl   @jsr                       ;
     E942 FE28     
36412                                                                          ; screen, i.e. clip the line at the (x1, y1) end
36413               
36414 E944 7347  18        sb   rone,ra                    ; DEC SWAP          ; Set SWAP = &FF to indicate that we just clipped the
36415                                                                          ; line at the (x2, y2) end by swapping the coordinates
36416                                                                          ; (the DEC does this as we set SWAP to 0 at the start of
36417                                                                          ; this subroutine)
36418               
36419               LL124:
36420                      .pla                            ; PLA               ; Restore Y from the stack so it gets preserved through
     **** ****     > PLA
0001 E946 058A  14        inc  rsp
0002 E948 D35A  26        movb *rsp,ra
                   < elite.a99
36421 E94A D3CD  18        movb ra,ry                      ; TAY               ; the call to this subroutine
36422               
36423 E94C 0460  28        b    @LL146                     ; JMP LL146         ; Jump up to LL146 to move the low bytes of (x1, y1) and
     E94E E726     
36424                                                                          ; (x2, y2) into (X1, Y1) and (X2, Y2), and return from
36425                                                                          ; the subroutine with a successfully clipped line
36426               
36427               LL137:
36428                      .pla                            ; PLA               ; Restore Y from the stack so it gets preserved through
     **** ****     > PLA
0001 E950 058A  14        inc  rsp
0002 E952 D35A  26        movb *rsp,ra
                   < elite.a99
36429 E954 D3CD  18        movb ra,ry                      ; TAY               ; the call to this subroutine
36430               
36431                      .sec                            ; SEC               ; Set the C flag to indicate the clipped line does not
     **** ****     > SEC
0001 E956 0A18  18        sla  rmone,1
                   < elite.a99
36432                                                                          ; fit on-screen
36433               
36434 E958 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E95A FE34     
36435               
36436               * ******************************************************************************
36437               *
36438               * Save ELTG.bin
36439               *
36440               * ******************************************************************************
36441               
36442                      ; PRINT "ELITE G"
36443                      ; PRINT "Assembled at ", ~CODE_G%
36444                      ; PRINT "Ends at ", ~P%
36445                      ; PRINT "Code size is ", ~(P% - CODE_G%)
36446                      ; PRINT "Execute at ", ~LOAD%
36447                      ; PRINT "Reload at ", ~LOAD_G%
36448               
36449                      ; PRINT "S.ELTG ", ~CODE_G%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_G%
36450                      ; SAVE "3-assembled-output/ELTG.bin", CODE_G%, P%, LOAD%
36451               
36452               * ******************************************************************************
36453               *
36454               * Name: checksum0
36455               * Type: Variable
36456               * Category: Copy protection
36457               * Summary: Checksum for the entire main game code
36458               *
36459               * ------------------------------------------------------------------------------
36460               *
36461               * This byte contains a checksum for the entire main game code. It is populated
36462               * by elite-checksum.py and is used by the encryption checks in elite-loader.asm
36463               * (see the CHK routine in the loader for more details).
36464               *
36465               * ******************************************************************************
36466               
36467               checksum0_:
36468 E95C                 bss 1                                               ; This value is checked against the calculated checksum
36469                                                                          ; in part 6 of the loader in elite-loader.asm
36470               
36471               * ******************************************************************************
36472               *
36473               * ELITE SHIP BLUEPRINTS FILE
36474               *
36475               * Produces the binary file SHIPS.bin that gets loaded by elite-bcfs.asm.
36476               *
36477               * ******************************************************************************
36478               
36479               CODE_SHIPS.:
36480                      equ $
36481               
36482               LOAD_SHIPS.:
36483                      equ LOAD. + $ - CODE.
36484               
36485               * ******************************************************************************
36486               *
36487               * Name: XX21
36488               * Type: Variable
36489               * Category: Drawing ships
36490               * Summary: Ship blueprints lookup table
36491               * Deep dive: Ship blueprints
36492               *
36493               * ******************************************************************************
36494               
36495               XX21:
36496 E95E E978            data SHIP_SIDEWINDER                                ; 1 = Sidewinder
36497 E960 EA22            data SHIP_VIPER                                     ; COPS =  2 = Viper
36498 E962 EAFE            data SHIP_MAMBA                                     ; 3 = Mamba
36499 E964 F33A            data SHIP_PYTHON                                    ; 4 = Python
36500 E966 EC2E            data SHIP_COBRA_MK_3                                ; 5 = Cobra Mk III (bounty hunter)
36501 E968 EDB8            data SHIP_THARGOID                                  ; THG  =  6 = Thargoid
36502 E96A EC2E            data SHIP_COBRA_MK_3                                ; CYL  =  7 = Cobra Mk III (trader)
36503 E96C EED6            data SHIP_CORIOLIS                                  ; SST  =  8 = Coriolis space station
36504 E96E EFF4            data SHIP_MISSILE                                   ; MSL  =  9 = Missile
36505 E970 F0F4            data SHIP_ASTEROID                                  ; AST  = 10 = Asteroid
36506 E972 F1CC            data SHIP_CANISTER                                  ; OIL  = 11 = Cargo canister
36507 E974 F276            data SHIP_THARGON                                   ; TGL  = 12 = Thargon
36508 E976 F2E4            data SHIP_ESCAPE_POD                                ; ESC  = 13 = Escape pod
36509               
36510               * ******************************************************************************
36511               *
36512               * Name: VERTEX
36513               * Type: Macro
36514               * Category: Drawing ships
36515               * Summary: Macro definition for adding vertices to ship blueprints
36516               * Deep dive: Ship blueprints
36517               *
36518               * ------------------------------------------------------------------------------
36519               *
36520               * The following macro is used to build the ship blueprints:
36521               *
36522               * VERTEX x, y, z, face1, face2, face3, face4, visibility
36523               *
36524               * See the deep dive on "Ship blueprints" for details of how vertices are stored
36525               * in the ship blueprints, and the deep dive on "Drawing ships" for information
36526               * on how vertices are used to draw 3D wireframe ships.
36527               *
36528               * ------------------------------------------------------------------------------
36529               *
36530               * Arguments:
36531               *
36532               * x                   The vertex's x-coordinate
36533               *
36534               * y                   The vertex's y-coordinate
36535               *
36536               * z                   The vertex's z-coordinate
36537               *
36538               * face1               The number of face 1 associated with this vertex
36539               *
36540               * face2               The number of face 2 associated with this vertex
36541               *
36542               * face3               The number of face 3 associated with this vertex
36543               *
36544               * face4               The number of face 4 associated with this vertex
36545               *
36546               * visibility          The visibility distance, beyond which the vertex is not
36547               * shown
36548               *
36549               * ******************************************************************************
36550               
36551                      ; MACRO VERTEX x, y, z, face1, face2, face3, face4, visibility
36552               
36553                      ; IF x < 0                      ;
36554                      ; s_x = 1 << 7                  ;
36555                      ; ELSE                          ;
36556                      ; s_x = 0                       ;
36557                      ; ENDIF                         ;
36558               
36559                      ; IF y < 0                      ;
36560                      ; s_y = 1 << 6                  ;
36561                      ; ELSE                          ;
36562                      ; s_y = 0                       ;
36563                      ; ENDIF                         ;
36564               
36565                      ; IF z < 0                      ;
36566                      ; s_z = 1 << 5                  ;
36567                      ; ELSE                          ;
36568                      ; s_z = 0                       ;
36569                      ; ENDIF                         ;
36570               
36571                      ; s = s_x + s_y + s_z + visibility ;
36572                      ; f1 = face1 + (face2 << 4)     ;
36573                      ; f2 = face3 + (face4 << 4)     ;
36574                      ; ax = ABS(x)                   ;
36575                      ; ay = ABS(y)                   ;
36576                      ; az = ABS(z)                   ;
36577               
36578                      ; EQUB ax, ay, az, s, f1, f2    ;
36579               
36580                      ; ENDMACRO
36581               
36582               * ******************************************************************************
36583               *
36584               * Name: EDGE
36585               * Type: Macro
36586               * Category: Drawing ships
36587               * Summary: Macro definition for adding edges to ship blueprints
36588               * Deep dive: Ship blueprints
36589               *
36590               * ------------------------------------------------------------------------------
36591               *
36592               * The following macro is used to build the ship blueprints:
36593               *
36594               * EDGE vertex1, vertex2, face1, face2, visibility
36595               *
36596               * See the deep dive on "Ship blueprints" for details of how edges are stored
36597               * in the ship blueprints, and the deep dive on "Drawing ships" for information
36598               * on how edges are used to draw 3D wireframe ships.
36599               *
36600               * ------------------------------------------------------------------------------
36601               *
36602               * Arguments:
36603               *
36604               * vertex1             The number of the vertex at the start of the edge
36605               *
36606               * vertex1             The number of the vertex at the end of the edge
36607               *
36608               * face1               The number of face 1 associated with this edge
36609               *
36610               * face2               The number of face 2 associated with this edge
36611               *
36612               * visibility          The visibility distance, beyond which the edge is not
36613               * shown
36614               *
36615               * ******************************************************************************
36616               
36617                      ; MACRO EDGE vertex1, vertex2, face1, face2, visibility
36618               
36619                      ; f = face1 + (face2 << 4)      ;
36620                      ; EQUB visibility, f, vertex1 << 2, vertex2 << 2 ;
36621               
36622                      ; ENDMACRO
36623               
36624               * ******************************************************************************
36625               *
36626               * Name: FACE
36627               * Type: Macro
36628               * Category: Drawing ships
36629               * Summary: Macro definition for adding faces to ship blueprints
36630               * Deep dive: Ship blueprints
36631               *
36632               * ------------------------------------------------------------------------------
36633               *
36634               * The following macro is used to build the ship blueprints:
36635               *
36636               * FACE normal_x, normal_y, normal_z, visibility
36637               *
36638               * See the deep dive on "Ship blueprints" for details of how faces are stored
36639               * in the ship blueprints, and the deep dive on "Drawing ships" for information
36640               * on how faces are used to draw 3D wireframe ships.
36641               *
36642               * ------------------------------------------------------------------------------
36643               *
36644               * Arguments:
36645               *
36646               * normal_x            The face normal's x-coordinate
36647               *
36648               * normal_y            The face normal's y-coordinate
36649               *
36650               * normal_z            The face normal's z-coordinate
36651               *
36652               * visibility          The visibility distance, beyond which the edge is always
36653               * shown
36654               *
36655               * ******************************************************************************
36656               
36657                      ; MACRO FACE normal_x, normal_y, normal_z, visibility
36658               
36659                      ; IF normal_x < 0               ;
36660                      ; s_x = 1 << 7                  ;
36661                      ; ELSE                          ;
36662                      ; s_x = 0                       ;
36663                      ; ENDIF                         ;
36664               
36665                      ; IF normal_y < 0               ;
36666                      ; s_y = 1 << 6                  ;
36667                      ; ELSE                          ;
36668                      ; s_y = 0                       ;
36669                      ; ENDIF                         ;
36670               
36671                      ; IF normal_z < 0               ;
36672                      ; s_z = 1 << 5                  ;
36673                      ; ELSE                          ;
36674                      ; s_z = 0                       ;
36675                      ; ENDIF                         ;
36676               
36677                      ; s = s_x + s_y + s_z + visibility ;
36678                      ; ax = ABS(normal_x)            ;
36679                      ; ay = ABS(normal_y)            ;
36680                      ; az = ABS(normal_z)            ;
36681               
36682                      ; EQUB s, ax, ay, az            ;
36683               
36684                      ; ENDMACRO
36685               
36686               * ******************************************************************************
36687               *
36688               * Name: SHIP_SIDEWINDER
36689               * Type: Variable
36690               * Category: Drawing ships
36691               * Summary: Ship blueprint for a Sidewinder
36692               * Deep dive: Ship blueprints
36693               *
36694               * ******************************************************************************
36695               
36696               SHIP_SIDEWINDER:
36697 E978 00              byte >00                                            ; Max. canisters on demise = 0
36698 E97A 1081            data 65 * 65                                        ; Targetable area          = 65 * 65
36699               
36700 E97C 52              byte (SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)%256  ; Edges data offset (low)
36701 E97D   8E            byte (SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)%256  ; Faces data offset (low)
36702               
36703 E97E 3D              byte >3d                                            ; Max. edge count          = (61 - 1) / 4 = 15
36704 E97F   00            byte >00                                            ; Gun vertex               = 0
36705 E980 1E              byte >1e                                            ; Explosion count          = 6, as (4 * n) + 6 = 30
36706 E981   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
36707 E982 0F              byte >0f                                            ; Number of edges          = 15
36708 E984 3200            data >3200                                          ; Bounty                   = 50
36709 E986 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
36710 E987   14            byte >14                                            ; Visibility distance      = 20
36711 E988 46              byte >46                                            ; Max. energy              = 70
36712 E989   25            byte >25                                            ; Max. speed               = 37
36713               
36714 E98A 00              byte (SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)/256  ; Edges data offset (high)
36715 E98B   00            byte (SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)/256  ; Faces data offset (high)
36716               
36717 E98C 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
36718 E98D   10            byte >10                                            ; Laser power              = 2
36719                                                                          ; Missiles                 = 0
36720               
36721               SHIP_SIDEWINDER_VERTICES:
36722                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36723 E98E 2000            byte >20, >00, >24, >9f, >10, >54                   ; Vertex 0
     E990 249F     
     E992 1054     
36724 E994 2000            byte >20, >00, >24, >1f, >20, >65                   ; Vertex 1
     E996 241F     
     E998 2065     
36725 E99A 4000            byte >40, >00, >1c, >3f, >32, >66                   ; Vertex 2
     E99C 1C3F     
     E99E 3266     
36726 E9A0 4000            byte >40, >00, >1c, >bf, >31, >44                   ; Vertex 3
     E9A2 1CBF     
     E9A4 3144     
36727 E9A6 0010            byte >00, >10, >1c, >3f, >10, >32                   ; Vertex 4
     E9A8 1C3F     
     E9AA 1032     
36728 E9AC 0010            byte >00, >10, >1c, >7f, >43, >65                   ; Vertex 5
     E9AE 1C7F     
     E9B0 4365     
36729 E9B2 0C06            byte >0c, >06, >1c, >af, >33, >33                   ; Vertex 6
     E9B4 1CAF     
     E9B6 3333     
36730 E9B8 0C06            byte >0c, >06, >1c, >2f, >33, >33                   ; Vertex 7
     E9BA 1C2F     
     E9BC 3333     
36731 E9BE 0C06            byte >0c, >06, >1c, >6c, >33, >33                   ; Vertex 8
     E9C0 1C6C     
     E9C2 3333     
36732 E9C4 0C06            byte >0c, >06, >1c, >ec, >33, >33                   ; Vertex 9
     E9C6 1CEC     
     E9C8 3333     
36733               
36734               SHIP_SIDEWINDER_EDGES:
36735                                                                          ; vertex1, vertex2, face1, face2, visibility
36736 E9CA 1F50            byte >1f, >50, >00, >04                             ; Edge 0
     E9CC 0004     
36737 E9CE 1F62            byte >1f, >62, >04, >08                             ; Edge 1
     E9D0 0408     
36738 E9D2 1F20            byte >1f, >20, >04, >10                             ; Edge 2
     E9D4 0410     
36739 E9D6 1F10            byte >1f, >10, >00, >10                             ; Edge 3
     E9D8 0010     
36740 E9DA 1F41            byte >1f, >41, >00, >0c                             ; Edge 4
     E9DC 000C     
36741 E9DE 1F31            byte >1f, >31, >0c, >10                             ; Edge 5
     E9E0 0C10     
36742 E9E2 1F32            byte >1f, >32, >08, >10                             ; Edge 6
     E9E4 0810     
36743 E9E6 1F43            byte >1f, >43, >0c, >14                             ; Edge 7
     E9E8 0C14     
36744 E9EA 1F63            byte >1f, >63, >08, >14                             ; Edge 8
     E9EC 0814     
36745 E9EE 1F65            byte >1f, >65, >04, >14                             ; Edge 9
     E9F0 0414     
36746 E9F2 1F54            byte >1f, >54, >00, >14                             ; Edge 10
     E9F4 0014     
36747 E9F6 0F33            byte >0f, >33, >18, >1c                             ; Edge 11
     E9F8 181C     
36748 E9FA 0C33            byte >0c, >33, >1c, >20                             ; Edge 12
     E9FC 1C20     
36749 E9FE 0C33            byte >0c, >33, >18, >24                             ; Edge 13
     EA00 1824     
36750 EA02 0C33            byte >0c, >33, >20, >24                             ; Edge 14
     EA04 2024     
36751               
36752               SHIP_SIDEWINDER_FACES:
36753                                                                          ; normal_x, normal_y, normal_z, visibility
36754 EA06 1F00            byte >1f, >00, >20, >08                             ; Face 0
     EA08 2008     
36755 EA0A 9F0C            byte >9f, >0c, >2f, >06                             ; Face 1
     EA0C 2F06     
36756 EA0E 1F0C            byte >1f, >0c, >2f, >06                             ; Face 2
     EA10 2F06     
36757 EA12 3F00            byte >3f, >00, >00, >70                             ; Face 3
     EA14 0070     
36758 EA16 DF0C            byte >df, >0c, >2f, >06                             ; Face 4
     EA18 2F06     
36759 EA1A 5F00            byte >5f, >00, >20, >08                             ; Face 5
     EA1C 2008     
36760 EA1E 5F0C            byte >5f, >0c, >2f, >06                             ; Face 6
     EA20 2F06     
36761               
36762               * ******************************************************************************
36763               *
36764               * Name: SHIP_VIPER
36765               * Type: Variable
36766               * Category: Drawing ships
36767               * Summary: Ship blueprint for a Viper
36768               * Deep dive: Ship blueprints
36769               *
36770               * ******************************************************************************
36771               
36772               SHIP_VIPER:
36773 EA22 00              byte >00                                            ; Max. canisters on demise = 0
36774 EA24 15F9            data 75 * 75                                        ; Targetable area          = 75 * 75
36775               
36776 EA26 70              byte (SHIP_VIPER_EDGES - SHIP_VIPER)%256            ; Edges data offset (low)
36777 EA27   C0            byte (SHIP_VIPER_FACES - SHIP_VIPER)%256            ; Faces data offset (low)
36778               
36779 EA28 4D              byte >4d                                            ; Max. edge count          = (77 - 1) / 4 = 19
36780 EA29   00            byte >00                                            ; Gun vertex               = 0
36781 EA2A 2A              byte >2a                                            ; Explosion count          = 9, as (4 * n) + 6 = 42
36782 EA2B   5A            byte >5a                                            ; Number of vertices       = 90 / 6 = 15
36783 EA2C 14              byte >14                                            ; Number of edges          = 20
36784 EA2E 0000            data >0000                                          ; Bounty                   = 0
36785 EA30 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
36786 EA31   17            byte >17                                            ; Visibility distance      = 23
36787 EA32 78              byte >78                                            ; Max. energy              = 120
36788 EA33   20            byte >20                                            ; Max. speed               = 32
36789               
36790 EA34 00              byte (SHIP_VIPER_EDGES - SHIP_VIPER)/256            ; Edges data offset (high)
36791 EA35   00            byte (SHIP_VIPER_FACES - SHIP_VIPER)/256            ; Faces data offset (high)
36792               
36793 EA36 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
36794 EA37   11            byte >11                                            ; Laser power              = 2
36795                                                                          ; Missiles                 = 1
36796               
36797               SHIP_VIPER_VERTICES:
36798                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36799 EA38 0000            byte >00, >00, >48, >1f, >21, >43                   ; Vertex 0
     EA3A 481F     
     EA3C 2143     
36800 EA3E 0010            byte >00, >10, >18, >1e, >10, >22                   ; Vertex 1
     EA40 181E     
     EA42 1022     
36801 EA44 0010            byte >00, >10, >18, >5e, >43, >55                   ; Vertex 2
     EA46 185E     
     EA48 4355     
36802 EA4A 3000            byte >30, >00, >18, >3f, >42, >66                   ; Vertex 3
     EA4C 183F     
     EA4E 4266     
36803 EA50 3000            byte >30, >00, >18, >bf, >31, >66                   ; Vertex 4
     EA52 18BF     
     EA54 3166     
36804 EA56 1810            byte >18, >10, >18, >7e, >54, >66                   ; Vertex 5
     EA58 187E     
     EA5A 5466     
36805 EA5C 1810            byte >18, >10, >18, >fe, >35, >66                   ; Vertex 6
     EA5E 18FE     
     EA60 3566     
36806 EA62 1810            byte >18, >10, >18, >3f, >20, >66                   ; Vertex 7
     EA64 183F     
     EA66 2066     
36807 EA68 1810            byte >18, >10, >18, >bf, >10, >66                   ; Vertex 8
     EA6A 18BF     
     EA6C 1066     
36808 EA6E 2000            byte >20, >00, >18, >b3, >66, >66                   ; Vertex 9
     EA70 18B3     
     EA72 6666     
36809 EA74 2000            byte >20, >00, >18, >33, >66, >66                   ; Vertex 10
     EA76 1833     
     EA78 6666     
36810 EA7A 0808            byte >08, >08, >18, >33, >66, >66                   ; Vertex 11
     EA7C 1833     
     EA7E 6666     
36811 EA80 0808            byte >08, >08, >18, >b3, >66, >66                   ; Vertex 12
     EA82 18B3     
     EA84 6666     
36812 EA86 0808            byte >08, >08, >18, >f2, >66, >66                   ; Vertex 13
     EA88 18F2     
     EA8A 6666     
36813 EA8C 0808            byte >08, >08, >18, >72, >66, >66                   ; Vertex 14
     EA8E 1872     
     EA90 6666     
36814               
36815               SHIP_VIPER_EDGES:
36816                                                                          ; vertex1, vertex2, face1, face2, visibility
36817 EA92 1F42            byte >1f, >42, >00, >0c                             ; Edge 0
     EA94 000C     
36818 EA96 1E21            byte >1e, >21, >00, >04                             ; Edge 1
     EA98 0004     
36819 EA9A 1E43            byte >1e, >43, >00, >08                             ; Edge 2
     EA9C 0008     
36820 EA9E 1F31            byte >1f, >31, >00, >10                             ; Edge 3
     EAA0 0010     
36821 EAA2 1E20            byte >1e, >20, >04, >1c                             ; Edge 4
     EAA4 041C     
36822 EAA6 1E10            byte >1e, >10, >04, >20                             ; Edge 5
     EAA8 0420     
36823 EAAA 1E54            byte >1e, >54, >08, >14                             ; Edge 6
     EAAC 0814     
36824 EAAE 1E53            byte >1e, >53, >08, >18                             ; Edge 7
     EAB0 0818     
36825 EAB2 1F60            byte >1f, >60, >1c, >20                             ; Edge 8
     EAB4 1C20     
36826 EAB6 1E65            byte >1e, >65, >14, >18                             ; Edge 9
     EAB8 1418     
36827 EABA 1F61            byte >1f, >61, >10, >20                             ; Edge 10
     EABC 1020     
36828 EABE 1E63            byte >1e, >63, >10, >18                             ; Edge 11
     EAC0 1018     
36829 EAC2 1F62            byte >1f, >62, >0c, >1c                             ; Edge 12
     EAC4 0C1C     
36830 EAC6 1E46            byte >1e, >46, >0c, >14                             ; Edge 13
     EAC8 0C14     
36831 EACA 1366            byte >13, >66, >24, >30                             ; Edge 14
     EACC 2430     
36832 EACE 1266            byte >12, >66, >24, >34                             ; Edge 15
     EAD0 2434     
36833 EAD2 1366            byte >13, >66, >28, >2c                             ; Edge 16
     EAD4 282C     
36834 EAD6 1266            byte >12, >66, >28, >38                             ; Edge 17
     EAD8 2838     
36835 EADA 1066            byte >10, >66, >2c, >38                             ; Edge 18
     EADC 2C38     
36836 EADE 1066            byte >10, >66, >30, >34                             ; Edge 19
     EAE0 3034     
36837               
36838               SHIP_VIPER_FACES:
36839                                                                          ; normal_x, normal_y, normal_z, visibility
36840 EAE2 1F00            byte >1f, >00, >20, >00                             ; Face 0
     EAE4 2000     
36841 EAE6 9F16            byte >9f, >16, >21, >0b                             ; Face 1
     EAE8 210B     
36842 EAEA 1F16            byte >1f, >16, >21, >0b                             ; Face 2
     EAEC 210B     
36843 EAEE DF16            byte >df, >16, >21, >0b                             ; Face 3
     EAF0 210B     
36844 EAF2 5F16            byte >5f, >16, >21, >0b                             ; Face 4
     EAF4 210B     
36845 EAF6 5F00            byte >5f, >00, >20, >00                             ; Face 5
     EAF8 2000     
36846 EAFA 3F00            byte >3f, >00, >00, >30                             ; Face 6
     EAFC 0030     
36847               
36848               * ******************************************************************************
36849               *
36850               * Name: SHIP_MAMBA
36851               * Type: Variable
36852               * Category: Drawing ships
36853               * Summary: Ship blueprint for a Mamba
36854               * Deep dive: Ship blueprints
36855               *
36856               * ******************************************************************************
36857               
36858               SHIP_MAMBA:
36859 EAFE 01              byte >01                                            ; Max. canisters on demise = 1
36860 EB00 1324            data 70 * 70                                        ; Targetable area          = 70 * 70
36861               
36862 EB02 AC              byte (SHIP_MAMBA_EDGES - SHIP_MAMBA)%256            ; Edges data offset (low)
36863 EB03   1C            byte (SHIP_MAMBA_FACES - SHIP_MAMBA)%256            ; Faces data offset (low)
36864               
36865 EB04 5D              byte >5d                                            ; Max. edge count          = (93 - 1) / 4 = 23
36866 EB05   00            byte >00                                            ; Gun vertex               = 0
36867 EB06 22              byte >22                                            ; Explosion count          = 7, as (4 * n) + 6 = 34
36868 EB07   96            byte >96                                            ; Number of vertices       = 150 / 6 = 25
36869 EB08 1C              byte >1c                                            ; Number of edges          = 28
36870 EB0A 9600            data >9600                                          ; Bounty                   = 150
36871 EB0C 14              byte >14                                            ; Number of faces          = 20 / 4 = 5
36872 EB0D   19            byte >19                                            ; Visibility distance      = 25
36873 EB0E 5A              byte >5a                                            ; Max. energy              = 90
36874 EB0F   1E            byte >1e                                            ; Max. speed               = 30
36875               
36876 EB10 00              byte (SHIP_MAMBA_EDGES - SHIP_MAMBA)/256            ; Edges data offset (high)
36877 EB11   01            byte (SHIP_MAMBA_FACES - SHIP_MAMBA)/256            ; Faces data offset (high)
36878               
36879 EB12 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
36880 EB13   12            byte >12                                            ; Laser power              = 2
36881                                                                          ; Missiles                 = 2
36882               
36883               SHIP_MAMBA_VERTICES:
36884                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36885 EB14 0000            byte >00, >00, >40, >1f, >10, >32                   ; Vertex 0
     EB16 401F     
     EB18 1032     
36886 EB1A 4008            byte >40, >08, >20, >ff, >20, >44                   ; Vertex 1
     EB1C 20FF     
     EB1E 2044     
36887 EB20 2008            byte >20, >08, >20, >be, >21, >44                   ; Vertex 2
     EB22 20BE     
     EB24 2144     
36888 EB26 2008            byte >20, >08, >20, >3e, >31, >44                   ; Vertex 3
     EB28 203E     
     EB2A 3144     
36889 EB2C 4008            byte >40, >08, >20, >7f, >30, >44                   ; Vertex 4
     EB2E 207F     
     EB30 3044     
36890 EB32 0404            byte >04, >04, >10, >8e, >11, >11                   ; Vertex 5
     EB34 108E     
     EB36 1111     
36891 EB38 0404            byte >04, >04, >10, >0e, >11, >11                   ; Vertex 6
     EB3A 100E     
     EB3C 1111     
36892 EB3E 0803            byte >08, >03, >1c, >0d, >11, >11                   ; Vertex 7
     EB40 1C0D     
     EB42 1111     
36893 EB44 0803            byte >08, >03, >1c, >8d, >11, >11                   ; Vertex 8
     EB46 1C8D     
     EB48 1111     
36894 EB4A 1404            byte >14, >04, >10, >d4, >00, >00                   ; Vertex 9
     EB4C 10D4     
     EB4E 0000     
36895 EB50 1404            byte >14, >04, >10, >54, >00, >00                   ; Vertex 10
     EB52 1054     
     EB54 0000     
36896 EB56 1807            byte >18, >07, >14, >f4, >00, >00                   ; Vertex 11
     EB58 14F4     
     EB5A 0000     
36897 EB5C 1007            byte >10, >07, >14, >f0, >00, >00                   ; Vertex 12
     EB5E 14F0     
     EB60 0000     
36898 EB62 1007            byte >10, >07, >14, >70, >00, >00                   ; Vertex 13
     EB64 1470     
     EB66 0000     
36899 EB68 1807            byte >18, >07, >14, >74, >00, >00                   ; Vertex 14
     EB6A 1474     
     EB6C 0000     
36900 EB6E 0804            byte >08, >04, >20, >ad, >44, >44                   ; Vertex 15
     EB70 20AD     
     EB72 4444     
36901 EB74 0804            byte >08, >04, >20, >2d, >44, >44                   ; Vertex 16
     EB76 202D     
     EB78 4444     
36902 EB7A 0804            byte >08, >04, >20, >6e, >44, >44                   ; Vertex 17
     EB7C 206E     
     EB7E 4444     
36903 EB80 0804            byte >08, >04, >20, >ee, >44, >44                   ; Vertex 18
     EB82 20EE     
     EB84 4444     
36904 EB86 2004            byte >20, >04, >20, >a7, >44, >44                   ; Vertex 19
     EB88 20A7     
     EB8A 4444     
36905 EB8C 2004            byte >20, >04, >20, >27, >44, >44                   ; Vertex 20
     EB8E 2027     
     EB90 4444     
36906 EB92 2404            byte >24, >04, >20, >67, >44, >44                   ; Vertex 21
     EB94 2067     
     EB96 4444     
36907 EB98 2404            byte >24, >04, >20, >e7, >44, >44                   ; Vertex 22
     EB9A 20E7     
     EB9C 4444     
36908 EB9E 2600            byte >26, >00, >20, >a5, >44, >44                   ; Vertex 23
     EBA0 20A5     
     EBA2 4444     
36909 EBA4 2600            byte >26, >00, >20, >25, >44, >44                   ; Vertex 24
     EBA6 2025     
     EBA8 4444     
36910               
36911               SHIP_MAMBA_EDGES:
36912                                                                          ; vertex1, vertex2, face1, face2, visibility
36913 EBAA 1F20            byte >1f, >20, >00, >04                             ; Edge 0
     EBAC 0004     
36914 EBAE 1F30            byte >1f, >30, >00, >10                             ; Edge 1
     EBB0 0010     
36915 EBB2 1F40            byte >1f, >40, >04, >10                             ; Edge 2
     EBB4 0410     
36916 EBB6 1E42            byte >1e, >42, >04, >08                             ; Edge 3
     EBB8 0408     
36917 EBBA 1E41            byte >1e, >41, >08, >0c                             ; Edge 4
     EBBC 080C     
36918 EBBE 1E43            byte >1e, >43, >0c, >10                             ; Edge 5
     EBC0 0C10     
36919 EBC2 0E11            byte >0e, >11, >14, >18                             ; Edge 6
     EBC4 1418     
36920 EBC6 0C11            byte >0c, >11, >18, >1c                             ; Edge 7
     EBC8 181C     
36921 EBCA 0D11            byte >0d, >11, >1c, >20                             ; Edge 8
     EBCC 1C20     
36922 EBCE 0C11            byte >0c, >11, >14, >20                             ; Edge 9
     EBD0 1420     
36923 EBD2 1400            byte >14, >00, >24, >2c                             ; Edge 10
     EBD4 242C     
36924 EBD6 1000            byte >10, >00, >24, >30                             ; Edge 11
     EBD8 2430     
36925 EBDA 1000            byte >10, >00, >28, >34                             ; Edge 12
     EBDC 2834     
36926 EBDE 1400            byte >14, >00, >28, >38                             ; Edge 13
     EBE0 2838     
36927 EBE2 0E00            byte >0e, >00, >34, >38                             ; Edge 14
     EBE4 3438     
36928 EBE6 0E00            byte >0e, >00, >2c, >30                             ; Edge 15
     EBE8 2C30     
36929 EBEA 0D44            byte >0d, >44, >3c, >40                             ; Edge 16
     EBEC 3C40     
36930 EBEE 0E44            byte >0e, >44, >44, >48                             ; Edge 17
     EBF0 4448     
36931 EBF2 0C44            byte >0c, >44, >3c, >48                             ; Edge 18
     EBF4 3C48     
36932 EBF6 0C44            byte >0c, >44, >40, >44                             ; Edge 19
     EBF8 4044     
36933 EBFA 0744            byte >07, >44, >50, >54                             ; Edge 20
     EBFC 5054     
36934 EBFE 0544            byte >05, >44, >50, >60                             ; Edge 21
     EC00 5060     
36935 EC02 0544            byte >05, >44, >54, >60                             ; Edge 22
     EC04 5460     
36936 EC06 0744            byte >07, >44, >4c, >58                             ; Edge 23
     EC08 4C58     
36937 EC0A 0544            byte >05, >44, >4c, >5c                             ; Edge 24
     EC0C 4C5C     
36938 EC0E 0544            byte >05, >44, >58, >5c                             ; Edge 25
     EC10 585C     
36939 EC12 1E21            byte >1e, >21, >00, >08                             ; Edge 26
     EC14 0008     
36940 EC16 1E31            byte >1e, >31, >00, >0c                             ; Edge 27
     EC18 000C     
36941               
36942               SHIP_MAMBA_FACES:
36943                                                                          ; normal_x, normal_y, normal_z, visibility
36944 EC1A 5E00            byte >5e, >00, >18, >02                             ; Face 0
     EC1C 1802     
36945 EC1E 1E00            byte >1e, >00, >18, >02                             ; Face 1
     EC20 1802     
36946 EC22 9E20            byte >9e, >20, >40, >10                             ; Face 2
     EC24 4010     
36947 EC26 1E20            byte >1e, >20, >40, >10                             ; Face 3
     EC28 4010     
36948 EC2A 3E00            byte >3e, >00, >00, >7f                             ; Face 4
     EC2C 007F     
36949               
36950               * ******************************************************************************
36951               *
36952               * Name: SHIP_COBRA_MK_3
36953               * Type: Variable
36954               * Category: Drawing ships
36955               * Summary: Ship blueprint for a Cobra Mk III
36956               * Deep dive: Ship blueprints
36957               *
36958               * ******************************************************************************
36959               
36960               SHIP_COBRA_MK_3:
36961 EC2E 03              byte >03                                            ; Max. canisters on demise = 3
36962 EC30 2341            data 95 * 95                                        ; Targetable area          = 95 * 95
36963               
36964 EC32 BE              byte (SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)%256  ; Edges data offset (low)
36965 EC33   56            byte (SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)%256  ; Faces data offset (low)
36966               
36967 EC34 99              byte >99                                            ; Max. edge count          = (153 - 1) / 4 = 38
36968 EC35   54            byte >54                                            ; Gun vertex               = 84 / 4 = 21
36969 EC36 2A              byte >2a                                            ; Explosion count          = 9, as (4 * n) + 6 = 42
36970 EC37   A8            byte >a8                                            ; Number of vertices       = 168 / 6 = 28
36971 EC38 26              byte >26                                            ; Number of edges          = 38
36972 EC3A 0000            data >0000                                          ; Bounty                   = 0
36973 EC3C 34              byte >34                                            ; Number of faces          = 52 / 4 = 13
36974 EC3D   32            byte >32                                            ; Visibility distance      = 50
36975 EC3E 96              byte >96                                            ; Max. energy              = 150
36976 EC3F   1C            byte >1c                                            ; Max. speed               = 28
36977               
36978 EC40 00              byte (SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)/256  ; Edges data offset (low)
36979 EC41   01            byte (SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)/256  ; Faces data offset (low)
36980               
36981 EC42 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
36982 EC43   13            byte >13                                            ; Laser power              = 2
36983                                                                          ; Missiles                 = 3
36984               
36985               SHIP_COBRA_MK_3_VERTICES:
36986                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36987 EC44 2000            byte >20, >00, >4c, >1f, >ff, >ff                   ; Vertex 0
     EC46 4C1F     
     EC48 FFFF     
36988 EC4A 2000            byte >20, >00, >4c, >9f, >ff, >ff                   ; Vertex 1
     EC4C 4C9F     
     EC4E FFFF     
36989 EC50 001A            byte >00, >1a, >18, >1f, >ff, >ff                   ; Vertex 2
     EC52 181F     
     EC54 FFFF     
36990 EC56 7803            byte >78, >03, >08, >ff, >73, >aa                   ; Vertex 3
     EC58 08FF     
     EC5A 73AA     
36991 EC5C 7803            byte >78, >03, >08, >7f, >84, >cc                   ; Vertex 4
     EC5E 087F     
     EC60 84CC     
36992 EC62 5810            byte >58, >10, >28, >bf, >ff, >ff                   ; Vertex 5
     EC64 28BF     
     EC66 FFFF     
36993 EC68 5810            byte >58, >10, >28, >3f, >ff, >ff                   ; Vertex 6
     EC6A 283F     
     EC6C FFFF     
36994 EC6E 8008            byte >80, >08, >28, >7f, >98, >cc                   ; Vertex 7
     EC70 287F     
     EC72 98CC     
36995 EC74 8008            byte >80, >08, >28, >ff, >97, >aa                   ; Vertex 8
     EC76 28FF     
     EC78 97AA     
36996 EC7A 001A            byte >00, >1a, >28, >3f, >65, >99                   ; Vertex 9
     EC7C 283F     
     EC7E 6599     
36997 EC80 2018            byte >20, >18, >28, >ff, >a9, >bb                   ; Vertex 10
     EC82 28FF     
     EC84 A9BB     
36998 EC86 2018            byte >20, >18, >28, >7f, >b9, >cc                   ; Vertex 11
     EC88 287F     
     EC8A B9CC     
36999 EC8C 2408            byte >24, >08, >28, >b4, >99, >99                   ; Vertex 12
     EC8E 28B4     
     EC90 9999     
37000 EC92 080C            byte >08, >0c, >28, >b4, >99, >99                   ; Vertex 13
     EC94 28B4     
     EC96 9999     
37001 EC98 080C            byte >08, >0c, >28, >34, >99, >99                   ; Vertex 14
     EC9A 2834     
     EC9C 9999     
37002 EC9E 2408            byte >24, >08, >28, >34, >99, >99                   ; Vertex 15
     ECA0 2834     
     ECA2 9999     
37003 ECA4 240C            byte >24, >0c, >28, >74, >99, >99                   ; Vertex 16
     ECA6 2874     
     ECA8 9999     
37004 ECAA 0810            byte >08, >10, >28, >74, >99, >99                   ; Vertex 17
     ECAC 2874     
     ECAE 9999     
37005 ECB0 0810            byte >08, >10, >28, >f4, >99, >99                   ; Vertex 18
     ECB2 28F4     
     ECB4 9999     
37006 ECB6 240C            byte >24, >0c, >28, >f4, >99, >99                   ; Vertex 19
     ECB8 28F4     
     ECBA 9999     
37007 ECBC 0000            byte >00, >00, >4c, >06, >b0, >bb                   ; Vertex 20
     ECBE 4C06     
     ECC0 B0BB     
37008 ECC2 0000            byte >00, >00, >5a, >1f, >b0, >bb                   ; Vertex 21
     ECC4 5A1F     
     ECC6 B0BB     
37009 ECC8 5006            byte >50, >06, >28, >e8, >99, >99                   ; Vertex 22
     ECCA 28E8     
     ECCC 9999     
37010 ECCE 5006            byte >50, >06, >28, >a8, >99, >99                   ; Vertex 23
     ECD0 28A8     
     ECD2 9999     
37011 ECD4 5800            byte >58, >00, >28, >a6, >99, >99                   ; Vertex 24
     ECD6 28A6     
     ECD8 9999     
37012 ECDA 5006            byte >50, >06, >28, >28, >99, >99                   ; Vertex 25
     ECDC 2828     
     ECDE 9999     
37013 ECE0 5800            byte >58, >00, >28, >26, >99, >99                   ; Vertex 26
     ECE2 2826     
     ECE4 9999     
37014 ECE6 5006            byte >50, >06, >28, >68, >99, >99                   ; Vertex 27
     ECE8 2868     
     ECEA 9999     
37015               
37016               SHIP_COBRA_MK_3_EDGES:
37017                                                                          ; vertex1, vertex2, face1, face2, visibility
37018 ECEC 1FB0            byte >1f, >b0, >00, >04                             ; Edge 0
     ECEE 0004     
37019 ECF0 1FC4            byte >1f, >c4, >00, >10                             ; Edge 1
     ECF2 0010     
37020 ECF4 1FA3            byte >1f, >a3, >04, >0c                             ; Edge 2
     ECF6 040C     
37021 ECF8 1FA7            byte >1f, >a7, >0c, >20                             ; Edge 3
     ECFA 0C20     
37022 ECFC 1FC8            byte >1f, >c8, >10, >1c                             ; Edge 4
     ECFE 101C     
37023 ED00 1F98            byte >1f, >98, >18, >1c                             ; Edge 5
     ED02 181C     
37024 ED04 1F96            byte >1f, >96, >18, >24                             ; Edge 6
     ED06 1824     
37025 ED08 1F95            byte >1f, >95, >14, >24                             ; Edge 7
     ED0A 1424     
37026 ED0C 1F97            byte >1f, >97, >14, >20                             ; Edge 8
     ED0E 1420     
37027 ED10 1F51            byte >1f, >51, >08, >14                             ; Edge 9
     ED12 0814     
37028 ED14 1F62            byte >1f, >62, >08, >18                             ; Edge 10
     ED16 0818     
37029 ED18 1F73            byte >1f, >73, >0c, >14                             ; Edge 11
     ED1A 0C14     
37030 ED1C 1F84            byte >1f, >84, >10, >18                             ; Edge 12
     ED1E 1018     
37031 ED20 1F10            byte >1f, >10, >04, >08                             ; Edge 13
     ED22 0408     
37032 ED24 1F20            byte >1f, >20, >00, >08                             ; Edge 14
     ED26 0008     
37033 ED28 1FA9            byte >1f, >a9, >20, >28                             ; Edge 15
     ED2A 2028     
37034 ED2C 1FB9            byte >1f, >b9, >28, >2c                             ; Edge 16
     ED2E 282C     
37035 ED30 1FC9            byte >1f, >c9, >1c, >2c                             ; Edge 17
     ED32 1C2C     
37036 ED34 1FBA            byte >1f, >ba, >04, >28                             ; Edge 18
     ED36 0428     
37037 ED38 1FCB            byte >1f, >cb, >00, >2c                             ; Edge 19
     ED3A 002C     
37038 ED3C 1D31            byte >1d, >31, >04, >14                             ; Edge 20
     ED3E 0414     
37039 ED40 1D42            byte >1d, >42, >00, >18                             ; Edge 21
     ED42 0018     
37040 ED44 06B0            byte >06, >b0, >50, >54                             ; Edge 22
     ED46 5054     
37041 ED48 1499            byte >14, >99, >30, >34                             ; Edge 23
     ED4A 3034     
37042 ED4C 1499            byte >14, >99, >48, >4c                             ; Edge 24
     ED4E 484C     
37043 ED50 1499            byte >14, >99, >38, >3c                             ; Edge 25
     ED52 383C     
37044 ED54 1499            byte >14, >99, >40, >44                             ; Edge 26
     ED56 4044     
37045 ED58 1399            byte >13, >99, >3c, >40                             ; Edge 27
     ED5A 3C40     
37046 ED5C 1199            byte >11, >99, >38, >44                             ; Edge 28
     ED5E 3844     
37047 ED60 1399            byte >13, >99, >34, >48                             ; Edge 29
     ED62 3448     
37048 ED64 1399            byte >13, >99, >30, >4c                             ; Edge 30
     ED66 304C     
37049 ED68 1E65            byte >1e, >65, >08, >24                             ; Edge 31
     ED6A 0824     
37050 ED6C 0699            byte >06, >99, >58, >60                             ; Edge 32
     ED6E 5860     
37051 ED70 0699            byte >06, >99, >5c, >60                             ; Edge 33
     ED72 5C60     
37052 ED74 0899            byte >08, >99, >58, >5c                             ; Edge 34
     ED76 585C     
37053 ED78 0699            byte >06, >99, >64, >68                             ; Edge 35
     ED7A 6468     
37054 ED7C 0699            byte >06, >99, >68, >6c                             ; Edge 36
     ED7E 686C     
37055 ED80 0899            byte >08, >99, >64, >6c                             ; Edge 37
     ED82 646C     
37056               
37057               SHIP_COBRA_MK_3_FACES:
37058                                                                          ; normal_x, normal_y, normal_z, visibility
37059 ED84 1F00            byte >1f, >00, >3e, >1f                             ; Face 0
     ED86 3E1F     
37060 ED88 9F12            byte >9f, >12, >37, >10                             ; Face 1
     ED8A 3710     
37061 ED8C 1F12            byte >1f, >12, >37, >10                             ; Face 2
     ED8E 3710     
37062 ED90 9F10            byte >9f, >10, >34, >0e                             ; Face 3
     ED92 340E     
37063 ED94 1F10            byte >1f, >10, >34, >0e                             ; Face 4
     ED96 340E     
37064 ED98 9F0E            byte >9f, >0e, >2f, >00                             ; Face 5
     ED9A 2F00     
37065 ED9C 1F0E            byte >1f, >0e, >2f, >00                             ; Face 6
     ED9E 2F00     
37066 EDA0 9F3D            byte >9f, >3d, >66, >00                             ; Face 7
     EDA2 6600     
37067 EDA4 1F3D            byte >1f, >3d, >66, >00                             ; Face 8
     EDA6 6600     
37068 EDA8 3F00            byte >3f, >00, >00, >50                             ; Face 9
     EDAA 0050     
37069 EDAC DF07            byte >df, >07, >2a, >09                             ; Face 10
     EDAE 2A09     
37070 EDB0 5F00            byte >5f, >00, >1e, >06                             ; Face 11
     EDB2 1E06     
37071 EDB4 5F07            byte >5f, >07, >2a, >09                             ; Face 12
     EDB6 2A09     
37072               
37073               * ******************************************************************************
37074               *
37075               * Name: SHIP_THARGOID
37076               * Type: Variable
37077               * Category: Drawing ships
37078               * Summary: Ship blueprint for a Thargoid mothership
37079               * Deep dive: Ship blueprints
37080               *
37081               * ******************************************************************************
37082               
37083               SHIP_THARGOID:
37084 EDB8 00              byte >00                                            ; Max. canisters on demise = 0
37085 EDBA 2649            data 99 * 99                                        ; Targetable area          = 99 * 99
37086               
37087 EDBC 8E              byte (SHIP_THARGOID_EDGES - SHIP_THARGOID)%256      ; Edges data offset (low)
37088 EDBD   F6            byte (SHIP_THARGOID_FACES - SHIP_THARGOID)%256      ; Faces data offset (low)
37089               
37090 EDBE 65              byte >65                                            ; Max. edge count          = (101 - 1) / 4 = 25
37091 EDBF   3C            byte >3c                                            ; Gun vertex               = 60 / 4 = 15
37092 EDC0 26              byte >26                                            ; Explosion count          = 8, as (4 * n) + 6 = 38
37093 EDC1   78            byte >78                                            ; Number of vertices       = 120 / 6 = 20
37094 EDC2 1A              byte >1a                                            ; Number of edges          = 26
37095 EDC4 F401            data >f401                                          ; Bounty                   = 500
37096 EDC6 28              byte >28                                            ; Number of faces          = 40 / 4 = 10
37097 EDC7   37            byte >37                                            ; Visibility distance      = 55
37098 EDC8 F0              byte >f0                                            ; Max. energy              = 240
37099 EDC9   27            byte >27                                            ; Max. speed               = 39
37100               
37101 EDCA 00              byte (SHIP_THARGOID_EDGES - SHIP_THARGOID)/256      ; Edges data offset (high)
37102 EDCB   00            byte (SHIP_THARGOID_FACES - SHIP_THARGOID)/256      ; Faces data offset (high)
37103               
37104 EDCC 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37105 EDCD   16            byte >16                                            ; Laser power              = 2
37106                                                                          ; Missiles                 = 6
37107               
37108               SHIP_THARGOID_VERTICES:
37109                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37110 EDCE 2030            byte >20, >30, >30, >5f, >40, >88                   ; Vertex 0
     EDD0 305F     
     EDD2 4088     
37111 EDD4 2044            byte >20, >44, >00, >5f, >10, >44                   ; Vertex 1
     EDD6 005F     
     EDD8 1044     
37112 EDDA 2030            byte >20, >30, >30, >7f, >21, >44                   ; Vertex 2
     EDDC 307F     
     EDDE 2144     
37113 EDE0 2000            byte >20, >00, >44, >3f, >32, >44                   ; Vertex 3
     EDE2 443F     
     EDE4 3244     
37114 EDE6 2030            byte >20, >30, >30, >3f, >43, >55                   ; Vertex 4
     EDE8 303F     
     EDEA 4355     
37115 EDEC 2044            byte >20, >44, >00, >1f, >54, >66                   ; Vertex 5
     EDEE 001F     
     EDF0 5466     
37116 EDF2 2030            byte >20, >30, >30, >1f, >64, >77                   ; Vertex 6
     EDF4 301F     
     EDF6 6477     
37117 EDF8 2000            byte >20, >00, >44, >1f, >74, >88                   ; Vertex 7
     EDFA 441F     
     EDFC 7488     
37118 EDFE 1874            byte >18, >74, >74, >df, >80, >99                   ; Vertex 8
     EE00 74DF     
     EE02 8099     
37119 EE04 18A4            byte >18, >a4, >00, >df, >10, >99                   ; Vertex 9
     EE06 00DF     
     EE08 1099     
37120 EE0A 1874            byte >18, >74, >74, >ff, >21, >99                   ; Vertex 10
     EE0C 74FF     
     EE0E 2199     
37121 EE10 1800            byte >18, >00, >a4, >bf, >32, >99                   ; Vertex 11
     EE12 A4BF     
     EE14 3299     
37122 EE16 1874            byte >18, >74, >74, >bf, >53, >99                   ; Vertex 12
     EE18 74BF     
     EE1A 5399     
37123 EE1C 18A4            byte >18, >a4, >00, >9f, >65, >99                   ; Vertex 13
     EE1E 009F     
     EE20 6599     
37124 EE22 1874            byte >18, >74, >74, >9f, >76, >99                   ; Vertex 14
     EE24 749F     
     EE26 7699     
37125 EE28 1800            byte >18, >00, >a4, >9f, >87, >99                   ; Vertex 15
     EE2A A49F     
     EE2C 8799     
37126 EE2E 1840            byte >18, >40, >50, >9e, >99, >99                   ; Vertex 16
     EE30 509E     
     EE32 9999     
37127 EE34 1840            byte >18, >40, >50, >be, >99, >99                   ; Vertex 17
     EE36 50BE     
     EE38 9999     
37128 EE3A 1840            byte >18, >40, >50, >fe, >99, >99                   ; Vertex 18
     EE3C 50FE     
     EE3E 9999     
37129 EE40 1840            byte >18, >40, >50, >de, >99, >99                   ; Vertex 19
     EE42 50DE     
     EE44 9999     
37130               
37131               SHIP_THARGOID_EDGES:
37132                                                                          ; vertex1, vertex2, face1, face2, visibility
37133 EE46 1F84            byte >1f, >84, >00, >1c                             ; Edge 0
     EE48 001C     
37134 EE4A 1F40            byte >1f, >40, >00, >04                             ; Edge 1
     EE4C 0004     
37135 EE4E 1F41            byte >1f, >41, >04, >08                             ; Edge 2
     EE50 0408     
37136 EE52 1F42            byte >1f, >42, >08, >0c                             ; Edge 3
     EE54 080C     
37137 EE56 1F43            byte >1f, >43, >0c, >10                             ; Edge 4
     EE58 0C10     
37138 EE5A 1F54            byte >1f, >54, >10, >14                             ; Edge 5
     EE5C 1014     
37139 EE5E 1F64            byte >1f, >64, >14, >18                             ; Edge 6
     EE60 1418     
37140 EE62 1F74            byte >1f, >74, >18, >1c                             ; Edge 7
     EE64 181C     
37141 EE66 1F80            byte >1f, >80, >00, >20                             ; Edge 8
     EE68 0020     
37142 EE6A 1F10            byte >1f, >10, >04, >24                             ; Edge 9
     EE6C 0424     
37143 EE6E 1F21            byte >1f, >21, >08, >28                             ; Edge 10
     EE70 0828     
37144 EE72 1F32            byte >1f, >32, >0c, >2c                             ; Edge 11
     EE74 0C2C     
37145 EE76 1F53            byte >1f, >53, >10, >30                             ; Edge 12
     EE78 1030     
37146 EE7A 1F65            byte >1f, >65, >14, >34                             ; Edge 13
     EE7C 1434     
37147 EE7E 1F76            byte >1f, >76, >18, >38                             ; Edge 14
     EE80 1838     
37148 EE82 1F87            byte >1f, >87, >1c, >3c                             ; Edge 15
     EE84 1C3C     
37149 EE86 1F98            byte >1f, >98, >20, >3c                             ; Edge 16
     EE88 203C     
37150 EE8A 1F90            byte >1f, >90, >20, >24                             ; Edge 17
     EE8C 2024     
37151 EE8E 1F91            byte >1f, >91, >24, >28                             ; Edge 18
     EE90 2428     
37152 EE92 1F92            byte >1f, >92, >28, >2c                             ; Edge 19
     EE94 282C     
37153 EE96 1F93            byte >1f, >93, >2c, >30                             ; Edge 20
     EE98 2C30     
37154 EE9A 1F95            byte >1f, >95, >30, >34                             ; Edge 21
     EE9C 3034     
37155 EE9E 1F96            byte >1f, >96, >34, >38                             ; Edge 22
     EEA0 3438     
37156 EEA2 1F97            byte >1f, >97, >38, >3c                             ; Edge 23
     EEA4 383C     
37157 EEA6 1E99            byte >1e, >99, >40, >44                             ; Edge 24
     EEA8 4044     
37158 EEAA 1E99            byte >1e, >99, >48, >4c                             ; Edge 25
     EEAC 484C     
37159               
37160               SHIP_THARGOID_FACES:
37161                                                                          ; normal_x, normal_y, normal_z, visibility
37162 EEAE 5F67            byte >5f, >67, >3c, >19                             ; Face 0
     EEB0 3C19     
37163 EEB2 7F67            byte >7f, >67, >3c, >19                             ; Face 1
     EEB4 3C19     
37164 EEB6 7F67            byte >7f, >67, >19, >3c                             ; Face 2
     EEB8 193C     
37165 EEBA 3F67            byte >3f, >67, >19, >3c                             ; Face 3
     EEBC 193C     
37166 EEBE 1F40            byte >1f, >40, >00, >00                             ; Face 4
     EEC0 0000     
37167 EEC2 3F67            byte >3f, >67, >3c, >19                             ; Face 5
     EEC4 3C19     
37168 EEC6 1F67            byte >1f, >67, >3c, >19                             ; Face 6
     EEC8 3C19     
37169 EECA 1F67            byte >1f, >67, >19, >3c                             ; Face 7
     EECC 193C     
37170 EECE 5F67            byte >5f, >67, >19, >3c                             ; Face 8
     EED0 193C     
37171 EED2 9F30            byte >9f, >30, >00, >00                             ; Face 9
     EED4 0000     
37172               
37173               * ******************************************************************************
37174               *
37175               * Name: SHIP_CORIOLIS
37176               * Type: Variable
37177               * Category: Drawing ships
37178               * Summary: Ship blueprint for a Coriolis space station
37179               * Deep dive: Ship blueprints
37180               *
37181               * ******************************************************************************
37182               
37183               SHIP_CORIOLIS:
37184 EED6 00              byte >00                                            ; Max. canisters on demise = 0
37185 EED8 6400            data 160 * 160                                      ; Targetable area          = 160 * 160
37186               
37187 EEDA 76              byte (SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)%256      ; Edges data offset (low)
37188 EEDB   E6            byte (SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)%256      ; Faces data offset (low)
37189               
37190 EEDC 55              byte >55                                            ; Max. edge count          = (85 - 1) / 4 = 21
37191 EEDD   00            byte >00                                            ; Gun vertex               = 0
37192 EEDE 36              byte >36                                            ; Explosion count          = 12, as (4 * n) + 6 = 54
37193 EEDF   60            byte >60                                            ; Number of vertices       = 96 / 6 = 16
37194 EEE0 1C              byte >1c                                            ; Number of edges          = 28
37195 EEE2 0000            data >0000                                          ; Bounty                   = 0
37196 EEE4 38              byte >38                                            ; Number of faces          = 56 / 4 = 14
37197 EEE5   78            byte >78                                            ; Visibility distance      = 120
37198 EEE6 F0              byte >f0                                            ; Max. energy              = 240
37199 EEE7   00            byte >00                                            ; Max. speed               = 0
37200               
37201 EEE8 00              byte (SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)/256      ; Edges data offset (high)
37202 EEE9   00            byte (SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)/256      ; Faces data offset (high)
37203               
37204 EEEA 00              byte >00                                            ; Normals are scaled by    = 2^0 = 1
37205 EEEB   06            byte >06                                            ; Laser power              = 0
37206                                                                          ; Missiles                 = 6
37207               
37208               SHIP_CORIOLIS_VERTICES:
37209                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37210 EEEC A000            byte >a0, >00, >a0, >1f, >10, >62                   ; Vertex 0
     EEEE A01F     
     EEF0 1062     
37211 EEF2 00A0            byte >00, >a0, >a0, >1f, >20, >83                   ; Vertex 1
     EEF4 A01F     
     EEF6 2083     
37212 EEF8 A000            byte >a0, >00, >a0, >9f, >30, >74                   ; Vertex 2
     EEFA A09F     
     EEFC 3074     
37213 EEFE 00A0            byte >00, >a0, >a0, >5f, >10, >54                   ; Vertex 3
     EF00 A05F     
     EF02 1054     
37214 EF04 A0A0            byte >a0, >a0, >00, >5f, >51, >a6                   ; Vertex 4
     EF06 005F     
     EF08 51A6     
37215 EF0A A0A0            byte >a0, >a0, >00, >1f, >62, >b8                   ; Vertex 5
     EF0C 001F     
     EF0E 62B8     
37216 EF10 A0A0            byte >a0, >a0, >00, >9f, >73, >c8                   ; Vertex 6
     EF12 009F     
     EF14 73C8     
37217 EF16 A0A0            byte >a0, >a0, >00, >df, >54, >97                   ; Vertex 7
     EF18 00DF     
     EF1A 5497     
37218 EF1C A000            byte >a0, >00, >a0, >3f, >a6, >db                   ; Vertex 8
     EF1E A03F     
     EF20 A6DB     
37219 EF22 00A0            byte >00, >a0, >a0, >3f, >b8, >dc                   ; Vertex 9
     EF24 A03F     
     EF26 B8DC     
37220 EF28 A000            byte >a0, >00, >a0, >bf, >97, >dc                   ; Vertex 10
     EF2A A0BF     
     EF2C 97DC     
37221 EF2E 00A0            byte >00, >a0, >a0, >7f, >95, >da                   ; Vertex 11
     EF30 A07F     
     EF32 95DA     
37222 EF34 0A1E            byte >0a, >1e, >a0, >5e, >00, >00                   ; Vertex 12
     EF36 A05E     
     EF38 0000     
37223 EF3A 0A1E            byte >0a, >1e, >a0, >1e, >00, >00                   ; Vertex 13
     EF3C A01E     
     EF3E 0000     
37224 EF40 0A1E            byte >0a, >1e, >a0, >9e, >00, >00                   ; Vertex 14
     EF42 A09E     
     EF44 0000     
37225 EF46 0A1E            byte >0a, >1e, >a0, >de, >00, >00                   ; Vertex 15
     EF48 A0DE     
     EF4A 0000     
37226               
37227               SHIP_CORIOLIS_EDGES:
37228                                                                          ; vertex1, vertex2, face1, face2, visibility
37229 EF4C 1F10            byte >1f, >10, >00, >0c                             ; Edge 0
     EF4E 000C     
37230 EF50 1F20            byte >1f, >20, >00, >04                             ; Edge 1
     EF52 0004     
37231 EF54 1F30            byte >1f, >30, >04, >08                             ; Edge 2
     EF56 0408     
37232 EF58 1F40            byte >1f, >40, >08, >0c                             ; Edge 3
     EF5A 080C     
37233 EF5C 1F51            byte >1f, >51, >0c, >10                             ; Edge 4
     EF5E 0C10     
37234 EF60 1F61            byte >1f, >61, >00, >10                             ; Edge 5
     EF62 0010     
37235 EF64 1F62            byte >1f, >62, >00, >14                             ; Edge 6
     EF66 0014     
37236 EF68 1F82            byte >1f, >82, >14, >04                             ; Edge 7
     EF6A 1404     
37237 EF6C 1F83            byte >1f, >83, >04, >18                             ; Edge 8
     EF6E 0418     
37238 EF70 1F73            byte >1f, >73, >08, >18                             ; Edge 9
     EF72 0818     
37239 EF74 1F74            byte >1f, >74, >08, >1c                             ; Edge 10
     EF76 081C     
37240 EF78 1F54            byte >1f, >54, >0c, >1c                             ; Edge 11
     EF7A 0C1C     
37241 EF7C 1FDA            byte >1f, >da, >20, >2c                             ; Edge 12
     EF7E 202C     
37242 EF80 1FDB            byte >1f, >db, >20, >24                             ; Edge 13
     EF82 2024     
37243 EF84 1FDC            byte >1f, >dc, >24, >28                             ; Edge 14
     EF86 2428     
37244 EF88 1FD9            byte >1f, >d9, >28, >2c                             ; Edge 15
     EF8A 282C     
37245 EF8C 1FA5            byte >1f, >a5, >10, >2c                             ; Edge 16
     EF8E 102C     
37246 EF90 1FA6            byte >1f, >a6, >10, >20                             ; Edge 17
     EF92 1020     
37247 EF94 1FB6            byte >1f, >b6, >14, >20                             ; Edge 18
     EF96 1420     
37248 EF98 1FB8            byte >1f, >b8, >14, >24                             ; Edge 19
     EF9A 1424     
37249 EF9C 1FC8            byte >1f, >c8, >18, >24                             ; Edge 20
     EF9E 1824     
37250 EFA0 1FC7            byte >1f, >c7, >18, >28                             ; Edge 21
     EFA2 1828     
37251 EFA4 1F97            byte >1f, >97, >1c, >28                             ; Edge 22
     EFA6 1C28     
37252 EFA8 1F95            byte >1f, >95, >1c, >2c                             ; Edge 23
     EFAA 1C2C     
37253 EFAC 1E00            byte >1e, >00, >30, >34                             ; Edge 24
     EFAE 3034     
37254 EFB0 1E00            byte >1e, >00, >34, >38                             ; Edge 25
     EFB2 3438     
37255 EFB4 1E00            byte >1e, >00, >38, >3c                             ; Edge 26
     EFB6 383C     
37256 EFB8 1E00            byte >1e, >00, >3c, >30                             ; Edge 27
     EFBA 3C30     
37257               
37258               SHIP_CORIOLIS_FACES:
37259                                                                          ; normal_x, normal_y, normal_z, visibility
37260 EFBC 1F00            byte >1f, >00, >00, >a0                             ; Face 0
     EFBE 00A0     
37261 EFC0 5F6B            byte >5f, >6b, >6b, >6b                             ; Face 1
     EFC2 6B6B     
37262 EFC4 1F6B            byte >1f, >6b, >6b, >6b                             ; Face 2
     EFC6 6B6B     
37263 EFC8 9F6B            byte >9f, >6b, >6b, >6b                             ; Face 3
     EFCA 6B6B     
37264 EFCC DF6B            byte >df, >6b, >6b, >6b                             ; Face 4
     EFCE 6B6B     
37265 EFD0 5F00            byte >5f, >00, >a0, >00                             ; Face 5
     EFD2 A000     
37266 EFD4 1FA0            byte >1f, >a0, >00, >00                             ; Face 6
     EFD6 0000     
37267 EFD8 9FA0            byte >9f, >a0, >00, >00                             ; Face 7
     EFDA 0000     
37268 EFDC 1F00            byte >1f, >00, >a0, >00                             ; Face 8
     EFDE A000     
37269 EFE0 FF6B            byte >ff, >6b, >6b, >6b                             ; Face 9
     EFE2 6B6B     
37270 EFE4 7F6B            byte >7f, >6b, >6b, >6b                             ; Face 10
     EFE6 6B6B     
37271 EFE8 3F6B            byte >3f, >6b, >6b, >6b                             ; Face 11
     EFEA 6B6B     
37272 EFEC BF6B            byte >bf, >6b, >6b, >6b                             ; Face 12
     EFEE 6B6B     
37273 EFF0 3F00            byte >3f, >00, >00, >a0                             ; Face 13
     EFF2 00A0     
37274               
37275               * ******************************************************************************
37276               *
37277               * Name: SHIP_MISSILE
37278               * Type: Variable
37279               * Category: Drawing ships
37280               * Summary: Ship blueprint for a missile
37281               * Deep dive: Ship blueprints
37282               *
37283               * ******************************************************************************
37284               
37285               SHIP_MISSILE:
37286 EFF4 00              byte >00                                            ; Max. canisters on demise = 0
37287 EFF6 0640            data 40 * 40                                        ; Targetable area          = 40 * 40
37288               
37289 EFF8 7C              byte (SHIP_MISSILE_EDGES - SHIP_MISSILE)%256        ; Edges data offset (low)
37290 EFF9   DC            byte (SHIP_MISSILE_FACES - SHIP_MISSILE)%256        ; Faces data offset (low)
37291               
37292 EFFA 51              byte >51                                            ; Max. edge count          = (81 - 1) / 4 = 20
37293 EFFB   00            byte >00                                            ; Gun vertex               = 0
37294 EFFC 0A              byte >0a                                            ; Explosion count          = 1, as (4 * n) + 6 = 10
37295 EFFD   66            byte >66                                            ; Number of vertices       = 102 / 6 = 17
37296 EFFE 18              byte >18                                            ; Number of edges          = 24
37297 F000 0000            data >0000                                          ; Bounty                   = 0
37298 F002 24              byte >24                                            ; Number of faces          = 36 / 4 = 9
37299 F003   0E            byte >0e                                            ; Visibility distance      = 14
37300 F004 02              byte >02                                            ; Max. energy              = 2
37301 F005   2C            byte >2c                                            ; Max. speed               = 44
37302               
37303 F006 00              byte (SHIP_MISSILE_EDGES - SHIP_MISSILE)/256        ; Edges data offset (high)
37304 F007   00            byte (SHIP_MISSILE_FACES - SHIP_MISSILE)/256        ; Faces data offset (high)
37305               
37306 F008 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37307 F009   00            byte >00                                            ; Laser power              = 0
37308                                                                          ; Missiles                 = 0
37309               
37310               SHIP_MISSILE_VERTICES:
37311                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37312 F00A 0000            byte >00, >00, >44, >1f, >10, >32                   ; Vertex 0
     F00C 441F     
     F00E 1032     
37313 F010 0808            byte >08, >08, >24, >5f, >21, >54                   ; Vertex 1
     F012 245F     
     F014 2154     
37314 F016 0808            byte >08, >08, >24, >1f, >32, >74                   ; Vertex 2
     F018 241F     
     F01A 3274     
37315 F01C 0808            byte >08, >08, >24, >9f, >30, >76                   ; Vertex 3
     F01E 249F     
     F020 3076     
37316 F022 0808            byte >08, >08, >24, >df, >10, >65                   ; Vertex 4
     F024 24DF     
     F026 1065     
37317 F028 0808            byte >08, >08, >2c, >3f, >74, >88                   ; Vertex 5
     F02A 2C3F     
     F02C 7488     
37318 F02E 0808            byte >08, >08, >2c, >7f, >54, >88                   ; Vertex 6
     F030 2C7F     
     F032 5488     
37319 F034 0808            byte >08, >08, >2c, >ff, >65, >88                   ; Vertex 7
     F036 2CFF     
     F038 6588     
37320 F03A 0808            byte >08, >08, >2c, >bf, >76, >88                   ; Vertex 8
     F03C 2CBF     
     F03E 7688     
37321 F040 0C0C            byte >0c, >0c, >2c, >28, >74, >88                   ; Vertex 9
     F042 2C28     
     F044 7488     
37322 F046 0C0C            byte >0c, >0c, >2c, >68, >54, >88                   ; Vertex 10
     F048 2C68     
     F04A 5488     
37323 F04C 0C0C            byte >0c, >0c, >2c, >e8, >65, >88                   ; Vertex 11
     F04E 2CE8     
     F050 6588     
37324 F052 0C0C            byte >0c, >0c, >2c, >a8, >76, >88                   ; Vertex 12
     F054 2CA8     
     F056 7688     
37325 F058 0808            byte >08, >08, >0c, >a8, >76, >77                   ; Vertex 13
     F05A 0CA8     
     F05C 7677     
37326 F05E 0808            byte >08, >08, >0c, >e8, >65, >66                   ; Vertex 14
     F060 0CE8     
     F062 6566     
37327 F064 0808            byte >08, >08, >0c, >28, >74, >77                   ; Vertex 15
     F066 0C28     
     F068 7477     
37328 F06A 0808            byte >08, >08, >0c, >68, >54, >55                   ; Vertex 16
     F06C 0C68     
     F06E 5455     
37329               
37330               SHIP_MISSILE_EDGES:
37331                                                                          ; vertex1, vertex2, face1, face2, visibility
37332 F070 1F21            byte >1f, >21, >00, >04                             ; Edge 0
     F072 0004     
37333 F074 1F32            byte >1f, >32, >00, >08                             ; Edge 1
     F076 0008     
37334 F078 1F30            byte >1f, >30, >00, >0c                             ; Edge 2
     F07A 000C     
37335 F07C 1F10            byte >1f, >10, >00, >10                             ; Edge 3
     F07E 0010     
37336 F080 1F24            byte >1f, >24, >04, >08                             ; Edge 4
     F082 0408     
37337 F084 1F51            byte >1f, >51, >04, >10                             ; Edge 5
     F086 0410     
37338 F088 1F60            byte >1f, >60, >0c, >10                             ; Edge 6
     F08A 0C10     
37339 F08C 1F73            byte >1f, >73, >08, >0c                             ; Edge 7
     F08E 080C     
37340 F090 1F74            byte >1f, >74, >08, >14                             ; Edge 8
     F092 0814     
37341 F094 1F54            byte >1f, >54, >04, >18                             ; Edge 9
     F096 0418     
37342 F098 1F65            byte >1f, >65, >10, >1c                             ; Edge 10
     F09A 101C     
37343 F09C 1F76            byte >1f, >76, >0c, >20                             ; Edge 11
     F09E 0C20     
37344 F0A0 1F86            byte >1f, >86, >1c, >20                             ; Edge 12
     F0A2 1C20     
37345 F0A4 1F87            byte >1f, >87, >14, >20                             ; Edge 13
     F0A6 1420     
37346 F0A8 1F84            byte >1f, >84, >14, >18                             ; Edge 14
     F0AA 1418     
37347 F0AC 1F85            byte >1f, >85, >18, >1c                             ; Edge 15
     F0AE 181C     
37348 F0B0 0885            byte >08, >85, >18, >28                             ; Edge 16
     F0B2 1828     
37349 F0B4 0887            byte >08, >87, >14, >24                             ; Edge 17
     F0B6 1424     
37350 F0B8 0887            byte >08, >87, >20, >30                             ; Edge 18
     F0BA 2030     
37351 F0BC 0885            byte >08, >85, >1c, >2c                             ; Edge 19
     F0BE 1C2C     
37352 F0C0 0874            byte >08, >74, >24, >3c                             ; Edge 20
     F0C2 243C     
37353 F0C4 0854            byte >08, >54, >28, >40                             ; Edge 21
     F0C6 2840     
37354 F0C8 0876            byte >08, >76, >30, >34                             ; Edge 22
     F0CA 3034     
37355 F0CC 0865            byte >08, >65, >2c, >38                             ; Edge 23
     F0CE 2C38     
37356               
37357               SHIP_MISSILE_FACES:
37358                                                                          ; normal_x, normal_y, normal_z, visibility
37359 F0D0 9F40            byte >9f, >40, >00, >10                             ; Face 0
     F0D2 0010     
37360 F0D4 5F00            byte >5f, >00, >40, >10                             ; Face 1
     F0D6 4010     
37361 F0D8 1F40            byte >1f, >40, >00, >10                             ; Face 2
     F0DA 0010     
37362 F0DC 1F00            byte >1f, >00, >40, >10                             ; Face 3
     F0DE 4010     
37363 F0E0 1F20            byte >1f, >20, >00, >00                             ; Face 4
     F0E2 0000     
37364 F0E4 5F00            byte >5f, >00, >20, >00                             ; Face 5
     F0E6 2000     
37365 F0E8 9F20            byte >9f, >20, >00, >00                             ; Face 6
     F0EA 0000     
37366 F0EC 1F00            byte >1f, >00, >20, >00                             ; Face 7
     F0EE 2000     
37367 F0F0 3F00            byte >3f, >00, >00, >b0                             ; Face 8
     F0F2 00B0     
37368               
37369               * ******************************************************************************
37370               *
37371               * Name: SHIP_ASTEROID
37372               * Type: Variable
37373               * Category: Drawing ships
37374               * Summary: Ship blueprint for an asteroid
37375               * Deep dive: Ship blueprints
37376               *
37377               * ******************************************************************************
37378               
37379               SHIP_ASTEROID:
37380 F0F4 00              byte >00                                            ; Max. canisters on demise = 0
37381 F0F6 1900            data 80 * 80                                        ; Targetable area          = 80 * 80
37382               
37383 F0F8 4C              byte (SHIP_ASTEROID_EDGES - SHIP_ASTEROID)%256      ; Edges data offset (low)
37384 F0F9   A0            byte (SHIP_ASTEROID_FACES - SHIP_ASTEROID)%256      ; Faces data offset (low)
37385               
37386 F0FA 41              byte >41                                            ; Max. edge count          = (65 - 1) / 4 = 16
37387 F0FB   00            byte >00                                            ; Gun vertex               = 0
37388 F0FC 22              byte >22                                            ; Explosion count          = 7, as (4 * n) + 6 = 34
37389 F0FD   36            byte >36                                            ; Number of vertices       = 54 / 6 = 9
37390 F0FE 15              byte >15                                            ; Number of edges          = 21
37391 F100 0500            data >0500                                          ; Bounty                   = 5
37392 F102 38              byte >38                                            ; Number of faces          = 56 / 4 = 14
37393 F103   32            byte >32                                            ; Visibility distance      = 50
37394 F104 3C              byte >3c                                            ; Max. energy              = 60
37395 F105   1E            byte >1e                                            ; Max. speed               = 30
37396               
37397 F106 00              byte (SHIP_ASTEROID_EDGES - SHIP_ASTEROID)/256      ; Edges data offset (high)
37398 F107   00            byte (SHIP_ASTEROID_FACES - SHIP_ASTEROID)/256      ; Faces data offset (high)
37399               
37400 F108 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
37401 F109   00            byte >00                                            ; Laser power              = 0
37402                                                                          ; Missiles                 = 0
37403               
37404               SHIP_ASTEROID_VERTICES:
37405                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37406 F10A 0050            byte >00, >50, >00, >1f, >ff, >ff                   ; Vertex 0
     F10C 001F     
     F10E FFFF     
37407 F110 500A            byte >50, >0a, >00, >df, >ff, >ff                   ; Vertex 1
     F112 00DF     
     F114 FFFF     
37408 F116 0050            byte >00, >50, >00, >5f, >ff, >ff                   ; Vertex 2
     F118 005F     
     F11A FFFF     
37409 F11C 4628            byte >46, >28, >00, >5f, >ff, >ff                   ; Vertex 3
     F11E 005F     
     F120 FFFF     
37410 F122 3C32            byte >3c, >32, >00, >1f, >65, >dc                   ; Vertex 4
     F124 001F     
     F126 65DC     
37411 F128 3200            byte >32, >00, >3c, >1f, >ff, >ff                   ; Vertex 5
     F12A 3C1F     
     F12C FFFF     
37412 F12E 2800            byte >28, >00, >46, >9f, >10, >32                   ; Vertex 6
     F130 469F     
     F132 1032     
37413 F134 001E            byte >00, >1e, >4b, >3f, >ff, >ff                   ; Vertex 7
     F136 4B3F     
     F138 FFFF     
37414 F13A 0032            byte >00, >32, >3c, >7f, >98, >ba                   ; Vertex 8
     F13C 3C7F     
     F13E 98BA     
37415               
37416               SHIP_ASTEROID_EDGES:
37417                                                                          ; vertex1, vertex2, face1, face2, visibility
37418 F140 1F72            byte >1f, >72, >00, >04                             ; Edge 0
     F142 0004     
37419 F144 1FD6            byte >1f, >d6, >00, >10                             ; Edge 1
     F146 0010     
37420 F148 1FC5            byte >1f, >c5, >0c, >10                             ; Edge 2
     F14A 0C10     
37421 F14C 1FB4            byte >1f, >b4, >08, >0c                             ; Edge 3
     F14E 080C     
37422 F150 1FA3            byte >1f, >a3, >04, >08                             ; Edge 4
     F152 0408     
37423 F154 1F32            byte >1f, >32, >04, >18                             ; Edge 5
     F156 0418     
37424 F158 1F31            byte >1f, >31, >08, >18                             ; Edge 6
     F15A 0818     
37425 F15C 1F41            byte >1f, >41, >08, >14                             ; Edge 7
     F15E 0814     
37426 F160 1F10            byte >1f, >10, >14, >18                             ; Edge 8
     F162 1418     
37427 F164 1F60            byte >1f, >60, >00, >14                             ; Edge 9
     F166 0014     
37428 F168 1F54            byte >1f, >54, >0c, >14                             ; Edge 10
     F16A 0C14     
37429 F16C 1F20            byte >1f, >20, >00, >18                             ; Edge 11
     F16E 0018     
37430 F170 1F65            byte >1f, >65, >10, >14                             ; Edge 12
     F172 1014     
37431 F174 1FA8            byte >1f, >a8, >04, >20                             ; Edge 13
     F176 0420     
37432 F178 1F87            byte >1f, >87, >04, >1c                             ; Edge 14
     F17A 041C     
37433 F17C 1FD7            byte >1f, >d7, >00, >1c                             ; Edge 15
     F17E 001C     
37434 F180 1FDC            byte >1f, >dc, >10, >1c                             ; Edge 16
     F182 101C     
37435 F184 1FC9            byte >1f, >c9, >0c, >1c                             ; Edge 17
     F186 0C1C     
37436 F188 1FB9            byte >1f, >b9, >0c, >20                             ; Edge 18
     F18A 0C20     
37437 F18C 1FBA            byte >1f, >ba, >08, >20                             ; Edge 19
     F18E 0820     
37438 F190 1F98            byte >1f, >98, >1c, >20                             ; Edge 20
     F192 1C20     
37439               
37440               SHIP_ASTEROID_FACES:
37441                                                                          ; normal_x, normal_y, normal_z, visibility
37442 F194 1F09            byte >1f, >09, >42, >51                             ; Face 0
     F196 4251     
37443 F198 5F09            byte >5f, >09, >42, >51                             ; Face 1
     F19A 4251     
37444 F19C 9F48            byte >9f, >48, >40, >1f                             ; Face 2
     F19E 401F     
37445 F1A0 DF40            byte >df, >40, >49, >2f                             ; Face 3
     F1A2 492F     
37446 F1A4 5F2D            byte >5f, >2d, >4f, >41                             ; Face 4
     F1A6 4F41     
37447 F1A8 1F87            byte >1f, >87, >0f, >23                             ; Face 5
     F1AA 0F23     
37448 F1AC 1F26            byte >1f, >26, >4c, >46                             ; Face 6
     F1AE 4C46     
37449 F1B0 BF42            byte >bf, >42, >3b, >27                             ; Face 7
     F1B2 3B27     
37450 F1B4 FF43            byte >ff, >43, >0f, >50                             ; Face 8
     F1B6 0F50     
37451 F1B8 7F42            byte >7f, >42, >0e, >4b                             ; Face 9
     F1BA 0E4B     
37452 F1BC FF46            byte >ff, >46, >50, >28                             ; Face 10
     F1BE 5028     
37453 F1C0 7F3A            byte >7f, >3a, >66, >33                             ; Face 11
     F1C2 6633     
37454 F1C4 3F51            byte >3f, >51, >09, >43                             ; Face 12
     F1C6 0943     
37455 F1C8 3F2F            byte >3f, >2f, >5e, >3f                             ; Face 13
     F1CA 5E3F     
37456               
37457               * ******************************************************************************
37458               *
37459               * Name: SHIP_CANISTER
37460               * Type: Variable
37461               * Category: Drawing ships
37462               * Summary: Ship blueprint for a cargo canister
37463               * Deep dive: Ship blueprints
37464               *
37465               * ******************************************************************************
37466               
37467               SHIP_CANISTER:
37468 F1CC 00              byte >00                                            ; Max. canisters on demise = 0
37469 F1CE 0190            data 20 * 20                                        ; Targetable area          = 20 * 20
37470               
37471 F1D0 52              byte (SHIP_CANISTER_EDGES - SHIP_CANISTER)%256      ; Edges data offset (low)
37472 F1D1   8E            byte (SHIP_CANISTER_FACES - SHIP_CANISTER)%256      ; Faces data offset (low)
37473               
37474 F1D2 31              byte >31                                            ; Max. edge count          = (49 - 1) / 4 = 12
37475 F1D3   00            byte >00                                            ; Gun vertex               = 0
37476 F1D4 12              byte >12                                            ; Explosion count          = 3, as (4 * n) + 6 = 18
37477 F1D5   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
37478 F1D6 0F              byte >0f                                            ; Number of edges          = 15
37479 F1D8 0000            data >0000                                          ; Bounty                   = 0
37480 F1DA 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
37481 F1DB   0C            byte >0c                                            ; Visibility distance      = 12
37482 F1DC 11              byte >11                                            ; Max. energy              = 17
37483 F1DD   0F            byte >0f                                            ; Max. speed               = 15
37484               
37485 F1DE 00              byte (SHIP_CANISTER_EDGES - SHIP_CANISTER)/256      ; Edges data offset (high)
37486 F1DF   00            byte (SHIP_CANISTER_FACES - SHIP_CANISTER)/256      ; Faces data offset (high)
37487               
37488 F1E0 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37489 F1E1   00            byte >00                                            ; Laser power              = 0
37490                                                                          ; Missiles                 = 0
37491               
37492               SHIP_CANISTER_VERTICES:
37493                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37494 F1E2 1810            byte >18, >10, >00, >1f, >10, >55                   ; Vertex 0
     F1E4 001F     
     F1E6 1055     
37495 F1E8 1805            byte >18, >05, >0f, >1f, >10, >22                   ; Vertex 1
     F1EA 0F1F     
     F1EC 1022     
37496 F1EE 180D            byte >18, >0d, >09, >5f, >20, >33                   ; Vertex 2
     F1F0 095F     
     F1F2 2033     
37497 F1F4 180D            byte >18, >0d, >09, >7f, >30, >44                   ; Vertex 3
     F1F6 097F     
     F1F8 3044     
37498 F1FA 1805            byte >18, >05, >0f, >3f, >40, >55                   ; Vertex 4
     F1FC 0F3F     
     F1FE 4055     
37499 F200 1810            byte >18, >10, >00, >9f, >51, >66                   ; Vertex 5
     F202 009F     
     F204 5166     
37500 F206 1805            byte >18, >05, >0f, >9f, >21, >66                   ; Vertex 6
     F208 0F9F     
     F20A 2166     
37501 F20C 180D            byte >18, >0d, >09, >df, >32, >66                   ; Vertex 7
     F20E 09DF     
     F210 3266     
37502 F212 180D            byte >18, >0d, >09, >ff, >43, >66                   ; Vertex 8
     F214 09FF     
     F216 4366     
37503 F218 1805            byte >18, >05, >0f, >bf, >54, >66                   ; Vertex 9
     F21A 0FBF     
     F21C 5466     
37504               
37505               SHIP_CANISTER_EDGES:
37506                                                                          ; vertex1, vertex2, face1, face2, visibility
37507 F21E 1F10            byte >1f, >10, >00, >04                             ; Edge 0
     F220 0004     
37508 F222 1F20            byte >1f, >20, >04, >08                             ; Edge 1
     F224 0408     
37509 F226 1F30            byte >1f, >30, >08, >0c                             ; Edge 2
     F228 080C     
37510 F22A 1F40            byte >1f, >40, >0c, >10                             ; Edge 3
     F22C 0C10     
37511 F22E 1F50            byte >1f, >50, >00, >10                             ; Edge 4
     F230 0010     
37512 F232 1F51            byte >1f, >51, >00, >14                             ; Edge 5
     F234 0014     
37513 F236 1F21            byte >1f, >21, >04, >18                             ; Edge 6
     F238 0418     
37514 F23A 1F32            byte >1f, >32, >08, >1c                             ; Edge 7
     F23C 081C     
37515 F23E 1F43            byte >1f, >43, >0c, >20                             ; Edge 8
     F240 0C20     
37516 F242 1F54            byte >1f, >54, >10, >24                             ; Edge 9
     F244 1024     
37517 F246 1F61            byte >1f, >61, >14, >18                             ; Edge 10
     F248 1418     
37518 F24A 1F62            byte >1f, >62, >18, >1c                             ; Edge 11
     F24C 181C     
37519 F24E 1F63            byte >1f, >63, >1c, >20                             ; Edge 12
     F250 1C20     
37520 F252 1F64            byte >1f, >64, >20, >24                             ; Edge 13
     F254 2024     
37521 F256 1F65            byte >1f, >65, >24, >14                             ; Edge 14
     F258 2414     
37522               
37523               SHIP_CANISTER_FACES:
37524                                                                          ; normal_x, normal_y, normal_z, visibility
37525 F25A 1F60            byte >1f, >60, >00, >00                             ; Face 0
     F25C 0000     
37526 F25E 1F00            byte >1f, >00, >29, >1e                             ; Face 1
     F260 291E     
37527 F262 5F00            byte >5f, >00, >12, >30                             ; Face 2
     F264 1230     
37528 F266 5F00            byte >5f, >00, >33, >00                             ; Face 3
     F268 3300     
37529 F26A 7F00            byte >7f, >00, >12, >30                             ; Face 4
     F26C 1230     
37530 F26E 3F00            byte >3f, >00, >29, >1e                             ; Face 5
     F270 291E     
37531 F272 9F60            byte >9f, >60, >00, >00                             ; Face 6
     F274 0000     
37532               
37533               * ******************************************************************************
37534               *
37535               * Name: SHIP_THARGON
37536               * Type: Variable
37537               * Category: Drawing ships
37538               * Summary: Ship blueprint for a Thargon
37539               * Deep dive: Ship blueprints
37540               *
37541               * ------------------------------------------------------------------------------
37542               *
37543               * The ship blueprint for the Thargon reuses the edges data from the cargo
37544               * canister, so the edges data offset is negative.
37545               *
37546               * ******************************************************************************
37547               
37548               SHIP_THARGON:
37549 F276 00              byte >00                                            ; Max. canisters on demise = 0
37550 F278 0640            data 40 * 40                                        ; Targetable area          = 40 * 40
37551               
37552 F27A 58              byte (SHIP_CANISTER_EDGES - SHIP_THARGON)%256       ; Edges from canister
37553 F27B   52            byte (SHIP_THARGON_FACES - SHIP_THARGON)%256        ; Faces data offset (low)
37554               
37555 F27C 41              byte >41                                            ; Max. edge count          = (65 - 1) / 4 = 16
37556 F27D   00            byte >00                                            ; Gun vertex               = 0
37557 F27E 12              byte >12                                            ; Explosion count          = 3, as (4 * n) + 6 = 18
37558 F27F   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
37559 F280 0F              byte >0f                                            ; Number of edges          = 15
37560 F282 3200            data >3200                                          ; Bounty                   = 50
37561 F284 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
37562 F285   14            byte >14                                            ; Visibility distance      = 20
37563 F286 14              byte >14                                            ; Max. energy              = 20
37564 F287   1E            byte >1e                                            ; Max. speed               = 30
37565               
37566 F288 00              byte (SHIP_CANISTER_EDGES - SHIP_THARGON)/256       ; Edges from canister
37567 F289   00            byte (SHIP_THARGON_FACES - SHIP_THARGON)/256        ; Faces data offset (high)
37568               
37569 F28A 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37570 F28B   10            byte >10                                            ; Laser power              = 2
37571                                                                          ; Missiles                 = 0
37572               
37573               SHIP_THARGON_VERTICES:
37574                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37575 F28C 0900            byte >09, >00, >28, >9f, >01, >55                   ; Vertex 0
     F28E 289F     
     F290 0155     
37576 F292 0926            byte >09, >26, >0c, >df, >01, >22                   ; Vertex 1
     F294 0CDF     
     F296 0122     
37577 F298 0918            byte >09, >18, >20, >ff, >02, >33                   ; Vertex 2
     F29A 20FF     
     F29C 0233     
37578 F29E 0918            byte >09, >18, >20, >bf, >03, >44                   ; Vertex 3
     F2A0 20BF     
     F2A2 0344     
37579 F2A4 0926            byte >09, >26, >0c, >9f, >04, >55                   ; Vertex 4
     F2A6 0C9F     
     F2A8 0455     
37580 F2AA 0900            byte >09, >00, >08, >3f, >15, >66                   ; Vertex 5
     F2AC 083F     
     F2AE 1566     
37581 F2B0 090A            byte >09, >0a, >0f, >7f, >12, >66                   ; Vertex 6
     F2B2 0F7F     
     F2B4 1266     
37582 F2B6 0906            byte >09, >06, >1a, >7f, >23, >66                   ; Vertex 7
     F2B8 1A7F     
     F2BA 2366     
37583 F2BC 0906            byte >09, >06, >1a, >3f, >34, >66                   ; Vertex 8
     F2BE 1A3F     
     F2C0 3466     
37584 F2C2 090A            byte >09, >0a, >0f, >3f, >45, >66                   ; Vertex 9
     F2C4 0F3F     
     F2C6 4566     
37585               
37586               SHIP_THARGON_FACES:
37587                                                                          ; normal_x, normal_y, normal_z, visibility
37588 F2C8 9F24            byte >9f, >24, >00, >00                             ; Face 0
     F2CA 0000     
37589 F2CC 5F14            byte >5f, >14, >05, >07                             ; Face 1
     F2CE 0507     
37590 F2D0 7F2E            byte >7f, >2e, >2a, >0e                             ; Face 2
     F2D2 2A0E     
37591 F2D4 3F24            byte >3f, >24, >00, >68                             ; Face 3
     F2D6 0068     
37592 F2D8 3F2E            byte >3f, >2e, >2a, >0e                             ; Face 4
     F2DA 2A0E     
37593 F2DC 1F14            byte >1f, >14, >05, >07                             ; Face 5
     F2DE 0507     
37594 F2E0 1F24            byte >1f, >24, >00, >00                             ; Face 6
     F2E2 0000     
37595               
37596               * ******************************************************************************
37597               *
37598               * Name: SHIP_ESCAPE_POD
37599               * Type: Variable
37600               * Category: Drawing ships
37601               * Summary: Ship blueprint for an escape pod
37602               * Deep dive: Ship blueprints
37603               *
37604               * ******************************************************************************
37605               
37606               SHIP_ESCAPE_POD:
37607 F2E4 00              byte >00                                            ; Max. canisters on demise = 0
37608 F2E6 0100            data 16 * 16                                        ; Targetable area          = 16 * 16
37609               
37610 F2E8 2E              byte (SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)%256  ; Edges data offset (low)
37611 F2E9   46            byte (SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)%256  ; Faces data offset (low)
37612               
37613 F2EA 19              byte >19                                            ; Max. edge count          = (25 - 1) / 4 = 6
37614 F2EB   00            byte >00                                            ; Gun vertex               = 0
37615 F2EC 16              byte >16                                            ; Explosion count          = 4, as (4 * n) + 6 = 22
37616 F2ED   18            byte >18                                            ; Number of vertices       = 24 / 6 = 4
37617 F2EE 06              byte >06                                            ; Number of edges          = 6
37618 F2F0 0000            data >0000                                          ; Bounty                   = 0
37619 F2F2 10              byte >10                                            ; Number of faces          = 16 / 4 = 4
37620 F2F3   08            byte >08                                            ; Visibility distance      = 8
37621 F2F4 11              byte >11                                            ; Max. energy              = 17
37622 F2F5   08            byte >08                                            ; Max. speed               = 8
37623               
37624 F2F6 00              byte (SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)/256  ; Edges data offset (high)
37625 F2F7   00            byte (SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)/256  ; Faces data offset (high)
37626               
37627 F2F8 03              byte >03                                            ; Normals are scaled by    =  2^3 = 8
37628 F2F9   00            byte >00                                            ; Laser power              = 0
37629                                                                          ; Missiles                 = 0
37630               
37631               SHIP_ESCAPE_POD_VERTICES:
37632                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37633 F2FA 0700            byte >07, >00, >24, >9f, >12, >33                   ; Vertex 0
     F2FC 249F     
     F2FE 1233     
37634 F300 070E            byte >07, >0e, >0c, >ff, >02, >33                   ; Vertex 1
     F302 0CFF     
     F304 0233     
37635 F306 070E            byte >07, >0e, >0c, >bf, >01, >33                   ; Vertex 2
     F308 0CBF     
     F30A 0133     
37636 F30C 1500            byte >15, >00, >00, >1f, >01, >22                   ; Vertex 3
     F30E 001F     
     F310 0122     
37637               
37638               SHIP_ESCAPE_POD_EDGES:
37639                                                                          ; vertex1, vertex2, face1, face2, visibility
37640 F312 1F23            byte >1f, >23, >00, >04                             ; Edge 0
     F314 0004     
37641 F316 1F03            byte >1f, >03, >04, >08                             ; Edge 1
     F318 0408     
37642 F31A 1F01            byte >1f, >01, >08, >0c                             ; Edge 2
     F31C 080C     
37643 F31E 1F12            byte >1f, >12, >0c, >00                             ; Edge 3
     F320 0C00     
37644 F322 1F13            byte >1f, >13, >00, >08                             ; Edge 4
     F324 0008     
37645 F326 1F02            byte >1f, >02, >0c, >04                             ; Edge 5
     F328 0C04     
37646               
37647               SHIP_ESCAPE_POD_FACES:
37648                                                                          ; normal_x, normal_y, normal_z, visibility
37649 F32A 3F1A            byte >3f, >1a, >00, >3d                             ; Face 0
     F32C 003D     
37650 F32E 1F13            byte >1f, >13, >33, >0f                             ; Face 1
     F330 330F     
37651 F332 5F13            byte >5f, >13, >33, >0f                             ; Face 2
     F334 330F     
37652 F336 9F38            byte >9f, >38, >00, >00                             ; Face 3
     F338 0000     
37653               
37654               * ******************************************************************************
37655               *
37656               * Save SHIPS.bin
37657               *
37658               * ******************************************************************************
37659               
37660                      ; PRINT "SHIPS"
37661                      ; PRINT "Assembled at ", ~CODE_SHIPS%
37662                      ; PRINT "Ends at ", ~P%
37663                      ; PRINT "Code size is ", ~(P% - CODE_SHIPS%)
37664                      ; PRINT "Execute at ", ~LOAD%
37665                      ; PRINT "Reload at ", ~LOAD_SHIPS%
37666               
37667                      ; PRINT "S.SHIPS ", ~CODE_SHIPS%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_SHIPS%
37668                      ; SAVE "3-assembled-output/SHIPS.bin", CODE_SHIPS%, P%, LOAD%
37669               
37670               * ******************************************************************************
37671               *
37672               * ELITE PYTHON SHIP BLUEPRINT FILE
37673               *
37674               * Produces the binary file PYTHON.bin that gets loaded by elite-bcfs.asm.
37675               *
37676               * ******************************************************************************
37677               
37678                      ; CLEAR 0, &7F00                ; CLEAR 0, &7F00
37679               
37680               LOAD_PYTHON.:
37681                      equ >1B00
37682               
37683               * ORG CODE_PYTHON%
37684               
37685               * ******************************************************************************
37686               *
37687               * Name: SHIP_PYTHON
37688               * Type: Variable
37689               * Category: Drawing ships
37690               * Summary: Ship blueprint for a Python
37691               * Deep dive: Ship blueprints
37692               *
37693               * ******************************************************************************
37694               
37695               SHIP_PYTHON:
37696 F33A 03              byte >03                                            ; Max. canisters on demise = 3
37697 F33C 3840            data 120 * 120                                      ; Targetable area          = 120 * 120
37698               
37699 F33E 58              byte (SHIP_PYTHON_EDGES - SHIP_PYTHON)%256          ; Edges data offset (low)
37700 F33F   C0            byte (SHIP_PYTHON_FACES - SHIP_PYTHON)%256          ; Faces data offset (low)
37701               
37702 F340 55              byte >55                                            ; Max. edge count          = (85 - 1) / 4 = 21
37703 F341   00            byte >00                                            ; Gun vertex               = 0
37704 F342 2E              byte >2e                                            ; Explosion count          = 10, as (4 * n) + 6 = 46
37705 F343   42            byte >42                                            ; Number of vertices       = 66 / 6 = 11
37706 F344 1A              byte >1a                                            ; Number of edges          = 26
37707 F346 C800            data >c800                                          ; Bounty                   = 200
37708 F348 34              byte >34                                            ; Number of faces          = 52 / 4 = 13
37709 F349   28            byte >28                                            ; Visibility distance      = 40
37710 F34A FA              byte >fa                                            ; Max. energy              = 250
37711 F34B   14            byte >14                                            ; Max. speed               = 20
37712               
37713 F34C 00              byte (SHIP_PYTHON_EDGES - SHIP_PYTHON)/256          ; Edges data offset (high)
37714 F34D   00            byte (SHIP_PYTHON_FACES - SHIP_PYTHON)/256          ; Faces data offset (high)
37715               
37716 F34E 00              byte >00                                            ; Normals are scaled by    = 2^0 = 1
37717 F34F   1B            byte >1b                                            ; Laser power              = 3
37718                                                                          ; Missiles                 = 3
37719               
37720               SHIP_PYTHON_VERTICES:
37721                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37722 F350 0000            byte >00, >00, >e0, >1f, >10, >32                   ; Vertex 0
     F352 E01F     
     F354 1032     
37723 F356 0030            byte >00, >30, >30, >1e, >10, >54                   ; Vertex 1
     F358 301E     
     F35A 1054     
37724 F35C 6000            byte >60, >00, >10, >3f, >ff, >ff                   ; Vertex 2
     F35E 103F     
     F360 FFFF     
37725 F362 6000            byte >60, >00, >10, >bf, >ff, >ff                   ; Vertex 3
     F364 10BF     
     F366 FFFF     
37726 F368 0030            byte >00, >30, >20, >3e, >54, >98                   ; Vertex 4
     F36A 203E     
     F36C 5498     
37727 F36E 0018            byte >00, >18, >70, >3f, >89, >cc                   ; Vertex 5
     F370 703F     
     F372 89CC     
37728 F374 3000            byte >30, >00, >70, >bf, >b8, >cc                   ; Vertex 6
     F376 70BF     
     F378 B8CC     
37729 F37A 3000            byte >30, >00, >70, >3f, >a9, >cc                   ; Vertex 7
     F37C 703F     
     F37E A9CC     
37730 F380 0030            byte >00, >30, >30, >5e, >32, >76                   ; Vertex 8
     F382 305E     
     F384 3276     
37731 F386 0030            byte >00, >30, >20, >7e, >76, >ba                   ; Vertex 9
     F388 207E     
     F38A 76BA     
37732 F38C 0018            byte >00, >18, >70, >7e, >ba, >cc                   ; Vertex 10
     F38E 707E     
     F390 BACC     
37733               
37734               SHIP_PYTHON_EDGES:
37735                                                                          ; vertex1, vertex2, face1, face2, visibility
37736 F392 1E32            byte >1e, >32, >00, >20                             ; Edge 0
     F394 0020     
37737 F396 1F20            byte >1f, >20, >00, >0c                             ; Edge 1
     F398 000C     
37738 F39A 1F31            byte >1f, >31, >00, >08                             ; Edge 2
     F39C 0008     
37739 F39E 1E10            byte >1e, >10, >00, >04                             ; Edge 3
     F3A0 0004     
37740 F3A2 1D59            byte >1d, >59, >08, >10                             ; Edge 4
     F3A4 0810     
37741 F3A6 1D51            byte >1d, >51, >04, >08                             ; Edge 5
     F3A8 0408     
37742 F3AA 1D37            byte >1d, >37, >08, >20                             ; Edge 6
     F3AC 0820     
37743 F3AE 1D40            byte >1d, >40, >04, >0c                             ; Edge 7
     F3B0 040C     
37744 F3B2 1D62            byte >1d, >62, >0c, >20                             ; Edge 8
     F3B4 0C20     
37745 F3B6 1DA7            byte >1d, >a7, >08, >24                             ; Edge 9
     F3B8 0824     
37746 F3BA 1D84            byte >1d, >84, >0c, >10                             ; Edge 10
     F3BC 0C10     
37747 F3BE 1DB6            byte >1d, >b6, >0c, >24                             ; Edge 11
     F3C0 0C24     
37748 F3C2 0588            byte >05, >88, >0c, >14                             ; Edge 12
     F3C4 0C14     
37749 F3C6 05BB            byte >05, >bb, >0c, >28                             ; Edge 13
     F3C8 0C28     
37750 F3CA 0599            byte >05, >99, >08, >14                             ; Edge 14
     F3CC 0814     
37751 F3CE 05AA            byte >05, >aa, >08, >28                             ; Edge 15
     F3D0 0828     
37752 F3D2 1FA9            byte >1f, >a9, >08, >1c                             ; Edge 16
     F3D4 081C     
37753 F3D6 1FB8            byte >1f, >b8, >0c, >18                             ; Edge 17
     F3D8 0C18     
37754 F3DA 1FC8            byte >1f, >c8, >14, >18                             ; Edge 18
     F3DC 1418     
37755 F3DE 1FC9            byte >1f, >c9, >14, >1c                             ; Edge 19
     F3E0 141C     
37756 F3E2 1DAC            byte >1d, >ac, >1c, >28                             ; Edge 20
     F3E4 1C28     
37757 F3E6 1DCB            byte >1d, >cb, >18, >28                             ; Edge 21
     F3E8 1828     
37758 F3EA 1D98            byte >1d, >98, >10, >14                             ; Edge 22
     F3EC 1014     
37759 F3EE 1DBA            byte >1d, >ba, >24, >28                             ; Edge 23
     F3F0 2428     
37760 F3F2 1D54            byte >1d, >54, >04, >10                             ; Edge 24
     F3F4 0410     
37761 F3F6 1D76            byte >1d, >76, >20, >24                             ; Edge 25
     F3F8 2024     
37762               
37763               SHIP_PYTHON_FACES:
37764                                                                          ; normal_x, normal_y, normal_z, visibility
37765 F3FA 9E1B            byte >9e, >1b, >28, >0b                             ; Face 0
     F3FC 280B     
37766 F3FE 1E1B            byte >1e, >1b, >28, >0b                             ; Face 1
     F400 280B     
37767 F402 DE1B            byte >de, >1b, >28, >0b                             ; Face 2
     F404 280B     
37768 F406 5E1B            byte >5e, >1b, >28, >0b                             ; Face 3
     F408 280B     
37769 F40A 9E13            byte >9e, >13, >26, >00                             ; Face 4
     F40C 2600     
37770 F40E 1E13            byte >1e, >13, >26, >00                             ; Face 5
     F410 2600     
37771 F412 DE13            byte >de, >13, >26, >00                             ; Face 6
     F414 2600     
37772 F416 5E13            byte >5e, >13, >26, >00                             ; Face 7
     F418 2600     
37773 F41A BE19            byte >be, >19, >25, >0b                             ; Face 8
     F41C 250B     
37774 F41E 3E19            byte >3e, >19, >25, >0b                             ; Face 9
     F420 250B     
37775 F422 7E19            byte >7e, >19, >25, >0b                             ; Face 10
     F424 250B     
37776 F426 FE19            byte >fe, >19, >25, >0b                             ; Face 11
     F428 250B     
37777 F42A 3E00            byte >3e, >00, >00, >70                             ; Face 12
     F42C 0070     
37778               
37779 F42E                 bss 11                                              ; This space appears to be unused
37780               
37781               * ******************************************************************************
37782               *
37783               * Name: SVN
37784               * Type: Variable
37785               * Category: Save and load
37786               * Summary: The "saving in progress" flag
37787               *
37788               * ******************************************************************************
37789               
37790               SVN:
37791 F439                 bss 1                                               ; "Saving in progress" flag
37792                                                                          ;
37793                                                                          ; * Non-zero while we are saving a commander
37794                                                                          ;
37795                                                                          ; * 0 otherwise
37796               
37797               * ******************************************************************************
37798               *
37799               * Name: VEC
37800               * Type: Variable
37801               * Category: Drawing the screen
37802               * Summary: The original value of the IRQ1 vector
37803               *
37804               * ******************************************************************************
37805               
37806               VEC:
37807               * SKIP 2                 \ VEC = &7FFE
37808                                                                          ;
37809                                                                          ; This gets set to the value of the original IRQ1 vector
37810                                                                          ; by the loading process
37811               * ******************************************************************************
37812               *
37813               * Save PYTHON.bin
37814               *
37815               * ******************************************************************************
37816                      ; PRINT "PYTHON"
37817                      ; PRINT "Assembled at ", ~CODE_PYTHON%
37818                      ; PRINT "Ends at ", ~P%
37819                      ; PRINT "Code size is ", ~(P% - CODE_PYTHON%)
37820                      ; PRINT "Execute at ", ~LOAD%
37821                      ; PRINT "Reload at ", ~LOAD_PYTHON%
37822               
37823                      ; PRINT "S.PYTHON ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_PYTHON%
37824                      ; SAVE "3-assembled-output/PYTHON.bin", CODE_PYTHON%, P%, LOAD%
37825               
37826               * ******************************************************************************
37827               *
37828               * Show free space
37829               *
37830               * ******************************************************************************
37831               
37832                      ; PRINT "ELITE game code ", ~(&6000-P%), " bytes free"
37833                      ; PRINT "Ends at ", ~P%
                   < main.a99
0004                      aorg >FE00
0005                      copy "entry.a99"
     **** ****     > entry.a99
0001 FE00 0300  22        limi 0
     FE02 0000     
0002 FE04 02E0  18        lwpi workspace
     FE06 8300     
0003 FE08 020A  20        li   rsp,STACK.
     FE0A 0100     
0004 FE0C 0209  20        li   rvdpwd,vdpwd
     FE0E 8C00     
0005 FE10 04C6  14        clr  rzero
0006 FE12 0207  20        li   rone,>0100
     FE14 0100     
0007 FE16 0208  20        li   rmone,>ff00
     FE18 FF00     
0008 FE1A 06A0  32        bl   @graphics_mode
     FE1C FE94     
0009 FE1E 0460  28        b    @TT170
     FE20 C64C     
0010               
                   < main.a99
0006                      copy "subroutines.a99"
     **** ****     > subroutines.a99
0001               OSBYTE:
0002 FE22 1008  14        jmp rts
0003               OSWORD:
0004 FE24 1007  14        jmp rts
0005               OSFILE:
0006 FE26 1006  14        jmp rts
0007               
0008               jsr:
0009 FE28 D68B  30        movb r11,*rsp
0010 FE2A 060A  14        dec  rsp
0011 FE2C 06CB  14        swpb r11
0012 FE2E D68B  30        movb r11,*rsp
0013 FE30 060A  14        dec  rsp
0014 FE32 0450  20        b    *rtmp
0015               
0016               rts:
0017 FE34 058A  14        inc  rsp
0018 FE36 D2FA  28        movb *rsp+,r11
0019 FE38 06CB  14        swpb r11
0020 FE3A D2DA  26        movb *rsp,r11
0021 FE3C 045B  20        b    *r11
0022               
0023               rola:
0024 FE3E 1702  14        jnc  !
0025 FE40 026D  22        ori  ra,>0080
     FE42 0080     
0026               !:
0027 FE44 1002  14        jmp  !
0028 FE46 024D  22        andi ra,>ff7f
     FE48 FF7F     
0029               !:
0030 FE4A 0A1D  18        sla  ra,1
0031 FE4C 045B  20        rt
0032               
0033               rol:
0034 FE4E D014  26        movb *rarg1,rtmp
0035 FE50 1702  14        jnc  !
0036 FE52 0260  22        ori  rtmp,>0080
     FE54 0080     
0037               !:
0038 FE56 1002  14        jmp  !
0039 FE58 0240  22        andi rtmp,>ff7f
     FE5A FF7F     
0040               !:
0041 FE5C 0A10  18        sla  rtmp,1
0042 FE5E C500  30        mov  rtmp,*rarg1
0043 FE60 045B  20        rt
0044               
0045               rora:
0046 FE62 1702  14        jnc  !
0047 FE64 026D  22        ori  ra,>0001
     FE66 0001     
0048               !:
0049 FE68 1002  14        jmp  !
0050 FE6A 024D  22        andi ra,>fffe
     FE6C FFFE     
0051               !:
0052 FE6E 0B1D  18        src  ra,1
0053 FE70 024D  22        andi ra,>0080
     FE72 0080     
0054 FE74 C00D  18        mov  ra,rtmp
0055 FE76 0A90  34        sla  rtmp,9
0056 FE78 045B  20        rt
0057               
0058               ror:
0059 FE7A D014  26        movb *rarg1,rtmp
0060 FE7C 1702  14        jnc  !
0061 FE7E 0260  22        ori  rtmp,>0001
     FE80 0001     
0062               !:
0063 FE82 1002  14        jmp  !
0064 FE84 0240  22        andi rtmp,>fffe
     FE86 FFFE     
0065               !:
0066 FE88 0B10  18        src  rtmp,1
0067 FE8A D500  30        movb rtmp,*rarg1
0068 FE8C 0240  22        andi rtmp,>0080
     FE8E 0080     
0069 FE90 0A90  34        sla  rtmp,9
0070 FE92 045B  20        rt
                   < main.a99
0007                      copy "vdp.a99"
     **** ****     > vdp.a99
0001               *********************************************************************************
0002               *
0003               * Set graphics mode
0004               *
0005               graphics_mode:
0006 FE94 C0CB  18        mov  r11,rtmp4
0007 FE96 0201  20        li   rtmp2,vregs2
     FE98 FEDE     
0008               graphics_mode_1:
0009 FE9A C031  30        mov  *rtmp2+,rtmp
0010 FE9C 111F  14        jlt  graphics_mode_2
0011 FE9E 06A0  32        bl   @vwtr                      ; Set register
     FEA0 FEF0     
0012 FEA2 10FB  14        jmp  graphics_mode_1
0013               *      Init name table
0014 FEA4 0200  20        li   rtmp,name_table
     FEA6 3800     
0015 FEA8 06A0  32        bl   @vwad
     FEAA FF02     
0016 FEAC 04C1  14        clr  rtmp2
0017 FEAE 0202  20        li   rtmp3,>300
     FEB0 0300     
0018               init_vdp_ram_1:
0019 FEB2 D641  30        movb rtmp2,*rvdpwd
0020 FEB4 0220  22        ai   rtmp,>0100
     FEB6 0100     
0021 FEB8 0602  14        dec  rtmp3
0022 FEBA 16FB  14        jne   init_vdp_ram_1
0023               *      Init patterms
0024 FEBC 0200  20        li   rtmp,pattern_table
     FEBE 0000     
0025 FEC0 0200  20        li   rtmp,>0000
     FEC2 0000     
0026 FEC4 0202  20        li   rtmp3,>1800
     FEC6 1800     
0027 FEC8 06A0  32        bl   @vsmw
     FECA FF40     
0028               *      Init colors
0029 FECC 0200  20        li   rtmp,color_table
     FECE 2000     
0030 FED0 0201  20        li   rtmp2,>f100
     FED2 F100     
0031 FED4 0202  20        li   rtmp3,>1800
     FED6 1800     
0032 FED8 06A0  32        bl   @vsmw
     FEDA FF40     
0033               *      Return
0034               graphics_mode_2:
0035 FEDC 0453  20        b    *rtmp4
0036               *      VDP registers
0037               vregs2:
0038 FEDE 0002            byte >00,>02                        ; Graphics II mode
0039 FEE0 01E2            byte >01,>e2                        ; 16K, display on, interrupts enabled
0040 FEE2 020E            byte >02,name_table/>400            ; Name table
0041 FEE4 03FF            byte >03,>ff                        ; Color table
0042 FEE6 0403            byte >04,pattern_table/>800+>03     ; Pattern table
0043 FEE8 0576            byte >05,sprite_attr_table/>80      ; Sprite attribute table
0044 FEEA 0603            byte >06,sprite_pattern_table/>800  ; Sprite pattern table
0045 FEEC 0701            byte >07,>01                        ; Backdrop color
0046 FEEE FFFF            data -1
0047               *// graphics_mode
0048               
0049               *********************************************************************
0050               *
0051               * VDP Write To Register
0052               *
0053               * rtmp MSB: VDP register to write to
0054               * rtmp LSB: Value to write
0055               *
0056               vwtr:
0057 FEF0 06C0  14        swpb rtmp
0058 FEF2 D800  30        movb rtmp,@vdpwa                ; Send low byte (value) to write to VDP register
     FEF4 8C02     
0059 FEF6 06C0  14        swpb rtmp
0060 FEF8 0260  22        ori  rtmp,>8000                 ; Set up a VDP register write operation (10)
     FEFA 8000     
0061 FEFC D800  30        movb rtmp,@vdpwa                ; Send high byte (address) of VDP register
     FEFE 8C02     
0062 FF00 045B  20        rt
0063               *// vwtr
0064               
0065               *********************************************************************
0066               *
0067               * VDP Set Write Address
0068               *
0069               * rtmp: Write address in VDP RAM
0070               *
0071               vwad:
0072 FF02 06C0  14        swpb rtmp
0073 FF04 D800  30        movb rtmp,@vdpwa                ; Send low byte of VDP RAM write address
     FF06 8C02     
0074 FF08 06C0  14        swpb rtmp
0075 FF0A 0260  22        ori  rtmp,>4000                 ; Set read/write bits 14 and 15 to write (01)
     FF0C 4000     
0076 FF0E D800  30        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF10 8C02     
0077 FF12 045B  20        rt
0078               *// vwad
0079               
0080               *********************************************************************
0081               *
0082               * VDP Single Byte Write
0083               *
0084               * rtmp: Write address in VDP RAM
0085               * rtmp2: MSB of rtmp2 sent to VDP RAM
0086               *
0087               vsbw:
0088 FF14 06C0  14        swpb rtmp
0089 FF16 D800  30        movb rtmp,@vdpwa                ; Send low byte of VDP RAM write address
     FF18 8C02     
0090 FF1A 06C0  14        swpb rtmp
0091 FF1C 0260  22        ori  rtmp,>4000                 ; Set read/write bits 14 and 15 to write (01)
     FF1E 4000     
0092 FF20 D800  30        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF22 8C02     
0093 FF24 D641  30        movb rtmp2,*rvdpwd              ; Write byte to VDP RAM
0094 FF26 045B  20        rt
0095               *// vsbw
0096               
0097               *********************************************************************
0098               *
0099               * VDP multiple Byte Write
0100               *
0101               * rtmp: Write address in VDP RAM
0102               * rtmp2: Starting read address in CPU RAM
0103               * rtmp3: Number of bytes to send
0104               *
0105               vmbw:
0106 FF28 06C0  14        swpb rtmp
0107 FF2A D800  30        movb rtmp,@vdpwa                ; Send low byte of VDP RAM write address
     FF2C 8C02     
0108 FF2E 06C0  14        swpb rtmp
0109 FF30 0260  22        ori  rtmp,>4000                 ; Set read/write bits 14 and 15 to write (01)
     FF32 4000     
0110 FF34 D800  30        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF36 8C02     
0111               vmbw_1:
0112 FF38 D670  40        movb *rtmp+,*rvdpwd             ; Write byte to VDP RAM
0113 FF3A 0602  14        dec  rtmp3
0114 FF3C 16FD  14        jne  vmbw_1
0115 FF3E 045B  20        rt
0116               *// vmbw
0117               
0118               *********************************************************************
0119               *
0120               * VDP Single Byte Multiple Write
0121               *
0122               * rtmp: Write address in VDP RAM
0123               * rtmp2: MSB of  sent to VDP RAM
0124               * rtmp3: Number of bytes to write to VDP RAM
0125               *
0126               vsmw:
0127 FF40 06C0  14        swpb rtmp
0128 FF42 D800  30        movb  rtmp,@vdpwa               ; Send low byte of VDP RAM write address
     FF44 8C02     
0129 FF46 06C0  14        swpb rtmp
0130 FF48 0260  22        ori  rtmp,>4000                 ; Set read/write bits 14 and 15 to write (01)
     FF4A 4000     
0131 FF4C D800  30        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF4E 8C02     
0132               vsmw_1:
0133 FF50 D641  30        movb rtmp2,*rvdpwd              ; Write byte to VDP RAM
0134 FF52 0602  14        dec  rtmp3                      ; Byte counter
0135 FF54 16FD  14        jne  vsmw_1
0136 FF56 045B  20        rt
0137               *// vsmw
0138               
0139               *********************************************************************
0140               *
0141               * Copy screen buffer to VDP
0142               *
0143               display_scr_buffer:
0144 FF58 04E0  26        clr  @vdpwa                     ; Send low byte of VDP RAM write address
     FF5A 8C02     
0145 FF5C 0200  20        li   rtmp,pattern_table+>4000
     FF5E 4000     
0146 FF60 D800  30        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF62 8C02     
0147 FF64 0201  20        li   rtmp2,scr_buffer
     FF66 6000     
0148 FF68 0202  20        li   rtmp3,>1800/8
     FF6A 0300     
0149               display_scr_buffer_1:
0150 FF6C D671  40        movb *rtmp2+,*rvdpwd            ; Send by to VDP
0151 FF6E D671  40        movb *rtmp2+,*rvdpwd            ; ...
0152 FF70 D671  40        movb *rtmp2+,*rvdpwd            ; ...
0153 FF72 D671  40        movb *rtmp2+,*rvdpwd            ; ...
0154 FF74 D671  40        movb *rtmp2+,*rvdpwd            ; ...
0155 FF76 D671  40        movb *rtmp2+,*rvdpwd            ; ...
0156 FF78 D671  40        movb *rtmp2+,*rvdpwd            ; ...
0157 FF7A D671  40        movb *rtmp2+,*rvdpwd            ; ...
0158 FF7C 0602  14        dec  rtmp3                      ; Counter
0159 FF7E 16F6  14        jne  display_scr_buffer_1       ; Loop
0160 FF80 045B  20        rt
0161               display_scr_buffer_end:
0162                      equ  $
0163               *// display_scr_buffer
                   < main.a99
