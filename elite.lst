XAS99 CROSS-ASSEMBLER   VERSION 3.6.5
     **** ****     > main.a99
0001                      copy "equates.a99"
     **** ****     > equates.a99
0001               workspace:
0002                      equ  8300
0003               
0004               ra:
0005      0000            requ 0
0006               ralb:
0007                      equ  workspace + >01
0008               rx:
0009      0000            requ 1
0010               ry:
0011      0000            requ 2
0012               rzero:
0013      0000            requ 3
0014               rone:
0015      0000            requ 4
0016               rmone:
0017      0000            requ 5
0018               rtmp:
0019      0000            requ 6
0020               rtmplb:
0021                      equ workspace + >0d
0022               rtmp2:
0023      0000            requ 7
0024               tmp2lb:
0025                      equ workspace + >0f
0026               rarg1:
0027      0000            requ 8
0028               rarg2:
0029      0000            requ 9
0030               rsp:
0031      0000            requ 10
0032               rsplb:
0033                      equ workspace + >15
0034               r11lb:
0035                      equ workspace + >17
0036               
0037               _MAX_COMMANDER:
0038                      equ  0
0039               _REMOVE_CHECKSUMS:
0040                      equ  1
0041               
0042               ZERO_PAGE.:
0043                      equ >0000
0044               STACK.:
0045                      equ >0100
0046               T.:
0047                      equ >0300
0048               CODE_WORDS.:
0049                      equ >0400
0050               K.:
0051                      equ >0900
0052               WP.:
0053                      equ >0D40
0054               CODE.:
0055                      equ >0F40
0056               CODE_UPPER.:
0057                      equ >A000
0058               CODE_PYTHON.:
0059                      equ >F200
                   < main.a99
0002                      copy "macros.a99"
     **** ****     > macros.a99
0001               **
0002               * Macros
0003               *
0013               
0021               
0031               
0043               
0056               
0070               
0075               
0080               
0086               
0092               
0099               
0106               
0117               
0124               
0131               
0137               
0146               
0154               
0160               
0166               
0173               
0180               
0185               
0190               
0198               
0204               
0209               
0216               
0222               
0228               
0229               
0230               
0234               
0238               
0246               
0266               
0270               
0274               
0280               
                   < main.a99
0003                      copy "elite.a99"
     **** ****     > elite.a99
0001               * ******************************************************************************
0002               *
0003               * ELITE GAME SOURCE
0004               *
0005               * Elite was written by Ian Bell and David Braben and is copyright Acornsoft 1984
0006               *
0007               * The code on this site is identical to the source discs released on Ian Bell's
0008               * personal website at http://www.elitehomepage.org/ (it's just been reformatted
0009               * to be more readable)
0010               *
0011               * The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
0012               * in the documentation are entirely my fault
0013               *
0014               * The terminology and notations used in this commentary are explained at
0015               * https://elite.bbcelite.com/terminology
0016               *
0017               * The deep dive articles referred to in this commentary can be found at
0018               * https://elite.bbcelite.com/deep_dives
0019               *
0020               * ------------------------------------------------------------------------------
0021               *
0022               * This source file produces the following binary files:
0023               *
0024               * * ELTA.bin
0025               * * ELTB.bin
0026               * * ELTC.bin
0027               * * ELTD.bin
0028               * * ELTE.bin
0029               * * ELTF.bin
0030               * * ELTG.bin
0031               * * PYTHON.bin
0032               * * SHIPS.bin
0033               * * WORDS9.bin
0034               *
0035               * ******************************************************************************
0036               
0037                      ; INCLUDE "1-source-files/main-sources/elite-build-options.asm"
0038               
0039               _SOURCE_DISC:                                              ; (_VARIANT = 1)
0040                      equ 0
0041               _TEXT_SOURCES:                                             ; (_VARIANT = 2)
0042                      equ 0
0043               _STH_CASSETTE:                                             ; (_VARIANT = 3)
0044                      equ 1
0045               
0046                      ; GUARD &6000                                       ; Guard against assembling over screen memory
0047               
0048               * ******************************************************************************
0049               *
0050               * Configuration variables
0051               *
0052               * ******************************************************************************
0053               
0054               * ZERO_PAGE% = &0000
0055               
0056               * STACK% = &0100
0057               
0058               * CODE% = &0F40         \ The address where the code will be run
0059               
0060               LOAD.:                                                     ; The address where the code will be loaded
0061                      equ >1128
0062               
0063               * T% = &0300            \ Current commander data and stardust data blocks
0064               
0065               * CODE_WORDS% = &0400   \ The address where the text data will be run
0066               
0067               LOAD_WORDS.:                                               ; The address where the text data will be loaded
0068                      equ >1100
0069               
0070               * K% = &0900
0071               
0072               * WP% = &0D40
0073               
0074               * CODE_PYTHON% = &7F00
0075               
0076               Q.:                                                        ; Set Q% to TRUE to max out the default commander, FALSE
0077                      equ _MAX_COMMANDER
0078                                                                          ; for the standard default commander
0079               
0080               NOST:                                                      ; The number of stardust particles in normal space (this
0081                      equ 18
0082                                                                          ; goes down to 3 in witchspace)
0083               
0084               NOSH:                                                      ; The maximum number of ships in our local bubble of
0085                      equ 12
0086                                                                          ; universe
0087               
0088               NTY:                                                       ; The number of different ship types
0089                      equ 13
0090               
0091               COPS:                                                      ; Ship type for a Viper
0092                      equ 2
0093               
0094               THG:                                                       ; Ship type for a Thargoid
0095                      equ 6
0096               
0097               CYL:                                                       ; Ship type for a Cobra Mk III (trader)
0098                      equ 7
0099               
0100               SST:                                                       ; Ship type for the space station
0101                      equ 8
0102               
0103               MSL:                                                       ; Ship type for a missile
0104                      equ 9
0105               
0106               AST:                                                       ; Ship type for an asteroid
0107                      equ 10
0108               
0109               OIL:                                                       ; Ship type for a cargo canister
0110                      equ 11
0111               
0112               TGL:                                                       ; Ship type for a Thargon
0113                      equ 12
0114               
0115               ESC:                                                       ; Ship type for an escape pod
0116                      equ 13
0117               
0118               POW:                                                       ; Pulse laser power
0119                      equ 15
0120               
0121               NI.:                                                       ; The number of bytes in each ship's data block (as
0122                      equ 36
0123                                                                          ; stored in INWK and K%)
0124               
0125               VSCAN:                                                     ; Defines the split position in the split-screen mode
0126                      equ 57
0127               
0128               X:                                                         ; The centre x-coordinate of the 256 x 192 space view
0129                      equ 128
0130               
0131               Y:                                                         ; The centre y-coordinate of the 256 x 192 space view
0132                      equ 96
0133               
0134               f0_:                                                       ; Internal key number for red key f0 (Launch, Front)
0135                      equ >20
0136               
0137               f1_:                                                       ; Internal key number for red key f1 (Buy Cargo, Rear)
0138                      equ >71
0139               
0140               f2_:                                                       ; Internal key number for red key f2 (Sell Cargo, Left)
0141                      equ >72
0142               
0143               f3_:                                                       ; Internal key number for red key f3 (Equip Ship, Right)
0144                      equ >73
0145               
0146               f4_:                                                       ; Internal key number for red key f4 (Long-range Chart)
0147                      equ >14
0148               
0149               f5_:                                                       ; Internal key number for red key f5 (Short-range Chart)
0150                      equ >74
0151               
0152               f6_:                                                       ; Internal key number for red key f6 (Data on System)
0153                      equ >75
0154               
0155               f7_:                                                       ; Internal key number for red key f7 (Market Price)
0156                      equ >16
0157               
0158               f8_:                                                       ; Internal key number for red key f8 (Status Mode)
0159                      equ >76
0160               
0161               f9_:                                                       ; Internal key number for red key f9 (Inventory)
0162                      equ >77
0163               
0164               RE:                                                        ; The obfuscation byte used to hide the recursive tokens
0165                      equ >23
0166                                                                          ; table from crackers viewing the binary code
0167               
0168               VIA:                                                       ; Memory-mapped space for accessing internal hardware,
0169                      equ >FE00
0170                                                                          ; such as the video ULA, 6845 CRTC and 6522 VIAs (also
0171                                                                          ; known as SHEILA)
0172               
0173               OSBYTE:                                                    ; The address for the OSBYTE routine, which is used
0174                      equ >FFF4
0175                                                                          ; three times in the main game code
0176               
0177               OSWORD:                                                    ; The address for the OSWORD routine, which is used
0178                      equ >FFF1
0179                                                                          ; twice in the main game code
0180               
0181               OSFILE:                                                    ; The address for the OSFILE routine, which is used
0182                      equ >FFDD
0183                                                                          ; once in the main game code
0184               
0185               * ******************************************************************************
0186               *
0187               * Name: ZP
0188               * Type: Workspace
0189               * Address: &0000 to &00B0
0190               * Category: Workspaces
0191               * Summary: Lots of important variables are stored in the zero page workspace
0192               * as it is quicker and more space-efficient to access memory here
0193               *
0194               * ******************************************************************************
0195               
0196                      aorg ZERO_PAGE.
0197               
0198               ZP:
0199 0000                 bss 0                                               ; The start of the zero page workspace
0200               
0201               RAND:
0202 0000                 bss 4                                               ; Four 8-bit seeds for the random number generation
0203                                                                          ; system implemented in the DORND routine
0204               
0205               TRTB.:
0206 0004                 bss 2                                               ; Contains the address of the keyboard translation
0207                                                                          ; table, which is used to translate internal key
0208                                                                          ; numbers to ASCII
0209               
0210               T1:
0211 0006                 bss 1                                               ; Temporary storage, used in a number of places
0212               
0213               SC:
0214 0007                 bss 1                                               ; Screen address (low byte)
0215                                                                          ;
0216                                                                          ; Elite draws on-screen by poking bytes directly into
0217                                                                          ; screen memory, and SC(1 0) is typically set to the
0218                                                                          ; address of the character block containing the pixel
0219                                                                          ; we want to draw (see the deep dives on "Drawing
0220                                                                          ; monochrome pixels in mode 4" and "Drawing colour
0221                                                                          ; pixels in mode 5" for more details)
0222               
0223               SCH:
0224 0008                 bss 1                                               ; Screen address (high byte)
0225               
0226               XX16:
0227 0009                 bss 18                                              ; Temporary storage for a block of values, used in a
0228                                                                          ; number of places
0229               
0230               P:
0231 001B                 bss 3                                               ; Temporary storage, used in a number of places
0232               
0233               XX0:
0234 001E                 bss 2                                               ; Temporary storage, used to store the address of a ship
0235                                                                          ; blueprint. For example, it is used when we add a new
0236                                                                          ; ship to the local bubble in routine NWSHP, and it
0237                                                                          ; contains the address of the current ship's blueprint
0238                                                                          ; as we loop through all the nearby ships in the main
0239                                                                          ; flight loop
0240               
0241               INF:
0242 0020                 bss 2                                               ; Temporary storage, typically used for storing the
0243                                                                          ; address of a ship's data block, so it can be copied
0244                                                                          ; to and from the internal workspace at INWK
0245               
0246               V:
0247 0022                 bss 2                                               ; Temporary storage, typically used for storing an
0248                                                                          ; address pointer
0249               
0250               XX:
0251 0024                 bss 2                                               ; Temporary storage, typically used for storing a 16-bit
0252                                                                          ; x-coordinate
0253               
0254               YY:
0255 0026                 bss 2                                               ; Temporary storage, typically used for storing a 16-bit
0256                                                                          ; y-coordinate
0257               
0258               SUNX:
0259 0028                 bss 2                                               ; The 16-bit x-coordinate of the vertical centre axis
0260                                                                          ; of the sun (which might be off-screen)
0261               
0262               BETA:
0263 002A                 bss 1                                               ; The current pitch angle beta, which is reduced from
0264                                                                          ; JSTY to a sign-magnitude value between -8 and +8
0265                                                                          ;
0266                                                                          ; This describes how fast we are pitching our ship, and
0267                                                                          ; determines how fast the universe pitches around us
0268                                                                          ;
0269                                                                          ; The sign bit is also stored in BET2, while the
0270                                                                          ; opposite sign is stored in BET2+1
0271               
0272               BET1:
0273 002B                 bss 1                                               ; The magnitude of the pitch angle beta, i.e. |beta|,
0274                                                                          ; which is a positive value between 0 and 8
0275               
0276               XC:
0277 002C                 bss 1                                               ; The x-coordinate of the text cursor (i.e. the text
0278                                                                          ; column), which can be from 0 to 32
0279                                                                          ;
0280                                                                          ; A value of 0 denotes the leftmost column and 32 the
0281                                                                          ; rightmost column, but because the top part of the
0282                                                                          ; screen (the space view) has a white border that
0283                                                                          ; clashes with columns 0 and 32, text is only shown
0284                                                                          ; in columns 1-31
0285               
0286               YC:
0287 002D                 bss 1                                               ; The y-coordinate of the text cursor (i.e. the text
0288                                                                          ; row), which can be from 0 to 23
0289                                                                          ;
0290                                                                          ; The screen actually has 31 character rows if you
0291                                                                          ; include the dashboard, but the text printing routines
0292                                                                          ; only work on the top part (the space view), so the
0293                                                                          ; text cursor only goes up to a maximum of 23, the row
0294                                                                          ; just before the screen splits
0295                                                                          ;
0296                                                                          ; A value of 0 denotes the top row, but because the
0297                                                                          ; top part of the screen has a white border that clashes
0298                                                                          ; with row 0, text is always shown at row 1 or greater
0299               
0300               QQ22:
0301 002E                 bss 2                                               ; The two hyperspace countdown counters
0302                                                                          ;
0303                                                                          ; Before a hyperspace jump, both QQ22 and QQ22+1 are
0304                                                                          ; set to 15
0305                                                                          ;
0306                                                                          ; QQ22 is an internal counter that counts down by 1
0307                                                                          ; each time TT102 is called, which happens every
0308                                                                          ; iteration of the main game loop. When it reaches
0309                                                                          ; zero, the on-screen counter in QQ22+1 gets
0310                                                                          ; decremented, and QQ22 gets set to 5 and the countdown
0311                                                                          ; continues (so the first tick of the hyperspace counter
0312                                                                          ; takes 15 iterations to happen, but subsequent ticks
0313                                                                          ; take 5 iterations each)
0314                                                                          ;
0315                                                                          ; QQ22+1 contains the number that's shown on-screen
0316                                                                          ; during the countdown. It counts down from 15 to 1, and
0317                                                                          ; when it hits 0, the hyperspace engines kick in
0318               
0319               ECMA:
0320 0030                 bss 1                                               ; The E.C.M. countdown timer, which determines whether
0321                                                                          ; an E.C.M. system is currently operating:
0322                                                                          ;
0323                                                                          ; * 0 = E.C.M. is off
0324                                                                          ;
0325                                                                          ; * Non-zero = E.C.M. is on and is counting down
0326                                                                          ;
0327                                                                          ; The counter starts at 32 when an E.C.M. is activated,
0328                                                                          ; either by us or by an opponent, and it decreases by 1
0329                                                                          ; in each iteration of the main flight loop until it
0330                                                                          ; reaches zero, at which point the E.C.M. switches off.
0331                                                                          ; Only one E.C.M. can be active at any one time, so
0332                                                                          ; there is only one counter
0333               
0334               XX15:
0335 0031                 bss 0                                               ; Temporary storage, typically used for storing screen
0336                                                                          ; coordinates in line-drawing routines
0337                                                                          ;
0338                                                                          ; There are six bytes of storage, from XX15 TO XX15+5.
0339                                                                          ; The first four bytes have the following aliases:
0340                                                                          ;
0341                                                                          ; X1 = XX15
0342                                                                          ; Y1 = XX15+1
0343                                                                          ; X2 = XX15+2
0344                                                                          ; Y2 = XX15+3
0345                                                                          ;
0346                                                                          ; These are typically used for describing lines in terms
0347                                                                          ; of screen coordinates, i.e. (X1, Y1) to (X2, Y2)
0348                                                                          ;
0349                                                                          ; The last two bytes of XX15 do not have aliases
0350               
0351               X1:
0352 0031                 bss 1                                               ; Temporary storage, typically used for x-coordinates in
0353                                                                          ; line-drawing routines
0354               
0355               Y1:
0356 0032                 bss 1                                               ; Temporary storage, typically used for y-coordinates in
0357                                                                          ; line-drawing routines
0358               
0359               X2:
0360 0033                 bss 1                                               ; Temporary storage, typically used for x-coordinates in
0361                                                                          ; line-drawing routines
0362               
0363               Y2:
0364 0034                 bss 1                                               ; Temporary storage, typically used for y-coordinates in
0365                                                                          ; line-drawing routines
0366               
0367 0035                 bss 2                                               ; The last two bytes of the XX15 block
0368               
0369               XX12:
0370 0037                 bss 6                                               ; Temporary storage for a block of values, used in a
0371                                                                          ; number of places
0372               
0373               K:
0374 003D                 bss 4                                               ; Temporary storage, used in a number of places
0375               
0376               KL:
0377 0041                 bss 1                                               ; The following bytes implement a key logger that
0378                                                                          ; enables Elite to scan for concurrent key presses of
0379                                                                          ; the primary flight keys, plus a secondary flight key
0380                                                                          ;
0381                                                                          ; See the deep dive on "The key logger" for more details
0382                                                                          ;
0383                                                                          ; If a key is being pressed that is not in the keyboard
0384                                                                          ; table at KYTB, it can be stored here (as seen in
0385                                                                          ; routine DK4, for example)
0386               
0387               KY1:
0388 0042                 bss 1                                               ; "?" is being pressed
0389                                                                          ;
0390                                                                          ; * 0 = no
0391                                                                          ;
0392                                                                          ; * Non-zero = yes
0393               
0394               KY2:
0395 0043                 bss 1                                               ; Space is being pressed
0396                                                                          ;
0397                                                                          ; * 0 = no
0398                                                                          ;
0399                                                                          ; * Non-zero = yes
0400               
0401               KY3:
0402 0044                 bss 1                                               ; "<" is being pressed
0403                                                                          ;
0404                                                                          ; * 0 = no
0405                                                                          ;
0406                                                                          ; * Non-zero = yes
0407               
0408               KY4:
0409 0045                 bss 1                                               ; ">" is being pressed
0410                                                                          ;
0411                                                                          ; * 0 = no
0412                                                                          ;
0413                                                                          ; * Non-zero = yes
0414               
0415               KY5:
0416 0046                 bss 1                                               ; "X" is being pressed
0417                                                                          ;
0418                                                                          ; * 0 = no
0419                                                                          ;
0420                                                                          ; * Non-zero = yes
0421               
0422               KY6:
0423 0047                 bss 1                                               ; "S" is being pressed
0424                                                                          ;
0425                                                                          ; * 0 = no
0426                                                                          ;
0427                                                                          ; * Non-zero = yes
0428               
0429               KY7:
0430 0048                 bss 1                                               ; "A" is being pressed
0431                                                                          ;
0432                                                                          ; * 0 = no
0433                                                                          ;
0434                                                                          ; * Non-zero = yes
0435                                                                          ;
0436                                                                          ; This is also set when the joystick fire button has
0437                                                                          ; been pressed
0438               
0439               KY12:
0440 0049                 bss 1                                               ; TAB is being pressed
0441                                                                          ;
0442                                                                          ; * 0 = no
0443                                                                          ;
0444                                                                          ; * Non-zero = yes
0445               
0446               KY13:
0447 004A                 bss 1                                               ; ESCAPE is being pressed
0448                                                                          ;
0449                                                                          ; * 0 = no
0450                                                                          ;
0451                                                                          ; * Non-zero = yes
0452               
0453               KY14:
0454 004B                 bss 1                                               ; "T" is being pressed
0455                                                                          ;
0456                                                                          ; * 0 = no
0457                                                                          ;
0458                                                                          ; * Non-zero = yes
0459               
0460               KY15:
0461 004C                 bss 1                                               ; "U" is being pressed
0462                                                                          ;
0463                                                                          ; * 0 = no
0464                                                                          ;
0465                                                                          ; * Non-zero = yes
0466               
0467               KY16:
0468 004D                 bss 1                                               ; "M" is being pressed
0469                                                                          ;
0470                                                                          ; * 0 = no
0471                                                                          ;
0472                                                                          ; * Non-zero = yes
0473               
0474               KY17:
0475 004E                 bss 1                                               ; "E" is being pressed
0476                                                                          ;
0477                                                                          ; * 0 = no
0478                                                                          ;
0479                                                                          ; * Non-zero = yes
0480               
0481               KY18:
0482 004F                 bss 1                                               ; "J" is being pressed
0483                                                                          ;
0484                                                                          ; * 0 = no
0485                                                                          ;
0486                                                                          ; * Non-zero = yes
0487               
0488               KY19:
0489 0050                 bss 1                                               ; "C" is being pressed
0490                                                                          ;
0491                                                                          ; * 0 = no
0492                                                                          ;
0493                                                                          ; * Non-zero = yes
0494               
0495               LAS:
0496 0051                 bss 1                                               ; Contains the laser power of the laser fitted to the
0497                                                                          ; current space view (or 0 if there is no laser fitted
0498                                                                          ; to the current view)
0499                                                                          ;
0500                                                                          ; This gets set to bits 0-6 of the laser power byte from
0501                                                                          ; the commander data block, which contains the laser's
0502                                                                          ; power (bit 7 doesn't denote laser power, just whether
0503                                                                          ; or not the laser pulses, so that is not stored here)
0504               
0505               MSTG:
0506 0052                 bss 1                                               ; The current missile lock target
0507                                                                          ;
0508                                                                          ; * &FF = no target
0509                                                                          ;
0510                                                                          ; * 1-12 = the slot number of the ship that our
0511                                                                          ; missile is locked onto
0512               
0513               XX1:
0514 0053                 bss 0                                               ; This is an alias for INWK that is used in the main
0515                                                                          ; ship-drawing routine at LL9
0516               
0517               INWK:
0518 0053                 bss 33                                              ; The zero-page internal workspace for the current ship
0519                                                                          ; data block
0520                                                                          ;
0521                                                                          ; As operations on zero page locations are faster and
0522                                                                          ; have smaller opcodes than operations on the rest of
0523                                                                          ; the addressable memory, Elite tends to store oft-used
0524                                                                          ; data here. A lot of the routines in Elite need to
0525                                                                          ; access and manipulate ship data, so to make this an
0526                                                                          ; efficient exercise, the ship data is first copied from
0527                                                                          ; the ship data blocks at K% into INWK (or, when new
0528                                                                          ; ships are spawned, from the blueprints at XX21). See
0529                                                                          ; the deep dive on "Ship data blocks" for details of
0530                                                                          ; what each of the bytes in the INWK data block
0531                                                                          ; represents
0532               
0533               XX19:
0534 0074                 bss NI. - 33                                        ; XX19(1 0) shares its location with INWK(34 33), which
0535                                                                          ; contains the address of the ship line heap
0536               
0537               LSP:
0538 0077                 bss 1                                               ; The ball line heap pointer, which contains the number
0539                                                                          ; of the first free byte after the end of the LSX2 and
0540                                                                          ; LSY2 heaps (see the deep dive on "The ball line heap"
0541                                                                          ; for details)
0542               
0543               QQ15:
0544 0078                 bss 6                                               ; The three 16-bit seeds for the selected system, i.e.
0545                                                                          ; the one in the crosshairs in the Short-range Chart
0546                                                                          ;
0547                                                                          ; See the deep dives on "Galaxy and system seeds" and
0548                                                                          ; "Twisting the system seeds" for more details
0549               
0550               K5:
0551 007E                 bss 0                                               ; Temporary storage used to store segment coordinates
0552                                                                          ; across successive calls to BLINE, the ball line
0553                                                                          ; routine
0554               
0555               XX18:
0556 007E                 bss 0                                               ; Temporary storage used to store coordinates in the
0557                                                                          ; LL9 ship-drawing routine
0558               
0559               QQ17:
0560 007E                 bss 1                                               ; Contains a number of flags that affect how text tokens
0561                                                                          ; are printed, particularly capitalisation:
0562                                                                          ;
0563                                                                          ; * If all bits are set (255) then text printing is
0564                                                                          ; disabled
0565                                                                          ;
0566                                                                          ; * Bit 7: 0 = ALL CAPS
0567                                                                          ; 1 = Sentence Case, bit 6 determines the
0568                                                                          ; case of the next letter to print
0569                                                                          ;
0570                                                                          ; * Bit 6: 0 = print the next letter in upper case
0571                                                                          ; 1 = print the next letter in lower case
0572                                                                          ;
0573                                                                          ; * Bits 0-5: If any of bits 0-5 are set, print in
0574                                                                          ; lower case
0575                                                                          ;
0576                                                                          ; So:
0577                                                                          ;
0578                                                                          ; * QQ17 = 0 means case is set to ALL CAPS
0579                                                                          ;
0580                                                                          ; * QQ17 = %10000000 means Sentence Case, currently
0581                                                                          ; printing upper case
0582                                                                          ;
0583                                                                          ; * QQ17 = %11000000 means Sentence Case, currently
0584                                                                          ; printing lower case
0585                                                                          ;
0586                                                                          ; * QQ17 = %11111111 means printing is disabled
0587               
0588               QQ19:
0589 007F                 bss 3                                               ; Temporary storage, used in a number of places
0590               
0591               K6:
0592 0082                 bss 5                                               ; Temporary storage, typically used for storing
0593                                                                          ; coordinates during vector calculations
0594               
0595               ALP1:
0596 0087                 bss 1                                               ; Magnitude of the roll angle alpha, i.e. |alpha|,
0597                                                                          ; which is a positive value between 0 and 31
0598               
0599               ALP2:
0600 0088                 bss 2                                               ; Bit 7 of ALP2 = sign of the roll angle in ALPHA
0601                                                                          ;
0602                                                                          ; Bit 7 of ALP2+1 = opposite sign to ALP2 and ALPHA
0603               
0604               BET2:
0605 008A                 bss 2                                               ; Bit 7 of BET2 = sign of the pitch angle in BETA
0606                                                                          ;
0607                                                                          ; Bit 7 of BET2+1 = opposite sign to BET2 and BETA
0608               
0609               DELTA:
0610 008C                 bss 1                                               ; Our current speed, in the range 1-40
0611               
0612               DELT4:
0613 008D                 bss 2                                               ; Our current speed * 64 as a 16-bit value
0614                                                                          ;
0615                                                                          ; This is stored as DELT4(1 0), so the high byte in
0616                                                                          ; DELT4+1 therefore contains our current speed / 4
0617               
0618               U:
0619 008F                 bss 1                                               ; Temporary storage, used in a number of places
0620               
0621               Q:
0622 0090                 bss 1                                               ; Temporary storage, used in a number of places
0623               
0624               R:
0625 0091                 bss 1                                               ; Temporary storage, used in a number of places
0626               
0627               S:
0628 0092                 bss 1                                               ; Temporary storage, used in a number of places
0629               
0630               XSAV:
0631 0093                 bss 1                                               ; Temporary storage for saving the value of the X
0632                                                                          ; register, used in a number of places
0633               
0634               YSAV:
0635 0094                 bss 1                                               ; Temporary storage for saving the value of the Y
0636                                                                          ; register, used in a number of places
0637               
0638               XX17:
0639 0095                 bss 1                                               ; Temporary storage, used in BPRNT to store the number
0640                                                                          ; of characters to print, and as the edge counter in the
0641                                                                          ; main ship-drawing routine
0642               
0643               QQ11:
0644 0096                 bss 1                                               ; The type of the current view:
0645                                                                          ;
0646                                                                          ; 0   = Space view
0647                                                                          ; 1   = Title screen
0648                                                                          ; Get commander name ("@", save/load commander)
0649                                                                          ; In-system jump just arrived ("J")
0650                                                                          ; Data on System screen (red key f6)
0651                                                                          ; Buy Cargo screen (red key f1)
0652                                                                          ; Mis-jump just arrived (witchspace)
0653                                                                          ; 4   = Sell Cargo screen (red key f2)
0654                                                                          ; 6   = Death screen
0655                                                                          ; 8   = Status Mode screen (red key f8)
0656                                                                          ; Inventory screen (red key f9)
0657                                                                          ; 16  = Market Price screen (red key f7)
0658                                                                          ; 32  = Equip Ship screen (red key f3)
0659                                                                          ; 64  = Long-range Chart (red key f4)
0660                                                                          ; 128 = Short-range Chart (red key f5)
0661                                                                          ;
0662                                                                          ; This value is typically set by calling routine TT66
0663               
0664               ZZ:
0665 0097                 bss 1                                               ; Temporary storage, typically used for distance values
0666               
0667               XX13:
0668 0098                 bss 1                                               ; Temporary storage, typically used in the line-drawing
0669                                                                          ; routines
0670               
0671               MCNT:
0672 0099                 bss 1                                               ; The main loop counter
0673                                                                          ;
0674                                                                          ; This counter determines how often certain actions are
0675                                                                          ; performed within the main loop. See the deep dive on
0676                                                                          ; "Scheduling tasks with the main loop counter" for more
0677                                                                          ; details
0678               
0679               DL:
0680 009A                 bss 1                                               ; Vertical sync flag
0681                                                                          ;
0682                                                                          ; DL gets set to 30 every time we reach vertical sync on
0683                                                                          ; the video system, which happens 50 times a second
0684                                                                          ; (50Hz). The WSCAN routine uses this to pause until the
0685                                                                          ; vertical sync, by setting DL to 0 and then monitoring
0686                                                                          ; its value until it changes to 30
0687               
0688               TYPE:
0689 009B                 bss 1                                               ; The current ship type
0690                                                                          ;
0691                                                                          ; This is where we store the current ship type for when
0692                                                                          ; we are iterating through the ships in the local bubble
0693                                                                          ; as part of the main flight loop. See the table at XX21
0694                                                                          ; for information about ship types
0695               
0696               JSTX:
0697 009C                 bss 1                                               ; Our current roll rate
0698                                                                          ;
0699                                                                          ; This value is shown in the dashboard's RL indicator,
0700                                                                          ; and determines the rate at which we are rolling
0701                                                                          ;
0702                                                                          ; The value ranges from 1 to 255 with 128 as the centre
0703                                                                          ; point, so 1 means roll is decreasing at the maximum
0704                                                                          ; rate, 128 means roll is not changing, and 255 means
0705                                                                          ; roll is increasing at the maximum rate
0706                                                                          ;
0707                                                                          ; This value is updated by "<" and ">" key presses, or
0708                                                                          ; if joysticks are enabled, from the joystick. If
0709                                                                          ; keyboard damping is enabled (which it is by default),
0710                                                                          ; the value is slowly moved towards the centre value of
0711                                                                          ; 128 (no roll) if there are no key presses or joystick
0712                                                                          ; movement
0713               
0714               JSTY:
0715 009D                 bss 1                                               ; Our current pitch rate
0716                                                                          ;
0717                                                                          ; This value is shown in the dashboard's DC indicator,
0718                                                                          ; and determines the rate at which we are pitching
0719                                                                          ;
0720                                                                          ; The value ranges from 1 to 255 with 128 as the centre
0721                                                                          ; point, so 1 means pitch is decreasing at the maximum
0722                                                                          ; rate, 128 means pitch is not changing, and 255 means
0723                                                                          ; pitch is increasing at the maximum rate
0724                                                                          ;
0725                                                                          ; This value is updated by "S" and "X" key presses, or
0726                                                                          ; if joysticks are enabled, from the joystick. If
0727                                                                          ; keyboard damping is enabled (which it is by default),
0728                                                                          ; the value is slowly moved towards the centre value of
0729                                                                          ; 128 (no pitch) if there are no key presses or joystick
0730                                                                          ; movement
0731               
0732               ALPHA:
0733 009E                 bss 1                                               ; The current roll angle alpha, which is reduced from
0734                                                                          ; JSTX to a sign-magnitude value between -31 and +31
0735                                                                          ;
0736                                                                          ; This describes how fast we are rolling our ship, and
0737                                                                          ; determines how fast the universe rolls around us
0738                                                                          ;
0739                                                                          ; The sign bit is also stored in ALP2, while the
0740                                                                          ; opposite sign is stored in ALP2+1
0741               
0742               QQ12:
0743 009F                 bss 1                                               ; Our "docked" status
0744                                                                          ;
0745                                                                          ; * 0 = we are not docked
0746                                                                          ;
0747                                                                          ; * &FF = we are docked
0748               
0749               TGT:
0750 00A0                 bss 1                                               ; Temporary storage, typically used as a target value
0751                                                                          ; for counters when drawing explosion clouds and partial
0752                                                                          ; circles
0753               
0754               SWAP:
0755 00A1                 bss 1                                               ; Temporary storage, used to store a flag that records
0756                                                                          ; whether or not we had to swap a line's start and end
0757                                                                          ; coordinates around when clipping the line in routine
0758                                                                          ; LL145 (the flag is used in places like BLINE to swap
0759                                                                          ; them back)
0760               
0761               COL:
0762 00A2                 bss 1                                               ; Temporary storage, used to store colour information
0763                                                                          ; when drawing pixels in the dashboard
0764               
0765               FLAG:
0766 00A3                 bss 1                                               ; A flag that's used to define whether this is the first
0767                                                                          ; call to the ball line routine in BLINE, so it knows
0768                                                                          ; whether to wait for the second call before storing
0769                                                                          ; segment data in the ball line heap
0770               
0771               CNT:
0772 00A4                 bss 1                                               ; Temporary storage, typically used for storing the
0773                                                                          ; number of iterations required when looping
0774               
0775               CNT2:
0776 00A5                 bss 1                                               ; Temporary storage, used in the planet-drawing routine
0777                                                                          ; to store the segment number where the arc of a partial
0778                                                                          ; circle should start
0779               
0780               STP:
0781 00A6                 bss 1                                               ; The step size for drawing circles
0782                                                                          ;
0783                                                                          ; Circles in Elite are split up into 64 points, and the
0784                                                                          ; step size determines how many points to skip with each
0785                                                                          ; straight-line segment, so the smaller the step size,
0786                                                                          ; the smoother the circle. The values used are:
0787                                                                          ;
0788                                                                          ; * 2 for big planets and the circles on the charts
0789                                                                          ; * 4 for medium planets and the launch tunnel
0790                                                                          ; * 8 for small planets and the hyperspace tunnel
0791                                                                          ;
0792                                                                          ; As the step size increases we move from smoother
0793                                                                          ; circles at the top to more polygonal at the bottom.
0794                                                                          ; See the CIRCLE2 routine for more details
0795               
0796               XX4:
0797 00A7                 bss 1                                               ; Temporary storage, used in a number of places
0798               
0799               XX20:
0800 00A8                 bss 1                                               ; Temporary storage, used in a number of places
0801               
0802               XX14:
0803 00A9                 bss 1                                               ; This byte appears to be unused
0804               
0805               RAT:
0806 00AA                 bss 1                                               ; Used to store different signs depending on the current
0807                                                                          ; space view, for use in calculating stardust movement
0808               
0809               RAT2:
0810 00AB                 bss 1                                               ; Temporary storage, used to store the pitch and roll
0811                                                                          ; signs when moving objects and stardust
0812               
0813               K2:
0814 00AC                 bss 4                                               ; Temporary storage, used in a number of places
0815               
0816               * RM: At &00B0 = 176
0817               
0818                      aorg ZERO_PAGE.+>00D1
0819               
0820               T:
0821 00D1                 bss 1                                               ; Temporary storage, used in a number of places
0822               
0823               K3:
0824 00D2                 bss 0                                               ; Temporary storage, used in a number of places
0825               
0826               XX2:
0827 00D2                 bss 14                                              ; Temporary storage, used to store the visibility of the
0828                                                                          ; ship's faces during the ship-drawing routine at LL9
0829               
0830               K4:
0831 00E0                 bss 2                                               ; Temporary storage, used in a number of places
0832               
0833                      ; PRINT "Zero page variables from ", ~ZP, " to ", ~P%
0834               
0835               * ******************************************************************************
0836               *
0837               * Name: XX3
0838               * Type: Workspace
0839               * Address: &0100 to the top of the descending stack
0840               * Category: Workspaces
0841               * Summary: Temporary storage space for complex calculations
0842               *
0843               * ------------------------------------------------------------------------------
0844               *
0845               * Used as heap space for storing temporary data during calculations. Shared with
0846               * the descending 6502 stack, which works down from &01FF.
0847               *
0848               * ******************************************************************************
0849               
0850                      aorg STACK.
0851               
0852               XX3:
0853 0100                 bss 256                                             ; Temporary storage, typically used for storing tables
0854                                                                          ; of values such as screen coordinates or ship data
0855               
0856               * ******************************************************************************
0857               *
0858               * Name: T%
0859               * Type: Workspace
0860               * Address: &0300 to &035F
0861               * Category: Workspaces
0862               * Summary: Current commander data and stardust data blocks
0863               *
0864               * ------------------------------------------------------------------------------
0865               *
0866               * Contains the current commander data (NT% bytes at location TP), and the
0867               * stardust data blocks (NOST bytes at location SX)
0868               *
0869               * ******************************************************************************
0870               
0871                      aorg T.
0872               
0873 0300                 bss 0                                               ; The start of the T% workspace
0874               
0875               TP:
0876 0300                 bss 1                                               ; The current mission status, which is always 0 for the
0877                                                                          ; cassette version of Elite as there are no missions
0878               
0879               QQ0:
0880 0301                 bss 1                                               ; The current system's galactic x-coordinate (0-256)
0881               
0882               QQ1:
0883 0302                 bss 1                                               ; The current system's galactic y-coordinate (0-256)
0884               
0885               QQ21:
0886 0303                 bss 6                                               ; The three 16-bit seeds for the current galaxy
0887                                                                          ;
0888                                                                          ; These seeds define system 0 in the current galaxy, so
0889                                                                          ; they can be used as a starting point to generate all
0890                                                                          ; 256 systems in the galaxy
0891                                                                          ;
0892                                                                          ; Using a galactic hyperdrive rotates each byte to the
0893                                                                          ; left (rolling each byte within itself) to get the
0894                                                                          ; seeds for the next galaxy, so after eight galactic
0895                                                                          ; jumps, the seeds roll around to the first galaxy again
0896                                                                          ;
0897                                                                          ; See the deep dives on "Galaxy and system seeds" and
0898                                                                          ; "Twisting the system seeds" for more details
0899               
0900               CASH:
0901 0309                 bss 4                                               ; Our current cash pot
0902                                                                          ;
0903                                                                          ; The cash stash is stored as a 32-bit unsigned integer,
0904                                                                          ; with the most significant byte in CASH and the least
0905                                                                          ; significant in CASH+3. This is big-endian, which is
0906                                                                          ; the opposite way round to most of the numbers used in
0907                                                                          ; Elite - to use our notation for multi-byte numbers,
0908                                                                          ; the amount of cash is CASH(0 1 2 3)
0909               
0910               QQ14:
0911 030D                 bss 1                                               ; Our current fuel level (0-70)
0912                                                                          ;
0913                                                                          ; The fuel level is stored as the number of light years
0914                                                                          ; multiplied by 10, so QQ14 = 1 represents 0.1 light
0915                                                                          ; years, and the maximum possible value is 70, for 7.0
0916                                                                          ; light years
0917               
0918               COK:
0919 030E                 bss 1                                               ; Flags used to generate the competition code
0920                                                                          ;
0921                                                                          ; See the deep dive on "The competition code" for
0922                                                                          ; details of these flags and how they are used in
0923                                                                          ; generating and decoding the competition code
0924               
0925               GCNT:
0926 030F                 bss 1                                               ; The number of the current galaxy (0-7)
0927                                                                          ;
0928                                                                          ; When this is displayed in-game, 1 is added to the
0929                                                                          ; number, so we start in galaxy 1 in-game, but it's
0930                                                                          ; stored as galaxy 0 internally
0931                                                                          ;
0932                                                                          ; The galaxy number increases by one every time a
0933                                                                          ; galactic hyperdrive is used, and wraps back around to
0934                                                                          ; the start after eight galaxies
0935               
0936               LASER:
0937 0310                 bss 4                                               ; The specifications of the lasers fitted to each of the
0938                                                                          ; four space views:
0939                                                                          ;
0940                                                                          ; * Byte #0 = front view
0941                                                                          ; * Byte #1 = rear view
0942                                                                          ; * Byte #2 = left view
0943                                                                          ; * Byte #3 = right view
0944                                                                          ;
0945                                                                          ; For each of the views:
0946                                                                          ;
0947                                                                          ; * 0 = no laser is fitted to this view
0948                                                                          ;
0949                                                                          ; * Non-zero = a laser is fitted to this view, with
0950                                                                          ; the following specification:
0951                                                                          ;
0952                                                                          ; * Bits 0-6 contain the laser's power
0953                                                                          ;
0954                                                                          ; * Bit 7 determines whether or not the laser pulses
0955                                                                          ; (0 = pulse laser) or is always on (1 = beam
0956                                                                          ; laser)
0957               
0958 0314                 bss 2                                               ; These bytes appear to be unused (they were originally
0959                                                                          ; used for up/down lasers, but they were dropped)
0960               
0961               CRGO:
0962 0316                 bss 1                                               ; Our ship's cargo capacity
0963                                                                          ;
0964                                                                          ; * 22 = standard cargo bay of 20 tonnes
0965                                                                          ;
0966                                                                          ; * 37 = large cargo bay of 35 tonnes
0967                                                                          ;
0968                                                                          ; The value is two greater than the actual capacity to
0969                                                                          ; make the maths in tnpr slightly more efficient
0970               
0971               QQ20:
0972 0317                 bss 17                                              ; The contents of our cargo hold
0973                                                                          ;
0974                                                                          ; The amount of market item X that we have in our hold
0975                                                                          ; can be found in the X-th byte of QQ20. For example:
0976                                                                          ;
0977                                                                          ; * QQ20 contains the amount of food (item 0)
0978                                                                          ;
0979                                                                          ; * QQ20+7 contains the amount of computers (item 7)
0980                                                                          ;
0981                                                                          ; See QQ23 for a list of market item numbers and their
0982                                                                          ; storage units
0983               
0984               ECM:
0985 0328                 bss 1                                               ; E.C.M. system
0986                                                                          ;
0987                                                                          ; * 0 = not fitted
0988                                                                          ;
0989                                                                          ; * &FF = fitted
0990               
0991               BST:
0992 0329                 bss 1                                               ; Fuel scoops (BST stands for "barrel status")
0993                                                                          ;
0994                                                                          ; * 0 = not fitted
0995                                                                          ;
0996                                                                          ; * &FF = fitted
0997               
0998               BOMB:
0999 032A                 bss 1                                               ; Energy bomb
1000                                                                          ;
1001                                                                          ; * 0 = not fitted
1002                                                                          ;
1003                                                                          ; * &7F = fitted
1004               
1005               ENGY:
1006 032B                 bss 1                                               ; Energy unit
1007                                                                          ;
1008                                                                          ; * 0 = not fitted
1009                                                                          ;
1010                                                                          ; * Non-zero = fitted
1011                                                                          ;
1012                                                                          ; The actual value determines the refresh rate of our
1013                                                                          ; energy banks, as they refresh by ENGY+1 each time (so
1014                                                                          ; our ship's energy level goes up by 2 each time if we
1015                                                                          ; have an energy unit fitted, otherwise it goes up by 1)
1016               
1017               DKCMP:
1018 032C                 bss 1                                               ; Docking computer
1019                                                                          ;
1020                                                                          ; * 0 = not fitted
1021                                                                          ;
1022                                                                          ; * &FF = fitted
1023               
1024               GHYP:
1025 032D                 bss 1                                               ; Galactic hyperdrive
1026                                                                          ;
1027                                                                          ; * 0 = not fitted
1028                                                                          ;
1029                                                                          ; * &FF = fitted
1030               
1031               ESCP:
1032 032E                 bss 1                                               ; Escape pod
1033                                                                          ;
1034                                                                          ; * 0 = not fitted
1035                                                                          ;
1036                                                                          ; * &FF = fitted
1037               
1038 032F                 bss 4                                               ; These bytes appear to be unused
1039               
1040               NOMSL:
1041 0333                 bss 1                                               ; The number of missiles we have fitted (0-4)
1042               
1043               FIST:
1044 0334                 bss 1                                               ; Our legal status (FIST stands for "fugitive/innocent
1045                                                                          ; status"):
1046                                                                          ;
1047                                                                          ; * 0 = Clean
1048                                                                          ;
1049                                                                          ; * 1-49 = Offender
1050                                                                          ;
1051                                                                          ; * 50+ = Fugitive
1052                                                                          ;
1053                                                                          ; You get 64 points if you kill a cop, so that's a fast
1054                                                                          ; ticket to fugitive status
1055               
1056               AVL:
1057 0335                 bss 17                                              ; Market availability in the current system
1058                                                                          ;
1059                                                                          ; The available amount of market item X is stored in
1060                                                                          ; the X-th byte of AVL, so for example:
1061                                                                          ;
1062                                                                          ; * AVL contains the amount of food (item 0)
1063                                                                          ;
1064                                                                          ; * AVL+7 contains the amount of computers (item 7)
1065                                                                          ;
1066                                                                          ; See QQ23 for a list of market item numbers and their
1067                                                                          ; storage units, and the deep dive on "Market item
1068                                                                          ; prices and availability" for details of the algorithm
1069                                                                          ; used for calculating each item's availability
1070               
1071               QQ26:
1072 0346                 bss 1                                               ; A random value used to randomise market data
1073                                                                          ;
1074                                                                          ; This value is set to a new random number for each
1075                                                                          ; change of system, so we can add a random factor into
1076                                                                          ; the calculations for market prices (for details of how
1077                                                                          ; this is used, see the deep dive on "Market prices")
1078               
1079               TALLY:
1080 0347                 bss 2                                               ; Our combat rank
1081                                                                          ;
1082                                                                          ; The combat rank is stored as the number of kills, in a
1083                                                                          ; 16-bit number TALLY(1 0) - so the high byte is in
1084                                                                          ; TALLY+1 and the low byte in TALLY
1085                                                                          ;
1086                                                                          ; If the high byte in TALLY+1 is 0 then we have between
1087                                                                          ; 0 and 255 kills, so our rank is Harmless, Mostly
1088                                                                          ; Harmless, Poor, Average or Above Average, according to
1089                                                                          ; the value of the low byte in TALLY:
1090                                                                          ;
1091                                                                          ; Harmless        = %00000000 to %00000011 = 0 to 3
1092                                                                          ; Mostly Harmless = %00000100 to %00000111 = 4 to 7
1093                                                                          ; Poor            = %00001000 to %00001111 = 8 to 15
1094                                                                          ; Average         = %00010000 to %00011111 = 16 to 31
1095                                                                          ; Above Average   = %00100000 to %11111111 = 32 to 255
1096                                                                          ;
1097                                                                          ; If the high byte in TALLY+1 is non-zero then we are
1098                                                                          ; Competent, Dangerous, Deadly or Elite, according to
1099                                                                          ; the high byte in TALLY+1:
1100                                                                          ;
1101                                                                          ; Competent       = 1           = 256 to 511 kills
1102                                                                          ; Dangerous       = 2 to 9      = 512 to 2559 kills
1103                                                                          ; Deadly          = 10 to 24    = 2560 to 6399 kills
1104                                                                          ; Elite           = 25 and up   = 6400 kills and up
1105                                                                          ;
1106                                                                          ; You can see the rating calculation in the STATUS
1107                                                                          ; subroutine
1108               
1109               SVC:
1110 0349                 bss 1                                               ; The save count
1111                                                                          ;
1112                                                                          ; When a new commander is created, the save count gets
1113                                                                          ; set to 128. This value gets halved each time the
1114                                                                          ; commander file is saved, but it is otherwise unused.
1115                                                                          ; It is presumably part of the security system for the
1116                                                                          ; competition, possibly another flag to catch out
1117                                                                          ; entries with manually altered commander files
1118               
1119 034A                 bss 2                                               ; The commander file checksum
1120                                                                          ;
1121                                                                          ; These two bytes are reserved for the commander file
1122                                                                          ; checksum, so when the current commander block is
1123                                                                          ; copied from here to the last saved commander block at
1124                                                                          ; NA%, CHK and CHK2 get overwritten
1125               
1126               NT.:                                                       ; This sets the variable NT% to the size of the current
1127                      equ SVC + 2 - TP
1128                                                                          ; commander data block, which starts at TP and ends at
1129                                                                          ; SVC+2 (inclusive)
1130               
1131               SX:
1132 034C                 bss NOST + 1                                        ; This is where we store the x_hi coordinates for all
1133                                                                          ; the stardust particles
1134               
1135               SXL:
1136 035F                 bss NOST + 1                                        ; This is where we store the x_lo coordinates for all
1137                                                                          ; the stardust particles
1138               
1139                      ; PRINT "T% workspace from  ", ~T%, " to ", ~P%
1140               
1141               * ******************************************************************************
1142               *
1143               * ELITE RECURSIVE TEXT TOKEN FILE
1144               *
1145               * Produces the binary file WORDS9.bin that gets loaded by elite-loader.asm.
1146               *
1147               * The recursive token table is loaded at &1100 and is moved down to &0400 as
1148               * part of elite-loader.asm, so it ends up at &0400 to &07FF.
1149               *
1150               * ******************************************************************************
1151               
1152                      aorg CODE_WORDS.
1153               
1154               * ******************************************************************************
1155               *
1156               * Name: CHAR
1157               * Type: Macro
1158               * Category: Text
1159               * Summary: Macro definition for characters in the recursive token table
1160               * Deep dive: Printing text tokens
1161               *
1162               * ------------------------------------------------------------------------------
1163               *
1164               * The following macro is used when building the recursive token table:
1165               *
1166               * CHAR 'x'            Insert ASCII character "x"
1167               *
1168               * To include an apostrophe, use a backtick character, as in CHAR '`'.
1169               *
1170               * See the deep dive on "Printing text tokens" for details on how characters are
1171               * stored in the recursive token table.
1172               *
1173               * ------------------------------------------------------------------------------
1174               *
1175               * Arguments:
1176               *
1177               * 'x'                 The character to insert into the table
1178               *
1179               * ******************************************************************************
1180               
1181                      ; MACRO CHAR x
1182               
1183                      ; IF x = '`'                    ;
1184                      ; EQUB 39 EOR RE                ;
1185                      ; ELSE                          ;
1186                      ; EQUB x EOR RE                 ;
1187                      ; ENDIF                         ;
1188               
1189                      ; ENDMACRO
1190               
1191               * ******************************************************************************
1192               *
1193               * Name: TWOK
1194               * Type: Macro
1195               * Category: Text
1196               * Summary: Macro definition for two-letter tokens in the token table
1197               * Deep dive: Printing text tokens
1198               *
1199               * ------------------------------------------------------------------------------
1200               *
1201               * The following macro is used when building the recursive token table:
1202               *
1203               * TWOK 'x', 'y'       Insert two-letter token "xy"
1204               *
1205               * See the deep dive on "Printing text tokens" for details on how two-letter
1206               * tokens are stored in the recursive token table.
1207               *
1208               * ------------------------------------------------------------------------------
1209               *
1210               * Arguments:
1211               *
1212               * 'x'                 The first letter of the two-letter token to insert into
1213               * the table
1214               *
1215               * 'y'                 The second letter of the two-letter token to insert into
1216               * the table
1217               *
1218               * ******************************************************************************
1219               
1220                      ; MACRO TWOK t, k
1221               
1222                      ; IF t = 'A' AND k = 'L' : EQUB 128 EOR RE : ENDIF ;
1223                      ; IF t = 'L' AND k = 'E' : EQUB 129 EOR RE : ENDIF ;
1224                      ; IF t = 'X' AND k = 'E' : EQUB 130 EOR RE : ENDIF ;
1225                      ; IF t = 'G' AND k = 'E' : EQUB 131 EOR RE : ENDIF ;
1226                      ; IF t = 'Z' AND k = 'A' : EQUB 132 EOR RE : ENDIF ;
1227                      ; IF t = 'C' AND k = 'E' : EQUB 133 EOR RE : ENDIF ;
1228                      ; IF t = 'B' AND k = 'I' : EQUB 134 EOR RE : ENDIF ;
1229                      ; IF t = 'S' AND k = 'O' : EQUB 135 EOR RE : ENDIF ;
1230                      ; IF t = 'U' AND k = 'S' : EQUB 136 EOR RE : ENDIF ;
1231                      ; IF t = 'E' AND k = 'S' : EQUB 137 EOR RE : ENDIF ;
1232                      ; IF t = 'A' AND k = 'R' : EQUB 138 EOR RE : ENDIF ;
1233                      ; IF t = 'M' AND k = 'A' : EQUB 139 EOR RE : ENDIF ;
1234                      ; IF t = 'I' AND k = 'N' : EQUB 140 EOR RE : ENDIF ;
1235                      ; IF t = 'D' AND k = 'I' : EQUB 141 EOR RE : ENDIF ;
1236                      ; IF t = 'R' AND k = 'E' : EQUB 142 EOR RE : ENDIF ;
1237                      ; IF t = 'A' AND k = '?' : EQUB 143 EOR RE : ENDIF ;
1238                      ; IF t = 'E' AND k = 'R' : EQUB 144 EOR RE : ENDIF ;
1239                      ; IF t = 'A' AND k = 'T' : EQUB 145 EOR RE : ENDIF ;
1240                      ; IF t = 'E' AND k = 'N' : EQUB 146 EOR RE : ENDIF ;
1241                      ; IF t = 'B' AND k = 'E' : EQUB 147 EOR RE : ENDIF ;
1242                      ; IF t = 'R' AND k = 'A' : EQUB 148 EOR RE : ENDIF ;
1243                      ; IF t = 'L' AND k = 'A' : EQUB 149 EOR RE : ENDIF ;
1244                      ; IF t = 'V' AND k = 'E' : EQUB 150 EOR RE : ENDIF ;
1245                      ; IF t = 'T' AND k = 'I' : EQUB 151 EOR RE : ENDIF ;
1246                      ; IF t = 'E' AND k = 'D' : EQUB 152 EOR RE : ENDIF ;
1247                      ; IF t = 'O' AND k = 'R' : EQUB 153 EOR RE : ENDIF ;
1248                      ; IF t = 'Q' AND k = 'U' : EQUB 154 EOR RE : ENDIF ;
1249                      ; IF t = 'A' AND k = 'N' : EQUB 155 EOR RE : ENDIF ;
1250                      ; IF t = 'T' AND k = 'E' : EQUB 156 EOR RE : ENDIF ;
1251                      ; IF t = 'I' AND k = 'S' : EQUB 157 EOR RE : ENDIF ;
1252                      ; IF t = 'R' AND k = 'I' : EQUB 158 EOR RE : ENDIF ;
1253                      ; IF t = 'O' AND k = 'N' : EQUB 159 EOR RE : ENDIF ;
1254               
1255                      ; ENDMACRO
1256               
1257               * ******************************************************************************
1258               *
1259               * Name: CONT
1260               * Type: Macro
1261               * Category: Text
1262               * Summary: Macro definition for control codes in the recursive token table
1263               * Deep dive: Printing text tokens
1264               *
1265               * ------------------------------------------------------------------------------
1266               *
1267               * The following macro is used when building the recursive token table:
1268               *
1269               * CONT n              Insert control code token {n}
1270               *
1271               * See the deep dive on "Printing text tokens" for details on how characters are
1272               * stored in the recursive token table.
1273               *
1274               * ------------------------------------------------------------------------------
1275               *
1276               * Arguments:
1277               *
1278               * n                   The control code to insert into the table
1279               *
1280               * ******************************************************************************
1281               
1282                      ; MACRO CONT n
1283               
1284                      ; EQUB n EOR RE                 ;
1285               
1286                      ; ENDMACRO
1287               
1288               * ******************************************************************************
1289               *
1290               * Name: RTOK
1291               * Type: Macro
1292               * Category: Text
1293               * Summary: Macro definition for recursive tokens in the recursive token table
1294               * Deep dive: Printing text tokens
1295               *
1296               * ------------------------------------------------------------------------------
1297               *
1298               * The following macro is used when building the recursive token table:
1299               *
1300               * RTOK n              Insert recursive token [n]
1301               *
1302               * * Tokens 0-95 get stored as n + 160
1303               *
1304               * * Tokens 128-145 get stored as n - 114
1305               *
1306               * * Tokens 96-127 get stored as n
1307               *
1308               * See the deep dive on "Printing text tokens" for details on how recursive
1309               * tokens are stored in the recursive token table.
1310               *
1311               * ------------------------------------------------------------------------------
1312               *
1313               * Arguments:
1314               *
1315               * n                   The number of the recursive token to insert into the
1316               * table, in the range 0 to 145
1317               *
1318               * ******************************************************************************
1319               
1320                      ; MACRO RTOK n
1321               
1322                      ; IF n >= 0 AND n <= 95         ;
1323                      ; t = n + 160                   ;
1324                      ; ELIF n >= 128                 ;
1325                      ; t = n - 114                   ;
1326                      ; ELSE                          ;
1327                      ; t = n                         ;
1328                      ; ENDIF                         ;
1329               
1330                      ; EQUB t EOR RE                 ;
1331               
1332                      ; ENDMACRO
1333               
1334               * ******************************************************************************
1335               *
1336               * Name: QQ18
1337               * Type: Variable
1338               * Category: Text
1339               * Summary: The recursive token table for tokens 0-148
1340               * Deep dive: Printing text tokens
1341               *
1342               * ******************************************************************************
1343               
1344               QQ18:
1345                      .rtok 111                                           ; Token 0:      "FUEL SCOOPS ON {beep}"
     **** ****     > RTOK
0008 0400 4C              byte 111 ^ RE
                   < elite.a99
1346                      .rtok 131                                           ;
     **** ****     > RTOK
0006 0401   32            byte (131 - 114) ^ RE
                   < elite.a99
1347                      .cont 7                                             ; Encoded as:   "[111][131]{7}"
     **** ****     > CONT
0001 0402 24              byte 7 ^ RE
                   < elite.a99
1348 0403   00            byte >00
1349               
1350                      .char ' '                                           ; Token 1:      " CHART"
     **** ****     > CHAR
0004 0404 03              byte ' ' ^ RE
                   < elite.a99
1351                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0405   60            byte 'C' ^ RE
                   < elite.a99
1352                      .char 'H'                                           ; Encoded as:   " CH<138>T"
     **** ****     > CHAR
0004 0406 6B              byte 'H' ^ RE
                   < elite.a99
1353 0407   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1354                      .char 'T'
     **** ****     > CHAR
0004 0408 77              byte 'T' ^ RE
                   < elite.a99
1355 0409   00            byte >00
1356               
1357                      .char 'G'                                           ; Token 2:      "GOVERNMENT"
     **** ****     > CHAR
0004 040A 64              byte 'G' ^ RE
                   < elite.a99
1358                      .char 'O'                                           ;
     **** ****     > CHAR
0004 040B   6C            byte 'O' ^ RE
                   < elite.a99
1359 040C B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' Encoded as:   "GO<150>RNM<146>T"
1360                      .char 'R'
     **** ****     > CHAR
0004 040D   71            byte 'R' ^ RE
                   < elite.a99
1361                      .char 'N'
     **** ****     > CHAR
0004 040E 6D              byte 'N' ^ RE
                   < elite.a99
1362                      .char 'M'
     **** ****     > CHAR
0004 040F   6E            byte 'M' ^ RE
                   < elite.a99
1363 0410 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
1364                      .char 'T'
     **** ****     > CHAR
0004 0411   77            byte 'T' ^ RE
                   < elite.a99
1365 0412 00              byte >00
1366               
1367                      .char 'D'                                           ; Token 3:      "DATA ON {selected system name}"
     **** ****     > CHAR
0004 0413   67            byte 'D' ^ RE
                   < elite.a99
1368 0414 B2              byte 145 ^ RE                                       ; TWOK 'A', 'T'
1369                      .char 'A'                                           ; Encoded as:   "D<145>A[131]{3}"
     **** ****     > CHAR
0004 0415   62            byte 'A' ^ RE
                   < elite.a99
1370                      .rtok 131
     **** ****     > RTOK
0006 0416 32              byte (131 - 114) ^ RE
                   < elite.a99
1371                      .cont 3
     **** ****     > CONT
0001 0417   20            byte 3 ^ RE
                   < elite.a99
1372 0418 00              byte >00
1373               
1374 0419   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 4:      "INVENTORY{crlf}
1375 041A B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' "
1376                      .char 'N'                                           ;
     **** ****     > CHAR
0004 041B   6D            byte 'N' ^ RE
                   < elite.a99
1377                      .char 'T'                                           ; Encoded as:   "<140><150>NT<153>Y{13}"
     **** ****     > CHAR
0004 041C 77              byte 'T' ^ RE
                   < elite.a99
1378 041D   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1379                      .char 'Y'
     **** ****     > CHAR
0004 041E 7A              byte 'Y' ^ RE
                   < elite.a99
1380                      .cont 13
     **** ****     > CONT
0001 041F   2E            byte 13 ^ RE
                   < elite.a99
1381 0420 00              byte >00
1382               
1383                      .char 'S'                                           ; Token 5:      "SYSTEM"
     **** ****     > CHAR
0004 0421   70            byte 'S' ^ RE
                   < elite.a99
1384                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 0422 7A              byte 'Y' ^ RE
                   < elite.a99
1385                      .char 'S'                                           ; Encoded as:   "SYS<156>M"
     **** ****     > CHAR
0004 0423   70            byte 'S' ^ RE
                   < elite.a99
1386 0424 BF              byte 156 ^ RE                                       ; TWOK 'T', 'E' null
1387                      .char 'M'
     **** ****     > CHAR
0004 0425   6E            byte 'M' ^ RE
                   < elite.a99
1388 0426 00              byte >00
1389               
1390                      .char 'P'                                           ; Token 6:      "PRICE"
     **** ****     > CHAR
0004 0427   73            byte 'P' ^ RE
                   < elite.a99
1391 0428 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I'
1392 0429   A6            byte 133 ^ RE                                       ; TWOK 'C', 'E' Encoded as:   "P<158><133>"
1393 042A 00              byte >00
1394               
1395                      .cont 2                                             ; Token 7:      "{current system name} MARKET PRICES"
     **** ****     > CONT
0001 042B   21            byte 2 ^ RE
                   < elite.a99
1396                      .char ' '                                           ;
     **** ****     > CHAR
0004 042C 03              byte ' ' ^ RE
                   < elite.a99
1397 042D   A8            byte 139 ^ RE                                       ; TWOK 'M', 'A' Encoded as:   "{2} <139>RKET [6]S"
1398                      .char 'R'
     **** ****     > CHAR
0004 042E 71              byte 'R' ^ RE
                   < elite.a99
1399                      .char 'K'
     **** ****     > CHAR
0004 042F   68            byte 'K' ^ RE
                   < elite.a99
1400                      .char 'E'
     **** ****     > CHAR
0004 0430 66              byte 'E' ^ RE
                   < elite.a99
1401                      .char 'T'
     **** ****     > CHAR
0004 0431   77            byte 'T' ^ RE
                   < elite.a99
1402                      .char ' '
     **** ****     > CHAR
0004 0432 03              byte ' ' ^ RE
                   < elite.a99
1403                      .rtok 6
     **** ****     > RTOK
0003 0433   85            byte (6 + 160) ^ RE
                   < elite.a99
1404                      .char 'S'
     **** ****     > CHAR
0004 0434 70              byte 'S' ^ RE
                   < elite.a99
1405 0435   00            byte >00
1406               
1407 0436 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 8:      "INDUSTRIAL"
1408                      .char 'D'                                           ;
     **** ****     > CHAR
0004 0437   67            byte 'D' ^ RE
                   < elite.a99
1409 0438 AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' Encoded as:   "<140>D<136>T<158><128>"
1410                      .char 'T'
     **** ****     > CHAR
0004 0439   77            byte 'T' ^ RE
                   < elite.a99
1411 043A BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' null
1412 043B   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1413 043C 00              byte >00
1414               
1415                      .char 'A'                                           ; Token 9:      "AGRICULTURAL"
     **** ****     > CHAR
0004 043D   62            byte 'A' ^ RE
                   < elite.a99
1416                      .char 'G'                                           ;
     **** ****     > CHAR
0004 043E 64              byte 'G' ^ RE
                   < elite.a99
1417 043F   BD            byte 158 ^ RE                                       ; TWOK 'R', 'I' Encoded as:   "AG<158>CULTU<148>L"
1418                      .char 'C'
     **** ****     > CHAR
0004 0440 60              byte 'C' ^ RE
                   < elite.a99
1419                      .char 'U'
     **** ****     > CHAR
0004 0441   76            byte 'U' ^ RE
                   < elite.a99
1420                      .char 'L'
     **** ****     > CHAR
0004 0442 6F              byte 'L' ^ RE
                   < elite.a99
1421                      .char 'T'
     **** ****     > CHAR
0004 0443   77            byte 'T' ^ RE
                   < elite.a99
1422                      .char 'U'
     **** ****     > CHAR
0004 0444 76              byte 'U' ^ RE
                   < elite.a99
1423 0445   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' null
1424                      .char 'L'
     **** ****     > CHAR
0004 0446 6F              byte 'L' ^ RE
                   < elite.a99
1425 0447   00            byte >00
1426               
1427 0448 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' Token 10:     "RICH "
1428                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0449   60            byte 'C' ^ RE
                   < elite.a99
1429                      .char 'H'                                           ; Encoded as:   "<158>CH "
     **** ****     > CHAR
0004 044A 6B              byte 'H' ^ RE
                   < elite.a99
1430                      .char ' '
     **** ****     > CHAR
0004 044B   03            byte ' ' ^ RE
                   < elite.a99
1431 044C 00              byte >00
1432               
1433                      .char 'A'                                           ; Token 11:     "AVERAGE "
     **** ****     > CHAR
0004 044D   62            byte 'A' ^ RE
                   < elite.a99
1434 044E B5              byte 150 ^ RE                                       ; TWOK 'V', 'E'
1435 044F   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Encoded as:   "A<150><148><131> "
1436 0450 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' null
1437                      .char ' '
     **** ****     > CHAR
0004 0451   03            byte ' ' ^ RE
                   < elite.a99
1438 0452 00              byte >00
1439               
1440                      .char 'P'                                           ; Token 12:     "POOR "
     **** ****     > CHAR
0004 0453   73            byte 'P' ^ RE
                   < elite.a99
1441                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0454 6C              byte 'O' ^ RE
                   < elite.a99
1442 0455   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' Encoded as:   "PO<153> "
1443                      .char ' '
     **** ****     > CHAR
0004 0456 03              byte ' ' ^ RE
                   < elite.a99
1444 0457   00            byte >00
1445               
1446 0458 A8              byte 139 ^ RE                                       ; TWOK 'M', 'A' Token 13:     "MAINLY "
1447 0459   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
1448                      .char 'L'                                           ; Encoded as:   "<139><140>LY "
     **** ****     > CHAR
0004 045A 6F              byte 'L' ^ RE
                   < elite.a99
1449                      .char 'Y'
     **** ****     > CHAR
0004 045B   7A            byte 'Y' ^ RE
                   < elite.a99
1450                      .char ' '
     **** ****     > CHAR
0004 045C 03              byte ' ' ^ RE
                   < elite.a99
1451 045D   00            byte >00
1452               
1453                      .char 'U'                                           ; Token 14:     "UNIT"
     **** ****     > CHAR
0004 045E 76              byte 'U' ^ RE
                   < elite.a99
1454                      .char 'N'                                           ;
     **** ****     > CHAR
0004 045F   6D            byte 'N' ^ RE
                   < elite.a99
1455                      .char 'I'                                           ; Encoded as:   "UNIT"
     **** ****     > CHAR
0004 0460 6A              byte 'I' ^ RE
                   < elite.a99
1456                      .char 'T'
     **** ****     > CHAR
0004 0461   77            byte 'T' ^ RE
                   < elite.a99
1457 0462 00              byte >00
1458               
1459                      .char 'V'                                           ; Token 15:     "VIEW "
     **** ****     > CHAR
0004 0463   75            byte 'V' ^ RE
                   < elite.a99
1460                      .char 'I'                                           ;
     **** ****     > CHAR
0004 0464 6A              byte 'I' ^ RE
                   < elite.a99
1461                      .char 'E'                                           ; Encoded as:   "VIEW "
     **** ****     > CHAR
0004 0465   66            byte 'E' ^ RE
                   < elite.a99
1462                      .char 'W'
     **** ****     > CHAR
0004 0466 74              byte 'W' ^ RE
                   < elite.a99
1463                      .char ' '
     **** ****     > CHAR
0004 0467   03            byte ' ' ^ RE
                   < elite.a99
1464 0468 00              byte >00
1465               
1466 0469   B9            byte 154 ^ RE                                       ; TWOK 'Q', 'U' Token 16:     "QUANTITY"
1467 046A B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
1468 046B   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' Encoded as:   "<154><155><151>TY"
1469                      .char 'T'
     **** ****     > CHAR
0004 046C 77              byte 'T' ^ RE
                   < elite.a99
1470                      .char 'Y'
     **** ****     > CHAR
0004 046D   7A            byte 'Y' ^ RE
                   < elite.a99
1471 046E 00              byte >00
1472               
1473 046F   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Token 17:     "ANARCHY"
1474 0470 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1475                      .char 'C'                                           ; Encoded as:   "<155><138>CHY"
     **** ****     > CHAR
0004 0471   60            byte 'C' ^ RE
                   < elite.a99
1476                      .char 'H'
     **** ****     > CHAR
0004 0472 6B              byte 'H' ^ RE
                   < elite.a99
1477                      .char 'Y'
     **** ****     > CHAR
0004 0473   7A            byte 'Y' ^ RE
                   < elite.a99
1478 0474 00              byte >00
1479               
1480                      .char 'F'                                           ; Token 18:     "FEUDAL"
     **** ****     > CHAR
0004 0475   65            byte 'F' ^ RE
                   < elite.a99
1481                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0476 66              byte 'E' ^ RE
                   < elite.a99
1482                      .char 'U'                                           ; Encoded as:   "FEUD<128>"
     **** ****     > CHAR
0004 0477   76            byte 'U' ^ RE
                   < elite.a99
1483                      .char 'D'
     **** ****     > CHAR
0004 0478 67              byte 'D' ^ RE
                   < elite.a99
1484 0479   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1485 047A 00              byte >00
1486               
1487                      .char 'M'                                           ; Token 19:     "MULTI-GOVERNMENT"
     **** ****     > CHAR
0004 047B   6E            byte 'M' ^ RE
                   < elite.a99
1488                      .char 'U'                                           ;
     **** ****     > CHAR
0004 047C 76              byte 'U' ^ RE
                   < elite.a99
1489                      .char 'L'                                           ; Encoded as:   "MUL<151>-[2]"
     **** ****     > CHAR
0004 047D   6F            byte 'L' ^ RE
                   < elite.a99
1490 047E B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1491                      .char '-'
     **** ****     > CHAR
0004 047F   0E            byte '-' ^ RE
                   < elite.a99
1492                      .rtok 2
     **** ****     > RTOK
0003 0480 81              byte (2 + 160) ^ RE
                   < elite.a99
1493 0481   00            byte >00
1494               
1495 0482 AE              byte 141 ^ RE                                       ; TWOK 'D', 'I' Token 20:     "DICTATORSHIP"
1496                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0483   60            byte 'C' ^ RE
                   < elite.a99
1497                      .char 'T'                                           ; Encoded as:   "<141>CT<145><153>[25]"
     **** ****     > CHAR
0004 0484 77              byte 'T' ^ RE
                   < elite.a99
1498 0485   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1499 0486 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1500                      .rtok 25
     **** ****     > RTOK
0003 0487   9A            byte (25 + 160) ^ RE
                   < elite.a99
1501 0488 00              byte >00
1502               
1503                      .rtok 91                                            ; Token 21:     "COMMUNIST"
     **** ****     > RTOK
0003 0489   D8            byte (91 + 160) ^ RE
                   < elite.a99
1504                      .char 'M'                                           ;
     **** ****     > CHAR
0004 048A 6E              byte 'M' ^ RE
                   < elite.a99
1505                      .char 'U'                                           ; Encoded as:   "[91]MUN<157>T"
     **** ****     > CHAR
0004 048B   76            byte 'U' ^ RE
                   < elite.a99
1506                      .char 'N'
     **** ****     > CHAR
0004 048C 6D              byte 'N' ^ RE
                   < elite.a99
1507 048D   BE            byte 157 ^ RE                                       ; TWOK 'I', 'S' null
1508                      .char 'T'
     **** ****     > CHAR
0004 048E 77              byte 'T' ^ RE
                   < elite.a99
1509 048F   00            byte >00
1510               
1511                      .char 'C'                                           ; Token 22:     "CONFEDERACY"
     **** ****     > CHAR
0004 0490 60              byte 'C' ^ RE
                   < elite.a99
1512 0491   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N'
1513                      .char 'F'                                           ; Encoded as:   "C<159>F<152><144>ACY"
     **** ****     > CHAR
0004 0492 65              byte 'F' ^ RE
                   < elite.a99
1514 0493   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1515 0494 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1516                      .char 'A'
     **** ****     > CHAR
0004 0495   62            byte 'A' ^ RE
                   < elite.a99
1517                      .char 'C'
     **** ****     > CHAR
0004 0496 60              byte 'C' ^ RE
                   < elite.a99
1518                      .char 'Y'
     **** ****     > CHAR
0004 0497   7A            byte 'Y' ^ RE
                   < elite.a99
1519 0498 00              byte >00
1520               
1521                      .char 'D'                                           ; Token 23:     "DEMOCRACY"
     **** ****     > CHAR
0004 0499   67            byte 'D' ^ RE
                   < elite.a99
1522                      .char 'E'                                           ;
     **** ****     > CHAR
0004 049A 66              byte 'E' ^ RE
                   < elite.a99
1523                      .char 'M'                                           ; Encoded as:   "DEMOC<148>CY"
     **** ****     > CHAR
0004 049B   6E            byte 'M' ^ RE
                   < elite.a99
1524                      .char 'O'
     **** ****     > CHAR
0004 049C 6C              byte 'O' ^ RE
                   < elite.a99
1525                      .char 'C'
     **** ****     > CHAR
0004 049D   60            byte 'C' ^ RE
                   < elite.a99
1526 049E B7              byte 148 ^ RE                                       ; TWOK 'R', 'A' null
1527                      .char 'C'
     **** ****     > CHAR
0004 049F   60            byte 'C' ^ RE
                   < elite.a99
1528                      .char 'Y'
     **** ****     > CHAR
0004 04A0 7A              byte 'Y' ^ RE
                   < elite.a99
1529 04A1   00            byte >00
1530               
1531                      .char 'C'                                           ; Token 24:     "CORPORATE STATE"
     **** ****     > CHAR
0004 04A2 60              byte 'C' ^ RE
                   < elite.a99
1532 04A3   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R'
1533                      .char 'P'                                           ; Encoded as:   "C<153>P<153><145>E [43]<145>E"
     **** ****     > CHAR
0004 04A4 73              byte 'P' ^ RE
                   < elite.a99
1534 04A5   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1535 04A6 B2              byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1536                      .char 'E'
     **** ****     > CHAR
0004 04A7   66            byte 'E' ^ RE
                   < elite.a99
1537                      .char ' '
     **** ****     > CHAR
0004 04A8 03              byte ' ' ^ RE
                   < elite.a99
1538                      .rtok 43
     **** ****     > RTOK
0003 04A9   E8            byte (43 + 160) ^ RE
                   < elite.a99
1539 04AA B2              byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1540                      .char 'E'
     **** ****     > CHAR
0004 04AB   66            byte 'E' ^ RE
                   < elite.a99
1541 04AC 00              byte >00
1542               
1543                      .char 'S'                                           ; Token 25:     "SHIP"
     **** ****     > CHAR
0004 04AD   70            byte 'S' ^ RE
                   < elite.a99
1544                      .char 'H'                                           ;
     **** ****     > CHAR
0004 04AE 6B              byte 'H' ^ RE
                   < elite.a99
1545                      .char 'I'                                           ; Encoded as:   "SHIP"
     **** ****     > CHAR
0004 04AF   6A            byte 'I' ^ RE
                   < elite.a99
1546                      .char 'P'
     **** ****     > CHAR
0004 04B0 73              byte 'P' ^ RE
                   < elite.a99
1547 04B1   00            byte >00
1548               
1549                      .char 'P'                                           ; Token 26:     "PRODUCT"
     **** ****     > CHAR
0004 04B2 73              byte 'P' ^ RE
                   < elite.a99
1550                      .char 'R'                                           ;
     **** ****     > CHAR
0004 04B3   71            byte 'R' ^ RE
                   < elite.a99
1551                      .char 'O'                                           ; Encoded as:   "PRODUCT"
     **** ****     > CHAR
0004 04B4 6C              byte 'O' ^ RE
                   < elite.a99
1552                      .char 'D'
     **** ****     > CHAR
0004 04B5   67            byte 'D' ^ RE
                   < elite.a99
1553                      .char 'U'
     **** ****     > CHAR
0004 04B6 76              byte 'U' ^ RE
                   < elite.a99
1554                      .char 'C'
     **** ****     > CHAR
0004 04B7   60            byte 'C' ^ RE
                   < elite.a99
1555                      .char 'T'
     **** ****     > CHAR
0004 04B8 77              byte 'T' ^ RE
                   < elite.a99
1556 04B9   00            byte >00
1557               
1558                      .char ' '                                           ; Token 27:     " LASER"
     **** ****     > CHAR
0004 04BA 03              byte ' ' ^ RE
                   < elite.a99
1559 04BB   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1560                      .char 'S'                                           ; Encoded as:   " <149>S<144>"
     **** ****     > CHAR
0004 04BC 70              byte 'S' ^ RE
                   < elite.a99
1561 04BD   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1562 04BE 00              byte >00
1563               
1564                      .char 'H'                                           ; Token 28:     "HUMAN COLONIAL"
     **** ****     > CHAR
0004 04BF   6B            byte 'H' ^ RE
                   < elite.a99
1565                      .char 'U'                                           ;
     **** ****     > CHAR
0004 04C0 76              byte 'U' ^ RE
                   < elite.a99
1566                      .char 'M'                                           ; Encoded as:   "HUM<155> COL<159>I<128>"
     **** ****     > CHAR
0004 04C1   6E            byte 'M' ^ RE
                   < elite.a99
1567 04C2 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N' null
1568                      .char ' '
     **** ****     > CHAR
0004 04C3   03            byte ' ' ^ RE
                   < elite.a99
1569                      .char 'C'
     **** ****     > CHAR
0004 04C4 60              byte 'C' ^ RE
                   < elite.a99
1570                      .char 'O'
     **** ****     > CHAR
0004 04C5   6C            byte 'O' ^ RE
                   < elite.a99
1571                      .char 'L'
     **** ****     > CHAR
0004 04C6 6F              byte 'L' ^ RE
                   < elite.a99
1572 04C7   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1573                      .char 'I'
     **** ****     > CHAR
0004 04C8 6A              byte 'I' ^ RE
                   < elite.a99
1574 04C9   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1575 04CA 00              byte >00
1576               
1577                      .char 'H'                                           ; Token 29:     "HYPERSPACE "
     **** ****     > CHAR
0004 04CB   6B            byte 'H' ^ RE
                   < elite.a99
1578                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 04CC 7A              byte 'Y' ^ RE
                   < elite.a99
1579                      .char 'P'                                           ; Encoded as:   "HYP<144>SPA<133> "
     **** ****     > CHAR
0004 04CD   73            byte 'P' ^ RE
                   < elite.a99
1580 04CE B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1581                      .char 'S'
     **** ****     > CHAR
0004 04CF   70            byte 'S' ^ RE
                   < elite.a99
1582                      .char 'P'
     **** ****     > CHAR
0004 04D0 73              byte 'P' ^ RE
                   < elite.a99
1583                      .char 'A'
     **** ****     > CHAR
0004 04D1   62            byte 'A' ^ RE
                   < elite.a99
1584 04D2 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1585                      .char ' '
     **** ****     > CHAR
0004 04D3   03            byte ' ' ^ RE
                   < elite.a99
1586 04D4 00              byte >00
1587               
1588                      .char 'S'                                           ; Token 30:     "SHORT RANGE CHART"
     **** ****     > CHAR
0004 04D5   70            byte 'S' ^ RE
                   < elite.a99
1589                      .char 'H'                                           ;
     **** ****     > CHAR
0004 04D6 6B              byte 'H' ^ RE
                   < elite.a99
1590 04D7   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' Encoded as:   "SH<153>T [42][1]"
1591                      .char 'T'
     **** ****     > CHAR
0004 04D8 77              byte 'T' ^ RE
                   < elite.a99
1592                      .char ' '
     **** ****     > CHAR
0004 04D9   03            byte ' ' ^ RE
                   < elite.a99
1593                      .rtok 42
     **** ****     > RTOK
0003 04DA E9              byte (42 + 160) ^ RE
                   < elite.a99
1594                      .rtok 1
     **** ****     > RTOK
0003 04DB   82            byte (1 + 160) ^ RE
                   < elite.a99
1595 04DC 00              byte >00
1596               
1597 04DD   AE            byte 141 ^ RE                                       ; TWOK 'D', 'I' Token 31:     "DISTANCE"
1598                      .rtok 43                                            ;
     **** ****     > RTOK
0003 04DE E8              byte (43 + 160) ^ RE
                   < elite.a99
1599 04DF   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "<141>[43]<155><133>"
1600 04E0 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1601 04E1   00            byte >00
1602               
1603                      .char 'P'                                           ; Token 32:     "POPULATION"
     **** ****     > CHAR
0004 04E2 73              byte 'P' ^ RE
                   < elite.a99
1604                      .char 'O'                                           ;
     **** ****     > CHAR
0004 04E3   6C            byte 'O' ^ RE
                   < elite.a99
1605                      .char 'P'                                           ; Encoded as:   "POPUL<145>I<159>"
     **** ****     > CHAR
0004 04E4 73              byte 'P' ^ RE
                   < elite.a99
1606                      .char 'U'
     **** ****     > CHAR
0004 04E5   76            byte 'U' ^ RE
                   < elite.a99
1607                      .char 'L'
     **** ****     > CHAR
0004 04E6 6F              byte 'L' ^ RE
                   < elite.a99
1608 04E7   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1609                      .char 'I'
     **** ****     > CHAR
0004 04E8 6A              byte 'I' ^ RE
                   < elite.a99
1610 04E9   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1611 04EA 00              byte >00
1612               
1613                      .char 'G'                                           ; Token 33:     "GROSS PRODUCTIVITY"
     **** ****     > CHAR
0004 04EB   64            byte 'G' ^ RE
                   < elite.a99
1614                      .char 'R'                                           ;
     **** ****     > CHAR
0004 04EC 71              byte 'R' ^ RE
                   < elite.a99
1615                      .char 'O'                                           ; Encoded as:   "GROSS [26]IVITY"
     **** ****     > CHAR
0004 04ED   6C            byte 'O' ^ RE
                   < elite.a99
1616                      .char 'S'
     **** ****     > CHAR
0004 04EE 70              byte 'S' ^ RE
                   < elite.a99
1617                      .char 'S'
     **** ****     > CHAR
0004 04EF   70            byte 'S' ^ RE
                   < elite.a99
1618                      .char ' '
     **** ****     > CHAR
0004 04F0 03              byte ' ' ^ RE
                   < elite.a99
1619                      .rtok 26
     **** ****     > RTOK
0003 04F1   99            byte (26 + 160) ^ RE
                   < elite.a99
1620                      .char 'I'
     **** ****     > CHAR
0004 04F2 6A              byte 'I' ^ RE
                   < elite.a99
1621                      .char 'V'
     **** ****     > CHAR
0004 04F3   75            byte 'V' ^ RE
                   < elite.a99
1622                      .char 'I'
     **** ****     > CHAR
0004 04F4 6A              byte 'I' ^ RE
                   < elite.a99
1623                      .char 'T'
     **** ****     > CHAR
0004 04F5   77            byte 'T' ^ RE
                   < elite.a99
1624                      .char 'Y'
     **** ****     > CHAR
0004 04F6 7A              byte 'Y' ^ RE
                   < elite.a99
1625 04F7   00            byte >00
1626               
1627                      .char 'E'                                           ; Token 34:     "ECONOMY"
     **** ****     > CHAR
0004 04F8 66              byte 'E' ^ RE
                   < elite.a99
1628                      .char 'C'                                           ;
     **** ****     > CHAR
0004 04F9   60            byte 'C' ^ RE
                   < elite.a99
1629 04FA BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' Encoded as:   "EC<159>OMY"
1630                      .char 'O'
     **** ****     > CHAR
0004 04FB   6C            byte 'O' ^ RE
                   < elite.a99
1631                      .char 'M'
     **** ****     > CHAR
0004 04FC 6E              byte 'M' ^ RE
                   < elite.a99
1632                      .char 'Y'
     **** ****     > CHAR
0004 04FD   7A            byte 'Y' ^ RE
                   < elite.a99
1633 04FE 00              byte >00
1634               
1635                      .char ' '                                           ; Token 35:     " LIGHT YEARS"
     **** ****     > CHAR
0004 04FF   03            byte ' ' ^ RE
                   < elite.a99
1636                      .char 'L'                                           ;
     **** ****     > CHAR
0004 0500 6F              byte 'L' ^ RE
                   < elite.a99
1637                      .char 'I'                                           ; Encoded as:   " LIGHT YE<138>S"
     **** ****     > CHAR
0004 0501   6A            byte 'I' ^ RE
                   < elite.a99
1638                      .char 'G'
     **** ****     > CHAR
0004 0502 64              byte 'G' ^ RE
                   < elite.a99
1639                      .char 'H'
     **** ****     > CHAR
0004 0503   6B            byte 'H' ^ RE
                   < elite.a99
1640                      .char 'T'
     **** ****     > CHAR
0004 0504 77              byte 'T' ^ RE
                   < elite.a99
1641                      .char ' '
     **** ****     > CHAR
0004 0505   03            byte ' ' ^ RE
                   < elite.a99
1642                      .char 'Y'
     **** ****     > CHAR
0004 0506 7A              byte 'Y' ^ RE
                   < elite.a99
1643                      .char 'E'
     **** ****     > CHAR
0004 0507   66            byte 'E' ^ RE
                   < elite.a99
1644 0508 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1645                      .char 'S'
     **** ****     > CHAR
0004 0509   70            byte 'S' ^ RE
                   < elite.a99
1646 050A 00              byte >00
1647               
1648 050B   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E' Token 36:     "TECH.LEVEL"
1649                      .char 'C'                                           ;
     **** ****     > CHAR
0004 050C 60              byte 'C' ^ RE
                   < elite.a99
1650                      .char 'H'                                           ; Encoded as:   "<156>CH.<129><150>L"
     **** ****     > CHAR
0004 050D   6B            byte 'H' ^ RE
                   < elite.a99
1651                      .char '.'
     **** ****     > CHAR
0004 050E 0D              byte '.' ^ RE
                   < elite.a99
1652 050F   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
1653 0510 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
1654                      .char 'L'
     **** ****     > CHAR
0004 0511   6F            byte 'L' ^ RE
                   < elite.a99
1655 0512 00              byte >00
1656               
1657                      .char 'C'                                           ; Token 37:     "CASH"
     **** ****     > CHAR
0004 0513   60            byte 'C' ^ RE
                   < elite.a99
1658                      .char 'A'                                           ;
     **** ****     > CHAR
0004 0514 62              byte 'A' ^ RE
                   < elite.a99
1659                      .char 'S'                                           ; Encoded as:   "CASH"
     **** ****     > CHAR
0004 0515   70            byte 'S' ^ RE
                   < elite.a99
1660                      .char 'H'
     **** ****     > CHAR
0004 0516 6B              byte 'H' ^ RE
                   < elite.a99
1661 0517   00            byte >00
1662               
1663                      .char ' '                                           ; Token 38:     " BILLION"
     **** ****     > CHAR
0004 0518 03              byte ' ' ^ RE
                   < elite.a99
1664 0519   A5            byte 134 ^ RE                                       ; TWOK 'B', 'I'
1665                      .rtok 118                                           ; Encoded as:   " <134>[118]I<159>"
     **** ****     > RTOK
0008 051A 55              byte 118 ^ RE
                   < elite.a99
1666                      .char 'I'
     **** ****     > CHAR
0004 051B   6A            byte 'I' ^ RE
                   < elite.a99
1667 051C BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1668 051D   00            byte >00
1669               
1670                      .rtok 122                                           ; Token 39:     "GALACTIC CHART{galaxy number}"
     **** ****     > RTOK
0008 051E 59              byte 122 ^ RE
                   < elite.a99
1671                      .rtok 1                                             ;
     **** ****     > RTOK
0003 051F   82            byte (1 + 160) ^ RE
                   < elite.a99
1672                      .cont 1                                             ; Encoded as:   "[122][1]{1}"
     **** ****     > CONT
0001 0520 22              byte 1 ^ RE
                   < elite.a99
1673 0521   00            byte >00
1674               
1675                      .char 'T'                                           ; Token 40:     "TARGET LOST"
     **** ****     > CHAR
0004 0522 77              byte 'T' ^ RE
                   < elite.a99
1676 0523   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R'
1677 0524 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "T<138><131>T LO[43]"
1678                      .char 'T'
     **** ****     > CHAR
0004 0525   77            byte 'T' ^ RE
                   < elite.a99
1679                      .char ' '
     **** ****     > CHAR
0004 0526 03              byte ' ' ^ RE
                   < elite.a99
1680                      .char 'L'
     **** ****     > CHAR
0004 0527   6F            byte 'L' ^ RE
                   < elite.a99
1681                      .char 'O'
     **** ****     > CHAR
0004 0528 6C              byte 'O' ^ RE
                   < elite.a99
1682                      .rtok 43
     **** ****     > RTOK
0003 0529   E8            byte (43 + 160) ^ RE
                   < elite.a99
1683 052A 00              byte >00
1684               
1685                      .rtok 106                                           ; Token 41:     "MISSILE JAMMED"
     **** ****     > RTOK
0008 052B   49            byte 106 ^ RE
                   < elite.a99
1686                      .char ' '                                           ;
     **** ****     > CHAR
0004 052C 03              byte ' ' ^ RE
                   < elite.a99
1687                      .char 'J'                                           ; Encoded as:   "[106] JAMM<152>"
     **** ****     > CHAR
0004 052D   69            byte 'J' ^ RE
                   < elite.a99
1688                      .char 'A'
     **** ****     > CHAR
0004 052E 62              byte 'A' ^ RE
                   < elite.a99
1689                      .char 'M'
     **** ****     > CHAR
0004 052F   6E            byte 'M' ^ RE
                   < elite.a99
1690                      .char 'M'
     **** ****     > CHAR
0004 0530 6E              byte 'M' ^ RE
                   < elite.a99
1691 0531   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1692 0532 00              byte >00
1693               
1694                      .char 'R'                                           ; Token 42:     "RANGE"
     **** ****     > CHAR
0004 0533   71            byte 'R' ^ RE
                   < elite.a99
1695 0534 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
1696 0535   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "R<155><131>"
1697 0536 00              byte >00
1698               
1699                      .char 'S'                                           ; Token 43:     "ST"
     **** ****     > CHAR
0004 0537   70            byte 'S' ^ RE
                   < elite.a99
1700                      .char 'T'                                           ;
     **** ****     > CHAR
0004 0538 77              byte 'T' ^ RE
                   < elite.a99
1701 0539   00            byte >00                                            ; Encoded as:   "ST"
1702               
1703                      .rtok 16                                            ; Token 44:     "QUANTITY OF "
     **** ****     > RTOK
0003 053A 93              byte (16 + 160) ^ RE
                   < elite.a99
1704                      .char ' '                                           ;
     **** ****     > CHAR
0004 053B   03            byte ' ' ^ RE
                   < elite.a99
1705                      .char 'O'                                           ; Encoded as:   "[16] OF "
     **** ****     > CHAR
0004 053C 6C              byte 'O' ^ RE
                   < elite.a99
1706                      .char 'F'
     **** ****     > CHAR
0004 053D   65            byte 'F' ^ RE
                   < elite.a99
1707                      .char ' '
     **** ****     > CHAR
0004 053E 03              byte ' ' ^ RE
                   < elite.a99
1708 053F   00            byte >00
1709               
1710                      .char 'S'                                           ; Token 45:     "SELL"
     **** ****     > CHAR
0004 0540 70              byte 'S' ^ RE
                   < elite.a99
1711                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0541   66            byte 'E' ^ RE
                   < elite.a99
1712                      .rtok 118                                           ; Encoded as:   "SE[118]"
     **** ****     > RTOK
0008 0542 55              byte 118 ^ RE
                   < elite.a99
1713 0543   00            byte >00
1714               
1715                      .char ' '                                           ; Token 46:     " CARGO{sentence case}"
     **** ****     > CHAR
0004 0544 03              byte ' ' ^ RE
                   < elite.a99
1716                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0545   60            byte 'C' ^ RE
                   < elite.a99
1717 0546 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R' Encoded as:   " C<138>GO{6}"
1718                      .char 'G'
     **** ****     > CHAR
0004 0547   64            byte 'G' ^ RE
                   < elite.a99
1719                      .char 'O'
     **** ****     > CHAR
0004 0548 6C              byte 'O' ^ RE
                   < elite.a99
1720                      .cont 6
     **** ****     > CONT
0001 0549   25            byte 6 ^ RE
                   < elite.a99
1721 054A 00              byte >00
1722               
1723                      .char 'E'                                           ; Token 47:     "EQUIP"
     **** ****     > CHAR
0004 054B   66            byte 'E' ^ RE
                   < elite.a99
1724 054C B9              byte 154 ^ RE                                       ; TWOK 'Q', 'U'
1725                      .char 'I'                                           ; Encoded as:   "E<154>IP"
     **** ****     > CHAR
0004 054D   6A            byte 'I' ^ RE
                   < elite.a99
1726                      .char 'P'
     **** ****     > CHAR
0004 054E 73              byte 'P' ^ RE
                   < elite.a99
1727 054F   00            byte >00
1728               
1729                      .char 'F'                                           ; Token 48:     "FOOD"
     **** ****     > CHAR
0004 0550 65              byte 'F' ^ RE
                   < elite.a99
1730                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0551   6C            byte 'O' ^ RE
                   < elite.a99
1731                      .char 'O'                                           ; Encoded as:   "FOOD"
     **** ****     > CHAR
0004 0552 6C              byte 'O' ^ RE
                   < elite.a99
1732                      .char 'D'
     **** ****     > CHAR
0004 0553   67            byte 'D' ^ RE
                   < elite.a99
1733 0554 00              byte >00
1734               
1735 0555   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E' Token 49:     "TEXTILES"
1736                      .char 'X'                                           ;
     **** ****     > CHAR
0004 0556 7B              byte 'X' ^ RE
                   < elite.a99
1737 0557   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' Encoded as:   "<156>X<151>L<137>"
1738                      .char 'L'
     **** ****     > CHAR
0004 0558 6F              byte 'L' ^ RE
                   < elite.a99
1739 0559   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1740 055A 00              byte >00
1741               
1742 055B   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Token 50:     "RADIOACTIVES"
1743 055C AE              byte 141 ^ RE                                       ; TWOK 'D', 'I'
1744                      .char 'O'                                           ; Encoded as:   "<148><141>OAC<151><150>S"
     **** ****     > CHAR
0004 055D   6C            byte 'O' ^ RE
                   < elite.a99
1745                      .char 'A'
     **** ****     > CHAR
0004 055E 62              byte 'A' ^ RE
                   < elite.a99
1746                      .char 'C'
     **** ****     > CHAR
0004 055F   60            byte 'C' ^ RE
                   < elite.a99
1747 0560 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1748 0561   B5            byte 150 ^ RE                                       ; TWOK 'V', 'E' null
1749                      .char 'S'
     **** ****     > CHAR
0004 0562 70              byte 'S' ^ RE
                   < elite.a99
1750 0563   00            byte >00
1751               
1752                      .char 'S'                                           ; Token 51:     "SLAVES"
     **** ****     > CHAR
0004 0564 70              byte 'S' ^ RE
                   < elite.a99
1753 0565   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1754 0566 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' Encoded as:   "S<149><150>S"
1755                      .char 'S'
     **** ****     > CHAR
0004 0567   70            byte 'S' ^ RE
                   < elite.a99
1756 0568 00              byte >00
1757               
1758                      .char 'L'                                           ; Token 52:     "LIQUOR/WINES"
     **** ****     > CHAR
0004 0569   6F            byte 'L' ^ RE
                   < elite.a99
1759                      .char 'I'                                           ;
     **** ****     > CHAR
0004 056A 6A              byte 'I' ^ RE
                   < elite.a99
1760 056B   B9            byte 154 ^ RE                                       ; TWOK 'Q', 'U' Encoded as:   "LI<154><153>/W<140><137>"
1761 056C BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1762                      .char '/'
     **** ****     > CHAR
0004 056D   0C            byte '/' ^ RE
                   < elite.a99
1763                      .char 'W'
     **** ****     > CHAR
0004 056E 74              byte 'W' ^ RE
                   < elite.a99
1764 056F   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1765 0570 AA              byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1766 0571   00            byte >00
1767               
1768                      .char 'L'                                           ; Token 53:     "LUXURIES"
     **** ****     > CHAR
0004 0572 6F              byte 'L' ^ RE
                   < elite.a99
1769                      .char 'U'                                           ;
     **** ****     > CHAR
0004 0573   76            byte 'U' ^ RE
                   < elite.a99
1770                      .char 'X'                                           ; Encoded as:   "LUXU<158><137>"
     **** ****     > CHAR
0004 0574 7B              byte 'X' ^ RE
                   < elite.a99
1771                      .char 'U'
     **** ****     > CHAR
0004 0575   76            byte 'U' ^ RE
                   < elite.a99
1772 0576 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' null
1773 0577   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1774 0578 00              byte >00
1775               
1776                      .char 'N'                                           ; Token 54:     "NARCOTICS"
     **** ****     > CHAR
0004 0579   6D            byte 'N' ^ RE
                   < elite.a99
1777 057A A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1778                      .char 'C'                                           ; Encoded as:   "N<138>CO<151>CS"
     **** ****     > CHAR
0004 057B   60            byte 'C' ^ RE
                   < elite.a99
1779                      .char 'O'
     **** ****     > CHAR
0004 057C 6C              byte 'O' ^ RE
                   < elite.a99
1780 057D   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1781                      .char 'C'
     **** ****     > CHAR
0004 057E 60              byte 'C' ^ RE
                   < elite.a99
1782                      .char 'S'
     **** ****     > CHAR
0004 057F   70            byte 'S' ^ RE
                   < elite.a99
1783 0580 00              byte >00
1784               
1785                      .rtok 91                                            ; Token 55:     "COMPUTERS"
     **** ****     > RTOK
0003 0581   D8            byte (91 + 160) ^ RE
                   < elite.a99
1786                      .char 'P'                                           ;
     **** ****     > CHAR
0004 0582 73              byte 'P' ^ RE
                   < elite.a99
1787                      .char 'U'                                           ; Encoded as:   "[91]PUT<144>S"
     **** ****     > CHAR
0004 0583   76            byte 'U' ^ RE
                   < elite.a99
1788                      .char 'T'
     **** ****     > CHAR
0004 0584 77              byte 'T' ^ RE
                   < elite.a99
1789 0585   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1790                      .char 'S'
     **** ****     > CHAR
0004 0586 70              byte 'S' ^ RE
                   < elite.a99
1791 0587   00            byte >00
1792               
1793 0588 A8              byte 139 ^ RE                                       ; TWOK 'M', 'A' Token 56:     "MACHINERY"
1794                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0589   60            byte 'C' ^ RE
                   < elite.a99
1795                      .char 'H'                                           ; Encoded as:   "<139>CH<140><144>Y"
     **** ****     > CHAR
0004 058A 6B              byte 'H' ^ RE
                   < elite.a99
1796 058B   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1797 058C B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1798                      .char 'Y'
     **** ****     > CHAR
0004 058D   7A            byte 'Y' ^ RE
                   < elite.a99
1799 058E 00              byte >00
1800               
1801                      .rtok 117                                           ; Token 57:     "ALLOYS"
     **** ****     > RTOK
0008 058F   56            byte 117 ^ RE
                   < elite.a99
1802                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0590 6C              byte 'O' ^ RE
                   < elite.a99
1803                      .char 'Y'                                           ; Encoded as:   "[117]OYS"
     **** ****     > CHAR
0004 0591   7A            byte 'Y' ^ RE
                   < elite.a99
1804                      .char 'S'
     **** ****     > CHAR
0004 0592 70              byte 'S' ^ RE
                   < elite.a99
1805 0593   00            byte >00
1806               
1807                      .char 'F'                                           ; Token 58:     "FIREARMS"
     **** ****     > CHAR
0004 0594 65              byte 'F' ^ RE
                   < elite.a99
1808                      .char 'I'                                           ;
     **** ****     > CHAR
0004 0595   6A            byte 'I' ^ RE
                   < elite.a99
1809 0596 AD              byte 142 ^ RE                                       ; TWOK 'R', 'E' Encoded as:   "FI<142><138>MS"
1810 0597   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1811                      .char 'M'
     **** ****     > CHAR
0004 0598 6E              byte 'M' ^ RE
                   < elite.a99
1812                      .char 'S'
     **** ****     > CHAR
0004 0599   70            byte 'S' ^ RE
                   < elite.a99
1813 059A 00              byte >00
1814               
1815                      .char 'F'                                           ; Token 59:     "FURS"
     **** ****     > CHAR
0004 059B   65            byte 'F' ^ RE
                   < elite.a99
1816                      .char 'U'                                           ;
     **** ****     > CHAR
0004 059C 76              byte 'U' ^ RE
                   < elite.a99
1817                      .char 'R'                                           ; Encoded as:   "FURS"
     **** ****     > CHAR
0004 059D   71            byte 'R' ^ RE
                   < elite.a99
1818                      .char 'S'
     **** ****     > CHAR
0004 059E 70              byte 'S' ^ RE
                   < elite.a99
1819 059F   00            byte >00
1820               
1821                      .char 'M'                                           ; Token 60:     "MINERALS"
     **** ****     > CHAR
0004 05A0 6E              byte 'M' ^ RE
                   < elite.a99
1822 05A1   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
1823 05A2 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' Encoded as:   "M<140><144><128>S"
1824 05A3   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1825                      .char 'S'
     **** ****     > CHAR
0004 05A4 70              byte 'S' ^ RE
                   < elite.a99
1826 05A5   00            byte >00
1827               
1828                      .char 'G'                                           ; Token 61:     "GOLD"
     **** ****     > CHAR
0004 05A6 64              byte 'G' ^ RE
                   < elite.a99
1829                      .char 'O'                                           ;
     **** ****     > CHAR
0004 05A7   6C            byte 'O' ^ RE
                   < elite.a99
1830                      .char 'L'                                           ; Encoded as:   "GOLD"
     **** ****     > CHAR
0004 05A8 6F              byte 'L' ^ RE
                   < elite.a99
1831                      .char 'D'
     **** ****     > CHAR
0004 05A9   67            byte 'D' ^ RE
                   < elite.a99
1832 05AA 00              byte >00
1833               
1834                      .char 'P'                                           ; Token 62:     "PLATINUM"
     **** ****     > CHAR
0004 05AB   73            byte 'P' ^ RE
                   < elite.a99
1835                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05AC 6F              byte 'L' ^ RE
                   < elite.a99
1836 05AD   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' Encoded as:   "PL<145><140>UM"
1837 05AE AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1838                      .char 'U'
     **** ****     > CHAR
0004 05AF   76            byte 'U' ^ RE
                   < elite.a99
1839                      .char 'M'
     **** ****     > CHAR
0004 05B0 6E              byte 'M' ^ RE
                   < elite.a99
1840 05B1   00            byte >00
1841               
1842 05B2 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' Token 63:     "GEM-STONES"
1843                      .char 'M'                                           ;
     **** ****     > CHAR
0004 05B3   6E            byte 'M' ^ RE
                   < elite.a99
1844                      .char '-'                                           ; Encoded as:   "<131>M-[43]<159><137>"
     **** ****     > CHAR
0004 05B4 0E              byte '-' ^ RE
                   < elite.a99
1845                      .rtok 43
     **** ****     > RTOK
0003 05B5   E8            byte (43 + 160) ^ RE
                   < elite.a99
1846 05B6 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1847 05B7   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1848 05B8 00              byte >00
1849               
1850 05B9   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' Token 64:     "ALIEN ITEMS"
1851                      .char 'I'                                           ;
     **** ****     > CHAR
0004 05BA 6A              byte 'I' ^ RE
                   < elite.a99
1852 05BB   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' Encoded as:   "<128>I<146> [127]S"
1853                      .char ' '
     **** ****     > CHAR
0004 05BC 03              byte ' ' ^ RE
                   < elite.a99
1854                      .rtok 127
     **** ****     > RTOK
0008 05BD   5C            byte 127 ^ RE
                   < elite.a99
1855                      .char 'S'
     **** ****     > CHAR
0004 05BE 70              byte 'S' ^ RE
                   < elite.a99
1856 05BF   00            byte >00
1857               
1858                      .char '('                                           ; Token 65:     "(Y/N)?"
     **** ****     > CHAR
0004 05C0 0B              byte '(' ^ RE
                   < elite.a99
1859                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 05C1   7A            byte 'Y' ^ RE
                   < elite.a99
1860                      .char '/'                                           ; Encoded as:   "(Y/N)?"
     **** ****     > CHAR
0004 05C2 0C              byte '/' ^ RE
                   < elite.a99
1861                      .char 'N'
     **** ****     > CHAR
0004 05C3   6D            byte 'N' ^ RE
                   < elite.a99
1862                      .char ')'
     **** ****     > CHAR
0004 05C4 0A              byte ')' ^ RE
                   < elite.a99
1863                      .char '?'
     **** ****     > CHAR
0004 05C5   1C            byte '?' ^ RE
                   < elite.a99
1864 05C6 00              byte >00
1865               
1866                      .char ' '                                           ; Token 66:     " CR"
     **** ****     > CHAR
0004 05C7   03            byte ' ' ^ RE
                   < elite.a99
1867                      .char 'C'                                           ;
     **** ****     > CHAR
0004 05C8 60              byte 'C' ^ RE
                   < elite.a99
1868                      .char 'R'                                           ; Encoded as:   " CR"
     **** ****     > CHAR
0004 05C9   71            byte 'R' ^ RE
                   < elite.a99
1869 05CA 00              byte >00
1870               
1871                      .char 'L'                                           ; Token 67:     "LARGE"
     **** ****     > CHAR
0004 05CB   6F            byte 'L' ^ RE
                   < elite.a99
1872 05CC A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1873 05CD   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "L<138><131>"
1874 05CE 00              byte >00
1875               
1876                      .char 'F'                                           ; Token 68:     "FIERCE"
     **** ****     > CHAR
0004 05CF   65            byte 'F' ^ RE
                   < elite.a99
1877                      .char 'I'                                           ;
     **** ****     > CHAR
0004 05D0 6A              byte 'I' ^ RE
                   < elite.a99
1878 05D1   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' Encoded as:   "FI<144><133>"
1879 05D2 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1880 05D3   00            byte >00
1881               
1882                      .char 'S'                                           ; Token 69:     "SMALL"
     **** ****     > CHAR
0004 05D4 70              byte 'S' ^ RE
                   < elite.a99
1883 05D5   A8            byte 139 ^ RE                                       ; TWOK 'M', 'A'
1884                      .rtok 118                                           ; Encoded as:   "S<139>[118]"
     **** ****     > RTOK
0008 05D6 55              byte 118 ^ RE
                   < elite.a99
1885 05D7   00            byte >00
1886               
1887                      .char 'G'                                           ; Token 70:     "GREEN"
     **** ****     > CHAR
0004 05D8 64              byte 'G' ^ RE
                   < elite.a99
1888 05D9   AD            byte 142 ^ RE                                       ; TWOK 'R', 'E'
1889 05DA B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' Encoded as:   "G<142><146>"
1890 05DB   00            byte >00
1891               
1892                      .char 'R'                                           ; Token 71:     "RED"
     **** ****     > CHAR
0004 05DC 71              byte 'R' ^ RE
                   < elite.a99
1893 05DD   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D'
1894 05DE 00              byte >00                                            ; Encoded as:   "R<152>"
1895               
1896                      .char 'Y'                                           ; Token 72:     "YELLOW"
     **** ****     > CHAR
0004 05DF   7A            byte 'Y' ^ RE
                   < elite.a99
1897                      .char 'E'                                           ;
     **** ****     > CHAR
0004 05E0 66              byte 'E' ^ RE
                   < elite.a99
1898                      .rtok 118                                           ; Encoded as:   "YE[118]OW"
     **** ****     > RTOK
0008 05E1   55            byte 118 ^ RE
                   < elite.a99
1899                      .char 'O'
     **** ****     > CHAR
0004 05E2 6C              byte 'O' ^ RE
                   < elite.a99
1900                      .char 'W'
     **** ****     > CHAR
0004 05E3   74            byte 'W' ^ RE
                   < elite.a99
1901 05E4 00              byte >00
1902               
1903                      .char 'B'                                           ; Token 73:     "BLUE"
     **** ****     > CHAR
0004 05E5   61            byte 'B' ^ RE
                   < elite.a99
1904                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05E6 6F              byte 'L' ^ RE
                   < elite.a99
1905                      .char 'U'                                           ; Encoded as:   "BLUE"
     **** ****     > CHAR
0004 05E7   76            byte 'U' ^ RE
                   < elite.a99
1906                      .char 'E'
     **** ****     > CHAR
0004 05E8 66              byte 'E' ^ RE
                   < elite.a99
1907 05E9   00            byte >00
1908               
1909                      .char 'B'                                           ; Token 74:     "BLACK"
     **** ****     > CHAR
0004 05EA 61              byte 'B' ^ RE
                   < elite.a99
1910 05EB   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1911                      .char 'C'                                           ; Encoded as:   "B<149>CK"
     **** ****     > CHAR
0004 05EC 60              byte 'C' ^ RE
                   < elite.a99
1912                      .char 'K'
     **** ****     > CHAR
0004 05ED   68            byte 'K' ^ RE
                   < elite.a99
1913 05EE 00              byte >00
1914               
1915                      .rtok 136                                           ; Token 75:     "HARMLESS"
     **** ****     > RTOK
0006 05EF   35            byte (136 - 114) ^ RE
                   < elite.a99
1916 05F0 00              byte >00                                            ;
1917                                                                          ; Encoded as:   "[136]"
1918               
1919                      .char 'S'                                           ; Token 76:     "SLIMY"
     **** ****     > CHAR
0004 05F1   70            byte 'S' ^ RE
                   < elite.a99
1920                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05F2 6F              byte 'L' ^ RE
                   < elite.a99
1921                      .char 'I'                                           ; Encoded as:   "SLIMY"
     **** ****     > CHAR
0004 05F3   6A            byte 'I' ^ RE
                   < elite.a99
1922                      .char 'M'
     **** ****     > CHAR
0004 05F4 6E              byte 'M' ^ RE
                   < elite.a99
1923                      .char 'Y'
     **** ****     > CHAR
0004 05F5   7A            byte 'Y' ^ RE
                   < elite.a99
1924 05F6 00              byte >00
1925               
1926                      .char 'B'                                           ; Token 77:     "BUG-EYED"
     **** ****     > CHAR
0004 05F7   61            byte 'B' ^ RE
                   < elite.a99
1927                      .char 'U'                                           ;
     **** ****     > CHAR
0004 05F8 76              byte 'U' ^ RE
                   < elite.a99
1928                      .char 'G'                                           ; Encoded as:   "BUG-EY<152>"
     **** ****     > CHAR
0004 05F9   64            byte 'G' ^ RE
                   < elite.a99
1929                      .char '-'
     **** ****     > CHAR
0004 05FA 0E              byte '-' ^ RE
                   < elite.a99
1930                      .char 'E'
     **** ****     > CHAR
0004 05FB   66            byte 'E' ^ RE
                   < elite.a99
1931                      .char 'Y'
     **** ****     > CHAR
0004 05FC 7A              byte 'Y' ^ RE
                   < elite.a99
1932 05FD   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1933 05FE 00              byte >00
1934               
1935                      .char 'H'                                           ; Token 78:     "HORNED"
     **** ****     > CHAR
0004 05FF   6B            byte 'H' ^ RE
                   < elite.a99
1936 0600 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R'
1937                      .char 'N'                                           ; Encoded as:   "H<153>N<152>"
     **** ****     > CHAR
0004 0601   6D            byte 'N' ^ RE
                   < elite.a99
1938 0602 BB              byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1939 0603   00            byte >00
1940               
1941                      .char 'B'                                           ; Token 79:     "BONY"
     **** ****     > CHAR
0004 0604 61              byte 'B' ^ RE
                   < elite.a99
1942 0605   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N'
1943                      .char 'Y'                                           ; Encoded as:   "B<159>Y"
     **** ****     > CHAR
0004 0606 7A              byte 'Y' ^ RE
                   < elite.a99
1944 0607   00            byte >00
1945               
1946                      .char 'F'                                           ; Token 80:     "FAT"
     **** ****     > CHAR
0004 0608 65              byte 'F' ^ RE
                   < elite.a99
1947 0609   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T'
1948 060A 00              byte >00                                            ; Encoded as:   "F<145>"
1949               
1950                      .char 'F'                                           ; Token 81:     "FURRY"
     **** ****     > CHAR
0004 060B   65            byte 'F' ^ RE
                   < elite.a99
1951                      .char 'U'                                           ;
     **** ****     > CHAR
0004 060C 76              byte 'U' ^ RE
                   < elite.a99
1952                      .char 'R'                                           ; Encoded as:   "FURRY"
     **** ****     > CHAR
0004 060D   71            byte 'R' ^ RE
                   < elite.a99
1953                      .char 'R'
     **** ****     > CHAR
0004 060E 71              byte 'R' ^ RE
                   < elite.a99
1954                      .char 'Y'
     **** ****     > CHAR
0004 060F   7A            byte 'Y' ^ RE
                   < elite.a99
1955 0610 00              byte >00
1956               
1957                      .char 'R'                                           ; Token 82:     "RODENT"
     **** ****     > CHAR
0004 0611   71            byte 'R' ^ RE
                   < elite.a99
1958                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0612 6C              byte 'O' ^ RE
                   < elite.a99
1959                      .char 'D'                                           ; Encoded as:   "ROD<146>T"
     **** ****     > CHAR
0004 0613   67            byte 'D' ^ RE
                   < elite.a99
1960 0614 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
1961                      .char 'T'
     **** ****     > CHAR
0004 0615   77            byte 'T' ^ RE
                   < elite.a99
1962 0616 00              byte >00
1963               
1964                      .char 'F'                                           ; Token 83:     "FROG"
     **** ****     > CHAR
0004 0617   65            byte 'F' ^ RE
                   < elite.a99
1965                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0618 71              byte 'R' ^ RE
                   < elite.a99
1966                      .char 'O'                                           ; Encoded as:   "FROG"
     **** ****     > CHAR
0004 0619   6C            byte 'O' ^ RE
                   < elite.a99
1967                      .char 'G'
     **** ****     > CHAR
0004 061A 64              byte 'G' ^ RE
                   < elite.a99
1968 061B   00            byte >00
1969               
1970                      .char 'L'                                           ; Token 84:     "LIZARD"
     **** ****     > CHAR
0004 061C 6F              byte 'L' ^ RE
                   < elite.a99
1971                      .char 'I'                                           ;
     **** ****     > CHAR
0004 061D   6A            byte 'I' ^ RE
                   < elite.a99
1972 061E A7              byte 132 ^ RE                                       ; TWOK 'Z', 'A' Encoded as:   "LI<132>RD"
1973                      .char 'R'
     **** ****     > CHAR
0004 061F   71            byte 'R' ^ RE
                   < elite.a99
1974                      .char 'D'
     **** ****     > CHAR
0004 0620 67              byte 'D' ^ RE
                   < elite.a99
1975 0621   00            byte >00
1976               
1977                      .char 'L'                                           ; Token 85:     "LOBSTER"
     **** ****     > CHAR
0004 0622 6F              byte 'L' ^ RE
                   < elite.a99
1978                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0623   6C            byte 'O' ^ RE
                   < elite.a99
1979                      .char 'B'                                           ; Encoded as:   "LOB[43]<144>"
     **** ****     > CHAR
0004 0624 61              byte 'B' ^ RE
                   < elite.a99
1980                      .rtok 43
     **** ****     > RTOK
0003 0625   E8            byte (43 + 160) ^ RE
                   < elite.a99
1981 0626 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1982 0627   00            byte >00
1983               
1984 0628 A5              byte 134 ^ RE                                       ; TWOK 'B', 'I' Token 86:     "BIRD"
1985                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0629   71            byte 'R' ^ RE
                   < elite.a99
1986                      .char 'D'                                           ; Encoded as:   "<134>RD"
     **** ****     > CHAR
0004 062A 67              byte 'D' ^ RE
                   < elite.a99
1987 062B   00            byte >00
1988               
1989                      .char 'H'                                           ; Token 87:     "HUMANOID"
     **** ****     > CHAR
0004 062C 6B              byte 'H' ^ RE
                   < elite.a99
1990                      .char 'U'                                           ;
     **** ****     > CHAR
0004 062D   76            byte 'U' ^ RE
                   < elite.a99
1991                      .char 'M'                                           ; Encoded as:   "HUM<155>OID"
     **** ****     > CHAR
0004 062E 6E              byte 'M' ^ RE
                   < elite.a99
1992 062F   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' null
1993                      .char 'O'
     **** ****     > CHAR
0004 0630 6C              byte 'O' ^ RE
                   < elite.a99
1994                      .char 'I'
     **** ****     > CHAR
0004 0631   6A            byte 'I' ^ RE
                   < elite.a99
1995                      .char 'D'
     **** ****     > CHAR
0004 0632 67              byte 'D' ^ RE
                   < elite.a99
1996 0633   00            byte >00
1997               
1998                      .char 'F'                                           ; Token 88:     "FELINE"
     **** ****     > CHAR
0004 0634 65              byte 'F' ^ RE
                   < elite.a99
1999                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0635   66            byte 'E' ^ RE
                   < elite.a99
2000                      .char 'L'                                           ; Encoded as:   "FEL<140>E"
     **** ****     > CHAR
0004 0636 6F              byte 'L' ^ RE
                   < elite.a99
2001 0637   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
2002                      .char 'E'
     **** ****     > CHAR
0004 0638 66              byte 'E' ^ RE
                   < elite.a99
2003 0639   00            byte >00
2004               
2005 063A AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 89:     "INSECT"
2006                      .char 'S'                                           ;
     **** ****     > CHAR
0004 063B   70            byte 'S' ^ RE
                   < elite.a99
2007                      .char 'E'                                           ; Encoded as:   "<140>SECT"
     **** ****     > CHAR
0004 063C 66              byte 'E' ^ RE
                   < elite.a99
2008                      .char 'C'
     **** ****     > CHAR
0004 063D   60            byte 'C' ^ RE
                   < elite.a99
2009                      .char 'T'
     **** ****     > CHAR
0004 063E 77              byte 'T' ^ RE
                   < elite.a99
2010 063F   00            byte >00
2011               
2012                      .rtok 11                                            ; Token 90:     "AVERAGE RADIUS"
     **** ****     > RTOK
0003 0640 88              byte (11 + 160) ^ RE
                   < elite.a99
2013 0641   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A'
2014 0642 AE              byte 141 ^ RE                                       ; TWOK 'D', 'I' Encoded as:   "[11]<148><141><136>"
2015 0643   AB            byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2016 0644 00              byte >00
2017               
2018                      .char 'C'                                           ; Token 91:     "COM"
     **** ****     > CHAR
0004 0645   60            byte 'C' ^ RE
                   < elite.a99
2019                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0646 6C              byte 'O' ^ RE
                   < elite.a99
2020                      .char 'M'                                           ; Encoded as:   "COM"
     **** ****     > CHAR
0004 0647   6E            byte 'M' ^ RE
                   < elite.a99
2021 0648 00              byte >00
2022               
2023                      .rtok 91                                            ; Token 92:     "COMMANDER"
     **** ****     > RTOK
0003 0649   D8            byte (91 + 160) ^ RE
                   < elite.a99
2024                      .char 'M'                                           ;
     **** ****     > CHAR
0004 064A 6E              byte 'M' ^ RE
                   < elite.a99
2025 064B   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "[91]M<155>D<144>"
2026                      .char 'D'
     **** ****     > CHAR
0004 064C 67              byte 'D' ^ RE
                   < elite.a99
2027 064D   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
2028 064E 00              byte >00
2029               
2030                      .char ' '                                           ; Token 93:     " DESTROYED"
     **** ****     > CHAR
0004 064F   03            byte ' ' ^ RE
                   < elite.a99
2031                      .char 'D'                                           ;
     **** ****     > CHAR
0004 0650 67              byte 'D' ^ RE
                   < elite.a99
2032 0651   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' Encoded as:   " D<137>TROY<152>"
2033                      .char 'T'
     **** ****     > CHAR
0004 0652 77              byte 'T' ^ RE
                   < elite.a99
2034                      .char 'R'
     **** ****     > CHAR
0004 0653   71            byte 'R' ^ RE
                   < elite.a99
2035                      .char 'O'
     **** ****     > CHAR
0004 0654 6C              byte 'O' ^ RE
                   < elite.a99
2036                      .char 'Y'
     **** ****     > CHAR
0004 0655   7A            byte 'Y' ^ RE
                   < elite.a99
2037 0656 BB              byte 152 ^ RE                                       ; TWOK 'E', 'D' null
2038 0657   00            byte >00
2039               
2040                      .char 'B'                                           ; Token 94:     "BY D.BRABEN & I.BELL"
     **** ****     > CHAR
0004 0658 61              byte 'B' ^ RE
                   < elite.a99
2041                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 0659   7A            byte 'Y' ^ RE
                   < elite.a99
2042                      .char ' '                                           ; Encoded as:   "BY D.B<148><147>N & I.<147>[118]"
     **** ****     > CHAR
0004 065A 03              byte ' ' ^ RE
                   < elite.a99
2043                      .char 'D'
     **** ****     > CHAR
0004 065B   67            byte 'D' ^ RE
                   < elite.a99
2044                      .char '.'
     **** ****     > CHAR
0004 065C 0D              byte '.' ^ RE
                   < elite.a99
2045                      .char 'B'
     **** ****     > CHAR
0004 065D   61            byte 'B' ^ RE
                   < elite.a99
2046 065E B7              byte 148 ^ RE                                       ; TWOK 'R', 'A' null
2047 065F   B0            byte 147 ^ RE                                       ; TWOK 'B', 'E' null
2048                      .char 'N'
     **** ****     > CHAR
0004 0660 6D              byte 'N' ^ RE
                   < elite.a99
2049                      .char ' '
     **** ****     > CHAR
0004 0661   03            byte ' ' ^ RE
                   < elite.a99
2050                      .char '&'
     **** ****     > CHAR
0004 0662 05              byte '&' ^ RE
                   < elite.a99
2051                      .char ' '
     **** ****     > CHAR
0004 0663   03            byte ' ' ^ RE
                   < elite.a99
2052                      .char 'I'
     **** ****     > CHAR
0004 0664 6A              byte 'I' ^ RE
                   < elite.a99
2053                      .char '.'
     **** ****     > CHAR
0004 0665   0D            byte '.' ^ RE
                   < elite.a99
2054 0666 B0              byte 147 ^ RE                                       ; TWOK 'B', 'E' null
2055                      .rtok 118
     **** ****     > RTOK
0008 0667   55            byte 118 ^ RE
                   < elite.a99
2056 0668 00              byte >00
2057               
2058                      .rtok 14                                            ; Token 95:     "UNIT  QUANTITY{crlf}
     **** ****     > RTOK
0003 0669   8D            byte (14 + 160) ^ RE
                   < elite.a99
2059                      .char ' '                                           ; PRODUCT   UNIT PRICE FOR SALE{crlf}
     **** ****     > CHAR
0004 066A 03              byte ' ' ^ RE
                   < elite.a99
2060                      .char ' '                                           ; {lf}"
     **** ****     > CHAR
0004 066B   03            byte ' ' ^ RE
                   < elite.a99
2061                      .rtok 16                                            ;
     **** ****     > RTOK
0003 066C 93              byte (16 + 160) ^ RE
                   < elite.a99
2062                      .cont 13                                            ; Encoded as:   "[14]  [16]{13} [26]   [14] [6] F<153>
     **** ****     > CONT
0001 066D   2E            byte 13 ^ RE
                   < elite.a99
2063                      .char ' '                                           ; SA<129>{13}{10}"
     **** ****     > CHAR
0004 066E 03              byte ' ' ^ RE
                   < elite.a99
2064                      .rtok 26
     **** ****     > RTOK
0003 066F   99            byte (26 + 160) ^ RE
                   < elite.a99
2065                      .char ' '
     **** ****     > CHAR
0004 0670 03              byte ' ' ^ RE
                   < elite.a99
2066                      .char ' '
     **** ****     > CHAR
0004 0671   03            byte ' ' ^ RE
                   < elite.a99
2067                      .char ' '
     **** ****     > CHAR
0004 0672 03              byte ' ' ^ RE
                   < elite.a99
2068                      .rtok 14
     **** ****     > RTOK
0003 0673   8D            byte (14 + 160) ^ RE
                   < elite.a99
2069                      .char ' '
     **** ****     > CHAR
0004 0674 03              byte ' ' ^ RE
                   < elite.a99
2070                      .rtok 6
     **** ****     > RTOK
0003 0675   85            byte (6 + 160) ^ RE
                   < elite.a99
2071                      .char ' '
     **** ****     > CHAR
0004 0676 03              byte ' ' ^ RE
                   < elite.a99
2072                      .char 'F'
     **** ****     > CHAR
0004 0677   65            byte 'F' ^ RE
                   < elite.a99
2073 0678 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2074                      .char ' '
     **** ****     > CHAR
0004 0679   03            byte ' ' ^ RE
                   < elite.a99
2075                      .char 'S'
     **** ****     > CHAR
0004 067A 70              byte 'S' ^ RE
                   < elite.a99
2076                      .char 'A'
     **** ****     > CHAR
0004 067B   62            byte 'A' ^ RE
                   < elite.a99
2077 067C A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2078                      .cont 13
     **** ****     > CONT
0001 067D   2E            byte 13 ^ RE
                   < elite.a99
2079                      .cont 10
     **** ****     > CONT
0001 067E 29              byte 10 ^ RE
                   < elite.a99
2080 067F   00            byte >00
2081               
2082                      .char 'F'                                           ; Token 96:     "FRONT"
     **** ****     > CHAR
0004 0680 65              byte 'F' ^ RE
                   < elite.a99
2083                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0681   71            byte 'R' ^ RE
                   < elite.a99
2084 0682 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' Encoded as:   "FR<159>T"
2085                      .char 'T'
     **** ****     > CHAR
0004 0683   77            byte 'T' ^ RE
                   < elite.a99
2086 0684 00              byte >00
2087               
2088 0685   AD            byte 142 ^ RE                                       ; TWOK 'R', 'E' Token 97:     "REAR"
2089 0686 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
2090 0687   00            byte >00                                            ; Encoded as:   "<142><138>"
2091               
2092 0688 A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' Token 98:     "LEFT"
2093                      .char 'F'                                           ;
     **** ****     > CHAR
0004 0689   65            byte 'F' ^ RE
                   < elite.a99
2094                      .char 'T'                                           ; Encoded as:   "<129>FT"
     **** ****     > CHAR
0004 068A 77              byte 'T' ^ RE
                   < elite.a99
2095 068B   00            byte >00
2096               
2097 068C BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' Token 99:     "RIGHT"
2098                      .char 'G'                                           ;
     **** ****     > CHAR
0004 068D   64            byte 'G' ^ RE
                   < elite.a99
2099                      .char 'H'                                           ; Encoded as:   "<158>GHT"
     **** ****     > CHAR
0004 068E 6B              byte 'H' ^ RE
                   < elite.a99
2100                      .char 'T'
     **** ****     > CHAR
0004 068F   77            byte 'T' ^ RE
                   < elite.a99
2101 0690 00              byte >00
2102               
2103                      .rtok 121                                           ; Token 100:    "ENERGY LOW{beep}"
     **** ****     > RTOK
0008 0691   5A            byte 121 ^ RE
                   < elite.a99
2104                      .char 'L'                                           ;
     **** ****     > CHAR
0004 0692 6F              byte 'L' ^ RE
                   < elite.a99
2105                      .char 'O'                                           ; Encoded as:   "[121]LOW{7}"
     **** ****     > CHAR
0004 0693   6C            byte 'O' ^ RE
                   < elite.a99
2106                      .char 'W'
     **** ****     > CHAR
0004 0694 74              byte 'W' ^ RE
                   < elite.a99
2107                      .cont 7
     **** ****     > CONT
0001 0695   24            byte 7 ^ RE
                   < elite.a99
2108 0696 00              byte >00
2109               
2110                      .rtok 99                                            ; Token 101:    "RIGHT ON COMMANDER!"
     **** ****     > RTOK
0008 0697   40            byte 99 ^ RE
                   < elite.a99
2111                      .rtok 131                                           ;
     **** ****     > RTOK
0006 0698 32              byte (131 - 114) ^ RE
                   < elite.a99
2112                      .rtok 92                                            ; Encoded as:   "[99][131][92]!"
     **** ****     > RTOK
0003 0699   DF            byte (92 + 160) ^ RE
                   < elite.a99
2113                      .char '!'
     **** ****     > CHAR
0004 069A 02              byte '!' ^ RE
                   < elite.a99
2114 069B   00            byte >00
2115               
2116                      .char 'E'                                           ; Token 102:    "EXTRA "
     **** ****     > CHAR
0004 069C 66              byte 'E' ^ RE
                   < elite.a99
2117                      .char 'X'                                           ;
     **** ****     > CHAR
0004 069D   7B            byte 'X' ^ RE
                   < elite.a99
2118                      .char 'T'                                           ; Encoded as:   "EXT<148> "
     **** ****     > CHAR
0004 069E 77              byte 'T' ^ RE
                   < elite.a99
2119 069F   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' null
2120                      .char ' '
     **** ****     > CHAR
0004 06A0 03              byte ' ' ^ RE
                   < elite.a99
2121 06A1   00            byte >00
2122               
2123                      .char 'P'                                           ; Token 103:    "PULSE LASER"
     **** ****     > CHAR
0004 06A2 73              byte 'P' ^ RE
                   < elite.a99
2124                      .char 'U'                                           ;
     **** ****     > CHAR
0004 06A3   76            byte 'U' ^ RE
                   < elite.a99
2125                      .char 'L'                                           ; Encoded as:   "PULSE[27]"
     **** ****     > CHAR
0004 06A4 6F              byte 'L' ^ RE
                   < elite.a99
2126                      .char 'S'
     **** ****     > CHAR
0004 06A5   70            byte 'S' ^ RE
                   < elite.a99
2127                      .char 'E'
     **** ****     > CHAR
0004 06A6 66              byte 'E' ^ RE
                   < elite.a99
2128                      .rtok 27
     **** ****     > RTOK
0003 06A7   98            byte (27 + 160) ^ RE
                   < elite.a99
2129 06A8 00              byte >00
2130               
2131 06A9   B0            byte 147 ^ RE                                       ; TWOK 'B', 'E' Token 104:    "BEAM LASER"
2132                      .char 'A'                                           ;
     **** ****     > CHAR
0004 06AA 62              byte 'A' ^ RE
                   < elite.a99
2133                      .char 'M'                                           ; Encoded as:   "<147>AM[27]"
     **** ****     > CHAR
0004 06AB   6E            byte 'M' ^ RE
                   < elite.a99
2134                      .rtok 27
     **** ****     > RTOK
0003 06AC 98              byte (27 + 160) ^ RE
                   < elite.a99
2135 06AD   00            byte >00
2136               
2137                      .char 'F'                                           ; Token 105:    "FUEL"
     **** ****     > CHAR
0004 06AE 65              byte 'F' ^ RE
                   < elite.a99
2138                      .char 'U'                                           ;
     **** ****     > CHAR
0004 06AF   76            byte 'U' ^ RE
                   < elite.a99
2139                      .char 'E'                                           ; Encoded as:   "FUEL"
     **** ****     > CHAR
0004 06B0 66              byte 'E' ^ RE
                   < elite.a99
2140                      .char 'L'
     **** ****     > CHAR
0004 06B1   6F            byte 'L' ^ RE
                   < elite.a99
2141 06B2 00              byte >00
2142               
2143                      .char 'M'                                           ; Token 106:    "MISSILE"
     **** ****     > CHAR
0004 06B3   6E            byte 'M' ^ RE
                   < elite.a99
2144 06B4 BE              byte 157 ^ RE                                       ; TWOK 'I', 'S'
2145                      .char 'S'                                           ; Encoded as:   "M<157>SI<129>"
     **** ****     > CHAR
0004 06B5   70            byte 'S' ^ RE
                   < elite.a99
2146                      .char 'I'
     **** ****     > CHAR
0004 06B6 6A              byte 'I' ^ RE
                   < elite.a99
2147 06B7   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2148 06B8 00              byte >00
2149               
2150                      .rtok 67                                            ; Token 107:    "LARGE CARGO{sentence case} BAY"
     **** ****     > RTOK
0003 06B9   C0            byte (67 + 160) ^ RE
                   < elite.a99
2151                      .rtok 46                                            ;
     **** ****     > RTOK
0003 06BA ED              byte (46 + 160) ^ RE
                   < elite.a99
2152                      .char ' '                                           ; Encoded as:   "[67][46] BAY"
     **** ****     > CHAR
0004 06BB   03            byte ' ' ^ RE
                   < elite.a99
2153                      .char 'B'
     **** ****     > CHAR
0004 06BC 61              byte 'B' ^ RE
                   < elite.a99
2154                      .char 'A'
     **** ****     > CHAR
0004 06BD   62            byte 'A' ^ RE
                   < elite.a99
2155                      .char 'Y'
     **** ****     > CHAR
0004 06BE 7A              byte 'Y' ^ RE
                   < elite.a99
2156 06BF   00            byte >00
2157               
2158                      .char 'E'                                           ; Token 108:    "E.C.M.SYSTEM"
     **** ****     > CHAR
0004 06C0 66              byte 'E' ^ RE
                   < elite.a99
2159                      .char '.'                                           ;
     **** ****     > CHAR
0004 06C1   0D            byte '.' ^ RE
                   < elite.a99
2160                      .char 'C'                                           ; Encoded as:   "E.C.M.[5]"
     **** ****     > CHAR
0004 06C2 60              byte 'C' ^ RE
                   < elite.a99
2161                      .char '.'
     **** ****     > CHAR
0004 06C3   0D            byte '.' ^ RE
                   < elite.a99
2162                      .char 'M'
     **** ****     > CHAR
0004 06C4 6E              byte 'M' ^ RE
                   < elite.a99
2163                      .char '.'
     **** ****     > CHAR
0004 06C5   0D            byte '.' ^ RE
                   < elite.a99
2164                      .rtok 5
     **** ****     > RTOK
0003 06C6 86              byte (5 + 160) ^ RE
                   < elite.a99
2165 06C7   00            byte >00
2166               
2167                      .rtok 102                                           ; Token 109:    "EXTRA PULSE LASERS"
     **** ****     > RTOK
0008 06C8 45              byte 102 ^ RE
                   < elite.a99
2168                      .rtok 103                                           ;
     **** ****     > RTOK
0008 06C9   44            byte 103 ^ RE
                   < elite.a99
2169                      .char 'S'                                           ; Encoded as:   "[102][103]S"
     **** ****     > CHAR
0004 06CA 70              byte 'S' ^ RE
                   < elite.a99
2170 06CB   00            byte >00
2171               
2172                      .rtok 102                                           ; Token 110:    "EXTRA BEAM LASERS"
     **** ****     > RTOK
0008 06CC 45              byte 102 ^ RE
                   < elite.a99
2173                      .rtok 104                                           ;
     **** ****     > RTOK
0008 06CD   4B            byte 104 ^ RE
                   < elite.a99
2174                      .char 'S'                                           ; Encoded as:   "[102][104]S"
     **** ****     > CHAR
0004 06CE 70              byte 'S' ^ RE
                   < elite.a99
2175 06CF   00            byte >00
2176               
2177                      .rtok 105                                           ; Token 111:    "FUEL SCOOPS"
     **** ****     > RTOK
0008 06D0 4A              byte 105 ^ RE
                   < elite.a99
2178                      .char ' '                                           ;
     **** ****     > CHAR
0004 06D1   03            byte ' ' ^ RE
                   < elite.a99
2179                      .char 'S'                                           ; Encoded as:   "[105] SCOOPS"
     **** ****     > CHAR
0004 06D2 70              byte 'S' ^ RE
                   < elite.a99
2180                      .char 'C'
     **** ****     > CHAR
0004 06D3   60            byte 'C' ^ RE
                   < elite.a99
2181                      .char 'O'
     **** ****     > CHAR
0004 06D4 6C              byte 'O' ^ RE
                   < elite.a99
2182                      .char 'O'
     **** ****     > CHAR
0004 06D5   6C            byte 'O' ^ RE
                   < elite.a99
2183                      .char 'P'
     **** ****     > CHAR
0004 06D6 73              byte 'P' ^ RE
                   < elite.a99
2184                      .char 'S'
     **** ****     > CHAR
0004 06D7   70            byte 'S' ^ RE
                   < elite.a99
2185 06D8 00              byte >00
2186               
2187 06D9   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' Token 112:    "ESCAPE POD"
2188                      .char 'C'                                           ;
     **** ****     > CHAR
0004 06DA 60              byte 'C' ^ RE
                   < elite.a99
2189                      .char 'A'                                           ; Encoded as:   "<137>CAPE POD"
     **** ****     > CHAR
0004 06DB   62            byte 'A' ^ RE
                   < elite.a99
2190                      .char 'P'
     **** ****     > CHAR
0004 06DC 73              byte 'P' ^ RE
                   < elite.a99
2191                      .char 'E'
     **** ****     > CHAR
0004 06DD   66            byte 'E' ^ RE
                   < elite.a99
2192                      .char ' '
     **** ****     > CHAR
0004 06DE 03              byte ' ' ^ RE
                   < elite.a99
2193                      .char 'P'
     **** ****     > CHAR
0004 06DF   73            byte 'P' ^ RE
                   < elite.a99
2194                      .char 'O'
     **** ****     > CHAR
0004 06E0 6C              byte 'O' ^ RE
                   < elite.a99
2195                      .char 'D'
     **** ****     > CHAR
0004 06E1   67            byte 'D' ^ RE
                   < elite.a99
2196 06E2 00              byte >00
2197               
2198                      .rtok 121                                           ; Token 113:    "ENERGY BOMB"
     **** ****     > RTOK
0008 06E3   5A            byte 121 ^ RE
                   < elite.a99
2199                      .char 'B'                                           ;
     **** ****     > CHAR
0004 06E4 61              byte 'B' ^ RE
                   < elite.a99
2200                      .char 'O'                                           ; Encoded as:   "[121]BOMB"
     **** ****     > CHAR
0004 06E5   6C            byte 'O' ^ RE
                   < elite.a99
2201                      .char 'M'
     **** ****     > CHAR
0004 06E6 6E              byte 'M' ^ RE
                   < elite.a99
2202                      .char 'B'
     **** ****     > CHAR
0004 06E7   61            byte 'B' ^ RE
                   < elite.a99
2203 06E8 00              byte >00
2204               
2205                      .rtok 121                                           ; Token 114:    "ENERGY UNIT"
     **** ****     > RTOK
0008 06E9   5A            byte 121 ^ RE
                   < elite.a99
2206                      .rtok 14                                            ;
     **** ****     > RTOK
0003 06EA 8D              byte (14 + 160) ^ RE
                   < elite.a99
2207 06EB   00            byte >00                                            ; Encoded as:   "[121][14]"
2208               
2209                      .rtok 124                                           ; Token 115:    "DOCKING COMPUTERS"
     **** ****     > RTOK
0008 06EC 5F              byte 124 ^ RE
                   < elite.a99
2210 06ED   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
2211                      .char 'G'                                           ; Encoded as:   "[124]<140>G [55]"
     **** ****     > CHAR
0004 06EE 64              byte 'G' ^ RE
                   < elite.a99
2212                      .char ' '
     **** ****     > CHAR
0004 06EF   03            byte ' ' ^ RE
                   < elite.a99
2213                      .rtok 55
     **** ****     > RTOK
0003 06F0 F4              byte (55 + 160) ^ RE
                   < elite.a99
2214 06F1   00            byte >00
2215               
2216                      .rtok 122                                           ; Token 116:    "GALACTIC HYPERSPACE "
     **** ****     > RTOK
0008 06F2 59              byte 122 ^ RE
                   < elite.a99
2217                      .char ' '                                           ;
     **** ****     > CHAR
0004 06F3   03            byte ' ' ^ RE
                   < elite.a99
2218                      .rtok 29                                            ; Encoded as:   "[122] [29]"
     **** ****     > RTOK
0003 06F4 9E              byte (29 + 160) ^ RE
                   < elite.a99
2219 06F5   00            byte >00
2220               
2221                      .char 'A'                                           ; Token 117:    "ALL"
     **** ****     > CHAR
0004 06F6 62              byte 'A' ^ RE
                   < elite.a99
2222                      .rtok 118                                           ;
     **** ****     > RTOK
0008 06F7   55            byte 118 ^ RE
                   < elite.a99
2223 06F8 00              byte >00                                            ; Encoded as:   "A[118]"
2224               
2225                      .char 'L'                                           ; Token 118:    "LL"
     **** ****     > CHAR
0004 06F9   6F            byte 'L' ^ RE
                   < elite.a99
2226                      .char 'L'                                           ;
     **** ****     > CHAR
0004 06FA 6F              byte 'L' ^ RE
                   < elite.a99
2227 06FB   00            byte >00                                            ; Encoded as:   "LL"
2228               
2229                      .rtok 37                                            ; Token 119:    "CASH:{cash} CR{crlf}
     **** ****     > RTOK
0003 06FC E6              byte (37 + 160) ^ RE
                   < elite.a99
2230                      .char ':'                                           ; "
     **** ****     > CHAR
0004 06FD   19            byte ':' ^ RE
                   < elite.a99
2231                      .cont 0                                             ;
     **** ****     > CONT
0001 06FE 23              byte 0 ^ RE
                   < elite.a99
2232 06FF   00            byte >00                                            ; Encoded as:   "[37]:{0}"
2233               
2234 0700 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 120:    "INCOMING MISSILE"
2235                      .rtok 91                                            ;
     **** ****     > RTOK
0003 0701   D8            byte (91 + 160) ^ RE
                   < elite.a99
2236 0702 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Encoded as:   "<140>[91]<140>G [106]"
2237                      .char 'G'
     **** ****     > CHAR
0004 0703   64            byte 'G' ^ RE
                   < elite.a99
2238                      .char ' '
     **** ****     > CHAR
0004 0704 03              byte ' ' ^ RE
                   < elite.a99
2239                      .rtok 106
     **** ****     > RTOK
0008 0705   49            byte 106 ^ RE
                   < elite.a99
2240 0706 00              byte >00
2241               
2242 0707   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' Token 121:    "ENERGY "
2243 0708 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R'
2244                      .char 'G'                                           ; Encoded as:   "<146><144>GY "
     **** ****     > CHAR
0004 0709   64            byte 'G' ^ RE
                   < elite.a99
2245                      .char 'Y'
     **** ****     > CHAR
0004 070A 7A              byte 'Y' ^ RE
                   < elite.a99
2246                      .char ' '
     **** ****     > CHAR
0004 070B   03            byte ' ' ^ RE
                   < elite.a99
2247 070C 00              byte >00
2248               
2249                      .char 'G'                                           ; Token 122:    "GALACTIC"
     **** ****     > CHAR
0004 070D   64            byte 'G' ^ RE
                   < elite.a99
2250                      .char 'A'                                           ;
     **** ****     > CHAR
0004 070E 62              byte 'A' ^ RE
                   < elite.a99
2251 070F   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A' Encoded as:   "GA<149>C<151>C"
2252                      .char 'C'
     **** ****     > CHAR
0004 0710 60              byte 'C' ^ RE
                   < elite.a99
2253 0711   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2254                      .char 'C'
     **** ****     > CHAR
0004 0712 60              byte 'C' ^ RE
                   < elite.a99
2255 0713   00            byte >00
2256               
2257                      .cont 13                                            ; Token 123:    "{crlf}
     **** ****     > CONT
0001 0714 2E              byte 13 ^ RE
                   < elite.a99
2258                      .rtok 92                                            ; COMMANDER'S NAME? "
     **** ****     > RTOK
0003 0715   DF            byte (92 + 160) ^ RE
                   < elite.a99
2259                      .char '`'                                           ;
     **** ****     > CHAR
0002 0716 04              byte 39 ^ RE
                   < elite.a99
2260                      .char 'S'                                           ; Encoded as:   "{13}[92]'S NAME? "
     **** ****     > CHAR
0004 0717   70            byte 'S' ^ RE
                   < elite.a99
2261                      .char ' '
     **** ****     > CHAR
0004 0718 03              byte ' ' ^ RE
                   < elite.a99
2262                      .char 'N'
     **** ****     > CHAR
0004 0719   6D            byte 'N' ^ RE
                   < elite.a99
2263                      .char 'A'
     **** ****     > CHAR
0004 071A 62              byte 'A' ^ RE
                   < elite.a99
2264                      .char 'M'
     **** ****     > CHAR
0004 071B   6E            byte 'M' ^ RE
                   < elite.a99
2265                      .char 'E'
     **** ****     > CHAR
0004 071C 66              byte 'E' ^ RE
                   < elite.a99
2266                      .char '?'
     **** ****     > CHAR
0004 071D   1C            byte '?' ^ RE
                   < elite.a99
2267                      .char ' '
     **** ****     > CHAR
0004 071E 03              byte ' ' ^ RE
                   < elite.a99
2268 071F   00            byte >00
2269               
2270                      .char 'D'                                           ; Token 124:    "DOCK"
     **** ****     > CHAR
0004 0720 67              byte 'D' ^ RE
                   < elite.a99
2271                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0721   6C            byte 'O' ^ RE
                   < elite.a99
2272                      .char 'C'                                           ; Encoded as:   "DOCK"
     **** ****     > CHAR
0004 0722 60              byte 'C' ^ RE
                   < elite.a99
2273                      .char 'K'
     **** ****     > CHAR
0004 0723   68            byte 'K' ^ RE
                   < elite.a99
2274 0724 00              byte >00
2275               
2276                      .cont 5                                             ; Token 125:    "FUEL: {fuel level} LIGHT YEARS{crlf}
     **** ****     > CONT
0001 0725   26            byte 5 ^ RE
                   < elite.a99
2277 0726 A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' CASH:{cash} CR{crlf}
2278                      .char 'G'                                           ; LEGAL STATUS:"
     **** ****     > CHAR
0004 0727   64            byte 'G' ^ RE
                   < elite.a99
2279 0728 A3              byte 128 ^ RE                                       ; TWOK 'A', 'L'
2280                      .char ' '                                           ; Encoded as:   "{5}<129>G<128> [43]<145><136>:"
     **** ****     > CHAR
0004 0729   03            byte ' ' ^ RE
                   < elite.a99
2281                      .rtok 43
     **** ****     > RTOK
0003 072A E8              byte (43 + 160) ^ RE
                   < elite.a99
2282 072B   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
2283 072C AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2284                      .char ':'
     **** ****     > CHAR
0004 072D   19            byte ':' ^ RE
                   < elite.a99
2285 072E 00              byte >00
2286               
2287                      .rtok 92                                            ; Token 126:    "COMMANDER {commander name}{crlf}
     **** ****     > RTOK
0003 072F   DF            byte (92 + 160) ^ RE
                   < elite.a99
2288                      .char ' '                                           ; {crlf}
     **** ****     > CHAR
0004 0730 03              byte ' ' ^ RE
                   < elite.a99
2289                      .cont 4                                             ; {crlf}
     **** ****     > CONT
0001 0731   27            byte 4 ^ RE
                   < elite.a99
2290                      .cont 13                                            ; {sentence case}PRESENT SYSTEM{tab to
     **** ****     > CONT
0001 0732 2E              byte 13 ^ RE
                   < elite.a99
2291                      .cont 13                                            ; column 21}:{current system name}{crlf}
     **** ****     > CONT
0001 0733   2E            byte 13 ^ RE
                   < elite.a99
2292                      .cont 13                                            ; HYPERSPACE SYSTEM{tab to column 21}:
     **** ****     > CONT
0001 0734 2E              byte 13 ^ RE
                   < elite.a99
2293                      .cont 6                                             ; {selected system name}{crlf}
     **** ****     > CONT
0001 0735   25            byte 6 ^ RE
                   < elite.a99
2294                      .rtok 145                                           ; CONDITION{tab to column 21}:"
     **** ****     > RTOK
0006 0736 3C              byte (145 - 114) ^ RE
                   < elite.a99
2295                      .char ' '                                           ;
     **** ****     > CHAR
0004 0737   03            byte ' ' ^ RE
                   < elite.a99
2296                      .rtok 5                                             ; Encoded as:   "[92] {4}{13}{13}{13}{6}[145] [5]{9}{2}
     **** ****     > RTOK
0003 0738 86              byte (5 + 160) ^ RE
                   < elite.a99
2297                      .cont 9                                             ; {13}[29][5]{9}{3}{13}C<159><141><151>
     **** ****     > CONT
0001 0739   2A            byte 9 ^ RE
                   < elite.a99
2298                      .cont 2                                             ; <159>{9}"
     **** ****     > CONT
0001 073A 21              byte 2 ^ RE
                   < elite.a99
2299                      .cont 13
     **** ****     > CONT
0001 073B   2E            byte 13 ^ RE
                   < elite.a99
2300                      .rtok 29
     **** ****     > RTOK
0003 073C 9E              byte (29 + 160) ^ RE
                   < elite.a99
2301                      .rtok 5
     **** ****     > RTOK
0003 073D   86            byte (5 + 160) ^ RE
                   < elite.a99
2302                      .cont 9
     **** ****     > CONT
0001 073E 2A              byte 9 ^ RE
                   < elite.a99
2303                      .cont 3
     **** ****     > CONT
0001 073F   20            byte 3 ^ RE
                   < elite.a99
2304                      .cont 13
     **** ****     > CONT
0001 0740 2E              byte 13 ^ RE
                   < elite.a99
2305                      .char 'C'
     **** ****     > CHAR
0004 0741   60            byte 'C' ^ RE
                   < elite.a99
2306 0742 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
2307 0743   AE            byte 141 ^ RE                                       ; TWOK 'D', 'I' null
2308 0744 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2309 0745   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
2310                      .cont 9
     **** ****     > CONT
0001 0746 2A              byte 9 ^ RE
                   < elite.a99
2311 0747   00            byte >00
2312               
2313                      .char 'I'                                           ; Token 127:    "ITEM"
     **** ****     > CHAR
0004 0748 6A              byte 'I' ^ RE
                   < elite.a99
2314 0749   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E'
2315                      .char 'M'                                           ; Encoded as:   "I<156>M"
     **** ****     > CHAR
0004 074A 6E              byte 'M' ^ RE
                   < elite.a99
2316 074B   00            byte >00
2317               
2318                      .char ' '                                           ; Token 128:    "  LOAD NEW COMMANDER (Y/N)?{crlf}
     **** ****     > CHAR
0004 074C 03              byte ' ' ^ RE
                   < elite.a99
2319                      .char ' '                                           ; {crlf}
     **** ****     > CHAR
0004 074D   03            byte ' ' ^ RE
                   < elite.a99
2320                      .char 'L'                                           ; "
     **** ****     > CHAR
0004 074E 6F              byte 'L' ^ RE
                   < elite.a99
2321                      .char 'O'                                           ;
     **** ****     > CHAR
0004 074F   6C            byte 'O' ^ RE
                   < elite.a99
2322                      .char 'A'                                           ; Encoded as:   "  LOAD NEW [92] [65]{13}{13}"
     **** ****     > CHAR
0004 0750 62              byte 'A' ^ RE
                   < elite.a99
2323                      .char 'D'
     **** ****     > CHAR
0004 0751   67            byte 'D' ^ RE
                   < elite.a99
2324                      .char ' '
     **** ****     > CHAR
0004 0752 03              byte ' ' ^ RE
                   < elite.a99
2325                      .char 'N'
     **** ****     > CHAR
0004 0753   6D            byte 'N' ^ RE
                   < elite.a99
2326                      .char 'E'
     **** ****     > CHAR
0004 0754 66              byte 'E' ^ RE
                   < elite.a99
2327                      .char 'W'
     **** ****     > CHAR
0004 0755   74            byte 'W' ^ RE
                   < elite.a99
2328                      .char ' '
     **** ****     > CHAR
0004 0756 03              byte ' ' ^ RE
                   < elite.a99
2329                      .rtok 92
     **** ****     > RTOK
0003 0757   DF            byte (92 + 160) ^ RE
                   < elite.a99
2330                      .char ' '
     **** ****     > CHAR
0004 0758 03              byte ' ' ^ RE
                   < elite.a99
2331                      .rtok 65
     **** ****     > RTOK
0003 0759   C2            byte (65 + 160) ^ RE
                   < elite.a99
2332                      .cont 13
     **** ****     > CONT
0001 075A 2E              byte 13 ^ RE
                   < elite.a99
2333                      .cont 13
     **** ****     > CONT
0001 075B   2E            byte 13 ^ RE
                   < elite.a99
2334 075C 00              byte >00
2335               
2336                      .cont 6                                             ; Token 129:    "{sentence case}DOCKED"
     **** ****     > CONT
0001 075D   25            byte 6 ^ RE
                   < elite.a99
2337                      .rtok 124                                           ;
     **** ****     > RTOK
0008 075E 5F              byte 124 ^ RE
                   < elite.a99
2338 075F   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' Encoded as:   "{6}[124]<152>"
2339 0760 00              byte >00
2340               
2341 0761   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Token 130:    "RATING:"
2342 0762 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I'
2343                      .char 'N'                                           ; Encoded as:   "<148><151>NG:"
     **** ****     > CHAR
0004 0763   6D            byte 'N' ^ RE
                   < elite.a99
2344                      .char 'G'
     **** ****     > CHAR
0004 0764 64              byte 'G' ^ RE
                   < elite.a99
2345                      .char ':'
     **** ****     > CHAR
0004 0765   19            byte ':' ^ RE
                   < elite.a99
2346 0766 00              byte >00
2347               
2348                      .char ' '                                           ; Token 131:    " ON "
     **** ****     > CHAR
0004 0767   03            byte ' ' ^ RE
                   < elite.a99
2349 0768 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N'
2350                      .char ' '                                           ; Encoded as:   " <159> "
     **** ****     > CHAR
0004 0769   03            byte ' ' ^ RE
                   < elite.a99
2351 076A 00              byte >00
2352               
2353                      .cont 13                                            ; Token 132:    "{crlf}
     **** ****     > CONT
0001 076B   2E            byte 13 ^ RE
                   < elite.a99
2354                      .cont 8                                             ; {all caps}EQUIPMENT: {sentence case}"
     **** ****     > CONT
0001 076C 2B              byte 8 ^ RE
                   < elite.a99
2355                      .rtok 47                                            ;
     **** ****     > RTOK
0003 076D   EC            byte (47 + 160) ^ RE
                   < elite.a99
2356                      .char 'M'                                           ; Encoded as:   "{13}{8}[47]M<146>T:{6}"
     **** ****     > CHAR
0004 076E 6E              byte 'M' ^ RE
                   < elite.a99
2357 076F   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2358                      .char 'T'
     **** ****     > CHAR
0004 0770 77              byte 'T' ^ RE
                   < elite.a99
2359                      .char ':'
     **** ****     > CHAR
0004 0771   19            byte ':' ^ RE
                   < elite.a99
2360                      .cont 6
     **** ****     > CONT
0001 0772 25              byte 6 ^ RE
                   < elite.a99
2361 0773   00            byte >00
2362               
2363                      .char 'C'                                           ; Token 133:    "CLEAN"
     **** ****     > CHAR
0004 0774 60              byte 'C' ^ RE
                   < elite.a99
2364 0775   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E'
2365 0776 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "C<129><155>"
2366 0777   00            byte >00
2367               
2368                      .char 'O'                                           ; Token 134:    "OFFENDER"
     **** ****     > CHAR
0004 0778 6C              byte 'O' ^ RE
                   < elite.a99
2369                      .char 'F'                                           ;
     **** ****     > CHAR
0004 0779   65            byte 'F' ^ RE
                   < elite.a99
2370                      .char 'F'                                           ; Encoded as:   "OFF<146>D<144>"
     **** ****     > CHAR
0004 077A 65              byte 'F' ^ RE
                   < elite.a99
2371 077B   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2372                      .char 'D'
     **** ****     > CHAR
0004 077C 67              byte 'D' ^ RE
                   < elite.a99
2373 077D   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
2374 077E 00              byte >00
2375               
2376                      .char 'F'                                           ; Token 135:    "FUGITIVE"
     **** ****     > CHAR
0004 077F   65            byte 'F' ^ RE
                   < elite.a99
2377                      .char 'U'                                           ;
     **** ****     > CHAR
0004 0780 76              byte 'U' ^ RE
                   < elite.a99
2378                      .char 'G'                                           ; Encoded as:   "FUGI<151><150>"
     **** ****     > CHAR
0004 0781   64            byte 'G' ^ RE
                   < elite.a99
2379                      .char 'I'
     **** ****     > CHAR
0004 0782 6A              byte 'I' ^ RE
                   < elite.a99
2380 0783   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2381 0784 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2382 0785   00            byte >00
2383               
2384                      .char 'H'                                           ; Token 136:    "HARMLESS"
     **** ****     > CHAR
0004 0786 6B              byte 'H' ^ RE
                   < elite.a99
2385 0787   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R'
2386                      .char 'M'                                           ; Encoded as:   "H<138>M<129>SS"
     **** ****     > CHAR
0004 0788 6E              byte 'M' ^ RE
                   < elite.a99
2387 0789   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2388                      .char 'S'
     **** ****     > CHAR
0004 078A 70              byte 'S' ^ RE
                   < elite.a99
2389                      .char 'S'
     **** ****     > CHAR
0004 078B   70            byte 'S' ^ RE
                   < elite.a99
2390 078C 00              byte >00
2391               
2392                      .char 'M'                                           ; Token 137:    "MOSTLY HARMLESS"
     **** ****     > CHAR
0004 078D   6E            byte 'M' ^ RE
                   < elite.a99
2393                      .char 'O'                                           ;
     **** ****     > CHAR
0004 078E 6C              byte 'O' ^ RE
                   < elite.a99
2394                      .rtok 43                                            ; Encoded as:   "MO[43]LY [136]"
     **** ****     > RTOK
0003 078F   E8            byte (43 + 160) ^ RE
                   < elite.a99
2395                      .char 'L'
     **** ****     > CHAR
0004 0790 6F              byte 'L' ^ RE
                   < elite.a99
2396                      .char 'Y'
     **** ****     > CHAR
0004 0791   7A            byte 'Y' ^ RE
                   < elite.a99
2397                      .char ' '
     **** ****     > CHAR
0004 0792 03              byte ' ' ^ RE
                   < elite.a99
2398                      .rtok 136
     **** ****     > RTOK
0006 0793   35            byte (136 - 114) ^ RE
                   < elite.a99
2399 0794 00              byte >00
2400               
2401                      .rtok 12                                            ; Token 138:    "POOR "
     **** ****     > RTOK
0003 0795   8F            byte (12 + 160) ^ RE
                   < elite.a99
2402 0796 00              byte >00                                            ;
2403                                                                          ; Encoded as:   "[12]"
2404               
2405                      .rtok 11                                            ; Token 139:    "AVERAGE "
     **** ****     > RTOK
0003 0797   88            byte (11 + 160) ^ RE
                   < elite.a99
2406 0798 00              byte >00                                            ;
2407                                                                          ; Encoded as:   "[11]"
2408               
2409                      .char 'A'                                           ; Token 140:    "ABOVE AVERAGE "
     **** ****     > CHAR
0004 0799   62            byte 'A' ^ RE
                   < elite.a99
2410                      .char 'B'                                           ;
     **** ****     > CHAR
0004 079A 61              byte 'B' ^ RE
                   < elite.a99
2411                      .char 'O'                                           ; Encoded as:   "ABO<150> [11]"
     **** ****     > CHAR
0004 079B   6C            byte 'O' ^ RE
                   < elite.a99
2412 079C B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2413                      .char ' '
     **** ****     > CHAR
0004 079D   03            byte ' ' ^ RE
                   < elite.a99
2414                      .rtok 11
     **** ****     > RTOK
0003 079E 88              byte (11 + 160) ^ RE
                   < elite.a99
2415 079F   00            byte >00
2416               
2417                      .rtok 91                                            ; Token 141:    "COMPETENT"
     **** ****     > RTOK
0003 07A0 D8              byte (91 + 160) ^ RE
                   < elite.a99
2418                      .char 'P'                                           ;
     **** ****     > CHAR
0004 07A1   73            byte 'P' ^ RE
                   < elite.a99
2419                      .char 'E'                                           ; Encoded as:   "[91]PET<146>T"
     **** ****     > CHAR
0004 07A2 66              byte 'E' ^ RE
                   < elite.a99
2420                      .char 'T'
     **** ****     > CHAR
0004 07A3   77            byte 'T' ^ RE
                   < elite.a99
2421 07A4 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2422                      .char 'T'
     **** ****     > CHAR
0004 07A5   77            byte 'T' ^ RE
                   < elite.a99
2423 07A6 00              byte >00
2424               
2425                      .char 'D'                                           ; Token 142:    "DANGEROUS"
     **** ****     > CHAR
0004 07A7   67            byte 'D' ^ RE
                   < elite.a99
2426 07A8 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
2427 07A9   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "D<155><131>RO<136>"
2428                      .char 'R'
     **** ****     > CHAR
0004 07AA 71              byte 'R' ^ RE
                   < elite.a99
2429                      .char 'O'
     **** ****     > CHAR
0004 07AB   6C            byte 'O' ^ RE
                   < elite.a99
2430 07AC AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2431 07AD   00            byte >00
2432               
2433                      .char 'D'                                           ; Token 143:    "DEADLY"
     **** ****     > CHAR
0004 07AE 67              byte 'D' ^ RE
                   < elite.a99
2434                      .char 'E'                                           ;
     **** ****     > CHAR
0004 07AF   66            byte 'E' ^ RE
                   < elite.a99
2435                      .char 'A'                                           ; Encoded as:   "DEADLY"
     **** ****     > CHAR
0004 07B0 62              byte 'A' ^ RE
                   < elite.a99
2436                      .char 'D'
     **** ****     > CHAR
0004 07B1   67            byte 'D' ^ RE
                   < elite.a99
2437                      .char 'L'
     **** ****     > CHAR
0004 07B2 6F              byte 'L' ^ RE
                   < elite.a99
2438                      .char 'Y'
     **** ****     > CHAR
0004 07B3   7A            byte 'Y' ^ RE
                   < elite.a99
2439 07B4 00              byte >00
2440               
2441                      .char '-'                                           ; Token 144:    "---- E L I T E ----"
     **** ****     > CHAR
0004 07B5   0E            byte '-' ^ RE
                   < elite.a99
2442                      .char '-'                                           ;
     **** ****     > CHAR
0004 07B6 0E              byte '-' ^ RE
                   < elite.a99
2443                      .char '-'                                           ; Encoded as:   "---- E L I T E ----"
     **** ****     > CHAR
0004 07B7   0E            byte '-' ^ RE
                   < elite.a99
2444                      .char '-'
     **** ****     > CHAR
0004 07B8 0E              byte '-' ^ RE
                   < elite.a99
2445                      .char ' '
     **** ****     > CHAR
0004 07B9   03            byte ' ' ^ RE
                   < elite.a99
2446                      .char 'E'
     **** ****     > CHAR
0004 07BA 66              byte 'E' ^ RE
                   < elite.a99
2447                      .char ' '
     **** ****     > CHAR
0004 07BB   03            byte ' ' ^ RE
                   < elite.a99
2448                      .char 'L'
     **** ****     > CHAR
0004 07BC 6F              byte 'L' ^ RE
                   < elite.a99
2449                      .char ' '
     **** ****     > CHAR
0004 07BD   03            byte ' ' ^ RE
                   < elite.a99
2450                      .char 'I'
     **** ****     > CHAR
0004 07BE 6A              byte 'I' ^ RE
                   < elite.a99
2451                      .char ' '
     **** ****     > CHAR
0004 07BF   03            byte ' ' ^ RE
                   < elite.a99
2452                      .char 'T'
     **** ****     > CHAR
0004 07C0 77              byte 'T' ^ RE
                   < elite.a99
2453                      .char ' '
     **** ****     > CHAR
0004 07C1   03            byte ' ' ^ RE
                   < elite.a99
2454                      .char 'E'
     **** ****     > CHAR
0004 07C2 66              byte 'E' ^ RE
                   < elite.a99
2455                      .char ' '
     **** ****     > CHAR
0004 07C3   03            byte ' ' ^ RE
                   < elite.a99
2456                      .char '-'
     **** ****     > CHAR
0004 07C4 0E              byte '-' ^ RE
                   < elite.a99
2457                      .char '-'
     **** ****     > CHAR
0004 07C5   0E            byte '-' ^ RE
                   < elite.a99
2458                      .char '-'
     **** ****     > CHAR
0004 07C6 0E              byte '-' ^ RE
                   < elite.a99
2459                      .char '-'
     **** ****     > CHAR
0004 07C7   0E            byte '-' ^ RE
                   < elite.a99
2460 07C8 00              byte >00
2461               
2462                      .char 'P'                                           ; Token 145:    "PRESENT"
     **** ****     > CHAR
0004 07C9   73            byte 'P' ^ RE
                   < elite.a99
2463 07CA AD              byte 142 ^ RE                                       ; TWOK 'R', 'E'
2464                      .char 'S'                                           ; Encoded as:   "P<142>S<146>T"
     **** ****     > CHAR
0004 07CB   70            byte 'S' ^ RE
                   < elite.a99
2465 07CC B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2466                      .char 'T'
     **** ****     > CHAR
0004 07CD   77            byte 'T' ^ RE
                   < elite.a99
2467 07CE 00              byte >00
2468               
2469                      .cont 8                                             ; Token 146:    "{all caps}GAME OVER"
     **** ****     > CONT
0001 07CF   2B            byte 8 ^ RE
                   < elite.a99
2470                      .char 'G'                                           ;
     **** ****     > CHAR
0004 07D0 64              byte 'G' ^ RE
                   < elite.a99
2471                      .char 'A'                                           ; Encoded as:   "{8}GAME O<150>R"
     **** ****     > CHAR
0004 07D1   62            byte 'A' ^ RE
                   < elite.a99
2472                      .char 'M'
     **** ****     > CHAR
0004 07D2 6E              byte 'M' ^ RE
                   < elite.a99
2473                      .char 'E'
     **** ****     > CHAR
0004 07D3   66            byte 'E' ^ RE
                   < elite.a99
2474                      .char ' '
     **** ****     > CHAR
0004 07D4 03              byte ' ' ^ RE
                   < elite.a99
2475                      .char 'O'
     **** ****     > CHAR
0004 07D5   6C            byte 'O' ^ RE
                   < elite.a99
2476 07D6 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2477                      .char 'R'
     **** ****     > CHAR
0004 07D7   71            byte 'R' ^ RE
                   < elite.a99
2478 07D8 00              byte >00
2479               
2480                      .char 'P'                                           ; Token 147:    "PRESS FIRE OR SPACE,COMMANDER.{crlf}
     **** ****     > CHAR
0004 07D9   73            byte 'P' ^ RE
                   < elite.a99
2481                      .char 'R'                                           ; {crlf}
     **** ****     > CHAR
0004 07DA 71              byte 'R' ^ RE
                   < elite.a99
2482 07DB   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' "
2483                      .char 'S'                                           ;
     **** ****     > CHAR
0004 07DC 70              byte 'S' ^ RE
                   < elite.a99
2484                      .char ' '                                           ; Encoded as:   "PR<137>S FI<142> <153> SPA<133>,[92].
     **** ****     > CHAR
0004 07DD   03            byte ' ' ^ RE
                   < elite.a99
2485                      .char 'F'                                           ; {13}{13}"
     **** ****     > CHAR
0004 07DE 65              byte 'F' ^ RE
                   < elite.a99
2486                      .char 'I'
     **** ****     > CHAR
0004 07DF   6A            byte 'I' ^ RE
                   < elite.a99
2487 07E0 AD              byte 142 ^ RE                                       ; TWOK 'R', 'E' null
2488                      .char ' '
     **** ****     > CHAR
0004 07E1   03            byte ' ' ^ RE
                   < elite.a99
2489 07E2 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2490                      .char ' '
     **** ****     > CHAR
0004 07E3   03            byte ' ' ^ RE
                   < elite.a99
2491                      .char 'S'
     **** ****     > CHAR
0004 07E4 70              byte 'S' ^ RE
                   < elite.a99
2492                      .char 'P'
     **** ****     > CHAR
0004 07E5   73            byte 'P' ^ RE
                   < elite.a99
2493                      .char 'A'
     **** ****     > CHAR
0004 07E6 62              byte 'A' ^ RE
                   < elite.a99
2494 07E7   A6            byte 133 ^ RE                                       ; TWOK 'C', 'E' null
2495                      .char ','
     **** ****     > CHAR
0004 07E8 0F              byte ',' ^ RE
                   < elite.a99
2496                      .rtok 92
     **** ****     > RTOK
0003 07E9   DF            byte (92 + 160) ^ RE
                   < elite.a99
2497                      .char '.'
     **** ****     > CHAR
0004 07EA 0D              byte '.' ^ RE
                   < elite.a99
2498                      .cont 13
     **** ****     > CONT
0001 07EB   2E            byte 13 ^ RE
                   < elite.a99
2499                      .cont 13
     **** ****     > CONT
0001 07EC 2E              byte 13 ^ RE
                   < elite.a99
2500 07ED   00            byte >00
2501               
2502                      .char '('                                           ; Token 148:    "(C) ACORNSOFT 1984"
     **** ****     > CHAR
0004 07EE 0B              byte '(' ^ RE
                   < elite.a99
2503                      .char 'C'                                           ;
     **** ****     > CHAR
0004 07EF   60            byte 'C' ^ RE
                   < elite.a99
2504                      .char ')'                                           ; Encoded as:   "(C) AC<153>N<135>FT 1984"
     **** ****     > CHAR
0004 07F0 0A              byte ')' ^ RE
                   < elite.a99
2505                      .char ' '
     **** ****     > CHAR
0004 07F1   03            byte ' ' ^ RE
                   < elite.a99
2506                      .char 'A'
     **** ****     > CHAR
0004 07F2 62              byte 'A' ^ RE
                   < elite.a99
2507                      .char 'C'
     **** ****     > CHAR
0004 07F3   60            byte 'C' ^ RE
                   < elite.a99
2508 07F4 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2509                      .char 'N'
     **** ****     > CHAR
0004 07F5   6D            byte 'N' ^ RE
                   < elite.a99
2510 07F6 A4              byte 135 ^ RE                                       ; TWOK 'S', 'O' null
2511                      .char 'F'
     **** ****     > CHAR
0004 07F7   65            byte 'F' ^ RE
                   < elite.a99
2512                      .char 'T'
     **** ****     > CHAR
0004 07F8 77              byte 'T' ^ RE
                   < elite.a99
2513                      .char ' '
     **** ****     > CHAR
0004 07F9   03            byte ' ' ^ RE
                   < elite.a99
2514                      .char '1'
     **** ****     > CHAR
0004 07FA 12              byte '1' ^ RE
                   < elite.a99
2515                      .char '9'
     **** ****     > CHAR
0004 07FB   1A            byte '9' ^ RE
                   < elite.a99
2516                      .char '8'
     **** ****     > CHAR
0004 07FC 1B              byte '8' ^ RE
                   < elite.a99
2517                      .char '4'
     **** ****     > CHAR
0004 07FD   17            byte '4' ^ RE
                   < elite.a99
2518 07FE 00              byte >00
2519               
2520               * ******************************************************************************
2521               *
2522               * Save WORDS9.bin
2523               *
2524               * ******************************************************************************
2525               
2526                      ; PRINT "WORDS9"
2527                      ; PRINT "Assembled at ", ~CODE_WORDS%
2528                      ; PRINT "Ends at ", ~P%
2529                      ; PRINT "Code size is ", ~(P% - CODE_WORDS%)
2530                      ; PRINT "Execute at ", ~LOAD_WORDS%
2531                      ; PRINT "Reload at ", ~LOAD_WORDS%
2532               
2533                      ; PRINT "S.WORDS9 ",~CODE_WORDS%," ",~P%," ",~LOAD_WORDS%," ",~LOAD_WORDS%
2534                      ; SAVE "3-assembled-output/WORDS9.bin", CODE_WORDS%, P%, LOAD_WORDS%
2535               
2536               * ******************************************************************************
2537               *
2538               * Name: K%
2539               * Type: Workspace
2540               * Address: &0900 to &0AAF
2541               * Category: Workspaces
2542               * Summary: Ship data blocks and ship line heaps
2543               * Deep dive: Ship data blocks
2544               * The local bubble of universe
2545               *
2546               * ------------------------------------------------------------------------------
2547               *
2548               * Contains ship data for all the ships, planets, suns and space stations in our
2549               * local bubble of universe, along with their corresponding ship line heaps.
2550               *
2551               * The blocks are pointed to by the lookup table at location UNIV. The first 432
2552               * bytes of the K% workspace hold ship data on up to 12 ships, with 36 (NI%)
2553               * bytes per ship, and the ship line heap grows downwards from WP at the end of
2554               * the K% workspace.
2555               *
2556               * See the deep dive on "Ship data blocks" for details on ship data blocks, and
2557               * the deep dive on "The local bubble of universe" for details of how Elite
2558               * stores the local universe in K%, FRIN and UNIV.
2559               *
2560               * ******************************************************************************
2561               
2562                      aorg K.
2563               
2564 0900                 bss NOSH * NI.                                      ; Ship data blocks and ship line heap
2565               
2566               * ******************************************************************************
2567               *
2568               * Name: WP
2569               * Type: Workspace
2570               * Address: &0D40 to &0F33
2571               * Category: Workspaces
2572               * Summary: Ship slots, variables
2573               *
2574               * ******************************************************************************
2575               
2576                      aorg WP.
2577               
2578 0D40                 bss 0                                               ; The start of the WP workspace
2579               
2580               FRIN:
2581 0D40                 bss NOSH + 1                                        ; Slots for the ships in the local bubble of universe
2582                                                                          ;
2583                                                                          ; There are #NOSH + 1 slots, but the ship-spawning
2584                                                                          ; routine at NWSHP only populates #NOSH of them, so
2585                                                                          ; there are 13 slots but only 12 are used for ships
2586                                                                          ; (the last slot is effectively used as a null
2587                                                                          ; terminator when shuffling the slots down in the
2588                                                                          ; KILLSHP routine)
2589                                                                          ;
2590                                                                          ; See the deep dive on "The local bubble of universe"
2591                                                                          ; for details of how Elite stores the local universe in
2592                                                                          ; FRIN, UNIV and K%
2593               
2594               CABTMP:
2595 0D4D                 bss 0                                               ; Cabin temperature
2596                                                                          ;
2597                                                                          ; The ambient cabin temperature in deep space is 30,
2598                                                                          ; which is displayed as one notch on the dashboard bar
2599                                                                          ;
2600                                                                          ; We get higher temperatures closer to the sun
2601                                                                          ;
2602                                                                          ; CABTMP shares a location with MANY, but that's OK as
2603                                                                          ; MANY+0 would contain the number of ships of type 0,
2604                                                                          ; and as there is no ship type 0 (they start at 1), the
2605                                                                          ; byte at MANY+0 is not used for storing a ship type
2606                                                                          ; and can be used for the cabin temperature instead
2607               
2608               MANY:
2609 0D4D                 bss SST                                             ; The number of ships of each type in the local bubble
2610                                                                          ; of universe
2611                                                                          ;
2612                                                                          ; The number of ships of type X in the local bubble is
2613                                                                          ; stored at MANY+X
2614                                                                          ;
2615                                                                          ; See the deep dive on "Ship blueprints" for a list of
2616                                                                          ; ship types
2617               
2618               SSPR:
2619 0D55                 bss NTY + 1 - SST                                   ; "Space station present" flag
2620                                                                          ;
2621                                                                          ; * Non-zero if we are inside the space station's safe
2622                                                                          ; zone
2623                                                                          ;
2624                                                                          ; * 0 if we aren't (in which case we can show the sun)
2625                                                                          ;
2626                                                                          ; This flag is at MANY+SST, which is no coincidence, as
2627                                                                          ; MANY+SST is a count of how many space stations there
2628                                                                          ; are in our local bubble, which is the same as saying
2629                                                                          ; "space station present"
2630               
2631               ECMP:
2632 0D5B                 bss 1                                               ; Our E.C.M. status
2633                                                                          ;
2634                                                                          ; * 0 = E.C.M. is off
2635                                                                          ;
2636                                                                          ; * Non-zero = E.C.M. is on
2637               
2638               MJ:
2639 0D5C                 bss 1                                               ; Are we in witchspace (i.e. have we mis-jumped)?
2640                                                                          ;
2641                                                                          ; * 0 = no, we are in normal space
2642                                                                          ;
2643                                                                          ; * &FF = yes, we are in witchspace
2644               
2645               LAS2:
2646 0D5D                 bss 1                                               ; Laser power for the current laser
2647                                                                          ;
2648                                                                          ; * Bits 0-6 contain the laser power of the current
2649                                                                          ; space view
2650                                                                          ;
2651                                                                          ; * Bit 7 denotes whether or not the laser pulses:
2652                                                                          ;
2653                                                                          ; * 0 = pulsing laser
2654                                                                          ;
2655                                                                          ; * 1 = beam laser (i.e. always on)
2656               
2657               MSAR:
2658 0D5E                 bss 1                                               ; The targeting state of our leftmost missile
2659                                                                          ;
2660                                                                          ; * 0 = missile is not looking for a target, or it
2661                                                                          ; already has a target lock (indicator is not
2662                                                                          ; yellow/white)
2663                                                                          ;
2664                                                                          ; * Non-zero = missile is currently looking for a
2665                                                                          ; target (indicator is yellow/white)
2666               
2667               VIEW:
2668 0D5F                 bss 1                                               ; The number of the current space view
2669                                                                          ;
2670                                                                          ; * 0 = front
2671                                                                          ; * 1 = rear
2672                                                                          ; * 2 = left
2673                                                                          ; * 3 = right
2674               
2675               LASCT:
2676 0D60                 bss 1                                               ; The laser pulse count for the current laser
2677                                                                          ;
2678                                                                          ; This is a counter that defines the gap between the
2679                                                                          ; pulses of a pulse laser. It is set as follows:
2680                                                                          ;
2681                                                                          ; * 0 for a beam laser
2682                                                                          ;
2683                                                                          ; * 10 for a pulse laser
2684                                                                          ;
2685                                                                          ; It gets decremented every vertical sync (in the LINSCN
2686                                                                          ; routine, which is called 50 times a second) and is set
2687                                                                          ; to a non-zero value for pulse lasers only
2688                                                                          ;
2689                                                                          ; The laser only fires when the value of LASCT hits
2690                                                                          ; zero, so for pulse lasers with a value of 10, that
2691                                                                          ; means the laser fires once every 10 vertical syncs (or
2692                                                                          ; 5 times a second)
2693                                                                          ;
2694                                                                          ; In comparison, beam lasers fire continuously as the
2695                                                                          ; value of LASCT is always 0
2696               
2697               GNTMP:
2698 0D61                 bss 1                                               ; Laser temperature (or "gun temperature")
2699                                                                          ;
2700                                                                          ; If the laser temperature exceeds 242 then the laser
2701                                                                          ; overheats and cannot be fired again until it has
2702                                                                          ; cooled down
2703               
2704               HFX:
2705 0D62                 bss 1                                               ; A flag that toggles the hyperspace colour effect
2706                                                                          ;
2707                                                                          ; * 0 = no colour effect
2708                                                                          ;
2709                                                                          ; * Non-zero = hyperspace colour effect enabled
2710                                                                          ;
2711                                                                          ; When HFX is set to 1, the mode 4 screen that makes
2712                                                                          ; up the top part of the display is temporarily switched
2713                                                                          ; to mode 5 (the same screen mode as the dashboard),
2714                                                                          ; which has the effect of blurring and colouring the
2715                                                                          ; hyperspace rings in the top part of the screen. The
2716                                                                          ; code to do this is in the LINSCN routine, which is
2717                                                                          ; called as part of the screen mode routine at IRQ1.
2718                                                                          ; It's in LINSCN that HFX is checked, and if it is
2719                                                                          ; non-zero, the top part of the screen is not switched
2720                                                                          ; to mode 4, thus leaving the top part of the screen in
2721                                                                          ; the more colourful mode 5
2722               
2723               EV:
2724 0D63                 bss 1                                               ; The "extra vessels" spawning counter
2725                                                                          ;
2726                                                                          ; This counter is set to 0 on arrival in a system and
2727                                                                          ; following an in-system jump, and is bumped up when we
2728                                                                          ; spawn bounty hunters or pirates (i.e. "extra vessels")
2729                                                                          ;
2730                                                                          ; It decreases by 1 each time we consider spawning more
2731                                                                          ; "extra vessels" in part 4 of the main game loop, so
2732                                                                          ; increasing the value of EV has the effect of delaying
2733                                                                          ; the spawning of more vessels
2734                                                                          ;
2735                                                                          ; In other words, this counter stops bounty hunters and
2736                                                                          ; pirates from continually appearing, and ensures that
2737                                                                          ; there's a delay between spawnings
2738               
2739               DLY:
2740 0D64                 bss 1                                               ; In-flight message delay
2741                                                                          ;
2742                                                                          ; This counter is used to keep an in-flight message up
2743                                                                          ; for a specified time before it gets removed. The value
2744                                                                          ; in DLY is decremented each time we start another
2745                                                                          ; iteration of the main game loop at TT100
2746               
2747               de_:
2748 0D65                 bss 1                                               ; Equipment destruction flag
2749                                                                          ;
2750                                                                          ; * Bit 1 denotes whether or not the in-flight message
2751                                                                          ; about to be shown by the MESS routine is about
2752                                                                          ; destroyed equipment:
2753                                                                          ;
2754                                                                          ; * 0 = the message is shown normally
2755                                                                          ;
2756                                                                          ; * 1 = the string " DESTROYED" gets added to the
2757                                                                          ; end of the message
2758               
2759               LSX:
2760 0D66                 bss 0                                               ; LSX is an alias that points to the first byte of the
2761                                                                          ; sun line heap at LSO
2762                                                                          ;
2763                                                                          ; * &FF indicates the sun line heap is empty
2764                                                                          ;
2765                                                                          ; * Otherwise the LSO heap contains the line data for
2766                                                                          ; the sun
2767               
2768               LSO:
2769 0D66                 bss 192                                             ; The ship line heap for the space station (see NWSPS)
2770                                                                          ; and the sun line heap (see SUN)
2771                                                                          ;
2772                                                                          ; The spaces can be shared as our local bubble of
2773                                                                          ; universe can support either the sun or a space
2774                                                                          ; station, but not both
2775               
2776               LSX2:
2777 0E26                 bss 78                                              ; The ball line heap for storing x-coordinates (see the
2778                                                                          ; deep dive on "The ball line heap" for details)
2779               
2780               LSY2:
2781 0E74                 bss 78                                              ; The ball line heap for storing y-coordinates (see the
2782                                                                          ; deep dive on "The ball line heap" for details)
2783               
2784               SY:
2785 0EC2                 bss NOST + 1                                        ; This is where we store the y_hi coordinates for all
2786                                                                          ; the stardust particles
2787               
2788               SYL:
2789 0ED5                 bss NOST + 1                                        ; This is where we store the y_lo coordinates for all
2790                                                                          ; the stardust particles
2791               
2792               SZ:
2793 0EE8                 bss NOST + 1                                        ; This is where we store the z_hi coordinates for all
2794                                                                          ; the stardust particles
2795               
2796               SZL:
2797 0EFB                 bss NOST + 1                                        ; This is where we store the z_lo coordinates for all
2798                                                                          ; the stardust particles
2799               
2800               XSAV2:
2801 0F0E                 bss 1                                               ; Temporary storage, used for storing the value of the X
2802                                                                          ; register in the TT26 routine
2803               
2804               YSAV2:
2805 0F0F                 bss 1                                               ; Temporary storage, used for storing the value of the Y
2806                                                                          ; register in the TT26 routine
2807               
2808               MCH:
2809 0F10                 bss 1                                               ; The text token number of the in-flight message that is
2810                                                                          ; currently being shown, and which will be removed by
2811                                                                          ; the me2 routine when the counter in DLY reaches zero
2812               
2813               FSH:
2814 0F11                 bss 1                                               ; Forward shield status
2815                                                                          ;
2816                                                                          ; * 0 = empty
2817                                                                          ;
2818                                                                          ; * &FF = full
2819               
2820               ASH:
2821 0F12                 bss 1                                               ; Aft shield status
2822                                                                          ;
2823                                                                          ; * 0 = empty
2824                                                                          ;
2825                                                                          ; * &FF = full
2826               
2827               ENERGY:
2828 0F13                 bss 1                                               ; Energy bank status
2829                                                                          ;
2830                                                                          ; * 0 = empty
2831                                                                          ;
2832                                                                          ; * &FF = full
2833               
2834               LASX:
2835 0F14                 bss 1                                               ; The x-coordinate of the tip of the laser line
2836               
2837               LASY:
2838 0F15                 bss 1                                               ; The y-coordinate of the tip of the laser line
2839               
2840               COMX:
2841 0F16                 bss 1                                               ; The x-coordinate of the compass dot
2842               
2843               COMY:
2844 0F17                 bss 1                                               ; The y-coordinate of the compass dot
2845               
2846               QQ24:
2847 0F18                 bss 1                                               ; Temporary storage, used to store the current market
2848                                                                          ; item's price in routine TT151
2849               
2850               QQ25:
2851 0F19                 bss 1                                               ; Temporary storage, used to store the current market
2852                                                                          ; item's availability in routine TT151
2853               
2854               QQ28:
2855 0F1A                 bss 1                                               ; The current system's economy (0-7)
2856                                                                          ;
2857                                                                          ; * 0 = Rich Industrial
2858                                                                          ; * 1 = Average Industrial
2859                                                                          ; * 2 = Poor Industrial
2860                                                                          ; * 3 = Mainly Industrial
2861                                                                          ; * 4 = Mainly Agricultural
2862                                                                          ; * 5 = Rich Agricultural
2863                                                                          ; * 6 = Average Agricultural
2864                                                                          ; * 7 = Poor Agricultural
2865                                                                          ;
2866                                                                          ; See the deep dive on "Generating system data" for more
2867                                                                          ; information on economies
2868               
2869               QQ29:
2870 0F1B                 bss 1                                               ; Temporary storage, used in a number of places
2871               
2872               gov_:
2873 0F1C                 bss 1                                               ; The current system's government type (0-7)
2874                                                                          ;
2875                                                                          ; See the deep dive on "Generating system data" for
2876                                                                          ; details of the various government types
2877               
2878               tek_:
2879 0F1D                 bss 1                                               ; The current system's tech level (0-14)
2880                                                                          ;
2881                                                                          ; See the deep dive on "Generating system data" for more
2882                                                                          ; information on tech levels
2883               
2884               SLSP:
2885 0F1E                 bss 2                                               ; The address of the bottom of the ship line heap
2886                                                                          ;
2887                                                                          ; The ship line heap is a descending block of memory
2888                                                                          ; that starts at WP and descends down to SLSP. It can be
2889                                                                          ; extended downwards by the NWSHP routine when adding
2890                                                                          ; new ships (and their associated ship line heaps), in
2891                                                                          ; which case SLSP is lowered to provide more heap space,
2892                                                                          ; assuming there is enough free memory to do so
2893               
2894               XX24:
2895 0F20                 bss 1                                               ; This byte appears to be unused
2896               
2897               ALTIT:
2898 0F21                 bss 1                                               ; Our altitude above the surface of the planet or sun
2899                                                                          ;
2900                                                                          ; * 255 = we are a long way above the surface
2901                                                                          ;
2902                                                                          ; * 1-254 = our altitude as the square root of:
2903                                                                          ;
2904                                                                          ; x_hi^2 + y_hi^2 + z_hi^2 - 6^2
2905                                                                          ;
2906                                                                          ; where our ship is at the origin, the centre of the
2907                                                                          ; planet/sun is at (x_hi, y_hi, z_hi), and the
2908                                                                          ; radius of the planet/sun is 6
2909                                                                          ;
2910                                                                          ; * 0 = we have crashed into the surface
2911               
2912               QQ2:
2913 0F22                 bss 6                                               ; The three 16-bit seeds for the current system, i.e.
2914                                                                          ; the one we are currently in
2915                                                                          ;
2916                                                                          ; See the deep dives on "Galaxy and system seeds" and
2917                                                                          ; "Twisting the system seeds" for more details
2918               
2919               QQ3:
2920 0F28                 bss 1                                               ; The selected system's economy (0-7)
2921                                                                          ;
2922                                                                          ; * 0 = Rich Industrial
2923                                                                          ; * 1 = Average Industrial
2924                                                                          ; * 2 = Poor Industrial
2925                                                                          ; * 3 = Mainly Industrial
2926                                                                          ; * 4 = Mainly Agricultural
2927                                                                          ; * 5 = Rich Agricultural
2928                                                                          ; * 6 = Average Agricultural
2929                                                                          ; * 7 = Poor Agricultural
2930                                                                          ;
2931                                                                          ; See the deep dive on "Generating system data" for more
2932                                                                          ; information on economies
2933               
2934               QQ4:
2935 0F29                 bss 1                                               ; The selected system's government (0-7)
2936                                                                          ;
2937                                                                          ; See the deep dive on "Generating system data" for more
2938                                                                          ; details of the various government types
2939               
2940               QQ5:
2941 0F2A                 bss 1                                               ; The selected system's tech level (0-14)
2942                                                                          ;
2943                                                                          ; See the deep dive on "Generating system data" for more
2944                                                                          ; information on tech levels
2945               
2946               QQ6:
2947 0F2B                 bss 2                                               ; The selected system's population in billions * 10
2948                                                                          ; (1-71), so the maximum population is 7.1 billion
2949                                                                          ;
2950                                                                          ; See the deep dive on "Generating system data" for more
2951                                                                          ; details on population levels
2952               
2953               QQ7:
2954 0F2D                 bss 2                                               ; The selected system's productivity in M CR (96-62480)
2955                                                                          ;
2956                                                                          ; See the deep dive on "Generating system data" for more
2957                                                                          ; details about productivity levels
2958               
2959               QQ8:
2960 0F2F                 bss 2                                               ; The distance from the current system to the selected
2961                                                                          ; system in light years * 10, stored as a 16-bit number
2962                                                                          ;
2963                                                                          ; The distance will be 0 if the selected system is the
2964                                                                          ; current system
2965                                                                          ;
2966                                                                          ; The galaxy chart is 102.4 light years wide and 51.2
2967                                                                          ; light years tall (see the intra-system distance
2968                                                                          ; calculations in routine TT111 for details), which
2969                                                                          ; equates to 1024 x 512 in terms of QQ8
2970               
2971               QQ9:
2972 0F31                 bss 1                                               ; The galactic x-coordinate of the crosshairs in the
2973                                                                          ; galaxy chart (and, most of the time, the selected
2974                                                                          ; system's galactic x-coordinate)
2975               
2976               QQ10:
2977 0F32                 bss 1                                               ; The galactic y-coordinate of the crosshairs in the
2978                                                                          ; galaxy chart (and, most of the time, the selected
2979                                                                          ; system's galactic y-coordinate)
2980               
2981               NOSTM:
2982 0F33                 bss 1                                               ; The number of stardust particles shown on screen,
2983                                                                          ; which is 18 (#NOST) for normal space, and 3 for
2984                                                                          ; witchspace
2985               
2986                      ; PRINT "WP workspace from  ", ~WP," to ", ~P%
2987               
2988               * ******************************************************************************
2989               *
2990               * ELITE A FILE
2991               *
2992               * Produces the binary file ELTA.bin that gets loaded by elite-bcfs.asm.
2993               *
2994               * The main game code (ELITE A through G, plus the ship data) is loaded at &1128
2995               * and is moved down to &0F40 as part of elite-loader.asm.
2996               *
2997               * ******************************************************************************
2998               
2999                      aorg CODE.
3000               
3001               LOAD_A.:
3002                      equ LOAD.
3003               
3004               * ******************************************************************************
3005               *
3006               * Name: S%
3007               * Type: Workspace
3008               * Address: &0F40 to &0F50
3009               * Category: Workspaces
3010               * Summary: Vector addresses, compass colour and configuration settings
3011               *
3012               * ------------------------------------------------------------------------------
3013               *
3014               * Contains addresses that are used by the loader to set up vectors, the current
3015               * compass colour, and the game's configuration settings.
3016               *
3017               * ******************************************************************************
3018               
3019               S.:
3020 0F40 C5A4            data TT170                                          ; The entry point for the main game; once the main code
3021                                                                          ; has been loaded, decrypted and moved to the right
3022                                                                          ; place by elite-loader.asm, the game is started by a
3023                                                                          ; JMP (S%) instruction, which jumps to the main entry
3024                                                                          ; point at TT170 via this location
3025               
3026 0F42 3172            data TT26                                           ; WRCHV is set to point here by elite-loader.asm
3027               
3028 0F44 35EA            data IRQ1                                           ; IRQ1V is set to point here by elite-loader.asm
3029               
3030 0F46 C5AC            data BR1                                            ; BRKV is set to point here by elite-loader.asm
3031               
3032               COMC:
3033 0F48                 bss 1                                               ; The colour of the dot on the compass
3034                                                                          ;
3035                                                                          ; * &F0 = the object in the compass is in front of us,
3036                                                                          ; so the dot is yellow/white
3037                                                                          ;
3038                                                                          ; * &FF = the object in the compass is behind us, so
3039                                                                          ; the dot is green/cyan
3040               
3041               DNOIZ:
3042 0F49                 bss 1                                               ; Sound on/off configuration setting
3043                                                                          ;
3044                                                                          ; * 0 = sound is on (default)
3045                                                                          ;
3046                                                                          ; * Non-zero = sound is off
3047                                                                          ;
3048                                                                          ; Toggled by pressing "S" when paused, see the DK4
3049                                                                          ; routine for details
3050               
3051               DAMP:
3052 0F4A                 bss 1                                               ; Keyboard damping configuration setting
3053                                                                          ;
3054                                                                          ; * 0 = damping is enabled (default)
3055                                                                          ;
3056                                                                          ; * &FF = damping is disabled
3057                                                                          ;
3058                                                                          ; Toggled by pressing CAPS LOCK when paused, see the
3059                                                                          ; DKS3 routine for details
3060               
3061               DJD:
3062 0F4B                 bss 1                                               ; Keyboard auto-recentre configuration setting
3063                                                                          ;
3064                                                                          ; * 0 = auto-recentre is enabled (default)
3065                                                                          ;
3066                                                                          ; * &FF = auto-recentre is disabled
3067                                                                          ;
3068                                                                          ; Toggled by pressing "A" when paused, see the DKS3
3069                                                                          ; routine for details
3070               
3071               PATG:
3072 0F4C                 bss 1                                               ; Configuration setting to show the author names on the
3073                                                                          ; start-up screen and enable manual hyperspace mis-jumps
3074                                                                          ;
3075                                                                          ; * 0 = no author names or manual mis-jumps (default)
3076                                                                          ;
3077                                                                          ; * &FF = show author names and allow manual mis-jumps
3078                                                                          ;
3079                                                                          ; Toggled by pressing "X" when paused, see the DKS3
3080                                                                          ; routine for details
3081                                                                          ;
3082                                                                          ; This needs to be turned on for manual mis-jumps to be
3083                                                                          ; possible. To do a manual mis-jump, first toggle the
3084                                                                          ; author display by pausing the game (COPY) and pressing
3085                                                                          ; "X", and during the next hyperspace, hold down CTRL to
3086                                                                          ; force a mis-jump. See routine ee5 for the "AND PATG"
3087                                                                          ; instruction that implements this logic
3088               
3089               FLH:
3090 0F4D                 bss 1                                               ; Flashing console bars configuration setting
3091                                                                          ;
3092                                                                          ; * 0 = static bars (default)
3093                                                                          ;
3094                                                                          ; * &FF = flashing bars
3095                                                                          ;
3096                                                                          ; Toggled by pressing "F" when paused, see the DKS3
3097                                                                          ; routine for details
3098               
3099               JSTGY:
3100 0F4E                 bss 1                                               ; Reverse joystick Y-channel configuration setting
3101                                                                          ;
3102                                                                          ; * 0 = standard Y-channel (default)
3103                                                                          ;
3104                                                                          ; * &FF = reversed Y-channel
3105                                                                          ;
3106                                                                          ; Toggled by pressing "Y" when paused, see the DKS3
3107                                                                          ; routine for details
3108               
3109               JSTE:
3110 0F4F                 bss 1                                               ; Reverse both joystick channels configuration setting
3111                                                                          ;
3112                                                                          ; * 0 = standard channels (default)
3113                                                                          ;
3114                                                                          ; * &FF = reversed channels
3115                                                                          ;
3116                                                                          ; Toggled by pressing "J" when paused, see the DKS3
3117                                                                          ; routine for details
3118               
3119               JSTK:
3120 0F50                 bss 1                                               ; Keyboard or joystick configuration setting
3121                                                                          ;
3122                                                                          ; * 0 = keyboard (default)
3123                                                                          ;
3124                                                                          ; * &FF = joystick
3125                                                                          ;
3126                                                                          ; Toggled by pressing "K" when paused, see the DKS3
3127                                                                          ; routine for details
3128               
3129               * ******************************************************************************
3130               *
3131               * Name: Main flight loop (Part 1 of 16)
3132               * Type: Subroutine
3133               * Category: Main loop
3134               * Summary: Seed the random number generator
3135               * Deep dive: Program flow of the main game loop
3136               * Generating random numbers
3137               *
3138               * ------------------------------------------------------------------------------
3139               *
3140               * The main flight loop covers most of the flight-specific aspects of Elite. This
3141               * section covers the following:
3142               *
3143               * * Seed the random number generator
3144               *
3145               * ------------------------------------------------------------------------------
3146               *
3147               * Other entry points:
3148               *
3149               * M%                  The entry point for the main flight loop
3150               *
3151               * ******************************************************************************
3152               
3153               M.:
3154 0F52 D020  22        movb @K.,ra                     ; LDA K%            ; We want to seed the random number generator with a
     0F54 0900     
3155                                                                          ; pretty random number, so fetch the contents of K%,
3156                                                                          ; which is the x_lo coordinate of the planet. This value
3157                                                                          ; will be fairly unpredictable, so it's a pretty good
3158                                                                          ; candidate
3159               
3160 0F56 D800  22        movb ra,@RAND                   ; STA RAND          ; Store the seed in the first byte of the four-byte
     0F58 0000     
3161                                                                          ; random number seed that's stored in RAND
3162               
3163               * ******************************************************************************
3164               *
3165               * Name: Main flight loop (Part 2 of 16)
3166               * Type: Subroutine
3167               * Category: Main loop
3168               * Summary: Calculate the alpha and beta angles from the current pitch and
3169               * roll of our ship
3170               * Deep dive: Program flow of the main game loop
3171               * Pitching and rolling
3172               *
3173               * ------------------------------------------------------------------------------
3174               *
3175               * The main flight loop covers most of the flight-specific aspects of Elite. This
3176               * section covers the following:
3177               *
3178               * * Calculate the alpha and beta angles from the current pitch and roll
3179               *
3180               * Here we take the current rate of pitch and roll, as set by the joystick or
3181               * keyboard, and convert them into alpha and beta angles that we can use in the
3182               * matrix functions to rotate space around our ship. The alpha angle covers
3183               * roll, while the beta angle covers pitch (there is no yaw in this version of
3184               * Elite). The angles are in radians, which allows us to use the small angle
3185               * approximation when moving objects in the sky (see the MVEIT routine for more
3186               * on this). Also, the signs of the two angles are stored separately, in both
3187               * the sign and the flipped sign, as this makes calculations easier.
3188               *
3189               * ******************************************************************************
3190               
3191 0F5A D060  22        movb @JSTX,rx                   ; LDX JSTX          ; Set X to the current rate of roll in JSTX
     0F5C 009C     
3192               
3193 0F5E 0206  12        li   rtmp,cntr_                 ; JSR cntr          ; Apply keyboard damping twice (if enabled) so the roll
     0F60 4714     
3194 0F62 06A0  24        bl   @jsr                       ;
     0F64 FF10     
3195 0F66 0206  12        li   rtmp,cntr_                 ; JSR cntr          ; rate in X creeps towards the centre by 2
     0F68 4714     
3196 0F6A 06A0  24        bl   @jsr                       ;
     0F6C FF10     
3197               
3198                                                                          ; The roll rate in JSTX increases if we press ">" (and
3199                                                                          ; the RL indicator on the dashboard goes to the right)
3200                                                                          ;
3201                                                                          ; This rolls our ship to the right (clockwise), but we
3202                                                                          ; actually implement this by rolling everything else
3203                                                                          ; to the left (anti-clockwise), so a positive roll rate
3204                                                                          ; in JSTX translates to a negative roll angle alpha
3205               
3206 0F6E D001  14        movb rx,ra                      ; TXA               ; Set A and Y to the roll rate but with the sign bit
3207                      .eoi (>80*256)                  ; EOR #%10000000    ; flipped (i.e. set them to the sign we want for alpha)
     **** ****     > EOI
0001 0F70 0206  12        li   rtmp,(>80*256)
     0F72 8000     
0002 0F74 2806  14        xor  rtmp,ra
                   < elite.a99
3208 0F76 D080  14        movb ra,ry                      ; TAY
3209               
3210 0F78 0240  14        andi ra,>80*256                 ; AND #%10000000    ; Extract the flipped sign of the roll rate and store
     0F7A 8000     
3211 0F7C D800  22        movb ra,@ALP2                   ; STA ALP2          ; in ALP2 (so ALP2 contains the sign of the roll angle
     0F7E 0088     
3212                                                                          ; alpha)
3213               
3214 0F80 D801  22        movb rx,@JSTX                   ; STX JSTX          ; Update JSTX with the damped value that's still in X
     0F82 009C     
3215               
3216                      .eoi (>80*256)                  ; EOR #%10000000    ; Extract the correct sign of the roll rate and store
     **** ****     > EOI
0001 0F84 0206  12        li   rtmp,(>80*256)
     0F86 8000     
0002 0F88 2806  14        xor  rtmp,ra
                   < elite.a99
3217 0F8A D800  22        movb ra,@ALP2+1                 ; STA ALP2+1        ; in ALP2+1 (so ALP2+1 contains the flipped sign of the
     0F8C 0089     
3218                                                                          ; roll angle alpha)
3219               
3220 0F8E D002  14        movb ry,ra                      ; TYA               ; Set A to the roll rate but with the sign bit flipped
3221               
3222 0F90 1508  10        jgt  B01                        ; BPL B01           ; If the value of A is positive, skip the following
3223                                                                          ; three instructions
3224               
3225                      .eoi (>ff*256)                  ; EOR #%11111111    ; A is negative, so change the sign of A using two's
     **** ****     > EOI
0001 0F92 0206  12        li   rtmp,(>FF*256)
     0F94 FF00     
0002 0F96 2806  14        xor  rtmp,ra
                   < elite.a99
3226                      .clc                            ; CLC               ; complement so that A is now positive and contains
     **** ****     > CLC
0001 0F98 0A13  14        sla  rzero,1
                   < elite.a99
3227                      .adi (>01*256)                  ; ADC #1            ; the absolute value of the roll rate, i.e. |JSTX|
     **** ****     > ADI
0001 0F9A 1701  10        jnc  !
0002 0F9C B004  14        ab   rone,ra
0003               !:
0004 0F9E 0220  14        ai   ra,(>01*256)
     0FA0 0100     
                   < elite.a99
3228               
3229               B01:
3230 0FA2 0910  14        srl  ra,1                       ; LSR A             ; Divide the (positive) roll rate in A by 4
3231 0FA4 0910  14        srl  ra,1                       ; LSR A
3232               
3233 0FA6 0280  14        ci   ra,>08*256                 ; CMP #8            ; If A >= 8, skip the following two instructions
     0FA8 0800     
3234 0FAA 1802  10        joc  B02                        ; BCS B02
3235               
3236 0FAC 0910  14        srl  ra,1                       ; LSR A             ; A < 8, so halve A again
3237               
3238                      .clc                            ; CLC               ; This instruction has no effect, as we only get here
     **** ****     > CLC
0001 0FAE 0A13  14        sla  rzero,1
                   < elite.a99
3239                                                                          ; if the C flag is clear (if it is set, we skip this
3240                                                                          ; instruction)
3241               B02:
3242 0FB0 D800  22        movb ra,@ALP1                   ; STA ALP1          ; Store A in ALP1, so we now have:
     0FB2 0087     
3243                                                                          ;
3244                                                                          ; ALP1 = |JSTX| / 8    if |JSTX| < 32
3245                                                                          ;
3246                                                                          ; ALP1 = |JSTX| / 4    if |JSTX| >= 32
3247                                                                          ;
3248                                                                          ; This means that at lower roll rates, the roll angle is
3249                                                                          ; reduced closer to zero than at higher roll rates,
3250                                                                          ; which gives us finer control over the ship's roll at
3251                                                                          ; lower roll rates
3252                                                                          ;
3253                                                                          ; Because JSTX is in the range -127 to +127, ALP1 is
3254                                                                          ; in the range 0 to 31
3255               
3256 0FB4 F020  22        socb @ALP2,ra                   ; ORA ALP2          ; Store A in ALPHA, but with the sign set to ALP2 (so
     0FB6 0088     
3257 0FB8 D800  22        movb ra,@ALPHA                  ; STA ALPHA         ; ALPHA has a different sign to the actual roll rate)
     0FBA 009E     
3258               
3259 0FBC D060  22        movb @JSTY,rx                   ; LDX JSTY          ; Set X to the current rate of pitch in JSTY
     0FBE 009D     
3260               
3261 0FC0 0206  12        li   rtmp,cntr_                 ; JSR cntr          ; Apply keyboard damping so the pitch rate in X creeps
     0FC2 4714     
3262 0FC4 06A0  24        bl   @jsr                       ;
     0FC6 FF10     
3263                                                                          ; towards the centre by 1
3264               
3265 0FC8 D001  14        movb rx,ra                      ; TXA               ; Set A and Y to the pitch rate but with the sign bit
3266                      .eoi (>80*256)                  ; EOR #%10000000    ; flipped
     **** ****     > EOI
0001 0FCA 0206  12        li   rtmp,(>80*256)
     0FCC 8000     
0002 0FCE 2806  14        xor  rtmp,ra
                   < elite.a99
3267 0FD0 D080  14        movb ra,ry                      ; TAY
3268               
3269 0FD2 0240  14        andi ra,>80*256                 ; AND #%10000000    ; Extract the flipped sign of the pitch rate into A
     0FD4 8000     
3270               
3271 0FD6 D801  22        movb rx,@JSTY                   ; STX JSTY          ; Update JSTY with the damped value that's still in X
     0FD8 009D     
3272               
3273 0FDA D800  22        movb ra,@BET2+1                 ; STA BET2+1        ; Store the flipped sign of the pitch rate in BET2+1
     0FDC 008B     
3274               
3275                      .eoi (>80*256)                  ; EOR #%10000000    ; Extract the correct sign of the pitch rate and store
     **** ****     > EOI
0001 0FDE 0206  12        li   rtmp,(>80*256)
     0FE0 8000     
0002 0FE2 2806  14        xor  rtmp,ra
                   < elite.a99
3276 0FE4 D800  22        movb ra,@BET2                   ; STA BET2          ; it in BET2
     0FE6 008A     
3277               
3278 0FE8 D002  14        movb ry,ra                      ; TYA               ; Set A to the pitch rate but with the sign bit flipped
3279               
3280 0FEA 1503  10        jgt  B03                        ; BPL B03           ; If the value of A is positive, skip the following
3281                                                                          ; instruction
3282               
3283                      .eoi (>ff*256)                  ; EOR #%11111111    ; A is negative, so flip the bits
     **** ****     > EOI
0001 0FEC 0206  12        li   rtmp,(>FF*256)
     0FEE FF00     
0002 0FF0 2806  14        xor  rtmp,ra
                   < elite.a99
3284               
3285               B03:
3286                      .adi (>04*256)                  ; ADC #4            ; Add 4 to the (positive) pitch rate, so the maximum
     **** ****     > ADI
0001 0FF2 1701  10        jnc  !
0002 0FF4 B004  14        ab   rone,ra
0003               !:
0004 0FF6 0220  14        ai   ra,(>04*256)
     0FF8 0400     
                   < elite.a99
3287                                                                          ; value is now up to 131 (rather than 127)
3288               
3289 0FFA 0910  14        srl  ra,1                       ; LSR A             ; Divide the (positive) pitch rate in A by 16
3290 0FFC 0910  14        srl  ra,1                       ; LSR A
3291 0FFE 0910  14        srl  ra,1                       ; LSR A
3292 1000 0910  14        srl  ra,1                       ; LSR A
3293               
3294 1002 0280  14        ci   ra,>03*256                 ; CMP #3            ; If A >= 3, skip the following instruction
     1004 0300     
3295 1006 1801  10        joc  B04                        ; BCS B04
3296               
3297 1008 0910  14        srl  ra,1                       ; LSR A             ; A < 3, so halve A again
3298               
3299               B04:
3300 100A D800  22        movb ra,@BET1                   ; STA BET1          ; Store A in BET1, so we now have:
     100C 002B     
3301                                                                          ;
3302                                                                          ; BET1 = |JSTY| / 32    if |JSTY| < 48
3303                                                                          ;
3304                                                                          ; BET1 = |JSTY| / 16    if |JSTY| >= 48
3305                                                                          ;
3306                                                                          ; This means that at lower pitch rates, the pitch angle
3307                                                                          ; is reduced closer to zero than at higher pitch rates,
3308                                                                          ; which gives us finer control over the ship's pitch at
3309                                                                          ; lower pitch rates
3310                                                                          ;
3311                                                                          ; Because JSTY is in the range -131 to +131, BET1 is in
3312                                                                          ; the range 0 to 8
3313               
3314 100E F020  22        socb @BET2,ra                   ; ORA BET2          ; Store A in BETA, but with the sign set to BET2 (so
     1010 008A     
3315 1012 D800  22        movb ra,@BETA                   ; STA BETA          ; BETA has the same sign as the actual pitch rate)
     1014 002A     
3316               
3317               * ******************************************************************************
3318               *
3319               * Name: Main flight loop (Part 3 of 16)
3320               * Type: Subroutine
3321               * Category: Main loop
3322               * Summary: Scan for flight keys and process the results
3323               * Deep dive: Program flow of the main game loop
3324               * The key logger
3325               *
3326               * ------------------------------------------------------------------------------
3327               *
3328               * The main flight loop covers most of the flight-specific aspects of Elite. This
3329               * section covers the following:
3330               *
3331               * * Scan for flight keys and process the results
3332               *
3333               * Flight keys are logged in the key logger at location KY1 onwards, with a
3334               * non-zero value in the relevant location indicating a key press. See the deep
3335               * dive on "The key logger" for more details.
3336               *
3337               * The key presses that are processed are as follows:
3338               *
3339               * * Space and "?" to speed up and slow down
3340               * * "U", "T" and "M" to disarm, arm and fire missiles
3341               * * TAB to fire an energy bomb
3342               * * ESCAPE to launch an escape pod
3343               * * "J" to initiate an in-system jump
3344               * * "E" to deploy E.C.M. anti-missile countermeasures
3345               * * "C" to use the docking computer
3346               * * "A" to fire lasers
3347               *
3348               * ******************************************************************************
3349               
3350 1016 D020  22        movb @KY2,ra                    ; LDA KY2           ; If Space is being pressed, keep going, otherwise jump
     1018 0043     
3351 101A 1306  10        jeq  MA17                       ; BEQ MA17          ; down to MA17 to skip the following
3352               
3353 101C D020  22        movb @DELTA,ra                  ; LDA DELTA         ; The "go faster" key is being pressed, so first we
     101E 008C     
3354 1020 0280  14        ci   ra,>28*256                 ; CMP #40           ; fetch the current speed from DELTA into A, and if
     1022 2800     
3355 1024 1801  10        joc  MA17                       ; BCS MA17          ; A >= 40, we are already going at full pelt, so jump
3356                                                                          ; down to MA17 to skip the following
3357               
3358 1026 B004  14        ab   rone,ra                    ; INC DELTA         ; We can go a bit faster, so increment the speed in
3359                                                                          ; location DELTA
3360               
3361               MA17:
3362 1028 D020  22        movb @KY1,ra                    ; LDA KY1           ; If "?" is being pressed, keep going, otherwise jump
     102A 0042     
3363 102C 1303  10        jeq  MA4                        ; BEQ MA4           ; down to MA4 to skip the following
3364               
3365 102E 7004  14        sb   rone,ra                    ; DEC DELTA         ; The "slow down" key is being pressed, so we decrement
3366                                                                          ; the current ship speed in DELTA
3367               
3368 1030 1601  10        jne  MA4                        ; BNE MA4           ; If the speed is still greater than zero, jump to MA4
3369               
3370 1032 B004  14        ab   rone,ra                    ; INC DELTA         ; Otherwise we just braked a little too hard, so bump
3371                                                                          ; the speed back up to the minimum value of 1
3372               
3373               MA4:
3374 1034 D020  22        movb @KY15,ra                   ; LDA KY15          ; If "U" is being pressed and the number of missiles
     1036 004C     
3375                      .and @NOMSL                     ; AND NOMSL         ; in NOMSL is non-zero, keep going, otherwise jump down
     **** ****     > AND
0001 1038 D1A0  22        movb @NOMSL,rtmp
     103A 0333     
0002 103C 0546  10        inv  rtmp
0003 103E 5006  14        szcb rtmp,ra
                   < elite.a99
3376 1040 1310  10        jeq  MA20                       ; BEQ MA20          ; to MA20 to skip the following
3377               
3378 1042 0202  12        li   ry,>ee*256                 ; LDY #&EE          ; The "disarm missiles" key is being pressed, so call
     1044 EE00     
3379 1046 0206  12        li   rtmp,ABORT                 ; JSR ABORT         ; ABORT to disarm the missile and update the missile
     1048 B0A2     
3380 104A 06A0  24        bl   @jsr                       ;
     104C FF10     
3381                                                                          ; indicators on the dashboard to green/cyan (Y = &EE)
3382               
3383 104E 0200  12        li   ra,>28*256                 ; LDA #40           ; Call the NOISE routine with A = 40 to make a low,
     1050 2800     
3384 1052 0206  12        li   rtmp,NOISE                 ; JSR NOISE         ; long beep to indicate the missile is now disarmed
     1054 CBB0     
3385 1056 06A0  24        bl   @jsr                       ;
     1058 FF10     
3386               
3387               MA31:
3388 105A 0200  12        li   ra,>00*256                 ; LDA #0            ; Set MSAR to 0 to indicate that no missiles are
     105C 0000     
3389 105E D800  22        movb ra,@MSAR                   ; STA MSAR          ; currently armed
     1060 0D5E     
3390               
3391               MA20:
3392 1062 D020  22        movb @MSTG,ra                   ; LDA MSTG          ; If MSTG is positive (i.e. it does not have bit 7 set),
     1064 0052     
3393 1066 150E  10        jgt  MA25                       ; BPL MA25          ; then it indicates we already have a missile locked on
3394                                                                          ; a target (in which case MSTG contains the ship number
3395                                                                          ; of the target), so jump to MA25 to skip targeting. Or
3396                                                                          ; to put it another way, if MSTG = &FF, which means
3397                                                                          ; there is no current target lock, keep going
3398               
3399 1068 D020  22        movb @KY14,ra                   ; LDA KY14          ; If "T" is being pressed, keep going, otherwise jump
     106A 004B     
3400 106C 130B  10        jeq  MA25                       ; BEQ MA25          ; down to MA25 to skip the following
3401               
3402 106E D060  22        movb @NOMSL,rx                  ; LDX NOMSL         ; If the number of missiles in NOMSL is zero, jump down
     1070 0333     
3403 1072 1308  10        jeq  MA25                       ; BEQ MA25          ; to MA25 to skip the following
3404               
3405 1074 D800  22        movb ra,@MSAR                   ; STA MSAR          ; The "target missile" key is being pressed and we have
     1076 0D5E     
3406                                                                          ; at least one missile, so set MSAR = &FF to denote that
3407                                                                          ; our missile is currently armed (we know A has the
3408                                                                          ; value &FF, as we just loaded it from MSTG and checked
3409                                                                          ; that it was negative)
3410               
3411 1078 0202  12        li   ry,>e0*256                 ; LDY #&E0          ; Change the leftmost missile indicator to yellow/white
     107A E000     
3412 107C 0206  12        li   rtmp,MSBAR                 ; JSR MSBAR         ; on the missile bar (this call changes the leftmost
     107E B10E     
3413 1080 06A0  24        bl   @jsr                       ;
     1082 FF10     
3414                                                                          ; indicator because we set X to the number of missiles
3415                                                                          ; in NOMSL above, and the indicators are numbered from
3416                                                                          ; right to left, so X is the number of the leftmost
3417                                                                          ; indicator)
3418               
3419               MA25:
3420 1084 D020  22        movb @KY16,ra                   ; LDA KY16          ; If "M" is being pressed, keep going, otherwise jump
     1086 004D     
3421 1088 1307  10        jeq  MA24                       ; BEQ MA24          ; down to MA24 to skip the following
3422               
3423 108A D020  22        movb @MSTG,ra                   ; LDA MSTG          ; If MSTG = &FF then there is no target lock, so jump to
     108C 0052     
3424 108E 112D  10        jlt  MA64                       ; BMI MA64          ; MA64 to skip the following (also skipping the checks
3425                                                                          ; for TAB, ESCAPE, "J" and "E")
3426               
3427 1090 0206  12        li   rtmp,FRMIS                 ; JSR FRMIS         ; The "fire missile" key is being pressed and we have
     1092 3C2A     
3428 1094 06A0  24        bl   @jsr                       ;
     1096 FF10     
3429                                                                          ; a missile lock, so call the FRMIS routine to fire
3430                                                                          ; the missile
3431               
3432               MA24:
3433 1098 D020  22        movb @KY12,ra                   ; LDA KY12          ; If TAB is being pressed, keep going, otherwise jump
     109A 0049     
3434 109C 1307  10        jeq  MA76                       ; BEQ MA76          ; down to MA76 to skip the following
3435               
3436                      .asl @BOMB                      ; ASL BOMB          ; The "energy bomb" key is being pressed, so double
     **** ****     > ASL
0001 109E D1A0  22        movb @BOMB,rtmp
     10A0 032A     
0002 10A2 0246  14        andi rtmp,>ff00
     10A4 FF00     
0003 10A6 0A16  14        sla  rtmp,1
0004 10A8 D806  22        movb rtmp,@BOMB
     10AA 032A     
                   < elite.a99
3437                                                                          ; the value in BOMB. If we have an energy bomb fitted,
3438                                                                          ; BOMB will contain &7F (%01111111) before this shift
3439                                                                          ; and will contain &FE (%11111110) after the shift; if
3440                                                                          ; we don't have an energy bomb fitted, BOMB will still
3441                                                                          ; contain 0. The bomb explosion is dealt with in the
3442                                                                          ; MAL1 routine below - this just registers the fact that
3443                                                                          ; we've set the bomb ticking
3444               
3445               MA76:
3446 10AC D020  22        movb @KY13,ra                   ; LDA KY13          ; If ESCAPE is being pressed and we have an escape pod
     10AE 004A     
3447                      .and @ESCP                      ; AND ESCP          ; fitted, keep going, otherwise skip the next
     **** ****     > AND
0001 10B0 D1A0  22        movb @ESCP,rtmp
     10B2 032E     
0002 10B4 0546  10        inv  rtmp
0003 10B6 5006  14        szcb rtmp,ra
                   < elite.a99
3448 10B8 1302  10        jeq  B05                        ; BEQ B05           ; instruction
3449               
3450 10BA 0460  20        b    @ESCAPE                    ; JMP ESCAPE        ; The button is being pressed to launch an escape pod
     10BC 3646     
3451                                                                          ; and we have an escape pod fitted, so jump to ESCAPE to
3452                                                                          ; launch it, and exit the main flight loop using a tail
3453                                                                          ; call
3454               
3455               B05:
3456 10BE D020  22        movb @KY18,ra                   ; LDA KY18          ; If "J" is being pressed, keep going, otherwise skip
     10C0 004F     
3457 10C2 1304  10        jeq  B06                        ; BEQ B06           ; the next instruction
3458               
3459 10C4 0206  12        li   rtmp,WARP                  ; JSR WARP          ; Call the WARP routine to do an in-system jump
     10C6 4838     
3460 10C8 06A0  24        bl   @jsr                       ;
     10CA FF10     
3461               
3462               B06:
3463 10CC D020  22        movb @KY17,ra                   ; LDA KY17          ; If "E" is being pressed and we have an E.C.M. fitted,
     10CE 004E     
3464                      .and @ECM                       ; AND ECM           ; keep going, otherwise jump down to MA64 to skip the
     **** ****     > AND
0001 10D0 D1A0  22        movb @ECM,rtmp
     10D2 0328     
0002 10D4 0546  10        inv  rtmp
0003 10D6 5006  14        szcb rtmp,ra
                   < elite.a99
3465 10D8 1308  10        jeq  MA64                       ; BEQ MA64          ; following
3466               
3467 10DA D020  22        movb @ECMA,ra                   ; LDA ECMA          ; If ECMA is non-zero, that means an E.C.M. is already
     10DC 0030     
3468 10DE 1605  10        jne  MA64                       ; BNE MA64          ; operating and is counting down (this can be either
3469                                                                          ; our E.C.M. or an opponent's), so jump down to MA64 to
3470                                                                          ; skip the following (as we can't have two E.C.M.
3471                                                                          ; systems operating at the same time)
3472               
3473 10E0 7004  14        sb   rone,ra                    ; DEC ECMP          ; The E.C.M. button is being pressed and nobody else
3474                                                                          ; is operating their E.C.M., so decrease the value of
3475                                                                          ; ECMP to make it non-zero, to denote that our E.C.M.
3476                                                                          ; is now on
3477               
3478 10E2 0206  12        li   rtmp,ECBLB2                ; JSR ECBLB2        ; Call ECBLB2 to light up the E.C.M. indicator bulb on
     10E4 B0BE     
3479 10E6 06A0  24        bl   @jsr                       ;
     10E8 FF10     
3480                                                                          ; the dashboard, set the E.C.M. countdown timer to 32,
3481                                                                          ; and start making the E.C.M. sound
3482               
3483               MA64:
3484 10EA D020  22        movb @KY19,ra                   ; LDA KY19          ; If "C" is being pressed, and we have a docking
     10EC 0050     
3485                      .and @DKCMP                     ; AND DKCMP         ; computer fitted, and we are inside the space station's
     **** ****     > AND
0001 10EE D1A0  22        movb @DKCMP,rtmp
     10F0 032C     
0002 10F2 0546  10        inv  rtmp
0003 10F4 5006  14        szcb rtmp,ra
                   < elite.a99
3486                      .and @SSPR                      ; AND SSPR          ; safe zone, keep going, otherwise jump down to MA68 to
     **** ****     > AND
0001 10F6 D1A0  22        movb @SSPR,rtmp
     10F8 0D55     
0002 10FA 0546  10        inv  rtmp
0003 10FC 5006  14        szcb rtmp,ra
                   < elite.a99
3487 10FE 1305  10        jeq  MA68                       ; BEQ MA68          ; skip the following
3488               
3489 1100 D020  22        movb @K.+NI.+32,ra              ; LDA K%+NI%+32     ; Fetch the AI counter (byte #32) of the second ship
     1102 0944     
3490 1104 1102  10        jlt  MA68                       ; BMI MA68          ; from the ship data workspace at K%, which is reserved
3491                                                                          ; for the sun or the space station (in this case it's
3492                                                                          ; the latter as we are in the safe zone). If byte #32 is
3493                                                                          ; negative, meaning the station is hostile, then jump
3494                                                                          ; down to MA68 to skip the following (so we can't use
3495                                                                          ; the docking computer to dock at a station that has
3496                                                                          ; turned against us)
3497               
3498 1106 0460  16        b    @GOIN                      ; JMP GOIN          ; The Docking Computer button has been pressed and
     1108 130A     
3499                                                                          ; we are allowed to dock at the station, so jump to
3500                                                                          ; GOIN to dock (or "go in"), and exit the main flight
3501                                                                          ; loop using a tail call
3502               
3503               MA68:
3504 110A 0200  12        li   ra,>00*256                 ; LDA #0            ; Set LAS = 0, to switch the laser off while we do the
     110C 0000     
3505 110E D800  22        movb ra,@LAS                    ; STA LAS           ; following logic
     1110 0051     
3506               
3507 1112 D800  22        movb ra,@DELT4                  ; STA DELT4         ; Take the 16-bit value (DELTA 0) - i.e. a two-byte
     1114 008D     
3508 1116 D020  22        movb @DELTA,ra                  ; LDA DELTA         ; number with DELTA as the high byte and 0 as the low
     1118 008C     
3509 111A 0910  14        srl  ra,1                       ; LSR A             ; byte - and divide it by 4, storing the 16-bit result
3510 111C 0208  12        li   rarg1,DELT4                ; ROR DELT4         ; in DELT4(1 0). This has the effect of storing the
     111E 008D     
3511 1120 06A0  24        bl   @ror                       ;
     1122 FF62     
3512 1124 0910  14        srl  ra,1                       ; LSR A             ; current speed * 64 in the 16-bit location DELT4(1 0)
3513 1126 0208  12        li   rarg1,DELT4                ; ROR DELT4
     1128 008D     
3514 112A 06A0  24        bl   @ror                       ;
     112C FF62     
3515 112E D800  22        movb ra,@DELT4+1                ; STA DELT4+1
     1130 008E     
3516               
3517 1132 D020  22        movb @LASCT,ra                  ; LDA LASCT         ; If LASCT is zero, keep going, otherwise the laser is
     1134 0D60     
3518 1136 1628  10        jne  MA3                        ; BNE MA3           ; a pulse laser that is between pulses, so jump down to
3519                                                                          ; MA3 to skip the following
3520               
3521 1138 D020  22        movb @KY7,ra                    ; LDA KY7           ; If "A" is being pressed, keep going, otherwise jump
     113A 0048     
3522 113C 1325  10        jeq  MA3                        ; BEQ MA3           ; down to MA3 to skip the following
3523               
3524 113E D020  22        movb @GNTMP,ra                  ; LDA GNTMP         ; If the laser temperature >= 242 then the laser has
     1140 0D61     
3525 1142 0280  14        ci   ra,>f2*256                 ; CMP #242          ; overheated, so jump down to MA3 to skip the following
     1144 F200     
3526 1146 1820  10        joc  MA3                        ; BCS MA3
3527               
3528 1148 D060  22        movb @VIEW,rx                   ; LDX VIEW          ; If the current space view has a laser fitted (i.e. the
     114A 0D5F     
3529 114C D021  26        movb @LASER(rx),ra              ; LDA LASER,X       ; laser power for this view is greater than zero), then
     114E 0310     
3530 1150 131B  10        jeq  MA3                        ; BEQ MA3           ; keep going, otherwise jump down to MA3 to skip the
3531                                                                          ; following
3532               
3533                                                                          ; If we get here, then the "fire" button is being
3534                                                                          ; pressed, our laser hasn't overheated and isn't already
3535                                                                          ; being fired, and we actually have a laser fitted to
3536                                                                          ; the current space view, so it's time to hit me with
3537                                                                          ; those laser beams
3538               
3539                      .pha                            ; PHA               ; Store the current view's laser power on the stack
     **** ****     > PHA
0001 1152 D680  26        movb ra,*rsp
0002 1154 060A  10        dec  rsp
                   < elite.a99
3540               
3541 1156 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; Set LAS and LAS2 to bits 0-6 of the laser power
     1158 7F00     
3542 115A D800  22        movb ra,@LAS                    ; STA LAS
     115C 0051     
3543 115E D800  22        movb ra,@LAS2                   ; STA LAS2
     1160 0D5D     
3544               
3545 1162 0200  12        li   ra,>00*256                 ; LDA #0            ; Call the NOISE routine with A = 0 to make the sound
     1164 0000     
3546 1166 0206  12        li   rtmp,NOISE                 ; JSR NOISE         ; of our laser firing
     1168 CBB0     
3547 116A 06A0  24        bl   @jsr                       ;
     116C FF10     
3548               
3549 116E 0206  12        li   rtmp,LASLI                 ; JSR LASLI         ; Call LASLI to draw the laser lines
     1170 48DA     
3550 1172 06A0  24        bl   @jsr                       ;
     1174 FF10     
3551               
3552                      .pla                            ; PLA               ; Restore the current view's laser power into A
     **** ****     > PLA
0001 1176 058A  10        inc  rsp
0002 1178 D01A  22        movb *rsp,ra
                   < elite.a99
3553               
3554 117A 1502  10        jgt  ma1_                       ; BPL ma1           ; If the laser power has bit 7 set, then it's an "always
3555                                                                          ; on" laser rather than a pulsing laser, so keep going,
3556                                                                          ; otherwise jump down to ma1 to skip the following
3557                                                                          ; instruction
3558               
3559 117C 0200  12        li   ra,>00*256                 ; LDA #0            ; This is an "always on" laser (i.e. a beam laser,
     117E 0000     
3560                                                                          ; as this version of Elite doesn't have military
3561                                                                          ; lasers), so set A = 0, which will be stored in LASCT
3562                                                                          ; to denote that this is not a pulsing laser
3563               
3564               ma1_:
3565 1180 0240  14        andi ra,>fa*256                 ; AND #%11111010    ; LASCT will be set to 0 for beam lasers, and to the
     1182 FA00     
3566 1184 D800  22        movb ra,@LASCT                  ; STA LASCT         ; laser power AND %11111010 for pulse lasers, which
     1186 0D60     
3567                                                                          ; comes to 10 (as pulse lasers have a power of 15). See
3568                                                                          ; MA23 below for more on laser pulsing and LASCT
3569               
3570               * ******************************************************************************
3571               *
3572               * Name: Main flight loop (Part 4 of 16)
3573               * Type: Subroutine
3574               * Category: Main loop
3575               * Summary: For each nearby ship: Copy the ship's data block from K% to the
3576               * zero-page workspace at INWK
3577               * Deep dive: Program flow of the main game loop
3578               * Ship data blocks
3579               *
3580               * ------------------------------------------------------------------------------
3581               *
3582               * The main flight loop covers most of the flight-specific aspects of Elite. This
3583               * section covers the following:
3584               *
3585               * * Start looping through all the ships in the local bubble, and for each
3586               * one:
3587               *
3588               * * Copy the ship's data block from K% to INWK
3589               *
3590               * * Set XX0 to point to the ship's blueprint (if this is a ship)
3591               *
3592               * ------------------------------------------------------------------------------
3593               *
3594               * Other entry points:
3595               *
3596               * MAL1                Marks the beginning of the ship analysis loop, so we
3597               * can jump back here from part 12 of the main flight loop
3598               * to work our way through each ship in the local bubble.
3599               * We also jump back here when a ship is removed from the
3600               * bubble, so we can continue processing from the next ship
3601               *
3602               * ******************************************************************************
3603               
3604               MA3:
3605 1188 0201  12        li   rx,>00*256                 ; LDX #0            ; We're about to work our way through all the ships in
     118A 0000     
3606                                                                          ; our local bubble of universe, so set a counter in X,
3607                                                                          ; starting from 0, to refer to each ship slot in turn
3608               
3609               MAL1:
3610 118C D801  22        movb rx,@XSAV                   ; STX XSAV          ; Store the current slot number in XSAV
     118E 0093     
3611               
3612 1190 D021  26        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the contents of this slot into A. If it is 0
     1192 0D40     
3613 1194 1602  10        jne  B07                        ; BNE B07           ; then this slot is empty and we have no more ships to
3614 1196 0460  16        b    @MA18                      ; JMP MA18          ; process, so jump to MA18 below, otherwise A contains
     1198 1516     
3615                                                                          ; the type of ship that's in this slot, so skip over the
3616                                                                          ; JMP MA18 instruction and keep going
3617               
3618               B07:
3619 119A D800  22        movb ra,@TYPE                   ; STA TYPE          ; Store the ship type in TYPE
     119C 009B     
3620               
3621 119E 0206  12        li   rtmp,GINF                  ; JSR GINF          ; Call GINF to fetch the address of the ship data block
     11A0 AF0C     
3622 11A2 06A0  24        bl   @jsr                       ;
     11A4 FF10     
3623                                                                          ; for the ship in slot X and store it in INF. The data
3624                                                                          ; block is in the K% workspace, which is where all the
3625                                                                          ; ship data blocks are stored
3626               
3627                                                                          ; Next we want to copy the ship data block from INF to
3628                                                                          ; the zero-page workspace at INWK, so we can process it
3629                                                                          ; more efficiently
3630               
3631 11A6 0202  12        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; There are NI% bytes in each ship data block (and in
     11A8 2300     
3632                                                                          ; the INWK workspace, so we set a counter in Y so we can
3633                                                                          ; loop through them
3634               
3635               MAL2:
3636                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Load the Y-th byte of INF and store it in the Y-th
     **** ****     > LD_IND_Y_IDX
0001 11AA D820  38        movb @INF,@rtmplb
     11AC 0020     
     11AE 2079     
0002 11B0 D1A0  22        movb @INF+1,rtmp
     11B2 0021     
0003 11B4 A182  14        a    ry,rtmp
0004 11B6 D016  22        movb *rtmp,RA
                   < elite.a99
3637 11B8 D880  30        movb ra,@INWK(ry)               ; STA INWK,Y        ; byte of INWK
     11BA 0053     
3638               
3639 11BC 7084  14        sb   rone,ry                    ; DEY               ; Decrement the loop counter
3640               
3641 11BE 15F5  10        jgt  MAL2                       ; BPL MAL2          ; Loop back for the next byte until we have copied the
3642                                                                          ; last byte from INF to INWK
3643               
3644 11C0 D020  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is negative then this indicates a
     11C2 009B     
3645 11C4 1121  10        jlt  MA21                       ; BMI MA21          ; planet or sun, so jump down to MA21, as the next bit
3646                                                                          ; sets up a pointer to the ship blueprint, and then
3647                                                                          ; checks for energy bomb damage, and neither of these
3648                                                                          ; apply to planets and suns
3649               
3650                      .asla                           ; ASL A             ; Set Y = ship type * 2
     **** ****     > ASLA
0001 11C6 0240  14        andi ra,>ff00
     11C8 FF00     
0002 11CA 0A10  14        sla  ra,1
                   < elite.a99
3651 11CC D080  14        movb ra,ry                      ; TAY
3652               
3653 11CE D022  26        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; The ship blueprints at XX21 start with a lookup
     11D0 E7E0     
3654 11D2 D800  22        movb ra,@XX0                    ; STA XX0           ; table that points to the individual ship blueprints,
     11D4 001E     
3655                                                                          ; so this fetches the low byte of this particular ship
3656                                                                          ; type's blueprint and stores it in XX0
3657               
3658 11D6 D022  26        movb @XX21-1(ry),ra             ; LDA XX21-1,Y      ; Fetch the high byte of this particular ship type's
     11D8 E7E1     
3659 11DA D800  22        movb ra,@XX0+1                  ; STA XX0+1         ; blueprint and store it in XX0+1
     11DC 001F     
3660               
3661               * ******************************************************************************
3662               *
3663               * Name: Main flight loop (Part 5 of 16)
3664               * Type: Subroutine
3665               * Category: Main loop
3666               * Summary: For each nearby ship: If an energy bomb has been set off,
3667               * potentially kill this ship
3668               * Deep dive: Program flow of the main game loop
3669               *
3670               * ------------------------------------------------------------------------------
3671               *
3672               * The main flight loop covers most of the flight-specific aspects of Elite. This
3673               * section covers the following:
3674               *
3675               * * Continue looping through all the ships in the local bubble, and for each
3676               * one:
3677               *
3678               * * If an energy bomb has been set off and this ship can be killed, kill it
3679               * and increase the kill tally
3680               *
3681               * ******************************************************************************
3682               
3683 11DE D020  22        movb @BOMB,ra                   ; LDA BOMB          ; If we set off our energy bomb (see MA24 above), then
     11E0 032A     
3684 11E2 1512  10        jgt  MA21                       ; BPL MA21          ; BOMB is now negative, so this skips to MA21 if our
3685                                                                          ; energy bomb is not going off
3686               
3687 11E4 0282  14        ci   ry,(2*SST)*256             ; CPY #2*SST        ; If the ship in Y is the space station, jump to BA21
     11E6 1000     
3688 11E8 130F  10        jeq  MA21                       ; BEQ MA21          ; as energy bombs are useless against space stations
3689               
3690 11EA D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; If the ship we are checking has bit 5 set in its ship
     11EC 0072     
3691 11EE 0240  14        andi ra,>20*256                 ; AND #%00100000    ; byte #31, then it is already exploding, so jump to
     11F0 2000     
3692 11F2 160A  10        jne  MA21                       ; BNE MA21          ; BA21 as ships can't explode more than once
3693               
3694 11F4 D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; The energy bomb is killing this ship, so set bit 7 of
     11F6 0072     
3695 11F8 0260  14        ori  ra,>80*256                 ; ORA #%10000000    ; the ship byte #31 to indicate that it has now been
     11FA 8000     
3696 11FC D800  22        movb ra,@INWK+31                ; STA INWK+31       ; killed
     11FE 0072     
3697               
3698 1200 0206  12        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     1202 CB60     
3699 1204 06A0  24        bl   @jsr                       ;
     1206 FF10     
3700                                                                          ; ship (so increase the kill tally, make an explosion
3701                                                                          ; sound and possibly display "RIGHT ON COMMANDER!")
3702               
3703               * ******************************************************************************
3704               *
3705               * Name: Main flight loop (Part 6 of 16)
3706               * Type: Subroutine
3707               * Category: Main loop
3708               * Summary: For each nearby ship: Move the ship in space and copy the updated
3709               * INWK data block back to K%
3710               * Deep dive: Program flow of the main game loop
3711               * Program flow of the ship-moving routine
3712               * Ship data blocks
3713               *
3714               * ------------------------------------------------------------------------------
3715               *
3716               * The main flight loop covers most of the flight-specific aspects of Elite. This
3717               * section covers the following:
3718               *
3719               * * Continue looping through all the ships in the local bubble, and for each
3720               * one:
3721               *
3722               * * Move the ship in space
3723               *
3724               * * Copy the updated ship's data block from INWK back to K%
3725               *
3726               * ******************************************************************************
3727               
3728               MA21:
3729 1208 0206  12        li   rtmp,MVEIT                 ; JSR MVEIT         ; Call MVEIT to move the ship we are processing in space
     120A 17E2     
3730 120C 06A0  24        bl   @jsr                       ;
     120E FF10     
3731               
3732                                                                          ; Now that we are done processing this ship, we need to
3733                                                                          ; copy the ship data back from INWK to the correct place
3734                                                                          ; in the K% workspace. We already set INF in part 4 to
3735                                                                          ; point to the ship's data block in K%, so we can simply
3736                                                                          ; do the reverse of the copy we did before, this time
3737                                                                          ; copying from INWK to INF
3738               
3739 1210 0202  12        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; Set a counter in Y so we can loop through the NI%
     1212 2300     
3740                                                                          ; bytes in the ship data block
3741               
3742               MAL3:
3743 1214 D022  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Load the Y-th byte of INWK and store it in the Y-th
     1216 0053     
3744                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; byte of INF
     **** ****     > ST_IND_Y_IDX
0001 1218 D820  38        movb @INF,@rtmplb
     121A 0020     
     121C 2079     
0002 121E D1A0  22        movb @INF+1,rtmp
     1220 0021     
0003 1222 A182  14        a    ry,rtmp
0004 1224 D580  26        movb RA,*rtmp
                   < elite.a99
3745               
3746 1226 7084  14        sb   rone,ry                    ; DEY               ; Decrement the loop counter
3747               
3748 1228 15F5  10        jgt  MAL3                       ; BPL MAL3          ; Loop back for the next byte, until we have copied the
3749                                                                          ; last byte from INWK back to INF
3750               
3751               * ******************************************************************************
3752               *
3753               * Name: Main flight loop (Part 7 of 16)
3754               * Type: Subroutine
3755               * Category: Main loop
3756               * Summary: For each nearby ship: Check whether we are docking, scooping or
3757               * colliding with it
3758               * Deep dive: Program flow of the main game loop
3759               *
3760               * ------------------------------------------------------------------------------
3761               *
3762               * The main flight loop covers most of the flight-specific aspects of Elite. This
3763               * section covers the following:
3764               *
3765               * * Continue looping through all the ships in the local bubble, and for each
3766               * one:
3767               *
3768               * * Check how close we are to this ship and work out if we are docking,
3769               * scooping or colliding with it
3770               *
3771               * ******************************************************************************
3772               
3773 122A D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the status of this ship from bits 5 (is ship
     122C 0072     
3774 122E 0240  14        andi ra,>a0*256                 ; AND #%10100000    ; exploding?) and bit 7 (has ship been killed?) from
     1230 A000     
3775                                                                          ; ship byte #31 into A
3776               
3777 1232 0206  12        li   rtmp,MAS4                  ; JSR MAS4          ; Or this value with x_hi, y_hi and z_hi
     1234 C46E     
3778 1236 06A0  24        bl   @jsr                       ;
     1238 FF10     
3779               
3780 123A 164C  10        jne  MA65                       ; BNE MA65          ; If this value is non-zero, then either the ship is
3781                                                                          ; far away (i.e. has a non-zero high byte in at least
3782                                                                          ; one of the three axes), or it is already exploding,
3783                                                                          ; or has been flagged as being killed - in which case
3784                                                                          ; jump to MA65 to skip the following, as we can't dock
3785                                                                          ; scoop or collide with it
3786               
3787 123C D020  22        movb @INWK,ra                   ; LDA INWK          ; Set A = (x_lo OR y_lo OR z_lo), and if bit 7 of the
     123E 0053     
3788 1240 F020  22        socb @INWK+3,ra                 ; ORA INWK+3        ; result is set, the ship is still a fair distance
     1242 0056     
3789 1244 F020  22        socb @INWK+6,ra                 ; ORA INWK+6        ; away (further than 127 in at least one axis), so jump
     1246 0059     
3790 1248 1145  10        jlt  MA65                       ; BMI MA65          ; to MA65 to skip the following, as it's too far away to
3791                                                                          ; dock, scoop or collide with
3792               
3793 124A D060  22        movb @TYPE,rx                   ; LDX TYPE          ; If the current ship type is negative then it's either
     124C 009B     
3794 124E 1142  10        jlt  MA65                       ; BMI MA65          ; a planet or a sun, so jump down to MA65 to skip the
3795                                                                          ; following, as we can't dock with it or scoop it
3796               
3797 1250 0281  14        ci   rx,(SST)*256               ; CPX #SST          ; If this ship is the space station, jump to ISDK to
     1252 0800     
3798 1254 1341  10        jeq  ISDK                       ; BEQ ISDK          ; check whether we are docking with it
3799               
3800 1256 0240  14        andi ra,>c0*256                 ; AND #%11000000    ; If bit 6 of (x_lo OR y_lo OR z_lo) is set, then the
     1258 C000     
3801 125A 163C  10        jne  MA65                       ; BNE MA65          ; ship is still a reasonable distance away (further than
3802                                                                          ; 63 in at least one axis), so jump to MA65 to skip the
3803                                                                          ; following, as it's too far away to dock, scoop or
3804                                                                          ; collide with
3805               
3806 125C 0281  14        ci   rx,(MSL)*256               ; CPX #MSL          ; If this ship is a missile, jump down to MA65 to skip
     125E 0900     
3807 1260 1339  10        jeq  MA65                       ; BEQ MA65          ; the following, as we can't scoop or dock with a
3808                                                                          ; missile, and it has its own dedicated collision
3809                                                                          ; checks in the TACTICS routine
3810               
3811 1262 0281  14        ci   rx,(OIL)*256               ; CPX #OIL          ; If ship type >= OIL (i.e. it's a cargo canister,
     1264 0B00     
3812 1266 1802  10        joc  B08                        ; BCS B08           ; Thargon or escape pod), skip the JMP instruction and
3813 1268 0460  16        b    @MA58                      ; JMP MA58          ; continue on, otherwise jump to MA58 to process a
     126A 1368     
3814                                                                          ; potential collision
3815               
3816               B08:
3817 126C D020  22        movb @BST,ra                    ; LDA BST           ; If we have fuel scoops fitted then BST will be &FF,
     126E 0329     
3818                                                                          ; otherwise it will be 0
3819               
3820                      .and @INWK+5                    ; AND INWK+5        ; Ship byte #5 contains the y_sign of this ship, so a
     **** ****     > AND
0001 1270 D1A0  22        movb @INWK+5,rtmp
     1272 0058     
0002 1274 0546  10        inv  rtmp
0003 1276 5006  14        szcb rtmp,ra
                   < elite.a99
3821                                                                          ; negative value here means the canister is below us,
3822                                                                          ; which means the result of the AND will be negative if
3823                                                                          ; the canister is below us and we have a fuel scoop
3824                                                                          ; fitted
3825               
3826 1278 1577  10        jgt  MA58                       ; BPL MA58          ; If the result is positive, then we either have no
3827                                                                          ; scoop or the canister is above us, and in both cases
3828                                                                          ; this means we can't scoop the item, so jump to MA58
3829                                                                          ; to process a collision
3830               
3831               * ******************************************************************************
3832               *
3833               * Name: Main flight loop (Part 8 of 16)
3834               * Type: Subroutine
3835               * Category: Main loop
3836               * Summary: For each nearby ship: Process us potentially scooping this item
3837               * Deep dive: Program flow of the main game loop
3838               *
3839               * ------------------------------------------------------------------------------
3840               *
3841               * The main flight loop covers most of the flight-specific aspects of Elite. This
3842               * section covers the following:
3843               *
3844               * * Continue looping through all the ships in the local bubble, and for each
3845               * one:
3846               *
3847               * * Process us potentially scooping this item
3848               *
3849               * ******************************************************************************
3850               
3851 127A 0200  12        li   ra,>03*256                 ; LDA #3            ; Set A to 3 to denote we may be scooping an escape pod
     127C 0300     
3852               
3853 127E 0281  14        ci   rx,(TGL)*256               ; CPX #TGL          ; If ship type < Thargon, i.e. it's a canister, jump
     1280 0C00     
3854 1282 1704  10        jnc  oily_                      ; BCC oily          ; to oily to randomly decide the canister's contents
3855               
3856 1284 1609  10        jne  slvy2_                     ; BNE slvy2         ; If ship type <> Thargon, i.e. it's an escape pod,
3857                                                                          ; jump to slvy2 with A set to 3, so we scoop up the
3858                                                                          ; escape pod as slaves
3859               
3860 1286 0200  12        li   ra,>10*256                 ; LDA #16           ; Otherwise this is a Thargon, so jump to slvy2 with
     1288 1000     
3861 128A 1606  10        jne  slvy2_                     ; BNE slvy2         ; A set to 16, so we scoop up the Thargon as alien items
3862                                                                          ; (this BNE is effectively a JMP as A will never be
3863                                                                          ; zero)
3864               
3865               oily_:
3866 128C 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers and reduce A to a
     128E C07C     
3867 1290 06A0  24        bl   @jsr                       ;
     1292 FF10     
3868 1294 0240  14        andi ra,>07*256                 ; AND #7            ; random number in the range 0-7
     1296 0700     
3869               
3870               slvy2_:
3871                                                                          ; By the time we get here, we are scooping, and A
3872                                                                          ; contains the type of item we are scooping (a random
3873                                                                          ; number 0-7 if we are scooping a cargo canister, 3 if
3874                                                                          ; we are scooping an escape pod, or 16 if we are
3875                                                                          ; scooping a Thargon). These numbers correspond to the
3876                                                                          ; relevant market items (see QQ23 for a list), so a
3877                                                                          ; cargo canister can contain anything from food to
3878                                                                          ; computers, while escape pods contain slaves, and
3879                                                                          ; Thargons become alien items when scooped
3880 1298 D800  22        movb ra,@QQ29                   ; STA QQ29          ; Call tnpr with the scooped cargo type stored in QQ29
     129A 0F1B     
3881 129C 0200  12        li   ra,>01*256                 ; LDA #1            ; and A set to 1, to work out whether we have room in
     129E 0100     
3882 12A0 0206  12        li   rtmp,tnpr_                 ; JSR tnpr          ; the hold for the scooped item (A is preserved by this
     12A2 4DF4     
3883 12A4 06A0  24        bl   @jsr                       ;
     12A6 FF10     
3884                                                                          ; call, and the C flag contains the result)
3885               
3886 12A8 0202  12        li   ry,>4e*256                 ; LDY #78           ; This instruction has no effect, so presumably it used
     12AA 4E00     
3887                                                                          ; to do something, but didn't get removed
3888               
3889 12AC 1845  10        joc  MA59                       ; BCS MA59          ; If the C flag is set then we have no room in the hold
3890                                                                          ; for the scooped item, so jump down to MA59 make a
3891                                                                          ; sound to indicate failure, before destroying the
3892                                                                          ; canister
3893               
3894 12AE D0A0  22        movb @QQ29,ry                   ; LDY QQ29          ; Scooping was successful, so set Y to the type of
     12B0 0F1B     
3895                                                                          ; item we just scooped, which we stored in QQ29 above
3896               
3897                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; Add A (which we set to 1 above) to the number of items
     **** ****     > ADC
0001 12B2 1701  10        jnc  !
0002 12B4 B004  14        ab   rone,ra
0003               !:
0004 12B6 B022  26        ab   @QQ20(RY),ra
     12B8 0317     
                   < elite.a99
3898 12BA D880  30        movb ra,@QQ20(ry)               ; STA QQ20,Y        ; of type Y in the cargo hold, as we just successfully
     12BC 0317     
3899                                                                          ; scooped one canister of type Y
3900               
3901 12BE D002  14        movb ry,ra                      ; TYA               ; Print recursive token 48 + Y as an in-flight token,
3902                      .adi (>d0*256)                  ; ADC #208          ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
     **** ****     > ADI
0001 12C0 1701  10        jnc  !
0002 12C2 B004  14        ab   rone,ra
0003               !:
0004 12C4 0220  14        ai   ra,(>D0*256)
     12C6 D000     
                   < elite.a99
3903 12C8 0206  12        li   rtmp,MESS                  ; JSR MESS          ; ITEMS"), so this prints the scooped item's name
     12CA CE5E     
3904 12CC 06A0  24        bl   @jsr                       ;
     12CE FF10     
3905               
3906 12D0 0460  16        b    @MA60                      ; JMP MA60          ; We are done scooping, so jump down to MA60 to set the
     12D2 1340     
3907                                                                          ; kill flag on the canister, as it no longer exists in
3908                                                                          ; the local bubble
3909               
3910               MA65:
3911 12D4 0460  16        b    @MA26                      ; JMP MA26          ; If we get here, then the ship we are processing was
     12D6 139A     
3912                                                                          ; too far away to be scooped, docked or collided with,
3913                                                                          ; so jump to MA26 to skip over the collision routines
3914                                                                          ; and move on to missile targeting
3915               
3916               * ******************************************************************************
3917               *
3918               * Name: Main flight loop (Part 9 of 16)
3919               * Type: Subroutine
3920               * Category: Main loop
3921               * Summary: For each nearby ship: If it is a space station, check whether we
3922               * are successfully docking with it
3923               * Deep dive: Program flow of the main game loop
3924               * Docking checks
3925               *
3926               * ------------------------------------------------------------------------------
3927               *
3928               * The main flight loop covers most of the flight-specific aspects of Elite. This
3929               * section covers the following:
3930               *
3931               * * Process docking with a space station
3932               *
3933               * For details on the various docking checks in this routine, see the deep dive
3934               * on "Docking checks".
3935               *
3936               * ------------------------------------------------------------------------------
3937               *
3938               * Other entry points:
3939               *
3940               * GOIN                We jump here from part 3 of the main flight loop if the
3941               * docking computer is activated by pressing "C"
3942               *
3943               * ******************************************************************************
3944               
3945               ISDK:
3946 12D8 D020  22        movb @K.+NI.+32,ra              ; LDA K%+NI%+32     ; 1. Fetch the AI counter (byte #32) of the second ship
     12DA 0944     
3947 12DC 1126  10        jlt  MA62                       ; BMI MA62          ; in the ship data workspace at K%, which is reserved
3948                                                                          ; for the sun or the space station (in this case it's
3949                                                                          ; the latter), and if it's negative, i.e. bit 7 is set,
3950                                                                          ; meaning the station is hostile, jump down to MA62 to
3951                                                                          ; fail docking (so trying to dock at a station that we
3952                                                                          ; have annoyed does not end well)
3953               
3954 12DE D020  22        movb @INWK+14,ra                ; LDA INWK+14       ; 2. If nosev_z_hi < 214, jump down to MA62 to fail
     12E0 0061     
3955 12E2 0280  14        ci   ra,>d6*256                 ; CMP #214          ; docking, as the angle of approach is greater than 26
     12E4 D600     
3956 12E6 1721  10        jnc  MA62                       ; BCC MA62          ; degrees
3957               
3958 12E8 0206  12        li   rtmp,SPS4                  ; JSR SPS4          ; Call SPS4 to get the vector to the space station
     12EA AD58     
3959 12EC 06A0  24        bl   @jsr                       ;
     12EE FF10     
3960                                                                          ; into XX15
3961               
3962 12F0 D020  22        movb @XX15+2,ra                 ; LDA XX15+2        ; 3. Check the sign of the z-axis (bit 7 of XX15+2) and
     12F2 0033     
3963 12F4 111A  10        jlt  MA62                       ; BMI MA62          ; if it is negative, we are facing away from the
3964                                                                          ; station, so jump to MA62 to fail docking
3965               
3966 12F6 0280  14        ci   ra,>59*256                 ; CMP #89           ; 4. If z-axis < 89, jump to MA62 to fail docking, as
     12F8 5900     
3967 12FA 1717  10        jnc  MA62                       ; BCC MA62          ; we are not in the 22.0 degree safe cone of approach
3968               
3969 12FC D020  22        movb @INWK+16,ra                ; LDA INWK+16       ; 5. If |roofv_x_hi| < 80, jump to MA62 to fail docking,
     12FE 0063     
3970 1300 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; as the slot is more than 36.6 degrees from horizontal
     1302 7F00     
3971 1304 0280  14        ci   ra,>50*256                 ; CMP #80
     1306 5000     
3972 1308 1710  10        jnc  MA62                       ; BCC MA62
3973               
3974               GOIN:
3975                                                                          ; If we arrive here, either the docking computer has
3976                                                                          ; been activated, or we just docked successfully
3977 130A 0200  12        li   ra,>00*256                 ; LDA #0            ; Set the on-screen hyperspace counter to 0
     130C 0000     
3978 130E D800  22        movb ra,@QQ22+1                 ; STA QQ22+1
     1310 002F     
3979               
3980 1312 0200  12        li   ra,>08*256                 ; LDA #8            ; This instruction has no effect, so presumably it used
     1314 0800     
3981                                                                          ; to do something, and didn't get removed
3982               
3983 1316 0206  12        li   rtmp,LAUN                  ; JSR LAUN          ; Show the space station launch tunnel
     1318 3E62     
3984 131A 06A0  24        bl   @jsr                       ;
     131C FF10     
3985               
3986 131E 0206  12        li   rtmp,RES4                  ; JSR RES4          ; Reset the shields and energy banks, stardust and INWK
     1320 BF22     
3987 1322 06A0  24        bl   @jsr                       ;
     1324 FF10     
3988                                                                          ; workspace
3989               
3990 1326 0460  20        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     1328 C65C     
3991                                                                          ; screen)
3992               
3993               MA62:
3994                                                                          ; If we arrive here, docking has just failed
3995 132A D020  22        movb @DELTA,ra                  ; LDA DELTA         ; If the ship's speed is < 5, jump to MA67 to register
     132C 008C     
3996 132E 0280  14        ci   ra,>05*256                 ; CMP #5            ; some damage, but not a huge amount
     1330 0500     
3997 1332 1713  10        jnc  MA67                       ; BCC MA67
3998               
3999 1334 0460  20        b    @DEATH                     ; JMP DEATH         ; Otherwise we have just crashed into the station, so
     1336 C47E     
4000                                                                          ; process our death
4001               
4002               * ******************************************************************************
4003               *
4004               * Name: Main flight loop (Part 10 of 16)
4005               * Type: Subroutine
4006               * Category: Main loop
4007               * Summary: For each nearby ship: Remove if scooped, or process collisions
4008               * Deep dive: Program flow of the main game loop
4009               *
4010               * ------------------------------------------------------------------------------
4011               *
4012               * The main flight loop covers most of the flight-specific aspects of Elite. This
4013               * section covers the following:
4014               *
4015               * * Continue looping through all the ships in the local bubble, and for each
4016               * one:
4017               *
4018               * * Remove scooped item after both successful and failed scooping attempts
4019               *
4020               * * Process collisions
4021               *
4022               * ******************************************************************************
4023               
4024               MA59:
4025                                                                          ; If we get here then scooping failed
4026 1338 0206  12        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of the cargo canister being destroyed
     133A CB2E     
4027 133C 06A0  24        bl   @jsr                       ;
     133E FF10     
4028                                                                          ; and fall through into MA60 to remove the canister
4029                                                                          ; from our local bubble
4030               
4031               MA60:
4032                                                                          ; If we get here then scooping was successful
4033                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the scooped or destroyed item, to denote
     **** ****     > ASL
0001 1340 D1A0  22        movb @INWK+31,rtmp
     1342 0072     
0002 1344 0246  14        andi rtmp,>ff00
     1346 FF00     
0003 1348 0A16  14        sla  rtmp,1
0004 134A D806  22        movb rtmp,@INWK+31
     134C 0072     
                   < elite.a99
4034                      .sec                            ; SEC               ; that it has been killed and should be removed from
     **** ****     > SEC
0001 134E 0A15  14        sla  rmone,1
                   < elite.a99
4035 1350 0208  12        li   rarg1,INWK+31              ; ROR INWK+31       ; the local bubble
     1352 0072     
4036 1354 06A0  24        bl   @ror                       ;
     1356 FF62     
4037               
4038               MA61:
4039 1358 1620  10        jne  MA26                       ; BNE MA26          ; Jump to MA26 to skip over the collision routines and
4040                                                                          ; to move on to missile targeting (this BNE is
4041                                                                          ; effectively a JMP as A will never be zero)
4042               
4043               MA67:
4044                                                                          ; If we get here then we have collided with something,
4045                                                                          ; but not fatally
4046 135A 0200  12        li   ra,>01*256                 ; LDA #1            ; Set the speed in DELTA to 1 (i.e. a sudden stop)
     135C 0100     
4047 135E D800  22        movb ra,@DELTA                  ; STA DELTA
     1360 008C     
4048               
4049 1362 0200  12        li   ra,>05*256                 ; LDA #5            ; Set the amount of damage in A to 5 (a small dent) and
     1364 0500     
4050 1366 1611  10        jne  MA63                       ; BNE MA63          ; jump down to MA63 to process the damage (this BNE is
4051                                                                          ; effectively a JMP as A will never be zero)
4052               
4053               MA58:
4054                                                                          ; If we get here, we have collided with something in a
4055                                                                          ; potentially fatal way
4056                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the ship we just collided with, to
     **** ****     > ASL
0001 1368 D1A0  22        movb @INWK+31,rtmp
     136A 0072     
0002 136C 0246  14        andi rtmp,>ff00
     136E FF00     
0003 1370 0A16  14        sla  rtmp,1
0004 1372 D806  22        movb rtmp,@INWK+31
     1374 0072     
                   < elite.a99
4057                      .sec                            ; SEC               ; denote that it has been killed and should be removed
     **** ****     > SEC
0001 1376 0A15  14        sla  rmone,1
                   < elite.a99
4058 1378 0208  12        li   rarg1,INWK+31              ; ROR INWK+31       ; from the local bubble
     137A 0072     
4059 137C 06A0  24        bl   @ror                       ;
     137E FF62     
4060               
4061 1380 D020  22        movb @INWK+35,ra                ; LDA INWK+35       ; Load A with the energy level of the ship we just hit
     1382 0076     
4062               
4063                      .sec                            ; SEC               ; Set the amount of damage in A to 128 + A / 2, so
     **** ****     > SEC
0001 1384 0A15  14        sla  rmone,1
                   < elite.a99
4064 1386 06A0  24        bl   @rora                      ; ROR A             ; this is quite a big dent, and colliding with higher
     1388 FF4A     
4065                                                                          ; energy ships will cause more damage
4066               
4067               MA63:
4068 138A 0206  12        li   rtmp,OOPS                  ; JSR OOPS          ; The amount of damage is in A, so call OOPS to reduce
     138C AE76     
4069 138E 06A0  24        bl   @jsr                       ;
     1390 FF10     
4070                                                                          ; our shields, and if the shields are gone, there's a
4071                                                                          ; chance of cargo loss or even death
4072               
4073 1392 0206  12        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of colliding with the other ship and
     1394 CB2E     
4074 1396 06A0  24        bl   @jsr                       ;
     1398 FF10     
4075                                                                          ; fall through into MA26 to try targeting a missile
4076               
4077               * ******************************************************************************
4078               *
4079               * Name: Main flight loop (Part 11 of 16)
4080               * Type: Subroutine
4081               * Category: Main loop
4082               * Summary: For each nearby ship: Process missile lock and firing our laser
4083               * Deep dive: Program flow of the main game loop
4084               * Flipping axes between space views
4085               *
4086               * ------------------------------------------------------------------------------
4087               *
4088               * The main flight loop covers most of the flight-specific aspects of Elite. This
4089               * section covers the following:
4090               *
4091               * * Continue looping through all the ships in the local bubble, and for each
4092               * one:
4093               *
4094               * * If this is not the front space view, flip the axes of the ship's
4095               * coordinates in INWK
4096               *
4097               * * Process missile lock
4098               *
4099               * * Process our laser firing
4100               *
4101               * ******************************************************************************
4102               
4103               MA26:
4104 139A D020  22        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to MA15 to skip
     139C 0096     
4105 139E 1662  10        jne  MA15                       ; BNE MA15          ; missile and laser locking
4106               
4107 13A0 0206  12        li   rtmp,PLUT                  ; JSR PLUT          ; Call PLUT to update the geometric axes in INWK to
     13A2 4984     
4108 13A4 06A0  24        bl   @jsr                       ;
     13A6 FF10     
4109                                                                          ; match the view (front, rear, left, right)
4110               
4111 13A8 0206  12        li   rtmp,HITCH                 ; JSR HITCH         ; Call HITCH to see if this ship is in the crosshairs,
     13AA 3B3E     
4112 13AC 06A0  24        bl   @jsr                       ;
     13AE FF10     
4113 13B0 1755  10        jnc  MA8                        ; BCC MA8           ; in which case the C flag will be set (so if there is
4114                                                                          ; no missile or laser lock, we jump to MA8 to skip the
4115                                                                          ; following)
4116               
4117 13B2 D020  22        movb @MSAR,ra                   ; LDA MSAR          ; We have missile lock, so check whether the leftmost
     13B4 0D5E     
4118 13B6 130C  10        jeq  MA47                       ; BEQ MA47          ; missile is currently armed, and if not, jump to MA47
4119                                                                          ; to process laser fire, as we can't lock an unarmed
4120                                                                          ; missile
4121               
4122 13B8 0206  12        li   rtmp,BEEP                  ; JSR BEEP          ; We have missile lock and an armed missile, so call
     13BA CBAC     
4123 13BC 06A0  24        bl   @jsr                       ;
     13BE FF10     
4124                                                                          ; the BEEP subroutine to make a short, high beep
4125               
4126 13C0 D060  22        movb @XSAV,rx                   ; LDX XSAV          ; Call ABORT2 to store the details of this missile
     13C2 0093     
4127 13C4 0202  12        li   ry,>0e*256                 ; LDY #&0E          ; lock, with the targeted ship's slot number in X
     13C6 0E00     
4128 13C8 0206  12        li   rtmp,ABORT2                ; JSR ABORT2        ; (which we stored in XSAV at the start of this ship's
     13CA B0A6     
4129 13CC 06A0  24        bl   @jsr                       ;
     13CE FF10     
4130                                                                          ; loop at MAL1), and set the colour of the missile
4131                                                                          ; indicator to the colour in Y (red = &0E)
4132               
4133               MA47:
4134                                                                          ; If we get here then the ship is in our sights, but
4135                                                                          ; we didn't lock a missile, so let's see if we're
4136                                                                          ; firing the laser
4137 13D0 D020  22        movb @LAS,ra                    ; LDA LAS           ; If we are firing the laser then LAS will contain the
     13D2 0051     
4138 13D4 1343  10        jeq  MA8                        ; BEQ MA8           ; laser power (which we set in MA68 above), so if this
4139                                                                          ; is zero, jump down to MA8 to skip the following
4140               
4141 13D6 0201  12        li   rx,>0f*256                 ; LDX #15           ; We are firing our laser and the ship in INWK is in
     13D8 0F00     
4142 13DA 0206  12        li   rtmp,EXNO                  ; JSR EXNO          ; the crosshairs, so call EXNO to make the sound of
     13DC CB76     
4143 13DE 06A0  24        bl   @jsr                       ;
     13E0 FF10     
4144                                                                          ; us making a laser strike on another ship
4145               
4146 13E2 D020  22        movb @INWK+35,ra                ; LDA INWK+35       ; Fetch the hit ship's energy from byte #35 and subtract
     13E4 0076     
4147                      .sec                            ; SEC               ; our current laser power, and if the result is greater
     **** ****     > SEC
0001 13E6 0A15  14        sla  rmone,1
                   < elite.a99
4148                      .sbc @LAS,ra                    ; SBC LAS           ; than zero, the other ship has survived the hit, so
     **** ****     > SBC
0001 13E8 1801  10        joc  !
0002 13EA 7004  14        sb   rone,ra
0003               !:
0004 13EC 7020  22        sb   @LAS,ra
     13EE 0051     
                   < elite.a99
4149 13F0 182D  10        joc  MA14                       ; BCS MA14          ; jump down to MA14 to make it angry
4150               
4151 13F2 D020  22        movb @TYPE,ra                   ; LDA TYPE          ; Did we just hit the space station? If so, jump to
     13F4 009B     
4152 13F6 0280  14        ci   ra,(SST)*256               ; CMP #SST          ; MA14+2 to make the station hostile, skipping the
     13F8 0800     
4153 13FA 1329  10        jeq  MA14+2                     ; BEQ MA14+2        ; following as we can't destroy a space station
4154               
4155 13FC D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 7 of the enemy ship's byte #31, to indicate
     13FE 0072     
4156 1400 0260  14        ori  ra,>80*256                 ; ORA #%10000000    ; that it has been killed
     1402 8000     
4157 1404 D800  22        movb ra,@INWK+31                ; STA INWK+31
     1406 0072     
4158               
4159 1408 1829  10        joc  MA8                        ; BCS MA8           ; If the enemy ship type is >= SST (i.e. missile,
4160                                                                          ; asteroid, canister, Thargon or escape pod) then
4161                                                                          ; jump down to MA8
4162               
4163 140A 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Fetch a random number, and jump to oh if it is
     140C C07C     
4164 140E 06A0  24        bl   @jsr                       ;
     1410 FF10     
4165 1412 1518  10        jgt  oh_                        ; BPL oh            ; positive (50% chance)
4166               
4167 1414 0202  12        li   ry,>00*256                 ; LDY #0            ; Fetch the first byte of the hit ship's blueprint,
     1416 0000     
4168                      .and_ind_y_idx @XX0,ra          ; AND (XX0),Y       ; which determines the maximum number of bits of
     **** ****     > AND_IND_Y_IDX
0001 1418 D820  38        movb @XX0,@rtmplb
     141A 001E     
     141C 2079     
0002 141E D1A0  22        movb @XX0+1,rtmp
     1420 001F     
0003 1422 A182  14        a    ry,rtmp
0004 1424 D196  22        movb *rtmp,rtmp
0005 1426 0546  10        inv  rtmp
0006 1428 5006  14        szcb rtmp,RA
                   < elite.a99
4169                                                                          ; debris shown when the ship is destroyed, and AND
4170                                                                          ; with the random number we just fetched
4171               
4172 142A D800  22        movb ra,@CNT                    ; STA CNT           ; Store the result in CNT, so CNT contains a random
     142C 00A4     
4173                                                                          ; number between 0 and the maximum number of bits of
4174                                                                          ; debris that this ship will release when destroyed
4175               
4176               um_:
4177 142E 130A  10        jeq  oh_                        ; BEQ oh            ; We're going to go round a loop using CNT as a counter
4178                                                                          ; so this checks whether the counter is zero and jumps
4179                                                                          ; to oh when it gets there (which might be straight
4180                                                                          ; away)
4181               
4182 1430 0201  12        li   rx,(OIL)*256               ; LDX #OIL          ; Call SFS1 to spawn a cargo canister from the now
     1432 0B00     
4183 1434 0200  12        li   ra,>00*256                 ; LDA #0            ; deceased parent ship, giving the spawned canister an
     1436 0000     
4184 1438 0206  12        li   rtmp,SFS1                  ; JSR SFS1          ; AI flag of 0 (no AI, no E.C.M., non-hostile)
     143A 3D02     
4185 143C 06A0  24        bl   @jsr                       ;
     143E FF10     
4186               
4187 1440 7004  14        sb   rone,ra                    ; DEC CNT           ; Decrease the loop counter
4188               
4189 1442 15F5  10        jgt  um_                        ; BPL um            ; Jump back up to um (this BPL is effectively a JMP as
4190                                                                          ; CNT will never be negative)
4191               
4192               oh_:
4193 1444 0206  12        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     1446 CB60     
4194 1448 06A0  24        bl   @jsr                       ;
     144A FF10     
4195                                                                          ; ship (so increase the kill tally, make an explosion
4196                                                                          ; sound and so on)
4197               
4198               MA14:
4199 144C D800  22        movb ra,@INWK+35                ; STA INWK+35       ; Store the hit ship's updated energy in ship byte #35
     144E 0076     
4200               
4201 1450 D020  22        movb @TYPE,ra                   ; LDA TYPE          ; Call ANGRY to make this ship hostile, now that we
     1452 009B     
4202 1454 0206  12        li   rtmp,ANGRY                 ; JSR ANGRY         ; have hit it
     1456 3C66     
4203 1458 06A0  24        bl   @jsr                       ;
     145A FF10     
4204               
4205               * ******************************************************************************
4206               *
4207               * Name: Main flight loop (Part 12 of 16)
4208               * Type: Subroutine
4209               * Category: Main loop
4210               * Summary: For each nearby ship: Draw the ship, remove if killed, loop back
4211               * Deep dive: Program flow of the main game loop
4212               * Drawing ships
4213               *
4214               * ------------------------------------------------------------------------------
4215               *
4216               * The main flight loop covers most of the flight-specific aspects of Elite. This
4217               * section covers the following:
4218               *
4219               * * Continue looping through all the ships in the local bubble, and for each
4220               * one:
4221               *
4222               * * Draw the ship
4223               *
4224               * * Process removal of killed ships
4225               *
4226               * * Loop back up to MAL1 to move onto the next ship in the local bubble
4227               *
4228               * ******************************************************************************
4229               
4230               MA8:
4231 145C 0206  12        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to draw the ship we're processing on-screen
     145E D4B4     
4232 1460 06A0  24        bl   @jsr                       ;
     1462 FF10     
4233               
4234               MA15:
4235 1464 0202  12        li   ry,>23*256                 ; LDY #35           ; Fetch the ship's energy from byte #35 and copy it to
     1466 2300     
4236 1468 D020  22        movb @INWK+35,ra                ; LDA INWK+35       ; byte #35 in INF (so the ship's data in K% gets
     146A 0076     
4237                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; updated)
     **** ****     > ST_IND_Y_IDX
0001 146C D820  38        movb @INF,@rtmplb
     146E 0020     
     1470 2079     
0002 1472 D1A0  22        movb @INF+1,rtmp
     1474 0021     
0003 1476 A182  14        a    ry,rtmp
0004 1478 D580  26        movb RA,*rtmp
                   < elite.a99
4238               
4239 147A D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; If bit 7 of the ship's byte #31 is clear, then the
     147C 0072     
4240 147E 1533  10        jgt  MAC1                       ; BPL MAC1          ; ship hasn't been killed by energy bomb, collision or
4241                                                                          ; laser fire, so jump to MAC1 to skip the following
4242               
4243 1480 0240  14        andi ra,>20*256                 ; AND #%00100000    ; If bit 5 of the ship's byte #31 is clear then the
     1482 2000     
4244 1484 1330  10        jeq  NBOUN                      ; BEQ NBOUN         ; ship is no longer exploding, so jump to NBOUN to skip
4245                                                                          ; the following
4246               
4247 1486 D020  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship we just destroyed was a cop, keep going,
     1488 009B     
4248 148A 0280  14        ci   ra,(COPS)*256              ; CMP #COPS         ; otherwise jump to q2 to skip the following
     148C 0200     
4249 148E 1606  10        jne  q2_                        ; BNE q2
4250               
4251 1490 D020  22        movb @FIST,ra                   ; LDA FIST          ; We shot the sheriff, so update our FIST flag
     1492 0334     
4252 1494 0260  14        ori  ra,>40*256                 ; ORA #64           ; ("fugitive/innocent status") to at least 64, which
     1496 4000     
4253 1498 D800  22        movb ra,@FIST                   ; STA FIST          ; will instantly make us a fugitive
     149A 0334     
4254               
4255               q2_:
4256 149C D020  22        movb @DLY,ra                    ; LDA DLY           ; If we already have an in-flight message on-screen (in
     149E 0D64     
4257 14A0 F020  22        socb @MJ,ra                     ; ORA MJ            ; which case DLY > 0), or we are in witchspace (in
     14A2 0D5C     
4258 14A4 161E  10        jne  KS1S                       ; BNE KS1S          ; which case MJ > 0), jump to KS1S to skip showing an
4259                                                                          ; on-screen bounty for this kill
4260               
4261 14A6 0202  12        li   ry,>0a*256                 ; LDY #10           ; Fetch byte #10 of the ship's blueprint, which is the
     14A8 0A00     
4262                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; low byte of the bounty awarded when this ship is
     **** ****     > LD_IND_Y_IDX
0001 14AA D820  38        movb @XX0,@rtmplb
     14AC 001E     
     14AE 2079     
0002 14B0 D1A0  22        movb @XX0+1,rtmp
     14B2 001F     
0003 14B4 A182  14        a    ry,rtmp
0004 14B6 D016  22        movb *rtmp,RA
                   < elite.a99
4263 14B8 1314  10        jeq  KS1S                       ; BEQ KS1S          ; killed (in Cr * 10), and if it's zero jump to KS1S as
4264                                                                          ; there is no on-screen bounty to display
4265               
4266 14BA D040  14        movb ra,rx                      ; TAX               ; Put the low byte of the bounty into X
4267               
4268 14BC B084  14        ab   rone,ry                    ; INY               ; Fetch byte #11 of the ship's blueprint, which is the
4269                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; high byte of the bounty awarded (in Cr * 10), and put
     **** ****     > LD_IND_Y_IDX
0001 14BE D820  38        movb @XX0,@rtmplb
     14C0 001E     
     14C2 2079     
0002 14C4 D1A0  22        movb @XX0+1,rtmp
     14C6 001F     
0003 14C8 A182  14        a    ry,rtmp
0004 14CA D016  22        movb *rtmp,RA
                   < elite.a99
4270 14CC D080  14        movb ra,ry                      ; TAY               ; it into Y
4271               
4272 14CE 0206  12        li   rtmp,MCASH                 ; JSR MCASH         ; Call MCASH to add (Y X) to the cash pot
     14D0 A1BE     
4273 14D2 06A0  24        bl   @jsr                       ;
     14D4 FF10     
4274               
4275 14D6 0200  12        li   ra,>00*256                 ; LDA #0            ; Print control code 0 (current cash, right-aligned to
     14D8 0000     
4276 14DA 0206  12        li   rtmp,MESS                  ; JSR MESS          ; width 9, then " CR", newline) as an in-flight message
     14DC CE5E     
4277 14DE 06A0  24        bl   @jsr                       ;
     14E0 FF10     
4278               
4279               KS1S:
4280 14E2 0460  20        b    @KS1                       ; JMP KS1           ; Process the killing of this ship (which removes this
     14E4 BC54     
4281                                                                          ; ship from its slot and shuffles all the other ships
4282                                                                          ; down to close up the gap)
4283               
4284               NBOUN:
4285                      equ  $
4286               MAC1:
4287 14E6 D020  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship we are processing is a planet or sun,
     14E8 009B     
4288 14EA 1105  10        jlt  MA27                       ; BMI MA27          ; jump to MA27 to skip the following two instructions
4289               
4290 14EC 0206  12        li   rtmp,FAROF                 ; JSR FAROF         ; If the ship we are processing is a long way away (its
     14EE C456     
4291 14F0 06A0  24        bl   @jsr                       ;
     14F2 FF10     
4292 14F4 17F6  10        jnc  KS1S                       ; BCC KS1S          ; distance in any one direction is > 224, jump to KS1S
4293                                                                          ; to remove the ship from our local bubble, as it's just
4294                                                                          ; left the building
4295               
4296               MA27:
4297 14F6 0202  12        li   ry,>1f*256                 ; LDY #31           ; Fetch the ship's explosion/killed state from byte #31
     14F8 1F00     
4298 14FA D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; and copy it to byte #31 in INF (so the ship's data in
     14FC 0072     
4299                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; K% gets updated)
     **** ****     > ST_IND_Y_IDX
0001 14FE D820  38        movb @INF,@rtmplb
     1500 0020     
     1502 2079     
0002 1504 D1A0  22        movb @INF+1,rtmp
     1506 0021     
0003 1508 A182  14        a    ry,rtmp
0004 150A D580  26        movb RA,*rtmp
                   < elite.a99
4300               
4301 150C D060  22        movb @XSAV,rx                   ; LDX XSAV          ; We're done processing this ship, so fetch the ship's
     150E 0093     
4302                                                                          ; slot number, which we saved in XSAV back at the start
4303                                                                          ; of the loop
4304               
4305 1510 B044  14        ab   rone,rx                    ; INX               ; Increment the slot number to move on to the next slot
4306               
4307 1512 0460  16        b    @MAL1                      ; JMP MAL1          ; And jump back up to the beginning of the loop to get
     1514 118C     
4308                                                                          ; the next ship in the local bubble for processing
4309               
4310               * ******************************************************************************
4311               *
4312               * Name: Main flight loop (Part 13 of 16)
4313               * Type: Subroutine
4314               * Category: Main loop
4315               * Summary: Show energy bomb effect, charge shields and energy banks
4316               * Deep dive: Program flow of the main game loop
4317               * Scheduling tasks with the main loop counter
4318               *
4319               * ------------------------------------------------------------------------------
4320               *
4321               * The main flight loop covers most of the flight-specific aspects of Elite. This
4322               * section covers the following:
4323               *
4324               * * Show energy bomb effect (if applicable)
4325               *
4326               * * Charge shields and energy banks (every 7 iterations of the main loop)
4327               *
4328               * ******************************************************************************
4329               
4330               MA18:
4331 1516 D020  22        movb @BOMB,ra                   ; LDA BOMB          ; If we set off our energy bomb (see MA24 above), then
     1518 032A     
4332 151A 150F  10        jgt  MA77                       ; BPL MA77          ; BOMB is now negative, so this skips to MA21 if our
4333                                                                          ; energy bomb is not going off
4334               
4335                      .asl @BOMB                      ; ASL BOMB          ; We set off our energy bomb, so rotate BOMB to the
     **** ****     > ASL
0001 151C D1A0  22        movb @BOMB,rtmp
     151E 032A     
0002 1520 0246  14        andi rtmp,>ff00
     1522 FF00     
0003 1524 0A16  14        sla  rtmp,1
0004 1526 D806  22        movb rtmp,@BOMB
     1528 032A     
                   < elite.a99
4336                                                                          ; left by one place. BOMB was rotated left once already
4337                                                                          ; during this iteration of the main loop, back at MA24,
4338                                                                          ; so if this is the first pass it will already be
4339                                                                          ; %11111110, and this will shift it to %11111100 - so
4340                                                                          ; if we set off an energy bomb, it stays activated
4341                                                                          ; (BOMB > 0) for four iterations of the main loop
4342               
4343 152A 0206  12        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     152C 4DE2     
4344 152E 06A0  24        bl   @jsr                       ;
     1530 FF10     
4345                                                                          ; screen gets drawn and the following palette change
4346                                                                          ; won't kick in while the screen is still refreshing
4347               
4348 1532 0200  12        li   ra,>30*256                 ; LDA #%00110000    ; Set the palette byte at SHEILA &21 to map logical
     1534 3000     
4349 1536 D800  30        movb ra,@VIA+>21                ; STA VIA+&21       ; colour 0 to physical colour 7 (white), but with only
     1538 FE21     
4350                                                                          ; one mapping (rather than the 7 mappings required to
4351                                                                          ; do the mapping properly). This makes the space screen
4352                                                                          ; flash with black and white stripes. See p.382 of the
4353                                                                          ; Advanced User Guide for details of why this single
4354                                                                          ; palette change creates a special effect
4355               
4356               MA77:
4357 153A D020  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 7,
     153C 0099     
4358 153E 0240  14        andi ra,>07*256                 ; AND #7            ; jumping to MA22 if it is non-zero (so the following
     1540 0700     
4359 1542 1664  10        jne  MA22                       ; BNE MA22          ; code only runs every 8 iterations of the main loop)
4360               
4361 1544 D060  22        movb @ENERGY,rx                 ; LDX ENERGY        ; Fetch our ship's energy levels and skip to b if bit 7
     1546 0F13     
4362 1548 1510  10        jgt  b_                         ; BPL b             ; is not set, i.e. only charge the shields from the
4363                                                                          ; energy banks if they are at more than 50% charge
4364               
4365 154A D060  22        movb @ASH,rx                    ; LDX ASH           ; Call SHD to recharge our aft shield and update the
     154C 0F12     
4366 154E 0206  12        li   rtmp,SHD                   ; JSR SHD           ; shield status in ASH
     1550 ACDE     
4367 1552 06A0  24        bl   @jsr                       ;
     1554 FF10     
4368 1556 D801  22        movb rx,@ASH                    ; STX ASH
     1558 0F12     
4369               
4370 155A D060  22        movb @FSH,rx                    ; LDX FSH           ; Call SHD to recharge our forward shield and update
     155C 0F11     
4371 155E 0206  12        li   rtmp,SHD                   ; JSR SHD           ; the shield status in FSH
     1560 ACDE     
4372 1562 06A0  24        bl   @jsr                       ;
     1564 FF10     
4373 1566 D801  22        movb rx,@FSH                    ; STX FSH
     1568 0F11     
4374               
4375               b_:
4376                      .sec                            ; SEC               ; Set A = ENERGY + ENGY + 1, so our ship's energy
     **** ****     > SEC
0001 156A 0A15  14        sla  rmone,1
                   < elite.a99
4377 156C D020  22        movb @ENGY,ra                   ; LDA ENGY          ; level goes up by 2 if we have an energy unit fitted,
     156E 032B     
4378                      .adc @ENERGY,ra                 ; ADC ENERGY        ; otherwise it goes up by 1
     **** ****     > ADC
0001 1570 1701  10        jnc  !
0002 1572 B004  14        ab   rone,ra
0003               !:
0004 1574 B020  22        ab   @ENERGY,ra
     1576 0F13     
                   < elite.a99
4379               
4380 1578 1802  10        joc  B09                        ; BCS B09           ; If the value of A did not overflow (the maximum
4381 157A D800  22        movb ra,@ENERGY                 ; STA ENERGY        ; energy level is &FF), then store A in ENERGY
     157C 0F13     
4382               
4383               * ******************************************************************************
4384               *
4385               * Name: Main flight loop (Part 14 of 16)
4386               * Type: Subroutine
4387               * Category: Main loop
4388               * Summary: Spawn a space station if we are close enough to the planet
4389               * Deep dive: Program flow of the main game loop
4390               * Scheduling tasks with the main loop counter
4391               * Ship data blocks
4392               * The space station safe zone
4393               *
4394               * ------------------------------------------------------------------------------
4395               *
4396               * The main flight loop covers most of the flight-specific aspects of Elite. This
4397               * section covers the following:
4398               *
4399               * * Spawn a space station if we are close enough to the planet (every 32
4400               * iterations of the main loop)
4401               *
4402               * ******************************************************************************
4403               
4404               B09:
4405 157E D020  22        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace, jump down to MA23S to skip
     1580 0D5C     
4406 1582 1642  10        jne  MA23S                      ; BNE MA23S         ; the following, as there are no space stations in
4407                                                                          ; witchspace
4408               
4409 1584 D020  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 32,
     1586 0099     
4410 1588 0240  14        andi ra,>1f*256                 ; AND #31           ; jumping to MA93 if it is on-zero (so the following
     158A 1F00     
4411 158C 1646  10        jne  MA93                       ; BNE MA93          ; code only runs every 32 iterations of the main loop)
4412               
4413 158E D020  22        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     1590 0D55     
4414 1592 163A  10        jne  MA23S                      ; BNE MA23S         ; MA23S to skip the following, as we already have a
4415                                                                          ; space station and don't need another
4416               
4417 1594 D080  14        movb ra,ry                      ; TAY               ; Set Y = A = 0 (A is 0 as we didn't branch with the
4418                                                                          ; previous BNE instruction)
4419               
4420 1596 0206  12        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to calculate the largest distance to the
     1598 1786     
4421 159A 06A0  24        bl   @jsr                       ;
     159C FF10     
4422 159E 1634  10        jne  MA23S                      ; BNE MA23S         ; planet in any of the three axes, and if it's
4423                                                                          ; non-zero, jump to MA23S to skip the following, as we
4424                                                                          ; are too far from the planet to bump into a space
4425                                                                          ; station
4426               
4427                                                                          ; We now want to spawn a space station, so first we
4428                                                                          ; need to set up a ship data block for the station in
4429                                                                          ; INWK that we can then pass to NWSPS to add a new
4430                                                                          ; station to our bubble of universe. We do this by
4431                                                                          ; copying the planet data block from K% to INWK so we
4432                                                                          ; can work on it, but we only need the first 29 bytes,
4433                                                                          ; as we don't need to worry about bytes #29 to #35
4434                                                                          ; for planets (as they don't have rotation counters,
4435                                                                          ; AI, explosions, missiles, a ship line heap or energy
4436                                                                          ; levels)
4437               
4438 15A0 0201  12        li   rx,>1c*256                 ; LDX #28           ; So we set a counter in X to copy 29 bytes from K%+0
     15A2 1C00     
4439                                                                          ; to K%+28
4440               
4441               MAL4:
4442 15A4 D021  26        movb @K.(rx),ra                 ; LDA K%,X          ; Load the X-th byte of K% and store in the X-th byte
     15A6 0900     
4443 15A8 D840  30        movb ra,@INWK(rx)               ; STA INWK,X        ; of the INWK workspace
     15AA 0053     
4444               
4445 15AC 7044  14        sb   rone,rx                    ; DEX               ; Decrement the loop counter
4446               
4447 15AE 15FA  10        jgt  MAL4                       ; BPL MAL4          ; Loop back for the next byte until we have copied the
4448                                                                          ; first 28 bytes of K% to INWK
4449               
4450                                                                          ; We now check the distance from our ship (at the
4451                                                                          ; origin) towards the point where we will spawn the
4452                                                                          ; space station if we are close enough
4453                                                                          ;
4454                                                                          ; This point is calculated by starting at the planet's
4455                                                                          ; centre and adding 2 * nosev, which takes us to a point
4456                                                                          ; above the planet's surface, at an altitude that
4457                                                                          ; matches the planet's radius
4458                                                                          ;
4459                                                                          ; This point pitches and rolls around the planet as the
4460                                                                          ; nosev vector rotates with the planet, and if our ship
4461                                                                          ; is within a distance of (192 0) from this point in all
4462                                                                          ; three axes, then we spawn the space station at this
4463                                                                          ; point, with the station's slot facing towards the
4464                                                                          ; planet, along the nosev vector
4465                                                                          ;
4466                                                                          ; This works because in the following, we calculate the
4467                                                                          ; station's coordinates one axis at a time, and store
4468                                                                          ; the results in the INWK block, so by the time we have
4469                                                                          ; calculated and checked all three, the ship data block
4470                                                                          ; is set up with the correct spawning coordinates
4471               
4472 15B0 B044  14        ab   rone,rx                    ; INX               ; Set X = 0 (as we ended the above loop with X as &FF)
4473               
4474 15B2 0202  12        li   ry,>09*256                 ; LDY #9            ; Call MAS1 with X = 0, Y = 9 to do the following:
     15B4 0900     
4475 15B6 0206  12        li   rtmp,MAS1                  ; JSR MAS1          ;
     15B8 1738     
4476 15BA 06A0  24        bl   @jsr                       ;
     15BC FF10     
4477                                                                          ; (x_sign x_hi x_lo) += (nosev_x_hi nosev_x_lo) * 2
4478                                                                          ;
4479                                                                          ; A = |x_sign|
4480               
4481 15BE 1624  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4482                                                                          ; are too far from the planet in the x-direction to
4483                                                                          ; bump into a space station
4484               
4485 15C0 0201  12        li   rx,>03*256                 ; LDX #3            ; Call MAS1 with X = 3, Y = 11 to do the following:
     15C2 0300     
4486 15C4 0202  12        li   ry,>0b*256                 ; LDY #11           ;
     15C6 0B00     
4487 15C8 0206  12        li   rtmp,MAS1                  ; JSR MAS1          ; (y_sign y_hi y_lo) += (nosev_y_hi nosev_y_lo) * 2
     15CA 1738     
4488 15CC 06A0  24        bl   @jsr                       ;
     15CE FF10     
4489                                                                          ;
4490                                                                          ; A = |y_sign|
4491               
4492 15D0 161B  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4493                                                                          ; are too far from the planet in the y-direction to
4494                                                                          ; bump into a space station
4495               
4496 15D2 0201  12        li   rx,>06*256                 ; LDX #6            ; Call MAS1 with X = 6, Y = 13 to do the following:
     15D4 0600     
4497 15D6 0202  12        li   ry,>0d*256                 ; LDY #13           ;
     15D8 0D00     
4498 15DA 0206  12        li   rtmp,MAS1                  ; JSR MAS1          ; (z_sign z_hi z_lo) += (nosev_z_hi nosev_z_lo) * 2
     15DC 1738     
4499 15DE 06A0  24        bl   @jsr                       ;
     15E0 FF10     
4500                                                                          ;
4501                                                                          ; A = |z_sign|
4502               
4503 15E2 1612  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4504                                                                          ; are too far from the planet in the z-direction to
4505                                                                          ; bump into a space station
4506               
4507 15E4 0200  12        li   ra,>c0*256                 ; LDA #192          ; Call FAROF2 to compare x_hi, y_hi and z_hi with 192,
     15E6 C000     
4508 15E8 0206  12        li   rtmp,FAROF2                ; JSR FAROF2        ; which will set the C flag if all three are < 192, or
     15EA C45A     
4509 15EC 06A0  24        bl   @jsr                       ;
     15EE FF10     
4510                                                                          ; clear the C flag if any of them are >= 192
4511               
4512 15F0 170B  10        jnc  MA23S                      ; BCC MA23S         ; Jump to MA23S if any one of x_hi, y_hi or z_hi are
4513                                                                          ; >= 192 (i.e. they must all be < 192 for us to be near
4514                                                                          ; enough to the planet to bump into a space station)
4515               
4516 15F2 D020  22        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is not a space view, skip the
     15F4 0096     
4517 15F6 1604  10        jne  B10                        ; BNE B10           ; following instruction (so we only remove the sun from
4518                                                                          ; the screen if we are potentially looking at it)
4519               
4520 15F8 0206  12        li   rtmp,WPLS                  ; JSR WPLS          ; Call WPLS to remove the sun from the screen, as we
     15FA B97C     
4521 15FC 06A0  24        bl   @jsr                       ;
     15FE FF10     
4522                                                                          ; can't have both the sun and the space station at the
4523                                                                          ; same time
4524               
4525               B10:
4526 1600 0206  12        li   rtmp,NWSPS                 ; JSR NWSPS         ; Add a new space station to our local bubble of
     1602 AF2A     
4527 1604 06A0  24        bl   @jsr                       ;
     1606 FF10     
4528                                                                          ; universe
4529               
4530               MA23S:
4531 1608 0460  16        b    @MA23                      ; JMP MA23          ; Jump to MA23 to skip the following planet and sun
     160A 16EC     
4532                                                                          ; altitude checks
4533               
4534               * ******************************************************************************
4535               *
4536               * Name: Main flight loop (Part 15 of 16)
4537               * Type: Subroutine
4538               * Category: Main loop
4539               * Summary: Perform altitude checks with the planet and sun and process fuel
4540               * scooping if appropriate
4541               * Deep dive: Program flow of the main game loop
4542               * Scheduling tasks with the main loop counter
4543               *
4544               * ------------------------------------------------------------------------------
4545               *
4546               * The main flight loop covers most of the flight-specific aspects of Elite. This
4547               * section covers the following:
4548               *
4549               * * Perform an altitude check with the planet (every 32 iterations of the main
4550               * loop, on iteration 10 of each 32)
4551               *
4552               * * Perform an altitude check with the sun and process fuel scooping (every
4553               * 32 iterations of the main loop, on iteration 20 of each 32)
4554               *
4555               * ******************************************************************************
4556               
4557               MA22:
4558 160C D020  22        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace, jump down to MA23 to skip
     160E 0D5C     
4559 1610 166D  10        jne  MA23                       ; BNE MA23          ; the following, as there are no planets or suns to
4560                                                                          ; bump into in witchspace
4561               
4562 1612 D020  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 32,
     1614 0099     
4563 1616 0240  14        andi ra,>1f*256                 ; AND #31           ; which tells us the position of this loop in each block
     1618 1F00     
4564                                                                          ; of 32 iterations
4565               
4566               MA93:
4567 161A 0280  14        ci   ra,>0a*256                 ; CMP #10           ; If this is the tenth iteration in this block of 32,
     161C 0A00     
4568 161E 162D  10        jne  MA29                       ; BNE MA29          ; do the following, otherwise jump to MA29 to skip the
4569                                                                          ; planet altitude check and move on to the sun distance
4570                                                                          ; check
4571               
4572 1620 0200  12        li   ra,>32*256                 ; LDA #50           ; If our energy bank status in ENERGY is >= 50, skip
     1622 3200     
4573 1624 9020  22        cb   @ENERGY,ra                 ; CMP ENERGY        ; printing the following message (so the message is
     1626 0F13     
4574 1628 1707  10        jnc  B11                        ; BCC B11           ; only shown if our energy is low)
4575               
4576                      .asla                           ; ASL A             ; Print recursive token 100 ("ENERGY LOW{beep}") as an
     **** ****     > ASLA
0001 162A 0240  14        andi ra,>ff00
     162C FF00     
0002 162E 0A10  14        sla  ra,1
                   < elite.a99
4577 1630 0206  12        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     1632 CE5E     
4578 1634 06A0  24        bl   @jsr                       ;
     1636 FF10     
4579               
4580               B11:
4581 1638 0202  12        li   ry,>ff*256                 ; LDY #&FF          ; Set our altitude in ALTIT to &FF, the maximum
     163A FF00     
4582 163C D802  22        movb ry,@ALTIT                  ; STY ALTIT
     163E 0F21     
4583               
4584 1640 B084  14        ab   rone,ry                    ; INY               ; Set Y = 0
4585               
4586 1642 0206  12        li   rtmp,m_                    ; JSR m             ; Call m to calculate the maximum distance to the
     1644 1782     
4587 1646 06A0  24        bl   @jsr                       ;
     1648 FF10     
4588                                                                          ; planet in any of the three axes, returned in A
4589               
4590 164A 1650  10        jne  MA23                       ; BNE MA23          ; If A > 0 then we are a fair distance away from the
4591                                                                          ; planet in at least one axis, so jump to MA23 to skip
4592                                                                          ; the rest of the altitude check
4593               
4594 164C 0206  12        li   rtmp,MAS3                  ; JSR MAS3          ; Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
     164E 179A     
4595 1650 06A0  24        bl   @jsr                       ;
     1652 FF10     
4596                                                                          ; we now know that A now contains the square of the
4597                                                                          ; distance between our ship (at the origin) and the
4598                                                                          ; centre of the planet at (x_hi, y_hi, z_hi)
4599               
4600 1654 184B  10        joc  MA23                       ; BCS MA23          ; If the C flag was set by MAS3, then the result
4601                                                                          ; overflowed (was greater than &FF) and we are still a
4602                                                                          ; fair distance from the planet, so jump to MA23 as we
4603                                                                          ; haven't crashed into the planet
4604               
4605                      .sbi (>24*256)                  ; SBC #36           ; Subtract 36 from x_hi^2 + y_hi^2 + z_hi^2
     **** ****     > SBI
0001 1656 1801  10        joc  !
0002 1658 7004  14        sb   rone,ra
0003               !:
0004 165A 0220  14        ai   ra,-(>24*256)
     165C DC00     
                   < elite.a99
4606                                                                          ;
4607                                                                          ; When we do the 3D Pythagoras calculation, we only use
4608                                                                          ; the high bytes of the coordinates, so that's x_hi,
4609                                                                          ; y_hi and z_hi and
4610                                                                          ;
4611                                                                          ; The planet radius is (0 96 0), as defined in the
4612                                                                          ; PLANET routine, so the high byte is 96
4613                                                                          ;
4614                                                                          ; When we square the coordinates above and add them,
4615                                                                          ; the result gets divided by 256 (otherwise the result
4616                                                                          ; wouldn't fit into one byte), so if we do the same for
4617                                                                          ; the planet's radius, we get:
4618                                                                          ;
4619                                                                          ; 96 * 96 / 256 = 36
4620                                                                          ;
4621                                                                          ; So for the planet, the equivalent figure to test the
4622                                                                          ; sum of the _hi bytes against is 36, so A now contains
4623                                                                          ; the high byte of our altitude above the planet
4624                                                                          ; surface, squared
4625               
4626 165E 170B  10        jnc  MA28                       ; BCC MA28          ; If A < 0 then jump to MA28 as we have crashed into
4627                                                                          ; the planet
4628               
4629 1660 D800  22        movb ra,@R                      ; STA R             ; We are getting close to the planet, so we need to
     1662 0091     
4630 1664 0206  12        li   rtmp,LL5                   ; JSR LL5           ; work out how close. We know from the above that A
     1666 D2B6     
4631 1668 06A0  24        bl   @jsr                       ;
     166A FF10     
4632                                                                          ; contains our altitude squared, so we store A in R
4633                                                                          ; and call LL5 to calculate:
4634                                                                          ;
4635                                                                          ; Q = SQRT(R Q) = SQRT(A Q)
4636                                                                          ;
4637                                                                          ; Interestingly, Q doesn't appear to be set to 0 for
4638                                                                          ; this calculation, so presumably this doesn't make a
4639                                                                          ; difference
4640               
4641 166C D020  22        movb @Q,ra                      ; LDA Q             ; Store the result in ALTIT, our altitude
     166E 0090     
4642 1670 D800  22        movb ra,@ALTIT                  ; STA ALTIT
     1672 0F21     
4643               
4644 1674 163B  10        jne  MA23                       ; BNE MA23          ; If our altitude is non-zero then we haven't crashed,
4645                                                                          ; so jump to MA23 to skip to the next section
4646               
4647               MA28:
4648 1676 0460  20        b    @DEATH                     ; JMP DEATH         ; If we get here then we just crashed into the planet
     1678 C47E     
4649                                                                          ; or got too close to the sun, so jump to DEATH to start
4650                                                                          ; the funeral preparations and return from the main
4651                                                                          ; flight loop using a tail call
4652               
4653               MA29:
4654 167A 0280  14        ci   ra,>14*256                 ; CMP #20           ; If this is the 20th iteration in this block of 32,
     167C 1400     
4655 167E 1636  10        jne  MA23                       ; BNE MA23          ; do the following, otherwise jump to MA23 to skip the
4656                                                                          ; sun altitude check
4657               
4658 1680 0200  12        li   ra,>1e*256                 ; LDA #30           ; Set CABTMP to 30, the cabin temperature in deep space
     1682 1E00     
4659 1684 D800  22        movb ra,@CABTMP                 ; STA CABTMP        ; (i.e. one notch on the dashboard bar)
     1686 0D4D     
4660               
4661 1688 D020  22        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     168A 0D55     
4662 168C 162F  10        jne  MA23                       ; BNE MA23          ; MA23 to skip the following, as we can't have both the
4663                                                                          ; sun and space station at the same time, so we clearly
4664                                                                          ; can't be flying near the sun
4665               
4666 168E 0202  12        li   ry,(NI.)*256               ; LDY #NI%          ; Set Y to NI%, which is the offset in K% for the sun's
     1690 2400     
4667                                                                          ; data block, as the second block at K% is reserved for
4668                                                                          ; the sun (or space station)
4669               
4670 1692 0206  12        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to calculate the largest distance to the
     1694 1786     
4671 1696 06A0  24        bl   @jsr                       ;
     1698 FF10     
4672 169A 1628  10        jne  MA23                       ; BNE MA23          ; sun in any of the three axes, and if it's non-zero,
4673                                                                          ; jump to MA23 to skip the following, as we are too far
4674                                                                          ; from the sun for scooping or temperature changes
4675               
4676 169C 0206  12        li   rtmp,MAS3                  ; JSR MAS3          ; Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
     169E 179A     
4677 16A0 06A0  24        bl   @jsr                       ;
     16A2 FF10     
4678                                                                          ; we now know that A now contains the square of the
4679                                                                          ; distance between our ship (at the origin) and the
4680                                                                          ; heart of the sun at (x_hi, y_hi, z_hi)
4681               
4682                      .eoi (>ff*256)                  ; EOR #%11111111    ; Invert A, so A is now small if we are far from the
     **** ****     > EOI
0001 16A4 0206  12        li   rtmp,(>FF*256)
     16A6 FF00     
0002 16A8 2806  14        xor  rtmp,ra
                   < elite.a99
4683                                                                          ; sun and large if we are close to the sun, in the
4684                                                                          ; range 0 = far away to &FF = extremely close, ouch,
4685                                                                          ; hot, hot, hot!
4686               
4687                      .adi (>1e*256)                  ; ADC #30           ; Add the minimum cabin temperature of 30, so we get
     **** ****     > ADI
0001 16AA 1701  10        jnc  !
0002 16AC B004  14        ab   rone,ra
0003               !:
0004 16AE 0220  14        ai   ra,(>1E*256)
     16B0 1E00     
                   < elite.a99
4688                                                                          ; one of the following:
4689                                                                          ;
4690                                                                          ; * If the C flag is clear, A contains the cabin
4691                                                                          ; temperature, ranging from 30 to 255, that's hotter
4692                                                                          ; the closer we are to the sun
4693                                                                          ;
4694                                                                          ; * If the C flag is set, the addition has rolled over
4695                                                                          ; and the cabin temperature is over 255
4696               
4697 16B2 D800  22        movb ra,@CABTMP                 ; STA CABTMP        ; Store the updated cabin temperature
     16B4 0D4D     
4698               
4699 16B6 18DF  10        joc  MA28                       ; BCS MA28          ; If the C flag is set then jump to MA28 to die, as
4700                                                                          ; our temperature is off the scale
4701               
4702 16B8 0280  14        ci   ra,>e0*256                 ; CMP #224          ; If the cabin temperature < 224 then jump to MA23 to
     16BA E000     
4703 16BC 1717  10        jnc  MA23                       ; BCC MA23          ; skip fuel scooping, as we aren't close enough
4704               
4705 16BE D020  22        movb @BST,ra                    ; LDA BST           ; If we don't have fuel scoops fitted, jump to BA23 to
     16C0 0329     
4706 16C2 1314  10        jeq  MA23                       ; BEQ MA23          ; skip fuel scooping, as we can't scoop without fuel
4707                                                                          ; scoops
4708               
4709 16C4 D020  22        movb @DELT4+1,ra                ; LDA DELT4+1       ; We are now successfully fuel scooping, so it's time
     16C6 008E     
4710 16C8 0910  14        srl  ra,1                       ; LSR A             ; to work out how much fuel we're scooping. Fetch the
4711                                                                          ; high byte of DELT4, which contains our current speed
4712                                                                          ; divided by 4, and halve it to get our current speed
4713                                                                          ; divided by 8 (so it's now a value between 1 and 5, as
4714                                                                          ; our speed is normally between 1 and 40). This gives
4715                                                                          ; us the amount of fuel that's being scooped in A, so
4716                                                                          ; the faster we go, the more fuel we scoop, and because
4717                                                                          ; the fuel levels are stored as 10 * the fuel in light
4718                                                                          ; years, that means we just scooped between 0.1 and 0.5
4719                                                                          ; light years of free fuel
4720               
4721                      .adc @QQ14,ra                   ; ADC QQ14          ; Set A = A + the current fuel level * 10 (from QQ14)
     **** ****     > ADC
0001 16CA 1701  10        jnc  !
0002 16CC B004  14        ab   rone,ra
0003               !:
0004 16CE B020  22        ab   @QQ14,ra
     16D0 030D     
                   < elite.a99
4722               
4723 16D2 0280  14        ci   ra,>46*256                 ; CMP #70           ; If A > 70 then set A = 70 (as 70 is the maximum fuel
     16D4 4600     
4724 16D6 1702  10        jnc  B12                        ; BCC B12           ; level, or 7.0 light years)
4725 16D8 0200  12        li   ra,>46*256                 ; LDA #70
     16DA 4600     
4726               
4727               B12:
4728 16DC D800  22        movb ra,@QQ14                   ; STA QQ14          ; Store the updated fuel level in QQ14
     16DE 030D     
4729               
4730 16E0 0200  12        li   ra,>a0*256                 ; LDA #160          ; Print recursive token 0 ("FUEL SCOOPS ON") as an
     16E2 A000     
4731 16E4 0206  12        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     16E6 CE5E     
4732 16E8 06A0  24        bl   @jsr                       ;
     16EA FF10     
4733               
4734               * ******************************************************************************
4735               *
4736               * Name: Main flight loop (Part 16 of 16)
4737               * Type: Subroutine
4738               * Category: Main loop
4739               * Summary: Process laser pulsing, E.C.M. energy drain, call stardust routine
4740               * Deep dive: Program flow of the main game loop
4741               *
4742               * ------------------------------------------------------------------------------
4743               *
4744               * The main flight loop covers most of the flight-specific aspects of Elite. This
4745               * section covers the following:
4746               *
4747               * * Process laser pulsing
4748               *
4749               * * Process E.C.M. energy drain
4750               *
4751               * * Jump to the stardust routine if we are in a space view
4752               *
4753               * * Return from the main flight loop
4754               *
4755               * ******************************************************************************
4756               
4757               MA23:
4758 16EC D020  22        movb @LAS2,ra                   ; LDA LAS2          ; If the current view has no laser, jump to MA16 to skip
     16EE 0D5D     
4759 16F0 130D  10        jeq  MA16                       ; BEQ MA16          ; the following
4760               
4761 16F2 D020  22        movb @LASCT,ra                  ; LDA LASCT         ; If LASCT >= 8, jump to MA16 to skip the following, so
     16F4 0D60     
4762 16F6 0280  14        ci   ra,>08*256                 ; CMP #8            ; for a pulse laser with a LASCT between 8 and 10, the
     16F8 0800     
4763 16FA 1808  10        joc  MA16                       ; BCS MA16          ; laser stays on, but for a LASCT of 7 or less it gets
4764                                                                          ; turned off and stays off until LASCT reaches zero and
4765                                                                          ; the next pulse can start (if the fire button is still
4766                                                                          ; being pressed)
4767                                                                          ;
4768                                                                          ; For pulse lasers, LASCT gets set to 10 in ma1 above,
4769                                                                          ; and it decrements every vertical sync (50 times a
4770                                                                          ; second), so this means it pulses five times a second,
4771                                                                          ; with the laser being on for the first 3/10 of each
4772                                                                          ; pulse and off for the rest of the pulse
4773                                                                          ;
4774                                                                          ; If this is a beam laser, LASCT is 0 so we always keep
4775                                                                          ; going here. This means the laser doesn't pulse, but it
4776                                                                          ; does get drawn and removed every cycle, in a slightly
4777                                                                          ; different place each time, so the beams still flicker
4778                                                                          ; around the screen
4779               
4780 16FC 0206  12        li   rtmp,LASLI2                ; JSR LASLI2        ; Redraw the existing laser lines, which has the effect
     16FE 4922     
4781 1700 06A0  24        bl   @jsr                       ;
     1702 FF10     
4782                                                                          ; of removing them from the screen
4783               
4784 1704 0200  12        li   ra,>00*256                 ; LDA #0            ; Set LAS2 to 0 so if this is a pulse laser, it will
     1706 0000     
4785 1708 D800  22        movb ra,@LAS2                   ; STA LAS2          ; skip over the above until the next pulse (this has no
     170A 0D5D     
4786                                                                          ; effect if this is a beam laser)
4787               
4788               MA16:
4789 170C D020  22        movb @ECMP,ra                   ; LDA ECMP          ; If our E.C.M is not on, skip to MA69, otherwise keep
     170E 0D5B     
4790 1710 1305  10        jeq  MA69                       ; BEQ MA69          ; going to drain some energy
4791               
4792 1712 0206  12        li   rtmp,DENGY                 ; JSR DENGY         ; Call DENGY to deplete our energy banks by 1
     1714 ACE2     
4793 1716 06A0  24        bl   @jsr                       ;
     1718 FF10     
4794               
4795 171A 1305  10        jeq  MA70                       ; BEQ MA70          ; If we have no energy left, jump to MA70 to turn our
4796                                                                          ; E.C.M. off
4797               
4798               MA69:
4799 171C D020  22        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M is going off (ours or an opponent's) then
     171E 0030     
4800 1720 1306  10        jeq  MA66                       ; BEQ MA66          ; keep going, otherwise skip to MA66
4801               
4802 1722 7004  14        sb   rone,ra                    ; DEC ECMA          ; Decrement the E.C.M. countdown timer, and if it has
4803 1724 1604  10        jne  MA66                       ; BNE MA66          ; reached zero, keep going, otherwise skip to MA66
4804               
4805               MA70:
4806 1726 0206  12        li   rtmp,ECMOF                 ; JSR ECMOF         ; If we get here then either we have either run out of
     1728 CB14     
4807 172A 06A0  24        bl   @jsr                       ;
     172C FF10     
4808                                                                          ; energy, or the E.C.M. timer has run down, so switch
4809                                                                          ; off the E.C.M.
4810               
4811               MA66:
4812 172E D020  22        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view (i.e. QQ11 is non-zero)
     1730 0096     
4813 1732 1625  10        jne  MA9                        ; BNE MA9           ; then jump to MA9 to return from the main flight loop
4814                                                                          ; (as MA9 is an RTS)
4815               
4816 1734 0460  20        b    @STARS                     ; JMP STARS         ; This is a space view, so jump to the STARS routine to
     1736 299A     
4817                                                                          ; process the stardust, and return from the main flight
4818                                                                          ; loop using a tail call
4819               
4820               * ******************************************************************************
4821               *
4822               * Name: MAS1
4823               * Type: Subroutine
4824               * Category: Maths (Geometry)
4825               * Summary: Add an orientation vector coordinate to an INWK coordinate
4826               * Deep dive: The space station safe zone
4827               *
4828               * ------------------------------------------------------------------------------
4829               *
4830               * Add a doubled nosev vector coordinate, e.g. (nosev_y_hi nosev_y_lo) * 2, to
4831               * an INWK coordinate, e.g. (x_sign x_hi x_lo), storing the result in the INWK
4832               * coordinate. The axes used in each side of the addition are specified by the
4833               * arguments X and Y.
4834               *
4835               * In the comments below, we document the routine as if we are doing the
4836               * following, i.e. if X = 0 and Y = 11:
4837               *
4838               * (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (nosev_y_hi nosev_y_lo) * 2
4839               *
4840               * as that way the variable names in the comments contain "x" and "y" to match
4841               * the registers that specify the vector axis to use.
4842               *
4843               * ------------------------------------------------------------------------------
4844               *
4845               * Arguments:
4846               *
4847               * X                   The coordinate to add, as follows:
4848               *
4849               * * If X = 0, add (x_sign x_hi x_lo)
4850               * * If X = 3, add (y_sign y_hi y_lo)
4851               * * If X = 6, add (z_sign z_hi z_lo)
4852               *
4853               * Y                   The vector to add, as follows:
4854               *
4855               * * If Y = 9,  add (nosev_x_hi nosev_x_lo)
4856               * * If Y = 11, add (nosev_y_hi nosev_y_lo)
4857               * * If Y = 13, add (nosev_z_hi nosev_z_lo)
4858               *
4859               * ------------------------------------------------------------------------------
4860               *
4861               * Returns:
4862               *
4863               * A                   The highest byte of the result with the sign cleared
4864               * (e.g. |x_sign| when X = 0, etc.)
4865               *
4866               * ------------------------------------------------------------------------------
4867               *
4868               * Other entry points:
4869               *
4870               * MA9                 Contains an RTS
4871               *
4872               * ******************************************************************************
4873               
4874               MAS1:
4875 1738 D022  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Set K(2 1) = (nosev_y_hi nosev_y_lo) * 2
     173A 0053     
4876                      .asla                           ; ASL A
     **** ****     > ASLA
0001 173C 0240  14        andi ra,>ff00
     173E FF00     
0002 1740 0A10  14        sla  ra,1
                   < elite.a99
4877 1742 D800  22        movb ra,@K+1                    ; STA K+1
     1744 003E     
4878 1746 D022  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y
     1748 0054     
4879 174A 06A0  24        bl   @rola                      ; ROL A
     174C FF26     
4880 174E D800  22        movb ra,@K+2                    ; STA K+2
     1750 003F     
4881               
4882 1752 0200  12        li   ra,>00*256                 ; LDA #0            ; Set K+3 bit 7 to the C flag, so the sign bit of the
     1754 0000     
4883 1756 06A0  24        bl   @rora                      ; ROR A             ; above result goes into K+3
     1758 FF4A     
4884 175A D800  22        movb ra,@K+3                    ; STA K+3
     175C 0040     
4885               
4886 175E 0206  12        li   rtmp,MVT3                  ; JSR MVT3          ; Add (x_sign x_hi x_lo) to K(3 2 1)
     1760 1C88     
4887 1762 06A0  24        bl   @jsr                       ;
     1764 FF10     
4888               
4889 1766 D840  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X      ; Store the sign of the result in x_sign
     1768 0055     
4890               
4891 176A D0A0  22        movb @K+1,ry                    ; LDY K+1           ; Store K(2 1) in (x_hi x_lo)
     176C 003E     
4892 176E D842  30        movb ry,@INWK(rx)               ; STY INWK,X
     1770 0053     
4893 1772 D0A0  22        movb @K+2,ry                    ; LDY K+2
     1774 003F     
4894 1776 D842  30        movb ry,@INWK+1(rx)             ; STY INWK+1,X
     1778 0054     
4895               
4896 177A 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; Set A to the sign byte with the sign cleared,
     177C 7F00     
4897                                                                          ; i.e. |x_sign| when X = 0
4898               
4899               MA9:
4900 177E 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1780 FF1C     
4901               
4902               * ******************************************************************************
4903               *
4904               * Name: MAS2
4905               * Type: Subroutine
4906               * Category: Maths (Geometry)
4907               * Summary: Calculate a cap on the maximum distance to the planet or sun
4908               *
4909               * ------------------------------------------------------------------------------
4910               *
4911               * Given a value in Y that points to the start of a ship data block as an offset
4912               * from K%, calculate the following:
4913               *
4914               * A = A OR x_sign OR y_sign OR z_sign
4915               *
4916               * and clear the sign bit of the result. The K% workspace contains the ship data
4917               * blocks, so the offset in Y must be 0 or a multiple of NI% (as each block in
4918               * K% contains NI% bytes).
4919               *
4920               * The result effectively contains a maximum cap of the three values (though it
4921               * might not be one of the three input values - it's just guaranteed to be
4922               * larger than all of them).
4923               *
4924               * If Y = 0 and A = 0, then this calculates the maximum cap of the highest byte
4925               * containing the distance to the planet, as K%+2 = x_sign, K%+5 = y_sign and
4926               * K%+8 = z_sign (the first slot in the K% workspace represents the planet).
4927               *
4928               * ------------------------------------------------------------------------------
4929               *
4930               * Arguments:
4931               *
4932               * Y                   The offset from K% for the start of the ship data block
4933               * to use
4934               *
4935               * ------------------------------------------------------------------------------
4936               *
4937               * Returns:
4938               *
4939               * A                   A OR K%+2+Y OR K%+5+Y OR K%+8+Y, with bit 7 cleared
4940               *
4941               * ------------------------------------------------------------------------------
4942               *
4943               * Other entry points:
4944               *
4945               * m                   Do not include A in the calculation
4946               *
4947               * ******************************************************************************
4948               
4949               m_:
4950 1782 0200  12        li   ra,>00*256                 ; LDA #0            ; Set A = 0 and fall through into MAS2 to calculate the
     1784 0000     
4951                                                                          ; OR of the three bytes at K%+2+Y, K%+5+Y and K%+8+Y
4952               
4953               MAS2:
4954 1786 F022  26        socb @K.+2(ry),ra               ; ORA K%+2,Y        ; Set A = A OR x_sign OR y_sign OR z_sign
     1788 0902     
4955 178A F022  26        socb @K.+5(ry),ra               ; ORA K%+5,Y
     178C 0905     
4956 178E F022  26        socb @K.+8(ry),ra               ; ORA K%+8,Y
     1790 0908     
4957               
4958 1792 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; Clear bit 7 in A
     1794 7F00     
4959               
4960 1796 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1798 FF1C     
4961               
4962               * ******************************************************************************
4963               *
4964               * Name: MAS3
4965               * Type: Subroutine
4966               * Category: Maths (Arithmetic)
4967               * Summary: Calculate A = x_hi^2 + y_hi^2 + z_hi^2 in the K% block
4968               *
4969               * ------------------------------------------------------------------------------
4970               *
4971               * Given a value in Y that points to the start of a ship data block as an offset
4972               * from K%, calculate the following:
4973               *
4974               * A = x_hi^2 + y_hi^2 + z_hi^2
4975               *
4976               * returning A = &FF if the calculation overflows a one-byte result. The K%
4977               * workspace contains the ship data blocks, so the offset in Y must be 0 or a
4978               * multiple of NI% (as each block in K% contains NI% bytes).
4979               *
4980               * ------------------------------------------------------------------------------
4981               *
4982               * Arguments:
4983               *
4984               * Y                   The offset from K% for the start of the ship data block
4985               * to use
4986               *
4987               * Returns
4988               *
4989               * A                   A = x_hi^2 + y_hi^2 + z_hi^2
4990               *
4991               * A = &FF if the calculation overflows a one-byte result
4992               *
4993               * ******************************************************************************
4994               
4995               MAS3:
4996 179A D022  26        movb @K.+1(ry),ra               ; LDA K%+1,Y        ; Set (A P) = x_hi * x_hi
     179C 0901     
4997 179E 0206  12        li   rtmp,SQUA2                 ; JSR SQUA2
     17A0 42BA     
4998 17A2 06A0  24        bl   @jsr                       ;
     17A4 FF10     
4999               
5000 17A6 D800  22        movb ra,@R                      ; STA R             ; Store A (high byte of result) in R
     17A8 0091     
5001               
5002 17AA D022  26        movb @K.+4(ry),ra               ; LDA K%+4,Y        ; Set (A P) = y_hi * y_hi
     17AC 0904     
5003 17AE 0206  12        li   rtmp,SQUA2                 ; JSR SQUA2
     17B0 42BA     
5004 17B2 06A0  24        bl   @jsr                       ;
     17B4 FF10     
5005               
5006                      .adc @R,ra                      ; ADC R             ; Add A (high byte of second result) to R
     **** ****     > ADC
0001 17B6 1701  10        jnc  !
0002 17B8 B004  14        ab   rone,ra
0003               !:
0004 17BA B020  22        ab   @R,ra
     17BC 0091     
                   < elite.a99
5007               
5008 17BE 180D  10        joc  MA30                       ; BCS MA30          ; If the addition of the two high bytes caused a carry
5009                                                                          ; (i.e. they overflowed), jump to MA30 to return A = &FF
5010               
5011 17C0 D800  22        movb ra,@R                      ; STA R             ; Store A (sum of the two high bytes) in R
     17C2 0091     
5012               
5013 17C4 D022  26        movb @K.+7(ry),ra               ; LDA K%+7,Y        ; Set (A P) = z_hi * z_hi
     17C6 0907     
5014 17C8 0206  12        li   rtmp,SQUA2                 ; JSR SQUA2
     17CA 42BA     
5015 17CC 06A0  24        bl   @jsr                       ;
     17CE FF10     
5016               
5017                      .adc @R,ra                      ; ADC R             ; Add A (high byte of third result) to R, so R now
     **** ****     > ADC
0001 17D0 1701  10        jnc  !
0002 17D2 B004  14        ab   rone,ra
0003               !:
0004 17D4 B020  22        ab   @R,ra
     17D6 0091     
                   < elite.a99
5018                                                                          ; contains the sum of x_hi^2 + y_hi^2 + z_hi^2
5019               
5020 17D8 1702  10        jnc  B13                        ; BCC B13           ; If there is no carry, skip the following instruction
5021                                                                          ; to return straight from the subroutine
5022               
5023               MA30:
5024 17DA 0200  12        li   ra,>ff*256                 ; LDA #&FF          ; The calculation has overflowed, so set A = &FF
     17DC FF00     
5025               
5026               B13:
5027 17DE 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     17E0 FF1C     
5028               
5029               * ******************************************************************************
5030               *
5031               * Name: MVEIT (Part 1 of 9)
5032               * Type: Subroutine
5033               * Category: Moving
5034               * Summary: Move current ship: Tidy the orientation vectors
5035               * Deep dive: Program flow of the ship-moving routine
5036               * Scheduling tasks with the main loop counter
5037               *
5038               * ------------------------------------------------------------------------------
5039               *
5040               * This routine has multiple stages. This stage does the following:
5041               *
5042               * * Tidy the orientation vectors for one of the ship slots
5043               *
5044               * ------------------------------------------------------------------------------
5045               *
5046               * Arguments:
5047               *
5048               * INWK                The current ship/planet/sun's data block
5049               *
5050               * XSAV                The slot number of the current ship/planet/sun
5051               *
5052               * TYPE                The type of the current ship/planet/sun
5053               *
5054               * ******************************************************************************
5055               
5056               MVEIT:
5057 17E2 D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; If bits 5 or 7 of ship byte #31 are set, jump to MV30
     17E4 0072     
5058 17E6 0240  14        andi ra,>a0*256                 ; AND #%10100000    ; as the ship is either exploding or has been killed, so
     17E8 A000     
5059 17EA 1623  10        jne  MV30                       ; BNE MV30          ; we don't need to tidy its orientation vectors or apply
5060                                                                          ; tactics
5061               
5062 17EC D020  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter
     17EE 0099     
5063               
5064                      .eor @XSAV                      ; EOR XSAV          ; Fetch the slot number of the ship we are moving, EOR
     **** ****     > EOR
0001 17F0 D1A0  22        movb @XSAV,rtmp
     17F2 0093     
0002 17F4 2806  14        xor  rtmp,ra
                   < elite.a99
5065 17F6 0240  14        andi ra,>0f*256                 ; AND #15           ; with the loop counter and apply mod 15 to the result.
     17F8 0F00     
5066 17FA 1604  10        jne  MV3                        ; BNE MV3           ; The result will be zero when "counter mod 15" matches
5067                                                                          ; the slot number, so this makes sure we call TIDY 12
5068                                                                          ; times every 16 main loop iterations, like this:
5069                                                                          ;
5070                                                                          ; Iteration 0, tidy the ship in slot 0
5071                                                                          ; Iteration 1, tidy the ship in slot 1
5072                                                                          ; Iteration 2, tidy the ship in slot 2
5073                                                                          ; ...
5074                                                                          ; Iteration 11, tidy the ship in slot 11
5075                                                                          ; Iteration 12, do nothing
5076                                                                          ; Iteration 13, do nothing
5077                                                                          ; Iteration 14, do nothing
5078                                                                          ; Iteration 15, do nothing
5079                                                                          ; Iteration 16, tidy the ship in slot 0
5080                                                                          ; ...
5081                                                                          ;
5082                                                                          ; and so on
5083               
5084 17FC 0206  12        li   rtmp,TIDY                  ; JSR TIDY          ; Call TIDY to tidy up the orientation vectors, to
     17FE CFA8     
5085 1800 06A0  24        bl   @jsr                       ;
     1802 FF10     
5086                                                                          ; prevent the ship from getting elongated and out of
5087                                                                          ; shape due to the imprecise nature of trigonometry
5088                                                                          ; in assembly language
5089               
5090               * ******************************************************************************
5091               *
5092               * Name: MVEIT (Part 2 of 9)
5093               * Type: Subroutine
5094               * Category: Moving
5095               * Summary: Move current ship: Call tactics routine, remove ship from scanner
5096               * Deep dive: Scheduling tasks with the main loop counter
5097               *
5098               * ------------------------------------------------------------------------------
5099               *
5100               * This routine has multiple stages. This stage does the following:
5101               *
5102               * * Apply tactics to ships with AI enabled (by calling the TACTICS routine)
5103               *
5104               * * Remove the ship from the scanner, so we can move it
5105               *
5106               * ******************************************************************************
5107               
5108               MV3:
5109 1804 D060  22        movb @TYPE,rx                   ; LDX TYPE          ; If the type of the ship we are moving is positive,
     1806 009B     
5110 1808 1502  10        jgt  B14                        ; BPL B14           ; i.e. it is not a planet (types 128 and 130) or sun
5111                                                                          ; (type 129), then skip the following instruction
5112               
5113 180A 0460  20        b    @MV40                      ; JMP MV40          ; This item is the planet or sun, so jump to MV40 to
     180C 2002     
5114                                                                          ; move it, which ends by jumping back into this routine
5115                                                                          ; at MV45 (after all the rotation, tactics and scanner
5116                                                                          ; code, which we don't need to apply to planets or suns)
5117               
5118               B14:
5119 180E D020  22        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the ship's byte #32 (AI flag) into A
     1810 0073     
5120               
5121 1812 150F  10        jgt  MV30                       ; BPL MV30          ; If bit 7 of the AI flag is clear, then if this is a
5122                                                                          ; ship or missile it is dumb and has no AI, and if this
5123                                                                          ; is the space station it is not hostile, so in both
5124                                                                          ; cases skip the following as it has no tactics
5125               
5126 1814 0281  14        ci   rx,(MSL)*256               ; CPX #MSL          ; If the ship is a missile, skip straight to MV26 to
     1816 0900     
5127 1818 1308  10        jeq  MV26                       ; BEQ MV26          ; call the TACTICS routine, as we do this every
5128                                                                          ; iteration of the main loop for missiles only
5129               
5130 181A D020  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter
     181C 0099     
5131               
5132                      .eor @XSAV                      ; EOR XSAV          ; Fetch the slot number of the ship we are moving, EOR
     **** ****     > EOR
0001 181E D1A0  22        movb @XSAV,rtmp
     1820 0093     
0002 1822 2806  14        xor  rtmp,ra
                   < elite.a99
5133 1824 0240  14        andi ra,>07*256                 ; AND #7            ; with the loop counter and apply mod 8 to the result.
     1826 0700     
5134 1828 1604  10        jne  MV30                       ; BNE MV30          ; The result will be zero when "counter mod 8" matches
5135                                                                          ; the slot number mod 8, so this makes sure we call
5136                                                                          ; TACTICS 12 times every 8 main loop iterations, like
5137                                                                          ; this:
5138                                                                          ;
5139                                                                          ; Iteration 0, apply tactics to slots 0 and 8
5140                                                                          ; Iteration 1, apply tactics to slots 1 and 9
5141                                                                          ; Iteration 2, apply tactics to slots 2 and 10
5142                                                                          ; Iteration 3, apply tactics to slots 3 and 11
5143                                                                          ; Iteration 4, apply tactics to slot 4
5144                                                                          ; Iteration 5, apply tactics to slot 5
5145                                                                          ; Iteration 6, apply tactics to slot 6
5146                                                                          ; Iteration 7, apply tactics to slot 7
5147                                                                          ; Iteration 8, apply tactics to slots 0 and 8
5148                                                                          ; ...
5149                                                                          ;
5150                                                                          ; and so on
5151               
5152               MV26:
5153 182A 0206  12        li   rtmp,TACTICS               ; JSR TACTICS       ; Call TACTICS to apply AI tactics to this ship
     182C 37FC     
5154 182E 06A0  24        bl   @jsr                       ;
     1830 FF10     
5155               
5156               MV30:
5157 1832 0206  12        li   rtmp,SCAN                  ; JSR SCAN          ; Draw the ship on the scanner, which has the effect of
     1834 4C86     
5158 1836 06A0  24        bl   @jsr                       ;
     1838 FF10     
5159                                                                          ; removing it, as it's already at this point and hasn't
5160                                                                          ; yet moved
5161               
5162               * ******************************************************************************
5163               *
5164               * Name: MVEIT (Part 3 of 9)
5165               * Type: Subroutine
5166               * Category: Moving
5167               * Summary: Move current ship: Move ship forward according to its speed
5168               *
5169               * ------------------------------------------------------------------------------
5170               *
5171               * This routine has multiple stages. This stage does the following:
5172               *
5173               * * Move the ship forward (along the vector pointing in the direction of
5174               * travel) according to its speed:
5175               *
5176               * (x, y, z) += nosev_hi * speed / 64
5177               *
5178               * ******************************************************************************
5179               
5180 183A D020  22        movb @INWK+27,ra                ; LDA INWK+27       ; Set Q = the ship's speed byte #27 * 4
     183C 006E     
5181                      .asla                           ; ASL A
     **** ****     > ASLA
0001 183E 0240  14        andi ra,>ff00
     1840 FF00     
0002 1842 0A10  14        sla  ra,1
                   < elite.a99
5182                      .asla                           ; ASL A
     **** ****     > ASLA
0001 1844 0240  14        andi ra,>ff00
     1846 FF00     
0002 1848 0A10  14        sla  ra,1
                   < elite.a99
5183 184A D800  22        movb ra,@Q                      ; STA Q
     184C 0090     
5184               
5185 184E D020  22        movb @INWK+10,ra                ; LDA INWK+10       ; Set A = |nosev_x_hi|
     1850 005D     
5186 1852 0240  14        andi ra,>7f*256                 ; AND #%01111111
     1854 7F00     
5187               
5188 1856 0206  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     1858 4338     
5189 185A 06A0  24        bl   @jsr                       ;
     185C FF10     
5190 185E D800  22        movb ra,@R                      ; STA R             ; = |nosev_x_hi| * speed / 64
     1860 0091     
5191               
5192 1862 D020  22        movb @INWK+10,ra                ; LDA INWK+10       ; If nosev_x_hi is positive, then:
     1864 005D     
5193 1866 0201  12        li   rx,>00*256                 ; LDX #0            ;
     1868 0000     
5194 186A 0206  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + R
     186C 1BA8     
5195 186E 06A0  24        bl   @jsr                       ;
     1870 FF10     
5196                                                                          ;
5197                                                                          ; If nosev_x_hi is negative, then:
5198                                                                          ;
5199                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - R
5200                                                                          ;
5201                                                                          ; So in effect, this does:
5202                                                                          ;
5203                                                                          ; (x_sign x_hi x_lo) += nosev_x_hi * speed / 64
5204               
5205 1872 D020  22        movb @INWK+12,ra                ; LDA INWK+12       ; Set A = |nosev_y_hi|
     1874 005F     
5206 1876 0240  14        andi ra,>7f*256                 ; AND #%01111111
     1878 7F00     
5207               
5208 187A 0206  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     187C 4338     
5209 187E 06A0  24        bl   @jsr                       ;
     1880 FF10     
5210 1882 D800  22        movb ra,@R                      ; STA R             ; = |nosev_y_hi| * speed / 64
     1884 0091     
5211               
5212 1886 D020  22        movb @INWK+12,ra                ; LDA INWK+12       ; If nosev_y_hi is positive, then:
     1888 005F     
5213 188A 0201  12        li   rx,>03*256                 ; LDX #3            ;
     188C 0300     
5214 188E 0206  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (y_sign y_hi y_lo) = (y_sign y_hi y_lo) + R
     1890 1BA8     
5215 1892 06A0  24        bl   @jsr                       ;
     1894 FF10     
5216                                                                          ;
5217                                                                          ; If nosev_y_hi is negative, then:
5218                                                                          ;
5219                                                                          ; (y_sign y_hi y_lo) = (y_sign y_hi y_lo) - R
5220                                                                          ;
5221                                                                          ; So in effect, this does:
5222                                                                          ;
5223                                                                          ; (y_sign y_hi y_lo) += nosev_y_hi * speed / 64
5224               
5225 1896 D020  22        movb @INWK+14,ra                ; LDA INWK+14       ; Set A = |nosev_z_hi|
     1898 0061     
5226 189A 0240  14        andi ra,>7f*256                 ; AND #%01111111
     189C 7F00     
5227               
5228 189E 0206  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     18A0 4338     
5229 18A2 06A0  24        bl   @jsr                       ;
     18A4 FF10     
5230 18A6 D800  22        movb ra,@R                      ; STA R             ; = |nosev_z_hi| * speed / 64
     18A8 0091     
5231               
5232 18AA D020  22        movb @INWK+14,ra                ; LDA INWK+14       ; If nosev_y_hi is positive, then:
     18AC 0061     
5233 18AE 0201  12        li   rx,>06*256                 ; LDX #6            ;
     18B0 0600     
5234 18B2 0206  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + R
     18B4 1BA8     
5235 18B6 06A0  24        bl   @jsr                       ;
     18B8 FF10     
5236                                                                          ;
5237                                                                          ; If nosev_z_hi is negative, then:
5238                                                                          ;
5239                                                                          ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) - R
5240                                                                          ;
5241                                                                          ; So in effect, this does:
5242                                                                          ;
5243                                                                          ; (z_sign z_hi z_lo) += nosev_z_hi * speed / 64
5244               
5245               * ******************************************************************************
5246               *
5247               * Name: MVEIT (Part 4 of 9)
5248               * Type: Subroutine
5249               * Category: Moving
5250               * Summary: Move current ship: Apply acceleration to ship's speed as a one-off
5251               *
5252               * ------------------------------------------------------------------------------
5253               *
5254               * This routine has multiple stages. This stage does the following:
5255               *
5256               * * Apply acceleration to the ship's speed (if acceleration is non-zero),
5257               * and then zero the acceleration as it's a one-off change
5258               *
5259               * ******************************************************************************
5260               
5261 18BA D020  22        movb @INWK+27,ra                ; LDA INWK+27       ; Set A = the ship's speed in byte #24 + the ship's
     18BC 006E     
5262                      .clc                            ; CLC               ; acceleration in byte #28
     **** ****     > CLC
0001 18BE 0A13  14        sla  rzero,1
                   < elite.a99
5263                      .adc @INWK+28,ra                ; ADC INWK+28
     **** ****     > ADC
0001 18C0 1701  10        jnc  !
0002 18C2 B004  14        ab   rone,ra
0003               !:
0004 18C4 B020  22        ab   @INWK+28,ra
     18C6 006F     
                   < elite.a99
5264               
5265 18C8 1502  10        jgt  B15                        ; BPL B15           ; If the result is positive, skip the following
5266                                                                          ; instruction
5267               
5268 18CA 0200  12        li   ra,>00*256                 ; LDA #0            ; Set A to 0 to stop the speed from going negative
     18CC 0000     
5269               
5270               B15:
5271 18CE 0202  12        li   ry,>0f*256                 ; LDY #15           ; We now fetch byte #15 from the ship's blueprint, which
     18D0 0F00     
5272                                                                          ; contains the ship's maximum speed, so set Y = 15 to
5273                                                                          ; use as an index
5274               
5275                      .cmp_ind_y_idx @XX0,ra          ; CMP (XX0),Y       ; If A < the ship's maximum speed, skip the following
     **** ****     > CMP_IND_Y_IDX
0001 18D2 D820  38        movb @XX0,@rtmplb
     18D4 001E     
     18D6 2079     
0002 18D8 D1A0  22        movb @XX0+1,rtmp
     18DA 001F     
0003 18DC A182  14        a    ry,rtmp
0004 18DE D196  22        movb *rtmp,rtmp
0005 18E0 9180  14        cb   ra,rtmp
                   < elite.a99
5276 18E2 1707  10        jnc  B16                        ; BCC B16           ; instruction
5277               
5278                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; Set A to the ship's maximum speed
     **** ****     > LD_IND_Y_IDX
0001 18E4 D820  38        movb @XX0,@rtmplb
     18E6 001E     
     18E8 2079     
0002 18EA D1A0  22        movb @XX0+1,rtmp
     18EC 001F     
0003 18EE A182  14        a    ry,rtmp
0004 18F0 D016  22        movb *rtmp,RA
                   < elite.a99
5279               
5280               B16:
5281 18F2 D800  22        movb ra,@INWK+27                ; STA INWK+27       ; We have now calculated the new ship's speed after
     18F4 006E     
5282                                                                          ; accelerating and keeping the speed within the ship's
5283                                                                          ; limits, so store the updated speed in byte #27
5284               
5285 18F6 0200  12        li   ra,>00*256                 ; LDA #0            ; We have added the ship's acceleration, so we now set
     18F8 0000     
5286 18FA D800  22        movb ra,@INWK+28                ; STA INWK+28       ; it back to 0 in byte #28, as it's a one-off change
     18FC 006F     
5287               
5288               * ******************************************************************************
5289               *
5290               * Name: MVEIT (Part 5 of 9)
5291               * Type: Subroutine
5292               * Category: Moving
5293               * Summary: Move current ship: Rotate ship's location by our pitch and roll
5294               * Deep dive: Rotating the universe
5295               *
5296               * ------------------------------------------------------------------------------
5297               *
5298               * This routine has multiple stages. This stage does the following:
5299               *
5300               * * Rotate the ship's location in space by the amount of pitch and roll of
5301               * our ship. See below for a deeper explanation of this routine
5302               *
5303               * ******************************************************************************
5304               
5305 18FE D060  22        movb @ALP1,rx                   ; LDX ALP1          ; Fetch the magnitude of the current roll into X, so
     1900 0087     
5306                                                                          ; if the roll angle is alpha, X contains |alpha|
5307               
5308 1902 D020  22        movb @INWK,ra                   ; LDA INWK          ; Set P = ~x_lo (i.e. with all its bits flipped) so that
     1904 0053     
5309                      .eoi (>ff*256)                  ; EOR #%11111111    ; we can pass x_lo to MLTU2 below)
     **** ****     > EOI
0001 1906 0206  12        li   rtmp,(>FF*256)
     1908 FF00     
0002 190A 2806  14        xor  rtmp,ra
                   < elite.a99
5310 190C D800  22        movb ra,@P                      ; STA P
     190E 001B     
5311               
5312 1910 D020  22        movb @INWK+1,ra                 ; LDA INWK+1        ; Set A = x_hi
     1912 0054     
5313               
5314 1914 0206  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     1916 437E     
5315 1918 06A0  24        bl   @jsr                       ;
     191A FF10     
5316                                                                          ; = (x_hi x_lo) * alpha
5317               
5318 191C D800  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     191E 001D     
5319                                                                          ; have:
5320                                                                          ;
5321                                                                          ; P(2 1 0) = (x_hi x_lo) * alpha
5322               
5323 1920 D020  22        movb @ALP2+1,ra                 ; LDA ALP2+1        ; Fetch the flipped sign of the current roll angle alpha
     1922 0089     
5324                      .eor @INWK+2                    ; EOR INWK+2        ; from ALP2+1 and EOR with byte #2 (x_sign), so if the
     **** ****     > EOR
0001 1924 D1A0  22        movb @INWK+2,rtmp
     1926 0055     
0002 1928 2806  14        xor  rtmp,ra
                   < elite.a99
5325                                                                          ; flipped roll angle and x_sign have the same sign, A
5326                                                                          ; will be positive, else it will be negative. So A will
5327                                                                          ; contain the sign bit of x_sign * flipped alpha sign,
5328                                                                          ; which is the opposite to the sign of the above result,
5329                                                                          ; so we now have:
5330                                                                          ;
5331                                                                          ; (A P+2 P+1) = - (x_sign x_hi x_lo) * alpha / 256
5332               
5333 192A 0201  12        li   rx,>03*256                 ; LDX #3            ; Set (A P+2 P+1) = (y_sign y_hi y_lo) + (A P+2 P+1)
     192C 0300     
5334 192E 0206  12        li   rtmp,MVT6                  ; JSR MVT6          ; = y - x * alpha / 256
     1930 1F7A     
5335 1932 06A0  24        bl   @jsr                       ;
     1934 FF10     
5336               
5337 1936 D800  22        movb ra,@K2+3                   ; STA K2+3          ; Set K2(3) = A = the sign of the result
     1938 00AF     
5338               
5339 193A D020  22        movb @P+1,ra                    ; LDA P+1           ; Set K2(1) = P+1, the low byte of the result
     193C 001C     
5340 193E D800  22        movb ra,@K2+1                   ; STA K2+1
     1940 00AD     
5341               
5342                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set P = ~K2+1 (i.e. with all its bits flipped) so
     **** ****     > EOI
0001 1942 0206  12        li   rtmp,(>FF*256)
     1944 FF00     
0002 1946 2806  14        xor  rtmp,ra
                   < elite.a99
5343 1948 D800  22        movb ra,@P                      ; STA P             ; that we can pass K2+1 to MLTU2 below)
     194A 001B     
5344               
5345 194C D020  22        movb @P+2,ra                    ; LDA P+2           ; Set K2(2) = A = P+2
     194E 001D     
5346 1950 D800  22        movb ra,@K2+2                   ; STA K2+2
     1952 00AE     
5347               
5348                                                                          ; So we now have result 1 above:
5349                                                                          ;
5350                                                                          ; K2(3 2 1) = (A P+2 P+1)
5351                                                                          ; = y - x * alpha / 256
5352               
5353 1954 D060  22        movb @BET1,rx                   ; LDX BET1          ; Fetch the magnitude of the current pitch into X, so
     1956 002B     
5354                                                                          ; if the pitch angle is beta, X contains |beta|
5355               
5356 1958 0206  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     195A 437E     
5357 195C 06A0  24        bl   @jsr                       ;
     195E FF10     
5358                                                                          ; = K2(2 1) * beta
5359               
5360 1960 D800  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     1962 001D     
5361                                                                          ; have:
5362                                                                          ;
5363                                                                          ; P(2 1 0) = K2(2 1) * beta
5364               
5365 1964 D020  22        movb @K2+3,ra                   ; LDA K2+3          ; Fetch the sign of the above result in K(3 2 1) from
     1966 00AF     
5366                      .eor @BET2                      ; EOR BET2          ; K2+3 and EOR with BET2, the sign of the current pitch
     **** ****     > EOR
0001 1968 D1A0  22        movb @BET2,rtmp
     196A 008A     
0002 196C 2806  14        xor  rtmp,ra
                   < elite.a99
5367                                                                          ; rate, so if the pitch and K(3 2 1) have the same sign,
5368                                                                          ; A will be positive, else it will be negative. So A
5369                                                                          ; will contain the sign bit of K(3 2 1) * beta, which is
5370                                                                          ; the same as the sign of the above result, so we now
5371                                                                          ; have:
5372                                                                          ;
5373                                                                          ; (A P+2 P+1) = K2(3 2 1) * beta / 256
5374               
5375 196E 0201  12        li   rx,>06*256                 ; LDX #6            ; Set (A P+2 P+1) = (z_sign z_hi z_lo) + (A P+2 P+1)
     1970 0600     
5376 1972 0206  12        li   rtmp,MVT6                  ; JSR MVT6          ; = z + K2 * beta / 256
     1974 1F7A     
5377 1976 06A0  24        bl   @jsr                       ;
     1978 FF10     
5378               
5379 197A D800  22        movb ra,@INWK+8                 ; STA INWK+8        ; Set z_sign = A = the sign of the result
     197C 005B     
5380               
5381 197E D020  22        movb @P+1,ra                    ; LDA P+1           ; Set z_lo = P+1, the low byte of the result
     1980 001C     
5382 1982 D800  22        movb ra,@INWK+6                 ; STA INWK+6
     1984 0059     
5383               
5384                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set P = ~z_lo (i.e. with all its bits flipped) so that
     **** ****     > EOI
0001 1986 0206  12        li   rtmp,(>FF*256)
     1988 FF00     
0002 198A 2806  14        xor  rtmp,ra
                   < elite.a99
5385 198C D800  22        movb ra,@P                      ; STA P             ; we can pass z_lo to MLTU2 below)
     198E 001B     
5386               
5387 1990 D020  22        movb @P+2,ra                    ; LDA P+2           ; Set z_hi = P+2
     1992 001D     
5388 1994 D800  22        movb ra,@INWK+7                 ; STA INWK+7
     1996 005A     
5389               
5390                                                                          ; So we now have result 2 above:
5391                                                                          ;
5392                                                                          ; (z_sign z_hi z_lo) = (A P+2 P+1)
5393                                                                          ; = z + K2 * beta / 256
5394               
5395 1998 0206  12        li   rtmp,MLTU2                 ; JSR MLTU2         ; MLTU2 doesn't change Q, and Q was set to beta in
     199A 4380     
5396 199C 06A0  24        bl   @jsr                       ;
     199E FF10     
5397                                                                          ; the previous call to MLTU2, so this call does:
5398                                                                          ;
5399                                                                          ; (A P+1 P) = (A ~P) * Q
5400                                                                          ; = (z_hi z_lo) * beta
5401               
5402 19A0 D800  22        movb ra,@P+2                    ; STA P+2           ; Set P+2 = A = the high byte of the result, so we
     19A2 001D     
5403                                                                          ; now have:
5404                                                                          ;
5405                                                                          ; P(2 1 0) = (z_hi z_lo) * beta
5406               
5407 19A4 D020  22        movb @K2+3,ra                   ; LDA K2+3          ; Set y_sign = K2+3
     19A6 00AF     
5408 19A8 D800  22        movb ra,@INWK+5                 ; STA INWK+5
     19AA 0058     
5409               
5410                      .eor @BET2                      ; EOR BET2          ; EOR y_sign with BET2, the sign of the current pitch
     **** ****     > EOR
0001 19AC D1A0  22        movb @BET2,rtmp
     19AE 008A     
0002 19B0 2806  14        xor  rtmp,ra
                   < elite.a99
5411                      .eor @INWK+8                    ; EOR INWK+8        ; rate, and z_sign. If the result is positive jump to
     **** ****     > EOR
0001 19B2 D1A0  22        movb @INWK+8,rtmp
     19B4 005B     
0002 19B6 2806  14        xor  rtmp,ra
                   < elite.a99
5412 19B8 1512  10        jgt  MV43                       ; BPL MV43          ; MV43, otherwise this means beta * z and y have
5413                                                                          ; different signs, i.e. P(2 1) and K2(3 2 1) have
5414                                                                          ; different signs, so we need to add them in order to
5415                                                                          ; calculate K2(2 1) - P(2 1)
5416               
5417 19BA D020  22        movb @P+1,ra                    ; LDA P+1           ; Set (y_hi y_lo) = K2(2 1) + P(2 1)
     19BC 001C     
5418                      .adc @K2+1,ra                   ; ADC K2+1
     **** ****     > ADC
0001 19BE 1701  10        jnc  !
0002 19C0 B004  14        ab   rone,ra
0003               !:
0004 19C2 B020  22        ab   @K2+1,ra
     19C4 00AD     
                   < elite.a99
5419 19C6 D800  22        movb ra,@INWK+3                 ; STA INWK+3
     19C8 0056     
5420 19CA D020  22        movb @P+2,ra                    ; LDA P+2
     19CC 001D     
5421                      .adc @K2+2,ra                   ; ADC K2+2
     **** ****     > ADC
0001 19CE 1701  10        jnc  !
0002 19D0 B004  14        ab   rone,ra
0003               !:
0004 19D2 B020  22        ab   @K2+2,ra
     19D4 00AE     
                   < elite.a99
5422 19D6 D800  22        movb ra,@INWK+4                 ; STA INWK+4
     19D8 0057     
5423               
5424 19DA 0460  16        b    @MV44                      ; JMP MV44          ; Jump to MV44 to continue the calculation
     19DC 1A2E     
5425               
5426               MV43:
5427 19DE D020  22        movb @K2+1,ra                   ; LDA K2+1          ; Reversing the logic above, we need to subtract P(2 1)
     19E0 00AD     
5428                      .sbc @P+1,ra                    ; SBC P+1           ; and K2(3 2 1) to calculate K2(2 1) - P(2 1), so this
     **** ****     > SBC
0001 19E2 1801  10        joc  !
0002 19E4 7004  14        sb   rone,ra
0003               !:
0004 19E6 7020  22        sb   @P+1,ra
     19E8 001C     
                   < elite.a99
5429 19EA D800  22        movb ra,@INWK+3                 ; STA INWK+3        ; sets (y_hi y_lo) = K2(2 1) - P(2 1)
     19EC 0056     
5430 19EE D020  22        movb @K2+2,ra                   ; LDA K2+2
     19F0 00AE     
5431                      .sbc @P+2,ra                    ; SBC P+2
     **** ****     > SBC
0001 19F2 1801  10        joc  !
0002 19F4 7004  14        sb   rone,ra
0003               !:
0004 19F6 7020  22        sb   @P+2,ra
     19F8 001D     
                   < elite.a99
5432 19FA D800  22        movb ra,@INWK+4                 ; STA INWK+4
     19FC 0057     
5433               
5434 19FE 1817  10        joc  MV44                       ; BCS MV44          ; If the above subtraction did not underflow, then
5435                                                                          ; jump to MV44, otherwise we need to negate the result
5436               
5437 1A00 0200  12        li   ra,>01*256                 ; LDA #1            ; Negate (y_sign y_hi y_lo) using two's complement,
     1A02 0100     
5438                      .sbc @INWK+3,ra                 ; SBC INWK+3        ; first doing the low bytes:
     **** ****     > SBC
0001 1A04 1801  10        joc  !
0002 1A06 7004  14        sb   rone,ra
0003               !:
0004 1A08 7020  22        sb   @INWK+3,ra
     1A0A 0056     
                   < elite.a99
5439 1A0C D800  22        movb ra,@INWK+3                 ; STA INWK+3        ;
     1A0E 0056     
5440                                                                          ; y_lo = 1 - y_lo
5441               
5442 1A10 0200  12        li   ra,>00*256                 ; LDA #0            ; Then the high bytes:
     1A12 0000     
5443                      .sbc @INWK+4,ra                 ; SBC INWK+4        ;
     **** ****     > SBC
0001 1A14 1801  10        joc  !
0002 1A16 7004  14        sb   rone,ra
0003               !:
0004 1A18 7020  22        sb   @INWK+4,ra
     1A1A 0057     
                   < elite.a99
5444 1A1C D800  22        movb ra,@INWK+4                 ; STA INWK+4        ; y_hi = 0 - y_hi
     1A1E 0057     
5445               
5446 1A20 D020  22        movb @INWK+5,ra                 ; LDA INWK+5        ; And finally flip the sign in y_sign
     1A22 0058     
5447                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1A24 0206  12        li   rtmp,(>80*256)
     1A26 8000     
0002 1A28 2806  14        xor  rtmp,ra
                   < elite.a99
5448 1A2A D800  22        movb ra,@INWK+5                 ; STA INWK+5
     1A2C 0058     
5449               
5450               MV44:
5451                                                                          ; So we now have result 3 above:
5452                                                                          ;
5453                                                                          ; (y_sign y_hi y_lo) = K2(2 1) - P(2 1)
5454                                                                          ; = K2 - beta * z
5455 1A2E D060  22        movb @ALP1,rx                   ; LDX ALP1          ; Fetch the magnitude of the current roll into X, so
     1A30 0087     
5456                                                                          ; if the roll angle is alpha, X contains |alpha|
5457               
5458 1A32 D020  22        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P = ~y_lo (i.e. with all its bits flipped) so that
     1A34 0056     
5459                      .eoi (>ff*256)                  ; EOR #&FF          ; we can pass y_lo to MLTU2 below)
     **** ****     > EOI
0001 1A36 0206  12        li   rtmp,(>FF*256)
     1A38 FF00     
0002 1A3A 2806  14        xor  rtmp,ra
                   < elite.a99
5460 1A3C D800  22        movb ra,@P                      ; STA P
     1A3E 001B     
5461               
5462 1A40 D020  22        movb @INWK+4,ra                 ; LDA INWK+4        ; Set A = y_hi
     1A42 0057     
5463               
5464 1A44 0206  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     1A46 437E     
5465 1A48 06A0  24        bl   @jsr                       ;
     1A4A FF10     
5466                                                                          ; = (y_hi y_lo) * alpha
5467               
5468 1A4C D800  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     1A4E 001D     
5469                                                                          ; have:
5470                                                                          ;
5471                                                                          ; P(2 1 0) = (y_hi y_lo) * alpha
5472               
5473 1A50 D020  22        movb @ALP2,ra                   ; LDA ALP2          ; Fetch the correct sign of the current roll angle alpha
     1A52 0088     
5474                      .eor @INWK+5                    ; EOR INWK+5        ; from ALP2 and EOR with byte #5 (y_sign), so if the
     **** ****     > EOR
0001 1A54 D1A0  22        movb @INWK+5,rtmp
     1A56 0058     
0002 1A58 2806  14        xor  rtmp,ra
                   < elite.a99
5475                                                                          ; correct roll angle and y_sign have the same sign, A
5476                                                                          ; will be positive, else it will be negative. So A will
5477                                                                          ; contain the sign bit of x_sign * correct alpha sign,
5478                                                                          ; which is the same as the sign of the above result,
5479                                                                          ; so we now have:
5480                                                                          ;
5481                                                                          ; (A P+2 P+1) = (y_sign y_hi y_lo) * alpha / 256
5482               
5483 1A5A 0201  12        li   rx,>00*256                 ; LDX #0            ; Set (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
     1A5C 0000     
5484 1A5E 0206  12        li   rtmp,MVT6                  ; JSR MVT6          ; = x + y * alpha / 256
     1A60 1F7A     
5485 1A62 06A0  24        bl   @jsr                       ;
     1A64 FF10     
5486               
5487 1A66 D800  22        movb ra,@INWK+2                 ; STA INWK+2        ; Set x_sign = A = the sign of the result
     1A68 0055     
5488               
5489 1A6A D020  22        movb @P+2,ra                    ; LDA P+2           ; Set x_hi = P+2, the high byte of the result
     1A6C 001D     
5490 1A6E D800  22        movb ra,@INWK+1                 ; STA INWK+1
     1A70 0054     
5491               
5492 1A72 D020  22        movb @P+1,ra                    ; LDA P+1           ; Set x_lo = P+1, the low byte of the result
     1A74 001C     
5493 1A76 D800  22        movb ra,@INWK                   ; STA INWK
     1A78 0053     
5494               
5495                                                                          ; So we now have result 4 above:
5496                                                                          ;
5497                                                                          ; x = x + alpha * y
5498                                                                          ;
5499                                                                          ; and the rotation of (x, y, z) is done
5500               
5501               * ******************************************************************************
5502               *
5503               * Name: MVEIT (Part 6 of 9)
5504               * Type: Subroutine
5505               * Category: Moving
5506               * Summary: Move current ship: Move the ship in space according to our speed
5507               *
5508               * ------------------------------------------------------------------------------
5509               *
5510               * This routine has multiple stages. This stage does the following:
5511               *
5512               * * Move the ship in space according to our speed (we already moved it
5513               * according to its own speed in part 3).
5514               *
5515               * We do this by subtracting our speed (i.e. the distance we travel in this
5516               * iteration of the loop) from the other ship's z-coordinate. We subtract because
5517               * they appear to be "moving" in the opposite direction to us, and the whole
5518               * MVEIT routine is about moving the other ships rather than us (even though we
5519               * are the one doing the moving).
5520               *
5521               * ------------------------------------------------------------------------------
5522               *
5523               * Other entry points:
5524               *
5525               * MV45                Rejoin the MVEIT routine after the rotation, tactics and
5526               * scanner code
5527               *
5528               * ******************************************************************************
5529               
5530               MV45:
5531 1A7A D020  22        movb @DELTA,ra                  ; LDA DELTA         ; Set R to our speed in DELTA
     1A7C 008C     
5532 1A7E D800  22        movb ra,@R                      ; STA R
     1A80 0091     
5533               
5534 1A82 0200  12        li   ra,>80*256                 ; LDA #%10000000    ; Set A to zeroes but with bit 7 set, so that (A R) is
     1A84 8000     
5535                                                                          ; a 16-bit number containing -R, or -speed
5536               
5537 1A86 0201  12        li   rx,>06*256                 ; LDX #6            ; Set X to the z-axis so the call to MVT1 does this:
     1A88 0600     
5538 1A8A 0206  12        li   rtmp,MVT1                  ; JSR MVT1          ;
     1A8C 1BAA     
5539 1A8E 06A0  24        bl   @jsr                       ;
     1A90 FF10     
5540                                                                          ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + (A R)
5541                                                                          ; = (z_sign z_hi z_lo) - speed
5542               
5543 1A92 D020  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is not the sun (129) then skip the
     1A94 009B     
5544 1A96 0240  14        andi ra,>81*256                 ; AND #%10000001    ; next instruction, otherwise return from the subroutine
     1A98 8100     
5545 1A9A 0280  14        ci   ra,>81*256                 ; CMP #129          ; as we don't need to rotate the sun around its origin.
     1A9C 8100     
5546 1A9E 1602  10        jne  B17                        ; BNE B17           ; Having both the AND and the CMP is a little odd, as
5547                                                                          ; the sun is the only ship type with bits 0 and 7 set,
5548                                                                          ; so the AND has no effect and could be removed
5549               
5550 1AA0 0460  20        b    @rts                       ; RTS               ; Return from the subroutine, as the ship we are moving
     1AA2 FF1C     
5551                                                                          ; is the sun and doesn't need any of the following
5552               
5553               * ******************************************************************************
5554               *
5555               * Name: MVEIT (Part 7 of 9)
5556               * Type: Subroutine
5557               * Category: Moving
5558               * Summary: Move current ship: Rotate ship's orientation vectors by pitch/roll
5559               * Deep dive: Orientation vectors
5560               * Pitching and rolling
5561               *
5562               * ------------------------------------------------------------------------------
5563               *
5564               * This routine has multiple stages. This stage does the following:
5565               *
5566               * * Rotate the ship's orientation vectors according to our pitch and roll
5567               *
5568               * As with the previous step, this is all about moving the other ships rather
5569               * than us (even though we are the one doing the moving). So we rotate the
5570               * current ship's orientation vectors (which defines its orientation in space),
5571               * by the angles we are "moving" the rest of the sky through (alpha and beta, our
5572               * roll and pitch), so the ship appears to us to be stationary while we rotate.
5573               *
5574               * ******************************************************************************
5575               
5576               B17:
5577 1AA4 0202  12        li   ry,>09*256                 ; LDY #9            ; Apply our pitch and roll rotations to the current
     1AA6 0900     
5578 1AA8 0206  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's nosev vector
     1AAA 1D68     
5579 1AAC 06A0  24        bl   @jsr                       ;
     1AAE FF10     
5580               
5581 1AB0 0202  12        li   ry,>0f*256                 ; LDY #15           ; Apply our pitch and roll rotations to the current
     1AB2 0F00     
5582 1AB4 0206  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's roofv vector
     1AB6 1D68     
5583 1AB8 06A0  24        bl   @jsr                       ;
     1ABA FF10     
5584               
5585 1ABC 0202  12        li   ry,>15*256                 ; LDY #21           ; Apply our pitch and roll rotations to the current
     1ABE 1500     
5586 1AC0 0206  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's sidev vector
     1AC2 1D68     
5587 1AC4 06A0  24        bl   @jsr                       ;
     1AC6 FF10     
5588               
5589               * ******************************************************************************
5590               *
5591               * Name: MVEIT (Part 8 of 9)
5592               * Type: Subroutine
5593               * Category: Moving
5594               * Summary: Move current ship: Rotate ship about itself by its own pitch/roll
5595               * Deep dive: Orientation vectors
5596               * Pitching and rolling by a fixed angle
5597               *
5598               * ------------------------------------------------------------------------------
5599               *
5600               * This routine has multiple stages. This stage does the following:
5601               *
5602               * * If the ship we are processing is rolling or pitching itself, rotate it and
5603               * apply damping if required
5604               *
5605               * ******************************************************************************
5606               
5607 1AC8 D020  22        movb @INWK+30,ra                ; LDA INWK+30       ; Fetch the ship's pitch counter and extract the sign
     1ACA 0071     
5608 1ACC 0240  14        andi ra,>80*256                 ; AND #%10000000    ; into RAT2
     1ACE 8000     
5609 1AD0 D800  22        movb ra,@RAT2                   ; STA RAT2
     1AD2 00AB     
5610               
5611 1AD4 D020  22        movb @INWK+30,ra                ; LDA INWK+30       ; Fetch the ship's pitch counter and extract the value
     1AD6 0071     
5612 1AD8 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; without the sign bit into A
     1ADA 7F00     
5613               
5614 1ADC 1322  10        jeq  MV8                        ; BEQ MV8           ; If the pitch counter is 0, then jump to MV8 to skip
5615                                                                          ; the following, as the ship is not pitching
5616               
5617 1ADE 0280  14        ci   ra,>7f*256                 ; CMP #%01111111    ; If bits 0-6 are set in the pitch counter (i.e. the
     1AE0 7F00     
5618                                                                          ; ship's pitch is not damping down), then the C flag
5619                                                                          ; will be set by this instruction
5620               
5621                      .sbi (>00*256)                  ; SBC #0            ; Set A = A - 0 - (1 - C), so if we are damping then we
     **** ****     > SBI
0001 1AE2 1801  10        joc  !
0002 1AE4 7004  14        sb   rone,ra
0003               !:
0004 1AE6 0220  14        ai   ra,-(>00*256)
     1AE8 0000     
                   < elite.a99
5622                                                                          ; reduce A by 1, otherwise it is unchanged
5623               
5624 1AEA F020  22        socb @RAT2,ra                   ; ORA RAT2          ; Change bit 7 of A to the sign we saved in RAT2, so
     1AEC 00AB     
5625                                                                          ; the updated pitch counter in A retains its sign
5626               
5627 1AEE D800  22        movb ra,@INWK+30                ; STA INWK+30       ; Store the updated pitch counter in byte #30
     1AF0 0071     
5628               
5629 1AF2 0201  12        li   rx,>0f*256                 ; LDX #15           ; Rotate (roofv_x, nosev_x) by a small angle (pitch)
     1AF4 0F00     
5630 1AF6 0202  12        li   ry,>09*256                 ; LDY #9
     1AF8 0900     
5631 1AFA 0206  12        li   rtmp,MVS5                  ; JSR MVS5
     1AFC 1E34     
5632 1AFE 06A0  24        bl   @jsr                       ;
     1B00 FF10     
5633               
5634 1B02 0201  12        li   rx,>11*256                 ; LDX #17           ; Rotate (roofv_y, nosev_y) by a small angle (pitch)
     1B04 1100     
5635 1B06 0202  12        li   ry,>0b*256                 ; LDY #11
     1B08 0B00     
5636 1B0A 0206  12        li   rtmp,MVS5                  ; JSR MVS5
     1B0C 1E34     
5637 1B0E 06A0  24        bl   @jsr                       ;
     1B10 FF10     
5638               
5639 1B12 0201  12        li   rx,>13*256                 ; LDX #19           ; Rotate (roofv_z, nosev_z) by a small angle (pitch)
     1B14 1300     
5640 1B16 0202  12        li   ry,>0d*256                 ; LDY #13
     1B18 0D00     
5641 1B1A 0206  12        li   rtmp,MVS5                  ; JSR MVS5
     1B1C 1E34     
5642 1B1E 06A0  24        bl   @jsr                       ;
     1B20 FF10     
5643               
5644               MV8:
5645 1B22 D020  22        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the ship's roll counter and extract the sign
     1B24 0070     
5646 1B26 0240  14        andi ra,>80*256                 ; AND #%10000000    ; into RAT2
     1B28 8000     
5647 1B2A D800  22        movb ra,@RAT2                   ; STA RAT2
     1B2C 00AB     
5648               
5649 1B2E D020  22        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the ship's roll counter and extract the value
     1B30 0070     
5650 1B32 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; without the sign bit into A
     1B34 7F00     
5651               
5652 1B36 1322  10        jeq  MV5                        ; BEQ MV5           ; If the roll counter is 0, then jump to MV5 to skip the
5653                                                                          ; following, as the ship is not rolling
5654               
5655 1B38 0280  14        ci   ra,>7f*256                 ; CMP #%01111111    ; If bits 0-6 are set in the roll counter (i.e. the
     1B3A 7F00     
5656                                                                          ; ship's roll is not damping down), then the C flag
5657                                                                          ; will be set by this instruction
5658               
5659                      .sbi (>00*256)                  ; SBC #0            ; Set A = A - 0 - (1 - C), so if we are damping then we
     **** ****     > SBI
0001 1B3C 1801  10        joc  !
0002 1B3E 7004  14        sb   rone,ra
0003               !:
0004 1B40 0220  14        ai   ra,-(>00*256)
     1B42 0000     
                   < elite.a99
5660                                                                          ; reduce A by 1, otherwise it is unchanged
5661               
5662 1B44 F020  22        socb @RAT2,ra                   ; ORA RAT2          ; Change bit 7 of A to the sign we saved in RAT2, so
     1B46 00AB     
5663                                                                          ; the updated roll counter in A retains its sign
5664               
5665 1B48 D800  22        movb ra,@INWK+29                ; STA INWK+29       ; Store the updated pitch counter in byte #29
     1B4A 0070     
5666               
5667 1B4C 0201  12        li   rx,>0f*256                 ; LDX #15           ; Rotate (roofv_x, sidev_x) by a small angle (roll)
     1B4E 0F00     
5668 1B50 0202  12        li   ry,>15*256                 ; LDY #21
     1B52 1500     
5669 1B54 0206  12        li   rtmp,MVS5                  ; JSR MVS5
     1B56 1E34     
5670 1B58 06A0  24        bl   @jsr                       ;
     1B5A FF10     
5671               
5672 1B5C 0201  12        li   rx,>11*256                 ; LDX #17           ; Rotate (roofv_y, sidev_y) by a small angle (roll)
     1B5E 1100     
5673 1B60 0202  12        li   ry,>17*256                 ; LDY #23
     1B62 1700     
5674 1B64 0206  12        li   rtmp,MVS5                  ; JSR MVS5
     1B66 1E34     
5675 1B68 06A0  24        bl   @jsr                       ;
     1B6A FF10     
5676               
5677 1B6C 0201  12        li   rx,>13*256                 ; LDX #19           ; Rotate (roofv_z, sidev_z) by a small angle (roll)
     1B6E 1300     
5678 1B70 0202  12        li   ry,>19*256                 ; LDY #25
     1B72 1900     
5679 1B74 0206  12        li   rtmp,MVS5                  ; JSR MVS5
     1B76 1E34     
5680 1B78 06A0  24        bl   @jsr                       ;
     1B7A FF10     
5681               
5682               * ******************************************************************************
5683               *
5684               * Name: MVEIT (Part 9 of 9)
5685               * Type: Subroutine
5686               * Category: Moving
5687               * Summary: Move current ship: Redraw on scanner, if it hasn't been destroyed
5688               *
5689               * ------------------------------------------------------------------------------
5690               *
5691               * This routine has multiple stages. This stage does the following:
5692               *
5693               * * If the ship is exploding or being removed, hide it on the scanner
5694               *
5695               * * Otherwise redraw the ship on the scanner, now that it's been moved
5696               *
5697               * ******************************************************************************
5698               
5699               MV5:
5700 1B7C D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the ship's exploding/killed state from byte #31
     1B7E 0072     
5701               
5702 1B80 0240  14        andi ra,>a0*256                 ; AND #%10100000    ; If we are exploding or removing this ship then jump to
     1B82 A000     
5703 1B84 1608  10        jne  MVD1                       ; BNE MVD1          ; MVD1 to remove it from the scanner permanently
5704               
5705 1B86 D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 4 to keep the ship visible on the scanner
     1B88 0072     
5706 1B8A 0260  14        ori  ra,>10*256                 ; ORA #%00010000
     1B8C 1000     
5707 1B8E D800  22        movb ra,@INWK+31                ; STA INWK+31
     1B90 0072     
5708               
5709 1B92 0460  20        b    @SCAN                      ; JMP SCAN          ; Display the ship on the scanner, returning from the
     1B94 4C86     
5710                                                                          ; subroutine using a tail call
5711               
5712               MVD1:
5713 1B96 D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; Clear bit 4 to hide the ship on the scanner
     1B98 0072     
5714 1B9A 0240  14        andi ra,>ef*256                 ; AND #%11101111
     1B9C EF00     
5715 1B9E D800  22        movb ra,@INWK+31                ; STA INWK+31
     1BA0 0072     
5716               
5717 1BA2 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1BA4 FF1C     
5718               
5719               * ******************************************************************************
5720               *
5721               * Name: MVT1
5722               * Type: Subroutine
5723               * Category: Moving
5724               * Summary: Calculate (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
5725               *
5726               * ------------------------------------------------------------------------------
5727               *
5728               * Add the signed delta (A R) to a ship's coordinate, along the axis given in X.
5729               * Mathematically speaking, this routine translates the ship along a single axis
5730               * by a signed delta. Taking the example of X = 0, the x-axis, it does the
5731               * following:
5732               *
5733               * (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
5734               *
5735               * (In practice, MVT1 is only ever called directly with A = 0 or 128, otherwise
5736               * it is always called via MVT-2, which clears A apart from the sign bit. The
5737               * routine is written to cope with a non-zero delta_hi, so it supports a full
5738               * 16-bit delta, but it appears that delta_hi is only ever used to hold the
5739               * sign of the delta.)
5740               *
5741               * The comments below assume we are adding delta to the x-axis, though the axis
5742               * is determined by the value of X.
5743               *
5744               * ------------------------------------------------------------------------------
5745               *
5746               * Arguments:
5747               *
5748               * (A R)               The signed delta, so A = delta_hi and R = delta_lo
5749               *
5750               * X                   Determines which coordinate axis of INWK to change:
5751               *
5752               * * X = 0 adds the delta to (x_lo, x_hi, x_sign)
5753               *
5754               * * X = 3 adds the delta to (y_lo, y_hi, y_sign)
5755               *
5756               * * X = 6 adds the delta to (z_lo, z_hi, z_sign)
5757               *
5758               * ------------------------------------------------------------------------------
5759               *
5760               * Other entry points:
5761               *
5762               * MVT1-2              Clear bits 0-6 of A before entering MVT1
5763               *
5764               * ******************************************************************************
5765               
5766 1BA6 0240  14        andi ra,>80*256                 ; AND #%10000000    ; Clear bits 0-6 of A
     1BA8 8000     
5767               
5768               MVT1:
5769                      .asla                           ; ASL A             ; Set the C flag to the sign bit of the delta, leaving
     **** ****     > ASLA
0001 1BAA 0240  14        andi ra,>ff00
     1BAC FF00     
0002 1BAE 0A10  14        sla  ra,1
                   < elite.a99
5770                                                                          ; delta_hi << 1 in A
5771               
5772 1BB0 D800  22        movb ra,@S                      ; STA S             ; Set S = delta_hi << 1
     1BB2 0092     
5773                                                                          ;
5774                                                                          ; This also clears bit 0 of S
5775               
5776 1BB4 0200  12        li   ra,>00*256                 ; LDA #0            ; Set T = just the sign bit of delta (in bit 7)
     1BB6 0000     
5777 1BB8 06A0  24        bl   @rora                      ; ROR A
     1BBA FF4A     
5778 1BBC D800  22        movb ra,@T                      ; STA T
     1BBE 00D1     
5779               
5780                      .lsr @S                         ; LSR S             ; Set S = delta_hi >> 1
     **** ****     > LSR
0001 1BC0 D1A0  22        movb @S,rtmp
     1BC2 0092     
0002 1BC4 0916  14        srl  rtmp,1
0003 1BC6 D806  22        movb rtmp,@S
     1BC8 0092     
                   < elite.a99
5781                                                                          ; = |delta_hi|
5782                                                                          ;
5783                                                                          ; This also clear the C flag, as we know that bit 0 of
5784                                                                          ; S was clear before the LSR
5785               
5786                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; If T EOR x_sign has bit 7 set, then x_sign and delta
     **** ****     > EOR
0001 1BCA D1A1  26        movb @INWK+2(RX),rtmp
     1BCC 0055     
0002 1BCE 2806  14        xor  rtmp,ra
                   < elite.a99
5787 1BD0 111C  10        jlt  MV10                       ; BMI MV10          ; have different signs, so jump to MV10
5788               
5789                                                                          ; At this point, we know x_sign and delta have the same
5790                                                                          ; sign, that sign is in T, and S contains |delta_hi|,
5791                                                                          ; so now we want to do:
5792                                                                          ;
5793                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (S R)
5794                                                                          ;
5795                                                                          ; and then set the sign of the result to the same sign
5796                                                                          ; as x_sign and delta
5797               
5798 1BD2 D020  22        movb @R,ra                      ; LDA R             ; First we add the low bytes, so:
     1BD4 0091     
5799                      .adc @INWK(rx),ra               ; ADC INWK,X        ;
     **** ****     > ADC
0001 1BD6 1701  10        jnc  !
0002 1BD8 B004  14        ab   rone,ra
0003               !:
0004 1BDA B021  26        ab   @INWK(RX),ra
     1BDC 0053     
                   < elite.a99
5800 1BDE D840  30        movb ra,@INWK(rx)               ; STA INWK,X        ; x_lo = x_lo + R
     1BE0 0053     
5801               
5802 1BE2 D020  22        movb @S,ra                      ; LDA S             ; Then we add the high bytes:
     1BE4 0092     
5803                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X      ;
     **** ****     > ADC
0001 1BE6 1701  10        jnc  !
0002 1BE8 B004  14        ab   rone,ra
0003               !:
0004 1BEA B021  26        ab   @INWK+1(RX),ra
     1BEC 0054     
                   < elite.a99
5804 1BEE D840  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = x_hi + S
     1BF0 0054     
5805               
5806 1BF2 D021  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally we add any carry into x_sign, and if the
     1BF4 0055     
5807                      .adi (>00*256)                  ; ADC #0            ; sign of x_sign and delta in T is negative, make sure
     **** ****     > ADI
0001 1BF6 1701  10        jnc  !
0002 1BF8 B004  14        ab   rone,ra
0003               !:
0004 1BFA 0220  14        ai   ra,(>00*256)
     1BFC 0000     
                   < elite.a99
5808 1BFE F020  22        socb @T,ra                      ; ORA T             ; the result is negative (by OR'ing with T)
     1C00 00D1     
5809 1C02 D840  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X
     1C04 0055     
5810               
5811 1C06 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1C08 FF1C     
5812               
5813               MV10:
5814                                                                          ; If we get here, we know x_sign and delta have
5815                                                                          ; different signs, with delta's sign in T, and
5816                                                                          ; |delta_hi| in S, so now we want to do:
5817                                                                          ;
5818                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - (S R)
5819                                                                          ;
5820                                                                          ; and then set the sign of the result according to
5821                                                                          ; the signs of x_sign and delta
5822 1C0A D021  26        movb @INWK(rx),ra               ; LDA INWK,X        ; First we subtract the low bytes, so:
     1C0C 0053     
5823                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1C0E 0A15  14        sla  rmone,1
                   < elite.a99
5824                      .sbc @R,ra                      ; SBC R             ; x_lo = x_lo - R
     **** ****     > SBC
0001 1C10 1801  10        joc  !
0002 1C12 7004  14        sb   rone,ra
0003               !:
0004 1C14 7020  22        sb   @R,ra
     1C16 0091     
                   < elite.a99
5825 1C18 D840  30        movb ra,@INWK(rx)               ; STA INWK,X
     1C1A 0053     
5826               
5827 1C1C D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Then we subtract the high bytes:
     1C1E 0054     
5828                      .sbc @S,ra                      ; SBC S             ;
     **** ****     > SBC
0001 1C20 1801  10        joc  !
0002 1C22 7004  14        sb   rone,ra
0003               !:
0004 1C24 7020  22        sb   @S,ra
     1C26 0092     
                   < elite.a99
5829 1C28 D840  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = x_hi - S
     1C2A 0054     
5830               
5831 1C2C D021  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally we subtract any borrow from bits 0-6 of
     1C2E 0055     
5832 1C30 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; x_sign, and give the result the opposite sign bit to T
     1C32 7F00     
5833                      .sbi (>00*256)                  ; SBC #0            ; (i.e. give it the sign of the original x_sign)
     **** ****     > SBI
0001 1C34 1801  10        joc  !
0002 1C36 7004  14        sb   rone,ra
0003               !:
0004 1C38 0220  14        ai   ra,-(>00*256)
     1C3A 0000     
                   < elite.a99
5834 1C3C 0260  14        ori  ra,>80*256                 ; ORA #%10000000
     1C3E 8000     
5835                      .eor @T                         ; EOR T
     **** ****     > EOR
0001 1C40 D1A0  22        movb @T,rtmp
     1C42 00D1     
0002 1C44 2806  14        xor  rtmp,ra
                   < elite.a99
5836 1C46 D840  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X
     1C48 0055     
5837               
5838 1C4A 181C  10        joc  MV11                       ; BCS MV11          ; If the C flag is set by the above SBC, then our sum
5839                                                                          ; above didn't underflow and is correct - to put it
5840                                                                          ; another way, (x_sign x_hi x_lo) >= (S R) so the result
5841                                                                          ; should indeed have the same sign as x_sign, so jump to
5842                                                                          ; MV11 to return from the subroutine
5843               
5844                                                                          ; Otherwise our subtraction underflowed because
5845                                                                          ; (x_sign x_hi x_lo) < (S R), so we now need to flip the
5846                                                                          ; subtraction around by using two's complement to this:
5847                                                                          ;
5848                                                                          ; (S R) - (x_sign x_hi x_lo)
5849                                                                          ;
5850                                                                          ; and then we need to give the result the same sign as
5851                                                                          ; (S R), the delta, as that's the dominant figure in the
5852                                                                          ; sum
5853               
5854 1C4C 0200  12        li   ra,>01*256                 ; LDA #1            ; First we subtract the low bytes, so:
     1C4E 0100     
5855                      .sbc @INWK(rx),ra               ; SBC INWK,X        ;
     **** ****     > SBC
0001 1C50 1801  10        joc  !
0002 1C52 7004  14        sb   rone,ra
0003               !:
0004 1C54 7021  26        sb   @INWK(RX),ra
     1C56 0053     
                   < elite.a99
5856 1C58 D840  30        movb ra,@INWK(rx)               ; STA INWK,X        ; x_lo = 1 - x_lo
     1C5A 0053     
5857               
5858 1C5C 0200  12        li   ra,>00*256                 ; LDA #0            ; Then we subtract the high bytes:
     1C5E 0000     
5859                      .sbc @INWK+1(rx),ra             ; SBC INWK+1,X      ;
     **** ****     > SBC
0001 1C60 1801  10        joc  !
0002 1C62 7004  14        sb   rone,ra
0003               !:
0004 1C64 7021  26        sb   @INWK+1(RX),ra
     1C66 0054     
                   < elite.a99
5860 1C68 D840  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = 0 - x_hi
     1C6A 0054     
5861               
5862 1C6C 0200  12        li   ra,>00*256                 ; LDA #0            ; And then we subtract the sign bytes:
     1C6E 0000     
5863                      .sbc @INWK+2(rx),ra             ; SBC INWK+2,X      ;
     **** ****     > SBC
0001 1C70 1801  10        joc  !
0002 1C72 7004  14        sb   rone,ra
0003               !:
0004 1C74 7021  26        sb   @INWK+2(RX),ra
     1C76 0055     
                   < elite.a99
5864                                                                          ; x_sign = 0 - x_sign
5865               
5866 1C78 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; Finally, we set the sign bit to the sign in T, the
     1C7A 7F00     
5867 1C7C F020  22        socb @T,ra                      ; ORA T             ; sign of the original delta, as the delta is the
     1C7E 00D1     
5868 1C80 D840  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X      ; dominant figure in the sum
     1C82 0055     
5869               
5870               MV11:
5871 1C84 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1C86 FF1C     
5872               
5873               * ******************************************************************************
5874               *
5875               * Name: MVT3
5876               * Type: Subroutine
5877               * Category: Moving
5878               * Summary: Calculate K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
5879               *
5880               * ------------------------------------------------------------------------------
5881               *
5882               * Add an INWK position coordinate - i.e. x, y or z - to K(3 2 1), like this:
5883               *
5884               * K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
5885               *
5886               * The INWK coordinate to add to K(3 2 1) is specified by X.
5887               *
5888               * ------------------------------------------------------------------------------
5889               *
5890               * Arguments:
5891               *
5892               * X                   The coordinate to add to K(3 2 1), as follows:
5893               *
5894               * * If X = 0, add (x_sign x_hi x_lo)
5895               *
5896               * * If X = 3, add (y_sign y_hi y_lo)
5897               *
5898               * * If X = 6, add (z_sign z_hi z_lo)
5899               *
5900               * ------------------------------------------------------------------------------
5901               *
5902               * Returns:
5903               *
5904               * A                   Contains a copy of the high byte of the result, K+3
5905               *
5906               * X                   X is preserved
5907               *
5908               * ******************************************************************************
5909               
5910               MVT3:
5911 1C88 D020  22        movb @K+3,ra                    ; LDA K+3           ; Set S = K+3
     1C8A 0040     
5912 1C8C D800  22        movb ra,@S                      ; STA S
     1C8E 0092     
5913               
5914 1C90 0240  14        andi ra,>80*256                 ; AND #%10000000    ; Set T = sign bit of K(3 2 1)
     1C92 8000     
5915 1C94 D800  22        movb ra,@T                      ; STA T
     1C96 00D1     
5916               
5917                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; If x_sign has a different sign to K(3 2 1), jump to
     **** ****     > EOR
0001 1C98 D1A1  26        movb @INWK+2(RX),rtmp
     1C9A 0055     
0002 1C9C 2806  14        xor  rtmp,ra
                   < elite.a99
5918 1C9E 111F  10        jlt  MV13                       ; BMI MV13          ; MV13 to process the addition as a subtraction
5919               
5920 1CA0 D020  22        movb @K+1,ra                    ; LDA K+1           ; Set K(3 2 1) = K(3 2 1) + (x_sign x_hi x_lo)
     1CA2 003E     
5921                      .clc                            ; CLC               ; starting with the low bytes
     **** ****     > CLC
0001 1CA4 0A13  14        sla  rzero,1
                   < elite.a99
5922                      .adc @INWK(rx),ra               ; ADC INWK,X
     **** ****     > ADC
0001 1CA6 1701  10        jnc  !
0002 1CA8 B004  14        ab   rone,ra
0003               !:
0004 1CAA B021  26        ab   @INWK(RX),ra
     1CAC 0053     
                   < elite.a99
5923 1CAE D800  22        movb ra,@K+1                    ; STA K+1
     1CB0 003E     
5924               
5925 1CB2 D020  22        movb @K+2,ra                    ; LDA K+2           ; Then the middle bytes
     1CB4 003F     
5926                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X
     **** ****     > ADC
0001 1CB6 1701  10        jnc  !
0002 1CB8 B004  14        ab   rone,ra
0003               !:
0004 1CBA B021  26        ab   @INWK+1(RX),ra
     1CBC 0054     
                   < elite.a99
5927 1CBE D800  22        movb ra,@K+2                    ; STA K+2
     1CC0 003F     
5928               
5929 1CC2 D020  22        movb @K+3,ra                    ; LDA K+3           ; And finally the high bytes
     1CC4 0040     
5930                      .adc @INWK+2(rx),ra             ; ADC INWK+2,X
     **** ****     > ADC
0001 1CC6 1701  10        jnc  !
0002 1CC8 B004  14        ab   rone,ra
0003               !:
0004 1CCA B021  26        ab   @INWK+2(RX),ra
     1CCC 0055     
                   < elite.a99
5931               
5932 1CCE 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; Setting the sign bit of K+3 to T, the original sign
     1CD0 7F00     
5933 1CD2 F020  22        socb @T,ra                      ; ORA T             ; of K(3 2 1)
     1CD4 00D1     
5934 1CD6 D800  22        movb ra,@K+3                    ; STA K+3
     1CD8 0040     
5935               
5936 1CDA 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1CDC FF1C     
5937               
5938               MV13:
5939 1CDE D020  22        movb @S,ra                      ; LDA S             ; Set S = |K+3| (i.e. K+3 with the sign bit cleared)
     1CE0 0092     
5940 1CE2 0240  14        andi ra,>7f*256                 ; AND #%01111111
     1CE4 7F00     
5941 1CE6 D800  22        movb ra,@S                      ; STA S
     1CE8 0092     
5942               
5943 1CEA D021  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Set K(3 2 1) = (x_sign x_hi x_lo) - K(3 2 1)
     1CEC 0053     
5944                      .sec                            ; SEC               ; starting with the low bytes
     **** ****     > SEC
0001 1CEE 0A15  14        sla  rmone,1
                   < elite.a99
5945                      .sbc @K+1,ra                    ; SBC K+1
     **** ****     > SBC
0001 1CF0 1801  10        joc  !
0002 1CF2 7004  14        sb   rone,ra
0003               !:
0004 1CF4 7020  22        sb   @K+1,ra
     1CF6 003E     
                   < elite.a99
5946 1CF8 D800  22        movb ra,@K+1                    ; STA K+1
     1CFA 003E     
5947               
5948 1CFC D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Then the middle bytes
     1CFE 0054     
5949                      .sbc @K+2,ra                    ; SBC K+2
     **** ****     > SBC
0001 1D00 1801  10        joc  !
0002 1D02 7004  14        sb   rone,ra
0003               !:
0004 1D04 7020  22        sb   @K+2,ra
     1D06 003F     
                   < elite.a99
5950 1D08 D800  22        movb ra,@K+2                    ; STA K+2
     1D0A 003F     
5951               
5952 1D0C D021  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally the high bytes, doing A = |x_sign| - |K+3|
     1D0E 0055     
5953 1D10 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; and setting the C flag for testing below
     1D12 7F00     
5954                      .sbc @S,ra                      ; SBC S
     **** ****     > SBC
0001 1D14 1801  10        joc  !
0002 1D16 7004  14        sb   rone,ra
0003               !:
0004 1D18 7020  22        sb   @S,ra
     1D1A 0092     
                   < elite.a99
5955               
5956 1D1C 0260  14        ori  ra,>80*256                 ; ORA #%10000000    ; Set the sign bit of K+3 to the opposite sign of T,
     1D1E 8000     
5957                      .eor @T                         ; EOR T             ; i.e. the opposite sign to the original K(3 2 1)
     **** ****     > EOR
0001 1D20 D1A0  22        movb @T,rtmp
     1D22 00D1     
0002 1D24 2806  14        xor  rtmp,ra
                   < elite.a99
5958 1D26 D800  22        movb ra,@K+3                    ; STA K+3
     1D28 0040     
5959               
5960 1D2A 181C  10        joc  MV14                       ; BCS MV14          ; If the C flag is set, i.e. |x_sign| >= |K+3|, then
5961                                                                          ; the sign of K(3 2 1). In this case, we want the
5962                                                                          ; result to have the same sign as the largest argument,
5963                                                                          ; which is (x_sign x_hi x_lo), which we know has the
5964                                                                          ; opposite sign to K(3 2 1), and that's what we just set
5965                                                                          ; the sign of K(3 2 1) to... so we can jump to MV14 to
5966                                                                          ; return from the subroutine
5967               
5968 1D2C 0200  12        li   ra,>01*256                 ; LDA #1            ; We need to swap the sign of the result in K(3 2 1),
     1D2E 0100     
5969                      .sbc @K+1,ra                    ; SBC K+1           ; which we do by calculating 0 - K(3 2 1), which we can
     **** ****     > SBC
0001 1D30 1801  10        joc  !
0002 1D32 7004  14        sb   rone,ra
0003               !:
0004 1D34 7020  22        sb   @K+1,ra
     1D36 003E     
                   < elite.a99
5970 1D38 D800  22        movb ra,@K+1                    ; STA K+1           ; do with 1 - C - K(3 2 1), as we know the C flag is
     1D3A 003E     
5971                                                                          ; clear. We start with the low bytes
5972               
5973 1D3C 0200  12        li   ra,>00*256                 ; LDA #0            ; Then the middle bytes
     1D3E 0000     
5974                      .sbc @K+2,ra                    ; SBC K+2
     **** ****     > SBC
0001 1D40 1801  10        joc  !
0002 1D42 7004  14        sb   rone,ra
0003               !:
0004 1D44 7020  22        sb   @K+2,ra
     1D46 003F     
                   < elite.a99
5975 1D48 D800  22        movb ra,@K+2                    ; STA K+2
     1D4A 003F     
5976               
5977 1D4C 0200  12        li   ra,>00*256                 ; LDA #0            ; And finally the high bytes
     1D4E 0000     
5978                      .sbc @K+3,ra                    ; SBC K+3
     **** ****     > SBC
0001 1D50 1801  10        joc  !
0002 1D52 7004  14        sb   rone,ra
0003               !:
0004 1D54 7020  22        sb   @K+3,ra
     1D56 0040     
                   < elite.a99
5979               
5980 1D58 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; Set the sign bit of K+3 to the same sign as T,
     1D5A 7F00     
5981 1D5C F020  22        socb @T,ra                      ; ORA T             ; i.e. the same sign as the original K(3 2 1), as
     1D5E 00D1     
5982 1D60 D800  22        movb ra,@K+3                    ; STA K+3           ; that's the largest argument
     1D62 0040     
5983               
5984               MV14:
5985 1D64 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1D66 FF1C     
5986               
5987               * ******************************************************************************
5988               *
5989               * Name: MVS4
5990               * Type: Subroutine
5991               * Category: Moving
5992               * Summary: Apply pitch and roll to an orientation vector
5993               * Deep dive: Orientation vectors
5994               * Pitching and rolling
5995               *
5996               * ------------------------------------------------------------------------------
5997               *
5998               * Apply pitch and roll angles alpha and beta to the orientation vector in Y.
5999               *
6000               * Specifically, this routine rotates a point (x, y, z) around the origin by
6001               * pitch alpha and roll beta, using the small angle approximation to make the
6002               * maths easier, and incorporating the Minsky circle algorithm to make the
6003               * rotation more stable (though more elliptic).
6004               *
6005               * If that paragraph makes sense to you, then you should probably be writing
6006               * this commentary! For the rest of us, there's a detailed explanation of all
6007               * this in the deep dive on "Pitching and rolling".
6008               *
6009               * ------------------------------------------------------------------------------
6010               *
6011               * Arguments:
6012               *
6013               * Y                   Determines which of the INWK orientation vectors to
6014               * transform:
6015               *
6016               * * Y = 9 rotates nosev: (nosev_x, nosev_y, nosev_z)
6017               *
6018               * * Y = 15 rotates roofv: (roofv_x, roofv_y, roofv_z)
6019               *
6020               * * Y = 21 rotates sidev: (sidev_x, sidev_y, sidev_z)
6021               *
6022               * ******************************************************************************
6023               
6024               MVS4:
6025 1D68 D020  22        movb @ALPHA,ra                  ; LDA ALPHA         ; Set Q = alpha (the roll angle to rotate through)
     1D6A 009E     
6026 1D6C D800  22        movb ra,@Q                      ; STA Q
     1D6E 0090     
6027               
6028 1D70 D062  26        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set (S R) = nosev_y
     1D72 0055     
6029 1D74 D801  22        movb rx,@R                      ; STX R
     1D76 0091     
6030 1D78 D062  26        movb @INWK+3(ry),rx             ; LDX INWK+3,Y
     1D7A 0056     
6031 1D7C D801  22        movb rx,@S                      ; STX S
     1D7E 0092     
6032               
6033 1D80 D062  26        movb @INWK(ry),rx               ; LDX INWK,Y        ; These instructions have no effect as MAD overwrites
     1D82 0053     
6034 1D84 D801  22        movb rx,@P                      ; STX P             ; X and P when called, but they set X = P = nosev_x_lo
     1D86 001B     
6035               
6036 1D88 D022  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Set A = -nosev_x_hi
     1D8A 0054     
6037                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1D8C 0206  12        li   rtmp,(>80*256)
     1D8E 8000     
0002 1D90 2806  14        xor  rtmp,ra
                   < elite.a99
6038               
6039 1D92 0206  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1D94 44B2     
6040 1D96 06A0  24        bl   @jsr                       ;
     1D98 FF10     
6041 1D9A D880  30        movb ra,@INWK+3(ry)             ; STA INWK+3,Y      ; = alpha * -nosev_x_hi + nosev_y
     1D9C 0056     
6042 1D9E D881  30        movb rx,@INWK+2(ry)             ; STX INWK+2,Y      ;
     1DA0 0055     
6043                                                                          ; and store (A X) in nosev_y, so this does:
6044                                                                          ;
6045                                                                          ; nosev_y = nosev_y - alpha * nosev_x_hi
6046               
6047 1DA2 D801  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1DA4 001B     
6048                                                                          ; but it sets P = nosev_y_lo
6049               
6050 1DA6 D062  26        movb @INWK(ry),rx               ; LDX INWK,Y        ; Set (S R) = nosev_x
     1DA8 0053     
6051 1DAA D801  22        movb rx,@R                      ; STX R
     1DAC 0091     
6052 1DAE D062  26        movb @INWK+1(ry),rx             ; LDX INWK+1,Y
     1DB0 0054     
6053 1DB2 D801  22        movb rx,@S                      ; STX S
     1DB4 0092     
6054               
6055 1DB6 D022  26        movb @INWK+3(ry),ra             ; LDA INWK+3,Y      ; Set A = nosev_y_hi
     1DB8 0056     
6056               
6057 1DBA 0206  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1DBC 44B2     
6058 1DBE 06A0  24        bl   @jsr                       ;
     1DC0 FF10     
6059 1DC2 D880  30        movb ra,@INWK+1(ry)             ; STA INWK+1,Y      ; = alpha * nosev_y_hi + nosev_x
     1DC4 0054     
6060 1DC6 D881  30        movb rx,@INWK(ry)               ; STX INWK,Y        ;
     1DC8 0053     
6061                                                                          ; and store (A X) in nosev_x, so this does:
6062                                                                          ;
6063                                                                          ; nosev_x = nosev_x + alpha * nosev_y_hi
6064               
6065 1DCA D801  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1DCC 001B     
6066                                                                          ; but it sets P = nosev_x_lo
6067               
6068 1DCE D020  22        movb @BETA,ra                   ; LDA BETA          ; Set Q = beta (the pitch angle to rotate through)
     1DD0 002A     
6069 1DD2 D800  22        movb ra,@Q                      ; STA Q
     1DD4 0090     
6070               
6071 1DD6 D062  26        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set (S R) = nosev_y
     1DD8 0055     
6072 1DDA D801  22        movb rx,@R                      ; STX R
     1DDC 0091     
6073 1DDE D062  26        movb @INWK+3(ry),rx             ; LDX INWK+3,Y
     1DE0 0056     
6074 1DE2 D801  22        movb rx,@S                      ; STX S
     1DE4 0092     
6075 1DE6 D062  26        movb @INWK+4(ry),rx             ; LDX INWK+4,Y
     1DE8 0057     
6076               
6077 1DEA D801  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1DEC 001B     
6078                                                                          ; but it sets P = nosev_y
6079               
6080 1DEE D022  26        movb @INWK+5(ry),ra             ; LDA INWK+5,Y      ; Set A = -nosev_z_hi
     1DF0 0058     
6081                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1DF2 0206  12        li   rtmp,(>80*256)
     1DF4 8000     
0002 1DF6 2806  14        xor  rtmp,ra
                   < elite.a99
6082               
6083 1DF8 0206  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1DFA 44B2     
6084 1DFC 06A0  24        bl   @jsr                       ;
     1DFE FF10     
6085 1E00 D880  30        movb ra,@INWK+3(ry)             ; STA INWK+3,Y      ; = beta * -nosev_z_hi + nosev_y
     1E02 0056     
6086 1E04 D881  30        movb rx,@INWK+2(ry)             ; STX INWK+2,Y      ;
     1E06 0055     
6087                                                                          ; and store (A X) in nosev_y, so this does:
6088                                                                          ;
6089                                                                          ; nosev_y = nosev_y - beta * nosev_z_hi
6090               
6091 1E08 D801  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1E0A 001B     
6092                                                                          ; but it sets P = nosev_y_lo
6093               
6094 1E0C D062  26        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; Set (S R) = nosev_z
     1E0E 0057     
6095 1E10 D801  22        movb rx,@R                      ; STX R
     1E12 0091     
6096 1E14 D062  26        movb @INWK+5(ry),rx             ; LDX INWK+5,Y
     1E16 0058     
6097 1E18 D801  22        movb rx,@S                      ; STX S
     1E1A 0092     
6098               
6099 1E1C D022  26        movb @INWK+3(ry),ra             ; LDA INWK+3,Y      ; Set A = nosev_y_hi
     1E1E 0056     
6100               
6101 1E20 0206  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1E22 44B2     
6102 1E24 06A0  24        bl   @jsr                       ;
     1E26 FF10     
6103 1E28 D880  30        movb ra,@INWK+5(ry)             ; STA INWK+5,Y      ; = beta * nosev_y_hi + nosev_z
     1E2A 0058     
6104 1E2C D881  30        movb rx,@INWK+4(ry)             ; STX INWK+4,Y      ;
     1E2E 0057     
6105                                                                          ; and store (A X) in nosev_z, so this does:
6106                                                                          ;
6107                                                                          ; nosev_z = nosev_z + beta * nosev_y_hi
6108               
6109 1E30 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1E32 FF1C     
6110               
6111               * ******************************************************************************
6112               *
6113               * Name: MVS5
6114               * Type: Subroutine
6115               * Category: Moving
6116               * Summary: Apply a 3.6 degree pitch or roll to an orientation vector
6117               * Deep dive: Orientation vectors
6118               * Pitching and rolling by a fixed angle
6119               *
6120               * ------------------------------------------------------------------------------
6121               *
6122               * Pitch or roll a ship by a small, fixed amount (1/16 radians, or 3.6 degrees),
6123               * in a specified direction, by rotating the orientation vectors. The vectors to
6124               * rotate are given in X and Y, and the direction of the rotation is given in
6125               * RAT2. The calculation is as follows:
6126               *
6127               * * If the direction is positive:
6128               *
6129               * X = X * (1 - 1/512) + Y / 16
6130               * Y = Y * (1 - 1/512) - X / 16
6131               *
6132               * * If the direction is negative:
6133               *
6134               * X = X * (1 - 1/512) - Y / 16
6135               * Y = Y * (1 - 1/512) + X / 16
6136               *
6137               * So if X = 15 (roofv_x), Y = 21 (sidev_x) and RAT2 is positive, it does this:
6138               *
6139               * roofv_x = roofv_x * (1 - 1/512)  + sidev_x / 16
6140               * sidev_x = sidev_x * (1 - 1/512)  - roofv_x / 16
6141               *
6142               * ------------------------------------------------------------------------------
6143               *
6144               * Arguments:
6145               *
6146               * X                   The first vector to rotate:
6147               *
6148               * * If X = 15, rotate roofv_x
6149               *
6150               * * If X = 17, rotate roofv_y
6151               *
6152               * * If X = 19, rotate roofv_z
6153               *
6154               * * If X = 21, rotate sidev_x
6155               *
6156               * * If X = 23, rotate sidev_y
6157               *
6158               * * If X = 25, rotate sidev_z
6159               *
6160               * Y                   The second vector to rotate:
6161               *
6162               * * If Y = 9,  rotate nosev_x
6163               *
6164               * * If Y = 11, rotate nosev_y
6165               *
6166               * * If Y = 13, rotate nosev_z
6167               *
6168               * * If Y = 21, rotate sidev_x
6169               *
6170               * * If Y = 23, rotate sidev_y
6171               *
6172               * * If Y = 25, rotate sidev_z
6173               *
6174               * RAT2                The direction of the pitch or roll to perform, positive
6175               * or negative (i.e. the sign of the roll or pitch counter
6176               * in bit 7)
6177               *
6178               * ******************************************************************************
6179               
6180               MVS5:
6181 1E34 D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch roofv_x_hi, clear the sign bit, divide by 2 and
     1E36 0054     
6182 1E38 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; store in T, so:
     1E3A 7F00     
6183 1E3C 0910  14        srl  ra,1                       ; LSR A             ;
6184 1E3E D800  22        movb ra,@T                      ; STA T             ; T = |roofv_x_hi| / 2
     1E40 00D1     
6185                                                                          ; = |roofv_x| / 512
6186                                                                          ;
6187                                                                          ; The above is true because:
6188                                                                          ;
6189                                                                          ; |roofv_x| = |roofv_x_hi| * 256 + roofv_x_lo
6190                                                                          ;
6191                                                                          ; so:
6192                                                                          ;
6193                                                                          ; |roofv_x| / 512 = |roofv_x_hi| * 256 / 512
6194                                                                          ; + roofv_x_lo / 512
6195                                                                          ; = |roofv_x_hi| / 2
6196               
6197 1E42 D021  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Now we do the following subtraction:
     1E44 0053     
6198                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1E46 0A15  14        sla  rmone,1
                   < elite.a99
6199                      .sbc @T,ra                      ; SBC T             ; (S R) = (roofv_x_hi roofv_x_lo) - |roofv_x| / 512
     **** ****     > SBC
0001 1E48 1801  10        joc  !
0002 1E4A 7004  14        sb   rone,ra
0003               !:
0004 1E4C 7020  22        sb   @T,ra
     1E4E 00D1     
                   < elite.a99
6200 1E50 D800  22        movb ra,@R                      ; STA R             ; = (1 - 1/512) * roofv_x
     1E52 0091     
6201                                                                          ;
6202                                                                          ; by doing the low bytes first
6203               
6204 1E54 D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; And then the high bytes (the high byte of the right
     1E56 0054     
6205                      .sbi (>00*256)                  ; SBC #0            ; side of the subtraction being 0)
     **** ****     > SBI
0001 1E58 1801  10        joc  !
0002 1E5A 7004  14        sb   rone,ra
0003               !:
0004 1E5C 0220  14        ai   ra,-(>00*256)
     1E5E 0000     
                   < elite.a99
6206 1E60 D800  22        movb ra,@S                      ; STA S
     1E62 0092     
6207               
6208 1E64 D022  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Set P = nosev_x_lo
     1E66 0053     
6209 1E68 D800  22        movb ra,@P                      ; STA P
     1E6A 001B     
6210               
6211 1E6C D022  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch the sign of nosev_x_hi (bit 7) and store in T
     1E6E 0054     
6212 1E70 0240  14        andi ra,>80*256                 ; AND #%10000000
     1E72 8000     
6213 1E74 D800  22        movb ra,@T                      ; STA T
     1E76 00D1     
6214               
6215 1E78 D022  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch nosev_x_hi into A and clear the sign bit, so
     1E7A 0054     
6216 1E7C 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; A = |nosev_x_hi|
     1E7E 7F00     
6217               
6218 1E80 0910  14        srl  ra,1                       ; LSR A             ; Set (A P) = (A P) / 16
6219 1E82 0208  12        li   rarg1,P                    ; ROR P             ; = |nosev_x_hi nosev_x_lo| / 16
     1E84 001B     
6220 1E86 06A0  24        bl   @ror                       ;
     1E88 FF62     
6221 1E8A 0910  14        srl  ra,1                       ; LSR A             ; = |nosev_x| / 16
6222 1E8C 0208  12        li   rarg1,P                    ; ROR P
     1E8E 001B     
6223 1E90 06A0  24        bl   @ror                       ;
     1E92 FF62     
6224 1E94 0910  14        srl  ra,1                       ; LSR A
6225 1E96 0208  12        li   rarg1,P                    ; ROR P
     1E98 001B     
6226 1E9A 06A0  24        bl   @ror                       ;
     1E9C FF62     
6227 1E9E 0910  14        srl  ra,1                       ; LSR A
6228 1EA0 0208  12        li   rarg1,P                    ; ROR P
     1EA2 001B     
6229 1EA4 06A0  24        bl   @ror                       ;
     1EA6 FF62     
6230               
6231 1EA8 F020  22        socb @T,ra                      ; ORA T             ; Set the sign of A to the sign in T (i.e. the sign of
     1EAA 00D1     
6232                                                                          ; the original nosev_x), so now:
6233                                                                          ;
6234                                                                          ; (A P) = nosev_x / 16
6235               
6236                      .eor @RAT2                      ; EOR RAT2          ; Give it the sign as if we multiplied by the direction
     **** ****     > EOR
0001 1EAC D1A0  22        movb @RAT2,rtmp
     1EAE 00AB     
0002 1EB0 2806  14        xor  rtmp,ra
                   < elite.a99
6237                                                                          ; by the pitch or roll direction
6238               
6239 1EB2 D801  22        movb rx,@Q                      ; STX Q             ; Store the value of X so it can be restored after the
     1EB4 0090     
6240                                                                          ; call to ADD
6241               
6242 1EB6 0206  12        li   rtmp,ADD                   ; JSR ADD           ; (A X) = (A P) + (S R)
     1EB8 44BA     
6243 1EBA 06A0  24        bl   @jsr                       ;
     1EBC FF10     
6244                                                                          ; = +/-nosev_x / 16 + (1 - 1/512) * roofv_x
6245               
6246 1EBE D800  22        movb ra,@K+1                    ; STA K+1           ; Set K(1 0) = (1 - 1/512) * roofv_x +/- nosev_x / 16
     1EC0 003E     
6247 1EC2 D801  22        movb rx,@K                      ; STX K
     1EC4 003D     
6248               
6249 1EC6 D060  22        movb @Q,rx                      ; LDX Q             ; Restore the value of X from before the call to ADD
     1EC8 0090     
6250               
6251 1ECA D022  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch nosev_x_hi, clear the sign bit, divide by 2 and
     1ECC 0054     
6252 1ECE 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; store in T, so:
     1ED0 7F00     
6253 1ED2 0910  14        srl  ra,1                       ; LSR A             ;
6254 1ED4 D800  22        movb ra,@T                      ; STA T             ; T = |nosev_x_hi| / 2
     1ED6 00D1     
6255                                                                          ; = |nosev_x| / 512
6256               
6257 1ED8 D022  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Now we do the following subtraction:
     1EDA 0053     
6258                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1EDC 0A15  14        sla  rmone,1
                   < elite.a99
6259                      .sbc @T,ra                      ; SBC T             ; (S R) = (nosev_x_hi nosev_x_lo) - |nosev_x| / 512
     **** ****     > SBC
0001 1EDE 1801  10        joc  !
0002 1EE0 7004  14        sb   rone,ra
0003               !:
0004 1EE2 7020  22        sb   @T,ra
     1EE4 00D1     
                   < elite.a99
6260 1EE6 D800  22        movb ra,@R                      ; STA R             ; = (1 - 1/512) * nosev_x
     1EE8 0091     
6261                                                                          ;
6262                                                                          ; by doing the low bytes first
6263               
6264 1EEA D022  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; And then the high bytes (the high byte of the right
     1EEC 0054     
6265                      .sbi (>00*256)                  ; SBC #0            ; side of the subtraction being 0)
     **** ****     > SBI
0001 1EEE 1801  10        joc  !
0002 1EF0 7004  14        sb   rone,ra
0003               !:
0004 1EF2 0220  14        ai   ra,-(>00*256)
     1EF4 0000     
                   < elite.a99
6266 1EF6 D800  22        movb ra,@S                      ; STA S
     1EF8 0092     
6267               
6268 1EFA D021  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Set P = roofv_x_lo
     1EFC 0053     
6269 1EFE D800  22        movb ra,@P                      ; STA P
     1F00 001B     
6270               
6271 1F02 D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch the sign of roofv_x_hi (bit 7) and store in T
     1F04 0054     
6272 1F06 0240  14        andi ra,>80*256                 ; AND #%10000000
     1F08 8000     
6273 1F0A D800  22        movb ra,@T                      ; STA T
     1F0C 00D1     
6274               
6275 1F0E D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch roofv_x_hi into A and clear the sign bit, so
     1F10 0054     
6276 1F12 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; A = |roofv_x_hi|
     1F14 7F00     
6277               
6278 1F16 0910  14        srl  ra,1                       ; LSR A             ; Set (A P) = (A P) / 16
6279 1F18 0208  12        li   rarg1,P                    ; ROR P             ; = |roofv_x_hi roofv_x_lo| / 16
     1F1A 001B     
6280 1F1C 06A0  24        bl   @ror                       ;
     1F1E FF62     
6281 1F20 0910  14        srl  ra,1                       ; LSR A             ; = |roofv_x| / 16
6282 1F22 0208  12        li   rarg1,P                    ; ROR P
     1F24 001B     
6283 1F26 06A0  24        bl   @ror                       ;
     1F28 FF62     
6284 1F2A 0910  14        srl  ra,1                       ; LSR A
6285 1F2C 0208  12        li   rarg1,P                    ; ROR P
     1F2E 001B     
6286 1F30 06A0  24        bl   @ror                       ;
     1F32 FF62     
6287 1F34 0910  14        srl  ra,1                       ; LSR A
6288 1F36 0208  12        li   rarg1,P                    ; ROR P
     1F38 001B     
6289 1F3A 06A0  24        bl   @ror                       ;
     1F3C FF62     
6290               
6291 1F3E F020  22        socb @T,ra                      ; ORA T             ; Set the sign of A to the opposite sign to T (i.e. the
     1F40 00D1     
6292                      .eoi (>80*256)                  ; EOR #%10000000    ; sign of the original -roofv_x), so now:
     **** ****     > EOI
0001 1F42 0206  12        li   rtmp,(>80*256)
     1F44 8000     
0002 1F46 2806  14        xor  rtmp,ra
                   < elite.a99
6293                                                                          ;
6294                                                                          ; (A P) = -roofv_x / 16
6295               
6296                      .eor @RAT2                      ; EOR RAT2          ; Give it the sign as if we multiplied by the direction
     **** ****     > EOR
0001 1F48 D1A0  22        movb @RAT2,rtmp
     1F4A 00AB     
0002 1F4C 2806  14        xor  rtmp,ra
                   < elite.a99
6297                                                                          ; by the pitch or roll direction
6298               
6299 1F4E D801  22        movb rx,@Q                      ; STX Q             ; Store the value of X so it can be restored after the
     1F50 0090     
6300                                                                          ; call to ADD
6301               
6302 1F52 0206  12        li   rtmp,ADD                   ; JSR ADD           ; (A X) = (A P) + (S R)
     1F54 44BA     
6303 1F56 06A0  24        bl   @jsr                       ;
     1F58 FF10     
6304                                                                          ; = -/+roofv_x / 16 + (1 - 1/512) * nosev_x
6305               
6306 1F5A D880  30        movb ra,@INWK+1(ry)             ; STA INWK+1,Y      ; Set nosev_x = (1-1/512) * nosev_x -/+ roofv_x / 16
     1F5C 0054     
6307 1F5E D881  30        movb rx,@INWK(ry)               ; STX INWK,Y
     1F60 0053     
6308               
6309 1F62 D060  22        movb @Q,rx                      ; LDX Q             ; Restore the value of X from before the call to ADD
     1F64 0090     
6310               
6311 1F66 D020  22        movb @K,ra                      ; LDA K             ; Set roofv_x = K(1 0)
     1F68 003D     
6312 1F6A D840  30        movb ra,@INWK(rx)               ; STA INWK,X        ; = (1-1/512) * roofv_x +/- nosev_x / 16
     1F6C 0053     
6313 1F6E D020  22        movb @K+1,ra                    ; LDA K+1
     1F70 003E     
6314 1F72 D840  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X
     1F74 0054     
6315               
6316 1F76 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1F78 FF1C     
6317               
6318               * ******************************************************************************
6319               *
6320               * Name: MVT6
6321               * Type: Subroutine
6322               * Category: Moving
6323               * Summary: Calculate (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
6324               *
6325               * ------------------------------------------------------------------------------
6326               *
6327               * Do the following calculation, for the coordinate given by X (so this is what
6328               * it does for the x-coordinate):
6329               *
6330               * (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
6331               *
6332               * A is a sign bit and is not included in the calculation, but bits 0-6 of A are
6333               * preserved. Bit 7 is set to the sign of the result.
6334               *
6335               * ------------------------------------------------------------------------------
6336               *
6337               * Arguments:
6338               *
6339               * A                   The sign of P(2 1) in bit 7
6340               *
6341               * P(2 1)              The 16-bit value we want to add the coordinate to
6342               *
6343               * X                   The coordinate to add, as follows:
6344               *
6345               * * If X = 0, add to (x_sign x_hi x_lo)
6346               *
6347               * * If X = 3, add to (y_sign y_hi y_lo)
6348               *
6349               * * If X = 6, add to (z_sign z_hi z_lo)
6350               *
6351               * ------------------------------------------------------------------------------
6352               *
6353               * Returns:
6354               *
6355               * A                   The sign of the result (in bit 7)
6356               *
6357               * ******************************************************************************
6358               
6359               MVT6:
6360 1F7A D080  14        movb ra,ry                      ; TAY               ; Store argument A into Y, for later use
6361               
6362                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; Set A = A EOR x_sign
     **** ****     > EOR
0001 1F7C D1A1  26        movb @INWK+2(RX),rtmp
     1F7E 0055     
0002 1F80 2806  14        xor  rtmp,ra
                   < elite.a99
6363               
6364 1F82 1114  10        jlt  MV50                       ; BMI MV50          ; If the sign is negative, i.e. A and x_sign have
6365                                                                          ; different signs, jump to MV50
6366               
6367                                                                          ; The signs are the same, so we can add the two
6368                                                                          ; arguments and keep the sign to get the result
6369               
6370 1F84 D020  22        movb @P+1,ra                    ; LDA P+1           ; First we add the low bytes:
     1F86 001C     
6371                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 1F88 0A13  14        sla  rzero,1
                   < elite.a99
6372                      .adc @INWK(rx),ra               ; ADC INWK,X        ; P+1 = P+1 + x_lo
     **** ****     > ADC
0001 1F8A 1701  10        jnc  !
0002 1F8C B004  14        ab   rone,ra
0003               !:
0004 1F8E B021  26        ab   @INWK(RX),ra
     1F90 0053     
                   < elite.a99
6373 1F92 D800  22        movb ra,@P+1                    ; STA P+1
     1F94 001C     
6374               
6375 1F96 D020  22        movb @P+2,ra                    ; LDA P+2           ; And then the high bytes:
     1F98 001D     
6376                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X      ;
     **** ****     > ADC
0001 1F9A 1701  10        jnc  !
0002 1F9C B004  14        ab   rone,ra
0003               !:
0004 1F9E B021  26        ab   @INWK+1(RX),ra
     1FA0 0054     
                   < elite.a99
6377 1FA2 D800  22        movb ra,@P+2                    ; STA P+2           ; P+2 = P+2 + x_hi
     1FA4 001D     
6378               
6379 1FA6 D002  14        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6380                                                                          ; so that we keep the original sign
6381               
6382 1FA8 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1FAA FF1C     
6383               
6384               MV50:
6385 1FAC D021  26        movb @INWK(rx),ra               ; LDA INWK,X        ; First we subtract the low bytes:
     1FAE 0053     
6386                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1FB0 0A15  14        sla  rmone,1
                   < elite.a99
6387                      .sbc @P+1,ra                    ; SBC P+1           ; P+1 = x_lo - P+1
     **** ****     > SBC
0001 1FB2 1801  10        joc  !
0002 1FB4 7004  14        sb   rone,ra
0003               !:
0004 1FB6 7020  22        sb   @P+1,ra
     1FB8 001C     
                   < elite.a99
6388 1FBA D800  22        movb ra,@P+1                    ; STA P+1
     1FBC 001C     
6389               
6390 1FBE D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; And then the high bytes:
     1FC0 0054     
6391                      .sbc @P+2,ra                    ; SBC P+2           ;
     **** ****     > SBC
0001 1FC2 1801  10        joc  !
0002 1FC4 7004  14        sb   rone,ra
0003               !:
0004 1FC6 7020  22        sb   @P+2,ra
     1FC8 001D     
                   < elite.a99
6392 1FCA D800  22        movb ra,@P+2                    ; STA P+2           ; P+2 = x_hi - P+2
     1FCC 001D     
6393               
6394 1FCE 1706  10        jnc  MV51                       ; BCC MV51          ; If the last subtraction underflowed, then the C flag
6395                                                                          ; will be clear and x_hi < P+2, so jump to MV51 to
6396                                                                          ; negate the result
6397               
6398 1FD0 D002  14        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6399                      .eoi (>80*256)                  ; EOR #%10000000    ; but flip bit 7, which flips the sign. We do this
     **** ****     > EOI
0001 1FD2 0206  12        li   rtmp,(>80*256)
     1FD4 8000     
0002 1FD6 2806  14        xor  rtmp,ra
                   < elite.a99
6400                                                                          ; because x_hi >= P+2 so we want the result to have the
6401                                                                          ; same sign as x_hi (as it's the dominant side in this
6402                                                                          ; calculation). The sign of x_hi is x_sign, and x_sign
6403                                                                          ; has the opposite sign to A, so we flip the sign in A
6404                                                                          ; to return the correct result
6405               
6406 1FD8 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1FDA FF1C     
6407               
6408               MV51:
6409 1FDC 0200  12        li   ra,>01*256                 ; LDA #1            ; Our subtraction underflowed, so we negate the result
     1FDE 0100     
6410                      .sbc @P+1,ra                    ; SBC P+1           ; using two's complement, first with the low byte:
     **** ****     > SBC
0001 1FE0 1801  10        joc  !
0002 1FE2 7004  14        sb   rone,ra
0003               !:
0004 1FE4 7020  22        sb   @P+1,ra
     1FE6 001C     
                   < elite.a99
6411 1FE8 D800  22        movb ra,@P+1                    ; STA P+1           ;
     1FEA 001C     
6412                                                                          ; P+1 = 1 - P+1
6413               
6414 1FEC 0200  12        li   ra,>00*256                 ; LDA #0            ; And then the high byte:
     1FEE 0000     
6415                      .sbc @P+2,ra                    ; SBC P+2           ;
     **** ****     > SBC
0001 1FF0 1801  10        joc  !
0002 1FF2 7004  14        sb   rone,ra
0003               !:
0004 1FF4 7020  22        sb   @P+2,ra
     1FF6 001D     
                   < elite.a99
6416 1FF8 D800  22        movb ra,@P+2                    ; STA P+2           ; P+2 = 0 - P+2
     1FFA 001D     
6417               
6418 1FFC D002  14        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6419                                                                          ; as this is the correct sign for the result. This is
6420                                                                          ; because x_hi < P+2, so we want to return the same sign
6421                                                                          ; as P+2, the dominant side
6422               
6423 1FFE 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     2000 FF1C     
6424               
6425               * ******************************************************************************
6426               *
6427               * Name: MV40
6428               * Type: Subroutine
6429               * Category: Moving
6430               * Summary: Rotate the planet or sun's location in space by the amount of
6431               * pitch and roll of our ship
6432               * Deep dive: Rotating the universe
6433               *
6434               * ------------------------------------------------------------------------------
6435               *
6436               * We implement this using the same equations as in part 5 of MVEIT, where we
6437               * rotated the current ship's location by our pitch and roll. Specifically, the
6438               * calculation is as follows:
6439               *
6440               * 1. K2 = y - alpha * x
6441               * 2. z = z + beta * K2
6442               * 3. y = K2 - beta * z
6443               * 4. x = x + alpha * y
6444               *
6445               * See the deep dive on "Rotating the universe" for more details on the above.
6446               *
6447               * ******************************************************************************
6448               
6449               MV40:
6450 2002 D020  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set Q = -ALPHA, so Q contains the angle we want to
     2004 009E     
6451                      .eoi (>80*256)                  ; EOR #%10000000    ; roll the planet through (i.e. in the opposite
     **** ****     > EOI
0001 2006 0206  20        li   rtmp,(>80*256)
     2008 8000     
0002 200A 2806  18        xor  rtmp,ra
                   < elite.a99
6452 200C D800  30        movb ra,@Q                      ; STA Q             ; direction to our ship's roll angle alpha)
     200E 0090     
6453               
6454 2010 D020  30        movb @INWK,ra                   ; LDA INWK          ; Set P(1 0) = (x_hi x_lo)
     2012 0053     
6455 2014 D800  30        movb ra,@P                      ; STA P
     2016 001B     
6456 2018 D020  30        movb @INWK+1,ra                 ; LDA INWK+1
     201A 0054     
6457 201C D800  30        movb ra,@P+1                    ; STA P+1
     201E 001C     
6458               
6459 2020 D020  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Set A = x_sign
     2022 0055     
6460               
6461 2024 0206  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     2026 4148     
6462 2028 06A0  32        bl   @jsr                       ;
     202A FF10     
6463                                                                          ;
6464                                                                          ; which also means:
6465                                                                          ;
6466                                                                          ; K(3 2 1) = (A P+1 P) * Q / 256
6467                                                                          ; = x * -alpha / 256
6468                                                                          ; = - alpha * x / 256
6469               
6470 202C 0201  20        li   rx,>03*256                 ; LDX #3            ; Set K(3 2 1) = (y_sign y_hi y_lo) + K(3 2 1)
     202E 0300     
6471 2030 0206  20        li   rtmp,MVT3                  ; JSR MVT3          ; = y - alpha * x / 256
     2032 1C88     
6472 2034 06A0  32        bl   @jsr                       ;
     2036 FF10     
6473               
6474 2038 D020  30        movb @K+1,ra                    ; LDA K+1           ; Set K2(2 1) = P(1 0) = K(2 1)
     203A 003E     
6475 203C D800  30        movb ra,@K2+1                   ; STA K2+1
     203E 00AD     
6476 2040 D800  30        movb ra,@P                      ; STA P
     2042 001B     
6477               
6478 2044 D020  30        movb @K+2,ra                    ; LDA K+2           ; Set K2+2 = K+2
     2046 003F     
6479 2048 D800  30        movb ra,@K2+2                   ; STA K2+2
     204A 00AE     
6480               
6481 204C D800  30        movb ra,@P+1                    ; STA P+1           ; Set P+1 = K+2
     204E 001C     
6482               
6483 2050 D020  30        movb @BETA,ra                   ; LDA BETA          ; Set Q = beta, the pitch angle of our ship
     2052 002A     
6484 2054 D800  30        movb ra,@Q                      ; STA Q
     2056 0090     
6485               
6486 2058 D020  30        movb @K+3,ra                    ; LDA K+3           ; Set K+3 to K2+3, so now we have result 1 above:
     205A 0040     
6487 205C D800  30        movb ra,@K2+3                   ; STA K2+3          ;
     205E 00AF     
6488                                                                          ; K2(3 2 1) = K(3 2 1)
6489                                                                          ; = y - alpha * x / 256
6490               
6491                                                                          ; We also have:
6492                                                                          ;
6493                                                                          ; A = K+3
6494                                                                          ;
6495                                                                          ; P(1 0) = K(2 1)
6496                                                                          ;
6497                                                                          ; so combined, these mean:
6498                                                                          ;
6499                                                                          ; (A P+1 P) = K(3 2 1)
6500                                                                          ; = K2(3 2 1)
6501               
6502 2060 0206  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     2062 4148     
6503 2064 06A0  32        bl   @jsr                       ;
     2066 FF10     
6504                                                                          ;
6505                                                                          ; which also means:
6506                                                                          ;
6507                                                                          ; K(3 2 1) = (A P+1 P) * Q / 256
6508                                                                          ; = K2(3 2 1) * beta / 256
6509                                                                          ; = beta * K2 / 256
6510               
6511 2068 0201  20        li   rx,>06*256                 ; LDX #6            ; K(3 2 1) = (z_sign z_hi z_lo) + K(3 2 1)
     206A 0600     
6512 206C 0206  20        li   rtmp,MVT3                  ; JSR MVT3          ; = z + beta * K2 / 256
     206E 1C88     
6513 2070 06A0  32        bl   @jsr                       ;
     2072 FF10     
6514               
6515 2074 D020  30        movb @K+1,ra                    ; LDA K+1           ; Set P = K+1
     2076 003E     
6516 2078 D800  30        movb ra,@P                      ; STA P
     207A 001B     
6517               
6518 207C D800  30        movb ra,@INWK+6                 ; STA INWK+6        ; Set z_lo = K+1
     207E 0059     
6519               
6520 2080 D020  30        movb @K+2,ra                    ; LDA K+2           ; Set P+1 = K+2
     2082 003F     
6521 2084 D800  30        movb ra,@P+1                    ; STA P+1
     2086 001C     
6522               
6523 2088 D800  30        movb ra,@INWK+7                 ; STA INWK+7        ; Set z_hi = K+2
     208A 005A     
6524               
6525 208C D020  30        movb @K+3,ra                    ; LDA K+3           ; Set A = z_sign = K+3, so now we have:
     208E 0040     
6526 2090 D800  30        movb ra,@INWK+8                 ; STA INWK+8        ;
     2092 005B     
6527                                                                          ; (z_sign z_hi z_lo) = K(3 2 1)
6528                                                                          ; = z + beta * K2 / 256
6529               
6530                                                                          ; So we now have result 2 above:
6531                                                                          ;
6532                                                                          ; z = z + beta * K2
6533               
6534                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign bit of A to give A = -z_sign
     **** ****     > EOI
0001 2094 0206  20        li   rtmp,(>80*256)
     2096 8000     
0002 2098 2806  18        xor  rtmp,ra
                   < elite.a99
6535               
6536 209A 0206  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     209C 4148     
6537 209E 06A0  32        bl   @jsr                       ;
     20A0 FF10     
6538                                                                          ; = (-z_sign z_hi z_lo) * beta
6539                                                                          ; = -z * beta
6540               
6541 20A2 D020  30        movb @K+3,ra                    ; LDA K+3           ; Set T to the sign bit of K(3 2 1 0), i.e. to the sign
     20A4 0040     
6542 20A6 0240  22        andi ra,>80*256                 ; AND #%10000000    ; bit of -z * beta
     20A8 8000     
6543 20AA D800  30        movb ra,@T                      ; STA T
     20AC 00D1     
6544               
6545                      .eor @K2+3                      ; EOR K2+3          ; If K2(3 2 1 0) has a different sign to K(3 2 1 0),
     **** ****     > EOR
0001 20AE D1A0  30        movb @K2+3,rtmp
     20B0 00AF     
0002 20B2 2806  18        xor  rtmp,ra
                   < elite.a99
6546 20B4 111E  14        jlt  MV1                        ; BMI MV1           ; then EOR'ing them will produce a 1 in bit 7, so jump
6547                                                                          ; to MV1 to take this into account
6548               
6549                                                                          ; If we get here, K and K2 have the same sign, so we can
6550                                                                          ; add them together to get the result we're after, and
6551                                                                          ; then set the sign afterwards
6552               
6553 20B6 D020  30        movb @K,ra                      ; LDA K             ; We now do the following sum:
     20B8 003D     
6554               * CLC                    \
6555                      .adc @K2,ra                     ; ADC K2            ; (A y_hi y_lo -) = K(3 2 1 0) + K2(3 2 1 0)
     **** ****     > ADC
0001 20BA 1701  14        jnc  !
0002 20BC B004  18        ab   rone,ra
0003               !:
0004 20BE B020  30        ab   @K2,ra
     20C0 00AC     
                   < elite.a99
6556                                                                          ;
6557                                                                          ; starting with the low bytes (which we don't keep)
6558                                                                          ;
6559                                                                          ; The CLC instruction is commented out in the original
6560                                                                          ; source. It isn't needed because MULT3 clears the C
6561                                                                          ; flag, so this is an example of the authors finding
6562                                                                          ; one more precious byte to save
6563               
6564 20C2 D020  30        movb @K+1,ra                    ; LDA K+1           ; We then do the middle bytes, which go into y_lo
     20C4 003E     
6565                      .adc @K2+1,ra                   ; ADC K2+1
     **** ****     > ADC
0001 20C6 1701  14        jnc  !
0002 20C8 B004  18        ab   rone,ra
0003               !:
0004 20CA B020  30        ab   @K2+1,ra
     20CC 00AD     
                   < elite.a99
6566 20CE D800  30        movb ra,@INWK+3                 ; STA INWK+3
     20D0 0056     
6567               
6568 20D2 D020  30        movb @K+2,ra                    ; LDA K+2           ; And then the high bytes, which go into y_hi
     20D4 003F     
6569                      .adc @K2+2,ra                   ; ADC K2+2
     **** ****     > ADC
0001 20D6 1701  14        jnc  !
0002 20D8 B004  18        ab   rone,ra
0003               !:
0004 20DA B020  30        ab   @K2+2,ra
     20DC 00AE     
                   < elite.a99
6570 20DE D800  30        movb ra,@INWK+4                 ; STA INWK+4
     20E0 0057     
6571               
6572 20E2 D020  30        movb @K+3,ra                    ; LDA K+3           ; And then the sign bytes into A, so overall we have the
     20E4 0040     
6573                      .adc @K2+3,ra                   ; ADC K2+3          ; following, if we drop the low bytes from the result:
     **** ****     > ADC
0001 20E6 1701  14        jnc  !
0002 20E8 B004  18        ab   rone,ra
0003               !:
0004 20EA B020  30        ab   @K2+3,ra
     20EC 00AF     
                   < elite.a99
6574                                                                          ;
6575                                                                          ; (A y_hi y_lo) = (K + K2) / 256
6576               
6577 20EE 0460  28        b    @MV2                       ; JMP MV2           ; Jump to MV2 to skip the calculation for when K and K2
     20F0 2172     
6578                                                                          ; have different signs
6579               
6580               MV1:
6581 20F2 D020  30        movb @K,ra                      ; LDA K             ; If we get here then K2 and K have different signs, so
     20F4 003D     
6582                      .sec                            ; SEC               ; instead of adding, we need to subtract to get the
     **** ****     > SEC
0001 20F6 0A15  18        sla  rmone,1
                   < elite.a99
6583                      .sbc @K2,ra                     ; SBC K2            ; result we want, like this:
     **** ****     > SBC
0001 20F8 1801  14        joc  !
0002 20FA 7004  18        sb   rone,ra
0003               !:
0004 20FC 7020  30        sb   @K2,ra
     20FE 00AC     
                   < elite.a99
6584                                                                          ;
6585                                                                          ; (A y_hi y_lo -) = K(3 2 1 0) - K2(3 2 1 0)
6586                                                                          ;
6587                                                                          ; starting with the low bytes (which we don't keep)
6588               
6589 2100 D020  30        movb @K+1,ra                    ; LDA K+1           ; We then do the middle bytes, which go into y_lo
     2102 003E     
6590                      .sbc @K2+1,ra                   ; SBC K2+1
     **** ****     > SBC
0001 2104 1801  14        joc  !
0002 2106 7004  18        sb   rone,ra
0003               !:
0004 2108 7020  30        sb   @K2+1,ra
     210A 00AD     
                   < elite.a99
6591 210C D800  30        movb ra,@INWK+3                 ; STA INWK+3
     210E 0056     
6592               
6593 2110 D020  30        movb @K+2,ra                    ; LDA K+2           ; And then the high bytes, which go into y_hi
     2112 003F     
6594                      .sbc @K2+2,ra                   ; SBC K2+2
     **** ****     > SBC
0001 2114 1801  14        joc  !
0002 2116 7004  18        sb   rone,ra
0003               !:
0004 2118 7020  30        sb   @K2+2,ra
     211A 00AE     
                   < elite.a99
6595 211C D800  30        movb ra,@INWK+4                 ; STA INWK+4
     211E 0057     
6596               
6597 2120 D020  30        movb @K2+3,ra                   ; LDA K2+3          ; Now for the sign bytes, so first we extract the sign
     2122 00AF     
6598 2124 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; byte from K2 without the sign bit, so P = |K2+3|
     2126 7F00     
6599 2128 D800  30        movb ra,@P                      ; STA P
     212A 001B     
6600               
6601 212C D020  30        movb @K+3,ra                    ; LDA K+3           ; And then we extract the sign byte from K without the
     212E 0040     
6602 2130 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; sign bit, so A = |K+3|
     2132 7F00     
6603               
6604                      .sbc @P,ra                      ; SBC P             ; And finally we subtract the sign bytes, so P = A - P
     **** ****     > SBC
0001 2134 1801  14        joc  !
0002 2136 7004  18        sb   rone,ra
0003               !:
0004 2138 7020  30        sb   @P,ra
     213A 001B     
                   < elite.a99
6605 213C D800  30        movb ra,@P                      ; STA P
     213E 001B     
6606               
6607                                                                          ; By now we have the following, if we drop the low bytes
6608                                                                          ; from the result:
6609                                                                          ;
6610                                                                          ; (A y_hi y_lo) = (K - K2) / 256
6611                                                                          ;
6612                                                                          ; so now we just need to make sure the sign of the
6613                                                                          ; result is correct
6614               
6615 2140 1818  14        joc  MV2                        ; BCS MV2           ; If the C flag is set, then the last subtraction above
6616                                                                          ; didn't underflow and the result is correct, so jump to
6617                                                                          ; MV2 as we are done with this particular stage
6618               
6619 2142 0200  20        li   ra,>01*256                 ; LDA #1            ; Otherwise the subtraction above underflowed, as K2 is
     2144 0100     
6620                      .sbc @INWK+3,ra                 ; SBC INWK+3        ; the dominant part of the subtraction, so we need to
     **** ****     > SBC
0001 2146 1801  14        joc  !
0002 2148 7004  18        sb   rone,ra
0003               !:
0004 214A 7020  30        sb   @INWK+3,ra
     214C 0056     
                   < elite.a99
6621 214E D800  30        movb ra,@INWK+3                 ; STA INWK+3        ; negate the result using two's complement, starting
     2150 0056     
6622                                                                          ; with the low bytes:
6623                                                                          ;
6624                                                                          ; y_lo = 1 - y_lo
6625               
6626 2152 0200  20        li   ra,>00*256                 ; LDA #0            ; And then the high bytes:
     2154 0000     
6627                      .sbc @INWK+4,ra                 ; SBC INWK+4        ;
     **** ****     > SBC
0001 2156 1801  14        joc  !
0002 2158 7004  18        sb   rone,ra
0003               !:
0004 215A 7020  30        sb   @INWK+4,ra
     215C 0057     
                   < elite.a99
6628 215E D800  30        movb ra,@INWK+4                 ; STA INWK+4        ; y_hi = 0 - y_hi
     2160 0057     
6629               
6630 2162 0200  20        li   ra,>00*256                 ; LDA #0            ; And finally the sign bytes:
     2164 0000     
6631                      .sbc @P,ra                      ; SBC P             ;
     **** ****     > SBC
0001 2166 1801  14        joc  !
0002 2168 7004  18        sb   rone,ra
0003               !:
0004 216A 7020  30        sb   @P,ra
     216C 001B     
                   < elite.a99
6632                                                                          ; A = 0 - P
6633               
6634 216E 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now force the sign bit to be negative, so that the
     2170 8000     
6635                                                                          ; final result below gets the opposite sign to K, which
6636                                                                          ; we want as K2 is the dominant part of the sum
6637               
6638               MV2:
6639                      .eor @T                         ; EOR T             ; T contains the sign bit of K, so if K is negative,
     **** ****     > EOR
0001 2172 D1A0  30        movb @T,rtmp
     2174 00D1     
0002 2176 2806  18        xor  rtmp,ra
                   < elite.a99
6640                                                                          ; this flips the sign of A
6641               
6642 2178 D800  30        movb ra,@INWK+5                 ; STA INWK+5        ; Store A in y_sign
     217A 0058     
6643               
6644                                                                          ; So we now have result 3 above:
6645                                                                          ;
6646                                                                          ; y = K2 + K
6647                                                                          ; = K2 - beta * z
6648               
6649 217C D020  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set A = alpha
     217E 009E     
6650 2180 D800  30        movb ra,@Q                      ; STA Q
     2182 0090     
6651               
6652 2184 D020  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P(1 0) = (y_hi y_lo)
     2186 0056     
6653 2188 D800  30        movb ra,@P                      ; STA P
     218A 001B     
6654 218C D020  30        movb @INWK+4,ra                 ; LDA INWK+4
     218E 0057     
6655 2190 D800  30        movb ra,@P+1                    ; STA P+1
     2192 001C     
6656               
6657 2194 D020  30        movb @INWK+5,ra                 ; LDA INWK+5        ; Set A = y_sign
     2196 0058     
6658               
6659 2198 0206  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     219A 4148     
6660 219C 06A0  32        bl   @jsr                       ;
     219E FF10     
6661                                                                          ; = (y_sign y_hi y_lo) * alpha
6662                                                                          ; = y * alpha
6663               
6664 21A0 0201  20        li   rx,>00*256                 ; LDX #0            ; Set K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
     21A2 0000     
6665 21A4 0206  20        li   rtmp,MVT3                  ; JSR MVT3          ; = x + y * alpha / 256
     21A6 1C88     
6666 21A8 06A0  32        bl   @jsr                       ;
     21AA FF10     
6667               
6668 21AC D020  30        movb @K+1,ra                    ; LDA K+1           ; Set (x_sign x_hi x_lo) = K(3 2 1)
     21AE 003E     
6669 21B0 D800  30        movb ra,@INWK                   ; STA INWK          ; = x + y * alpha / 256
     21B2 0053     
6670 21B4 D020  30        movb @K+2,ra                    ; LDA K+2
     21B6 003F     
6671 21B8 D800  30        movb ra,@INWK+1                 ; STA INWK+1
     21BA 0054     
6672 21BC D020  30        movb @K+3,ra                    ; LDA K+3
     21BE 0040     
6673 21C0 D800  30        movb ra,@INWK+2                 ; STA INWK+2
     21C2 0055     
6674               
6675                                                                          ; So we now have result 4 above:
6676                                                                          ;
6677                                                                          ; x = x + y * alpha
6678               
6679 21C4 0460  24        b    @MV45                      ; JMP MV45          ; We have now finished rotating the planet or sun by
     21C6 1A7A     
6680                                                                          ; our pitch and roll, so jump back into the MVEIT
6681                                                                          ; routine at MV45 to apply all the other movements
6682               
6683               * ******************************************************************************
6684               *
6685               * Save ELTA.bin
6686               *
6687               * ******************************************************************************
6688               
6689                      ; PRINT "ELITE A"
6690                      ; PRINT "Assembled at ", ~CODE%
6691                      ; PRINT "Ends at ", ~P%
6692                      ; PRINT "Code size is ", ~(P% - CODE%)
6693                      ; PRINT "Execute at ", ~LOAD%
6694                      ; PRINT "Reload at ", ~LOAD_A%
6695               
6696                      ; PRINT "S.ELTA ", ~CODE%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_A%
6697                      ; SAVE "3-assembled-output/ELTA.bin", CODE%, P%, LOAD%
6698               
6699               * ******************************************************************************
6700               *
6701               * ELITE B FILE
6702               *
6703               * Produces the binary file ELTB.bin that gets loaded by elite-bcfs.asm.
6704               *
6705               * ******************************************************************************
6706               
6707               CODE_B.:
6708                      equ $
6709               
6710               LOAD_B.:
6711                      equ LOAD. + $ - CODE.
6712               
6713               * ******************************************************************************
6714               *
6715               * Name: NA%
6716               * Type: Variable
6717               * Category: Save and load
6718               * Summary: The data block for the last saved commander
6719               * Deep dive: Commander save files
6720               * The competition code
6721               *
6722               * ------------------------------------------------------------------------------
6723               *
6724               * Contains the last saved commander data, with the name at NA% and the data at
6725               * NA%+8 onwards. The size of the data block is given in NT% (which also includes
6726               * the two checksum bytes that follow this block). This block is initially set up
6727               * with the default commander, which can be maxed out for testing purposes by
6728               * setting Q% to TRUE.
6729               *
6730               * The commander's name is stored at NA%, and can be up to 7 characters long
6731               * (the DFS filename limit). It is terminated with a carriage return character,
6732               * ASCII 13.
6733               *
6734               * The offset of each byte within a saved commander file is also shown as #0, #1
6735               * and so on, so the kill tally, for example, is in bytes #71 and #72 of the
6736               * saved file. The related variable name from the current commander block is
6737               * also shown.
6738               *
6739               * ******************************************************************************
6740               
6741               NA.:
6742 21C8 4A41            text 'JAMESON'                                      ; The current commander name, which defaults to JAMESON
     21CA 4D45     
     21CC 534F     
     21CE 4E       
6743 21CF   0D            byte >0d                                            ;
6744                                                                          ; The commander name can be up to 7 characters (the DFS
6745                                                                          ; limit for filenames), and is terminated by a carriage
6746                                                                          ; return
6747               
6748                                                                          ; NA%+8 is the start of the commander data block
6749                                                                          ;
6750                                                                          ; This block contains the last saved commander data
6751                                                                          ; block. As the game is played it uses an identical
6752                                                                          ; block at location TP to store the current commander
6753                                                                          ; state, and that block is copied here when the game is
6754                                                                          ; saved. Conversely, when the game starts up, the block
6755                                                                          ; here is copied to TP, which restores the last saved
6756                                                                          ; commander when we die
6757                                                                          ;
6758                                                                          ; The initial state of this block defines the default
6759                                                                          ; commander. Q% can be set to TRUE to give the default
6760                                                                          ; commander lots of credits and equipment
6761               
6762 21D0 00              byte >00                                            ; TP = Mission status, #0
6763               
6764 21D1   14            byte >14                                            ; QQ0 = Current system X-coordinate (Lave), #1
6765 21D2 AD              byte >ad                                            ; QQ1 = Current system Y-coordinate (Lave), #2
6766               
6767 21D4 4A5A            data >4a5a                                          ; QQ21 = Seed s0 for system 0, galaxy 0 (Tibedied), #3-4
6768 21D6 4802            data >4802                                          ; QQ21 = Seed s1 for system 0, galaxy 0 (Tibedied), #5-6
6769 21D8 53B7            data >53b7                                          ; QQ21 = Seed s2 for system 0, galaxy 0 (Tibedied), #7-8
6770               
6774 21DA 0000            data >0000, >0000                                   ; CASH = Amount of cash (100 Cr), #9-12
     21DC 0000     
6776               
6777 21DE 46              byte >46                                            ; QQ14 = Fuel level, #13
6778               
6779 21DF   00            byte >00                                            ; COK = Competition flags, #14
6780               
6781 21E0 00              byte >00                                            ; GCNT = Galaxy number, 0-7, #15
6782               
6783 21E1   0F            byte POW+(128 & Q.)                                 ; LASER = Front laser, #16
6784               
6785 21E2 00              byte (POW+128) & Q.                                 ; LASER+1 = Rear laser, #17
6786               
6787 21E3   00            byte >00                                            ; LASER+2 = Left laser, #18
6788               
6789 21E4 00              byte >00                                            ; LASER+3 = Right laser, #19
6790               
6791 21E6 0000            data >0000                                          ; These bytes appear to be unused (they were originally
6792                                                                          ; used for up/down lasers, but they were dropped),
6793                                                                          ; #20-21
6794               
6795 21E8 16              byte 22 + (15 & Q.)                                 ; CRGO = Cargo capacity, #22
6796               
6797 21E9   00            byte >00                                            ; QQ20+0  = Amount of food in cargo hold, #23
6798 21EA 00              byte >00                                            ; QQ20+1  = Amount of textiles in cargo hold, #24
6799 21EB   00            byte >00                                            ; QQ20+2  = Amount of radioactives in cargo hold, #25
6800 21EC 00              byte >00                                            ; QQ20+3  = Amount of slaves in cargo hold, #26
6801 21ED   00            byte >00                                            ; QQ20+4  = Amount of liquor/Wines in cargo hold, #27
6802 21EE 00              byte >00                                            ; QQ20+5  = Amount of luxuries in cargo hold, #28
6803 21EF   00            byte >00                                            ; QQ20+6  = Amount of narcotics in cargo hold, #29
6804 21F0 00              byte >00                                            ; QQ20+7  = Amount of computers in cargo hold, #30
6805 21F1   00            byte >00                                            ; QQ20+8  = Amount of machinery in cargo hold, #31
6806 21F2 00              byte >00                                            ; QQ20+9  = Amount of alloys in cargo hold, #32
6807 21F3   00            byte >00                                            ; QQ20+10 = Amount of firearms in cargo hold, #33
6808 21F4 00              byte >00                                            ; QQ20+11 = Amount of furs in cargo hold, #34
6809 21F5   00            byte >00                                            ; QQ20+12 = Amount of minerals in cargo hold, #35
6810 21F6 00              byte >00                                            ; QQ20+13 = Amount of gold in cargo hold, #36
6811 21F7   00            byte >00                                            ; QQ20+14 = Amount of platinum in cargo hold, #37
6812 21F8 00              byte >00                                            ; QQ20+15 = Amount of gem-stones in cargo hold, #38
6813 21F9   00            byte >00                                            ; QQ20+16 = Amount of alien items in cargo hold, #39
6814               
6815 21FA 00              byte Q.                                             ; ECM = E.C.M. system, #40
6816               
6817 21FB   00            byte Q.                                             ; BST = Fuel scoops ("barrel status"), #41
6818               
6819 21FC 00              byte Q. & 127                                       ; BOMB = Energy bomb, #42
6820               
6821 21FD   00            byte Q. & 1                                         ; ENGY = Energy/shield level, #43
6822               
6823 21FE 00              byte Q.                                             ; DKCMP = Docking computer, #44
6824               
6825 21FF   00            byte Q.                                             ; GHYP = Galactic hyperdrive, #45
6826               
6827 2200 00              byte Q.                                             ; ESCP = Escape pod, #46
6828               
6829 2202 0000            data >0000, >0000                                   ; These four bytes appear to be unused, #47-50
     2204 0000     
6830               
6831 2206 03              byte 3 + (Q. & 1)                                   ; NOMSL = Number of missiles, #51
6832               
6833 2207   00            byte >00                                            ; FIST = Legal status ("fugitive/innocent status"), #52
6834               
6835 2208 10              byte >10                                            ; AVL+0  = Market availability of food, #53
6836 2209   0F            byte >0f                                            ; AVL+1  = Market availability of textiles, #54
6837 220A 11              byte >11                                            ; AVL+2  = Market availability of radioactives, #55
6838 220B   00            byte >00                                            ; AVL+3  = Market availability of slaves, #56
6839 220C 03              byte >03                                            ; AVL+4  = Market availability of liquor/Wines, #57
6840 220D   1C            byte >1c                                            ; AVL+5  = Market availability of luxuries, #58
6841 220E 0E              byte >0e                                            ; AVL+6  = Market availability of narcotics, #59
6842 220F   00            byte >00                                            ; AVL+7  = Market availability of computers, #60
6843 2210 00              byte >00                                            ; AVL+8  = Market availability of machinery, #61
6844 2211   0A            byte >0a                                            ; AVL+9  = Market availability of alloys, #62
6845 2212 00              byte >00                                            ; AVL+10 = Market availability of firearms, #63
6846 2213   11            byte >11                                            ; AVL+11 = Market availability of furs, #64
6847 2214 3A              byte >3a                                            ; AVL+12 = Market availability of minerals, #65
6848 2215   07            byte >07                                            ; AVL+13 = Market availability of gold, #66
6849 2216 09              byte >09                                            ; AVL+14 = Market availability of platinum, #67
6850 2217   08            byte >08                                            ; AVL+15 = Market availability of gem-stones, #68
6851 2218 00              byte >00                                            ; AVL+16 = Market availability of alien items, #69
6852               
6853 2219   00            byte >00                                            ; QQ26 = Random byte that changes for each visit to a
6854                                                                          ; system, for randomising market prices, #70
6855               
6856 221A 0000            data >0000                                          ; TALLY = Number of kills, #71-72
6857               
6858 221C 80              byte >80                                            ; SVC = Save count, #73
6859               
6860               * ******************************************************************************
6861               *
6862               * Name: CHK2
6863               * Type: Variable
6864               * Category: Save and load
6865               * Summary: Second checksum byte for the saved commander data file
6866               * Deep dive: Commander save files
6867               * The competition code
6868               *
6869               * ------------------------------------------------------------------------------
6870               *
6871               * Second commander checksum byte. If the default commander is changed, a new
6872               * checksum will be calculated and inserted by the elite-checksum.py script.
6873               *
6874               * The offset of this byte within a saved commander file is also shown (it's at
6875               * byte #74).
6876               *
6877               * ******************************************************************************
6878               
6879               CHK2:
6880 221D   AA            byte >03 ^ >A9                                      ; The checksum value for the default commander, EOR'd
6881                                                                          ; with &A9 to make it harder to tamper with the checksum
6882                                                                          ; byte, #74
6883               
6884               * ******************************************************************************
6885               *
6886               * Name: CHK
6887               * Type: Variable
6888               * Category: Save and load
6889               * Summary: First checksum byte for the saved commander data file
6890               * Deep dive: Commander save files
6891               * The competition code
6892               *
6893               * ------------------------------------------------------------------------------
6894               *
6895               * Commander checksum byte. If the default commander is changed, a new checksum
6896               * will be calculated and inserted by the elite-checksum.py script.
6897               *
6898               * The offset of this byte within a saved commander file is also shown (it's at
6899               * byte #75).
6900               *
6901               * ******************************************************************************
6902               
6903               CHK:
6904 221E 03              byte >03                                            ; The checksum value for the default commander, #75
6905               
6906               * ******************************************************************************
6907               *
6908               * Name: UNIV
6909               * Type: Variable
6910               * Category: Universe
6911               * Summary: Table of pointers to the local universe's ship data blocks
6912               * Deep dive: The local bubble of universe
6913               *
6914               * ------------------------------------------------------------------------------
6915               *
6916               * See the deep dive on "Ship data blocks" for details on ship data blocks, and
6917               * the deep dive on "The local bubble of universe" for details of how Elite
6918               * stores the local universe in K%, FRIN and UNIV.
6919               *
6920               * ******************************************************************************
6921               
6922               UNIV:
6923                      ; FOR I%, 0, NOSH
6924               
6925                      ; EQUW K% + I% * NI%            ;                   ; Address of block no. I%, of size NI%, in workspace K%
6926               
6927                      ; NEXT
6928               
6929 221F   00            byte (K. + 0 * NI.) % 256, (K. + 0 * NI.) / 256
     2220 44       
6930 2221   24            byte (K. + 1 * NI.) % 256, (K. + 1 * NI.) / 256
     2222 44       
6931 2223   48            byte (K. + 2 * NI.) % 256, (K. + 2 * NI.) / 256
     2224 44       
6932 2225   6C            byte (K. + 3 * NI.) % 256, (K. + 3 * NI.) / 256
     2226 44       
6933 2227   90            byte (K. + 4 * NI.) % 256, (K. + 4 * NI.) / 256
     2228 44       
6934 2229   B4            byte (K. + 5 * NI.) % 256, (K. + 5 * NI.) / 256
     222A 44       
6935 222B   D8            byte (K. + 6 * NI.) % 256, (K. + 6 * NI.) / 256
     222C 44       
6936 222D   FC            byte (K. + 7 * NI.) % 256, (K. + 7 * NI.) / 256
     222E 44       
6937 222F   20            byte (K. + 8 * NI.) % 256, (K. + 8 * NI.) / 256
     2230 45       
6938 2231   44            byte (K. + 9 * NI.) % 256, (K. + 9 * NI.) / 256
     2232 45       
6939 2233   68            byte (K. + 10 * NI.) % 256, (K. + 10 * NI.) / 256
     2234 45       
6940 2235   8C            byte (K. + 11 * NI.) % 256, (K. + 11 * NI.) / 256
     2236 45       
6941 2237   B0            byte (K. + 12 * NI.) % 256, (K. + 12 * NI.) / 256
     2238 45       
6942               
6943               * ******************************************************************************
6944               *
6945               * Name: TWOS
6946               * Type: Variable
6947               * Category: Drawing pixels
6948               * Summary: Ready-made single-pixel character row bytes for mode 4
6949               * Deep dive: Drawing monochrome pixels in mode 4
6950               *
6951               * ------------------------------------------------------------------------------
6952               *
6953               * Ready-made bytes for plotting one-pixel points in mode 4 (the top part of the
6954               * split screen). See the PIXEL routine for details.
6955               *
6956               * ******************************************************************************
6957               
6958               TWOS:
6959 2239   80            byte >80
6960 223A 40              byte >40
6961 223B   20            byte >20
6962 223C 10              byte >10
6963 223D   08            byte >08
6964 223E 04              byte >04
6965 223F   02            byte >02
6966 2240 01              byte >01
6967               
6968               * ******************************************************************************
6969               *
6970               * Name: TWOS2
6971               * Type: Variable
6972               * Category: Drawing pixels
6973               * Summary: Ready-made double-pixel character row bytes for mode 4
6974               * Deep dive: Drawing monochrome pixels in mode 4
6975               *
6976               * ------------------------------------------------------------------------------
6977               *
6978               * Ready-made bytes for plotting two-pixel dashes in mode 4 (the top part of the
6979               * split screen). See the PIXEL routine for details.
6980               *
6981               * ******************************************************************************
6982               
6983               TWOS2:
6984 2241   C0            byte >c0
6985 2242 60              byte >60
6986 2243   30            byte >30
6987 2244 18              byte >18
6988 2245   0C            byte >0c
6989 2246 06              byte >06
6990 2247   03            byte >03
6991 2248 03              byte >03
6992               
6993               * ******************************************************************************
6994               *
6995               * Name: CTWOS
6996               * Type: Variable
6997               * Category: Drawing pixels
6998               * Summary: Ready-made single-pixel character row bytes for mode 5
6999               * Deep dive: Drawing colour pixels in mode 5
7000               *
7001               * ------------------------------------------------------------------------------
7002               *
7003               * Ready-made bytes for plotting one-pixel points in mode 5 (the bottom part of
7004               * the split screen). See the dashboard routines SCAN, DIL2 and CPIX2 for
7005               * details.
7006               *
7007               * There is one extra row to support the use of CTWOS+1,X indexing in the CPIX2
7008               * routine. The extra row is a repeat of the first row, and saves us from having
7009               * to work out whether CTWOS+1+X needs to be wrapped around when drawing a
7010               * two-pixel dash that crosses from one character block into another. See CPIX2
7011               * for more details.
7012               *
7013               * ******************************************************************************
7014               
7015               CTWOS:
7016 2249   88            byte >88
7017 224A 44              byte >44
7018 224B   22            byte >22
7019 224C 11              byte >11
7020 224D   88            byte >88
7021               
7022               * ******************************************************************************
7023               *
7024               * Name: LOIN (Part 1 of 7)
7025               * Type: Subroutine
7026               * Category: Drawing lines
7027               * Summary: Draw a line: Calculate the line gradient in the form of deltas
7028               * Deep dive: Bresenham's line algorithm
7029               *
7030               * ------------------------------------------------------------------------------
7031               *
7032               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7033               * This stage calculates the line deltas.
7034               *
7035               * ------------------------------------------------------------------------------
7036               *
7037               * Arguments:
7038               *
7039               * X1                  The screen x-coordinate of the start of the line
7040               *
7041               * Y1                  The screen y-coordinate of the start of the line
7042               *
7043               * X2                  The screen x-coordinate of the end of the line
7044               *
7045               * Y2                  The screen y-coordinate of the end of the line
7046               *
7047               * ------------------------------------------------------------------------------
7048               *
7049               * Returns:
7050               *
7051               * Y                   Y is preserved
7052               *
7053               * ------------------------------------------------------------------------------
7054               *
7055               * Other entry points:
7056               *
7057               * LL30                LL30 is a synonym for LOIN and draws a line from
7058               * (X1, Y1) to (X2, Y2)
7059               *
7060               * ******************************************************************************
7061               
7062               LL30:
7063 224E                 bss 0                                               ; LL30 is a synonym for LOIN
7064                                                                          ;
7065                                                                          ; In the cassette and disc versions of Elite, LL30 and
7066                                                                          ; LOIN are synonyms for the same routine, presumably
7067                                                                          ; because the two developers each had their own line
7068                                                                          ; routines to start with, and then chose one of them for
7069                                                                          ; the final game
7070               
7071               LOIN:
7072 224E D802  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y into YSAV, so we can preserve it across the
     2250 0094     
7073                                                                          ; call to this subroutine
7074               
7075 2252 0200  20        li   ra,>80*256                 ; LDA #128          ; Set S = 128, which is the starting point for the
     2254 8000     
7076 2256 D800  30        movb ra,@S                      ; STA S             ; slope error (representing half a pixel)
     2258 0092     
7077               
7078                      .asla                           ; ASL A             ; Set SWAP = 0, as %10000000 << 1 = 0
     **** ****     > ASLA
0001 225A 0240  22        andi ra,>ff00
     225C FF00     
0002 225E 0A10  18        sla  ra,1
                   < elite.a99
7079 2260 D800  30        movb ra,@SWAP                   ; STA SWAP
     2262 00A1     
7080               
7081 2264 D020  30        movb @X2,ra                     ; LDA X2            ; Set A = X2 - X1
     2266 0033     
7082                      .sbc @X1,ra                     ; SBC X1            ; = delta_x
     **** ****     > SBC
0001 2268 1801  14        joc  !
0002 226A 7004  18        sb   rone,ra
0003               !:
0004 226C 7020  30        sb   @X1,ra
     226E 0031     
                   < elite.a99
7083                                                                          ;
7084                                                                          ; This subtraction works as the ASL A above sets the C
7085                                                                          ; flag
7086               
7087 2270 1808  14        joc  LI1                        ; BCS LI1           ; If X2 > X1 then A is already positive and we can skip
7088                                                                          ; the next three instructions
7089               
7090                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A by flipping all the bits and
     **** ****     > EOI
0001 2272 0206  20        li   rtmp,(>FF*256)
     2274 FF00     
0002 2276 2806  18        xor  rtmp,ra
                   < elite.a99
7091                      .adi (>01*256)                  ; ADC #1            ; adding 1, i.e. using two's complement to make it
     **** ****     > ADI
0001 2278 1701  14        jnc  !
0002 227A B004  18        ab   rone,ra
0003               !:
0004 227C 0220  22        ai   ra,(>01*256)
     227E 0100     
                   < elite.a99
7092                                                                          ; positive
7093               
7094                      .sec                            ; SEC               ; Set the C flag, ready for the subtraction below
     **** ****     > SEC
0001 2280 0A15  18        sla  rmone,1
                   < elite.a99
7095               
7096               LI1:
7097 2282 D800  30        movb ra,@P                      ; STA P             ; Store A in P, so P = |X2 - X1|, or |delta_x|
     2284 001B     
7098               
7099 2286 D020  30        movb @Y2,ra                     ; LDA Y2            ; Set A = Y2 - Y1
     2288 0034     
7100                      .sbc @Y1,ra                     ; SBC Y1            ; = delta_y
     **** ****     > SBC
0001 228A 1801  14        joc  !
0002 228C 7004  18        sb   rone,ra
0003               !:
0004 228E 7020  30        sb   @Y1,ra
     2290 0032     
                   < elite.a99
7101                                                                          ;
7102                                                                          ; This subtraction works as we either set the C flag
7103                                                                          ; above, or we skipped that SEC instruction with a BCS
7104               
7105 2292 1807  14        joc  LI2                        ; BCS LI2           ; If Y2 > Y1 then A is already positive and we can skip
7106                                                                          ; the next two instructions
7107               
7108                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A by flipping all the bits and
     **** ****     > EOI
0001 2294 0206  20        li   rtmp,(>FF*256)
     2296 FF00     
0002 2298 2806  18        xor  rtmp,ra
                   < elite.a99
7109                      .adi (>01*256)                  ; ADC #1            ; adding 1, i.e. using two's complement to make it
     **** ****     > ADI
0001 229A 1701  14        jnc  !
0002 229C B004  18        ab   rone,ra
0003               !:
0004 229E 0220  22        ai   ra,(>01*256)
     22A0 0100     
                   < elite.a99
7110                                                                          ; positive
7111               
7112               LI2:
7113 22A2 D800  30        movb ra,@Q                      ; STA Q             ; Store A in Q, so Q = |Y2 - Y1|, or |delta_y|
     22A4 0090     
7114               
7115 22A6 9020  30        cb   @P,ra                      ; CMP P             ; If Q < P, jump to STPX to step along the x-axis, as
     22A8 001B     
7116 22AA 1702  14        jnc  STPX                       ; BCC STPX          ; the line is closer to being horizontal than vertical
7117               
7118 22AC 0460  28        b    @STPY                      ; JMP STPY          ; Otherwise Q >= P so jump to STPY to step along the
     22AE 242E     
7119                                                                          ; y-axis, as the line is closer to being vertical than
7120                                                                          ; horizontal
7121               
7122               * ******************************************************************************
7123               *
7124               * Name: LOIN (Part 2 of 7)
7125               * Type: Subroutine
7126               * Category: Drawing lines
7127               * Summary: Draw a line: Line has a shallow gradient, step right along x-axis
7128               * Deep dive: Bresenham's line algorithm
7129               *
7130               * ------------------------------------------------------------------------------
7131               *
7132               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7133               * If we get here, then:
7134               *
7135               * * |delta_y| < |delta_x|
7136               *
7137               * * The line is closer to being horizontal than vertical
7138               *
7139               * * We are going to step right along the x-axis
7140               *
7141               * * We potentially swap coordinates to make sure X1 < X2
7142               *
7143               * ******************************************************************************
7144               
7145               STPX:
7146 22B0 D060  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     22B2 0031     
7147               
7148 22B4 9060  30        cb   @X2,rx                     ; CPX X2            ; If X1 < X2, jump down to LI3, as the coordinates are
     22B6 0033     
7149 22B8 1710  14        jnc  LI3                        ; BCC LI3           ; already in the order that we want
7150               
7151 22BA 7004  18        sb   rone,ra                    ; DEC SWAP          ; Otherwise decrement SWAP from 0 to &FF, to denote that
7152                                                                          ; we are swapping the coordinates around
7153               
7154 22BC D020  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2
     22BE 0033     
7155 22C0 D800  30        movb ra,@X1                     ; STA X1
     22C2 0031     
7156 22C4 D801  30        movb rx,@X2                     ; STX X2
     22C6 0033     
7157               
7158 22C8 D040  18        movb ra,rx                      ; TAX               ; Set X = X1
7159               
7160 22CA D020  30        movb @Y2,ra                     ; LDA Y2            ; Swap the values of Y1 and Y2
     22CC 0034     
7161 22CE D0A0  30        movb @Y1,ry                     ; LDY Y1
     22D0 0032     
7162 22D2 D800  30        movb ra,@Y1                     ; STA Y1
     22D4 0032     
7163 22D6 D802  30        movb ry,@Y2                     ; STY Y2
     22D8 0034     
7164               
7165               LI3:
7166                                                                          ; By this point we know the line is horizontal-ish and
7167                                                                          ; X1 < X2, so we're going from left to right as we go
7168                                                                          ; from X1 to X2
7169 22DA D020  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 / 8, so A now contains the character row
     22DC 0032     
7170 22DE 0910  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7171 22E0 0910  18        srl  ra,1                       ; LSR A
7172 22E2 0910  18        srl  ra,1                       ; LSR A
7173               
7174 22E4 0260  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     22E6 6000     
7175                                                                          ; us the screen address of the character row (as each
7176                                                                          ; character row takes up 256 bytes, and the first
7177                                                                          ; character row is at screen address &6000, or page &60)
7178               
7179 22E8 D800  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     22EA 0008     
7180                                                                          ; the high byte of SC is set correctly for drawing the
7181                                                                          ; start of our line
7182               
7183 22EC D020  30        movb @Y1,ra                     ; LDA Y1            ; Set Y = Y1 mod 8, which is the pixel row within the
     22EE 0032     
7184 22F0 0240  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw the start of
     22F2 0700     
7185 22F4 D080  18        movb ra,ry                      ; TAY               ; our line (as each character block has 8 rows)
7186               
7187 22F6 D001  18        movb rx,ra                      ; TXA               ; Set A = bits 3-7 of X1
7188 22F8 0240  22        andi ra,>f8*256                 ; AND #%11111000
     22FA F800     
7189               
7190 22FC D800  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     22FE 0007     
7191                                                                          ; screen address of the far left end (x-coordinate = 0)
7192                                                                          ; of the horizontal pixel row that we want to draw the
7193                                                                          ; start of our line on
7194               
7195 2300 D001  18        movb rx,ra                      ; TXA               ; Set X = X1 mod 8, which is the horizontal pixel number
7196 2302 0240  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     2304 0700     
7197 2306 D040  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
7198                                                                          ; wide)
7199               
7200 2308 D021  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS where pixel X is set,
     230A 2239     
7201 230C D800  30        movb ra,@R                      ; STA R             ; and store it in R
     230E 0091     
7202               
7203                                                                          ; The following calculates:
7204                                                                          ;
7205                                                                          ; Q = Q / P
7206                                                                          ; = |delta_y| / |delta_x|
7207                                                                          ;
7208                                                                          ; using the same shift-and-subtract algorithm that's
7209                                                                          ; documented in TIS2
7210               
7211 2310 D020  30        movb @Q,ra                      ; LDA Q             ; Set A = |delta_y|
     2312 0090     
7212               
7213 2314 0201  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set Q to have bits 1-7 set, so we can rotate through 7
     2316 FE00     
7214 2318 D801  30        movb rx,@Q                      ; STX Q             ; loop iterations, getting a 1 each time, and then
     231A 0090     
7215                                                                          ; getting a 0 on the 8th iteration... and we can also
7216                                                                          ; use Q to catch our result bits into bit 0 each time
7217               
7218               LIL1:
7219                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 231C 0240  22        andi ra,>ff00
     231E FF00     
0002 2320 0A10  18        sla  ra,1
                   < elite.a99
7220               
7221 2322 1803  14        joc  LI4                        ; BCS LI4           ; If bit 7 of A was set, then jump straight to the
7222                                                                          ; subtraction
7223               
7224 2324 9020  30        cb   @P,ra                      ; CMP P             ; If A < P, skip the following subtraction
     2326 001B     
7225 2328 1705  14        jnc  LI5                        ; BCC LI5
7226               
7227               LI4:
7228                      .sbc @P,ra                      ; SBC P             ; A >= P, so set A = A - P
     **** ****     > SBC
0001 232A 1801  14        joc  !
0002 232C 7004  18        sb   rone,ra
0003               !:
0004 232E 7020  30        sb   @P,ra
     2330 001B     
                   < elite.a99
7229               
7230                      .sec                            ; SEC               ; Set the C flag to rotate into the result in Q
     **** ****     > SEC
0001 2332 0A15  18        sla  rmone,1
                   < elite.a99
7231               
7232               LI5:
7233 2334 0208  20        li   rarg1,Q                    ; ROL Q             ; Rotate the counter in Q to the left, and catch the
     2336 0090     
7234 2338 06A0  32        bl   @rol                       ;
     233A FF36     
7235                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
7236                                                                          ; do the subtraction, or 1 if we did)
7237               
7238 233C 18EF  14        joc  LIL1                       ; BCS LIL1          ; If we still have set bits in Q, loop back to TIL2 to
7239                                                                          ; do the next iteration of 7
7240               
7241                                                                          ; We now have:
7242                                                                          ;
7243                                                                          ; Q = A / P
7244                                                                          ; = |delta_y| / |delta_x|
7245                                                                          ;
7246                                                                          ; and the C flag is clear
7247               
7248 233E D060  30        movb @P,rx                      ; LDX P             ; Set X = P + 1
     2340 001B     
7249 2342 B044  18        ab   rone,rx                    ; INX               ; = |delta_x| + 1
7250                                                                          ;
7251                                                                          ; We add 1 so we can skip the first pixel plot if the
7252                                                                          ; line is being drawn with swapped coordinates
7253               
7254 2344 D020  30        movb @Y2,ra                     ; LDA Y2            ; Set A = Y2 - Y1 - 1 (as the C flag is clear following
     2346 0034     
7255                      .sbc @Y1,ra                     ; SBC Y1            ; the above division)
     **** ****     > SBC
0001 2348 1801  14        joc  !
0002 234A 7004  18        sb   rone,ra
0003               !:
0004 234C 7020  30        sb   @Y1,ra
     234E 0032     
                   < elite.a99
7256               
7257 2350 1836  14        joc  DOWN                       ; BCS DOWN          ; If Y2 >= Y1 - 1 then jump to DOWN, as we need to draw
7258                                                                          ; the line to the right and down
7259               
7260               * ******************************************************************************
7261               *
7262               * Name: LOIN (Part 3 of 7)
7263               * Type: Subroutine
7264               * Category: Drawing lines
7265               * Summary: Draw a shallow line going right and up or left and down
7266               * Deep dive: Bresenham's line algorithm
7267               *
7268               * ------------------------------------------------------------------------------
7269               *
7270               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7271               * If we get here, then:
7272               *
7273               * * The line is going right and up (no swap) or left and down (swap)
7274               *
7275               * * X1 < X2 and Y1-1 > Y2
7276               *
7277               * * Draw from (X1, Y1) at bottom left to (X2, Y2) at top right, omitting the
7278               * first pixel
7279               *
7280               * ******************************************************************************
7281               
7282 2352 D020  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP > 0 then we swapped the coordinates above, so
     2354 00A1     
7283 2356 160D  14        jne  LI6                        ; BNE LI6           ; jump down to LI6 to skip plotting the first pixel
7284                                                                          ;
7285                                                                          ; This appears to be a bug that omits the last pixel
7286                                                                          ; of this type of shallow line, rather than the first
7287                                                                          ; pixel, which makes the treatment of this kind of line
7288                                                                          ; different to the other kinds of slope (they all have a
7289                                                                          ; BEQ instruction at this point, rather than a BNE)
7290                                                                          ;
7291                                                                          ; The result is a rather messy line join when a shallow
7292                                                                          ; line that goes right and up or left and down joins a
7293                                                                          ; line with any of the other three types of slope
7294                                                                          ;
7295                                                                          ; This bug was fixed in the advanced versions of Elite,
7296                                                                          ; where the BNE is replaced by a BEQ to bring it in line
7297                                                                          ; with the other three slopes
7298               
7299 2358 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7300                                                                          ; the first pixel
7301               
7302               LIL2:
7303                                                                          ; We now loop along the line from left to right, using X
7304                                                                          ; as a decreasing counter, and at each count we plot a
7305                                                                          ; single pixel using the pixel mask in R
7306 235A D020  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     235C 0091     
7307               
7308                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 235E D1A0  30        movb @SC,rtmp
     2360 0007     
0002 2362 2806  18        xor  rtmp,ra
                   < elite.a99
7309                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 2364 D820  50        movb @SC,@rtmplb
     2366 0007     
     2368 2079     
0002 236A D1A0  30        movb @SC+1,rtmp
     236C 0008     
0003 236E A182  18        a    ry,rtmp
0004 2370 D580  30        movb RA,*rtmp
                   < elite.a99
7310               
7311               LI6:
7312                      .lsr @R                         ; LSR R             ; Shift the single pixel in R to the right to step along
     **** ****     > LSR
0001 2372 D1A0  30        movb @R,rtmp
     2374 0091     
0002 2376 0916  18        srl  rtmp,1
0003 2378 D806  30        movb rtmp,@R
     237A 0091     
                   < elite.a99
7313                                                                          ; the x-axis, so the next pixel we plot will be at the
7314                                                                          ; next x-coordinate along
7315               
7316 237C 170C  14        jnc  LI7                        ; BCC LI7           ; If the pixel didn't fall out of the right end of R
7317                                                                          ; into the C flag, then jump to LI7
7318               
7319 237E 0208  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     2380 0091     
7320 2382 06A0  32        bl   @ror                       ;
     2384 FF62     
7321                                                                          ; block, so first rotate R right so the set C flag goes
7322                                                                          ; back into the left end, giving %10000000
7323               
7324 2386 D020  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     2388 0007     
7325                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 238A 1701  14        jnc  !
0002 238C B004  18        ab   rone,ra
0003               !:
0004 238E 0220  22        ai   ra,(>08*256)
     2390 0800     
                   < elite.a99
7326 2392 D800  30        movb ra,@SC                     ; STA SC
     2394 0007     
7327               
7328               LI7:
7329 2396 D020  30        movb @S,ra                      ; LDA S             ; Set S = S + Q to update the slope error
     2398 0092     
7330                      .adc @Q,ra                      ; ADC Q
     **** ****     > ADC
0001 239A 1701  14        jnc  !
0002 239C B004  18        ab   rone,ra
0003               !:
0004 239E B020  30        ab   @Q,ra
     23A0 0090     
                   < elite.a99
7331 23A2 D800  30        movb ra,@S                      ; STA S
     23A4 0092     
7332               
7333 23A6 1705  14        jnc  LIC2                       ; BCC LIC2          ; If the addition didn't overflow, jump to LIC2
7334               
7335 23A8 7084  18        sb   rone,ry                    ; DEY               ; Otherwise we just overflowed, so decrement Y to move
7336                                                                          ; to the pixel line above
7337               
7338 23AA 1503  14        jgt  LIC2                       ; BPL LIC2          ; If Y is positive we are still within the same
7339                                                                          ; character block, so skip to LIC2
7340               
7341 23AC 7004  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7342 23AE 0202  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     23B0 0700     
7343                                                                          ; address and set the pixel line to the last line in
7344                                                                          ; that character block
7345               
7346               LIC2:
7347 23B2 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7348               
7349 23B4 16D2  14        jne  LIL2                       ; BNE LIL2          ; If we haven't yet reached the right end of the line,
7350                                                                          ; loop back to LIL2 to plot the next pixel along
7351               
7352 23B6 D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     23B8 0094     
7353               
7354 23BA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     23BC FF1C     
7355               
7356               * ******************************************************************************
7357               *
7358               * Name: LOIN (Part 4 of 7)
7359               * Type: Subroutine
7360               * Category: Drawing lines
7361               * Summary: Draw a shallow line going right and down or left and up
7362               * Deep dive: Bresenham's line algorithm
7363               *
7364               * ------------------------------------------------------------------------------
7365               *
7366               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7367               * If we get here, then:
7368               *
7369               * * The line is going right and down (no swap) or left and up (swap)
7370               *
7371               * * X1 < X2 and Y1-1 <= Y2
7372               *
7373               * * Draw from (X1, Y1) at top left to (X2, Y2) at bottom right, omitting the
7374               * first pixel
7375               *
7376               * ******************************************************************************
7377               
7378               DOWN:
7379 23BE D020  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     23C0 00A1     
7380 23C2 130D  14        jeq  LI9                        ; BEQ LI9           ; so jump down to LI9 to skip plotting the first pixel
7381               
7382 23C4 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7383                                                                          ; the first pixel
7384               
7385               LIL3:
7386                                                                          ; We now loop along the line from left to right, using X
7387                                                                          ; as a decreasing counter, and at each count we plot a
7388                                                                          ; single pixel using the pixel mask in R
7389 23C6 D020  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     23C8 0091     
7390               
7391                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 23CA D1A0  30        movb @SC,rtmp
     23CC 0007     
0002 23CE 2806  18        xor  rtmp,ra
                   < elite.a99
7392                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 23D0 D820  50        movb @SC,@rtmplb
     23D2 0007     
     23D4 2079     
0002 23D6 D1A0  30        movb @SC+1,rtmp
     23D8 0008     
0003 23DA A182  18        a    ry,rtmp
0004 23DC D580  30        movb RA,*rtmp
                   < elite.a99
7393               
7394               LI9:
7395                      .lsr @R                         ; LSR R             ; Shift the single pixel in R to the right to step along
     **** ****     > LSR
0001 23DE D1A0  30        movb @R,rtmp
     23E0 0091     
0002 23E2 0916  18        srl  rtmp,1
0003 23E4 D806  30        movb rtmp,@R
     23E6 0091     
                   < elite.a99
7396                                                                          ; the x-axis, so the next pixel we plot will be at the
7397                                                                          ; next x-coordinate along
7398               
7399 23E8 170C  14        jnc  LI10                       ; BCC LI10          ; If the pixel didn't fall out of the right end of R
7400                                                                          ; into the C flag, then jump to LI10
7401               
7402 23EA 0208  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     23EC 0091     
7403 23EE 06A0  32        bl   @ror                       ;
     23F0 FF62     
7404                                                                          ; block, so first rotate R right so the set C flag goes
7405                                                                          ; back into the left end, giving %10000000
7406               
7407 23F2 D020  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     23F4 0007     
7408                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 23F6 1701  14        jnc  !
0002 23F8 B004  18        ab   rone,ra
0003               !:
0004 23FA 0220  22        ai   ra,(>08*256)
     23FC 0800     
                   < elite.a99
7409 23FE D800  30        movb ra,@SC                     ; STA SC
     2400 0007     
7410               
7411               LI10:
7412 2402 D020  30        movb @S,ra                      ; LDA S             ; Set S = S + Q to update the slope error
     2404 0092     
7413                      .adc @Q,ra                      ; ADC Q
     **** ****     > ADC
0001 2406 1701  14        jnc  !
0002 2408 B004  18        ab   rone,ra
0003               !:
0004 240A B020  30        ab   @Q,ra
     240C 0090     
                   < elite.a99
7414 240E D800  30        movb ra,@S                      ; STA S
     2410 0092     
7415               
7416 2412 1707  14        jnc  LIC3                       ; BCC LIC3          ; If the addition didn't overflow, jump to LIC3
7417               
7418 2414 B084  18        ab   rone,ry                    ; INY               ; Otherwise we just overflowed, so increment Y to move
7419                                                                          ; to the pixel line below
7420               
7421 2416 0282  22        ci   ry,>08*256                 ; CPY #8            ; If Y < 8 we are still within the same character block,
     2418 0800     
7422 241A 1603  14        jne  LIC3                       ; BNE LIC3          ; so skip to LIC3
7423               
7424 241C B004  18        ab   rone,ra                    ; INC SCH           ; Otherwise we need to move down into the character
7425 241E 0202  20        li   ry,>00*256                 ; LDY #0            ; block below, so increment the high byte of the screen
     2420 0000     
7426                                                                          ; address and set the pixel line to the first line in
7427                                                                          ; that character block
7428               
7429               LIC3:
7430 2422 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7431               
7432 2424 16D0  14        jne  LIL3                       ; BNE LIL3          ; If we haven't yet reached the right end of the line,
7433                                                                          ; loop back to LIL3 to plot the next pixel along
7434               
7435 2426 D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2428 0094     
7436               
7437 242A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     242C FF1C     
7438               
7439               * ******************************************************************************
7440               *
7441               * Name: LOIN (Part 5 of 7)
7442               * Type: Subroutine
7443               * Category: Drawing lines
7444               * Summary: Draw a line: Line has a steep gradient, step up along y-axis
7445               * Deep dive: Bresenham's line algorithm
7446               *
7447               * ------------------------------------------------------------------------------
7448               *
7449               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7450               * If we get here, then:
7451               *
7452               * * |delta_y| >= |delta_x|
7453               *
7454               * * The line is closer to being vertical than horizontal
7455               *
7456               * * We are going to step up along the y-axis
7457               *
7458               * * We potentially swap coordinates to make sure Y1 >= Y2
7459               *
7460               * ******************************************************************************
7461               
7462               STPY:
7463 242E D0A0  30        movb @Y1,ry                     ; LDY Y1            ; Set A = Y = Y1
     2430 0032     
7464 2432 D002  18        movb ry,ra                      ; TYA
7465               
7466 2434 D060  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     2436 0031     
7467               
7468 2438 90A0  30        cb   @Y2,ry                     ; CPY Y2            ; If Y1 >= Y2, jump down to LI15, as the coordinates are
     243A 0034     
7469 243C 180F  14        joc  LI15                       ; BCS LI15          ; already in the order that we want
7470               
7471 243E 7004  18        sb   rone,ra                    ; DEC SWAP          ; Otherwise decrement SWAP from 0 to &FF, to denote that
7472                                                                          ; we are swapping the coordinates around
7473               
7474 2440 D020  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2
     2442 0033     
7475 2444 D800  30        movb ra,@X1                     ; STA X1
     2446 0031     
7476 2448 D801  30        movb rx,@X2                     ; STX X2
     244A 0033     
7477               
7478 244C D040  18        movb ra,rx                      ; TAX               ; Set X = X1
7479               
7480 244E D020  30        movb @Y2,ra                     ; LDA Y2            ; Swap the values of Y1 and Y2
     2450 0034     
7481 2452 D800  30        movb ra,@Y1                     ; STA Y1
     2454 0032     
7482 2456 D802  30        movb ry,@Y2                     ; STY Y2
     2458 0034     
7483               
7484 245A D080  18        movb ra,ry                      ; TAY               ; Set Y = A = Y1
7485               
7486               LI15:
7487                                                                          ; By this point we know the line is vertical-ish and
7488                                                                          ; Y1 >= Y2, so we're going from top to bottom as we go
7489                                                                          ; from Y1 to Y2
7490 245C 0910  18        srl  ra,1                       ; LSR A             ; Set A = Y1 / 8, so A now contains the character row
7491 245E 0910  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7492 2460 0910  18        srl  ra,1                       ; LSR A
7493               
7494 2462 0260  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     2464 6000     
7495                                                                          ; us the screen address of the character row (as each
7496                                                                          ; character row takes up 256 bytes, and the first
7497                                                                          ; character row is at screen address &6000, or page &60)
7498               
7499 2466 D800  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     2468 0008     
7500                                                                          ; the high byte of SC is set correctly for drawing the
7501                                                                          ; start of our line
7502               
7503 246A D001  18        movb rx,ra                      ; TXA               ; Set A = bits 3-7 of X1
7504 246C 0240  22        andi ra,>f8*256                 ; AND #%11111000
     246E F800     
7505               
7506 2470 D800  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     2472 0007     
7507                                                                          ; screen address of the far left end (x-coordinate = 0)
7508                                                                          ; of the horizontal pixel row that we want to draw the
7509                                                                          ; start of our line on
7510               
7511 2474 D001  18        movb rx,ra                      ; TXA               ; Set X = X1 mod 8, which is the horizontal pixel number
7512 2476 0240  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     2478 0700     
7513 247A D040  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
7514                                                                          ; wide)
7515               
7516 247C D021  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS where pixel X is set,
     247E 2239     
7517 2480 D800  30        movb ra,@R                      ; STA R             ; and store it in R
     2482 0091     
7518               
7519 2484 D020  30        movb @Y1,ra                     ; LDA Y1            ; Set Y = Y1 mod 8, which is the pixel row within the
     2486 0032     
7520 2488 0240  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw the start of
     248A 0700     
7521 248C D080  18        movb ra,ry                      ; TAY               ; our line (as each character block has 8 rows)
7522               
7523                                                                          ; The following calculates:
7524                                                                          ;
7525                                                                          ; P = P / Q
7526                                                                          ; = |delta_x| / |delta_y|
7527                                                                          ;
7528                                                                          ; using the same shift-and-subtract algorithm
7529                                                                          ; documented in TIS2
7530               
7531 248E D020  30        movb @P,ra                      ; LDA P             ; Set A = |delta_x|
     2490 001B     
7532               
7533 2492 0201  20        li   rx,>01*256                 ; LDX #1            ; Set Q to have bits 1-7 clear, so we can rotate through
     2494 0100     
7534 2496 D801  30        movb rx,@P                      ; STX P             ; 7 loop iterations, getting a 1 each time, and then
     2498 001B     
7535                                                                          ; getting a 1 on the 8th iteration... and we can also
7536                                                                          ; use P to catch our result bits into bit 0 each time
7537               
7538               LIL4:
7539                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 249A 0240  22        andi ra,>ff00
     249C FF00     
0002 249E 0A10  18        sla  ra,1
                   < elite.a99
7540               
7541 24A0 1803  14        joc  LI13                       ; BCS LI13          ; If bit 7 of A was set, then jump straight to the
7542                                                                          ; subtraction
7543               
7544 24A2 9020  30        cb   @Q,ra                      ; CMP Q             ; If A < Q, skip the following subtraction
     24A4 0090     
7545 24A6 1705  14        jnc  LI14                       ; BCC LI14
7546               
7547               LI13:
7548                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 24A8 1801  14        joc  !
0002 24AA 7004  18        sb   rone,ra
0003               !:
0004 24AC 7020  30        sb   @Q,ra
     24AE 0090     
                   < elite.a99
7549               
7550                      .sec                            ; SEC               ; Set the C flag to rotate into the result in Q
     **** ****     > SEC
0001 24B0 0A15  18        sla  rmone,1
                   < elite.a99
7551               
7552               LI14:
7553 24B2 0208  20        li   rarg1,P                    ; ROL P             ; Rotate the counter in P to the left, and catch the
     24B4 001B     
7554 24B6 06A0  32        bl   @rol                       ;
     24B8 FF36     
7555                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
7556                                                                          ; do the subtraction, or 1 if we did)
7557               
7558 24BA 17EF  14        jnc  LIL4                       ; BCC LIL4          ; If we still have set bits in P, loop back to TIL2 to
7559                                                                          ; do the next iteration of 7
7560               
7561                                                                          ; We now have:
7562                                                                          ;
7563                                                                          ; P = A / Q
7564                                                                          ; = |delta_x| / |delta_y|
7565                                                                          ;
7566                                                                          ; and the C flag is set
7567               
7568 24BC D060  30        movb @Q,rx                      ; LDX Q             ; Set X = Q + 1
     24BE 0090     
7569 24C0 B044  18        ab   rone,rx                    ; INX               ; = |delta_y| + 1
7570                                                                          ;
7571                                                                          ; We add 1 so we can skip the first pixel plot if the
7572                                                                          ; line is being drawn with swapped coordinates
7573               
7574 24C2 D020  30        movb @X2,ra                     ; LDA X2            ; Set A = X2 - X1 (the C flag is set as we didn't take
     24C4 0033     
7575                      .sbc @X1,ra                     ; SBC X1            ; the above BCC)
     **** ****     > SBC
0001 24C6 1801  14        joc  !
0002 24C8 7004  18        sb   rone,ra
0003               !:
0004 24CA 7020  30        sb   @X1,ra
     24CC 0031     
                   < elite.a99
7576               
7577 24CE 1737  14        jnc  LFT                        ; BCC LFT           ; If X2 < X1 then jump to LFT, as we need to draw the
7578                                                                          ; line to the left and down
7579               
7580               * ******************************************************************************
7581               *
7582               * Name: LOIN (Part 6 of 7)
7583               * Type: Subroutine
7584               * Category: Drawing lines
7585               * Summary: Draw a steep line going up and left or down and right
7586               * Deep dive: Bresenham's line algorithm
7587               *
7588               * ------------------------------------------------------------------------------
7589               *
7590               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7591               * If we get here, then:
7592               *
7593               * * The line is going up and left (no swap) or down and right (swap)
7594               *
7595               * * X1 < X2 and Y1 >= Y2
7596               *
7597               * * Draw from (X1, Y1) at top left to (X2, Y2) at bottom right, omitting the
7598               * first pixel
7599               *
7600               * ******************************************************************************
7601               
7602                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 24D0 0A13  18        sla  rzero,1
                   < elite.a99
7603               
7604 24D2 D020  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     24D4 00A1     
7605 24D6 130D  14        jeq  LI17                       ; BEQ LI17          ; so jump down to LI17 to skip plotting the first pixel
7606               
7607 24D8 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7608                                                                          ; the first pixel
7609               
7610               LIL5:
7611                                                                          ; We now loop along the line from left to right, using X
7612                                                                          ; as a decreasing counter, and at each count we plot a
7613                                                                          ; single pixel using the pixel mask in R
7614 24DA D020  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     24DC 0091     
7615               
7616                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 24DE D1A0  30        movb @SC,rtmp
     24E0 0007     
0002 24E2 2806  18        xor  rtmp,ra
                   < elite.a99
7617                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 24E4 D820  50        movb @SC,@rtmplb
     24E6 0007     
     24E8 2079     
0002 24EA D1A0  30        movb @SC+1,rtmp
     24EC 0008     
0003 24EE A182  18        a    ry,rtmp
0004 24F0 D580  30        movb RA,*rtmp
                   < elite.a99
7618               
7619               LI17:
7620 24F2 7084  18        sb   rone,ry                    ; DEY               ; Decrement Y to step up along the y-axis
7621               
7622 24F4 1503  14        jgt  LI16                       ; BPL LI16          ; If Y is positive we are still within the same
7623                                                                          ; character block, so skip to LI16
7624               
7625 24F6 7004  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7626 24F8 0202  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     24FA 0700     
7627                                                                          ; address and set the pixel line to the last line in
7628                                                                          ; that character block
7629               
7630               LI16:
7631 24FC D020  30        movb @S,ra                      ; LDA S             ; Set S = S + P to update the slope error
     24FE 0092     
7632                      .adc @P,ra                      ; ADC P
     **** ****     > ADC
0001 2500 1701  14        jnc  !
0002 2502 B004  18        ab   rone,ra
0003               !:
0004 2504 B020  30        ab   @P,ra
     2506 001B     
                   < elite.a99
7633 2508 D800  30        movb ra,@S                      ; STA S
     250A 0092     
7634               
7635 250C 1712  14        jnc  LIC5                       ; BCC LIC5          ; If the addition didn't overflow, jump to LIC5
7636               
7637                      .lsr @R                         ; LSR R             ; Otherwise we just overflowed, so shift the single
     **** ****     > LSR
0001 250E D1A0  30        movb @R,rtmp
     2510 0091     
0002 2512 0916  18        srl  rtmp,1
0003 2514 D806  30        movb rtmp,@R
     2516 0091     
                   < elite.a99
7638                                                                          ; pixel in R to the right, so the next pixel we plot
7639                                                                          ; will be at the next x-coordinate along
7640               
7641 2518 170C  14        jnc  LIC5                       ; BCC LIC5          ; If the pixel didn't fall out of the right end of R
7642                                                                          ; into the C flag, then jump to LIC5
7643               
7644 251A 0208  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     251C 0091     
7645 251E 06A0  32        bl   @ror                       ;
     2520 FF62     
7646                                                                          ; block, so first rotate R right so the set C flag goes
7647                                                                          ; back into the left end, giving %10000000
7648               
7649 2522 D020  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     2524 0007     
7650                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 2526 1701  14        jnc  !
0002 2528 B004  18        ab   rone,ra
0003               !:
0004 252A 0220  22        ai   ra,(>08*256)
     252C 0800     
                   < elite.a99
7651 252E D800  30        movb ra,@SC                     ; STA SC
     2530 0007     
7652               
7653               LIC5:
7654 2532 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7655               
7656 2534 16D2  14        jne  LIL5                       ; BNE LIL5          ; If we haven't yet reached the right end of the line,
7657                                                                          ; loop back to LIL5 to plot the next pixel along
7658               
7659 2536 D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2538 0094     
7660               
7661 253A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     253C FF1C     
7662               
7663               * ******************************************************************************
7664               *
7665               * Name: LOIN (Part 7 of 7)
7666               * Type: Subroutine
7667               * Category: Drawing lines
7668               * Summary: Draw a steep line going up and right or down and left
7669               * Deep dive: Bresenham's line algorithm
7670               *
7671               * ------------------------------------------------------------------------------
7672               *
7673               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7674               * If we get here, then:
7675               *
7676               * * The line is going up and right (no swap) or down and left (swap)
7677               *
7678               * * X1 >= X2 and Y1 >= Y2
7679               *
7680               * * Draw from (X1, Y1) at bottom left to (X2, Y2) at top right, omitting the
7681               * first pixel
7682               *
7683               * ------------------------------------------------------------------------------
7684               *
7685               * Other entry points:
7686               *
7687               * HL6                 Contains an RTS
7688               *
7689               * ******************************************************************************
7690               
7691               LFT:
7692 253E D020  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     2540 00A1     
7693 2542 130D  14        jeq  LI18                       ; BEQ LI18          ; so jump down to LI18 to skip plotting the first pixel
7694               
7695 2544 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7696                                                                          ; the first pixel
7697               
7698               LIL6:
7699 2546 D020  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     2548 0091     
7700               
7701                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 254A D1A0  30        movb @SC,rtmp
     254C 0007     
0002 254E 2806  18        xor  rtmp,ra
                   < elite.a99
7702                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 2550 D820  50        movb @SC,@rtmplb
     2552 0007     
     2554 2079     
0002 2556 D1A0  30        movb @SC+1,rtmp
     2558 0008     
0003 255A A182  18        a    ry,rtmp
0004 255C D580  30        movb RA,*rtmp
                   < elite.a99
7703               
7704               LI18:
7705 255E 7084  18        sb   rone,ry                    ; DEY               ; Decrement Y to step up along the y-axis
7706               
7707 2560 1503  14        jgt  LI19                       ; BPL LI19          ; If Y is positive we are still within the same
7708                                                                          ; character block, so skip to LI19
7709               
7710 2562 7004  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7711 2564 0202  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     2566 0700     
7712                                                                          ; address and set the pixel line to the last line in
7713                                                                          ; that character block
7714               
7715               LI19:
7716 2568 D020  30        movb @S,ra                      ; LDA S             ; Set S = S + P to update the slope error
     256A 0092     
7717                      .adc @P,ra                      ; ADC P
     **** ****     > ADC
0001 256C 1701  14        jnc  !
0002 256E B004  18        ab   rone,ra
0003               !:
0004 2570 B020  30        ab   @P,ra
     2572 001B     
                   < elite.a99
7718 2574 D800  30        movb ra,@S                      ; STA S
     2576 0092     
7719               
7720 2578 1715  14        jnc  LIC6                       ; BCC LIC6          ; If the addition didn't overflow, jump to LIC6
7721               
7722                      .asl @R                         ; ASL R             ; Otherwise we just overflowed, so shift the single
     **** ****     > ASL
0001 257A D1A0  30        movb @R,rtmp
     257C 0091     
0002 257E 0246  22        andi rtmp,>ff00
     2580 FF00     
0003 2582 0A16  18        sla  rtmp,1
0004 2584 D806  30        movb rtmp,@R
     2586 0091     
                   < elite.a99
7723                                                                          ; pixel in R to the left, so the next pixel we plot
7724                                                                          ; will be at the previous x-coordinate
7725               
7726 2588 170D  14        jnc  LIC6                       ; BCC LIC6          ; If the pixel didn't fall out of the left end of R
7727                                                                          ; into the C flag, then jump to LIC6
7728               
7729 258A 0208  20        li   rarg1,R                    ; ROL R             ; Otherwise we need to move over to the next character
     258C 0091     
7730 258E 06A0  32        bl   @rol                       ;
     2590 FF36     
7731                                                                          ; block, so first rotate R left so the set C flag goes
7732                                                                          ; back into the right end, giving %0000001
7733               
7734 2592 D020  30        movb @SC,ra                     ; LDA SC            ; Subtract 7 from SC, so SC(1 0) now points to the
     2594 0007     
7735                      .sbi (>07*256)                  ; SBC #7            ; previous character along to the left
     **** ****     > SBI
0001 2596 1801  14        joc  !
0002 2598 7004  18        sb   rone,ra
0003               !:
0004 259A 0220  22        ai   ra,-(>07*256)
     259C F900     
                   < elite.a99
7736 259E D800  30        movb ra,@SC                     ; STA SC
     25A0 0007     
7737               
7738                      .clc                            ; CLC               ; Clear the C flag so it doesn't affect the additions
     **** ****     > CLC
0001 25A2 0A13  18        sla  rzero,1
                   < elite.a99
7739                                                                          ; below
7740               
7741               LIC6:
7742 25A4 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7743               
7744 25A6 16CF  14        jne  LIL6                       ; BNE LIL6          ; If we haven't yet reached the left end of the line,
7745                                                                          ; loop back to LIL6 to plot the next pixel along
7746               
7747 25A8 D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     25AA 0094     
7748               
7749               HL6:
7750 25AC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     25AE FF1C     
7751               
7752               * ******************************************************************************
7753               *
7754               * Name: NLIN3
7755               * Type: Subroutine
7756               * Category: Drawing lines
7757               * Summary: Print a title and draw a horizontal line at row 19 to box it in
7758               *
7759               * ------------------------------------------------------------------------------
7760               *
7761               * This routine print a text token at the cursor position and draws a horizontal
7762               * line at pixel row 19. It is used for the Status Mode screen, the Short-range
7763               * Chart, the Market Price screen and the Equip Ship screen.
7764               *
7765               * ******************************************************************************
7766               
7767               NLIN3:
7768 25B0 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     25B2 A6E8     
7769 25B4 06A0  32        bl   @jsr                       ;
     25B6 FF10     
7770               
7771                                                                          ; Fall through into NLIN4 to draw a horizontal line at
7772                                                                          ; pixel row 19
7773               
7774               * ******************************************************************************
7775               *
7776               * Name: NLIN4
7777               * Type: Subroutine
7778               * Category: Drawing lines
7779               * Summary: Draw a horizontal line at pixel row 19 to box in a title
7780               *
7781               * ------------------------------------------------------------------------------
7782               *
7783               * This routine is used on the Inventory screen to draw a horizontal line at
7784               * pixel row 19 to box in the title.
7785               *
7786               * ******************************************************************************
7787               
7788               NLIN4:
7789 25B8 0200  20        li   ra,>13*256                 ; LDA #19           ; Jump to NLIN2 to draw a horizontal line at pixel row
     25BA 1300     
7790 25BC 1603  14        jne  NLIN2                      ; BNE NLIN2         ; 19, returning from the subroutine with using a tail
7791                                                                          ; call (this BNE is effectively a JMP as A will never
7792                                                                          ; be zero)
7793               
7794               * ******************************************************************************
7795               *
7796               * Name: NLIN
7797               * Type: Subroutine
7798               * Category: Drawing lines
7799               * Summary: Draw a horizontal line at pixel row 23 to box in a title
7800               *
7801               * ------------------------------------------------------------------------------
7802               *
7803               * Draw a horizontal line at pixel row 23 and move the text cursor down one
7804               * line.
7805               *
7806               * ******************************************************************************
7807               
7808               NLIN:
7809 25BE 0200  20        li   ra,>17*256                 ; LDA #23           ; Set A = 23 so NLIN2 below draws a horizontal line at
     25C0 1700     
7810                                                                          ; pixel row 23
7811               
7812 25C2 B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
7813               
7814                                                                          ; Fall through into NLIN2 to draw the horizontal line
7815                                                                          ; at row 23
7816               
7817               * ******************************************************************************
7818               *
7819               * Name: NLIN2
7820               * Type: Subroutine
7821               * Category: Drawing lines
7822               * Summary: Draw a screen-wide horizontal line at the pixel row in A
7823               *
7824               * ------------------------------------------------------------------------------
7825               *
7826               * This draws a line from (2, A) to (254, A), which is almost screen-wide and
7827               * fits in nicely between the white borders without clashing with it.
7828               *
7829               * ------------------------------------------------------------------------------
7830               *
7831               * Arguments:
7832               *
7833               * A                   The pixel row on which to draw the horizontal line
7834               *
7835               * ******************************************************************************
7836               
7837               NLIN2:
7838 25C4 D800  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 = A
     25C6 0032     
7839               
7840 25C8 0201  20        li   rx,>02*256                 ; LDX #2            ; Set X1 = 2, so (X1, Y1) = (2, A)
     25CA 0200     
7841 25CC D801  30        movb rx,@X1                     ; STX X1
     25CE 0031     
7842               
7843 25D0 0201  20        li   rx,>fe*256                 ; LDX #254          ; Set X2 = 254, so (X2, Y2) = (254, A)
     25D2 FE00     
7844 25D4 D801  30        movb rx,@X2                     ; STX X2
     25D6 0033     
7845               
7846 25D8 160A  14        jne  HLOIN                      ; BNE HLOIN         ; Call HLOIN to draw a horizontal line from (2, A) to
7847                                                                          ; (254, A) and return from the subroutine (this BNE is
7848                                                                          ; effectively a JMP as A will never be zero)
7849               
7850               * ******************************************************************************
7851               *
7852               * Name: HLOIN2
7853               * Type: Subroutine
7854               * Category: Drawing lines
7855               * Summary: Remove a line from the sun line heap and draw it on-screen
7856               *
7857               * ------------------------------------------------------------------------------
7858               *
7859               * Specifically, this does the following:
7860               *
7861               * * Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
7862               * centre YY(1 0) and length A to the left and right
7863               *
7864               * * Set the Y-th byte of the LSO block to 0 (i.e. remove this line from the
7865               * sun line heap)
7866               *
7867               * * Draw a horizontal line from (X1, Y) to (X2, Y)
7868               *
7869               * ------------------------------------------------------------------------------
7870               *
7871               * Arguments:
7872               *
7873               * YY(1 0)             The x-coordinate of the centre point of the line
7874               *
7875               * A                   The half-width of the line, i.e. the contents of the
7876               * Y-th byte of the sun line heap
7877               *
7878               * Y                   The number of the entry in the sun line heap (which is
7879               * also the y-coordinate of the line)
7880               *
7881               * ------------------------------------------------------------------------------
7882               *
7883               * Returns:
7884               *
7885               * Y                   Y is preserved
7886               *
7887               * ******************************************************************************
7888               
7889               HLOIN2:
7890 25DA 0206  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     25DC B9B2     
7891 25DE 06A0  32        bl   @jsr                       ;
     25E0 FF10     
7892                                                                          ; line centred on YY(1 0) and with half-width A
7893               
7894 25E2 D802  30        movb ry,@Y1                     ; STY Y1            ; Set Y1 = Y
     25E4 0032     
7895               
7896 25E6 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the Y-th byte of the LSO block to 0
     25E8 0000     
7897 25EA D880  38        movb ra,@LSO(ry)                ; STA LSO,Y
     25EC 0D66     
7898               
7899                                                                          ; Fall through into HLOIN to draw a horizontal line from
7900                                                                          ; (X1, Y) to (X2, Y)
7901               
7902               * ******************************************************************************
7903               *
7904               * Name: HLOIN
7905               * Type: Subroutine
7906               * Category: Drawing lines
7907               * Summary: Draw a horizontal line from (X1, Y1) to (X2, Y1)
7908               * Deep dive: Drawing monochrome pixels in mode 4
7909               *
7910               * ------------------------------------------------------------------------------
7911               *
7912               * We do not draw a pixel at the right end of the line.
7913               *
7914               * To understand how this routine works, you might find it helpful to read the
7915               * deep dive on "Drawing monochrome pixels in mode 4".
7916               *
7917               * ------------------------------------------------------------------------------
7918               *
7919               * Returns:
7920               *
7921               * Y                   Y is preserved
7922               *
7923               * ******************************************************************************
7924               
7925               HLOIN:
7926 25EE D802  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y into YSAV, so we can preserve it across the
     25F0 0094     
7927                                                                          ; call to this subroutine
7928               
7929 25F2 D060  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     25F4 0031     
7930               
7931 25F6 9060  30        cb   @X2,rx                     ; CPX X2            ; If X1 = X2 then the start and end points are the same,
     25F8 0033     
7932 25FA 13D8  14        jeq  HL6                        ; BEQ HL6           ; so return from the subroutine (as HL6 contains an RTS)
7933               
7934 25FC 1707  14        jnc  HL5                        ; BCC HL5           ; If X1 < X2, jump to HL5 to skip the following code, as
7935                                                                          ; (X1, Y1) is already the left point
7936               
7937 25FE D020  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2, so we know that (X1, Y1)
     2600 0033     
7938 2602 D800  30        movb ra,@X1                     ; STA X1            ; is on the left and (X2, Y1) is on the right
     2604 0031     
7939 2606 D801  30        movb rx,@X2                     ; STX X2
     2608 0033     
7940               
7941 260A D040  18        movb ra,rx                      ; TAX               ; Set X = X1
7942               
7943               HL5:
7944 260C 7004  18        sb   rone,ra                    ; DEC X2            ; Decrement X2 so we do not draw a pixel at the end
7945                                                                          ; point
7946               
7947 260E D020  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 / 8, so A now contains the character row
     2610 0032     
7948 2612 0910  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7949 2614 0910  18        srl  ra,1                       ; LSR A
7950 2616 0910  18        srl  ra,1                       ; LSR A
7951               
7952 2618 0260  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     261A 6000     
7953                                                                          ; us the screen address of the character row (as each
7954                                                                          ; character row takes up 256 bytes, and the first
7955                                                                          ; character row is at screen address &6000, or page &60)
7956               
7957 261C D800  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     261E 0008     
7958                                                                          ; the high byte of SC is set correctly for drawing our
7959                                                                          ; line
7960               
7961 2620 D020  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 mod 8, which is the pixel row within the
     2622 0032     
7962 2624 0240  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw our line (as
     2626 0700     
7963                                                                          ; each character block has 8 rows)
7964               
7965 2628 D800  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     262A 0007     
7966                                                                          ; screen address of the far left end (x-coordinate = 0)
7967                                                                          ; of the horizontal pixel row that we want to draw our
7968                                                                          ; horizontal line on
7969               
7970 262C D001  18        movb rx,ra                      ; TXA               ; Set Y = bits 3-7 of X1
7971 262E 0240  22        andi ra,>f8*256                 ; AND #%11111000
     2630 F800     
7972 2632 D080  18        movb ra,ry                      ; TAY
7973               
7974               HL1:
7975 2634 D001  18        movb rx,ra                      ; TXA               ; Set T = bits 3-7 of X1, which will contain the
7976 2636 0240  22        andi ra,>f8*256                 ; AND #%11111000    ; character number of the start of the line * 8
     2638 F800     
7977 263A D800  30        movb ra,@T                      ; STA T
     263C 00D1     
7978               
7979 263E D020  30        movb @X2,ra                     ; LDA X2            ; Set A = bits 3-7 of X2, which will contain the
     2640 0033     
7980 2642 0240  22        andi ra,>f8*256                 ; AND #%11111000    ; character number of the end of the line * 8
     2644 F800     
7981               
7982                      .sec                            ; SEC               ; Set A = A - T, which will contain the number of
     **** ****     > SEC
0001 2646 0A15  18        sla  rmone,1
                   < elite.a99
7983                      .sbc @T,ra                      ; SBC T             ; character blocks we need to fill - 1 * 8
     **** ****     > SBC
0001 2648 1801  14        joc  !
0002 264A 7004  18        sb   rone,ra
0003               !:
0004 264C 7020  30        sb   @T,ra
     264E 00D1     
                   < elite.a99
7984               
7985 2650 134A  14        jeq  HL2                        ; BEQ HL2           ; If A = 0 then the start and end character blocks are
7986                                                                          ; the same, so the whole line fits within one block, so
7987                                                                          ; jump down to HL2 to draw the line
7988               
7989                                                                          ; Otherwise the line spans multiple characters, so we
7990                                                                          ; start with the left character, then do any characters
7991                                                                          ; in the middle, and finish with the right character
7992               
7993 2652 0910  18        srl  ra,1                       ; LSR A             ; Set R = A / 8, so R now contains the number of
7994 2654 0910  18        srl  ra,1                       ; LSR A             ; character blocks we need to fill - 1
7995 2656 0910  18        srl  ra,1                       ; LSR A
7996 2658 D800  30        movb ra,@R                      ; STA R
     265A 0091     
7997               
7998 265C D020  30        movb @X1,ra                     ; LDA X1            ; Set X = X1 mod 8, which is the horizontal pixel number
     265E 0031     
7999 2660 0240  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     2662 0700     
8000 2664 D040  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
8001                                                                          ; wide)
8002               
8003 2666 D021  34        movb @TWFR(rx),ra               ; LDA TWFR,X        ; Fetch a ready-made byte with X pixels filled in at the
     2668 2731     
8004                                                                          ; right end of the byte (so the filled pixels start at
8005                                                                          ; point X and go all the way to the end of the byte),
8006                                                                          ; which is the shape we want for the left end of the
8007                                                                          ; line
8008               
8009                      .eor @SC                        ; EOR (SC),Y        ; Store this into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 266A D1A0  30        movb @SC,rtmp
     266C 0007     
0002 266E 2806  18        xor  rtmp,ra
                   < elite.a99
8010                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen,
     **** ****     > ST_IND_Y_IDX
0001 2670 D820  50        movb @SC,@rtmplb
     2672 0007     
     2674 2079     
0002 2676 D1A0  30        movb @SC+1,rtmp
     2678 0008     
0003 267A A182  18        a    ry,rtmp
0004 267C D580  30        movb RA,*rtmp
                   < elite.a99
8011                                                                          ; so we have now drawn the line's left cap
8012               
8013 267E D002  18        movb ry,ra                      ; TYA               ; Set Y = Y + 8 so (SC),Y points to the next character
8014                      .adi (>08*256)                  ; ADC #8            ; block along, on the same pixel row as before
     **** ****     > ADI
0001 2680 1701  14        jnc  !
0002 2682 B004  18        ab   rone,ra
0003               !:
0004 2684 0220  22        ai   ra,(>08*256)
     2686 0800     
                   < elite.a99
8015 2688 D080  18        movb ra,ry                      ; TAY
8016               
8017 268A D060  30        movb @R,rx                      ; LDX R             ; Fetch the number of character blocks we need to fill
     268C 0091     
8018                                                                          ; from R
8019               
8020 268E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the number of character blocks in X
8021               
8022 2690 1315  14        jeq  HL3                        ; BEQ HL3           ; If X = 0 then we only have the last block to do (i.e.
8023                                                                          ; the right cap), so jump down to HL3 to draw it
8024               
8025                      .clc                            ; CLC               ; Otherwise clear the C flag so we can do some additions
     **** ****     > CLC
0001 2692 0A13  18        sla  rzero,1
                   < elite.a99
8026                                                                          ; while we draw the character blocks with full-width
8027                                                                          ; lines in them
8028               
8029               HLL1:
8030 2694 0200  20        li   ra,>ff*256                 ; LDA #%11111111    ; Store a full-width 8-pixel horizontal line in SC(1 0)
     2696 FF00     
8031                      .eor @SC                        ; EOR (SC),Y        ; so that it draws the line on-screen, using EOR logic
     **** ****     > EOR
0001 2698 D1A0  30        movb @SC,rtmp
     269A 0007     
0002 269C 2806  18        xor  rtmp,ra
                   < elite.a99
8032                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 269E D820  50        movb @SC,@rtmplb
     26A0 0007     
     26A2 2079     
0002 26A4 D1A0  30        movb @SC+1,rtmp
     26A6 0008     
0003 26A8 A182  18        a    ry,rtmp
0004 26AA D580  30        movb RA,*rtmp
                   < elite.a99
8033               
8034 26AC D002  18        movb ry,ra                      ; TYA               ; Set Y = Y + 8 so (SC),Y points to the next character
8035                      .adi (>08*256)                  ; ADC #8            ; block along, on the same pixel row as before
     **** ****     > ADI
0001 26AE 1701  14        jnc  !
0002 26B0 B004  18        ab   rone,ra
0003               !:
0004 26B2 0220  22        ai   ra,(>08*256)
     26B4 0800     
                   < elite.a99
8036 26B6 D080  18        movb ra,ry                      ; TAY
8037               
8038 26B8 7044  18        sb   rone,rx                    ; DEX               ; Decrement the number of character blocks in X
8039               
8040 26BA 16EC  14        jne  HLL1                       ; BNE HLL1          ; Loop back to draw more full-width lines, if we have
8041                                                                          ; any more to draw
8042               
8043               HL3:
8044 26BC D020  30        movb @X2,ra                     ; LDA X2            ; Now to draw the last character block at the right end
     26BE 0033     
8045 26C0 0240  22        andi ra,>07*256                 ; AND #7            ; of the line, so set X = X2 mod 8, which is the
     26C2 0700     
8046 26C4 D040  18        movb ra,rx                      ; TAX               ; horizontal pixel number where the line ends
8047               
8048 26C6 D021  34        movb @TWFL(rx),ra               ; LDA TWFL,X        ; Fetch a ready-made byte with X pixels filled in at the
     26C8 272A     
8049                                                                          ; left end of the byte (so the filled pixels start at
8050                                                                          ; the left edge and go up to point X), which is the
8051                                                                          ; shape we want for the right end of the line
8052               
8053                      .eor @SC                        ; EOR (SC),Y        ; Store this into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 26CA D1A0  30        movb @SC,rtmp
     26CC 0007     
0002 26CE 2806  18        xor  rtmp,ra
                   < elite.a99
8054                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen,
     **** ****     > ST_IND_Y_IDX
0001 26D0 D820  50        movb @SC,@rtmplb
     26D2 0007     
     26D4 2079     
0002 26D6 D1A0  30        movb @SC+1,rtmp
     26D8 0008     
0003 26DA A182  18        a    ry,rtmp
0004 26DC D580  30        movb RA,*rtmp
                   < elite.a99
8055                                                                          ; so we have now drawn the line's right cap
8056               
8057 26DE D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved across the
     26E0 0094     
8058                                                                          ; call to this subroutine
8059               
8060 26E2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     26E4 FF1C     
8061               
8062               HL2:
8063                                                                          ; If we get here then the entire horizontal line fits
8064                                                                          ; into one character block
8065 26E6 D020  30        movb @X1,ra                     ; LDA X1            ; Set X = X1 mod 8, which is the horizontal pixel number
     26E8 0031     
8066 26EA 0240  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     26EC 0700     
8067 26EE D040  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
8068                                                                          ; wide)
8069               
8070 26F0 D021  34        movb @TWFR(rx),ra               ; LDA TWFR,X        ; Fetch a ready-made byte with X pixels filled in at the
     26F2 2731     
8071 26F4 D800  30        movb ra,@T                      ; STA T             ; right end of the byte (so the filled pixels start at
     26F6 00D1     
8072                                                                          ; point X and go all the way to the end of the byte)
8073               
8074 26F8 D020  30        movb @X2,ra                     ; LDA X2            ; Set X = X2 mod 8, which is the horizontal pixel number
     26FA 0033     
8075 26FC 0240  22        andi ra,>07*256                 ; AND #7            ; where the line ends
     26FE 0700     
8076 2700 D040  18        movb ra,rx                      ; TAX
8077               
8078 2702 D021  34        movb @TWFL(rx),ra               ; LDA TWFL,X        ; Fetch a ready-made byte with X pixels filled in at the
     2704 272A     
8079                                                                          ; left end of the byte (so the filled pixels start at
8080                                                                          ; the left edge and go up to point X)
8081               
8082                      .and @T                         ; AND T             ; We now have two bytes, one (T) containing pixels from
     **** ****     > AND
0001 2706 D1A0  30        movb @T,rtmp
     2708 00D1     
0002 270A 0546  14        inv  rtmp
0003 270C 5006  18        szcb rtmp,ra
                   < elite.a99
8083                                                                          ; the starting point X1 onwards, and the other (A)
8084                                                                          ; containing pixels up to the end point at X2, so we can
8085                                                                          ; get the actual line we want to draw by AND'ing them
8086                                                                          ; together. For example, if we want to draw a line from
8087                                                                          ; point 2 to point 5 (within the row of 8 pixels
8088                                                                          ; numbered from 0 to 7), we would have this:
8089                                                                          ;
8090                                                                          ; T       = %00111111
8091                                                                          ; A       = %11111100
8092                                                                          ; T AND A = %00111100
8093                                                                          ;
8094                                                                          ; So we can stick T AND A in screen memory to get the
8095                                                                          ; line we want, which is what we do here by setting
8096                                                                          ; A = A AND T
8097               
8098                      .eor @SC                        ; EOR (SC),Y        ; Store our horizontal line byte into screen memory at
     **** ****     > EOR
0001 270E D1A0  30        movb @SC,rtmp
     2710 0007     
0002 2712 2806  18        xor  rtmp,ra
                   < elite.a99
8099                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; SC(1 0), using EOR logic so it merges with whatever is
     **** ****     > ST_IND_Y_IDX
0001 2714 D820  50        movb @SC,@rtmplb
     2716 0007     
     2718 2079     
0002 271A D1A0  30        movb @SC+1,rtmp
     271C 0008     
0003 271E A182  18        a    ry,rtmp
0004 2720 D580  30        movb RA,*rtmp
                   < elite.a99
8100                                                                          ; already on-screen
8101               
8102 2722 D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2724 0094     
8103               
8104 2726 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2728 FF1C     
8105               
8106               * ******************************************************************************
8107               *
8108               * Name: TWFL
8109               * Type: Variable
8110               * Category: Drawing lines
8111               * Summary: Ready-made character rows for the left end of a horizontal line in
8112               * mode 4
8113               *
8114               * ------------------------------------------------------------------------------
8115               *
8116               * Ready-made bytes for plotting horizontal line end caps in mode 4 (the top part
8117               * of the split screen). This table provides a byte with pixels at the left end,
8118               * which is used for the right end of the line.
8119               *
8120               * See the HLOIN routine for details.
8121               *
8122               * ******************************************************************************
8123               
8124               TWFL:
8125 272A 80              byte >80
8126 272B   C0            byte >c0
8127 272C E0              byte >e0
8128 272D   F0            byte >f0
8129 272E F8              byte >f8
8130 272F   FC            byte >fc
8131 2730 FE              byte >fe
8132               
8133               * ******************************************************************************
8134               *
8135               * Name: TWFR
8136               * Type: Variable
8137               * Category: Drawing lines
8138               * Summary: Ready-made character rows for the right end of a horizontal line
8139               * in mode 4
8140               *
8141               * ------------------------------------------------------------------------------
8142               *
8143               * Ready-made bytes for plotting horizontal line end caps in mode 4 (the top part
8144               * of the split screen). This table provides a byte with pixels at the right end,
8145               * which is used for the left end of the line.
8146               *
8147               * See the HLOIN routine for details.
8148               *
8149               * ******************************************************************************
8150               
8151               TWFR:
8152 2731   FF            byte >ff
8153 2732 7F              byte >7f
8154 2733   3F            byte >3f
8155 2734 1F              byte >1f
8156 2735   0F            byte >0f
8157 2736 07              byte >07
8158 2737   03            byte >03
8159 2738 01              byte >01
8160               
8161               * ******************************************************************************
8162               *
8163               * Name: PX3
8164               * Type: Subroutine
8165               * Category: Drawing pixels
8166               * Summary: Plot a single pixel at (X, Y) within a character block
8167               *
8168               * ------------------------------------------------------------------------------
8169               *
8170               * This routine is called from PIXEL to set 1 pixel within a character block for
8171               * a distant point (i.e. where the distance ZZ >= &90). See the PIXEL routine for
8172               * details, as this routine is effectively part of PIXEL.
8173               *
8174               * ------------------------------------------------------------------------------
8175               *
8176               * Arguments:
8177               *
8178               * X                   The x-coordinate of the pixel within the character block
8179               *
8180               * Y                   The y-coordinate of the pixel within the character block
8181               *
8182               * SC(1 0)             The screen address of the character block
8183               *
8184               * T1                  The value of Y to restore on exit, so Y is preserved by
8185               * the call to PIXEL
8186               *
8187               * ******************************************************************************
8188               
8189               PX3:
8190 273A D021  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS and EOR it into SC+Y
     273C 2239     
8191                      .eor @SC                        ; EOR (SC),Y
     **** ****     > EOR
0001 273E D1A0  30        movb @SC,rtmp
     2740 0007     
0002 2742 2806  18        xor  rtmp,ra
                   < elite.a99
8192                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 2744 D820  50        movb @SC,@rtmplb
     2746 0007     
     2748 2079     
0002 274A D1A0  30        movb @SC+1,rtmp
     274C 0008     
0003 274E A182  18        a    ry,rtmp
0004 2750 D580  30        movb RA,*rtmp
                   < elite.a99
8193               
8194 2752 D0A0  30        movb @T1,ry                     ; LDY T1            ; Restore Y from T1, so Y is preserved by the routine
     2754 0006     
8195               
8196 2756 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2758 FF1C     
8197               
8198               * ******************************************************************************
8199               *
8200               * Name: PIX1
8201               * Type: Subroutine
8202               * Category: Maths (Arithmetic)
8203               * Summary: Calculate (YY+1 SYL+Y) = (A P) + (S R) and draw stardust particle
8204               *
8205               * ------------------------------------------------------------------------------
8206               *
8207               * Calculate the following:
8208               *
8209               * (YY+1 SYL+Y) = (A P) + (S R)
8210               *
8211               * and draw a stardust particle at (X1,Y1) with distance ZZ.
8212               *
8213               * ------------------------------------------------------------------------------
8214               *
8215               * Arguments:
8216               *
8217               * (A P)               A is the angle ALPHA or BETA, P is always 0
8218               *
8219               * (S R)               YY(1 0) or YY(1 0) + Q * A
8220               *
8221               * Y                   Stardust particle number
8222               *
8223               * X1                  The x-coordinate offset
8224               *
8225               * Y1                  The y-coordinate offset
8226               *
8227               * ZZ                  The distance of the point (further away = smaller point)
8228               *
8229               * ******************************************************************************
8230               
8231               PIX1:
8232 275A 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     275C 44BA     
8233 275E 06A0  32        bl   @jsr                       ;
     2760 FF10     
8234               
8235 2762 D800  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY+1 to A, the high byte of the result
     2764 0027     
8236               
8237 2766 D001  18        movb rx,ra                      ; TXA               ; Set SYL+Y to X, the low byte of the result
8238 2768 D880  38        movb ra,@SYL(ry)                ; STA SYL,Y
     276A 0ED5     
8239               
8240                                                                          ; Fall through into PIX1 to draw the stardust particle
8241                                                                          ; at (X1,Y1)
8242               
8243               * ******************************************************************************
8244               *
8245               * Name: PIXEL2
8246               * Type: Subroutine
8247               * Category: Drawing pixels
8248               * Summary: Draw a stardust particle relative to the screen centre
8249               *
8250               * ------------------------------------------------------------------------------
8251               *
8252               * Draw a point (X1, Y1) from the middle of the screen with a size determined by
8253               * a distance value. Used to draw stardust particles.
8254               *
8255               * ------------------------------------------------------------------------------
8256               *
8257               * Arguments:
8258               *
8259               * X1                  The x-coordinate offset
8260               *
8261               * Y1                  The y-coordinate offset (positive means up the screen
8262               * from the centre, negative means down the screen)
8263               *
8264               * ZZ                  The distance of the point (further away = smaller point)
8265               *
8266               * ******************************************************************************
8267               
8268               PIXEL2:
8269 276C D020  30        movb @X1,ra                     ; LDA X1            ; Fetch the x-coordinate offset into A
     276E 0031     
8270               
8271 2770 1508  14        jgt  PX1                        ; BPL PX1           ; If the x-coordinate offset is positive, jump to PX1
8272                                                                          ; to skip the following negation
8273               
8274                      .eoi (>7f*256)                  ; EOR #%01111111    ; The x-coordinate offset is negative, so flip all the
     **** ****     > EOI
0001 2772 0206  20        li   rtmp,(>7F*256)
     2774 7F00     
0002 2776 2806  18        xor  rtmp,ra
                   < elite.a99
8275                      .clc                            ; CLC               ; bits apart from the sign bit and add 1, to convert it
     **** ****     > CLC
0001 2778 0A13  18        sla  rzero,1
                   < elite.a99
8276                      .adi (>01*256)                  ; ADC #1            ; from a sign-magnitude number to a signed number
     **** ****     > ADI
0001 277A 1701  14        jnc  !
0002 277C B004  18        ab   rone,ra
0003               !:
0004 277E 0220  22        ai   ra,(>01*256)
     2780 0100     
                   < elite.a99
8277               
8278               PX1:
8279                      .eoi (>80*256)                  ; EOR #%10000000    ; Set X = X1 + 128
     **** ****     > EOI
0001 2782 0206  20        li   rtmp,(>80*256)
     2784 8000     
0002 2786 2806  18        xor  rtmp,ra
                   < elite.a99
8280 2788 D040  18        movb ra,rx                      ; TAX               ;
8281                                                                          ; So X is now the offset converted to an x-coordinate,
8282                                                                          ; centred on x-coordinate 128
8283               
8284 278A D020  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate offset into A and clear the
     278C 0032     
8285 278E 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; sign bit, so A = |Y1|
     2790 7F00     
8286               
8287 2792 0280  22        ci   ra,>60*256                 ; CMP #96           ; If |Y1| >= 96 then it's off the screen (as 96 is half
     2794 6000     
8288 2796 1851  14        joc  PX4                        ; BCS PX4           ; the screen height), so return from the subroutine (as
8289                                                                          ; PX4 contains an RTS)
8290               
8291 2798 D020  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate offset into A
     279A 0032     
8292               
8293 279C 1507  14        jgt  PX2                        ; BPL PX2           ; If the y-coordinate offset is positive, jump to PX2
8294                                                                          ; to skip the following negation
8295               
8296                      .eoi (>7f*256)                  ; EOR #%01111111    ; The y-coordinate offset is negative, so flip all the
     **** ****     > EOI
0001 279E 0206  20        li   rtmp,(>7F*256)
     27A0 7F00     
0002 27A2 2806  18        xor  rtmp,ra
                   < elite.a99
8297                      .adi (>01*256)                  ; ADC #1            ; bits apart from the sign bit and subtract 1, to negate
     **** ****     > ADI
0001 27A4 1701  14        jnc  !
0002 27A6 B004  18        ab   rone,ra
0003               !:
0004 27A8 0220  22        ai   ra,(>01*256)
     27AA 0100     
                   < elite.a99
8298                                                                          ; it to a positive number, i.e. A is now |Y1|
8299               
8300               PX2:
8301 27AC D800  30        movb ra,@T                      ; STA T             ; Set A = 97 - Y1
     27AE 00D1     
8302 27B0 0200  20        li   ra,>61*256                 ; LDA #97           ;
     27B2 6100     
8303                      .sbc @T,ra                      ; SBC T             ; So if Y is positive we display the point up from the
     **** ****     > SBC
0001 27B4 1801  14        joc  !
0002 27B6 7004  18        sb   rone,ra
0003               !:
0004 27B8 7020  30        sb   @T,ra
     27BA 00D1     
                   < elite.a99
8304                                                                          ; centre at y-coordinate 97, while a negative Y means
8305                                                                          ; down from the centre
8306               
8307                                                                          ; Fall through into PIXEL to draw the stardust at the
8308                                                                          ; screen coordinates in (X, A)
8309               
8310               * ******************************************************************************
8311               *
8312               * Name: PIXEL
8313               * Type: Subroutine
8314               * Category: Drawing pixels
8315               * Summary: Draw a 1-pixel dot, 2-pixel dash or 4-pixel square
8316               * Deep dive: Drawing monochrome pixels in mode 4
8317               *
8318               * ------------------------------------------------------------------------------
8319               *
8320               * Draw a point at screen coordinate (X, A) with the point size determined by the
8321               * distance in ZZ. This applies to the top part of the screen (the monochrome
8322               * mode 4 portion).
8323               *
8324               * ------------------------------------------------------------------------------
8325               *
8326               * Arguments:
8327               *
8328               * X                   The screen x-coordinate of the point to draw
8329               *
8330               * A                   The screen y-coordinate of the point to draw
8331               *
8332               * ZZ                  The distance of the point (further away = smaller point)
8333               *
8334               * ------------------------------------------------------------------------------
8335               *
8336               * Returns:
8337               *
8338               * Y                   Y is preserved
8339               *
8340               * ------------------------------------------------------------------------------
8341               *
8342               * Other entry points:
8343               *
8344               * PX4                 Contains an RTS
8345               *
8346               * ******************************************************************************
8347               
8348               PIXEL:
8349 27BC D802  30        movb ry,@T1                     ; STY T1            ; Store Y in T1
     27BE 0006     
8350               
8351 27C0 D080  18        movb ra,ry                      ; TAY               ; Copy A into Y, for use later
8352               
8353 27C2 0910  18        srl  ra,1                       ; LSR A             ; Set SCH = &60 + A >> 3
8354 27C4 0910  18        srl  ra,1                       ; LSR A
8355 27C6 0910  18        srl  ra,1                       ; LSR A
8356 27C8 0260  22        ori  ra,>60*256                 ; ORA #&60
     27CA 6000     
8357 27CC D800  30        movb ra,@SCH                    ; STA SCH
     27CE 0008     
8358               
8359 27D0 D001  18        movb rx,ra                      ; TXA               ; Set SC = (X >> 3) * 8
8360 27D2 0240  22        andi ra,>f8*256                 ; AND #%11111000
     27D4 F800     
8361 27D6 D800  30        movb ra,@SC                     ; STA SC
     27D8 0007     
8362               
8363 27DA D002  18        movb ry,ra                      ; TYA               ; Set Y = Y AND %111
8364 27DC 0240  22        andi ra,>07*256                 ; AND #%00000111
     27DE 0700     
8365 27E0 D080  18        movb ra,ry                      ; TAY
8366               
8367 27E2 D001  18        movb rx,ra                      ; TXA               ; Set X = X AND %111
8368 27E4 0240  22        andi ra,>07*256                 ; AND #%00000111
     27E6 0700     
8369 27E8 D040  18        movb ra,rx                      ; TAX
8370               
8371 27EA D020  30        movb @ZZ,ra                     ; LDA ZZ            ; If distance in ZZ >= 144, then this point is a very
     27EC 0097     
8372 27EE 0280  22        ci   ra,>90*256                 ; CMP #144          ; long way away, so jump to PX3 to fetch a 1-pixel point
     27F0 9000     
8373 27F2 18A3  14        joc  PX3                        ; BCS PX3           ; from TWOS and EOR it into SC+Y
8374               
8375 27F4 D021  34        movb @TWOS2(rx),ra              ; LDA TWOS2,X       ; Otherwise fetch a 2-pixel dash from TWOS2 and EOR it
     27F6 2241     
8376                      .eor @SC                        ; EOR (SC),Y        ; into SC+Y
     **** ****     > EOR
0001 27F8 D1A0  30        movb @SC,rtmp
     27FA 0007     
0002 27FC 2806  18        xor  rtmp,ra
                   < elite.a99
8377                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 27FE D820  50        movb @SC,@rtmplb
     2800 0007     
     2802 2079     
0002 2804 D1A0  30        movb @SC+1,rtmp
     2806 0008     
0003 2808 A182  18        a    ry,rtmp
0004 280A D580  30        movb RA,*rtmp
                   < elite.a99
8378               
8379 280C D020  30        movb @ZZ,ra                     ; LDA ZZ            ; If distance in ZZ >= 80, then this point is a medium
     280E 0097     
8380 2810 0280  22        ci   ra,>50*256                 ; CMP #80           ; distance away, so jump to PX13 to stop drawing, as a
     2812 5000     
8381 2814 1810  14        joc  PX13                       ; BCS PX13          ; 2-pixel dash is enough
8382               
8383                                                                          ; Otherwise we keep going to draw another 2 pixel point
8384                                                                          ; either above or below the one we just drew, to make a
8385                                                                          ; 4-pixel square
8386               
8387 2816 7084  18        sb   rone,ry                    ; DEY               ; Reduce Y by 1 to point to the pixel row above the one
8388 2818 1502  14        jgt  PX14                       ; BPL PX14          ; we just plotted, and if it is still positive, jump to
8389                                                                          ; PX14 to draw our second 2-pixel dash
8390               
8391 281A 0202  20        li   ry,>01*256                 ; LDY #1            ; Reducing Y by 1 made it negative, which means Y was
     281C 0100     
8392                                                                          ; 0 before we did the DEY above, so set Y to 1 to point
8393                                                                          ; to the pixel row after the one we just plotted
8394               
8395               PX14:
8396 281E D021  34        movb @TWOS2(rx),ra              ; LDA TWOS2,X       ; Fetch a 2-pixel dash from TWOS2 and EOR it into this
     2820 2241     
8397                      .eor @SC                        ; EOR (SC),Y        ; second row to make a 4-pixel square
     **** ****     > EOR
0001 2822 D1A0  30        movb @SC,rtmp
     2824 0007     
0002 2826 2806  18        xor  rtmp,ra
                   < elite.a99
8398                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 2828 D820  50        movb @SC,@rtmplb
     282A 0007     
     282C 2079     
0002 282E D1A0  30        movb @SC+1,rtmp
     2830 0008     
0003 2832 A182  18        a    ry,rtmp
0004 2834 D580  30        movb RA,*rtmp
                   < elite.a99
8399               
8400               PX13:
8401 2836 D0A0  30        movb @T1,ry                     ; LDY T1            ; Restore Y from T1, so Y is preserved by the routine
     2838 0006     
8402               
8403               PX4:
8404 283A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     283C FF1C     
8405               
8406               * ******************************************************************************
8407               *
8408               * Name: BLINE
8409               * Type: Subroutine
8410               * Category: Drawing circles
8411               * Summary: Draw a circle segment and add it to the ball line heap
8412               * Deep dive: The ball line heap
8413               * Drawing circles
8414               *
8415               * ------------------------------------------------------------------------------
8416               *
8417               * Draw a single segment of a circle, adding the point to the ball line heap.
8418               *
8419               * ------------------------------------------------------------------------------
8420               *
8421               * Arguments:
8422               *
8423               * CNT                 The number of this segment
8424               *
8425               * STP                 The step size for the circle
8426               *
8427               * K6(1 0)             The x-coordinate of the new point on the circle, as
8428               * a screen coordinate
8429               *
8430               * (T X)               The y-coordinate of the new point on the circle, as
8431               * an offset from the centre of the circle
8432               *
8433               * FLAG                Set to &FF for the first call, so it sets up the first
8434               * point in the heap but waits until the second call before
8435               * drawing anything (as we need two points, i.e. two calls,
8436               * before we can draw a line)
8437               *
8438               * K4(1 0)             Pixel y-coordinate of the centre of the circle
8439               *
8440               * K5(1 0)             Screen x-coordinate of the previous point added to the
8441               * ball line heap (if this is not the first point)
8442               *
8443               * K5(3 2)             Screen y-coordinate of the previous point added to the
8444               * ball line heap (if this is not the first point)
8445               *
8446               * ------------------------------------------------------------------------------
8447               *
8448               * Returns:
8449               *
8450               * CNT                 CNT is updated to CNT + STP
8451               *
8452               * A                   The new value of CNT
8453               *
8454               * K5(1 0)             Screen x-coordinate of the point that we just added to
8455               * the ball line heap
8456               *
8457               * K5(3 2)             Screen y-coordinate of the point that we just added to
8458               * the ball line heap
8459               *
8460               * FLAG                Set to 0
8461               *
8462               * ******************************************************************************
8463               
8464               BLINE:
8465 283E D001  18        movb rx,ra                      ; TXA               ; Set K6(3 2) = (T X) + K4(1 0)
8466                      .adc @K4,ra                     ; ADC K4            ; = y-coord of centre + y-coord of new point
     **** ****     > ADC
0001 2840 1701  14        jnc  !
0002 2842 B004  18        ab   rone,ra
0003               !:
0004 2844 B020  30        ab   @K4,ra
     2846 00E0     
                   < elite.a99
8467 2848 D800  30        movb ra,@K6+2                   ; STA K6+2          ;
     284A 0084     
8468 284C D020  30        movb @K4+1,ra                   ; LDA K4+1          ; so K6(3 2) now contains the y-coordinate of the new
     284E 00E1     
8469                      .adc @T,ra                      ; ADC T             ; point on the circle but as a screen coordinate, to go
     **** ****     > ADC
0001 2850 1701  14        jnc  !
0002 2852 B004  18        ab   rone,ra
0003               !:
0004 2854 B020  30        ab   @T,ra
     2856 00D1     
                   < elite.a99
8470 2858 D800  30        movb ra,@K6+3                   ; STA K6+3          ; along with the screen x-coordinate in K6(1 0)
     285A 0085     
8471               
8472 285C D020  30        movb @FLAG,ra                   ; LDA FLAG          ; If FLAG = 0, jump down to BL1
     285E 00A3     
8473 2860 130C  14        jeq  BL1                        ; BEQ BL1
8474               
8475 2862 B004  18        ab   rone,ra                    ; INC FLAG          ; Flag is &FF so this is the first call to BLINE, so
8476                                                                          ; increment FLAG to set it to 0, as then the next time
8477                                                                          ; we call BLINE it can draw the first line, from this
8478                                                                          ; point to the next
8479               
8480               BL5:
8481                                                                          ; The following inserts a &FF marker into the LSY2 line
8482                                                                          ; heap to indicate that the next call to BLINE should
8483                                                                          ; store both the (X1, Y1) and (X2, Y2) points. We do
8484                                                                          ; this on the very first call to BLINE (when FLAG is
8485                                                                          ; &FF), and on subsequent calls if the segment does not
8486                                                                          ; fit on-screen, in which case we don't draw or store
8487                                                                          ; that segment, and we start a new segment with the next
8488                                                                          ; call to BLINE that does fit on-screen
8489 2864 D0A0  30        movb @LSP,ry                    ; LDY LSP           ; If byte LSP-1 of LSY2 = &FF, jump to BL7 to tidy up
     2866 0077     
8490 2868 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; and return from the subroutine, as the point that has
     286A FF00     
8491 286C 9022  34        cb   @LSY2-1(ry),ra             ; CMP LSY2-1,Y      ; been passed to BLINE is the start of a segment, so all
     286E 0E73     
8492 2870 135E  14        jeq  BL7                        ; BEQ BL7           ; we need to do is save the coordinate in K5, without
8493                                                                          ; moving the pointer in LSP
8494               
8495 2872 D880  38        movb ra,@LSY2(ry)               ; STA LSY2,Y        ; Otherwise we just tried to plot a segment but it
     2874 0E74     
8496                                                                          ; didn't fit on-screen, so put the &FF marker into the
8497                                                                          ; heap for this point, so the next call to BLINE starts
8498                                                                          ; a new segment
8499               
8500 2876 B004  18        ab   rone,ra                    ; INC LSP           ; Increment LSP to point to the next point in the heap
8501               
8502 2878 165A  14        jne  BL7                        ; BNE BL7           ; Jump to BL7 to tidy up and return from the subroutine
8503                                                                          ; (this BNE is effectively a JMP, as LSP will never be
8504                                                                          ; zero)
8505               
8506               BL1:
8507 287A D020  30        movb @K5,ra                     ; LDA K5            ; Set XX15 = K5 = x_lo of previous point
     287C 007E     
8508 287E D800  30        movb ra,@XX15                   ; STA XX15
     2880 0031     
8509               
8510 2882 D020  30        movb @K5+1,ra                   ; LDA K5+1          ; Set XX15+1 = K5+1 = x_hi of previous point
     2884 007F     
8511 2886 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     2888 0032     
8512               
8513 288A D020  30        movb @K5+2,ra                   ; LDA K5+2          ; Set XX15+2 = K5+2 = y_lo of previous point
     288C 0080     
8514 288E D800  30        movb ra,@XX15+2                 ; STA XX15+2
     2890 0033     
8515               
8516 2892 D020  30        movb @K5+3,ra                   ; LDA K5+3          ; Set XX15+3 = K5+3 = y_hi of previous point
     2894 0081     
8517 2896 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     2898 0034     
8518               
8519 289A D020  30        movb @K6,ra                     ; LDA K6            ; Set XX15+4 = x_lo of new point
     289C 0082     
8520 289E D800  30        movb ra,@XX15+4                 ; STA XX15+4
     28A0 0035     
8521               
8522 28A2 D020  30        movb @K6+1,ra                   ; LDA K6+1          ; Set XX15+5 = x_hi of new point
     28A4 0083     
8523 28A6 D800  30        movb ra,@XX15+5                 ; STA XX15+5
     28A8 0036     
8524               
8525 28AA D020  30        movb @K6+2,ra                   ; LDA K6+2          ; Set XX12 = y_lo of new point
     28AC 0084     
8526 28AE D800  30        movb ra,@XX12                   ; STA XX12
     28B0 0037     
8527               
8528 28B2 D020  30        movb @K6+3,ra                   ; LDA K6+3          ; Set XX12+1 = y_hi of new point
     28B4 0085     
8529 28B6 D800  30        movb ra,@XX12+1                 ; STA XX12+1
     28B8 0038     
8530               
8531 28BA 0206  20        li   rtmp,LL145                 ; JSR LL145         ; Call LL145 to see if the new line segment needs to be
     28BC E56C     
8532 28BE 06A0  32        bl   @jsr                       ;
     28C0 FF10     
8533                                                                          ; clipped to fit on-screen, returning the clipped line's
8534                                                                          ; end-points in (X1, Y1) and (X2, Y2)
8535               
8536 28C2 18D0  14        joc  BL5                        ; BCS BL5           ; If the C flag is set then the line is not visible on
8537                                                                          ; screen anyway, so jump to BL5, to avoid drawing and
8538                                                                          ; storing this line
8539               
8540 28C4 D020  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0, then we didn't have to swap the line
     28C6 00A1     
8541 28C8 1310  14        jeq  BL9                        ; BEQ BL9           ; coordinates around during the clipping process, so
8542                                                                          ; jump to BL9 to skip the following swap
8543               
8544 28CA D020  30        movb @X1,ra                     ; LDA X1            ; Otherwise the coordinates were swapped by the call to
     28CC 0031     
8545 28CE D0A0  30        movb @X2,ry                     ; LDY X2            ; LL145 above, so we swap (X1, Y1) and (X2, Y2) back
     28D0 0033     
8546 28D2 D800  30        movb ra,@X2                     ; STA X2            ; again
     28D4 0033     
8547 28D6 D802  30        movb ry,@X1                     ; STY X1
     28D8 0031     
8548 28DA D020  30        movb @Y1,ra                     ; LDA Y1
     28DC 0032     
8549 28DE D0A0  30        movb @Y2,ry                     ; LDY Y2
     28E0 0034     
8550 28E2 D800  30        movb ra,@Y2                     ; STA Y2
     28E4 0034     
8551 28E6 D802  30        movb ry,@Y1                     ; STY Y1
     28E8 0032     
8552               
8553               BL9:
8554 28EA D0A0  30        movb @LSP,ry                    ; LDY LSP           ; Set Y = LSP
     28EC 0077     
8555               
8556 28EE D022  34        movb @LSY2-1(ry),ra             ; LDA LSY2-1,Y      ; If byte LSP-1 of LSY2 is not &FF, jump down to BL8
     28F0 0E73     
8557 28F2 0280  22        ci   ra,>ff*256                 ; CMP #&FF          ; to skip the following (X1, Y1) code
     28F4 FF00     
8558 28F6 1609  14        jne  BL8                        ; BNE BL8
8559               
8560                                                                          ; Byte LSP-1 of LSY2 is &FF, which indicates that we
8561                                                                          ; need to store (X1, Y1) in the heap
8562               
8563 28F8 D020  30        movb @X1,ra                     ; LDA X1            ; Store X1 in the LSP-th byte of LSX2
     28FA 0031     
8564 28FC D880  38        movb ra,@LSX2(ry)               ; STA LSX2,Y
     28FE 0E26     
8565               
8566 2900 D020  30        movb @Y1,ra                     ; LDA Y1            ; Store Y1 in the LSP-th byte of LSY2
     2902 0032     
8567 2904 D880  38        movb ra,@LSY2(ry)               ; STA LSY2,Y
     2906 0E74     
8568               
8569 2908 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next byte in LSX2/LSY2
8570               
8571               BL8:
8572 290A D020  30        movb @X2,ra                     ; LDA X2            ; Store X2 in the LSP-th byte of LSX2
     290C 0033     
8573 290E D880  38        movb ra,@LSX2(ry)               ; STA LSX2,Y
     2910 0E26     
8574               
8575 2912 D020  30        movb @Y2,ra                     ; LDA Y2            ; Store Y2 in the LSP-th byte of LSX2
     2914 0034     
8576 2916 D880  38        movb ra,@LSY2(ry)               ; STA LSY2,Y
     2918 0E74     
8577               
8578 291A B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next byte in LSX2/LSY2
8579               
8580 291C D802  30        movb ry,@LSP                    ; STY LSP           ; Update LSP to point to the same as Y
     291E 0077     
8581               
8582 2920 0206  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2)
     2922 224E     
8583 2924 06A0  32        bl   @jsr                       ;
     2926 FF10     
8584               
8585 2928 D020  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 is non-zero, jump up to BL5 to add a &FF
     292A 0098     
8586 292C 169B  14        jne  BL5                        ; BNE BL5           ; marker to the end of the line heap. XX13 is non-zero
8587                                                                          ; after the call to the clipping routine LL145 above if
8588                                                                          ; the end of the line was clipped, meaning the next line
8589                                                                          ; sent to BLINE can't join onto the end but has to start
8590                                                                          ; a new segment, and that's what inserting the &FF
8591                                                                          ; marker does
8592               
8593               BL7:
8594 292E D020  30        movb @K6,ra                     ; LDA K6            ; Copy the data for this step point from K6(3 2 1 0)
     2930 0082     
8595 2932 D800  30        movb ra,@K5                     ; STA K5            ; into K5(3 2 1 0), for use in the next call to BLINE:
     2934 007E     
8596 2936 D020  30        movb @K6+1,ra                   ; LDA K6+1          ;
     2938 0083     
8597 293A D800  30        movb ra,@K5+1                   ; STA K5+1          ; * K5(1 0) = screen x-coordinate of this point
     293C 007F     
8598 293E D020  30        movb @K6+2,ra                   ; LDA K6+2          ;
     2940 0084     
8599 2942 D800  30        movb ra,@K5+2                   ; STA K5+2          ; * K5(3 2) = screen y-coordinate of this point
     2944 0080     
8600 2946 D020  30        movb @K6+3,ra                   ; LDA K6+3          ;
     2948 0085     
8601 294A D800  30        movb ra,@K5+3                   ; STA K5+3          ; They now become the "previous point" in the next call
     294C 0081     
8602               
8603 294E D020  30        movb @CNT,ra                    ; LDA CNT           ; Set CNT = CNT + STP
     2950 00A4     
8604                      .clc                            ; CLC
     **** ****     > CLC
0001 2952 0A13  18        sla  rzero,1
                   < elite.a99
8605                      .adc @STP,ra                    ; ADC STP
     **** ****     > ADC
0001 2954 1701  14        jnc  !
0002 2956 B004  18        ab   rone,ra
0003               !:
0004 2958 B020  30        ab   @STP,ra
     295A 00A6     
                   < elite.a99
8606 295C D800  30        movb ra,@CNT                    ; STA CNT
     295E 00A4     
8607               
8608 2960 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2962 FF1C     
8609               
8610               * ******************************************************************************
8611               *
8612               * Name: FLIP
8613               * Type: Subroutine
8614               * Category: Stardust
8615               * Summary: Reflect the stardust particles in the screen diagonal and redraw
8616               * the stardust field
8617               *
8618               * ------------------------------------------------------------------------------
8619               *
8620               * Swap the x- and y-coordinates of all the stardust particles and draw the new
8621               * set of particles. Called by LOOK1 when we switch views.
8622               *
8623               * This is a quick way of making the stardust field in the new view feel
8624               * different without having to generate a whole new field. If you look carefully
8625               * at the stardust field when you switch views, you can just about see that the
8626               * new field is a reflection of the previous field in the screen diagonal, i.e.
8627               * in the line from bottom left to top right. This is the line where x = y when
8628               * the origin is in the middle of the screen, and positive x and y are right and
8629               * up, which is the coordinate system we use for stardust).
8630               *
8631               * ******************************************************************************
8632               
8633               FLIP:
8634               * LDA MJ                 \ These instructions are commented out in the original
8635               * BNE FLIP-1             \ source. They would have the effect of not swapping the
8636                                                                          ; stardust if we had mis-jumped into witchspace
8637 2964 D0A0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     2966 0F33     
8638                                                                          ; we can use it as a counter through all the stardust
8639               
8640               FLL1:
8641 2968 D062  34        movb @SY(ry),rx                 ; LDX SY,Y          ; Copy the Y-th particle's y-coordinate from SY+Y into X
     296A 0EC2     
8642               
8643 296C D022  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Copy the Y-th particle's x-coordinate from SX+Y into
     296E 034C     
8644 2970 D800  30        movb ra,@Y1                     ; STA Y1            ; both Y1 and the particle's y-coordinate
     2972 0032     
8645 2974 D880  38        movb ra,@SY(ry)                 ; STA SY,Y
     2976 0EC2     
8646               
8647 2978 D001  18        movb rx,ra                      ; TXA               ; Copy the Y-th particle's original y-coordinate into
8648 297A D800  30        movb ra,@X1                     ; STA X1            ; both X1 and the particle's x-coordinate, so the x- and
     297C 0031     
8649 297E D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; y-coordinates are now swapped and (X1, Y1) contains
     2980 034C     
8650                                                                          ; the particle's new coordinates
8651               
8652 2982 D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Fetch the Y-th particle's distance from SZ+Y into ZZ
     2984 0EE8     
8653 2986 D800  30        movb ra,@ZZ                     ; STA ZZ
     2988 0097     
8654               
8655 298A 0206  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ
     298C 276C     
8656 298E 06A0  32        bl   @jsr                       ;
     2990 FF10     
8657               
8658 2992 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point to the next particle of
8659                                                                          ; stardust
8660               
8661 2994 16E9  14        jne  FLL1                       ; BNE FLL1          ; Loop back to FLL1 until we have moved all the stardust
8662                                                                          ; particles
8663               
8664 2996 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2998 FF1C     
8665               
8666               * ******************************************************************************
8667               *
8668               * Name: STARS
8669               * Type: Subroutine
8670               * Category: Stardust
8671               * Summary: The main routine for processing the stardust
8672               *
8673               * ------------------------------------------------------------------------------
8674               *
8675               * Called at the very end of the main flight loop.
8676               *
8677               * ******************************************************************************
8678               
8679               STARS:
8680               * LDA #&FF               \ These instructions are commented out in the original
8681               * STA COL                \ source, but they would set the stardust colour to
8682                                                                          ; white. That said, COL is only used when updating the
8683                                                                          ; dashboard, so this would have no effect - perhaps it's
8684                                                                          ; left over from experiments with a colour top part of
8685                                                                          ; the screen? Who knows...
8686 299A D060  30        movb @VIEW,rx                   ; LDX VIEW          ; Load the current view into X:
     299C 0D5F     
8687                                                                          ;
8688                                                                          ; 0 = front
8689                                                                          ; 1 = rear
8690                                                                          ; 2 = left
8691                                                                          ; 3 = right
8692               
8693 299E 1306  14        jeq  STARS1                     ; BEQ STARS1        ; If this 0, jump to STARS1 to process the stardust for
8694                                                                          ; the front view
8695               
8696 29A0 7044  18        sb   rone,rx                    ; DEX               ; If this is view 2 or 3, jump to STARS2 (via ST11) to
8697 29A2 1602  14        jne  ST11                       ; BNE ST11          ; process the stardust for the left or right views
8698               
8699 29A4 0460  28        b    @STARS6                    ; JMP STARS6        ; Otherwise this is the rear view, so jump to STARS6 to
     29A6 2BBA     
8700                                                                          ; process the stardust for the rear view
8701               
8702               ST11:
8703 29A8 0460  28        b    @STARS2                    ; JMP STARS2        ; Jump to STARS2 for the left or right views, as it's
     29AA 3F04     
8704                                                                          ; too far for the branch instruction above
8705               
8706               * ******************************************************************************
8707               *
8708               * Name: STARS1
8709               * Type: Subroutine
8710               * Category: Stardust
8711               * Summary: Process the stardust for the front view
8712               * Deep dive: Stardust in the front view
8713               *
8714               * ------------------------------------------------------------------------------
8715               *
8716               * This moves the stardust towards us according to our speed (so the dust rushes
8717               * past us), and applies our current pitch and roll to each particle of dust, so
8718               * the stardust moves correctly when we steer our ship.
8719               *
8720               * When a stardust particle rushes past us and falls off the side of the screen,
8721               * its memory is recycled as a new particle that's positioned randomly on-screen.
8722               *
8723               * These are the calculations referred to in the commentary:
8724               *
8725               * 1. q = 64 * speed / z_hi
8726               * 2. z = z - speed * 64
8727               * 3. y = y + |y_hi| * q
8728               * 4. x = x + |x_hi| * q
8729               *
8730               * 5. y = y + alpha * x / 256
8731               * 6. x = x - alpha * y / 256
8732               *
8733               * 7. x = x + 2 * (beta * y / 256) ^ 2
8734               * 8. y = y - beta * 256
8735               *
8736               * For more information see the deep dive on "Stardust in the front view".
8737               *
8738               * ******************************************************************************
8739               
8740               STARS1:
8741 29AC D0A0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     29AE 0F33     
8742                                                                          ; we can use it as a counter through all the stardust
8743               
8744                                                                          ; In the following, we're going to refer to the 16-bit
8745                                                                          ; space coordinates of the current particle of stardust
8746                                                                          ; (i.e. the Y-th particle) like this:
8747                                                                          ;
8748                                                                          ; x = (x_hi x_lo)
8749                                                                          ; y = (y_hi y_lo)
8750                                                                          ; z = (z_hi z_lo)
8751                                                                          ;
8752                                                                          ; These values are stored in (SX+Y SXL+Y), (SY+Y SYL+Y)
8753                                                                          ; and (SZ+Y SZL+Y) respectively
8754               
8755               STL1:
8756 29B0 0206  20        li   rtmp,DV42                  ; JSR DV42          ; Call DV42 to set the following:
     29B2 45A4     
8757 29B4 06A0  32        bl   @jsr                       ;
     29B6 FF10     
8758                                                                          ;
8759                                                                          ; (P R) = 256 * DELTA / z_hi
8760                                                                          ; = 256 * speed / z_hi
8761                                                                          ;
8762                                                                          ; The maximum value returned is P = 2 and R = 128 (see
8763                                                                          ; DV42 for an explanation)
8764               
8765 29B8 D020  30        movb @R,ra                      ; LDA R             ; Set A = R, so now:
     29BA 0091     
8766                                                                          ;
8767                                                                          ; (P A) = 256 * speed / z_hi
8768               
8769                      .lsr @P                         ; LSR P             ; Rotate (P A) right by 2 places, which sets P = 0 (as P
     **** ****     > LSR
0001 29BC D1A0  30        movb @P,rtmp
     29BE 001B     
0002 29C0 0916  18        srl  rtmp,1
0003 29C2 D806  30        movb rtmp,@P
     29C4 001B     
                   < elite.a99
8770 29C6 06A0  32        bl   @rora                      ; ROR A             ; has a maximum value of 2) and leaves:
     29C8 FF4A     
8771                      .lsr @P                         ; LSR P             ;
     **** ****     > LSR
0001 29CA D1A0  30        movb @P,rtmp
     29CC 001B     
0002 29CE 0916  18        srl  rtmp,1
0003 29D0 D806  30        movb rtmp,@P
     29D2 001B     
                   < elite.a99
8772 29D4 06A0  32        bl   @rora                      ; ROR A             ; A = 64 * speed / z_hi
     29D6 FF4A     
8773               
8774 29D8 0260  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1, and store it in Q, so we
     29DA 0100     
8775 29DC D800  30        movb ra,@Q                      ; STA Q             ; now have result 1 above:
     29DE 0090     
8776                                                                          ;
8777                                                                          ; Q = 64 * speed / z_hi
8778               
8779 29E0 D022  34        movb @SZL(ry),ra                ; LDA SZL,Y         ; We now calculate the following:
     29E2 0EFB     
8780                      .sbc @DELT4,ra                  ; SBC DELT4         ;
     **** ****     > SBC
0001 29E4 1801  14        joc  !
0002 29E6 7004  18        sb   rone,ra
0003               !:
0004 29E8 7020  30        sb   @DELT4,ra
     29EA 008D     
                   < elite.a99
8781 29EC D880  38        movb ra,@SZL(ry)                ; STA SZL,Y         ; (z_hi z_lo) = (z_hi z_lo) - DELT4(1 0)
     29EE 0EFB     
8782                                                                          ;
8783                                                                          ; starting with the low bytes
8784               
8785 29F0 D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; And then we do the high bytes
     29F2 0EE8     
8786 29F4 D800  30        movb ra,@ZZ                     ; STA ZZ            ;
     29F6 0097     
8787                      .sbc @DELT4+1,ra                ; SBC DELT4+1       ; We also set ZZ to the original value of z_hi, which we
     **** ****     > SBC
0001 29F8 1801  14        joc  !
0002 29FA 7004  18        sb   rone,ra
0003               !:
0004 29FC 7020  30        sb   @DELT4+1,ra
     29FE 008E     
                   < elite.a99
8788 2A00 D880  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; use below to remove the existing particle
     2A02 0EE8     
8789                                                                          ;
8790                                                                          ; So now we have result 2 above:
8791                                                                          ;
8792                                                                          ; z = z - DELT4(1 0)
8793                                                                          ; = z - speed * 64
8794               
8795 2A04 0206  20        li   rtmp,MLU1                  ; JSR MLU1          ; Call MLU1 to set:
     2A06 42CE     
8796 2A08 06A0  32        bl   @jsr                       ;
     2A0A FF10     
8797                                                                          ;
8798                                                                          ; Y1 = y_hi
8799                                                                          ;
8800                                                                          ; (A P) = |y_hi| * Q
8801                                                                          ;
8802                                                                          ; So Y1 contains the original value of y_hi, which we
8803                                                                          ; use below to remove the existing particle
8804               
8805                                                                          ; We now calculate:
8806                                                                          ;
8807                                                                          ; (S R) = YY(1 0) = (A P) + y
8808               
8809 2A0C D800  30        movb ra,@YY+1                   ; STA YY+1          ; First we do the low bytes with:
     2A0E 0027     
8810 2A10 D020  30        movb @P,ra                      ; LDA P             ;
     2A12 001B     
8811                      .adc @SYL(ry),ra                ; ADC SYL,Y         ; YY+1 = A
     **** ****     > ADC
0001 2A14 1701  14        jnc  !
0002 2A16 B004  18        ab   rone,ra
0003               !:
0004 2A18 B022  34        ab   @SYL(RY),ra
     2A1A 0ED5     
                   < elite.a99
8812 2A1C D800  30        movb ra,@YY                     ; STA YY            ; R = YY = P + y_lo
     2A1E 0026     
8813 2A20 D800  30        movb ra,@R                      ; STA R             ;
     2A22 0091     
8814                                                                          ; so we get this:
8815                                                                          ;
8816                                                                          ; (? R) = YY(1 0) = (A P) + y_lo
8817               
8818 2A24 D020  30        movb @Y1,ra                     ; LDA Y1            ; And then we do the high bytes with:
     2A26 0032     
8819                      .adc @YY+1,ra                   ; ADC YY+1          ;
     **** ****     > ADC
0001 2A28 1701  14        jnc  !
0002 2A2A B004  18        ab   rone,ra
0003               !:
0004 2A2C B020  30        ab   @YY+1,ra
     2A2E 0027     
                   < elite.a99
8820 2A30 D800  30        movb ra,@YY+1                   ; STA YY+1          ; S = YY+1 = y_hi + YY+1
     2A32 0027     
8821 2A34 D800  30        movb ra,@S                      ; STA S             ;
     2A36 0092     
8822                                                                          ; so we get our result:
8823                                                                          ;
8824                                                                          ; (S R) = YY(1 0) = (A P) + (y_hi y_lo)
8825                                                                          ; = |y_hi| * Q + y
8826                                                                          ;
8827                                                                          ; which is result 3 above, and (S R) is set to the new
8828                                                                          ; value of y
8829               
8830 2A38 D022  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Set X1 = A = x_hi
     2A3A 034C     
8831 2A3C D800  30        movb ra,@X1                     ; STA X1            ;
     2A3E 0031     
8832                                                                          ; So X1 contains the original value of x_hi, which we
8833                                                                          ; use below to remove the existing particle
8834               
8835 2A40 0206  20        li   rtmp,MLU2                  ; JSR MLU2          ; Set (A P) = |x_hi| * Q
     2A42 42D6     
8836 2A44 06A0  32        bl   @jsr                       ;
     2A46 FF10     
8837               
8838                                                                          ; We now calculate:
8839                                                                          ;
8840                                                                          ; XX(1 0) = (A P) + x
8841               
8842 2A48 D800  30        movb ra,@XX+1                   ; STA XX+1          ; First we do the low bytes:
     2A4A 0025     
8843 2A4C D020  30        movb @P,ra                      ; LDA P             ;
     2A4E 001B     
8844                      .adc @SXL(ry),ra                ; ADC SXL,Y         ; XX(1 0) = (A P) + x_lo
     **** ****     > ADC
0001 2A50 1701  14        jnc  !
0002 2A52 B004  18        ab   rone,ra
0003               !:
0004 2A54 B022  34        ab   @SXL(RY),ra
     2A56 035F     
                   < elite.a99
8845 2A58 D800  30        movb ra,@XX                     ; STA XX
     2A5A 0024     
8846               
8847 2A5C D020  30        movb @X1,ra                     ; LDA X1            ; And then we do the high bytes:
     2A5E 0031     
8848                      .adc @XX+1,ra                   ; ADC XX+1          ;
     **** ****     > ADC
0001 2A60 1701  14        jnc  !
0002 2A62 B004  18        ab   rone,ra
0003               !:
0004 2A64 B020  30        ab   @XX+1,ra
     2A66 0025     
                   < elite.a99
8849 2A68 D800  30        movb ra,@XX+1                   ; STA XX+1          ; XX(1 0) = XX(1 0) + (x_hi 0)
     2A6A 0025     
8850                                                                          ;
8851                                                                          ; so we get our result:
8852                                                                          ;
8853                                                                          ; XX(1 0) = (A P) + x
8854                                                                          ; = |x_hi| * Q + x
8855                                                                          ;
8856                                                                          ; which is result 4 above, and we also have:
8857                                                                          ;
8858                                                                          ; A = XX+1 = (|x_hi| * Q + x) / 256
8859                                                                          ;
8860                                                                          ; i.e. A is the new value of x, divided by 256
8861               
8862                      .eor @ALP2+1                    ; EOR ALP2+1        ; EOR with the flipped sign of the roll angle alpha, so
     **** ****     > EOR
0001 2A6C D1A0  30        movb @ALP2+1,rtmp
     2A6E 0089     
0002 2A70 2806  18        xor  rtmp,ra
                   < elite.a99
8863                                                                          ; A has the opposite sign to the flipped roll angle
8864                                                                          ; alpha, i.e. it gets the same sign as alpha
8865               
8866 2A72 0206  20        li   rtmp,MLS1                  ; JSR MLS1          ; Call MLS1 to calculate:
     2A74 41EE     
8867 2A76 06A0  32        bl   @jsr                       ;
     2A78 FF10     
8868                                                                          ;
8869                                                                          ; (A P) = A * ALP1
8870                                                                          ; = (x / 256) * alpha
8871               
8872 2A7A 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2A7C 44BA     
8873 2A7E 06A0  32        bl   @jsr                       ;
     2A80 FF10     
8874                                                                          ;
8875                                                                          ; (A X) = (A P) + (S R)
8876                                                                          ; = (x / 256) * alpha + y
8877                                                                          ; = y + alpha * x / 256
8878               
8879 2A82 D800  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY(1 0) = (A X) to give:
     2A84 0027     
8880 2A86 D801  30        movb rx,@YY                     ; STX YY            ;
     2A88 0026     
8881                                                                          ; YY(1 0) = y + alpha * x / 256
8882                                                                          ;
8883                                                                          ; which is result 5 above, and we also have:
8884                                                                          ;
8885                                                                          ; A = YY+1 = y + alpha * x / 256
8886                                                                          ;
8887                                                                          ; i.e. A is the new value of y, divided by 256
8888               
8889                      .eor @ALP2                      ; EOR ALP2          ; EOR A with the correct sign of the roll angle alpha,
     **** ****     > EOR
0001 2A8A D1A0  30        movb @ALP2,rtmp
     2A8C 0088     
0002 2A8E 2806  18        xor  rtmp,ra
                   < elite.a99
8890                                                                          ; so A has the opposite sign to the roll angle alpha
8891               
8892 2A90 0206  20        li   rtmp,MLS2                  ; JSR MLS2          ; Call MLS2 to calculate:
     2A92 41DE     
8893 2A94 06A0  32        bl   @jsr                       ;
     2A96 FF10     
8894                                                                          ;
8895                                                                          ; (S R) = XX(1 0)
8896                                                                          ; = x
8897                                                                          ;
8898                                                                          ; (A P) = A * ALP1
8899                                                                          ; = -y / 256 * alpha
8900               
8901 2A98 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2A9A 44BA     
8902 2A9C 06A0  32        bl   @jsr                       ;
     2A9E FF10     
8903                                                                          ;
8904                                                                          ; (A X) = (A P) + (S R)
8905                                                                          ; = -y / 256 * alpha + x
8906               
8907 2AA0 D800  30        movb ra,@XX+1                   ; STA XX+1          ; Set XX(1 0) = (A X), which gives us result 6 above:
     2AA2 0025     
8908 2AA4 D801  30        movb rx,@XX                     ; STX XX            ;
     2AA6 0024     
8909                                                                          ; x = x - alpha * y / 256
8910               
8911 2AA8 D060  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the pitch magnitude into X
     2AAA 002B     
8912               
8913 2AAC D020  30        movb @YY+1,ra                   ; LDA YY+1          ; Set A to y_hi and set it to the flipped sign of beta
     2AAE 0027     
8914                      .eor @BET2+1                    ; EOR BET2+1
     **** ****     > EOR
0001 2AB0 D1A0  30        movb @BET2+1,rtmp
     2AB2 008B     
0002 2AB4 2806  18        xor  rtmp,ra
                   < elite.a99
8915               
8916 2AB6 0206  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     2AB8 41F4     
8917 2ABA 06A0  32        bl   @jsr                       ;
     2ABC FF10     
8918                                                                          ;
8919                                                                          ; (A P) = X * A
8920                                                                          ; = -beta * y_hi
8921               
8922 2ABE D800  30        movb ra,@Q                      ; STA Q             ; Store the high byte of the result in Q, so:
     2AC0 0090     
8923                                                                          ;
8924                                                                          ; Q = -beta * y_hi / 256
8925               
8926 2AC2 0206  20        li   rtmp,MUT2                  ; JSR MUT2          ; Call MUT2 to calculate:
     2AC4 43E4     
8927 2AC6 06A0  32        bl   @jsr                       ;
     2AC8 FF10     
8928                                                                          ;
8929                                                                          ; (S R) = XX(1 0) = x
8930                                                                          ;
8931                                                                          ; (A P) = Q * A
8932                                                                          ; = (-beta * y_hi / 256) * (-beta * y_hi / 256)
8933                                                                          ; = (beta * y / 256) ^ 2
8934               
8935                      .asl @P                         ; ASL P             ; Double (A P), store the top byte in A and set the C
     **** ****     > ASL
0001 2ACA D1A0  30        movb @P,rtmp
     2ACC 001B     
0002 2ACE 0246  22        andi rtmp,>ff00
     2AD0 FF00     
0003 2AD2 0A16  18        sla  rtmp,1
0004 2AD4 D806  30        movb rtmp,@P
     2AD6 001B     
                   < elite.a99
8936 2AD8 06A0  32        bl   @rola                      ; ROL A             ; flag to bit 7 of the original A, so this does:
     2ADA FF26     
8937 2ADC D800  30        movb ra,@T                      ; STA T             ;
     2ADE 00D1     
8938                                                                          ; (T P) = (A P) << 1
8939                                                                          ; = 2 * (beta * y / 256) ^ 2
8940               
8941 2AE0 0200  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 in A to the sign bit from the A in the
     2AE2 0000     
8942 2AE4 06A0  32        bl   @rora                      ; ROR A             ; calculation above and apply it to T, so we now have:
     2AE6 FF4A     
8943 2AE8 F020  30        socb @T,ra                      ; ORA T             ;
     2AEA 00D1     
8944                                                                          ; (A P) = (A P) * 2
8945                                                                          ; = 2 * (beta * y / 256) ^ 2
8946                                                                          ;
8947                                                                          ; with the doubling retaining the sign of (A P)
8948               
8949 2AEC 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2AEE 44BA     
8950 2AF0 06A0  32        bl   @jsr                       ;
     2AF2 FF10     
8951                                                                          ;
8952                                                                          ; (A X) = (A P) + (S R)
8953                                                                          ; = 2 * (beta * y / 256) ^ 2 + x
8954               
8955 2AF4 D800  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     2AF6 0025     
8956               
8957 2AF8 D001  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
8958 2AFA D880  38        movb ra,@SXL(ry)                ; STA SXL,Y
     2AFC 035F     
8959               
8960                                                                          ; So (XX+1 x_lo) now contains:
8961                                                                          ;
8962                                                                          ; x = x + 2 * (beta * y / 256) ^ 2
8963                                                                          ;
8964                                                                          ; which is result 7 above
8965               
8966 2AFE D020  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0) = y
     2B00 0026     
8967 2B02 D800  30        movb ra,@R                      ; STA R
     2B04 0091     
8968 2B06 D020  30        movb @YY+1,ra                   ; LDA YY+1
     2B08 0027     
8969               * JSR MAD                \ These instructions are commented out in the original
8970               * STA S                  \ source
8971               * STX R
8972 2B0A D800  30        movb ra,@S                      ; STA S
     2B0C 0092     
8973               
8974 2B0E 0200  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     2B10 0000     
8975 2B12 D800  30        movb ra,@P                      ; STA P
     2B14 001B     
8976               
8977 2B16 D020  30        movb @BETA,ra                   ; LDA BETA          ; Set A = -beta, so:
     2B18 002A     
8978                      .eoi (>80*256)                  ; EOR #%10000000    ;
     **** ****     > EOI
0001 2B1A 0206  20        li   rtmp,(>80*256)
     2B1C 8000     
0002 2B1E 2806  18        xor  rtmp,ra
                   < elite.a99
8979                                                                          ; (A P) = (-beta 0)
8980                                                                          ; = -beta * 256
8981               
8982 2B20 0206  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     2B22 275A     
8983 2B24 06A0  32        bl   @jsr                       ;
     2B26 FF10     
8984                                                                          ;
8985                                                                          ; (YY+1 y_lo) = (A P) + (S R)
8986                                                                          ; = -beta * 256 + y
8987                                                                          ;
8988                                                                          ; i.e. y = y - beta * 256, which is result 8 above
8989                                                                          ;
8990                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
8991                                                                          ; ZZ, which will remove the old stardust particle, as we
8992                                                                          ; set X1, Y1 and ZZ to the original values for this
8993                                                                          ; particle during the calculations above
8994               
8995                                                                          ; We now have our newly moved stardust particle at
8996                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
8997                                                                          ; and distance z_hi, so we draw it if it's still on
8998                                                                          ; screen, otherwise we recycle it as a new bit of
8999                                                                          ; stardust and draw that
9000               
9001 2B28 D020  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     2B2A 0025     
9002 2B2C D800  30        movb ra,@X1                     ; STA X1            ; the new x-coordinate is in (x_hi x_lo) and the high
     2B2E 0031     
9003 2B30 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; byte is in X1
     2B32 034C     
9004               
9005 2B34 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; If |x_hi| >= 120 then jump to KILL1 to recycle this
     2B36 7F00     
9006 2B38 0280  22        ci   ra,>78*256                 ; CMP #120          ; particle, as it's gone off the side of the screen,
     2B3A 7800     
9007 2B3C 181C  14        joc  KILL1                      ; BCS KILL1         ; and rejoin at STC1 with the new particle
9008               
9009 2B3E D020  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     2B40 0027     
9010 2B42 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     2B44 0EC2     
9011 2B46 D800  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     2B48 0032     
9012               
9013 2B4A 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 120 then jump to KILL1 to recycle this
     2B4C 7F00     
9014 2B4E 0280  22        ci   ra,>78*256                 ; CMP #120          ; particle, as it's gone off the top or bottom of the
     2B50 7800     
9015 2B52 1811  14        joc  KILL1                      ; BCS KILL1         ; screen, and rejoin at STC1 with the new particle
9016               
9017 2B54 D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; If z_hi < 16 then jump to KILL1 to recycle this
     2B56 0EE8     
9018 2B58 0280  22        ci   ra,>10*256                 ; CMP #16           ; particle, as it's so close that it's effectively gone
     2B5A 1000     
9019 2B5C 170C  14        jnc  KILL1                      ; BCC KILL1         ; past us, and rejoin at STC1 with the new particle
9020               
9021 2B5E D800  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the z-coordinate in z_hi
     2B60 0097     
9022               
9023               STC1:
9024 2B62 0206  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     2B64 276C     
9025 2B66 06A0  32        bl   @jsr                       ;
     2B68 FF10     
9026                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
9027                                                                          ; with distance z_hi
9028               
9029 2B6A 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
9030                                                                          ; stardust particle
9031               
9032 2B6C 1302  14        jeq  B18                        ; BEQ B18           ; If we have just done the last particle, skip the next
9033                                                                          ; instruction to return from the subroutine
9034               
9035 2B6E 0460  28        b    @STL1                      ; JMP STL1          ; We have more stardust to process, so jump back up to
     2B70 29B0     
9036                                                                          ; STL1 for the next particle
9037               
9038               B18:
9039 2B72 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2B74 FF1C     
9040               
9041               KILL1:
9042                                                                          ; Our particle of stardust just flew past us, so let's
9043                                                                          ; recycle that particle, starting it at a random
9044                                                                          ; position that isn't too close to the centre point
9045 2B76 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2B78 C07C     
9046 2B7A 06A0  32        bl   @jsr                       ;
     2B7C FF10     
9047               
9048 2B7E 0260  22        ori  ra,>04*256                 ; ORA #4            ; Make sure A is at least 4 and store it in Y1 and y_hi,
     2B80 0400     
9049 2B82 D800  30        movb ra,@Y1                     ; STA Y1            ; so the new particle starts at least 4 pixels above or
     2B84 0032     
9050 2B86 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; below the centre of the screen
     2B88 0EC2     
9051               
9052 2B8A 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2B8C C07C     
9053 2B8E 06A0  32        bl   @jsr                       ;
     2B90 FF10     
9054               
9055 2B92 0260  22        ori  ra,>08*256                 ; ORA #8            ; Make sure A is at least 8 and store it in X1 and x_hi,
     2B94 0800     
9056 2B96 D800  30        movb ra,@X1                     ; STA X1            ; so the new particle starts at least 8 pixels either
     2B98 0031     
9057 2B9A D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; side of the centre of the screen
     2B9C 034C     
9058               
9059 2B9E 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2BA0 C07C     
9060 2BA2 06A0  32        bl   @jsr                       ;
     2BA4 FF10     
9061               
9062 2BA6 0260  22        ori  ra,>90*256                 ; ORA #144          ; Make sure A is at least 144 and store it in ZZ and
     2BA8 9000     
9063 2BAA D880  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; z_hi so the new particle starts in the far distance
     2BAC 0EE8     
9064 2BAE D800  30        movb ra,@ZZ                     ; STA ZZ
     2BB0 0097     
9065               
9066 2BB2 D020  30        movb @Y1,ra                     ; LDA Y1            ; Set A to the new value of y_hi. This has no effect as
     2BB4 0032     
9067                                                                          ; STC1 starts with a jump to PIXEL2, which starts with a
9068                                                                          ; LDA instruction
9069               
9070 2BB6 0460  28        b    @STC1                      ; JMP STC1          ; Jump up to STC1 to draw this new particle
     2BB8 2B62     
9071               
9072               * ******************************************************************************
9073               *
9074               * Name: STARS6
9075               * Type: Subroutine
9076               * Category: Stardust
9077               * Summary: Process the stardust for the rear view
9078               *
9079               * ------------------------------------------------------------------------------
9080               *
9081               * This routine is very similar to STARS1, which processes stardust for the front
9082               * view. The main difference is that the direction of travel is reversed, so the
9083               * signs in the calculations are different, as well as the order of the first
9084               * batch of calculations.
9085               *
9086               * When a stardust particle falls away into the far distance, it is removed from
9087               * the screen and its memory is recycled as a new particle, positioned randomly
9088               * along one of the four edges of the screen.
9089               *
9090               * These are the calculations referred to in the commentary:
9091               *
9092               * 1. q = 64 * speed / z_hi
9093               * 2. z = z - speed * 64
9094               * 3. y = y + |y_hi| * q
9095               * 4. x = x + |x_hi| * q
9096               *
9097               * 5. y = y + alpha * x / 256
9098               * 6. x = x - alpha * y / 256
9099               *
9100               * 7. x = x + 2 * (beta * y / 256) ^ 2
9101               * 8. y = y - beta * 256
9102               *
9103               * For more information see the deep dive on "Stardust in the front view".
9104               *
9105               * ******************************************************************************
9106               
9107               STARS6:
9108 2BBA D0A0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     2BBC 0F33     
9109                                                                          ; we can use it as a counter through all the stardust
9110               
9111               STL6:
9112 2BBE 0206  20        li   rtmp,DV42                  ; JSR DV42          ; Call DV42 to set the following:
     2BC0 45A4     
9113 2BC2 06A0  32        bl   @jsr                       ;
     2BC4 FF10     
9114                                                                          ;
9115                                                                          ; (P R) = 256 * DELTA / z_hi
9116                                                                          ; = 256 * speed / z_hi
9117                                                                          ;
9118                                                                          ; The maximum value returned is P = 2 and R = 128 (see
9119                                                                          ; DV42 for an explanation)
9120               
9121 2BC6 D020  30        movb @R,ra                      ; LDA R             ; Set A = R, so now:
     2BC8 0091     
9122                                                                          ;
9123                                                                          ; (P A) = 256 * speed / z_hi
9124               
9125                      .lsr @P                         ; LSR P             ; Rotate (P A) right by 2 places, which sets P = 0 (as P
     **** ****     > LSR
0001 2BCA D1A0  30        movb @P,rtmp
     2BCC 001B     
0002 2BCE 0916  18        srl  rtmp,1
0003 2BD0 D806  30        movb rtmp,@P
     2BD2 001B     
                   < elite.a99
9126 2BD4 06A0  32        bl   @rora                      ; ROR A             ; has a maximum value of 2) and leaves:
     2BD6 FF4A     
9127                      .lsr @P                         ; LSR P             ;
     **** ****     > LSR
0001 2BD8 D1A0  30        movb @P,rtmp
     2BDA 001B     
0002 2BDC 0916  18        srl  rtmp,1
0003 2BDE D806  30        movb rtmp,@P
     2BE0 001B     
                   < elite.a99
9128 2BE2 06A0  32        bl   @rora                      ; ROR A             ; A = 64 * speed / z_hi
     2BE4 FF4A     
9129               
9130 2BE6 0260  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1, and store it in Q, so we
     2BE8 0100     
9131 2BEA D800  30        movb ra,@Q                      ; STA Q             ; now have result 1 above:
     2BEC 0090     
9132                                                                          ;
9133                                                                          ; Q = 64 * speed / z_hi
9134               
9135 2BEE D022  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Set X1 = A = x_hi
     2BF0 034C     
9136 2BF2 D800  30        movb ra,@X1                     ; STA X1            ;
     2BF4 0031     
9137                                                                          ; So X1 contains the original value of x_hi, which we
9138                                                                          ; use below to remove the existing particle
9139               
9140 2BF6 0206  20        li   rtmp,MLU2                  ; JSR MLU2          ; Set (A P) = |x_hi| * Q
     2BF8 42D6     
9141 2BFA 06A0  32        bl   @jsr                       ;
     2BFC FF10     
9142               
9143                                                                          ; We now calculate:
9144                                                                          ;
9145                                                                          ; XX(1 0) = x - (A P)
9146               
9147 2BFE D800  30        movb ra,@XX+1                   ; STA XX+1          ; First we do the low bytes:
     2C00 0025     
9148 2C02 D022  34        movb @SXL(ry),ra                ; LDA SXL,Y         ;
     2C04 035F     
9149                      .sbc @P,ra                      ; SBC P             ; XX(1 0) = x_lo - (A P)
     **** ****     > SBC
0001 2C06 1801  14        joc  !
0002 2C08 7004  18        sb   rone,ra
0003               !:
0004 2C0A 7020  30        sb   @P,ra
     2C0C 001B     
                   < elite.a99
9150 2C0E D800  30        movb ra,@XX                     ; STA XX
     2C10 0024     
9151               
9152 2C12 D020  30        movb @X1,ra                     ; LDA X1            ; And then we do the high bytes:
     2C14 0031     
9153                      .sbc @XX+1,ra                   ; SBC XX+1          ;
     **** ****     > SBC
0001 2C16 1801  14        joc  !
0002 2C18 7004  18        sb   rone,ra
0003               !:
0004 2C1A 7020  30        sb   @XX+1,ra
     2C1C 0025     
                   < elite.a99
9154 2C1E D800  30        movb ra,@XX+1                   ; STA XX+1          ; XX(1 0) = (x_hi 0) - XX(1 0)
     2C20 0025     
9155                                                                          ;
9156                                                                          ; so we get our result:
9157                                                                          ;
9158                                                                          ; XX(1 0) = x - (A P)
9159                                                                          ; = x - |x_hi| * Q
9160                                                                          ;
9161                                                                          ; which is result 2 above, and we also have:
9162               
9163 2C22 0206  20        li   rtmp,MLU1                  ; JSR MLU1          ; Call MLU1 to set:
     2C24 42CE     
9164 2C26 06A0  32        bl   @jsr                       ;
     2C28 FF10     
9165                                                                          ;
9166                                                                          ; Y1 = y_hi
9167                                                                          ;
9168                                                                          ; (A P) = |y_hi| * Q
9169                                                                          ;
9170                                                                          ; So Y1 contains the original value of y_hi, which we
9171                                                                          ; use below to remove the existing particle
9172               
9173                                                                          ; We now calculate:
9174                                                                          ;
9175                                                                          ; (S R) = YY(1 0) = y - (A P)
9176               
9177 2C2A D800  30        movb ra,@YY+1                   ; STA YY+1          ; First we do the low bytes with:
     2C2C 0027     
9178 2C2E D022  34        movb @SYL(ry),ra                ; LDA SYL,Y         ;
     2C30 0ED5     
9179                      .sbc @P,ra                      ; SBC P             ; YY+1 = A
     **** ****     > SBC
0001 2C32 1801  14        joc  !
0002 2C34 7004  18        sb   rone,ra
0003               !:
0004 2C36 7020  30        sb   @P,ra
     2C38 001B     
                   < elite.a99
9180 2C3A D800  30        movb ra,@YY                     ; STA YY            ; R = YY = y_lo - P
     2C3C 0026     
9181 2C3E D800  30        movb ra,@R                      ; STA R             ;
     2C40 0091     
9182                                                                          ; so we get this:
9183                                                                          ;
9184                                                                          ; (? R) = YY(1 0) = y_lo - (A P)
9185               
9186 2C42 D020  30        movb @Y1,ra                     ; LDA Y1            ; And then we do the high bytes with:
     2C44 0032     
9187                      .sbc @YY+1,ra                   ; SBC YY+1          ;
     **** ****     > SBC
0001 2C46 1801  14        joc  !
0002 2C48 7004  18        sb   rone,ra
0003               !:
0004 2C4A 7020  30        sb   @YY+1,ra
     2C4C 0027     
                   < elite.a99
9188 2C4E D800  30        movb ra,@YY+1                   ; STA YY+1          ; S = YY+1 = y_hi - YY+1
     2C50 0027     
9189 2C52 D800  30        movb ra,@S                      ; STA S             ;
     2C54 0092     
9190                                                                          ; so we get our result:
9191                                                                          ;
9192                                                                          ; (S R) = YY(1 0) = (y_hi y_lo) - (A P)
9193                                                                          ; = y - |y_hi| * Q
9194                                                                          ;
9195                                                                          ; which is result 3 above, and (S R) is set to the new
9196                                                                          ; value of y
9197               
9198 2C56 D022  34        movb @SZL(ry),ra                ; LDA SZL,Y         ; We now calculate the following:
     2C58 0EFB     
9199                      .adc @DELT4,ra                  ; ADC DELT4         ;
     **** ****     > ADC
0001 2C5A 1701  14        jnc  !
0002 2C5C B004  18        ab   rone,ra
0003               !:
0004 2C5E B020  30        ab   @DELT4,ra
     2C60 008D     
                   < elite.a99
9200 2C62 D880  38        movb ra,@SZL(ry)                ; STA SZL,Y         ; (z_hi z_lo) = (z_hi z_lo) + DELT4(1 0)
     2C64 0EFB     
9201                                                                          ;
9202                                                                          ; starting with the low bytes
9203               
9204 2C66 D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; And then we do the high bytes
     2C68 0EE8     
9205 2C6A D800  30        movb ra,@ZZ                     ; STA ZZ            ;
     2C6C 0097     
9206                      .adc @DELT4+1,ra                ; ADC DELT4+1       ; We also set ZZ to the original value of z_hi, which we
     **** ****     > ADC
0001 2C6E 1701  14        jnc  !
0002 2C70 B004  18        ab   rone,ra
0003               !:
0004 2C72 B020  30        ab   @DELT4+1,ra
     2C74 008E     
                   < elite.a99
9207 2C76 D880  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; use below to remove the existing particle
     2C78 0EE8     
9208                                                                          ;
9209                                                                          ; So now we have result 4 above:
9210                                                                          ;
9211                                                                          ; z = z + DELT4(1 0)
9212                                                                          ; = z + speed * 64
9213               
9214 2C7A D020  30        movb @XX+1,ra                   ; LDA XX+1          ; EOR x with the correct sign of the roll angle alpha,
     2C7C 0025     
9215                      .eor @ALP2                      ; EOR ALP2          ; so A has the opposite sign to the roll angle alpha
     **** ****     > EOR
0001 2C7E D1A0  30        movb @ALP2,rtmp
     2C80 0088     
0002 2C82 2806  18        xor  rtmp,ra
                   < elite.a99
9216               
9217 2C84 0206  20        li   rtmp,MLS1                  ; JSR MLS1          ; Call MLS1 to calculate:
     2C86 41EE     
9218 2C88 06A0  32        bl   @jsr                       ;
     2C8A FF10     
9219                                                                          ;
9220                                                                          ; (A P) = A * ALP1
9221                                                                          ; = (-x / 256) * alpha
9222               
9223 2C8C 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2C8E 44BA     
9224 2C90 06A0  32        bl   @jsr                       ;
     2C92 FF10     
9225                                                                          ;
9226                                                                          ; (A X) = (A P) + (S R)
9227                                                                          ; = (-x / 256) * alpha + y
9228                                                                          ; = y - alpha * x / 256
9229               
9230 2C94 D800  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY(1 0) = (A X) to give:
     2C96 0027     
9231 2C98 D801  30        movb rx,@YY                     ; STX YY            ;
     2C9A 0026     
9232                                                                          ; YY(1 0) = y - alpha * x / 256
9233                                                                          ;
9234                                                                          ; which is result 5 above, and we also have:
9235                                                                          ;
9236                                                                          ; A = YY+1 = y - alpha * x / 256
9237                                                                          ;
9238                                                                          ; i.e. A is the new value of y, divided by 256
9239               
9240                      .eor @ALP2+1                    ; EOR ALP2+1        ; EOR with the flipped sign of the roll angle alpha, so
     **** ****     > EOR
0001 2C9C D1A0  30        movb @ALP2+1,rtmp
     2C9E 0089     
0002 2CA0 2806  18        xor  rtmp,ra
                   < elite.a99
9241                                                                          ; A has the opposite sign to the flipped roll angle
9242                                                                          ; alpha, i.e. it gets the same sign as alpha
9243               
9244 2CA2 0206  20        li   rtmp,MLS2                  ; JSR MLS2          ; Call MLS2 to calculate:
     2CA4 41DE     
9245 2CA6 06A0  32        bl   @jsr                       ;
     2CA8 FF10     
9246                                                                          ;
9247                                                                          ; (S R) = XX(1 0)
9248                                                                          ; = x
9249                                                                          ;
9250                                                                          ; (A P) = A * ALP1
9251                                                                          ; = y / 256 * alpha
9252               
9253 2CAA 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2CAC 44BA     
9254 2CAE 06A0  32        bl   @jsr                       ;
     2CB0 FF10     
9255                                                                          ;
9256                                                                          ; (A X) = (A P) + (S R)
9257                                                                          ; = y / 256 * alpha + x
9258               
9259 2CB2 D800  30        movb ra,@XX+1                   ; STA XX+1          ; Set XX(1 0) = (A X), which gives us result 6 above:
     2CB4 0025     
9260 2CB6 D801  30        movb rx,@XX                     ; STX XX            ;
     2CB8 0024     
9261                                                                          ; x = x + alpha * y / 256
9262               
9263 2CBA D020  30        movb @YY+1,ra                   ; LDA YY+1          ; Set A to y_hi and set it to the flipped sign of beta
     2CBC 0027     
9264                      .eor @BET2+1                    ; EOR BET2+1
     **** ****     > EOR
0001 2CBE D1A0  30        movb @BET2+1,rtmp
     2CC0 008B     
0002 2CC2 2806  18        xor  rtmp,ra
                   < elite.a99
9265               
9266 2CC4 D060  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the pitch magnitude into X
     2CC6 002B     
9267               
9268 2CC8 0206  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     2CCA 41F4     
9269 2CCC 06A0  32        bl   @jsr                       ;
     2CCE FF10     
9270                                                                          ;
9271                                                                          ; (A P) = X * A
9272                                                                          ; = beta * y_hi
9273               
9274 2CD0 D800  30        movb ra,@Q                      ; STA Q             ; Store the high byte of the result in Q, so:
     2CD2 0090     
9275                                                                          ;
9276                                                                          ; Q = beta * y_hi / 256
9277               
9278 2CD4 D020  30        movb @XX+1,ra                   ; LDA XX+1          ; Set S = x_hi
     2CD6 0025     
9279 2CD8 D800  30        movb ra,@S                      ; STA S
     2CDA 0092     
9280               
9281                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A, so A now contains -x
     **** ****     > EOI
0001 2CDC 0206  20        li   rtmp,(>80*256)
     2CDE 8000     
0002 2CE0 2806  18        xor  rtmp,ra
                   < elite.a99
9282               
9283 2CE2 0206  20        li   rtmp,MUT1                  ; JSR MUT1          ; Call MUT1 to calculate:
     2CE4 43EC     
9284 2CE6 06A0  32        bl   @jsr                       ;
     2CE8 FF10     
9285                                                                          ;
9286                                                                          ; R = XX = x_lo
9287                                                                          ;
9288                                                                          ; (A P) = Q * A
9289                                                                          ; = (beta * y_hi / 256) * (-beta * y_hi / 256)
9290                                                                          ; = (-beta * y / 256) ^ 2
9291               
9292                      .asl @P                         ; ASL P             ; Double (A P), store the top byte in A and set the C
     **** ****     > ASL
0001 2CEA D1A0  30        movb @P,rtmp
     2CEC 001B     
0002 2CEE 0246  22        andi rtmp,>ff00
     2CF0 FF00     
0003 2CF2 0A16  18        sla  rtmp,1
0004 2CF4 D806  30        movb rtmp,@P
     2CF6 001B     
                   < elite.a99
9293 2CF8 06A0  32        bl   @rola                      ; ROL A             ; flag to bit 7 of the original A, so this does:
     2CFA FF26     
9294 2CFC D800  30        movb ra,@T                      ; STA T             ;
     2CFE 00D1     
9295                                                                          ; (T P) = (A P) << 1
9296                                                                          ; = 2 * (-beta * y / 256) ^ 2
9297               
9298 2D00 0200  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 in A to the sign bit from the A in the
     2D02 0000     
9299 2D04 06A0  32        bl   @rora                      ; ROR A             ; calculation above and apply it to T, so we now have:
     2D06 FF4A     
9300 2D08 F020  30        socb @T,ra                      ; ORA T             ;
     2D0A 00D1     
9301                                                                          ; (A P) = -2 * (beta * y / 256) ^ 2
9302                                                                          ;
9303                                                                          ; with the doubling retaining the sign of (A P)
9304               
9305 2D0C 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2D0E 44BA     
9306 2D10 06A0  32        bl   @jsr                       ;
     2D12 FF10     
9307                                                                          ;
9308                                                                          ; (A X) = (A P) + (S R)
9309                                                                          ; = -2 * (beta * y / 256) ^ 2 + x
9310               
9311 2D14 D800  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     2D16 0025     
9312               
9313 2D18 D001  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
9314 2D1A D880  38        movb ra,@SXL(ry)                ; STA SXL,Y
     2D1C 035F     
9315               
9316                                                                          ; So (XX+1 x_lo) now contains:
9317                                                                          ;
9318                                                                          ; x = x - 2 * (beta * y / 256) ^ 2
9319                                                                          ;
9320                                                                          ; which is result 7 above
9321               
9322 2D1E D020  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0) = y
     2D20 0026     
9323 2D22 D800  30        movb ra,@R                      ; STA R
     2D24 0091     
9324 2D26 D020  30        movb @YY+1,ra                   ; LDA YY+1
     2D28 0027     
9325 2D2A D800  30        movb ra,@S                      ; STA S
     2D2C 0092     
9326               
9327               * EOR #128               \ These instructions are commented out in the original
9328               * JSR MAD                \ source
9329               * STA S
9330               * STX R
9331               
9332 2D2E 0200  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     2D30 0000     
9333 2D32 D800  30        movb ra,@P                      ; STA P
     2D34 001B     
9334               
9335 2D36 D020  30        movb @BETA,ra                   ; LDA BETA          ; Set A = beta, so (A P) = (beta 0) = beta * 256
     2D38 002A     
9336               
9337 2D3A 0206  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     2D3C 275A     
9338 2D3E 06A0  32        bl   @jsr                       ;
     2D40 FF10     
9339                                                                          ;
9340                                                                          ; (YY+1 y_lo) = (A P) + (S R)
9341                                                                          ; = beta * 256 + y
9342                                                                          ;
9343                                                                          ; i.e. y = y + beta * 256, which is result 8 above
9344                                                                          ;
9345                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
9346                                                                          ; ZZ, which will remove the old stardust particle, as we
9347                                                                          ; set X1, Y1 and ZZ to the original values for this
9348                                                                          ; particle during the calculations above
9349               
9350                                                                          ; We now have our newly moved stardust particle at
9351                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
9352                                                                          ; and distance z_hi, so we draw it if it's still on
9353                                                                          ; screen, otherwise we recycle it as a new bit of
9354                                                                          ; stardust and draw that
9355               
9356 2D42 D020  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     2D44 0025     
9357 2D46 D800  30        movb ra,@X1                     ; STA X1            ; the new x-coordinate is in (x_hi x_lo) and the high
     2D48 0031     
9358 2D4A D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; byte is in X1
     2D4C 034C     
9359               
9360 2D4E D020  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     2D50 0027     
9361 2D52 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     2D54 0EC2     
9362 2D56 D800  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     2D58 0032     
9363               
9364 2D5A 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 110 then jump to KILL6 to recycle this
     2D5C 7F00     
9365 2D5E 0280  22        ci   ra,>6e*256                 ; CMP #110          ; particle, as it's gone off the top or bottom of the
     2D60 6E00     
9366 2D62 1811  14        joc  KILL6                      ; BCS KILL6         ; screen, and rejoin at STC6 with the new particle
9367               
9368 2D64 D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; If z_hi >= 160 then jump to KILL6 to recycle this
     2D66 0EE8     
9369 2D68 0280  22        ci   ra,>a0*256                 ; CMP #160          ; particle, as it's so far away that it's too far to
     2D6A A000     
9370 2D6C 180C  14        joc  KILL6                      ; BCS KILL6         ; see, and rejoin at STC1 with the new particle
9371               
9372 2D6E D800  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the z-coordinate in z_hi
     2D70 0097     
9373               
9374               STC6:
9375 2D72 0206  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     2D74 276C     
9376 2D76 06A0  32        bl   @jsr                       ;
     2D78 FF10     
9377                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
9378                                                                          ; with distance z_hi
9379               
9380 2D7A 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
9381                                                                          ; stardust particle
9382               
9383 2D7C 1302  14        jeq  ST3                        ; BEQ ST3           ; If we have just done the last particle, skip the next
9384                                                                          ; instruction to return from the subroutine
9385               
9386 2D7E 0460  28        b    @STL6                      ; JMP STL6          ; We have more stardust to process, so jump back up to
     2D80 2BBE     
9387                                                                          ; STL6 for the next particle
9388               
9389               ST3:
9390 2D82 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2D84 FF1C     
9391               
9392               KILL6:
9393 2D86 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2D88 C07C     
9394 2D8A 06A0  32        bl   @jsr                       ;
     2D8C FF10     
9395               
9396 2D8E 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit of A to get |A|
     2D90 7F00     
9397               
9398                      .adi (>0a*256)                  ; ADC #10           ; Make sure A is at least 10 and store it in z_hi and
     **** ****     > ADI
0001 2D92 1701  14        jnc  !
0002 2D94 B004  18        ab   rone,ra
0003               !:
0004 2D96 0220  22        ai   ra,(>0A*256)
     2D98 0A00     
                   < elite.a99
9399 2D9A D880  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; ZZ, so the new particle starts close to us
     2D9C 0EE8     
9400 2D9E D800  30        movb ra,@ZZ                     ; STA ZZ
     2DA0 0097     
9401               
9402 2DA2 0910  18        srl  ra,1                       ; LSR A             ; Divide A by 2 and randomly set the C flag
9403               
9404 2DA4 1813  14        joc  ST4                        ; BCS ST4           ; Jump to ST4 half the time
9405               
9406 2DA6 0910  18        srl  ra,1                       ; LSR A             ; Randomly set the C flag again
9407               
9408 2DA8 0200  20        li   ra,>fc*256                 ; LDA #252          ; Set A to either +126 or -126 (252 >> 1) depending on
     2DAA FC00     
9409 2DAC 06A0  32        bl   @rora                      ; ROR A             ; the C flag, as this is a sign-magnitude number with
     2DAE FF4A     
9410                                                                          ; the C flag rotated into its sign bit
9411               
9412 2DB0 D800  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to A, so this particle starts on
     2DB2 0031     
9413 2DB4 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; either the left or right edge of the screen
     2DB6 034C     
9414               
9415 2DB8 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2DBA C07C     
9416 2DBC 06A0  32        bl   @jsr                       ;
     2DBE FF10     
9417               
9418 2DC0 D800  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to random numbers, so the particle
     2DC2 0032     
9419 2DC4 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; starts anywhere along either the left or right edge
     2DC6 0EC2     
9420               
9421 2DC8 0460  28        b    @STC6                      ; JMP STC6          ; Jump up to STC6 to draw this new particle
     2DCA 2D72     
9422               
9423               ST4:
9424 2DCC 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2DCE C07C     
9425 2DD0 06A0  32        bl   @jsr                       ;
     2DD2 FF10     
9426               
9427 2DD4 D800  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to random numbers, so the particle
     2DD6 0031     
9428 2DD8 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; starts anywhere along the x-axis
     2DDA 034C     
9429               
9430 2DDC 0910  18        srl  ra,1                       ; LSR A             ; Randomly set the C flag
9431               
9432 2DDE 0200  20        li   ra,>e6*256                 ; LDA #230          ; Set A to either +115 or -115 (230 >> 1) depending on
     2DE0 E600     
9433 2DE2 06A0  32        bl   @rora                      ; ROR A             ; the C flag, as this is a sign-magnitude number with
     2DE4 FF4A     
9434                                                                          ; the C flag rotated into its sign bit
9435               
9436 2DE6 D800  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to A, so the particle starts anywhere
     2DE8 0032     
9437 2DEA D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; along either the top or bottom edge of the screen
     2DEC 0EC2     
9438               
9439 2DEE 16C1  14        jne  STC6                       ; BNE STC6          ; Jump up to STC6 to draw this new particle (this BNE is
9440                                                                          ; effectively a JMP as A will never be zero)
9441               
9442               * ******************************************************************************
9443               *
9444               * Name: PRXS
9445               * Type: Variable
9446               * Category: Equipment
9447               * Summary: Equipment prices
9448               *
9449               * ------------------------------------------------------------------------------
9450               *
9451               * Equipment prices are stored as 10 * the actual value, so we can support prices
9452               * with fractions of credits (0.1 Cr). This is used for the price of fuel only.
9453               *
9454               * ******************************************************************************
9455               
9456               PRXS:
9457 2DF0 0100            data >0100                                          ; 0  Fuel, calculated in EQSHP  140.0 Cr (full tank)
9458 2DF2 2C01            data >2c01                                          ; 1  Missile                     30.0 Cr
9459 2DF4 A00F            data >a00f                                          ; 2  Large Cargo Bay            400.0 Cr
9460 2DF6 7017            data >7017                                          ; 3  E.C.M. System              600.0 Cr
9461 2DF8 A00F            data >a00f                                          ; 4  Extra Pulse Lasers         400.0 Cr
9462 2DFA 1027            data >1027                                          ; 5  Extra Beam Lasers         1000.0 Cr
9463 2DFC 8214            data >8214                                          ; 6  Fuel Scoops                525.0 Cr
9464 2DFE 1027            data >1027                                          ; 7  Escape Pod                1000.0 Cr
9465 2E00 2823            data >2823                                          ; 8  Energy Bomb                900.0 Cr
9466 2E02 983A            data >983a                                          ; 9  Energy Unit               1500.0 Cr
9467 2E04 1027            data >1027                                          ; 10 Docking Computer          1000.0 Cr
9468 2E06 50C3            data >50c3                                          ; 11 Galactic Hyperspace       5000.0 Cr
9469               
9470               * ******************************************************************************
9471               *
9472               * Name: STATUS
9473               * Type: Subroutine
9474               * Category: Status
9475               * Summary: Show the Status Mode screen (red key f8)
9476               * Deep dive: Combat rank
9477               *
9478               * ******************************************************************************
9479               
9480               st4_:
9481                                                                          ; We call this from st5 below with the high byte of the
9482                                                                          ; kill tally in A, which is non-zero, and want to return
9483                                                                          ; with the following in X, depending on our rating:
9484                                                                          ;
9485                                                                          ; Competent = 6
9486                                                                          ; Dangerous = 7
9487                                                                          ; Deadly    = 8
9488                                                                          ; Elite     = 9
9489                                                                          ;
9490                                                                          ; The high bytes of the top tier ratings are as follows,
9491                                                                          ; so this a relatively simple calculation:
9492                                                                          ;
9493                                                                          ; Competent       = 1 to 2
9494                                                                          ; Dangerous       = 2 to 9
9495                                                                          ; Deadly          = 10 to 24
9496                                                                          ; Elite           = 25 and up
9497 2E08 0201  20        li   rx,>09*256                 ; LDX #9            ; Set X to 9 for an Elite rating
     2E0A 0900     
9498               
9499 2E0C 0280  22        ci   ra,>19*256                 ; CMP #25           ; If A >= 25, jump to st3 to print out our rating, as we
     2E0E 1900     
9500 2E10 185C  14        joc  st3_                       ; BCS st3           ; are Elite
9501               
9502 2E12 7044  18        sb   rone,rx                    ; DEX               ; Decrement X to 8 for a Deadly rating
9503               
9504 2E14 0280  22        ci   ra,>0a*256                 ; CMP #10           ; If A >= 10, jump to st3 to print out our rating, as we
     2E16 0A00     
9505 2E18 1858  14        joc  st3_                       ; BCS st3           ; are Deadly
9506               
9507 2E1A 7044  18        sb   rone,rx                    ; DEX               ; Decrement X to 7 for a Dangerous rating
9508               
9509 2E1C 0280  22        ci   ra,>02*256                 ; CMP #2            ; If A >= 2, jump to st3 to print out our rating, as we
     2E1E 0200     
9510 2E20 1854  14        joc  st3_                       ; BCS st3           ; are Dangerous
9511               
9512 2E22 7044  18        sb   rone,rx                    ; DEX               ; Decrement X to 6 for a Competent rating
9513               
9514 2E24 1652  14        jne  st3_                       ; BNE st3           ; Jump to st3 to print out our rating, as we are
9515                                                                          ; Competent (this BNE is effectively a JMP as A will
9516                                                                          ; never be zero)
9517               
9518               STATUS:
9519 2E26 0200  20        li   ra,>08*256                 ; LDA #8            ; Clear the top part of the screen, draw a white border,
     2E28 0800     
9520 2E2A 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 8 (Status
     2E2C 4B2A     
9521 2E2E 06A0  32        bl   @jsr                       ;
     2E30 FF10     
9522                                                                          ; Mode screen)
9523               
9524 2E32 0206  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     2E34 5AB8     
9525 2E36 06A0  32        bl   @jsr                       ;
     2E38 FF10     
9526                                                                          ; (QQ9, QQ10)
9527               
9528 2E3A 0200  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     2E3C 0700     
9529 2E3E D800  30        movb ra,@XC                     ; STA XC
     2E40 002C     
9530               
9531 2E42 0200  20        li   ra,>7e*256                 ; LDA #126          ; Print recursive token 126, which prints the top
     2E44 7E00     
9532 2E46 0206  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; four lines of the Status Mode screen:
     2E48 25B0     
9533 2E4A 06A0  32        bl   @jsr                       ;
     2E4C FF10     
9534                                                                          ;
9535                                                                          ; COMMANDER {commander name}
9536                                                                          ;
9537                                                                          ;
9538                                                                          ; Present System      : {current system name}
9539                                                                          ; Hyperspace System   : {selected system name}
9540                                                                          ; Condition           :
9541                                                                          ;
9542                                                                          ; and draw a horizontal line at pixel row 19 to box
9543                                                                          ; in the title
9544               
9545 2E4E 0200  20        li   ra,>0f*256                 ; LDA #15           ; Set A to token 129 ("{sentence case}DOCKED")
     2E50 0F00     
9546               
9547 2E52 D0A0  30        movb @QQ12,ry                   ; LDY QQ12          ; Fetch the docked status from QQ12, and if we are
     2E54 009F     
9548 2E56 160F  14        jne  st6_                       ; BNE st6           ; docked, jump to st6 to print "Docked" for our
9549                                                                          ; ship's condition
9550               
9551 2E58 0200  20        li   ra,>e6*256                 ; LDA #230          ; Otherwise we are in space, so start off by setting A
     2E5A E600     
9552                                                                          ; to token 70 ("GREEN")
9553               
9554 2E5C D0A0  30        movb @MANY+AST,ry               ; LDY MANY+AST      ; Set Y to the number of asteroids in our local bubble
     2E5E 0D57     
9555                                                                          ; of universe
9556               
9557 2E60 D062  34        movb @FRIN+2(ry),rx             ; LDX FRIN+2,Y      ; The ship slots at FRIN are ordered with the first two
     2E62 0D42     
9558                                                                          ; slots reserved for the planet and sun/space station,
9559                                                                          ; and then any ships, so if the slot at FRIN+2+Y is not
9560                                                                          ; empty (i.e. is non-zero), then that means the number
9561                                                                          ; of non-asteroids in the vicinity is at least 1
9562               
9563 2E64 1308  14        jeq  st6_                       ; BEQ st6           ; So if X = 0, there are no ships in the vicinity, so
9564                                                                          ; jump to st6 to print "Green" for our ship's condition
9565               
9566 2E66 D0A0  30        movb @ENERGY,ry                 ; LDY ENERGY        ; Otherwise we have ships in the vicinity, so we load
     2E68 0F13     
9567                                                                          ; our energy levels into Y
9568               
9569 2E6A 0282  22        ci   ry,>80*256                 ; CPY #128          ; Set the C flag if Y >= 128, so C is set if we have
     2E6C 8000     
9570                                                                          ; more than half of our energy banks charged
9571               
9572                      .adi (>01*256)                  ; ADC #1            ; Add 1 + C to A, so if C is not set (i.e. we have low
     **** ****     > ADI
0001 2E6E 1701  14        jnc  !
0002 2E70 B004  18        ab   rone,ra
0003               !:
0004 2E72 0220  22        ai   ra,(>01*256)
     2E74 0100     
                   < elite.a99
9573                                                                          ; energy levels) then A is set to token 231 ("RED"),
9574                                                                          ; and if C is set (i.e. we have healthy energy levels)
9575                                                                          ; then A is set to token 232 ("YELLOW")
9576               
9577               st6_:
9578 2E76 0206  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A (which contains our ship's
     2E78 A6D0     
9579 2E7A 06A0  32        bl   @jsr                       ;
     2E7C FF10     
9580                                                                          ; condition) followed by a newline
9581               
9582 2E7E 0200  20        li   ra,>7d*256                 ; LDA #125          ; Print recursive token 125, which prints the next
     2E80 7D00     
9583 2E82 0206  20        li   rtmp,spc_                  ; JSR spc           ; three lines of the Status Mode screen:
     2E84 4EFE     
9584 2E86 06A0  32        bl   @jsr                       ;
     2E88 FF10     
9585                                                                          ;
9586                                                                          ; Fuel: {fuel level} Light Years
9587                                                                          ; Cash: {cash} Cr
9588                                                                          ; Legal Status:
9589                                                                          ;
9590                                                                          ; followed by a space
9591               
9592 2E8A 0200  20        li   ra,>13*256                 ; LDA #19           ; Set A to token 133 ("CLEAN")
     2E8C 1300     
9593               
9594 2E8E D0A0  30        movb @FIST,ry                   ; LDY FIST          ; Fetch our legal status, and if it is 0, we are clean,
     2E90 0334     
9595 2E92 1306  14        jeq  st5_                       ; BEQ st5           ; so jump to st5 to print "Clean"
9596               
9597 2E94 0282  22        ci   ry,>32*256                 ; CPY #50           ; Set the C flag if Y >= 50, so C is set if we have
     2E96 3200     
9598                                                                          ; a legal status of 50+ (i.e. we are a fugitive)
9599               
9600                      .adi (>01*256)                  ; ADC #1            ; Add 1 + C to A, so if C is not set (i.e. we have a
     **** ****     > ADI
0001 2E98 1701  14        jnc  !
0002 2E9A B004  18        ab   rone,ra
0003               !:
0004 2E9C 0220  22        ai   ra,(>01*256)
     2E9E 0100     
                   < elite.a99
9601                                                                          ; legal status between 1 and 49) then A is set to token
9602                                                                          ; 134 ("OFFENDER"), and if C is set (i.e. we have a
9603                                                                          ; legal status of 50+) then A is set to token 135
9604                                                                          ; ("FUGITIVE")
9605               
9606               st5_:
9607 2EA0 0206  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A (which contains our legal
     2EA2 A6D0     
9608 2EA4 06A0  32        bl   @jsr                       ;
     2EA6 FF10     
9609                                                                          ; status) followed by a newline
9610               
9611 2EA8 0200  20        li   ra,>10*256                 ; LDA #16           ; Print recursive token 130 ("RATING:") followed by a
     2EAA 1000     
9612 2EAC 0206  20        li   rtmp,spc_                  ; JSR spc           ; space
     2EAE 4EFE     
9613 2EB0 06A0  32        bl   @jsr                       ;
     2EB2 FF10     
9614               
9615 2EB4 D020  30        movb @TALLY+1,ra                ; LDA TALLY+1       ; Fetch the high byte of the kill tally, and if it is
     2EB6 0348     
9616 2EB8 16A7  14        jne  st4_                       ; BNE st4           ; not zero, then we have more than 256 kills, so jump
9617                                                                          ; to st4 to work out whether we are Competent,
9618                                                                          ; Dangerous, Deadly or Elite
9619               
9620                                                                          ; Otherwise we have fewer than 256 kills, so we are one
9621                                                                          ; of Harmless, Mostly Harmless, Poor, Average or Above
9622                                                                          ; Average
9623               
9624 2EBA D040  18        movb ra,rx                      ; TAX               ; Set X to 0 (as A is 0)
9625               
9626 2EBC D020  30        movb @TALLY,ra                  ; LDA TALLY         ; Set A = lower byte of tally / 4
     2EBE 0347     
9627 2EC0 0910  18        srl  ra,1                       ; LSR A
9628 2EC2 0910  18        srl  ra,1                       ; LSR A
9629               
9630               st5L:
9631                                                                          ; We now loop through bits 2 to 7, shifting each of them
9632                                                                          ; off the end of A until there are no set bits left, and
9633                                                                          ; incrementing X for each shift, so at the end of the
9634                                                                          ; process, X contains the position of the leftmost 1 in
9635                                                                          ; A. Looking at the rank values in TALLY:
9636                                                                          ;
9637                                                                          ; Harmless        = %00000000 to %00000011
9638                                                                          ; Mostly Harmless = %00000100 to %00000111
9639                                                                          ; Poor            = %00001000 to %00001111
9640                                                                          ; Average         = %00010000 to %00011111
9641                                                                          ; Above Average   = %00100000 to %11111111
9642                                                                          ;
9643                                                                          ; we can see that the values returned by this process
9644                                                                          ; are:
9645                                                                          ;
9646                                                                          ; Harmless        = 1
9647                                                                          ; Mostly Harmless = 2
9648                                                                          ; Poor            = 3
9649                                                                          ; Average         = 4
9650                                                                          ; Above Average   = 5
9651 2EC4 B044  18        ab   rone,rx                    ; INX               ; Increment X for each shift
9652               
9653 2EC6 0910  18        srl  ra,1                       ; LSR A             ; Shift A to the right
9654               
9655 2EC8 16FD  14        jne  st5L                       ; BNE st5L          ; Keep looping around until A = 0, which means there are
9656                                                                          ; no set bits left in A
9657               
9658               st3_:
9659 2ECA D001  18        movb rx,ra                      ; TXA               ; A now contains our rating as a value of 1 to 9, so
9660                                                                          ; transfer X to A, so we can print it out
9661               
9662                      .clc                            ; CLC               ; Print recursive token 135 + A, which will be in the
     **** ****     > CLC
0001 2ECC 0A13  18        sla  rzero,1
                   < elite.a99
9663                      .adi (>15*256)                  ; ADC #21           ; range 136 ("HARMLESS") to 144 ("---- E L I T E ----")
     **** ****     > ADI
0001 2ECE 1701  14        jnc  !
0002 2ED0 B004  18        ab   rone,ra
0003               !:
0004 2ED2 0220  22        ai   ra,(>15*256)
     2ED4 1500     
                   < elite.a99
9664 2ED6 0206  20        li   rtmp,plf_                  ; JSR plf           ; followed by a newline
     2ED8 A6D0     
9665 2EDA 06A0  32        bl   @jsr                       ;
     2EDC FF10     
9666               
9667 2EDE 0200  20        li   ra,>12*256                 ; LDA #18           ; Print recursive token 132, which prints the next bit
     2EE0 1200     
9668 2EE2 0206  20        li   rtmp,plf2_                 ; JSR plf2          ; of the Status Mode screen:
     2EE4 2F94     
9669 2EE6 06A0  32        bl   @jsr                       ;
     2EE8 FF10     
9670                                                                          ;
9671                                                                          ; EQUIPMENT:
9672                                                                          ;
9673                                                                          ; followed by a newline and an indent of 6 characters
9674               
9675 2EEA D020  30        movb @CRGO,ra                   ; LDA CRGO          ; If our ship's cargo capacity is < 26 (i.e. we do not
     2EEC 0316     
9676 2EEE 0280  22        ci   ra,>1a*256                 ; CMP #26           ; have a cargo bay extension), skip the following two
     2EF0 1A00     
9677 2EF2 1706  14        jnc  B19                        ; BCC B19           ; instructions
9678               
9679 2EF4 0200  20        li   ra,>6b*256                 ; LDA #107          ; We do have a cargo bay extension, so print recursive
     2EF6 6B00     
9680 2EF8 0206  20        li   rtmp,plf2_                 ; JSR plf2          ; token 107 ("LARGE CARGO{sentence case} BAY"), followed
     2EFA 2F94     
9681 2EFC 06A0  32        bl   @jsr                       ;
     2EFE FF10     
9682                                                                          ; by a newline and an indent of 6 characters
9683               
9684               B19:
9685 2F00 D020  30        movb @BST,ra                    ; LDA BST           ; If we don't have fuel scoops fitted, skip the
     2F02 0329     
9686 2F04 1306  14        jeq  B20                        ; BEQ B20           ; following two instructions
9687               
9688 2F06 0200  20        li   ra,>6f*256                 ; LDA #111          ; We do have fuel scoops fitted, so print recursive
     2F08 6F00     
9689 2F0A 0206  20        li   rtmp,plf2_                 ; JSR plf2          ; token 111 ("FUEL SCOOPS"), followed by a newline and
     2F0C 2F94     
9690 2F0E 06A0  32        bl   @jsr                       ;
     2F10 FF10     
9691                                                                          ; an indent of 6 characters
9692               
9693               B20:
9694 2F12 D020  30        movb @ECM,ra                    ; LDA ECM           ; If we don't have an E.C.M. fitted, skip the following
     2F14 0328     
9695 2F16 1306  14        jeq  B21                        ; BEQ B21           ; two instructions
9696               
9697 2F18 0200  20        li   ra,>6c*256                 ; LDA #108          ; We do have an E.C.M. fitted, so print recursive token
     2F1A 6C00     
9698 2F1C 0206  20        li   rtmp,plf2_                 ; JSR plf2          ; 108 ("E.C.M.SYSTEM"), followed by a newline and an
     2F1E 2F94     
9699 2F20 06A0  32        bl   @jsr                       ;
     2F22 FF10     
9700                                                                          ; indent of 6 characters
9701               
9702               B21:
9703 2F24 0200  20        li   ra,>71*256                 ; LDA #113          ; We now cover the four pieces of equipment whose flags
     2F26 7100     
9704 2F28 D800  30        movb ra,@XX4                    ; STA XX4           ; are stored in BOMB through BOMB+3, and whose names
     2F2A 00A7     
9705                                                                          ; correspond with text tokens 113 through 116:
9706                                                                          ;
9707                                                                          ; BOMB+0 = BOMB  = token 113 = Energy bomb
9708                                                                          ; BOMB+1 = ENGY  = token 114 = Energy unit
9709                                                                          ; BOMB+2 = DKCMP = token 115 = Docking computer
9710                                                                          ; BOMB+3 = GHYP  = token 116 = Galactic hyperdrive
9711                                                                          ;
9712                                                                          ; We can print these out using a loop, so we set XX4 to
9713                                                                          ; 113 as a counter (and we also set A as well, to pass
9714                                                                          ; through to plf2)
9715               
9716               stqv_:
9717 2F2C D080  18        movb ra,ry                      ; TAY               ; Fetch byte BOMB+0 through BOMB+4 for values of XX4
9718 2F2E D062  34        movb @BOMB-113(ry),rx           ; LDX BOMB-113,Y    ; from 113 through 117
     2F30 02B9     
9719               
9720 2F32 1304  14        jeq  B22                        ; BEQ B22           ; If it is zero then we do not own that piece of
9721                                                                          ; equipment, so skip the next instruction
9722               
9723 2F34 0206  20        li   rtmp,plf2_                 ; JSR plf2          ; Print the recursive token in A from 113 ("ENERGY
     2F36 2F94     
9724 2F38 06A0  32        bl   @jsr                       ;
     2F3A FF10     
9725                                                                          ; BOMB") through 116 ("GALACTIC HYPERSPACE "), followed
9726                                                                          ; by a newline and an indent of 6 characters
9727               
9728               B22:
9729 2F3C B004  18        ab   rone,ra                    ; INC XX4           ; Increment the counter (and A as well)
9730 2F3E D020  30        movb @XX4,ra                    ; LDA XX4
     2F40 00A7     
9731               
9732 2F42 0280  22        ci   ra,>75*256                 ; CMP #117          ; If A < 117, loop back up to stqv to print the next
     2F44 7500     
9733 2F46 17F2  14        jnc  stqv_                      ; BCC stqv          ; piece of equipment
9734               
9735 2F48 0201  20        li   rx,>00*256                 ; LDX #0            ; Now to print our ship's lasers, so set a counter in X
     2F4A 0000     
9736                                                                          ; to count through the four views (0 = front, 1 = rear,
9737                                                                          ; 2 = left, 3 = right)
9738               
9739               st_:
9740 2F4C D801  30        movb rx,@CNT                    ; STX CNT           ; Store the view number in CNT
     2F4E 00A4     
9741               
9742 2F50 D0A1  34        movb @LASER(rx),ry              ; LDY LASER,X       ; Fetch the laser power for view X, and if we do not
     2F52 0310     
9743 2F54 1317  14        jeq  st1_                       ; BEQ st1           ; have a laser fitted to that view, jump to st1 to move
9744                                                                          ; on to the next one
9745               
9746 2F56 D001  18        movb rx,ra                      ; TXA               ; Print recursive token 96 + X, which will print from 96
9747                      .clc                            ; CLC               ; ("FRONT") through to 99 ("RIGHT"), followed by a space
     **** ****     > CLC
0001 2F58 0A13  18        sla  rzero,1
                   < elite.a99
9748                      .adi (>60*256)                  ; ADC #96
     **** ****     > ADI
0001 2F5A 1701  14        jnc  !
0002 2F5C B004  18        ab   rone,ra
0003               !:
0004 2F5E 0220  22        ai   ra,(>60*256)
     2F60 6000     
                   < elite.a99
9749 2F62 0206  20        li   rtmp,spc_                  ; JSR spc
     2F64 4EFE     
9750 2F66 06A0  32        bl   @jsr                       ;
     2F68 FF10     
9751               
9752 2F6A 0200  20        li   ra,>67*256                 ; LDA #103          ; Set A to token 103 ("PULSE LASER")
     2F6C 6700     
9753               
9754 2F6E D060  30        movb @CNT,rx                    ; LDX CNT           ; If the laser power for view X has bit 7 clear, then it
     2F70 00A4     
9755 2F72 D0A1  34        movb @LASER(rx),ry              ; LDY LASER,X       ; is a pulse laser, so skip the following instruction
     2F74 0310     
9756 2F76 1502  14        jgt  B23                        ; BPL B23
9757               
9758 2F78 0200  20        li   ra,>68*256                 ; LDA #104          ; Set A to token 104 ("BEAM LASER")
     2F7A 6800     
9759               
9760               B23:
9761 2F7C 0206  20        li   rtmp,plf2_                 ; JSR plf2          ; Print the text token in A (which contains the laser
     2F7E 2F94     
9762 2F80 06A0  32        bl   @jsr                       ;
     2F82 FF10     
9763                                                                          ; type) followed by a newline and an indent of 6
9764                                                                          ; characters
9765               
9766               st1_:
9767 2F84 D060  30        movb @CNT,rx                    ; LDX CNT           ; Increment the counter in X and CNT to point to the
     2F86 00A4     
9768 2F88 B044  18        ab   rone,rx                    ; INX               ; next view
9769               
9770 2F8A 0281  22        ci   rx,>04*256                 ; CPX #4            ; If this isn't the last of the four views, jump back up
     2F8C 0400     
9771 2F8E 17DE  14        jnc  st_                        ; BCC st            ; to st to print out the next one
9772               
9773 2F90 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2F92 FF1C     
9774               
9775               * ******************************************************************************
9776               *
9777               * Name: plf2
9778               * Type: Subroutine
9779               * Category: Text
9780               * Summary: Print text followed by a newline and indent of 6 characters
9781               *
9782               * ------------------------------------------------------------------------------
9783               *
9784               * Print a text token followed by a newline, and indent the next line to text
9785               * column 6.
9786               *
9787               * ------------------------------------------------------------------------------
9788               *
9789               * Arguments:
9790               *
9791               * A                   The text token to be printed
9792               *
9793               * ******************************************************************************
9794               
9795               plf2_:
9796 2F94 0206  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A followed by a newline
     2F96 A6D0     
9797 2F98 06A0  32        bl   @jsr                       ;
     2F9A FF10     
9798               
9799 2F9C 0201  20        li   rx,>06*256                 ; LDX #6            ; Move the text cursor to column 6
     2F9E 0600     
9800 2FA0 D801  30        movb rx,@XC                     ; STX XC
     2FA2 002C     
9801               
9802 2FA4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2FA6 FF1C     
9803               
9804               * ******************************************************************************
9805               *
9806               * Name: TENS
9807               * Type: Variable
9808               * Category: Text
9809               * Summary: A constant used when printing large numbers in BPRNT
9810               * Deep dive: Printing decimal numbers
9811               *
9812               * ------------------------------------------------------------------------------
9813               *
9814               * Contains the four low bytes of the value 100,000,000,000 (100 billion).
9815               *
9816               * The maximum number of digits that we can print with the BPRNT routine is 11,
9817               * so the biggest number we can print is 99,999,999,999. This maximum number
9818               * plus 1 is 100,000,000,000, which in hexadecimal is:
9819               *
9820               * & 17 48 76 E8 00
9821               *
9822               * The TENS variable contains the lowest four bytes in this number, with the
9823               * most significant byte first, i.e. 48 76 E8 00. This value is used in the
9824               * BPRNT routine when working out which decimal digits to print when printing a
9825               * number.
9826               *
9827               * ******************************************************************************
9828               
9829               TENS:
9830 2FA8 0000            data >0000, >0000
     2FAA 0000     
9831               
9832               * ******************************************************************************
9833               *
9834               * Name: pr2
9835               * Type: Subroutine
9836               * Category: Text
9837               * Summary: Print an 8-bit number, left-padded to 3 digits, and optional point
9838               *
9839               * ------------------------------------------------------------------------------
9840               *
9841               * Print the 8-bit number in X to 3 digits, left-padding with spaces for numbers
9842               * with fewer than 3 digits (so numbers < 100 are right-aligned). Optionally
9843               * include a decimal point.
9844               *
9845               * ------------------------------------------------------------------------------
9846               *
9847               * Arguments:
9848               *
9849               * X                   The number to print
9850               *
9851               * C flag              If set, include a decimal point
9852               *
9853               * ------------------------------------------------------------------------------
9854               *
9855               * Other entry points:
9856               *
9857               * pr2+2               Print the 8-bit number in X to the number of digits in A
9858               *
9859               * ******************************************************************************
9860               
9861               pr2_:
9862 2FAC 0200  20        li   ra,>03*256                 ; LDA #3            ; Set A to the number of digits (3)
     2FAE 0300     
9863               
9864 2FB0 0202  20        li   ry,>00*256                 ; LDY #0            ; Zero the Y register, so we can fall through into TT11
     2FB2 0000     
9865                                                                          ; to print the 16-bit number (Y X) to 3 digits, which
9866                                                                          ; effectively prints X to 3 digits as the high byte is
9867                                                                          ; zero
9868               
9869               * ******************************************************************************
9870               *
9871               * Name: TT11
9872               * Type: Subroutine
9873               * Category: Text
9874               * Summary: Print a 16-bit number, left-padded to n digits, and optional point
9875               *
9876               * ------------------------------------------------------------------------------
9877               *
9878               * Print the 16-bit number in (Y X) to a specific number of digits, left-padding
9879               * with spaces for numbers with fewer digits (so lower numbers will be right-
9880               * aligned). Optionally include a decimal point.
9881               *
9882               * ------------------------------------------------------------------------------
9883               *
9884               * Arguments:
9885               *
9886               * X                   The low byte of the number to print
9887               *
9888               * Y                   The high byte of the number to print
9889               *
9890               * A                   The number of digits
9891               *
9892               * C flag              If set, include a decimal point
9893               *
9894               * ******************************************************************************
9895               
9896               TT11:
9897 2FB4 D800  30        movb ra,@U                      ; STA U             ; We are going to use the BPRNT routine (below) to
     2FB6 008F     
9898                                                                          ; print this number, so we store the number of digits
9899                                                                          ; in U, as that's what BPRNT takes as an argument
9900               
9901 2FB8 0200  20        li   ra,>00*256                 ; LDA #0            ; BPRNT takes a 32-bit number in K to K+3, with the
     2FBA 0000     
9902 2FBC D800  30        movb ra,@K                      ; STA K             ; most significant byte first (big-endian), so we set
     2FBE 003D     
9903 2FC0 D800  30        movb ra,@K+1                    ; STA K+1           ; the two most significant bytes to zero (K and K+1)
     2FC2 003E     
9904 2FC4 D802  30        movb ry,@K+2                    ; STY K+2           ; and store (Y X) in the least two significant bytes
     2FC6 003F     
9905 2FC8 D801  30        movb rx,@K+3                    ; STX K+3           ; (K+2 and K+3), so we are going to print the 32-bit
     2FCA 0040     
9906                                                                          ; number (0 0 Y X)
9907               
9908                                                                          ; Finally we fall through into BPRNT to print out the
9909                                                                          ; number in K to K+3, which now contains (Y X), to 3
9910                                                                          ; digits (as U = 3), using the same C flag as when pr2
9911                                                                          ; was called to control the decimal point
9912               
9913               * ******************************************************************************
9914               *
9915               * Name: BPRNT
9916               * Type: Subroutine
9917               * Category: Text
9918               * Summary: Print a 32-bit number, left-padded to a specific number of digits,
9919               * with an optional decimal point
9920               * Deep dive: Printing decimal numbers
9921               *
9922               * ------------------------------------------------------------------------------
9923               *
9924               * Print the 32-bit number stored in K(0 1 2 3) to a specific number of digits,
9925               * left-padding with spaces for numbers with fewer digits (so lower numbers are
9926               * right-aligned). Optionally include a decimal point.
9927               *
9928               * See the deep dive on "Printing decimal numbers" for details of the algorithm
9929               * used in this routine.
9930               *
9931               * ------------------------------------------------------------------------------
9932               *
9933               * Arguments:
9934               *
9935               * K(0 1 2 3)          The number to print, stored with the most significant
9936               * byte in K and the least significant in K+3 (i.e. as a
9937               * big-endian number, which is the opposite way to how the
9938               * 6502 assembler stores addresses, for example)
9939               *
9940               * U                   The maximum number of digits to print, including the
9941               * decimal point (spaces will be used on the left to pad
9942               * out the result to this width, so the number is right-
9943               * aligned to this width). U must be 11 or less
9944               *
9945               * C flag              If set, include a decimal point followed by one
9946               * fractional digit (i.e. show the number to 1 decimal
9947               * place). In this case, the number in K(0 1 2 3) contains
9948               * 10 * the number we end up printing, so to print 123.4,
9949               * we would pass 1234 in K(0 1 2 3) and would set the C
9950               * flag to include the decimal point
9951               *
9952               * ******************************************************************************
9953               
9954               BPRNT:
9955 2FCC 0201  20        li   rx,>0b*256                 ; LDX #11           ; Set T to the maximum number of digits allowed (11
     2FCE 0B00     
9956 2FD0 D801  30        movb rx,@T                      ; STX T             ; characters, which is the number of digits in 10
     2FD2 00D1     
9957                                                                          ; billion). We will use this as a flag when printing
9958                                                                          ; characters in TT37 below
9959               
9960                      .php                            ; PHP               ; Make a copy of the status register (in particular
     **** ****     > PHP
0001 2FD4 02C6  12        stst rtmp
0002 2FD6 D686  30        movb rtmp,*rsp
0003 2FD8 060A  14        dec  rsp
                   < elite.a99
9961                                                                          ; the C flag) so we can retrieve it later
9962               
9963 2FDA 1702  14        jnc  TT30                       ; BCC TT30          ; If the C flag is clear, we do not want to print a
9964                                                                          ; decimal point, so skip the next two instructions
9965               
9966 2FDC 7004  18        sb   rone,ra                    ; DEC T             ; As we are going to show a decimal point, decrement
9967 2FDE 7004  18        sb   rone,ra                    ; DEC U             ; both the number of characters and the number of
9968                                                                          ; digits (as one of them is now a decimal point)
9969               
9970               TT30:
9971 2FE0 0200  20        li   ra,>0b*256                 ; LDA #11           ; Set A to 11, the maximum number of digits allowed
     2FE2 0B00     
9972               
9973                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 2FE4 0A15  18        sla  rmone,1
                   < elite.a99
9974                                                                          ; C flag affecting the result
9975               
9976 2FE6 D800  30        movb ra,@XX17                   ; STA XX17          ; Store the maximum number of digits allowed (11) in
     2FE8 0095     
9977                                                                          ; XX17
9978               
9979                      .sbc @U,ra                      ; SBC U             ; Set U = 11 - U + 1, so U now contains the maximum
     **** ****     > SBC
0001 2FEA 1801  14        joc  !
0002 2FEC 7004  18        sb   rone,ra
0003               !:
0004 2FEE 7020  30        sb   @U,ra
     2FF0 008F     
                   < elite.a99
9980 2FF2 D800  30        movb ra,@U                      ; STA U             ; number of digits minus the number of digits we want
     2FF4 008F     
9981 2FF6 B004  18        ab   rone,ra                    ; INC U             ; to display, plus 1 (so this is the number of digits
9982                                                                          ; we should skip before starting to print the number
9983                                                                          ; itself, and the plus 1 is there to ensure we print at
9984                                                                          ; least one digit)
9985               
9986 2FF8 0202  20        li   ry,>00*256                 ; LDY #0            ; In the main loop below, we use Y to count the number
     2FFA 0000     
9987                                                                          ; of times we subtract 10 billion to get the leftmost
9988                                                                          ; digit, so set this to zero
9989               
9990 2FFC D802  30        movb ry,@S                      ; STY S             ; In the main loop below, we use location S as an
     2FFE 0092     
9991                                                                          ; 8-bit overflow for the 32-bit calculations, so
9992                                                                          ; we need to set this to 0 before joining the loop
9993               
9994 3000 0460  28        b    @TT36                      ; JMP TT36          ; Jump to TT36 to start the process of printing this
     3002 30D4     
9995                                                                          ; number's digits
9996               
9997               TT35:
9998                                                                          ; This subroutine multiplies K(S 0 1 2 3) by 10 and
9999                                                                          ; stores the result back in K(S 0 1 2 3), using the fact
10000                                                                          ; that K * 10 = (K * 2) + (K * 2 * 2 * 2)
10001                      .asl @K+3                       ; ASL K+3           ; Set K(S 0 1 2 3) = K(S 0 1 2 3) * 2 by rotating left
     **** ****     > ASL
0001 3004 D1A0  30        movb @K+3,rtmp
     3006 0040     
0002 3008 0246  22        andi rtmp,>ff00
     300A FF00     
0003 300C 0A16  18        sla  rtmp,1
0004 300E D806  30        movb rtmp,@K+3
     3010 0040     
                   < elite.a99
10002 3012 0208  20        li   rarg1,K+2                  ; ROL K+2
     3014 003F     
10003 3016 06A0  32        bl   @rol                       ;
     3018 FF36     
10004 301A 0208  20        li   rarg1,K+1                  ; ROL K+1
     301C 003E     
10005 301E 06A0  32        bl   @rol                       ;
     3020 FF36     
10006 3022 0208  20        li   rarg1,K                    ; ROL K
     3024 003D     
10007 3026 06A0  32        bl   @rol                       ;
     3028 FF36     
10008 302A 0208  20        li   rarg1,S                    ; ROL S
     302C 0092     
10009 302E 06A0  32        bl   @rol                       ;
     3030 FF36     
10010               
10011 3032 0201  20        li   rx,>03*256                 ; LDX #3            ; Now we want to make a copy of the newly doubled K in
     3034 0300     
10012                                                                          ; XX15, so we can use it for the first (K * 2) in the
10013                                                                          ; equation above, so set up a counter in X for copying
10014                                                                          ; four bytes, starting with the last byte in memory
10015                                                                          ; (i.e. the least significant)
10016               
10017               tt35_:
10018 3036 D021  34        movb @K(rx),ra                  ; LDA K,X           ; Copy the X-th byte of K(0 1 2 3) to the X-th byte of
     3038 003D     
10019 303A D840  38        movb ra,@XX15(rx)               ; STA XX15,X        ; XX15(0 1 2 3), so that XX15 will contain a copy of
     303C 0031     
10020                                                                          ; K(0 1 2 3) once we've copied all four bytes
10021               
10022 303E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10023               
10024 3040 15FA  14        jgt  tt35_                      ; BPL tt35          ; Loop back to copy the next byte until we have copied
10025                                                                          ; all four
10026               
10027 3042 D020  30        movb @S,ra                      ; LDA S             ; Store the value of location S, our overflow byte, in
     3044 0092     
10028 3046 D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; XX15+4, so now XX15(4 0 1 2 3) contains a copy of
     3048 0035     
10029                                                                          ; K(S 0 1 2 3), which is the value of (K * 2) that we
10030                                                                          ; want to use in our calculation
10031               
10032                      .asl @K+3                       ; ASL K+3           ; Now to calculate the (K * 2 * 2 * 2) part. We still
     **** ****     > ASL
0001 304A D1A0  30        movb @K+3,rtmp
     304C 0040     
0002 304E 0246  22        andi rtmp,>ff00
     3050 FF00     
0003 3052 0A16  18        sla  rtmp,1
0004 3054 D806  30        movb rtmp,@K+3
     3056 0040     
                   < elite.a99
10033 3058 0208  20        li   rarg1,K+2                  ; ROL K+2           ; have (K * 2) in K(S 0 1 2 3), so we just need to shift
     305A 003F     
10034 305C 06A0  32        bl   @rol                       ;
     305E FF36     
10035 3060 0208  20        li   rarg1,K+1                  ; ROL K+1           ; it twice. This is the first one, so we do this:
     3062 003E     
10036 3064 06A0  32        bl   @rol                       ;
     3066 FF36     
10037 3068 0208  20        li   rarg1,K                    ; ROL K             ;
     306A 003D     
10038 306C 06A0  32        bl   @rol                       ;
     306E FF36     
10039 3070 0208  20        li   rarg1,S                    ; ROL S             ; K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 4
     3072 0092     
10040 3074 06A0  32        bl   @rol                       ;
     3076 FF36     
10041               
10042                      .asl @K+3                       ; ASL K+3           ; And then we do it again, so that means:
     **** ****     > ASL
0001 3078 D1A0  30        movb @K+3,rtmp
     307A 0040     
0002 307C 0246  22        andi rtmp,>ff00
     307E FF00     
0003 3080 0A16  18        sla  rtmp,1
0004 3082 D806  30        movb rtmp,@K+3
     3084 0040     
                   < elite.a99
10043 3086 0208  20        li   rarg1,K+2                  ; ROL K+2           ;
     3088 003F     
10044 308A 06A0  32        bl   @rol                       ;
     308C FF36     
10045 308E 0208  20        li   rarg1,K+1                  ; ROL K+1           ; K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 8
     3090 003E     
10046 3092 06A0  32        bl   @rol                       ;
     3094 FF36     
10047 3096 0208  20        li   rarg1,K                    ; ROL K
     3098 003D     
10048 309A 06A0  32        bl   @rol                       ;
     309C FF36     
10049 309E 0208  20        li   rarg1,S                    ; ROL S
     30A0 0092     
10050 30A2 06A0  32        bl   @rol                       ;
     30A4 FF36     
10051               
10052                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 30A6 0A13  18        sla  rzero,1
                   < elite.a99
10053                                                                          ; C flag affecting the result
10054               
10055 30A8 0201  20        li   rx,>03*256                 ; LDX #3            ; By now we've got (K * 2) in XX15(4 0 1 2 3) and
     30AA 0300     
10056                                                                          ; (K * 8) in K(S 0 1 2 3), so the final step is to add
10057                                                                          ; these two 32-bit numbers together to get K * 10.
10058                                                                          ; So we set a counter in X for four bytes, starting
10059                                                                          ; with the last byte in memory (i.e. the least
10060                                                                          ; significant)
10061               
10062               tt36_:
10063 30AC D021  34        movb @K(rx),ra                  ; LDA K,X           ; Fetch the X-th byte of K into A
     30AE 003D     
10064               
10065                      .adc @XX15(rx),ra               ; ADC XX15,X        ; Add the X-th byte of XX15 to A, with carry
     **** ****     > ADC
0001 30B0 1701  14        jnc  !
0002 30B2 B004  18        ab   rone,ra
0003               !:
0004 30B4 B021  34        ab   @XX15(RX),ra
     30B6 0031     
                   < elite.a99
10066               
10067 30B8 D840  38        movb ra,@K(rx)                  ; STA K,X           ; Store the result in the X-th byte of K
     30BA 003D     
10068               
10069 30BC 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10070               
10071 30BE 15F6  14        jgt  tt36_                      ; BPL tt36          ; Loop back to add the next byte, moving from the least
10072                                                                          ; significant byte to the most significant, until we
10073                                                                          ; have added all four
10074               
10075 30C0 D020  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Finally, fetch the overflow byte from XX15(4 0 1 2 3)
     30C2 0035     
10076               
10077                      .adc @S,ra                      ; ADC S             ; And add it to the overflow byte from K(S 0 1 2 3),
     **** ****     > ADC
0001 30C4 1701  14        jnc  !
0002 30C6 B004  18        ab   rone,ra
0003               !:
0004 30C8 B020  30        ab   @S,ra
     30CA 0092     
                   < elite.a99
10078                                                                          ; with carry
10079               
10080 30CC D800  30        movb ra,@S                      ; STA S             ; And store the result in the overflow byte from
     30CE 0092     
10081                                                                          ; K(S 0 1 2 3), so now we have our desired result, i.e.
10082                                                                          ;
10083                                                                          ; K(S 0 1 2 3) = K(S 0 1 2 3) * 10
10084               
10085 30D0 0202  20        li   ry,>00*256                 ; LDY #0            ; In the main loop below, we use Y to count the number
     30D2 0000     
10086                                                                          ; of times we subtract 10 billion to get the leftmost
10087                                                                          ; digit, so set this to zero so we can rejoin the main
10088                                                                          ; loop for another subtraction process
10089               
10090               TT36:
10091                                                                          ; This is the main loop of our digit-printing routine.
10092                                                                          ; In the following loop, we are going to count the
10093                                                                          ; number of times that we can subtract 10 million and
10094                                                                          ; store that count in Y, which we have already set to 0
10095 30D4 0201  20        li   rx,>03*256                 ; LDX #3            ; Our first calculation concerns 32-bit numbers, so
     30D6 0300     
10096                                                                          ; set up a counter for a four-byte loop
10097               
10098                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 30D8 0A15  18        sla  rmone,1
                   < elite.a99
10099                                                                          ; C flag affecting the result
10100               
10101               tt37_:
10102                                                                          ; We now loop through each byte in turn to do this:
10103                                                                          ;
10104                                                                          ; XX15(4 0 1 2 3) = K(S 0 1 2 3) - 100,000,000,000
10105 30DA D021  34        movb @K(rx),ra                  ; LDA K,X           ; Subtract the X-th byte of TENS (i.e. 10 billion) from
     30DC 003D     
10106                      .sbc @TENS(rx),ra               ; SBC TENS,X        ; the X-th byte of K
     **** ****     > SBC
0001 30DE 1801  14        joc  !
0002 30E0 7004  18        sb   rone,ra
0003               !:
0004 30E2 7021  34        sb   @TENS(RX),ra
     30E4 2FA8     
                   < elite.a99
10107               
10108 30E6 D840  38        movb ra,@XX15(rx)               ; STA XX15,X        ; Store the result in the X-th byte of XX15
     30E8 0031     
10109               
10110 30EA 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10111               
10112 30EC 15F6  14        jgt  tt37_                      ; BPL tt37          ; Loop back to subtract the next byte, moving from the
10113                                                                          ; least significant byte to the most significant, until
10114                                                                          ; we have subtracted all four
10115               
10116 30EE D020  30        movb @S,ra                      ; LDA S             ; Subtract the fifth byte of 10 billion (i.e. &17) from
     30F0 0092     
10117                      .sbi (>17*256)                  ; SBC #&17          ; the fifth (overflow) byte of K, which is S
     **** ****     > SBI
0001 30F2 1801  14        joc  !
0002 30F4 7004  18        sb   rone,ra
0003               !:
0004 30F6 0220  22        ai   ra,-(>17*256)
     30F8 E900     
                   < elite.a99
10118               
10119 30FA D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; Store the result in the overflow byte of XX15
     30FC 0035     
10120               
10121 30FE 170F  14        jnc  TT37                       ; BCC TT37          ; If subtracting 10 billion took us below zero, jump to
10122                                                                          ; TT37 to print out this digit, which is now in Y
10123               
10124 3100 0201  20        li   rx,>03*256                 ; LDX #3            ; We now want to copy XX15(4 0 1 2 3) back into
     3102 0300     
10125                                                                          ; K(S 0 1 2 3), so we can loop back up to do the next
10126                                                                          ; subtraction, so set up a counter for a four-byte loop
10127               
10128               tt38_:
10129 3104 D021  34        movb @XX15(rx),ra               ; LDA XX15,X        ; Copy the X-th byte of XX15(0 1 2 3) to the X-th byte
     3106 0031     
10130 3108 D840  38        movb ra,@K(rx)                  ; STA K,X           ; of K(0 1 2 3), so that K(0 1 2 3) will contain a copy
     310A 003D     
10131                                                                          ; of XX15(0 1 2 3) once we've copied all four bytes
10132               
10133 310C 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10134               
10135 310E 15FA  14        jgt  tt38_                      ; BPL tt38          ; Loop back to copy the next byte, until we have copied
10136                                                                          ; all four
10137               
10138 3110 D020  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Store the value of location XX15+4, our overflow
     3112 0035     
10139 3114 D800  30        movb ra,@S                      ; STA S             ; byte in S, so now K(S 0 1 2 3) contains a copy of
     3116 0092     
10140                                                                          ; XX15(4 0 1 2 3)
10141               
10142 3118 B084  18        ab   rone,ry                    ; INY               ; We have now managed to subtract 10 billion from our
10143                                                                          ; number, so increment Y, which is where we are keeping
10144                                                                          ; a count of the number of subtractions so far
10145               
10146 311A 0460  28        b    @TT36                      ; JMP TT36          ; Jump back to TT36 to subtract the next 10 billion
     311C 30D4     
10147               
10148               TT37:
10149 311E D002  18        movb ry,ra                      ; TYA               ; If we get here then Y contains the digit that we want
10150                                                                          ; to print (as Y has now counted the total number of
10151                                                                          ; subtractions of 10 billion), so transfer Y into A
10152               
10153 3120 1608  14        jne  TT32                       ; BNE TT32          ; If the digit is non-zero, jump to TT32 to print it
10154               
10155 3122 D020  30        movb @T,ra                      ; LDA T             ; Otherwise the digit is zero. If we are already
     3124 00D1     
10156                                                                          ; printing the number then we will want to print a 0,
10157                                                                          ; but if we haven't started printing the number yet,
10158                                                                          ; then we probably don't, as we don't want to print
10159                                                                          ; leading zeroes unless this is the only digit before
10160                                                                          ; the decimal point
10161                                                                          ;
10162                                                                          ; To help with this, we are going to use T as a flag
10163                                                                          ; that tells us whether we have already started
10164                                                                          ; printing digits:
10165                                                                          ;
10166                                                                          ; * If T <> 0 we haven't printed anything yet
10167                                                                          ;
10168                                                                          ; * If T = 0 then we have started printing digits
10169                                                                          ;
10170                                                                          ; We initially set T above to the maximum number of
10171                                                                          ; characters allowed, less 1 if we are printing a
10172                                                                          ; decimal point, so the first time we enter the digit
10173                                                                          ; printing routine at TT37, it is definitely non-zero
10174               
10175 3126 1305  14        jeq  TT32                       ; BEQ TT32          ; If T = 0, jump straight to the print routine at TT32,
10176                                                                          ; as we have already started printing the number, so we
10177                                                                          ; definitely want to print this digit too
10178               
10179 3128 7004  18        sb   rone,ra                    ; DEC U             ; We initially set U to the number of digits we want to
10180 312A 1510  14        jgt  TT34                       ; BPL TT34          ; skip before starting to print the number. If we get
10181                                                                          ; here then we haven't printed any digits yet, so
10182                                                                          ; decrement U to see if we have reached the point where
10183                                                                          ; we should start printing the number, and if not, jump
10184                                                                          ; to TT34 to set up things for the next digit
10185               
10186 312C 0200  20        li   ra,(' ')*256               ; LDA #' '          ; We haven't started printing any digits yet, but we
     312E 2000     
10187 3130 1609  14        jne  tt34_                      ; BNE tt34          ; have reached the point where we should start printing
10188                                                                          ; our number, so call TT26 (via tt34) to print a space
10189                                                                          ; so that the number is left-padded with spaces (this
10190                                                                          ; BNE is effectively a JMP as A will never be zero)
10191               
10192               TT32:
10193 3132 0202  20        li   ry,>00*256                 ; LDY #0            ; We are printing an actual digit, so first set T to 0,
     3134 0000     
10194 3136 D802  30        movb ry,@T                      ; STY T             ; to denote that we have now started printing digits as
     3138 00D1     
10195                                                                          ; opposed to spaces
10196               
10197                      .clc                            ; CLC               ; The digit value is in A, so add ASCII "0" to get the
     **** ****     > CLC
0001 313A 0A13  18        sla  rzero,1
                   < elite.a99
10198                      .adi (('0')*256)                ; ADC #'0'          ; ASCII character number to print
     **** ****     > ADI
0001 313C 1701  14        jnc  !
0002 313E B004  18        ab   rone,ra
0003               !:
0004 3140 0220  22        ai   ra,(('0')*256)
     3142 3000     
                   < elite.a99
10199               
10200               tt34_:
10201 3144 0206  20        li   rtmp,TT26                  ; JSR TT26          ; Call TT26 to print the character in A and fall through
     3146 3172     
10202 3148 06A0  32        bl   @jsr                       ;
     314A FF10     
10203                                                                          ; into TT34 to get things ready for the next digit
10204               
10205               TT34:
10206 314C 7004  18        sb   rone,ra                    ; DEC T             ; Decrement T but keep T >= 0 (by incrementing it
10207 314E 1501  14        jgt  B24                        ; BPL B24           ; again if the above decrement made T negative)
10208 3150 B004  18        ab   rone,ra                    ; INC T
10209               
10210               B24:
10211 3152 7004  18        sb   rone,ra                    ; DEC XX17          ; Decrement the total number of characters left to
10212                                                                          ; print, which we stored in XX17
10213               
10214 3154 1166  14        jlt  RR3+1                      ; BMI RR3+1         ; If the result is negative, we have printed all the
10215                                                                          ; characters, so return from the subroutine (as RR3
10216                                                                          ; contains an ORA #&60 instruction, so RR3+1 is &60,
10217                                                                          ; which is the opcode for an RTS)
10218               
10219 3156 1609  14        jne  B25                        ; BNE B25           ; If the result is positive (> 0) then we still have
10220                                                                          ; characters left to print, so loop back to TT35 (via
10221                                                                          ; the JMP TT35 instruction below) to print the next
10222                                                                          ; digit
10223               
10224                      .plp                            ; PLP               ; If we get here then we have printed the exact number
     **** ****     > PLP
0001 3158 058A  14        INC  rsp
0002 315A D19A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
10225                                                                          ; of digits that we wanted to, so restore the C flag
10226                                                                          ; that we stored at the start of the routine
10227               
10228 315C 1706  14        jnc  B25                        ; BCC B25           ; If the C flag is clear, we don't want a decimal point,
10229                                                                          ; so loop back to TT35 (via the JMP TT35 instruction
10230                                                                          ; below) to print the next digit
10231               
10232 315E 0200  20        li   ra,('.')*256               ; LDA #'.'          ; Otherwise the C flag is set, so print the decimal
     3160 2E00     
10233 3162 0206  20        li   rtmp,TT26                  ; JSR TT26          ; point
     3164 3172     
10234 3166 06A0  32        bl   @jsr                       ;
     3168 FF10     
10235               
10236               B25:
10237 316A 0460  28        b    @TT35                      ; JMP TT35          ; Loop back to TT35 to print the next digit
     316C 3004     
10238               
10239               * ******************************************************************************
10240               *
10241               * Name: BELL
10242               * Type: Subroutine
10243               * Category: Sound
10244               * Summary: Make a standard system beep
10245               *
10246               * ------------------------------------------------------------------------------
10247               *
10248               * This is the standard system beep, as made by the ASCII 7 "BELL" control code.
10249               *
10250               * ******************************************************************************
10251               
10252               BELL:
10253 316E 0200  20        li   ra,>07*256                 ; LDA #7            ; Control code 7 makes a beep, so load this into A
     3170 0700     
10254               
10255                                                                          ; Fall through into the TT26 print routine to
10256                                                                          ; actually make the sound
10257               
10258               * ******************************************************************************
10259               *
10260               * Name: TT26
10261               * Type: Subroutine
10262               * Category: Text
10263               * Summary: Print a character at the text cursor by poking into screen memory
10264               * Deep dive: Drawing text
10265               *
10266               * ------------------------------------------------------------------------------
10267               *
10268               * Print a character at the text cursor (XC, YC), do a beep, print a newline,
10269               * or delete left (backspace).
10270               *
10271               * WRCHV is set to point here by the loading process.
10272               *
10273               * ------------------------------------------------------------------------------
10274               *
10275               * Arguments:
10276               *
10277               * A                   The character to be printed. Can be one of the
10278               * following:
10279               *
10280               * * 7 (beep)
10281               *
10282               * * 10-13 (line feeds and carriage returns)
10283               *
10284               * * 32-95 (ASCII capital letters, numbers and
10285               * punctuation)
10286               *
10287               * * 127 (delete the character to the left of the text
10288               * cursor and move the cursor to the left)
10289               *
10290               * XC                  Contains the text column to print at (the x-coordinate)
10291               *
10292               * YC                  Contains the line number to print on (the y-coordinate)
10293               *
10294               * ------------------------------------------------------------------------------
10295               *
10296               * Returns:
10297               *
10298               * A                   A is preserved
10299               *
10300               * X                   X is preserved
10301               *
10302               * Y                   Y is preserved
10303               *
10304               * C flag              The C flag is cleared
10305               *
10306               * ------------------------------------------------------------------------------
10307               *
10308               * Other entry points:
10309               *
10310               * RR3+1               Contains an RTS
10311               *
10312               * RREN                Prints the character definition pointed to by P(2 1) at
10313               * the screen address pointed to by (A SC). Used by the
10314               * BULB routine
10315               *
10316               * rT9                 Contains an RTS
10317               *
10318               * ******************************************************************************
10319               
10320               TT26:
10321 3172 D800  30        movb ra,@K3                     ; STA K3            ; Store the A, X and Y registers, so we can restore
     3174 00D2     
10322 3176 D802  30        movb ry,@YSAV2                  ; STY YSAV2         ; them at the end (so they don't get changed by this
     3178 0F0F     
10323 317A D801  30        movb rx,@XSAV2                  ; STX XSAV2         ; routine)
     317C 0F0E     
10324               
10325 317E D0A0  30        movb @QQ17,ry                   ; LDY QQ17          ; Load the QQ17 flag, which contains the text printing
     3180 007E     
10326                                                                          ; flags
10327               
10328 3182 0282  22        ci   ry,>ff*256                 ; CPY #255          ; If QQ17 = 255 then printing is disabled, so jump to
     3184 FF00     
10329 3186 1366  14        jeq  RR4                        ; BEQ RR4           ; RR4, which doesn't print anything, it just restores
10330                                                                          ; the registers and returns from the subroutine
10331               
10332 3188 0280  22        ci   ra,>07*256                 ; CMP #7            ; If this is a beep character (A = 7), jump to R5,
     318A 0700     
10333 318C 136C  14        jeq  R5_                        ; BEQ R5_           ; which will emit the beep, restore the registers and
10334                                                                          ; return from the subroutine
10335               
10336 318E 0280  22        ci   ra,>20*256                 ; CMP #32           ; If this is an ASCII character (A >= 32), jump to RR1
     3190 2000     
10337 3192 1809  14        joc  RR1                        ; BCS RR1           ; below, which will print the character, restore the
10338                                                                          ; registers and return from the subroutine
10339               
10340 3194 0280  22        ci   ra,>0a*256                 ; CMP #10           ; If this is control code 10 (line feed) then jump to
     3196 0A00     
10341 3198 1304  14        jeq  RRX1                       ; BEQ RRX1          ; RRX1, which will move down a line, restore the
10342                                                                          ; registers and return from the subroutine
10343               
10344 319A 0201  20        li   rx,>01*256                 ; LDX #1            ; If we get here, then this is control code 11-13, of
     319C 0100     
10345 319E D801  30        movb rx,@XC                     ; STX XC            ; which only 13 is used. This code prints a newline,
     31A0 002C     
10346                                                                          ; which we can achieve by moving the text cursor
10347                                                                          ; to the start of the line (carriage return) and down
10348                                                                          ; one line (line feed). These two lines do the first
10349                                                                          ; bit by setting XC = 1, and we then fall through into
10350                                                                          ; the line feed routine that's used by control code 10
10351               
10352               RRX1:
10353 31A2 B004  18        ab   rone,ra                    ; INC YC            ; Print a line feed, simply by incrementing the row
10354                                                                          ; number (y-coordinate) of the text cursor, which is
10355                                                                          ; stored in YC
10356               
10357 31A4 1657  14        jne  RR4                        ; BNE RR4           ; Jump to RR4 to restore the registers and return from
10358                                                                          ; the subroutine (this BNE is effectively a JMP as Y
10359                                                                          ; will never be zero)
10360               
10361               RR1:
10362                                                                          ; If we get here, then the character to print is an
10363                                                                          ; ASCII character in the range 32-95. The quickest way
10364                                                                          ; to display text on-screen is to poke the character
10365                                                                          ; pixel by pixel, directly into screen memory, so
10366                                                                          ; that's what the rest of this routine does
10367                                                                          ;
10368                                                                          ; The first step, then, is to get hold of the bitmap
10369                                                                          ; definition for the character we want to draw on the
10370                                                                          ; screen (i.e. we need the pixel shape of this
10371                                                                          ; character). The MOS ROM contains bitmap definitions
10372                                                                          ; of the system's ASCII characters, starting from &C000
10373                                                                          ; for space (ASCII 32) and ending with the  symbol
10374                                                                          ; (ASCII 126)
10375                                                                          ;
10376                                                                          ; There are definitions for 32 characters in each of the
10377                                                                          ; three pages of MOS memory, as each definition takes up
10378                                                                          ; 8 bytes (8 rows of 8 pixels) and 32 * 8 = 256 bytes =
10379                                                                          ; 1 page. So:
10380                                                                          ;
10381                                                                          ; ASCII 32-63  are defined in &C000-&C0FF (page 0)
10382                                                                          ; ASCII 64-95  are defined in &C100-&C1FF (page 1)
10383                                                                          ; ASCII 96-126 are defined in &C200-&C2F0 (page 2)
10384                                                                          ;
10385                                                                          ; The following code reads the relevant character
10386                                                                          ; bitmap from the above locations in ROM and pokes
10387                                                                          ; those values into the correct position in screen
10388                                                                          ; memory, thus printing the character on-screen
10389                                                                          ;
10390                                                                          ; It's a long way from 10 PRINT "Hello world!":GOTO 10
10391               * LDX #LO(K3)            \ These instructions are commented out in the original
10392               * INX                    \ source, but they call OSWORD 10, which reads the
10393               * STX P+1                \ character bitmap for the character number in K3 and
10394               * DEX                    \ stores it in the block at K3+1, while also setting
10395               * LDY #HI(K3)            \ P+1 to point to the character definition. This is
10396               * STY P+2                \ exactly what the following uncommented code does,
10397               * LDA #10                \ just without calling OSWORD. Presumably the code
10398               * JSR OSWORD             \ below is faster than using the system call, as this
10399                                                                          ; version takes up 15 bytes, while the version below
10400                                                                          ; (which ends with STA P+1 and SYX P+2) is 17 bytes.
10401                                                                          ; Every efficiency saving helps, especially as this
10402                                                                          ; routine is run each time the game prints a character
10403                                                                          ;
10404                                                                          ; If you want to switch this code back on, uncomment
10405                                                                          ; the above block, and comment out the code below from
10406                                                                          ; TAY to STX P+2. You will also need to uncomment the
10407                                                                          ; LDA YC instruction a few lines down (in RR2), just to
10408                                                                          ; make sure the rest of the code doesn't shift in
10409                                                                          ; memory. To be honest I can't see a massive difference
10410                                                                          ; in speed, but there you go
10411 31A6 D080  18        movb ra,ry                      ; TAY               ; Copy the character number from A to Y, as we are
10412                                                                          ; about to pull A apart to work out where this
10413                                                                          ; character definition lives in memory
10414               
10415                                                                          ; Now we want to set X to point to the relevant page
10416                                                                          ; number for this character - i.e. &C0, &C1 or &C2.
10417               
10418                                                                          ; The following logic is easier to follow if we look
10419                                                                          ; at the three character number ranges in binary:
10420                                                                          ;
10421                                                                          ; Bit #  76543210
10422                                                                          ;
10423                                                                          ; 32  = %00100000     Page 0 of bitmap definitions
10424                                                                          ; 63  = %00111111
10425                                                                          ;
10426                                                                          ; 64  = %01000000     Page 1 of bitmap definitions
10427                                                                          ; 95  = %01011111
10428                                                                          ;
10429                                                                          ; 96  = %01100000     Page 2 of bitmap definitions
10430                                                                          ; 125 = %01111101
10431                                                                          ;
10432                                                                          ; We'll refer to this below
10433               
10434 31A8 0201  20        li   rx,>bf*256                 ; LDX #&BF          ; Set X to point to the first font page in ROM minus 1,
     31AA BF00     
10435                                                                          ; which is &C0 - 1, or &BF
10436               
10437                      .asla                           ; ASL A             ; If bit 6 of the character is clear (A is 32-63)
     **** ****     > ASLA
0001 31AC 0240  22        andi ra,>ff00
     31AE FF00     
0002 31B0 0A10  18        sla  ra,1
                   < elite.a99
10438                      .asla                           ; ASL A             ; then skip the following instruction
     **** ****     > ASLA
0001 31B2 0240  22        andi ra,>ff00
     31B4 FF00     
0002 31B6 0A10  18        sla  ra,1
                   < elite.a99
10439 31B8 1702  14        jnc  B26                        ; BCC B26
10440               
10441 31BA 0201  20        li   rx,>c1*256                 ; LDX #&C1          ; A is 64-126, so set X to point to page &C1
     31BC C100     
10442               
10443               B26:
10444                      .asla                           ; ASL A             ; If bit 5 of the character is clear (A is 64-95)
     **** ****     > ASLA
0001 31BE 0240  22        andi ra,>ff00
     31C0 FF00     
0002 31C2 0A10  18        sla  ra,1
                   < elite.a99
10445 31C4 1701  14        jnc  B27                        ; BCC B27           ; then skip the following instruction
10446               
10447 31C6 B044  18        ab   rone,rx                    ; INX               ; Increment X
10448                                                                          ;
10449                                                                          ; By this point, we started with X = &BF, and then
10450                                                                          ; we did the following:
10451                                                                          ;
10452                                                                          ; If A = 32-63:   skip    then INX  so X = &C0
10453                                                                          ; If A = 64-95:   X = &C1 then skip so X = &C1
10454                                                                          ; If A = 96-126:  X = &C1 then INX  so X = &C2
10455                                                                          ;
10456                                                                          ; In other words, X points to the relevant page. But
10457                                                                          ; what about the value of A? That gets shifted to the
10458                                                                          ; left three times during the above code, which
10459                                                                          ; multiplies the number by 8 but also drops bits 7, 6
10460                                                                          ; and 5 in the process. Look at the above binary
10461                                                                          ; figures and you can see that if we cleared bits 5-7,
10462                                                                          ; then that would change 32-53 to 0-31... but it would
10463                                                                          ; do exactly the same to 64-95 and 96-125. And because
10464                                                                          ; we also multiply this figure by 8, A now points to
10465                                                                          ; the start of the character's definition within its
10466                                                                          ; page (because there are 8 bytes per character
10467                                                                          ; definition)
10468                                                                          ;
10469                                                                          ; Or, to put it another way, X contains the high byte
10470                                                                          ; (the page) of the address of the definition that we
10471                                                                          ; want, while A contains the low byte (the offset into
10472                                                                          ; the page) of the address
10473               
10474               B27:
10475 31C8 D800  30        movb ra,@P+1                    ; STA P+1           ; Store the address of this character's definition in
     31CA 001C     
10476 31CC D801  30        movb rx,@P+2                    ; STX P+2           ; P(2 1)
     31CE 001D     
10477               
10478 31D0 D020  30        movb @XC,ra                     ; LDA XC            ; Fetch XC, the x-coordinate (column) of the text cursor
     31D2 002C     
10479                                                                          ; into A
10480               
10481                      .asla                           ; ASL A             ; Multiply A by 8, and store in SC. As each character is
     **** ****     > ASLA
0001 31D4 0240  22        andi ra,>ff00
     31D6 FF00     
0002 31D8 0A10  18        sla  ra,1
                   < elite.a99
10482                      .asla                           ; ASL A             ; 8 pixels wide, and the special screen mode Elite uses
     **** ****     > ASLA
0001 31DA 0240  22        andi ra,>ff00
     31DC FF00     
0002 31DE 0A10  18        sla  ra,1
                   < elite.a99
10483                      .asla                           ; ASL A             ; for the top part of the screen is 256 pixels across
     **** ****     > ASLA
0001 31E0 0240  22        andi ra,>ff00
     31E2 FF00     
0002 31E4 0A10  18        sla  ra,1
                   < elite.a99
10484 31E6 D800  30        movb ra,@SC                     ; STA SC            ; with one bit per pixel, this value is not only the
     31E8 0007     
10485                                                                          ; screen address offset of the text cursor from the left
10486                                                                          ; side of the screen, it's also the least significant
10487                                                                          ; byte of the screen address where we want to print this
10488                                                                          ; character, as each row of on-screen pixels corresponds
10489                                                                          ; to one page. To put this more explicitly, the screen
10490                                                                          ; starts at &6000, so the text rows are stored in screen
10491                                                                          ; memory like this:
10492                                                                          ;
10493                                                                          ; Row 1: &6000 - &60FF    YC = 1, XC = 0 to 31
10494                                                                          ; Row 2: &6100 - &61FF    YC = 2, XC = 0 to 31
10495                                                                          ; Row 3: &6200 - &62FF    YC = 3, XC = 0 to 31
10496                                                                          ;
10497                                                                          ; and so on
10498               
10499 31EA D020  30        movb @YC,ra                     ; LDA YC            ; Fetch YC, the y-coordinate (row) of the text cursor
     31EC 002D     
10500               
10501 31EE 0282  22        ci   ry,>7f*256                 ; CPY #127          ; If the character number (which is in Y) <> 127, then
     31F0 7F00     
10502 31F2 160D  14        jne  RR2                        ; BNE RR2           ; skip to RR2 to print that character, otherwise this is
10503                                                                          ; the delete character, so continue on
10504               
10505 31F4 7004  18        sb   rone,ra                    ; DEC XC            ; We want to delete the character to the left of the
10506                                                                          ; text cursor and move the cursor back one, so let's
10507                                                                          ; do that by decrementing YC. Note that this doesn't
10508                                                                          ; have anything to do with the actual deletion below,
10509                                                                          ; we're just updating the cursor so it's in the right
10510                                                                          ; position following the deletion
10511               
10512                      .adi (>5e*256)                  ; ADC #&5E          ; A contains YC (from above) and the C flag is set (from
     **** ****     > ADI
0001 31F6 1701  14        jnc  !
0002 31F8 B004  18        ab   rone,ra
0003               !:
0004 31FA 0220  22        ai   ra,(>5E*256)
     31FC 5E00     
                   < elite.a99
10513 31FE D040  18        movb ra,rx                      ; TAX               ; the CPY #127 above), so these instructions do this:
10514                                                                          ;
10515                                                                          ; X = YC + &5E + 1
10516                                                                          ; = YC + &5F
10517               
10518                                                                          ; Because YC starts at 0 for the first text row, this
10519                                                                          ; means that X will be &5F for row 0, &60 for row 1 and
10520                                                                          ; so on. In other words, X is now set to the page number
10521                                                                          ; for the row before the one containing the text cursor,
10522                                                                          ; and given that we set SC above to point to the offset
10523                                                                          ; in memory of the text cursor within the row's page,
10524                                                                          ; this means that (X SC) now points to the character
10525                                                                          ; above the text cursor
10526               
10527 3200 0202  20        li   ry,>f8*256                 ; LDY #&F8          ; Set Y = &F8, so the following call to ZES2 will count
     3202 F800     
10528                                                                          ; Y upwards from &F8 to &FF
10529               
10530 3204 0206  20        li   rtmp,ZES2                  ; JSR ZES2          ; Call ZES2, which zero-fills from address (X SC) + Y to
     3206 C826     
10531 3208 06A0  32        bl   @jsr                       ;
     320A FF10     
10532                                                                          ; (X SC) + &FF. (X SC) points to the character above the
10533                                                                          ; text cursor, and adding &FF to this would point to the
10534                                                                          ; cursor, so adding &F8 points to the character before
10535                                                                          ; the cursor, which is the one we want to delete. So
10536                                                                          ; this call zero-fills the character to the left of the
10537                                                                          ; cursor, which erases it from the screen
10538               
10539 320C 1323  14        jeq  RR4                        ; BEQ RR4           ; We are done deleting, so restore the registers and
10540                                                                          ; return from the subroutine (this BNE is effectively
10541                                                                          ; a JMP as ZES2 always returns with the Z flag set)
10542               
10543               RR2:
10544                                                                          ; Now to actually print the character
10545 320E B004  18        ab   rone,ra                    ; INC XC            ; Once we print the character, we want to move the text
10546                                                                          ; cursor to the right, so we do this by incrementing
10547                                                                          ; XC. Note that this doesn't have anything to do
10548                                                                          ; with the actual printing below, we're just updating
10549                                                                          ; the cursor so it's in the right position following
10550                                                                          ; the print
10551               
10552               * LDA YC                 \ This instruction is commented out in the original
10553                                                                          ; source. It isn't required because we only just did a
10554                                                                          ; LDA YC before jumping to RR2, so this is presumably
10555                                                                          ; an example of the authors squeezing the code to save
10556                                                                          ; 2 bytes and 3 cycles
10557                                                                          ;
10558                                                                          ; If you want to re-enable the commented block near the
10559                                                                          ; start of this routine, you should uncomment this
10560                                                                          ; instruction as well
10561               
10562 3210 0280  22        ci   ra,>18*256                 ; CMP #24           ; If the text cursor is on the screen (i.e. YC < 24, so
     3212 1800     
10563 3214 1706  14        jnc  RR3                        ; BCC RR3           ; we are on rows 0-23), then jump to RR3 to print the
10564                                                                          ; character
10565               
10566 3216 0206  20        li   rtmp,TTX66                 ; JSR TTX66         ; Otherwise we are off the bottom of the screen, so
     3218 4B2E     
10567 321A 06A0  32        bl   @jsr                       ;
     321C FF10     
10568                                                                          ; clear the screen and draw a white border
10569               
10570 321E 0460  28        b    @RR4                       ; JMP RR4           ; And restore the registers and return from the
     3220 3254     
10571                                                                          ; subroutine
10572               
10573               RR3:
10574                                                                          ; A contains the value of YC - the screen row where we
10575                                                                          ; want to print this character - so now we need to
10576                                                                          ; convert this into a screen address, so we can poke
10577                                                                          ; the character data to the right place in screen
10578                                                                          ; memory
10579 3222 0260  22        ori  ra,>60*256                 ; ORA #&60          ; We already stored the least significant byte
     3224 6000     
10580                                                                          ; of this screen address in SC above (see the STA SC
10581                                                                          ; instruction above), so all we need is the most
10582                                                                          ; significant byte. As mentioned above, in Elite's
10583                                                                          ; square mode 4 screen, each row of text on-screen
10584                                                                          ; takes up exactly one page, so the first row is page
10585                                                                          ; &60xx, the second row is page &61xx, so we can get
10586                                                                          ; the page for character (XC, YC) by OR'ing with &60.
10587                                                                          ; To see this in action, consider that our two values
10588                                                                          ; are, in binary:
10589                                                                          ;
10590                                                                          ; YC is between:  %00000000
10591                                                                          ; and:  %00010111
10592                                                                          ; &60 is:  %01100000
10593                                                                          ;
10594                                                                          ; so YC OR &60 effectively adds &60 to YC, giving us
10595                                                                          ; the page number that we want
10596               
10597               RREN:
10598 3226 D800  30        movb ra,@SC+1                   ; STA SC+1          ; Store the page number of the destination screen
     3228 0008     
10599                                                                          ; location in SC+1, so SC now points to the full screen
10600                                                                          ; location where this character should go
10601               
10602 322A 0202  20        li   ry,>07*256                 ; LDY #7            ; We want to print the 8 bytes of character data to the
     322C 0700     
10603                                                                          ; screen (one byte per row), so set up a counter in Y
10604                                                                          ; to count these bytes
10605               
10606               RRL1:
10607                      .ld_ind_y_idx @P+1,ra           ; LDA (P+1),Y       ; The character definition is at P(2 1) - we set this up
     **** ****     > LD_IND_Y_IDX
0001 322E D820  50        movb @P+1,@rtmplb
     3230 001C     
     3232 2079     
0002 3234 D1A0  30        movb @P+1+1,rtmp
     3236 001D     
0003 3238 A182  18        a    ry,rtmp
0004 323A D016  26        movb *rtmp,RA
                   < elite.a99
10608                                                                          ; above - so load the Y-th byte from P(2 1), which will
10609                                                                          ; contain the bitmap for the Y-th row of the character
10610               
10611                      .eor @SC                        ; EOR (SC),Y        ; If we EOR this value with the existing screen
     **** ****     > EOR
0001 323C D1A0  30        movb @SC,rtmp
     323E 0007     
0002 3240 2806  18        xor  rtmp,ra
                   < elite.a99
10612                                                                          ; contents, then it's reversible (so reprinting the
10613                                                                          ; same character in the same place will revert the
10614                                                                          ; screen to what it looked like before we printed
10615                                                                          ; anything); this means that printing a white pixel
10616                                                                          ; onto a white background results in a black pixel, but
10617                                                                          ; that's a small price to pay for easily erasable text
10618               
10619                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Store the Y-th byte at the screen address for this
     **** ****     > ST_IND_Y_IDX
0001 3242 D820  50        movb @SC,@rtmplb
     3244 0007     
     3246 2079     
0002 3248 D1A0  30        movb @SC+1,rtmp
     324A 0008     
0003 324C A182  18        a    ry,rtmp
0004 324E D580  30        movb RA,*rtmp
                   < elite.a99
10620                                                                          ; character location
10621               
10622 3250 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
10623               
10624 3252 15ED  14        jgt  RRL1                       ; BPL RRL1          ; Loop back for the next byte to print to the screen
10625               
10626               RR4:
10627 3254 D0A0  30        movb @YSAV2,ry                  ; LDY YSAV2         ; We're done printing, so restore the values of the
     3256 0F0F     
10628 3258 D060  30        movb @XSAV2,rx                  ; LDX XSAV2         ; A, X and Y registers that we saved above and clear
     325A 0F0E     
10629 325C D020  30        movb @K3,ra                     ; LDA K3            ; the C flag, so everything is back to how it was
     325E 00D2     
10630                      .clc                            ; CLC
     **** ****     > CLC
0001 3260 0A13  18        sla  rzero,1
                   < elite.a99
10631               
10632               rT9:
10633 3262 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3264 FF1C     
10634               
10635               R5_:
10636 3266 0206  20        li   rtmp,BEEP                  ; JSR BEEP          ; Call the BEEP subroutine to make a short, high beep
     3268 CBAC     
10637 326A 06A0  32        bl   @jsr                       ;
     326C FF10     
10638               
10639 326E 0460  28        b    @RR4                       ; JMP RR4           ; Jump to RR4 to restore the registers and return from
     3270 3254     
10640                                                                          ; the subroutine using a tail call
10641               
10642               * ******************************************************************************
10643               *
10644               * Name: DIALS (Part 1 of 4)
10645               * Type: Subroutine
10646               * Category: Dashboard
10647               * Summary: Update the dashboard: speed indicator
10648               * Deep dive: The dashboard indicators
10649               *
10650               * ------------------------------------------------------------------------------
10651               *
10652               * This routine updates the dashboard. First we draw all the indicators in the
10653               * right part of the dashboard, from top (speed) to bottom (energy banks), and
10654               * then we move on to the left part, again drawing from top (forward shield) to
10655               * bottom (altitude).
10656               *
10657               * This first section starts us off with the speedometer in the top right.
10658               *
10659               * ******************************************************************************
10660               
10661               DIALS:
10662 3272 0200  20        li   ra,>d0*256                 ; LDA #&D0          ; Set SC(1 0) = &78D0, which is the screen address for
     3274 D000     
10663 3276 D800  30        movb ra,@SC                     ; STA SC            ; the character block containing the left end of the
     3278 0007     
10664 327A 0200  20        li   ra,>78*256                 ; LDA #&78          ; top indicator in the right part of the dashboard, the
     327C 7800     
10665 327E D800  30        movb ra,@SC+1                   ; STA SC+1          ; one showing our speed
     3280 0008     
10666               
10667 3282 0206  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     3284 3402     
10668 3286 06A0  32        bl   @jsr                       ;
     3288 FF10     
10669                                                                          ; and X to the colour for safe values
10670               
10671 328A D801  30        movb rx,@K+1                    ; STX K+1           ; Set K+1 (the colour we should show for low values) to
     328C 003E     
10672                                                                          ; X (the colour to use for safe values)
10673               
10674 328E D800  30        movb ra,@K                      ; STA K             ; Set K (the colour we should show for high values) to
     3290 003D     
10675                                                                          ; A (the colour to use for dangerous values)
10676               
10677                                                                          ; The above sets the following indicators to show red
10678                                                                          ; for high values and yellow/white for low values
10679               
10680 3292 0200  20        li   ra,>0e*256                 ; LDA #14           ; Set T1 to 14, the threshold at which we change the
     3294 0E00     
10681 3296 D800  30        movb ra,@T1                     ; STA T1            ; indicator's colour
     3298 0006     
10682               
10683 329A D020  30        movb @DELTA,ra                  ; LDA DELTA         ; Fetch our ship's speed into A, in the range 0-40
     329C 008C     
10684               
10685               * LSR A                  \ Draw the speed indicator using a range of 0-31, and
10686 329E 0206  20        li   rtmp,DIL-1                 ; JSR DIL-1         ; increment SC to point to the next indicator (the roll
     32A0 342B     
10687 32A2 06A0  32        bl   @jsr                       ;
     32A4 FF10     
10688                                                                          ; indicator). The LSR is commented out as it isn't
10689                                                                          ; required with a call to DIL-1, so perhaps this was
10690                                                                          ; originally a call to DIL that got optimised
10691               
10692               * ******************************************************************************
10693               *
10694               * Name: DIALS (Part 2 of 4)
10695               * Type: Subroutine
10696               * Category: Dashboard
10697               * Summary: Update the dashboard: pitch and roll indicators
10698               * Deep dive: The dashboard indicators
10699               *
10700               * ******************************************************************************
10701               
10702 32A6 0200  20        li   ra,>00*256                 ; LDA #0            ; Set R = P = 0 for the low bytes in the call to the ADD
     32A8 0000     
10703 32AA D800  30        movb ra,@R                      ; STA R             ; routine below
     32AC 0091     
10704 32AE D800  30        movb ra,@P                      ; STA P
     32B0 001B     
10705               
10706 32B2 0200  20        li   ra,>08*256                 ; LDA #8            ; Set S = 8, which is the value of the centre of the
     32B4 0800     
10707 32B6 D800  30        movb ra,@S                      ; STA S             ; roll indicator
     32B8 0092     
10708               
10709 32BA D020  30        movb @ALP1,ra                   ; LDA ALP1          ; Fetch the roll angle alpha as a value between 0 and
     32BC 0087     
10710 32BE 0910  18        srl  ra,1                       ; LSR A             ; 31, and divide by 4 to get a value of 0 to 7
10711 32C0 0910  18        srl  ra,1                       ; LSR A
10712               
10713 32C2 F020  30        socb @ALP2,ra                   ; ORA ALP2          ; Apply the roll sign to the value, and flip the sign,
     32C4 0088     
10714                      .eoi (>80*256)                  ; EOR #%10000000    ; so it's now in the range -7 to +7, with a positive
     **** ****     > EOI
0001 32C6 0206  20        li   rtmp,(>80*256)
     32C8 8000     
0002 32CA 2806  18        xor  rtmp,ra
                   < elite.a99
10715                                                                          ; roll angle alpha giving a negative value in A
10716               
10717 32CC 0206  20        li   rtmp,ADD                   ; JSR ADD           ; We now add A to S to give us a value in the range 1 to
     32CE 44BA     
10718 32D0 06A0  32        bl   @jsr                       ;
     32D2 FF10     
10719                                                                          ; 15, which we can pass to DIL2 to draw the vertical
10720                                                                          ; bar on the indicator at this position. We use the ADD
10721                                                                          ; routine like this:
10722                                                                          ;
10723                                                                          ; (A X) = (A 0) + (S 0)
10724                                                                          ;
10725                                                                          ; and just take the high byte of the result. We use ADD
10726                                                                          ; rather than a normal ADC because ADD separates out the
10727                                                                          ; sign bit and does the arithmetic using absolute values
10728                                                                          ; and separate sign bits, which we want here rather than
10729                                                                          ; the two's complement that ADC uses
10730               
10731 32D4 0206  20        li   rtmp,DIL2                  ; JSR DIL2          ; Draw a vertical bar on the roll indicator at offset A
     32D6 34F6     
10732 32D8 06A0  32        bl   @jsr                       ;
     32DA FF10     
10733                                                                          ; and increment SC to point to the next indicator (the
10734                                                                          ; pitch indicator)
10735               
10736 32DC D020  30        movb @BETA,ra                   ; LDA BETA          ; Fetch the pitch angle beta as a value between -8 and
     32DE 002A     
10737                                                                          ; +8
10738               
10739 32E0 D060  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the magnitude of the pitch angle beta, and if it
     32E2 002B     
10740 32E4 1304  14        jeq  B28                        ; BEQ B28           ; is 0 (i.e. we are not pitching), skip the next
10741                                                                          ; instruction
10742               
10743                      .sbi (>01*256)                  ; SBC #1            ; The pitch angle beta is non-zero, so set A = A - 1
     **** ****     > SBI
0001 32E6 1801  14        joc  !
0002 32E8 7004  18        sb   rone,ra
0003               !:
0004 32EA 0220  22        ai   ra,-(>01*256)
     32EC FF00     
                   < elite.a99
10744                                                                          ; (the C flag is set by the call to DIL2 above, so we
10745                                                                          ; don't need to do a SEC). This gives us a value of A
10746                                                                          ; from -7 to +7 because these are magnitude-based
10747                                                                          ; numbers with sign bits, rather than two's complement
10748                                                                          ; numbers
10749               
10750               B28:
10751 32EE 0206  20        li   rtmp,ADD                   ; JSR ADD           ; We now add A to S to give us a value in the range 1 to
     32F0 44BA     
10752 32F2 06A0  32        bl   @jsr                       ;
     32F4 FF10     
10753                                                                          ; 15, which we can pass to DIL2 to draw the vertical
10754                                                                          ; bar on the indicator at this position (see the JSR ADD
10755                                                                          ; above for more on this)
10756               
10757 32F6 0206  20        li   rtmp,DIL2                  ; JSR DIL2          ; Draw a vertical bar on the pitch indicator at offset A
     32F8 34F6     
10758 32FA 06A0  32        bl   @jsr                       ;
     32FC FF10     
10759                                                                          ; and increment SC to point to the next indicator (the
10760                                                                          ; four energy banks)
10761               
10762               * ******************************************************************************
10763               *
10764               * Name: DIALS (Part 3 of 4)
10765               * Type: Subroutine
10766               * Category: Dashboard
10767               * Summary: Update the dashboard: four energy banks
10768               * Deep dive: The dashboard indicators
10769               *
10770               * ------------------------------------------------------------------------------
10771               *
10772               * This and the next section only run once every four iterations of the main
10773               * loop, so while the speed, pitch and roll indicators update every iteration,
10774               * the other indicators update less often.
10775               *
10776               * ******************************************************************************
10777               
10778 32FE D020  30        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 4,
     3300 0099     
10779 3302 0240  22        andi ra,>03*256                 ; AND #3            ; jumping to rT9 if it is non-zero. rT9 contains an RTS,
     3304 0300     
10780 3306 16AD  14        jne  rT9                        ; BNE rT9           ; so the following code only runs every 4 iterations of
10781                                                                          ; the main loop, otherwise we return from the subroutine
10782               
10783 3308 0202  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0, for use in various places below
     330A 0000     
10784               
10785 330C 0206  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     330E 3402     
10786 3310 06A0  32        bl   @jsr                       ;
     3312 FF10     
10787                                                                          ; and X to the colour for safe values
10788               
10789 3314 D801  30        movb rx,@K                      ; STX K             ; Set K (the colour we should show for high values) to X
     3316 003D     
10790                                                                          ; (the colour to use for safe values)
10791               
10792 3318 D800  30        movb ra,@K+1                    ; STA K+1           ; Set K+1 (the colour we should show for low values) to
     331A 003E     
10793                                                                          ; A (the colour to use for dangerous values)
10794               
10795                                                                          ; The above sets the following indicators to show red
10796                                                                          ; for low values and yellow/white for high values, which
10797                                                                          ; we use not only for the energy banks, but also for the
10798                                                                          ; shield levels and current fuel
10799               
10800 331C 0201  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X so we can zero the four bytes at
     331E 0300     
10801                                                                          ; XX12, so we can then calculate each of the four energy
10802                                                                          ; banks' values before drawing them later
10803               
10804 3320 D801  30        movb rx,@T1                     ; STX T1            ; Set T1 to 3, the threshold at which we change the
     3322 0006     
10805                                                                          ; indicator's colour
10806               
10807               DLL23:
10808 3324 D842  38        movb ry,@XX12(rx)               ; STY XX12,X        ; Set the X-th byte of XX12 to 0
     3326 0037     
10809               
10810 3328 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
10811               
10812 332A 15FC  14        jgt  DLL23                      ; BPL DLL23         ; Loop back for the next byte until the four bytes at
10813                                                                          ; XX12 are all zeroed
10814               
10815 332C 0201  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X to loop through the 4 energy
     332E 0300     
10816                                                                          ; bank indicators, so we can calculate each of the four
10817                                                                          ; energy banks' values and store them in XX12
10818               
10819 3330 D020  30        movb @ENERGY,ra                 ; LDA ENERGY        ; Set A = Q = ENERGY / 4, so they are both now in the
     3332 0F13     
10820 3334 0910  18        srl  ra,1                       ; LSR A             ; range 0-63 (so that's a maximum of 16 in each of the
10821 3336 0910  18        srl  ra,1                       ; LSR A             ; banks, and a maximum of 15 in the top bank)
10822               
10823 3338 D800  30        movb ra,@Q                      ; STA Q             ; Set Q to A, so we can use Q to hold the remaining
     333A 0090     
10824                                                                          ; energy as we work our way through each bank, from the
10825                                                                          ; full ones at the bottom to the empty ones at the top
10826               
10827               DLL24:
10828                      .sec                            ; SEC               ; Set A = A - 16 to reduce the energy count by a full
     **** ****     > SEC
0001 333C 0A15  18        sla  rmone,1
                   < elite.a99
10829                      .sbi (>10*256)                  ; SBC #16           ; bank
     **** ****     > SBI
0001 333E 1801  14        joc  !
0002 3340 7004  18        sb   rone,ra
0003               !:
0004 3342 0220  22        ai   ra,-(>10*256)
     3344 F000     
                   < elite.a99
10830               
10831 3346 170B  14        jnc  DLL26                      ; BCC DLL26         ; If the C flag is clear then A < 16, so this bank is
10832                                                                          ; not full to the brim, and is therefore the last one
10833                                                                          ; with any energy in it, so jump to DLL26
10834               
10835 3348 D800  30        movb ra,@Q                      ; STA Q             ; This bank is full, so update Q with the energy of the
     334A 0090     
10836                                                                          ; remaining banks
10837               
10838 334C 0200  20        li   ra,>10*256                 ; LDA #16           ; Store this bank's level in XX12 as 16, as it is full,
     334E 1000     
10839 3350 D840  38        movb ra,@XX12(rx)               ; STA XX12,X        ; with XX12+3 for the bottom bank and XX12+0 for the top
     3352 0037     
10840               
10841 3354 D020  30        movb @Q,ra                      ; LDA Q             ; Set A to the remaining energy level again
     3356 0090     
10842               
10843 3358 7044  18        sb   rone,rx                    ; DEX               ; Decrement X to point to the next bank, i.e. the one
10844                                                                          ; above the bank we just processed
10845               
10846 335A 15F0  14        jgt  DLL24                      ; BPL DLL24         ; Loop back to DLL24 until we have either processed all
10847                                                                          ; four banks, or jumped out early to DLL26 if the top
10848                                                                          ; banks have no charge
10849               
10850 335C 1104  14        jlt  DLL9                       ; BMI DLL9          ; Jump to DLL9 as we have processed all four banks (this
10851                                                                          ; BMI is effectively a JMP as A will never be positive)
10852               
10853               DLL26:
10854 335E D020  30        movb @Q,ra                      ; LDA Q             ; If we get here then the bank we just checked is not
     3360 0090     
10855 3362 D840  38        movb ra,@XX12(rx)               ; STA XX12,X        ; fully charged, so store its value in XX12 (using Q,
     3364 0037     
10856                                                                          ; which contains the energy of the remaining banks -
10857                                                                          ; i.e. this one)
10858               
10859                                                                          ; Now that we have the four energy bank values in XX12,
10860                                                                          ; we can draw them, starting with the top bank in XX12
10861                                                                          ; and looping down to the bottom bank in XX12+3, using Y
10862                                                                          ; as a loop counter, which was set to 0 above
10863               
10864               DLL9:
10865 3366 D022  34        movb @XX12(ry),ra               ; LDA XX12,Y        ; Fetch the value of the Y-th indicator, starting from
     3368 0037     
10866                                                                          ; the top
10867               
10868 336A D802  30        movb ry,@P                      ; STY P             ; Store the indicator number in P for retrieval later
     336C 001B     
10869               
10870 336E 0206  20        li   rtmp,DIL                   ; JSR DIL           ; Draw the energy bank using a range of 0-15, and
     3370 342C     
10871 3372 06A0  32        bl   @jsr                       ;
     3374 FF10     
10872                                                                          ; increment SC to point to the next indicator (the
10873                                                                          ; next energy bank down)
10874               
10875 3376 D0A0  30        movb @P,ry                      ; LDY P             ; Restore the indicator number into Y
     3378 001B     
10876               
10877 337A B084  18        ab   rone,ry                    ; INY               ; Increment the indicator number
10878               
10879 337C 0282  22        ci   ry,>04*256                 ; CPY #4            ; Check to see if we have drawn the last energy bank
     337E 0400     
10880               
10881 3380 16F2  14        jne  DLL9                       ; BNE DLL9          ; Loop back to DLL9 if we have more banks to draw,
10882                                                                          ; otherwise we are done
10883               
10884               * ******************************************************************************
10885               *
10886               * Name: DIALS (Part 4 of 4)
10887               * Type: Subroutine
10888               * Category: Dashboard
10889               * Summary: Update the dashboard: shields, fuel, laser & cabin temp, altitude
10890               * Deep dive: The dashboard indicators
10891               *
10892               * ******************************************************************************
10893               
10894 3382 0200  20        li   ra,>78*256                 ; LDA #&78          ; Set SC(1 0) = &7810, which is the screen address for
     3384 7800     
10895 3386 D800  30        movb ra,@SC+1                   ; STA SC+1          ; the character block containing the left end of the
     3388 0008     
10896 338A 0200  20        li   ra,>10*256                 ; LDA #&10          ; top indicator in the left part of the dashboard, the
     338C 1000     
10897 338E D800  30        movb ra,@SC                     ; STA SC            ; one showing the forward shield
     3390 0007     
10898               
10899 3392 D020  30        movb @FSH,ra                    ; LDA FSH           ; Draw the forward shield indicator using a range of
     3394 0F11     
10900 3396 0206  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     3398 3424     
10901 339A 06A0  32        bl   @jsr                       ;
     339C FF10     
10902                                                                          ; (the aft shield)
10903               
10904 339E D020  30        movb @ASH,ra                    ; LDA ASH           ; Draw the aft shield indicator using a range of 0-255,
     33A0 0F12     
10905 33A2 0206  20        li   rtmp,DILX                  ; JSR DILX          ; and increment SC to point to the next indicator (the
     33A4 3424     
10906 33A6 06A0  32        bl   @jsr                       ;
     33A8 FF10     
10907                                                                          ; fuel level)
10908               
10909 33AA D020  30        movb @QQ14,ra                   ; LDA QQ14          ; Draw the fuel level indicator using a range of 0-63,
     33AC 030D     
10910 33AE 0206  20        li   rtmp,DILX+2                ; JSR DILX+2        ; and increment SC to point to the next indicator (the
     33B0 3426     
10911 33B2 06A0  32        bl   @jsr                       ;
     33B4 FF10     
10912                                                                          ; cabin temperature)
10913               
10914 33B6 0206  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     33B8 3402     
10915 33BA 06A0  32        bl   @jsr                       ;
     33BC FF10     
10916                                                                          ; and X to the colour for safe values
10917               
10918 33BE D801  30        movb rx,@K+1                    ; STX K+1           ; Set K+1 (the colour we should show for low values) to
     33C0 003E     
10919                                                                          ; X (the colour to use for safe values)
10920               
10921 33C2 D800  30        movb ra,@K                      ; STA K             ; Set K (the colour we should show for high values) to
     33C4 003D     
10922                                                                          ; A (the colour to use for dangerous values)
10923               
10924                                                                          ; The above sets the following indicators to show red
10925                                                                          ; for high values and yellow/white for low values, which
10926                                                                          ; we use for the cabin and laser temperature bars
10927               
10928 33C6 0201  20        li   rx,>0b*256                 ; LDX #11           ; Set T1 to 11, the threshold at which we change the
     33C8 0B00     
10929 33CA D801  30        movb rx,@T1                     ; STX T1            ; cabin and laser temperature indicators' colours
     33CC 0006     
10930               
10931 33CE D020  30        movb @CABTMP,ra                 ; LDA CABTMP        ; Draw the cabin temperature indicator using a range of
     33D0 0D4D     
10932 33D2 0206  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     33D4 3424     
10933 33D6 06A0  32        bl   @jsr                       ;
     33D8 FF10     
10934                                                                          ; (the laser temperature)
10935               
10936 33DA D020  30        movb @GNTMP,ra                  ; LDA GNTMP         ; Draw the laser temperature indicator using a range of
     33DC 0D61     
10937 33DE 0206  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     33E0 3424     
10938 33E2 06A0  32        bl   @jsr                       ;
     33E4 FF10     
10939                                                                          ; (the altitude)
10940               
10941 33E6 0200  20        li   ra,>f0*256                 ; LDA #240          ; Set T1 to 240, the threshold at which we change the
     33E8 F000     
10942 33EA D800  30        movb ra,@T1                     ; STA T1            ; altitude indicator's colour. As the altitude has a
     33EC 0006     
10943                                                                          ; range of 0-255, pixel 16 will not be filled in, and
10944                                                                          ; 240 would change the colour when moving between pixels
10945                                                                          ; 15 and 16, so this effectively switches off the colour
10946                                                                          ; change for the altitude indicator
10947               
10948 33EE D800  30        movb ra,@K+1                    ; STA K+1           ; Set K+1 (the colour we should show for low values) to
     33F0 003E     
10949                                                                          ; 240, or &F0 (dashboard colour 2, yellow/white), so the
10950                                                                          ; altitude indicator always shows in this colour
10951               
10952 33F2 D020  30        movb @ALTIT,ra                  ; LDA ALTIT         ; Draw the altitude indicator using a range of 0-255
     33F4 0F21     
10953 33F6 0206  20        li   rtmp,DILX                  ; JSR DILX
     33F8 3424     
10954 33FA 06A0  32        bl   @jsr                       ;
     33FC FF10     
10955               
10956 33FE 0460  28        b    @COMPAS                    ; JMP COMPAS        ; We have now drawn all the indicators, so jump to
     3400 ACF6     
10957                                                                          ; COMPAS to draw the compass, returning from the
10958                                                                          ; subroutine using a tail call
10959               
10960               * ******************************************************************************
10961               *
10962               * Name: PZW
10963               * Type: Subroutine
10964               * Category: Dashboard
10965               * Summary: Fetch the current dashboard colours, to support flashing
10966               *
10967               * ------------------------------------------------------------------------------
10968               *
10969               * Set A and X to the colours we should use for indicators showing dangerous and
10970               * safe values respectively. This enables us to implement flashing indicators,
10971               * which is one of the game's configurable options.
10972               *
10973               * If flashing is enabled, the colour returned in A (dangerous values) will be
10974               * red for 8 iterations of the main loop, and yellow/white for the next 8, before
10975               * going back to red. If we always use PZW to decide which colours we should use
10976               * when updating indicators, flashing colours will be automatically taken care of
10977               * for us.
10978               *
10979               * The values returned are &F0 for yellow/white and &0F for red. These are mode 5
10980               * bytes that contain 4 pixels, with the colour of each pixel given in two bits,
10981               * the high bit from the first nibble (bits 4-7) and the low bit from the second
10982               * nibble (bits 0-3). So in &F0 each pixel is %10, or colour 2 (yellow or white,
10983               * depending on the dashboard palette), while in &0F each pixel is %01, or colour
10984               * 1 (red).
10985               *
10986               * ------------------------------------------------------------------------------
10987               *
10988               * Returns:
10989               *
10990               * A                   The colour to use for indicators with dangerous values
10991               *
10992               * X                   The colour to use for indicators with safe values
10993               *
10994               * ******************************************************************************
10995               
10996               PZW:
10997 3402 0201  20        li   rx,>f0*256                 ; LDX #&F0          ; Set X to dashboard colour 2 (yellow/white)
     3404 F000     
10998               
10999 3406 D020  30        movb @MCNT,ra                   ; LDA MCNT          ; A will be non-zero for 8 out of every 16 main loop
     3408 0099     
11000 340A 0240  22        andi ra,>08*256                 ; AND #%00001000    ; counts, when bit 4 is set, so this is what we use to
     340C 0800     
11001                                                                          ; flash the "danger" colour
11002               
11003                      .and @FLH                       ; AND FLH           ; A will be zeroed if flashing colours are disabled
     **** ****     > AND
0001 340E D1A0  30        movb @FLH,rtmp
     3410 0F4D     
0002 3412 0546  14        inv  rtmp
0003 3414 5006  18        szcb rtmp,ra
                   < elite.a99
11004               
11005 3416 1302  14        jeq  B29                        ; BEQ B29           ; If A is zero, skip to the LDA instruction below
11006               
11007 3418 D001  18        movb rx,ra                      ; TXA               ; Otherwise flashing colours are enabled and it's the
11008                                                                          ; main loop iteration where we flash them, so set A to
11009                                                                          ; colour 2 (yellow/white) and use the BIT trick below to
11010                                                                          ; return from the subroutine
11011               
11012 341A 2C              byte >2c                                            ; Skip the next instruction by turning it into
11013                                                                          ; &2C &A9 &0F, or BIT &0FA9, which does nothing apart
11014                                                                          ; from affect the flags
11015               
11016               B29:
11017 341C 0200  20        li   ra,>0f*256                 ; LDA #&0F          ; Set A to dashboard colour 1 (red)
     341E 0F00     
11018               
11019 3420 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3422 FF1C     
11020               
11021               * ******************************************************************************
11022               *
11023               * Name: DILX
11024               * Type: Subroutine
11025               * Category: Dashboard
11026               * Summary: Update a bar-based indicator on the dashboard
11027               * Deep dive: The dashboard indicators
11028               *
11029               * ------------------------------------------------------------------------------
11030               *
11031               * The range of values shown on the indicator depends on which entry point is
11032               * called. For the default entry point of DILX, the range is 0-255 (as the value
11033               * passed in A is one byte). The other entry points are shown below.
11034               *
11035               * ------------------------------------------------------------------------------
11036               *
11037               * Arguments:
11038               *
11039               * A                   The value to be shown on the indicator (so the larger
11040               * the value, the longer the bar)
11041               *
11042               * T1                  The threshold at which we change the indicator's colour
11043               * from the low value colour to the high value colour. The
11044               * threshold is in pixels, so it should have a value from
11045               * 0-16, as each bar indicator is 16 pixels wide
11046               *
11047               * K                   The colour to use when A is a high value, as a 4-pixel
11048               * mode 5 character row byte
11049               *
11050               * K+1                 The colour to use when A is a low value, as a 4-pixel
11051               * mode 5 character row byte
11052               *
11053               * SC(1 0)             The screen address of the first character block in the
11054               * indicator
11055               *
11056               * ------------------------------------------------------------------------------
11057               *
11058               * Other entry points:
11059               *
11060               * DILX+2              The range of the indicator is 0-64 (for the fuel
11061               * indicator)
11062               *
11063               * DIL-1               The range of the indicator is 0-32 (for the speed
11064               * indicator)
11065               *
11066               * DIL                 The range of the indicator is 0-16 (for the energy
11067               * banks)
11068               *
11069               * ******************************************************************************
11070               
11071               DILX:
11072 3424 0910  18        srl  ra,1                       ; LSR A             ; If we call DILX, we set A = A / 16, so A is 0-15
11073 3426 0910  18        srl  ra,1                       ; LSR A
11074               
11075 3428 0910  18        srl  ra,1                       ; LSR A             ; If we call DILX+2, we set A = A / 4, so A is 0-15
11076               
11077 342A 0910  18        srl  ra,1                       ; LSR A             ; If we call DIL-1, we set A = A / 2, so A is 0-15
11078               
11079               DIL:
11080                                                                          ; If we call DIL, we leave A alone, so A is 0-15
11081 342C D800  30        movb ra,@Q                      ; STA Q             ; Store the indicator value in Q, now reduced to 0-15,
     342E 0090     
11082                                                                          ; which is the length of the indicator to draw in pixels
11083               
11084 3430 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Set R = &FF, to use as a mask for drawing each row of
     3432 FF00     
11085 3434 D801  30        movb rx,@R                      ; STX R             ; each character block of the bar, starting with a full
     3436 0091     
11086                                                                          ; character's width of 4 pixels
11087               
11088 3438 9020  30        cb   @T1,ra                     ; CMP T1            ; If A >= T1 then we have passed the threshold where we
     343A 0006     
11089 343C 1803  14        joc  DL30                       ; BCS DL30          ; change bar colour, so jump to DL30 to set A to the
11090                                                                          ; "high value" colour
11091               
11092 343E D020  30        movb @K+1,ra                    ; LDA K+1           ; Set A to K+1, the "low value" colour to use
     3440 003E     
11093               
11094 3442 1602  14        jne  DL31                       ; BNE DL31          ; Jump down to DL31 (this BNE is effectively a JMP as A
11095                                                                          ; will never be zero)
11096               
11097               DL30:
11098 3444 D020  30        movb @K,ra                      ; LDA K             ; Set A to K, the "high value" colour to use
     3446 003D     
11099               
11100               DL31:
11101 3448 D800  30        movb ra,@COL                    ; STA COL           ; Store the colour of the indicator in COL
     344A 00A2     
11102               
11103 344C 0202  20        li   ry,>02*256                 ; LDY #2            ; We want to start drawing the indicator on the third
     344E 0200     
11104                                                                          ; line in this character row, so set Y to point to that
11105                                                                          ; row's offset
11106               
11107 3450 0201  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X for the width of the indicator,
     3452 0300     
11108                                                                          ; which is 4 characters (each of which is 4 pixels wide,
11109                                                                          ; to give a total width of 16 pixels)
11110               
11111               DL1:
11112 3454 D020  30        movb @Q,ra                      ; LDA Q             ; Fetch the indicator value (0-15) from Q into A
     3456 0090     
11113               
11114 3458 0280  22        ci   ra,>04*256                 ; CMP #4            ; If Q < 4, then we need to draw the end cap of the
     345A 0400     
11115 345C 172D  14        jnc  DL2                        ; BCC DL2           ; indicator, which is less than a full character's
11116                                                                          ; width, so jump down to DL2 to do this
11117               
11118                      .sbi (>04*256)                  ; SBC #4            ; Otherwise we can draw a 4-pixel wide block, so
     **** ****     > SBI
0001 345E 1801  14        joc  !
0002 3460 7004  18        sb   rone,ra
0003               !:
0004 3462 0220  22        ai   ra,-(>04*256)
     3464 FC00     
                   < elite.a99
11119 3466 D800  30        movb ra,@Q                      ; STA Q             ; subtract 4 from Q so it contains the amount of the
     3468 0090     
11120                                                                          ; indicator that's left to draw after this character
11121               
11122 346A D020  30        movb @R,ra                      ; LDA R             ; Fetch the shape of the indicator row that we need to
     346C 0091     
11123                                                                          ; display from R, so we can use it as a mask when
11124                                                                          ; painting the indicator. It will be &FF at this point
11125                                                                          ; (i.e. a full 4-pixel row)
11126               
11127               DL5:
11128                      .and @COL                       ; AND COL           ; Fetch the 4-pixel mode 5 colour byte from COL, and
     **** ****     > AND
0001 346E D1A0  30        movb @COL,rtmp
     3470 00A2     
0002 3472 0546  14        inv  rtmp
0003 3474 5006  18        szcb rtmp,ra
                   < elite.a99
11129                                                                          ; only keep pixels that have their equivalent bits set
11130                                                                          ; in the mask byte in A
11131               
11132                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the shape of the mask on pixel row Y of the
     **** ****     > ST_IND_Y_IDX
0001 3476 D820  50        movb @SC,@rtmplb
     3478 0007     
     347A 2079     
0002 347C D1A0  30        movb @SC+1,rtmp
     347E 0008     
0003 3480 A182  18        a    ry,rtmp
0004 3482 D580  30        movb RA,*rtmp
                   < elite.a99
11133                                                                          ; character block we are processing
11134               
11135 3484 B084  18        ab   rone,ry                    ; INY               ; Draw the next pixel row, incrementing Y
11136                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 3486 D820  50        movb @SC,@rtmplb
     3488 0007     
     348A 2079     
0002 348C D1A0  30        movb @SC+1,rtmp
     348E 0008     
0003 3490 A182  18        a    ry,rtmp
0004 3492 D580  30        movb RA,*rtmp
                   < elite.a99
11137               
11138 3494 B084  18        ab   rone,ry                    ; INY               ; And draw the third pixel row, incrementing Y
11139                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 3496 D820  50        movb @SC,@rtmplb
     3498 0007     
     349A 2079     
0002 349C D1A0  30        movb @SC+1,rtmp
     349E 0008     
0003 34A0 A182  18        a    ry,rtmp
0004 34A2 D580  30        movb RA,*rtmp
                   < elite.a99
11140               
11141 34A4 D002  18        movb ry,ra                      ; TYA               ; Add 6 to Y, so Y is now 8 more than when we started
11142                      .clc                            ; CLC               ; this loop iteration, so Y now points to the address
     **** ****     > CLC
0001 34A6 0A13  18        sla  rzero,1
                   < elite.a99
11143                      .adi (>06*256)                  ; ADC #6            ; of the first line of the indicator bar in the next
     **** ****     > ADI
0001 34A8 1701  14        jnc  !
0002 34AA B004  18        ab   rone,ra
0003               !:
0004 34AC 0220  22        ai   ra,(>06*256)
     34AE 0600     
                   < elite.a99
11144 34B0 D080  18        movb ra,ry                      ; TAY               ; character block (as each character is 8 bytes of
11145                                                                          ; screen memory)
11146               
11147 34B2 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter for the next character
11148                                                                          ; block along in the indicator
11149               
11150 34B4 111D  14        jlt  DL6                        ; BMI DL6           ; If we just drew the last character block then we are
11151                                                                          ; done drawing, so jump down to DL6 to finish off
11152               
11153 34B6 15CE  14        jgt  DL1                        ; BPL DL1           ; Loop back to DL1 to draw the next character block of
11154                                                                          ; the indicator (this BPL is effectively a JMP as A will
11155                                                                          ; never be negative following the previous BMI)
11156               
11157               DL2:
11158                      .eoi (>03*256)                  ; EOR #3            ; If we get here then we are drawing the indicator's
     **** ****     > EOI
0001 34B8 0206  20        li   rtmp,(>03*256)
     34BA 0300     
0002 34BC 2806  18        xor  rtmp,ra
                   < elite.a99
11159 34BE D800  30        movb ra,@Q                      ; STA Q             ; end cap, so Q is < 4, and this EOR flips the bits, so
     34C0 0090     
11160                                                                          ; instead of containing the number of indicator columns
11161                                                                          ; we need to fill in on the left side of the cap's
11162                                                                          ; character block, Q now contains the number of blank
11163                                                                          ; columns there should be on the right side of the cap's
11164                                                                          ; character block
11165               
11166 34C2 D020  30        movb @R,ra                      ; LDA R             ; Fetch the current mask from R, which will be &FF at
     34C4 0091     
11167                                                                          ; this point, so we need to turn Q of the columns on the
11168                                                                          ; right side of the mask to black to get the correct end
11169                                                                          ; cap shape for the indicator
11170               
11171               DL3:
11172                      .asla                           ; ASL A             ; Shift the mask left so bit 0 is cleared, and then
     **** ****     > ASLA
0001 34C6 0240  22        andi ra,>ff00
     34C8 FF00     
0002 34CA 0A10  18        sla  ra,1
                   < elite.a99
11173 34CC 0240  22        andi ra,>ef*256                 ; AND #%11101111    ; clear bit 4, which has the effect of shifting zeroes
     34CE EF00     
11174                                                                          ; from the left into each nibble (i.e. xxxx xxxx becomes
11175                                                                          ; xxx0 xxx0, which blanks out the last column in the
11176                                                                          ; 4-pixel mode 5 character block)
11177               
11178 34D0 7004  18        sb   rone,ra                    ; DEC Q             ; Decrement the counter for the number of columns to
11179                                                                          ; blank out
11180               
11181 34D2 15F9  14        jgt  DL3                        ; BPL DL3           ; If we still have columns to blank out in the mask,
11182                                                                          ; loop back to DL3 until the mask is correct for the
11183                                                                          ; end cap
11184               
11185                      .pha                            ; PHA               ; Store the mask byte on the stack while we use the
     **** ****     > PHA
0001 34D4 D680  30        movb ra,*rsp
0002 34D6 060A  14        dec  rsp
                   < elite.a99
11186                                                                          ; accumulator for a bit
11187               
11188 34D8 0200  20        li   ra,>00*256                 ; LDA #0            ; Change the mask so no bits are set, so the characters
     34DA 0000     
11189 34DC D800  30        movb ra,@R                      ; STA R             ; after the one we're about to draw will be all blank
     34DE 0091     
11190               
11191 34E0 0200  20        li   ra,>63*256                 ; LDA #99           ; Set Q to a high number (99, why not) so we will keep
     34E2 6300     
11192 34E4 D800  30        movb ra,@Q                      ; STA Q             ; drawing blank characters until we reach the end of
     34E6 0090     
11193                                                                          ; the indicator row
11194               
11195                      .pla                            ; PLA               ; Restore the mask byte from the stack so we can use it
     **** ****     > PLA
0001 34E8 058A  14        inc  rsp
0002 34EA D01A  26        movb *rsp,ra
                   < elite.a99
11196                                                                          ; to draw the end cap of the indicator
11197               
11198 34EC 0460  28        b    @DL5                       ; JMP DL5           ; Jump back up to DL5 to draw the mask byte on-screen
     34EE 346E     
11199               
11200               DL6:
11201 34F0 B004  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of SC to point to the next
11202                                                                          ; character row on-screen (as each row takes up exactly
11203                                                                          ; one page of 256 bytes) - so this sets up SC to point
11204                                                                          ; to the next indicator, i.e. the one below the one we
11205                                                                          ; just drew
11206               
11207               DL9:
11208 34F2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     34F4 FF1C     
11209               
11210               * ******************************************************************************
11211               *
11212               * Name: DIL2
11213               * Type: Subroutine
11214               * Category: Dashboard
11215               * Summary: Update the roll or pitch indicator on the dashboard
11216               * Deep dive: The dashboard indicators
11217               *
11218               * ------------------------------------------------------------------------------
11219               *
11220               * The indicator can show a vertical bar in 16 positions, with a value of 8
11221               * showing the bar in the middle of the indicator.
11222               *
11223               * In practice this routine is only ever called with A in the range 1 to 15, so
11224               * the vertical bar never appears in the leftmost position (though it does appear
11225               * in the rightmost).
11226               *
11227               * ------------------------------------------------------------------------------
11228               *
11229               * Arguments:
11230               *
11231               * A                   The offset of the vertical bar to show in the indicator,
11232               * from 0 at the far left, to 8 in the middle, and 15 at
11233               * the far right
11234               *
11235               * ------------------------------------------------------------------------------
11236               *
11237               * Returns:
11238               *
11239               * C flag              The C flag is set
11240               *
11241               * ******************************************************************************
11242               
11243               DIL2:
11244 34F6 0202  20        li   ry,>01*256                 ; LDY #1            ; We want to start drawing the vertical indicator bar on
     34F8 0100     
11245                                                                          ; the second line in the indicator's character block, so
11246                                                                          ; set Y to point to that row's offset
11247               
11248 34FA D800  30        movb ra,@Q                      ; STA Q             ; Store the offset of the vertical bar to draw in Q
     34FC 0090     
11249               
11250                                                                          ; We are now going to work our way along the indicator
11251                                                                          ; on the dashboard, from left to right, working our way
11252                                                                          ; along one character block at a time. Y will be used as
11253                                                                          ; a pixel row counter to work our way through the
11254                                                                          ; character blocks, so each time we draw a character
11255                                                                          ; block, we will increment Y by 8 to move on to the next
11256                                                                          ; block (as each character block contains 8 rows)
11257               
11258               DLL10:
11259                      .sec                            ; SEC               ; Set A = Q - 4, so that A contains the offset of the
     **** ****     > SEC
0001 34FE 0A15  18        sla  rmone,1
                   < elite.a99
11260 3500 D020  30        movb @Q,ra                      ; LDA Q             ; vertical bar from the start of this character block
     3502 0090     
11261                      .sbi (>04*256)                  ; SBC #4
     **** ****     > SBI
0001 3504 1801  14        joc  !
0002 3506 7004  18        sb   rone,ra
0003               !:
0004 3508 0220  22        ai   ra,-(>04*256)
     350A FC00     
                   < elite.a99
11262               
11263 350C 180B  14        joc  DLL11                      ; BCS DLL11         ; If Q >= 4 then the character block we are drawing does
11264                                                                          ; not contain the vertical indicator bar, so jump to
11265                                                                          ; DLL11 to draw a blank character block
11266               
11267 350E 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to a high number (and &FF is as high as they go)
     3510 FF00     
11268               
11269 3512 D060  30        movb @Q,rx                      ; LDX Q             ; Set X to the offset of the vertical bar, which we know
     3514 0090     
11270                                                                          ; is within this character block
11271               
11272 3516 D800  30        movb ra,@Q                      ; STA Q             ; Set Q to a high number (&FF, why not) so we will keep
     3518 0090     
11273                                                                          ; drawing blank characters after this one until we reach
11274                                                                          ; the end of the indicator row
11275               
11276 351A D021  34        movb @CTWOS(rx),ra              ; LDA CTWOS,X       ; CTWOS is a table of ready-made 1-pixel mode 5 bytes,
     351C 2249     
11277                                                                          ; just like the TWOS and TWOS2 tables for mode 4 (see
11278                                                                          ; the PIXEL routine for details of how they work). This
11279                                                                          ; fetches a mode 5 1-pixel byte with the pixel position
11280                                                                          ; at X, so the pixel is at the offset that we want for
11281                                                                          ; our vertical bar
11282               
11283 351E 0240  22        andi ra,>f0*256                 ; AND #&F0          ; The 4-pixel mode 5 colour byte &F0 represents four
     3520 F000     
11284                                                                          ; pixels of colour %10 (3), which is yellow in the
11285                                                                          ; normal dashboard palette and white if we have an
11286                                                                          ; escape pod fitted. We AND this with A so that we only
11287                                                                          ; keep the pixel that matches the position of the
11288                                                                          ; vertical bar (i.e. A is acting as a mask on the
11289                                                                          ; 4-pixel colour byte)
11290               
11291 3522 1604  14        jne  DLL12                      ; BNE DLL12         ; Jump to DLL12 to skip the code for drawing a blank,
11292                                                                          ; and move on to drawing the indicator (this BNE is
11293                                                                          ; effectively a JMP as A is always non-zero)
11294               
11295               DLL11:
11296                                                                          ; If we get here then we want to draw a blank for this
11297                                                                          ; character block
11298 3524 D800  30        movb ra,@Q                      ; STA Q             ; Update Q with the new offset of the vertical bar, so
     3526 0090     
11299                                                                          ; it becomes the offset after the character block we
11300                                                                          ; are about to draw
11301               
11302 3528 0200  20        li   ra,>00*256                 ; LDA #0            ; Change the mask so no bits are set, so all of the
     352A 0000     
11303                                                                          ; character blocks we display from now on will be blank
11304               DLL12:
11305                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the shape of the mask on pixel row Y of the
     **** ****     > ST_IND_Y_IDX
0001 352C D820  50        movb @SC,@rtmplb
     352E 0007     
     3530 2079     
0002 3532 D1A0  30        movb @SC+1,rtmp
     3534 0008     
0003 3536 A182  18        a    ry,rtmp
0004 3538 D580  30        movb RA,*rtmp
                   < elite.a99
11306                                                                          ; character block we are processing
11307               
11308 353A B084  18        ab   rone,ry                    ; INY               ; Draw the next pixel row, incrementing Y
11309                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 353C D820  50        movb @SC,@rtmplb
     353E 0007     
     3540 2079     
0002 3542 D1A0  30        movb @SC+1,rtmp
     3544 0008     
0003 3546 A182  18        a    ry,rtmp
0004 3548 D580  30        movb RA,*rtmp
                   < elite.a99
11310               
11311 354A B084  18        ab   rone,ry                    ; INY               ; And draw the third pixel row, incrementing Y
11312                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 354C D820  50        movb @SC,@rtmplb
     354E 0007     
     3550 2079     
0002 3552 D1A0  30        movb @SC+1,rtmp
     3554 0008     
0003 3556 A182  18        a    ry,rtmp
0004 3558 D580  30        movb RA,*rtmp
                   < elite.a99
11313               
11314 355A B084  18        ab   rone,ry                    ; INY               ; And draw the fourth pixel row, incrementing Y
11315                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 355C D820  50        movb @SC,@rtmplb
     355E 0007     
     3560 2079     
0002 3562 D1A0  30        movb @SC+1,rtmp
     3564 0008     
0003 3566 A182  18        a    ry,rtmp
0004 3568 D580  30        movb RA,*rtmp
                   < elite.a99
11316               
11317 356A D002  18        movb ry,ra                      ; TYA               ; Add 5 to Y, so Y is now 8 more than when we started
11318                      .clc                            ; CLC               ; this loop iteration, so Y now points to the address
     **** ****     > CLC
0001 356C 0A13  18        sla  rzero,1
                   < elite.a99
11319                      .adi (>05*256)                  ; ADC #5            ; of the first line of the indicator bar in the next
     **** ****     > ADI
0001 356E 1701  14        jnc  !
0002 3570 B004  18        ab   rone,ra
0003               !:
0004 3572 0220  22        ai   ra,(>05*256)
     3574 0500     
                   < elite.a99
11320 3576 D080  18        movb ra,ry                      ; TAY               ; character block (as each character is 8 bytes of
11321                                                                          ; screen memory)
11322               
11323 3578 0282  22        ci   ry,>1e*256                 ; CPY #30           ; If Y < 30 then we still have some more character
     357A 1E00     
11324 357C 17C0  14        jnc  DLL10                      ; BCC DLL10         ; blocks to draw, so loop back to DLL10 to display the
11325                                                                          ; next one along
11326               
11327 357E B004  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of SC to point to the next
11328                                                                          ; character row on-screen (as each row takes up exactly
11329                                                                          ; one page of 256 bytes) - so this sets up SC to point
11330                                                                          ; to the next indicator, i.e. the one below the one we
11331                                                                          ; just drew
11332               
11333 3580 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3582 FF1C     
11334               
11335               * ******************************************************************************
11336               *
11337               * Name: TVT1
11338               * Type: Variable
11339               * Category: Drawing the screen
11340               * Summary: Palette data for space and the two dashboard colour schemes
11341               *
11342               * ------------------------------------------------------------------------------
11343               *
11344               * Palette bytes for use with the split-screen mode (see IRQ1 below for more
11345               * details).
11346               *
11347               * Palette data is given as a set of bytes, with each byte mapping a logical
11348               * colour to a physical one. In each byte, the logical colour is given in bits
11349               * 4-7 and the physical colour in bits 0-3. See p.379 of the Advanced User Guide
11350               * for details of how palette mapping works, as in modes 4 and 5 we have to do
11351               * multiple palette commands to change the colours correctly, and the physical
11352               * colour value is EOR'd with 7, just to make things even more confusing.
11353               *
11354               * Similarly, the palette at TVT1+16 is for the monochrome space view, where
11355               * logical colour 1 is mapped to physical colour 0 EOR 7 = 7 (white), and
11356               * logical colour 0 is mapped to physical colour 7 EOR 7 = 0 (black). Each of
11357               * these mappings requires six calls to SHEILA &21 - see p.379 of the Advanced
11358               * User Guide for an explanation.
11359               *
11360               * The mode 5 palette table has two blocks which overlap. The block used depends
11361               * on whether or not we have an escape pod fitted. The block at TVT1 is used for
11362               * the standard dashboard colours, while TVT1+8 is used for the dashboard when an
11363               * escape pod is fitted. The colours are as follows:
11364               *
11365               * Normal (TVT1)     Escape pod (TVT1+8)
11366               *
11367               * Colour 0      Black             Black
11368               * Colour 1      Red               Red
11369               * Colour 2      Yellow            White
11370               * Colour 3      Green             Cyan
11371               *
11372               * ******************************************************************************
11373               
11374               TVT1:
11375 3584 D4C4            byte >d4,>c4                                        ; This block of palette data is used to create two
11376 3586 9484            byte >94,>84                                        ; palettes used in three different places, all of them
11377 3588 F5E5            byte >f5,>e5                                        ; redefining four colours in mode 5:
11378 358A B5A5            byte >b5,>a5                                        ;
11379                                                                          ; 12 bytes from TVT1 (i.e. the first 6 rows): applied
11380 358C 7666            byte >76,>66                                        ; when the T1 timer runs down at the switch from the
11381 358E 3626            byte >36,>26                                        ; space view to the dashboard, so this is the standard
11382                                                                          ; dashboard palette
11383 3590 E1F1            byte >e1,>f1                                        ;
11384 3592 B1A1            byte >b1,>a1                                        ; 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
11385                                                                          ; when the T1 timer runs down at the switch from the
11386                                                                          ; space view to the dashboard, and we have an escape
11387                                                                          ; pod fitted, so this is the escape pod dashboard
11388                                                                          ; palette
11389                                                                          ;
11390                                                                          ; 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
11391                                                                          ; at vertical sync in LINSCN when HFX is non-zero, to
11392                                                                          ; create the hyperspace effect in LINSCN (where the
11393                                                                          ; whole screen is switched to mode 5 at vertical sync)
11394               
11395 3594 F0E0            byte >f0,>e0                                        ; 12 bytes of palette data at TVT1+16, used to set the
11396 3596 B0A0            byte >b0,>a0                                        ; mode 4 palette in LINSCN when we hit vertical sync,
11397 3598 D0C0            byte >d0,>c0                                        ; so the palette is set to monochrome when we start to
11398 359A 9080            byte >90,>80                                        ; draw the first row of the screen
11399 359C 7767            byte >77,>67
11400 359E 3727            byte >37,>27
11401               
11402               * ******************************************************************************
11403               *
11404               * Name: IRQ1
11405               * Type: Subroutine
11406               * Category: Drawing the screen
11407               * Summary: The main screen-mode interrupt handler (IRQ1V points here)
11408               * Deep dive: The split-screen mode in BBC Micro Elite
11409               *
11410               * ------------------------------------------------------------------------------
11411               *
11412               * The main interrupt handler, which implements Elite's split-screen mode (see
11413               * the deep dive on "The split-screen mode in BBC Micro Elite" for details).
11414               *
11415               * IRQ1V is set to point to IRQ1 by the loading process.
11416               *
11417               * ******************************************************************************
11418               
11419               LINSCN:
11420                                                                          ; This is called from the interrupt handler below, at
11421                                                                          ; the start of each vertical sync (i.e. when the screen
11422                                                                          ; refresh starts)
11423 35A0 0200  20        li   ra,>1e*256                 ; LDA #30           ; Set the line scan counter to a non-zero value, so
     35A2 1E00     
11424 35A4 D800  30        movb ra,@DL                     ; STA DL            ; routines like WSCAN can set DL to 0 and then wait for
     35A6 009A     
11425                                                                          ; it to change to non-zero to catch the vertical sync
11426               
11427 35A8 D800  38        movb ra,@VIA+>44                ; STA VIA+&44       ; Set 6522 System VIA T1C-L timer 1 low-order counter
     35AA FE44     
11428                                                                          ; (SHEILA &44) to 30
11429               
11430 35AC 0200  20        li   ra,(VSCAN)*256             ; LDA #VSCAN        ; Set 6522 System VIA T1C-L timer 1 high-order counter
     35AE 3900     
11431 35B0 D800  38        movb ra,@VIA+>45                ; STA VIA+&45       ; (SHEILA &45) to VSCAN (57) to start the T1 counter
     35B2 FE45     
11432                                                                          ; counting down from 14622 at a rate of 1 MHz
11433               
11434 35B4 D020  30        movb @HFX,ra                    ; LDA HFX           ; If HFX is non-zero, jump to VNT1 to set the mode 5
     35B6 0D62     
11435 35B8 163D  14        jne  VNT1                       ; BNE VNT1          ; palette instead of switching to mode 4, which will
11436                                                                          ; have the effect of blurring and colouring the top
11437                                                                          ; screen. This is how the white hyperspace rings turn
11438                                                                          ; to colour when we do a hyperspace jump, and is
11439                                                                          ; triggered by setting HFX to 1 in routine LL164
11440               
11441 35BA 0200  20        li   ra,>08*256                 ; LDA #%00001000    ; Set the Video ULA control register (SHEILA &20) to
     35BC 0800     
11442 35BE D800  38        movb ra,@VIA+>20                ; STA VIA+&20       ; %00001000, which is the same as switching to mode 4
     35C0 FE20     
11443                                                                          ; (i.e. the top part of the screen) but with no cursor
11444               
11445               VNT3:
11446 35C2 D022  34        movb @TVT1+16(ry),ra            ; LDA TVT1+16,Y     ; Copy the Y-th palette byte from TVT1+16 to SHEILA &21
     35C4 3594     
11447 35C6 D800  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     35C8 FE21     
11448                                                                          ; of the screen (i.e. the dashboard)
11449               
11450 35CA 7084  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11451               
11452 35CC 15FA  14        jgt  VNT3                       ; BPL VNT3          ; Loop back to VNT3 until we have copied all the
11453                                                                          ; palette bytes
11454               
11455 35CE D020  30        movb @LASCT,ra                  ; LDA LASCT         ; Decrement the value of LASCT, but if we go too far
     35D0 0D60     
11456 35D2 1301  14        jeq  B30                        ; BEQ B30           ; and it becomes negative, bump it back up again (this
11457 35D4 7004  18        sb   rone,ra                    ; DEC LASCT         ; controls the pulsing of pulse lasers)
11458               
11459               B30:
11460 35D6 D020  34        movb @SVN,ra                    ; LDA SVN           ; If SVN is non-zero, we are in the process of saving
     35D8 F2BD     
11461 35DA 1623  14        jne  jvec_                      ; BNE jvec          ; the commander file, so jump to jvec to pass control
11462                                                                          ; to the next interrupt handler, so we don't break file
11463                                                                          ; saving by blocking the interrupt chain
11464               
11465                      .pla                            ; PLA               ; Otherwise restore Y from the stack
     **** ****     > PLA
0001 35DC 058A  14        inc  rsp
0002 35DE D01A  26        movb *rsp,ra
                   < elite.a99
11466 35E0 D080  18        movb ra,ry                      ; TAY
11467               
11468 35E2 D020  34        movb @VIA+>41,ra                ; LDA VIA+&41       ; Read 6522 System VIA input register IRA (SHEILA &41)
     35E4 FE41     
11469               
11470 35E6 D020  30        movb @>FC,ra                    ; LDA &FC           ; Set A to the interrupt accumulator save register,
     35E8 00FC     
11471                                                                          ; which restores A to the value it had on entering the
11472                                                                          ; interrupt
11473               
11474                      ; RTI                           ; RTI               ; Return from interrupts, so this interrupt is not
11475                                                                          ; passed on to the next interrupt handler, but instead
11476                                                                          ; the interrupt terminates here
11477               
11478               IRQ1:
11479 35EA D002  18        movb ry,ra                      ; TYA               ; Store Y on the stack
11480                      .pha                            ; PHA
     **** ****     > PHA
0001 35EC D680  30        movb ra,*rsp
0002 35EE 060A  14        dec  rsp
                   < elite.a99
11481               
11482 35F0 0202  20        li   ry,>0b*256                 ; LDY #11           ; Set Y as a counter for 12 bytes, to use when setting
     35F2 0B00     
11483                                                                          ; the dashboard palette below
11484               
11485 35F4 0200  20        li   ra,>02*256                 ; LDA #%00000010    ; Read the 6522 System VIA status byte bit 1 (SHEILA
     35F6 0200     
11486                      .bit @VIA+>4D                   ; BIT VIA+&4D       ; &4D), which is set if vertical sync has occurred on
     **** ****     > BIT
0001 35F8 D1A0  34        movb @VIA+>4D,rtmp
     35FA FE4D     
0002 35FC 0546  14        inv  rtmp
0003 35FE D1C4  18        movb rone,rtmp2
0004 3600 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
11487                                                                          ; the video system
11488               
11489 3602 16CE  14        jne  LINSCN                     ; BNE LINSCN        ; If we are on the vertical sync pulse, jump to LINSCN
11490                                                                          ; to set up the timers to enable us to switch the
11491                                                                          ; screen mode between the space view and dashboard
11492               
11493 3604 190E  14        jno  jvec_                      ; BVC jvec          ; Read the 6522 System VIA status byte bit 6, which is
11494                                                                          ; set if timer 1 has timed out. We set the timer in
11495                                                                          ; LINSCN above, so this means we only run the next bit
11496                                                                          ; if the screen redraw has reached the boundary between
11497                                                                          ; the space view and the dashboard. Otherwise bit 6 is
11498                                                                          ; clear and we aren't at the boundary, so we jump to
11499                                                                          ; jvec to pass control to the next interrupt handler
11500               
11501                      .asla                           ; ASL A             ; Double the value in A to 4
     **** ****     > ASLA
0001 3606 0240  22        andi ra,>ff00
     3608 FF00     
0002 360A 0A10  18        sla  ra,1
                   < elite.a99
11502               
11503 360C D800  38        movb ra,@VIA+>20                ; STA VIA+&20       ; Set the Video ULA control register (SHEILA &20) to
     360E FE20     
11504                                                                          ; %00000100, which is the same as switching to mode 5,
11505                                                                          ; (i.e. the bottom part of the screen) but with no
11506                                                                          ; cursor
11507               
11508 3610 D020  30        movb @ESCP,ra                   ; LDA ESCP          ; If an escape pod is fitted, jump to VNT1 to set the
     3612 032E     
11509 3614 160F  14        jne  VNT1                       ; BNE VNT1          ; mode 5 palette differently (so the dashboard is a
11510                                                                          ; different colour if we have an escape pod)
11511               
11512               B31:
11513 3616 D022  34        movb @TVT1(ry),ra               ; LDA TVT1,Y        ; Copy the Y-th palette byte from TVT1 to SHEILA &21
     3618 3584     
11514 361A D800  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     361C FE21     
11515                                                                          ; of the screen (i.e. the dashboard)
11516               
11517 361E 7084  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11518               
11519 3620 15FA  14        jgt  B31                        ; BPL B31           ; Loop back to the LDA TVT1,Y instruction until we have
11520                                                                          ; copied all the palette bytes
11521               
11522               jvec_:
11523                      .pla                            ; PLA               ; Restore Y from the stack
     **** ****     > PLA
0001 3622 058A  14        inc  rsp
0002 3624 D01A  26        movb *rsp,ra
                   < elite.a99
11524 3626 D080  18        movb ra,ry                      ; TAY
11525               
11526                      .jmpi @VEC                      ; JMP (VEC)         ; Jump to the address in VEC, which was set to the
     **** ****     > JMPI
0001 3628 D821  54        movb @VEC(rx),@rtmplb
     362A F2BE     
     362C 2079     
0002 362E D1A1  34        movb @VEC+1(rx),rtmp
     3630 F2BF     
0003 3632 0456  20        b    *rtmp
                   < elite.a99
11527                                                                          ; original IRQ1V vector by the loading process, so this
11528                                                                          ; instruction passes control to the next interrupt
11529                                                                          ; handler
11530               
11531               VNT1:
11532 3634 0202  20        li   ry,>07*256                 ; LDY #7            ; Set Y as a counter for 8 bytes
     3636 0700     
11533               
11534 3638 D022  34        movb @TVT1+8(ry),ra             ; LDA TVT1+8,Y      ; Copy the Y-th palette byte from TVT1+8 to SHEILA &21
     363A 358C     
11535 363C D800  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     363E FE21     
11536                                                                          ; of the screen (i.e. the dashboard)
11537               
11538 3640 7084  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11539               
11540 3642 15F9  14        jgt  VNT1+2                     ; BPL VNT1+2        ; Loop back to the LDA TVT1+8,Y instruction until we
11541                                                                          ; have copied all the palette bytes
11542               
11543 3644 11EE  14        jlt  jvec_                      ; BMI jvec          ; Jump up to jvec to pass control to the next interrupt
11544                                                                          ; handler (this BMI is effectively a JMP as we didn't
11545                                                                          ; loop back with the BPL above, so BMI is always true)
11546               
11547               * ******************************************************************************
11548               *
11549               * Name: ESCAPE
11550               * Type: Subroutine
11551               * Category: Flight
11552               * Summary: Launch our escape pod
11553               *
11554               * ------------------------------------------------------------------------------
11555               *
11556               * This routine displays our doomed Cobra Mk III disappearing off into the ether
11557               * before arranging our replacement ship. Called when we press ESCAPE during
11558               * flight and have an escape pod fitted.
11559               *
11560               * ******************************************************************************
11561               
11562               ESCAPE:
11563 3646 D020  30        movb @MJ,ra                     ; LDA MJ            ; Store the value of MJ on the stack (the "are we in
     3648 0D5C     
11564                      .pha                            ; PHA               ; witchspace?" flag)
     **** ****     > PHA
0001 364A D680  30        movb ra,*rsp
0002 364C 060A  14        dec  rsp
                   < elite.a99
11565               
11566 364E 0206  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     3650 BF32     
11567 3652 06A0  32        bl   @jsr                       ;
     3654 FF10     
11568               
11569 3656 0201  20        li   rx,(CYL)*256               ; LDX #CYL          ; Set the current ship type to a Cobra Mk III, so we
     3658 0700     
11570 365A D801  30        movb rx,@TYPE                   ; STX TYPE          ; can show our ship disappear into the distance when we
     365C 009B     
11571                                                                          ; eject in our pod
11572               
11573 365E 0206  20        li   rtmp,FRS1                  ; JSR FRS1          ; Call FRS1 to launch the Cobra Mk III straight ahead,
     3660 3BD8     
11574 3662 06A0  32        bl   @jsr                       ;
     3664 FF10     
11575                                                                          ; like a missile launch, but with our ship instead
11576               
11577 3666 0200  20        li   ra,>08*256                 ; LDA #8            ; Set the Cobra's byte #27 (speed) to 8
     3668 0800     
11578 366A D800  30        movb ra,@INWK+27                ; STA INWK+27
     366C 006E     
11579               
11580 366E 0200  20        li   ra,>c2*256                 ; LDA #194          ; Set the Cobra's byte #30 (pitch counter) to 194, so it
     3670 C200     
11581 3672 D800  30        movb ra,@INWK+30                ; STA INWK+30       ; pitches up as we pull away
     3674 0071     
11582               
11583 3676 0910  18        srl  ra,1                       ; LSR A             ; Set the Cobra's byte #32 (AI flag) to %01100001, so it
11584 3678 D800  30        movb ra,@INWK+32                ; STA INWK+32       ; has no AI, and we can use this value as a counter to
     367A 0073     
11585                                                                          ; do the following loop 97 times
11586               
11587               ESL1:
11588 367C 0206  20        li   rtmp,MVEIT                 ; JSR MVEIT         ; Call MVEIT to move the Cobra in space
     367E 17E2     
11589 3680 06A0  32        bl   @jsr                       ;
     3682 FF10     
11590               
11591 3684 0206  20        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to draw the Cobra on-screen
     3686 D4B4     
11592 3688 06A0  32        bl   @jsr                       ;
     368A FF10     
11593               
11594 368C 7004  18        sb   rone,ra                    ; DEC INWK+32       ; Decrement the counter in byte #32
11595               
11596 368E 16F6  14        jne  ESL1                       ; BNE ESL1          ; Loop back to keep moving the Cobra until the AI flag
11597                                                                          ; is 0, which gives it time to drift away from our pod
11598               
11599 3690 0206  20        li   rtmp,SCAN                  ; JSR SCAN          ; Call SCAN to remove the Cobra from the scanner (by
     3692 4C86     
11600 3694 06A0  32        bl   @jsr                       ;
     3696 FF10     
11601                                                                          ; redrawing it)
11602               
11603 3698 0206  20        li   rtmp,RESET                 ; JSR RESET         ; Call RESET to reset our ship and various controls
     369A BF0A     
11604 369C 06A0  32        bl   @jsr                       ;
     369E FF10     
11605               
11606                      .pla                            ; PLA               ; Restore the witchspace flag from before the escape pod
     **** ****     > PLA
0001 36A0 058A  14        inc  rsp
0002 36A2 D01A  26        movb *rsp,ra
                   < elite.a99
11607 36A4 1302  14        jeq  B32                        ; BEQ B32           ; launch, and if we were in normal space, skip the
11608                                                                          ; following instruction
11609               
11610 36A6 0460  28        b    @DEATH                     ; JMP DEATH         ; Launching an escape pod in witchspace is fatal, so
     36A8 C47E     
11611                                                                          ; jump to DEATH to begin the funeral and return from the
11612                                                                          ; subroutine using a tail call
11613               
11614               B32:
11615 36AA 0201  20        li   rx,>10*256                 ; LDX #16           ; We lose all our cargo when using our escape pod, so
     36AC 1000     
11616                                                                          ; up a counter in X so we can zero the 17 cargo slots
11617                                                                          ; in QQ20
11618               
11619               ESL2:
11620 36AE D840  38        movb ra,@QQ20(rx)               ; STA QQ20,X        ; Set the X-th byte of QQ20 to zero (as we know A = 0
     36B0 0317     
11621                                                                          ; from the BEQ above), so we no longer have any of item
11622                                                                          ; type X in the cargo hold
11623               
11624 36B2 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
11625               
11626 36B4 15FC  14        jgt  ESL2                       ; BPL ESL2          ; Loop back to ESL2 until we have emptied the entire
11627                                                                          ; cargo hold
11628               
11629 36B6 D800  30        movb ra,@FIST                   ; STA FIST          ; Launching an escape pod also clears our criminal
     36B8 0334     
11630                                                                          ; record, so set our legal status in FIST to 0 ("clean")
11631               
11632 36BA D800  30        movb ra,@ESCP                   ; STA ESCP          ; The escape pod is a one-use item, so set ESCP to 0 so
     36BC 032E     
11633                                                                          ; we no longer have one fitted
11634               
11635 36BE 0200  20        li   ra,>46*256                 ; LDA #70           ; Our replacement ship is delivered with a full tank of
     36C0 4600     
11636 36C2 D800  30        movb ra,@QQ14                   ; STA QQ14          ; fuel, so set the current fuel level in QQ14 to 70, or
     36C4 030D     
11637                                                                          ; 7.0 light years
11638               
11639 36C6 0460  28        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     36C8 C65C     
11640                                                                          ; screen) and return from the subroutine with a tail
11641                                                                          ; call
11642               
11643               * ******************************************************************************
11644               *
11645               * Save ELTB.bin
11646               *
11647               * ******************************************************************************
11648               
11649                      ; PRINT "ELITE B"
11650                      ; PRINT "Assembled at ", ~CODE_B%
11651                      ; PRINT "Ends at ", ~P%
11652                      ; PRINT "Code size is ", ~(P% - CODE_B%)
11653                      ; PRINT "Execute at ", ~LOAD%
11654                      ; PRINT "Reload at ", ~LOAD_B%
11655               
11656                      ; PRINT "S.ELTB ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_B%
11657                      ; SAVE "3-assembled-output/ELTB.bin", CODE_B%, P%, LOAD%
11658               
11659               * ******************************************************************************
11660               *
11661               * ELITE C FILE
11662               *
11663               * Produces the binary file ELTC.bin that gets loaded by elite-bcfs.asm.
11664               *
11665               * ******************************************************************************
11666               
11667               CODE_C.:
11668                      equ $
11669               
11670               LOAD_C.:
11671                      equ LOAD. + $ - CODE.
11672               
11673               * ******************************************************************************
11674               *
11675               * Name: TACTICS (Part 1 of 7)
11676               * Type: Subroutine
11677               * Category: Tactics
11678               * Summary: Apply tactics: Process missiles, both enemy missiles and our own
11679               * Deep dive: Program flow of the tactics routine
11680               *
11681               * ------------------------------------------------------------------------------
11682               *
11683               * This section implements missile tactics and is entered at TA18 from the main
11684               * entry point below, if the current ship is a missile. Specifically:
11685               *
11686               * * If E.C.M. is active, destroy the missile
11687               *
11688               * * If the missile is hostile towards us, then check how close it is. If it
11689               * hasn't reached us, jump to part 3 so it can streak towards us, otherwise
11690               * we've been hit, so process a large amount of damage to our ship
11691               *
11692               * * Otherwise see how close the missile is to its target. If it has not yet
11693               * reached its target, give the target a chance to activate its E.C.M. if it
11694               * has one, otherwise jump to TA19 with K3 set to the vector from the target
11695               * to the missile
11696               *
11697               * * If it has reached its target and the target is the space station, destroy
11698               * the missile, potentially damaging us if we are nearby
11699               *
11700               * * If it has reached its target and the target is a ship, destroy the missile
11701               * and the ship, potentially damaging us if we are nearby
11702               *
11703               * ******************************************************************************
11704               
11705               TA34:
11706                                                                          ; If we get here, the missile is hostile
11707 36CA 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A to x_hi OR y_hi OR z_hi
     36CC 0000     
11708 36CE 0206  20        li   rtmp,MAS4                  ; JSR MAS4
     36D0 C46E     
11709 36D2 06A0  32        bl   @jsr                       ;
     36D4 FF10     
11710               
11711 36D6 1300  14        jeq  B33                        ; BEQ B33           ; If A = 0 then the missile is very close to our ship,
11712                                                                          ; so skip the following instruction
11713               
11714               B33:
11715 36D8 0460  28        b    @TA21                      ; JMP TA21          ; Jump down to part 3 to set up the vectors and skip
     36DA 38AE     
11716                                                                          ; straight to aggressive manoeuvring
11717               
11718 36DC 0206  20        li   rtmp,TA87+3                ; JSR TA87+3        ; The missile has hit our ship, so call TA87+3 to set
     36DE 37B3     
11719 36E0 06A0  32        bl   @jsr                       ;
     36E2 FF10     
11720                                                                          ; bit 7 of the missile's byte #31, which marks the
11721                                                                          ; missile as being killed
11722               
11723 36E4 0206  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of the missile exploding
     36E6 CB2E     
11724 36E8 06A0  32        bl   @jsr                       ;
     36EA FF10     
11725               
11726 36EC 0200  20        li   ra,>fa*256                 ; LDA #250          ; Call OOPS to damage the ship by 250, which is a pretty
     36EE FA00     
11727 36F0 0460  28        b    @OOPS                      ; JMP OOPS          ; big hit, and return from the subroutine using a tail
     36F2 AE76     
11728                                                                          ; call
11729               
11730               TA18:
11731                                                                          ; This is the entry point for missile tactics and is
11732                                                                          ; called from the main TACTICS routine below
11733 36F4 D020  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     36F6 0030     
11734 36F8 164E  14        jne  TA35                       ; BNE TA35          ; opponent's), jump to TA35 to destroy this missile
11735               
11736 36FA D020  30        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the AI flag from byte #32 and if bit 6 is set
     36FC 0073     
11737                      .asla                           ; ASL A             ; (i.e. missile is hostile), jump up to TA34 to check
     **** ****     > ASLA
0001 36FE 0240  22        andi ra,>ff00
     3700 FF00     
0002 3702 0A10  18        sla  ra,1
                   < elite.a99
11738 3704 11E2  14        jlt  TA34                       ; BMI TA34          ; whether the missile has hit us
11739               
11740 3706 0910  18        srl  ra,1                       ; LSR A             ; Otherwise shift A right again. We know bits 6 and 7
11741                                                                          ; are now clear, so this leaves bits 0-5. Bits 1-5
11742                                                                          ; contain the target's slot number, and bit 0 is cleared
11743                                                                          ; in FRMIS when a missile is launched, so A contains
11744                                                                          ; the slot number shifted left by 1 (i.e. doubled) so we
11745                                                                          ; can use it as an index for the two-byte address table
11746                                                                          ; at UNIV
11747               
11748 3708 D040  18        movb ra,rx                      ; TAX               ; Copy the address of the target ship's data block from
11749 370A D021  34        movb @UNIV(rx),ra               ; LDA UNIV,X        ; UNIV(X+1 X) to V(1 0)
     370C 221F     
11750 370E D800  30        movb ra,@V                      ; STA V
     3710 0022     
11751 3712 D021  34        movb @UNIV+1(rx),ra             ; LDA UNIV+1,X
     3714 2220     
11752 3716 D800  30        movb ra,@V+1                    ; STA V+1
     3718 0023     
11753               
11754 371A 0202  20        li   ry,>02*256                 ; LDY #2            ; K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of
     371C 0200     
11755 371E 0206  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     3720 3AD2     
11756 3722 06A0  32        bl   @jsr                       ;
     3724 FF10     
11757               
11758 3726 0202  20        li   ry,>05*256                 ; LDY #5            ; K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of
     3728 0500     
11759 372A 0206  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     372C 3AD2     
11760 372E 06A0  32        bl   @jsr                       ;
     3730 FF10     
11761               
11762 3732 0202  20        li   ry,>08*256                 ; LDY #8            ; K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of
     3734 0800     
11763 3736 0206  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     3738 3AD2     
11764 373A 06A0  32        bl   @jsr                       ;
     373C FF10     
11765               
11766                                                                          ; So K3 now contains the vector from the target ship to
11767                                                                          ; the missile
11768               
11769 373E D020  30        movb @K3+2,ra                   ; LDA K3+2          ; Set A = OR of all the sign and high bytes of the
     3740 00D4     
11770 3742 F020  30        socb @K3+5,ra                   ; ORA K3+5          ; above, clearing bit 7 (i.e. ignore the signs)
     3744 00D7     
11771 3746 F020  30        socb @K3+8,ra                   ; ORA K3+8
     3748 00DA     
11772 374A 0240  22        andi ra,>7f*256                 ; AND #%01111111
     374C 7F00     
11773 374E F020  30        socb @K3+1,ra                   ; ORA K3+1
     3750 00D3     
11774 3752 F020  30        socb @K3+4,ra                   ; ORA K3+4
     3754 00D6     
11775 3756 F020  30        socb @K3+7,ra                   ; ORA K3+7
     3758 00D9     
11776               
11777 375A 163C  14        jne  TA64                       ; BNE TA64          ; If the result is non-zero, then the missile is some
11778                                                                          ; distance from the target, so jump down to TA64 see if
11779                                                                          ; the target activates its E.C.M.
11780               
11781 375C D020  30        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the AI flag from byte #32 and if only bits 7 and
     375E 0073     
11782 3760 0280  22        ci   ra,>82*256                 ; CMP #%10000010    ; 1 are set (AI is enabled and the target is slot 1, the
     3762 8200     
11783 3764 1318  14        jeq  TA35                       ; BEQ TA35          ; space station), jump to TA35 to destroy this missile,
11784                                                                          ; as the space station ain't kidding around
11785               
11786 3766 0202  20        li   ry,>1f*256                 ; LDY #31           ; Fetch byte #31 (the exploding flag) of the target ship
     3768 1F00     
11787                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; into A
     **** ****     > LD_IND_Y_IDX
0001 376A D820  50        movb @V,@rtmplb
     376C 0022     
     376E 2079     
0002 3770 D1A0  30        movb @V+1,rtmp
     3772 0023     
0003 3774 A182  18        a    ry,rtmp
0004 3776 D016  26        movb *rtmp,RA
                   < elite.a99
11788               
11789                      .bit @M32+1                     ; BIT M32+1         ; M32 contains an LDY #32 instruction, so M32+1 contains
     **** ****     > BIT
0001 3778 D1A0  34        movb @M32+1,rtmp
     377A 37E3     
0002 377C 0546  14        inv  rtmp
0003 377E D1C4  18        movb rone,rtmp2
0004 3780 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
11790                                                                          ; 32, so this instruction tests A with %00100000, which
11791                                                                          ; checks bit 5 of A (the "already exploding?" bit)
11792               
11793 3782 1609  14        jne  TA35                       ; BNE TA35          ; If the target ship is already exploding, jump to TA35
11794                                                                          ; to destroy this missile
11795               
11796 3784 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Otherwise set bit 7 of the target's byte #31 to mark
     3786 8000     
11797                      .st_ind_y_idx @V,ra             ; STA (V),Y         ; the ship as having been killed, so it explodes
     **** ****     > ST_IND_Y_IDX
0001 3788 D820  50        movb @V,@rtmplb
     378A 0022     
     378C 2079     
0002 378E D1A0  30        movb @V+1,rtmp
     3790 0023     
0003 3792 A182  18        a    ry,rtmp
0004 3794 D580  30        movb RA,*rtmp
                   < elite.a99
11798               
11799               TA35:
11800 3796 D020  30        movb @INWK,ra                   ; LDA INWK          ; Set A = x_lo OR y_lo OR z_lo of the missile
     3798 0053     
11801 379A F020  30        socb @INWK+3,ra                 ; ORA INWK+3
     379C 0056     
11802 379E F020  30        socb @INWK+6,ra                 ; ORA INWK+6
     37A0 0059     
11803               
11804 37A2 1606  14        jne  TA87                       ; BNE TA87          ; If A is non-zero then the missile is not near our
11805                                                                          ; ship, so jump to TA87 to skip damaging our ship
11806               
11807 37A4 0200  20        li   ra,>50*256                 ; LDA #80           ; Otherwise the missile just got destroyed near us, so
     37A6 5000     
11808 37A8 0206  20        li   rtmp,OOPS                  ; JSR OOPS          ; call OOPS to damage the ship by 80, which is nowhere
     37AA AE76     
11809 37AC 06A0  32        bl   @jsr                       ;
     37AE FF10     
11810                                                                          ; near as bad as the 250 damage from a missile slamming
11811                                                                          ; straight into us, but it's still pretty nasty
11812               
11813               TA87:
11814 37B0 0206  20        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     37B2 CB60     
11815 37B4 06A0  32        bl   @jsr                       ;
     37B6 FF10     
11816                                                                          ; missile (so increase the kill tally, make an explosion
11817                                                                          ; sound and so on)
11818               
11819                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the missile's byte #31 flag to mark it as
     **** ****     > ASL
0001 37B8 D1A0  30        movb @INWK+31,rtmp
     37BA 0072     
0002 37BC 0246  22        andi rtmp,>ff00
     37BE FF00     
0003 37C0 0A16  18        sla  rtmp,1
0004 37C2 D806  30        movb rtmp,@INWK+31
     37C4 0072     
                   < elite.a99
11820                      .sec                            ; SEC               ; having been killed, so it explodes
     **** ****     > SEC
0001 37C6 0A15  18        sla  rmone,1
                   < elite.a99
11821 37C8 0208  20        li   rarg1,INWK+31              ; ROR INWK+31
     37CA 0072     
11822 37CC 06A0  32        bl   @ror                       ;
     37CE FF62     
11823               
11824               TA1:
11825 37D0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     37D2 FF1C     
11826               
11827               TA64:
11828                                                                          ; If we get here then the missile has not reached the
11829                                                                          ; target
11830 37D4 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     37D6 C07C     
11831 37D8 06A0  32        bl   @jsr                       ;
     37DA FF10     
11832               
11833 37DC 0280  22        ci   ra,>10*256                 ; CMP #16           ; If A >= 16 (94% chance), jump down to TA19 with the
     37DE 1000     
11834 37E0 186E  14        joc  TA19                       ; BCS TA19          ; vector from the target to the missile in K3
11835               
11836               M32:
11837 37E2 0202  20        li   ry,>20*256                 ; LDY #32           ; Fetch byte #32 for the target and shift bit 0 (E.C.M.)
     37E4 2000     
11838                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; into the C flag
     **** ****     > LD_IND_Y_IDX
0001 37E6 D820  50        movb @V,@rtmplb
     37E8 0022     
     37EA 2079     
0002 37EC D1A0  30        movb @V+1,rtmp
     37EE 0023     
0003 37F0 A182  18        a    ry,rtmp
0004 37F2 D016  26        movb *rtmp,RA
                   < elite.a99
11839 37F4 0910  18        srl  ra,1                       ; LSR A
11840               
11841 37F6 1763  14        jnc  TA19                       ; BCC TA19          ; If the C flag is clear then the target does not have
11842                                                                          ; E.C.M. fitted, so jump down to TA19 with the vector
11843                                                                          ; from the target to the missile in K3
11844               
11845 37F8 0460  28        b    @ECBLB2                    ; JMP ECBLB2        ; The target has E.C.M., so jump to ECBLB2 to set it
     37FA B0BE     
11846                                                                          ; off, returning from the subroutine using a tail call
11847               
11848               * ******************************************************************************
11849               *
11850               * Name: TACTICS (Part 2 of 7)
11851               * Type: Subroutine
11852               * Category: Tactics
11853               * Summary: Apply tactics: Escape pod, station, lone Thargon, safe-zone pirate
11854               * Deep dive: Program flow of the tactics routine
11855               *
11856               * ------------------------------------------------------------------------------
11857               *
11858               * This section contains the main entry point at TACTICS, which is called from
11859               * part 2 of MVEIT for ships that have the AI flag set (i.e. bit 7 of byte #32).
11860               * This part does the following:
11861               *
11862               * * If this is a missile, jump up to the missile code in part 1
11863               *
11864               * * If this is an escape pod, point it at the planet and jump to the
11865               * manoeuvring code in part 7
11866               *
11867               * * If this is the space station and it is hostile, consider spawning a cop
11868               * (45% chance, up to a maximum of four) and we're done
11869               *
11870               * * If this is a lone Thargon without a mothership, set it adrift aimlessly
11871               * and we're done
11872               *
11873               * * If this is a pirate and we are within the space station safe zone, stop
11874               * the pirate from attacking by removing all its aggression
11875               *
11876               * * Recharge the ship's energy banks by 1
11877               *
11878               * ------------------------------------------------------------------------------
11879               *
11880               * Arguments:
11881               *
11882               * X                   The ship type
11883               *
11884               * ******************************************************************************
11885               
11886               TACTICS:
11887 37FC 0281  22        ci   rx,(MSL)*256               ; CPX #MSL          ; If this is a missile, jump up to TA18 to implement
     37FE 0900     
11888 3800 1602  14        jne  FIX001                     ; BNE FIX001        ; missile tactics
11889 3802 0460  28        b    @TA18                      ; JMP TA18
     3804 36F4     
11890               FIX001:
11891 3806 0281  22        ci   rx,(ESC)*256               ; CPX #ESC          ; If this is not an escape pod, skip the following two
     3808 0D00     
11892 380A 1606  14        jne  B34                        ; BNE B34           ; instructions
11893               
11894 380C 0206  20        li   rtmp,SPS1                  ; JSR SPS1          ; This is an escape pod, so call SPS1 to calculate the
     380E C97A     
11895 3810 06A0  32        bl   @jsr                       ;
     3812 FF10     
11896                                                                          ; vector to the planet and store it in XX15
11897               
11898 3814 0460  28        b    @TA15                      ; JMP TA15          ; Jump down to TA15
     3816 3A48     
11899               
11900               B34:
11901 3818 0281  22        ci   rx,(SST)*256               ; CPX #SST          ; If this is not the space station, jump down to TA13
     381A 0800     
11902 381C 1612  14        jne  TA13                       ; BNE TA13
11903               
11904                                                                          ; We only call the tactics routine for the space station
11905                                                                          ; when it is hostile, so if we get here then this is the
11906                                                                          ; station, and we already know it's hostile, so we need
11907                                                                          ; to spawn some cops
11908               
11909 381E 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3820 C07C     
11910 3822 06A0  32        bl   @jsr                       ;
     3824 FF10     
11911               
11912 3826 0280  22        ci   ra,>8c*256                 ; CMP #140          ; If A < 140 (55% chance) then return from the
     3828 8C00     
11913 382A 1723  14        jnc  TA14-1                     ; BCC TA14-1        ; subroutine (as TA14-1 contains an RTS)
11914               
11915 382C D020  30        movb @MANY+COPS,ra              ; LDA MANY+COPS     ; We only call the tactics routine for the space station
     382E 0D4F     
11916 3830 0280  22        ci   ra,>04*256                 ; CMP #4            ; when it is hostile, so first check the number of cops
     3832 0400     
11917 3834 181E  14        joc  TA14-1                     ; BCS TA14-1        ; in the vicinity, and if we already have 4 or more, we
11918                                                                          ; don't need to spawn any more, so return from the
11919                                                                          ; subroutine (as TA14-1 contains an RTS)
11920               
11921 3836 0201  20        li   rx,(COPS)*256              ; LDX #COPS         ; Set X to the ship type for a cop
     3838 0200     
11922               
11923 383A 0200  20        li   ra,>f1*256                 ; LDA #%11110001    ; Set the AI flag to give the ship E.C.M., enable AI and
     383C F100     
11924                                                                          ; make it very aggressive (60 out of 63)
11925               
11926 383E 0460  28        b    @SFS1                      ; JMP SFS1          ; Jump to SFS1 to spawn the ship, returning from the
     3840 3D02     
11927                                                                          ; subroutine using a tail call
11928               
11929               TA13:
11930 3842 0281  22        ci   rx,(TGL)*256               ; CPX #TGL          ; If this is not a Thargon, jump down to TA14
     3844 0C00     
11931 3846 1616  14        jne  TA14                       ; BNE TA14
11932               
11933 3848 D020  30        movb @MANY+THG,ra               ; LDA MANY+THG      ; If there is at least one Thargoid in the vicinity,
     384A 0D53     
11934 384C 1613  14        jne  TA14                       ; BNE TA14          ; jump down to TA14
11935               
11936                      .lsr @INWK+32                   ; LSR INWK+32       ; This is a Thargon but there is no Thargoid mothership,
     **** ****     > LSR
0001 384E D1A0  30        movb @INWK+32,rtmp
     3850 0073     
0002 3852 0916  18        srl  rtmp,1
0003 3854 D806  30        movb rtmp,@INWK+32
     3856 0073     
                   < elite.a99
11937                      .asl @INWK+32                   ; ASL INWK+32       ; so clear bit 0 of the AI flag to disable its E.C.M.
     **** ****     > ASL
0001 3858 D1A0  30        movb @INWK+32,rtmp
     385A 0073     
0002 385C 0246  22        andi rtmp,>ff00
     385E FF00     
0003 3860 0A16  18        sla  rtmp,1
0004 3862 D806  30        movb rtmp,@INWK+32
     3864 0073     
                   < elite.a99
11938               
11939                      .lsr @INWK+27                   ; LSR INWK+27       ; And halve the Thargon's speed
     **** ****     > LSR
0001 3866 D1A0  30        movb @INWK+27,rtmp
     3868 006E     
0002 386A 0916  18        srl  rtmp,1
0003 386C D806  30        movb rtmp,@INWK+27
     386E 006E     
                   < elite.a99
11940               
11941 3870 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3872 FF1C     
11942               
11943               TA14:
11944 3874 0281  22        ci   rx,(CYL)*256               ; CPX #CYL          ; If A >= #CYL, i.e. this is a Cobra Mk III trader (as
     3876 0700     
11945 3878 180C  14        joc  TA62                       ; BCS TA62          ; asteroids and cargo canisters never have AI), jump
11946                                                                          ; down to TA62
11947               
11948 387A 0281  22        ci   rx,(COPS)*256              ; CPX #COPS         ; If this is a cop, jump down to TA62
     387C 0200     
11949 387E 1309  14        jeq  TA62                       ; BEQ TA62
11950               
11951 3880 D020  30        movb @SSPR,ra                   ; LDA SSPR          ; If we aren't within range of the space station, jump
     3882 0D55     
11952 3884 1306  14        jeq  TA62                       ; BEQ TA62          ; down to TA62
11953               
11954 3886 D020  30        movb @INWK+32,ra                ; LDA INWK+32       ; This is a pirate or bounty hunter, but we are inside
     3888 0073     
11955 388A 0240  22        andi ra,>81*256                 ; AND #%10000001    ; the space station's safe zone, so clear bits 1-6 of
     388C 8100     
11956 388E D800  30        movb ra,@INWK+32                ; STA INWK+32       ; the AI flag to stop it being hostile, because even
     3890 0073     
11957                                                                          ; pirates aren't crazy enough to breach the station's
11958                                                                          ; no-fire zone
11959               
11960               TA62:
11961 3892 0202  20        li   ry,>0e*256                 ; LDY #14           ; If the ship's energy is greater or equal to the
     3894 0E00     
11962 3896 D020  30        movb @INWK+35,ra                ; LDA INWK+35       ; maximum value from the ship's blueprint pointed to by
     3898 0076     
11963                      .cmp_ind_y_idx @XX0,ra          ; CMP (XX0),Y       ; XX0, then skip the next instruction
     **** ****     > CMP_IND_Y_IDX
0001 389A D820  50        movb @XX0,@rtmplb
     389C 001E     
     389E 2079     
0002 38A0 D1A0  30        movb @XX0+1,rtmp
     38A2 001F     
0003 38A4 A182  18        a    ry,rtmp
0004 38A6 D196  26        movb *rtmp,rtmp
0005 38A8 9180  18        cb   ra,rtmp
                   < elite.a99
11964 38AA 1801  14        joc  TA21                       ; BCS TA21
11965               
11966 38AC B004  18        ab   rone,ra                    ; INC INWK+35       ; The ship's energy is not at maximum, so recharge the
11967                                                                          ; energy banks by 1
11968               
11969               * ******************************************************************************
11970               *
11971               * Name: TACTICS (Part 3 of 7)
11972               * Type: Subroutine
11973               * Category: Tactics
11974               * Summary: Apply tactics: Calculate dot product to determine ship's aim
11975               * Deep dive: Program flow of the tactics routine
11976               *
11977               * ------------------------------------------------------------------------------
11978               *
11979               * This section sets up some vectors and calculates dot products. Specifically:
11980               *
11981               * * Calculate the dot product of the ship's nose vector (i.e. the direction it
11982               * is pointing) with the vector between us and the ship. This value will help
11983               * us work out later on whether the enemy ship is pointing towards us, and
11984               * therefore whether it can hit us with its lasers.
11985               *
11986               * ******************************************************************************
11987               
11988               TA21:
11989 38AE 0201  20        li   rx,>08*256                 ; LDX #8            ; We now want to copy the ship's x, y and z coordinates
     38B0 0800     
11990                                                                          ; from INWK to K3, so set up a counter for 9 bytes
11991               
11992               TAL1:
11993 38B2 D021  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Copy the X-th byte from INWK to the X-th byte of K3
     38B4 0053     
11994 38B6 D840  38        movb ra,@K3(rx)                 ; STA K3,X
     38B8 00D2     
11995               
11996 38BA 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
11997               
11998 38BC 15FA  14        jgt  TAL1                       ; BPL TAL1          ; Loop back until we have copied all 9 bytes
11999               
12000               TA19:
12001                                                                          ; If this is a missile that's heading for its target
12002                                                                          ; (not us, one of the other ships), then the missile
12003                                                                          ; routine at TA18 above jumps here after setting K3 to
12004                                                                          ; the vector from the target to the missile
12005 38BE 0206  20        li   rtmp,TAS2                  ; JSR TAS2          ; Normalise the vector in K3 and store the normalised
     38C0 C99E     
12006 38C2 06A0  32        bl   @jsr                       ;
     38C4 FF10     
12007                                                                          ; version in XX15, so XX15 contains the normalised
12008                                                                          ; vector from our ship to the ship we are applying AI
12009                                                                          ; tactics to (or the normalised vector from the target
12010                                                                          ; to the missile - in both cases it's the vector from
12011                                                                          ; the potential victim to the attacker)
12012               
12013 38C6 0202  20        li   ry,>0a*256                 ; LDY #10           ; Set (A X) = nosev . XX15
     38C8 0A00     
12014 38CA 0206  20        li   rtmp,TAS3                  ; JSR TAS3
     38CC 4476     
12015 38CE 06A0  32        bl   @jsr                       ;
     38D0 FF10     
12016               
12017 38D2 D800  30        movb ra,@CNT                    ; STA CNT           ; Store the high byte of the dot product in CNT. The
     38D4 00A4     
12018                                                                          ; bigger the value, the more aligned the two ships are,
12019                                                                          ; with a maximum magnitude of 36 (96 * 96 >> 8). If CNT
12020                                                                          ; is positive, the ships are facing in a similar
12021                                                                          ; direction, if it's negative they are facing in
12022                                                                          ; opposite directions
12023               
12024               * ******************************************************************************
12025               *
12026               * Name: TACTICS (Part 4 of 7)
12027               * Type: Subroutine
12028               * Category: Tactics
12029               * Summary: Apply tactics: Check energy levels, maybe launch escape pod if low
12030               * Deep dive: Program flow of the tactics routine
12031               *
12032               * ------------------------------------------------------------------------------
12033               *
12034               * This section works out what kind of condition the ship is in. Specifically:
12035               *
12036               * * Rarely (2.5% chance) roll the ship by a noticeable amount
12037               *
12038               * * If the ship has at least half its energy banks full, jump to part 6 to
12039               * consider firing the lasers
12040               *
12041               * * If the ship is not into the last 1/8th of its energy, jump to part 5 to
12042               * consider firing a missile
12043               *
12044               * * If the ship is into the last 1/8th of its energy, then rarely (10% chance)
12045               * the ship launches an escape pod and is left drifting in space
12046               *
12047               * ******************************************************************************
12048               
12049 38D6 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; If this is not a missile, skip the following
     38D8 009B     
12050 38DA 0280  22        ci   ra,(MSL)*256               ; CMP #MSL          ; instruction
     38DC 0900     
12051 38DE 1602  14        jne  B35                        ; BNE B35
12052               
12053 38E0 0460  28        b    @TA20                      ; JMP TA20          ; This is a missile, so jump down to TA20 to get
     38E2 3A10     
12054                                                                          ; straight into some aggressive manoeuvring
12055               
12056               B35:
12057 38E4 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     38E6 C07C     
12058 38E8 06A0  32        bl   @jsr                       ;
     38EA FF10     
12059               
12060 38EC 0280  22        ci   ra,>fa*256                 ; CMP #250          ; If A < 250 (97.5% chance), jump down to TA7 to skip
     38EE FA00     
12061 38F0 1708  14        jnc  TA7                        ; BCC TA7           ; the following
12062               
12063 38F2 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     38F4 C07C     
12064 38F6 06A0  32        bl   @jsr                       ;
     38F8 FF10     
12065               
12066 38FA 0260  22        ori  ra,>68*256                 ; ORA #104          ; Bump A up to at least 104 and store in the roll
     38FC 6800     
12067 38FE D800  30        movb ra,@INWK+29                ; STA INWK+29       ; counter, to gives the ship a noticeable roll
     3900 0070     
12068               
12069               TA7:
12070 3902 0202  20        li   ry,>0e*256                 ; LDY #14           ; Set A = the ship's maximum energy / 2
     3904 0E00     
12071                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y
     **** ****     > LD_IND_Y_IDX
0001 3906 D820  50        movb @XX0,@rtmplb
     3908 001E     
     390A 2079     
0002 390C D1A0  30        movb @XX0+1,rtmp
     390E 001F     
0003 3910 A182  18        a    ry,rtmp
0004 3912 D016  26        movb *rtmp,RA
                   < elite.a99
12072 3914 0910  18        srl  ra,1                       ; LSR A
12073               
12074 3916 9020  30        cb   @INWK+35,ra                ; CMP INWK+35       ; If the ship's current energy in byte #35 > A, i.e. the
     3918 0076     
12075 391A 1738  14        jnc  TA3                        ; BCC TA3           ; ship has at least half of its energy banks charged,
12076                                                                          ; jump down to TA3
12077               
12078 391C 0910  18        srl  ra,1                       ; LSR A             ; If the ship's current energy in byte #35 > A / 4, i.e.
12079 391E 0910  18        srl  ra,1                       ; LSR A             ; the ship is not into the last 1/8th of its energy,
12080 3920 9020  30        cb   @INWK+35,ra                ; CMP INWK+35       ; jump down to ta3 to consider firing a missile
     3922 0076     
12081 3924 1712  14        jnc  ta3_                       ; BCC ta3
12082               
12083 3926 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3928 C07C     
12084 392A 06A0  32        bl   @jsr                       ;
     392C FF10     
12085               
12086 392E 0280  22        ci   ra,>e6*256                 ; CMP #230          ; If A < 230 (90% chance), jump down to ta3 to consider
     3930 E600     
12087 3932 170B  14        jnc  ta3_                       ; BCC ta3           ; firing a missile
12088               
12089 3934 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; If this is a Thargoid, jump down to ta3 to consider
     3936 009B     
12090 3938 0280  22        ci   ra,(THG)*256               ; CMP #THG          ; launching a Thargon
     393A 0600     
12091 393C 1306  14        jeq  ta3_                       ; BEQ ta3
12092               
12093                                                                          ; By this point, the ship has run out of both energy and
12094                                                                          ; luck, so it's time to bail
12095               
12096 393E 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the AI flag to 0 to disable AI, hostility and
     3940 0000     
12097 3942 D800  30        movb ra,@INWK+32                ; STA INWK+32       ; E.C.M., so the ship's a sitting duck
     3944 0073     
12098               
12099 3946 0460  28        b    @SESCP                     ; JMP SESCP         ; Jump to SESCP to spawn an escape pod from the ship,
     3948 3CFA     
12100                                                                          ; returning from the subroutine using a tail call
12101               
12102               * ******************************************************************************
12103               *
12104               * Name: TACTICS (Part 5 of 7)
12105               * Type: Subroutine
12106               * Category: Tactics
12107               * Summary: Apply tactics: Consider whether to launch a missile at us
12108               * Deep dive: Program flow of the tactics routine
12109               *
12110               * ------------------------------------------------------------------------------
12111               *
12112               * This section considers whether to launch a missile. Specifically:
12113               *
12114               * * If the ship doesn't have any missiles, skip to the next part
12115               *
12116               * * If an E.C.M. is firing, skip to the next part
12117               *
12118               * * Randomly decide whether to fire a missile (or, in the case of Thargoids,
12119               * release a Thargon), and if we do, we're done
12120               *
12121               * ******************************************************************************
12122               
12123               ta3_:
12124                                                                          ; If we get here then the ship has less than half energy
12125                                                                          ; so there may not be enough juice for lasers, but let's
12126                                                                          ; see if we can fire a missile
12127 394A D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set A = bits 0-2 of byte #31, the number of missiles
     394C 0072     
12128 394E 0240  22        andi ra,>07*256                 ; AND #%00000111    ; the ship has left
     3950 0700     
12129               
12130 3952 131C  14        jeq  TA3                        ; BEQ TA3           ; If it doesn't have any missiles, jump to TA3
12131               
12132 3954 D800  30        movb ra,@T                      ; STA T             ; Store the number of missiles in T
     3956 00D1     
12133               
12134 3958 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     395A C07C     
12135 395C 06A0  32        bl   @jsr                       ;
     395E FF10     
12136               
12137 3960 0240  22        andi ra,>1f*256                 ; AND #31           ; Restrict A to a random number in the range 0-31
     3962 1F00     
12138               
12139 3964 9020  30        cb   @T,ra                      ; CMP T             ; If A >= T, which is quite likely, though less likely
     3966 00D1     
12140 3968 1811  14        joc  TA3                        ; BCS TA3           ; with higher numbers of missiles, jump to TA3 to skip
12141                                                                          ; firing a missile
12142               
12143 396A D020  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     396C 0030     
12144 396E 160E  14        jne  TA3                        ; BNE TA3           ; opponent's), jump to TA3 to skip firing a missile
12145               
12146 3970 7004  18        sb   rone,ra                    ; DEC INWK+31       ; We're done with the checks, so it's time to fire off a
12147                                                                          ; missile, so reduce the missile count in byte #31 by 1
12148               
12149 3972 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship type into A
     3974 009B     
12150               
12151 3976 0280  22        ci   ra,(THG)*256               ; CMP #THG          ; If this is not a Thargoid, jump down to TA16 to launch
     3978 0600     
12152 397A 1606  14        jne  TA16                       ; BNE TA16          ; a missile
12153               
12154 397C 0201  20        li   rx,(TGL)*256               ; LDX #TGL          ; This is a Thargoid, so instead of launching a missile,
     397E 0C00     
12155 3980 D020  30        movb @INWK+32,ra                ; LDA INWK+32       ; the mothership launches a Thargon, so call SFS1 to
     3982 0073     
12156 3984 0460  28        b    @SFS1                      ; JMP SFS1          ; spawn a Thargon from the parent ship, and return from
     3986 3D02     
12157                                                                          ; the subroutine using a tail call
12158               
12159               TA16:
12160 3988 0460  28        b    @SFRMIS                    ; JMP SFRMIS        ; Jump to SFRMIS to spawn a missile as a child of the
     398A CB40     
12161                                                                          ; current ship, make a noise and print a message warning
12162                                                                          ; of incoming missiles, and return from the subroutine
12163                                                                          ; using a tail call
12164               
12165               * ******************************************************************************
12166               *
12167               * Name: TACTICS (Part 6 of 7)
12168               * Type: Subroutine
12169               * Category: Tactics
12170               * Summary: Apply tactics: Consider firing a laser at us, if aim is true
12171               * Deep dive: Program flow of the tactics routine
12172               *
12173               * ------------------------------------------------------------------------------
12174               *
12175               * This section looks at potentially firing the ship's laser at us. Specifically:
12176               *
12177               * * If the ship is not pointing at us, skip to the next part
12178               *
12179               * * If the ship is pointing at us but not accurately, fire its laser at us and
12180               * skip to the next part
12181               *
12182               * * If we are in the ship's crosshairs, register some damage to our ship, slow
12183               * down the attacking ship, make the noise of us being hit by laser fire, and
12184               * we're done
12185               *
12186               * ******************************************************************************
12187               
12188               TA3:
12189                                                                          ; If we get here then the ship either has plenty of
12190                                                                          ; energy, or levels are low but it couldn't manage to
12191                                                                          ; launch a missile, so maybe we can fire the laser?
12192 398C 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A to x_hi OR y_hi OR z_hi
     398E 0000     
12193 3990 0206  20        li   rtmp,MAS4                  ; JSR MAS4
     3992 C46E     
12194 3994 06A0  32        bl   @jsr                       ;
     3996 FF10     
12195               
12196 3998 0240  22        andi ra,>e0*256                 ; AND #%11100000    ; If any of the hi bytes have any of bits 5-7 set, then
     399A E000     
12197 399C 1624  14        jne  TA4                        ; BNE TA4           ; jump to TA4 to skip the laser checks, as the ship is
12198                                                                          ; too far away from us to hit us with a laser
12199               
12200 399E D060  30        movb @CNT,rx                    ; LDX CNT           ; Set X = the dot product set above in CNT. If this is
     39A0 00A4     
12201                                                                          ; positive, this ship and our ship are facing in similar
12202                                                                          ; directions, but if it's negative then we are facing
12203                                                                          ; each other, so for us to be in the enemy ship's line
12204                                                                          ; of fire, X needs to be negative. The value in X can
12205                                                                          ; have a maximum magnitude of 36, which would mean we
12206                                                                          ; were facing each other square on, so in the following
12207                                                                          ; code we check X like this:
12208                                                                          ;
12209                                                                          ; X = 0 to -31, we are not in the enemy ship's line
12210                                                                          ; of fire, so they can't shoot at us
12211                                                                          ;
12212                                                                          ; X = -32 to -34, we are in the enemy ship's line
12213                                                                          ; of fire, so they can shoot at us, but they can't
12214                                                                          ; hit us as we're not dead in their crosshairs
12215                                                                          ;
12216                                                                          ; X = -35 to -36, we are bang in the middle of the
12217                                                                          ; enemy ship's crosshairs, so they can not only
12218                                                                          ; shoot us, they can hit us
12219               
12220 39A2 0281  22        ci   rx,>a0*256                 ; CPX #160          ; If X < 160, i.e. X > -32, then we are not in the enemy
     39A4 A000     
12221 39A6 171F  14        jnc  TA4                        ; BCC TA4           ; ship's line of fire, so jump to TA4 to skip the laser
12222                                                                          ; checks
12223               
12224 39A8 D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 6 in byte #31 to denote that the ship is
     39AA 0072     
12225 39AC 0260  22        ori  ra,>40*256                 ; ORA #%01000000    ; firing its laser at us
     39AE 4000     
12226 39B0 D800  30        movb ra,@INWK+31                ; STA INWK+31
     39B2 0072     
12227               
12228 39B4 0281  22        ci   rx,>a3*256                 ; CPX #163          ; If X < 163, i.e. X > -35, then we are not in the enemy
     39B6 A300     
12229 39B8 1716  14        jnc  TA4                        ; BCC TA4           ; ship's crosshairs, so jump to TA4 to skip the laser
12230                                                                          ; checks
12231               
12232               HIT:
12233 39BA 0202  20        li   ry,>13*256                 ; LDY #19           ; We are being hit by enemy laser fire, so fetch the
     39BC 1300     
12234                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; enemy ship's byte #19 from their ship's blueprint
     **** ****     > LD_IND_Y_IDX
0001 39BE D820  50        movb @XX0,@rtmplb
     39C0 001E     
     39C2 2079     
0002 39C4 D1A0  30        movb @XX0+1,rtmp
     39C6 001F     
0003 39C8 A182  18        a    ry,rtmp
0004 39CA D016  26        movb *rtmp,RA
                   < elite.a99
12235                                                                          ; into A
12236               
12237 39CC 0910  18        srl  ra,1                       ; LSR A             ; Halve the enemy ship's byte #19 (which contains both
12238                                                                          ; the laser power and number of missiles) to get the
12239                                                                          ; amount of damage we should take
12240               
12241 39CE 0206  20        li   rtmp,OOPS                  ; JSR OOPS          ; Call OOPS to take some damage, which could do anything
     39D0 AE76     
12242 39D2 06A0  32        bl   @jsr                       ;
     39D4 FF10     
12243                                                                          ; from reducing the shields and energy, all the way to
12244                                                                          ; losing cargo or dying (if the latter, we don't come
12245                                                                          ; back from this subroutine)
12246               
12247 39D6 7004  18        sb   rone,ra                    ; DEC INWK+28       ; Halve the attacking ship's acceleration in byte #28
12248               
12249 39D8 D020  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     39DA 0030     
12250 39DC 1678  14        jne  TA10                       ; BNE TA10          ; opponent's), return from the subroutine without making
12251                                                                          ; the laser-strike sound (as TA10 contains an RTS)
12252               
12253 39DE 0200  20        li   ra,>08*256                 ; LDA #8            ; Call the NOISE routine with A = 8 to make the sound
     39E0 0800     
12254 39E2 0460  28        b    @NOISE                     ; JMP NOISE         ; of us being hit by lasers, returning from the
     39E4 CBB0     
12255                                                                          ; subroutine using a tail call
12256               
12257               * ******************************************************************************
12258               *
12259               * Name: TACTICS (Part 7 of 7)
12260               * Type: Subroutine
12261               * Category: Tactics
12262               * Summary: Apply tactics: Set pitch, roll, and acceleration
12263               * Deep dive: Program flow of the tactics routine
12264               *
12265               * ------------------------------------------------------------------------------
12266               *
12267               * This section looks at manoeuvring the ship. Specifically:
12268               *
12269               * * Work out which direction the ship should be moving, depending on whether
12270               * it's an escape pod, where it is, which direction it is pointing, and how
12271               * aggressive it is
12272               *
12273               * * Set the pitch and roll counters to head in that direction
12274               *
12275               * * Speed up or slow down, depending on where the ship is in relation to us
12276               *
12277               * ******************************************************************************
12278               
12279               TA4:
12280 39E6 D020  30        movb @INWK+7,ra                 ; LDA INWK+7        ; If z_hi >= 3 then the ship is quite far away, so jump
     39E8 005A     
12281 39EA 0280  22        ci   ra,>03*256                 ; CMP #3            ; down to TA5
     39EC 0300     
12282 39EE 1807  14        joc  TA5                        ; BCS TA5
12283               
12284 39F0 D020  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Otherwise set A = x_hi OR y_hi and extract bits 1-7
     39F2 0054     
12285 39F4 F020  30        socb @INWK+4,ra                 ; ORA INWK+4
     39F6 0057     
12286 39F8 0240  22        andi ra,>fe*256                 ; AND #%11111110
     39FA FE00     
12287               
12288 39FC 1325  14        jeq  TA15                       ; BEQ TA15          ; If A = 0 then the ship is pretty close to us, so jump
12289                                                                          ; to TA15 so it heads away from us
12290               
12291               TA5:
12292                                                                          ; If we get here then the ship is quite far away
12293 39FE 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3A00 C07C     
12294 3A02 06A0  32        bl   @jsr                       ;
     3A04 FF10     
12295               
12296 3A06 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 of A, so A is at least 128
     3A08 8000     
12297               
12298 3A0A 9020  30        cb   @INWK+32,ra                ; CMP INWK+32       ; If A >= byte #32 (the ship's AI flag) then jump down
     3A0C 0073     
12299 3A0E 181C  14        joc  TA15                       ; BCS TA15          ; to TA15 so it heads away from us
12300               
12301                                                                          ; We get here if A < byte #32, and the chances of this
12302                                                                          ; being true are greater with high values of byte #32,
12303                                                                          ; as long as they are at least 128
12304                                                                          ;
12305                                                                          ; In other words, higher byte #32 values increase the
12306                                                                          ; chances of a ship changing direction to head towards
12307                                                                          ; us - or, to put it another way, ships with higher
12308                                                                          ; byte #32 values of 128 or more are spoiling for a
12309                                                                          ; fight
12310                                                                          ;
12311                                                                          ; Thargoids have byte #32 set to 255, which explains
12312                                                                          ; an awful lot
12313               
12314               TA20:
12315                                                                          ; If this is a missile we will have jumped straight
12316                                                                          ; here, but we also get here if the ship is either far
12317                                                                          ; away and aggressive, or not too close
12318 3A10 D020  30        movb @XX15,ra                   ; LDA XX15          ; Reverse the signs of XX15 and the dot product in CNT,
     3A12 0031     
12319                      .eoi (>80*256)                  ; EOR #%10000000    ; starting with the x-coordinate
     **** ****     > EOI
0001 3A14 0206  20        li   rtmp,(>80*256)
     3A16 8000     
0002 3A18 2806  18        xor  rtmp,ra
                   < elite.a99
12320 3A1A D800  30        movb ra,@XX15                   ; STA XX15
     3A1C 0031     
12321               
12322 3A1E D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Then reverse the sign of the y-coordinate
     3A20 0032     
12323                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 3A22 0206  20        li   rtmp,(>80*256)
     3A24 8000     
0002 3A26 2806  18        xor  rtmp,ra
                   < elite.a99
12324 3A28 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     3A2A 0032     
12325               
12326 3A2C D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; And then the z-coordinate, so now the XX15 vector goes
     3A2E 0033     
12327                      .eoi (>80*256)                  ; EOR #%10000000    ; from the enemy ship to our ship (it was previously the
     **** ****     > EOI
0001 3A30 0206  20        li   rtmp,(>80*256)
     3A32 8000     
0002 3A34 2806  18        xor  rtmp,ra
                   < elite.a99
12328 3A36 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; other way round)
     3A38 0033     
12329               
12330 3A3A D020  30        movb @CNT,ra                    ; LDA CNT           ; And finally change the sign of the dot product in CNT,
     3A3C 00A4     
12331                      .eoi (>80*256)                  ; EOR #%10000000    ; so now it's positive if the ships are facing each
     **** ****     > EOI
0001 3A3E 0206  20        li   rtmp,(>80*256)
     3A40 8000     
0002 3A42 2806  18        xor  rtmp,ra
                   < elite.a99
12332 3A44 D800  30        movb ra,@CNT                    ; STA CNT           ; other, and negative if they are facing the same way
     3A46 00A4     
12333               
12334               TA15:
12335                                                                          ; If we get here, then one of the following is true:
12336                                                                          ;
12337                                                                          ; * This is an escape pod and XX15 is pointing towards
12338                                                                          ; the planet
12339                                                                          ;
12340                                                                          ; * The ship is pretty close to us, or it's just not
12341                                                                          ; very aggressive (though there is a random factor
12342                                                                          ; at play here too). XX15 is still pointing from our
12343                                                                          ; ship towards the enemy ship
12344                                                                          ;
12345                                                                          ; * The ship is aggressive (though again, there's an
12346                                                                          ; element of randomness here). XX15 is pointing from
12347                                                                          ; the enemy ship towards our ship
12348                                                                          ;
12349                                                                          ; * This is a missile heading for a target. XX15 is
12350                                                                          ; pointing from the missile towards the target
12351                                                                          ;
12352                                                                          ; We now want to move the ship in the direction of XX15,
12353                                                                          ; which will make aggressive ships head towards us, and
12354                                                                          ; ships that are too close turn away. Escape pods,
12355                                                                          ; meanwhile, head off towards the planet in search of a
12356                                                                          ; space station, and missiles home in on their targets
12357 3A48 0202  20        li   ry,>10*256                 ; LDY #16           ; Set (A X) = roofv . XX15
     3A4A 1000     
12358 3A4C 0206  20        li   rtmp,TAS3                  ; JSR TAS3          ;
     3A4E 4476     
12359 3A50 06A0  32        bl   @jsr                       ;
     3A52 FF10     
12360                                                                          ; This will be positive if XX15 is pointing in the same
12361                                                                          ; direction as an arrow out of the top of the ship, in
12362                                                                          ; other words if the ship should pull up to head in the
12363                                                                          ; direction of XX15
12364               
12365                      .eoi (>80*256)                  ; EOR #%10000000    ; Set the ship's pitch counter to 3, with the opposite
     **** ****     > EOI
0001 3A54 0206  20        li   rtmp,(>80*256)
     3A56 8000     
0002 3A58 2806  18        xor  rtmp,ra
                   < elite.a99
12366 3A5A 0240  22        andi ra,>80*256                 ; AND #%10000000    ; sign to the dot product result, which gently pitches
     3A5C 8000     
12367 3A5E 0260  22        ori  ra,>03*256                 ; ORA #%00000011    ; the ship towards the direction of the XX15 vector
     3A60 0300     
12368 3A62 D800  30        movb ra,@INWK+30                ; STA INWK+30
     3A64 0071     
12369               
12370 3A66 D020  30        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the roll counter from byte #29 into A and clear
     3A68 0070     
12371 3A6A 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; the sign bit (to give an endless clockwise roll)
     3A6C 7F00     
12372               
12373 3A6E 0280  22        ci   ra,>10*256                 ; CMP #16           ; If A >= 16 then jump to TA6, as the ship is already
     3A70 1000     
12374 3A72 1810  14        joc  TA6                        ; BCS TA6           ; in the process of rolling
12375               
12376 3A74 0202  20        li   ry,>16*256                 ; LDY #22           ; Set (A X) = sidev . XX15
     3A76 1600     
12377 3A78 0206  20        li   rtmp,TAS3                  ; JSR TAS3          ;
     3A7A 4476     
12378 3A7C 06A0  32        bl   @jsr                       ;
     3A7E FF10     
12379                                                                          ; This will be positive if XX15 is pointing in the same
12380                                                                          ; direction as an arrow out of the right side of the
12381                                                                          ; ship, in other words if the ship should roll right to
12382                                                                          ; head in the direction of XX15
12383               
12384                      .eor @INWK+30                   ; EOR INWK+30       ; Set the ship's roll counter to 5, with the sign set to
     **** ****     > EOR
0001 3A80 D1A0  30        movb @INWK+30,rtmp
     3A82 0071     
0002 3A84 2806  18        xor  rtmp,ra
                   < elite.a99
12385 3A86 0240  22        andi ra,>80*256                 ; AND #%10000000    ; positive (clockwise roll) if the pitch counter and dot
     3A88 8000     
12386                      .eoi (>85*256)                  ; EOR #%10000101    ; product have different signs, negative (anti-clockwise
     **** ****     > EOI
0001 3A8A 0206  20        li   rtmp,(>85*256)
     3A8C 8500     
0002 3A8E 2806  18        xor  rtmp,ra
                   < elite.a99
12387 3A90 D800  30        movb ra,@INWK+29                ; STA INWK+29       ; roll) if they have the same sign
     3A92 0070     
12388               
12389               TA6:
12390 3A94 D020  30        movb @CNT,ra                    ; LDA CNT           ; Fetch the dot product, and if it's negative jump to
     3A96 00A4     
12391 3A98 1109  14        jlt  TA9                        ; BMI TA9           ; TA9, as the ships are facing away from each other and
12392                                                                          ; the ship might want to slow down to take another shot
12393               
12394 3A9A 0280  22        ci   ra,>16*256                 ; CMP #22           ; The dot product is positive, so the ships are facing
     3A9C 1600     
12395 3A9E 1706  14        jnc  TA9                        ; BCC TA9           ; each other. If A < 22 then the ships are not heading
12396                                                                          ; directly towards each other, so jump to TA9 to slow
12397                                                                          ; down
12398               
12399 3AA0 0200  20        li   ra,>03*256                 ; LDA #3            ; Otherwise set the acceleration in byte #28 to 3
     3AA2 0300     
12400 3AA4 D800  30        movb ra,@INWK+28                ; STA INWK+28
     3AA6 006F     
12401               
12402 3AA8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3AAA FF1C     
12403               
12404               TA9:
12405 3AAC 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit of the dot product in A
     3AAE 7F00     
12406               
12407 3AB0 0280  22        ci   ra,>12*256                 ; CMP #18           ; If A < 18 then the ship is way off the XX15 vector, so
     3AB2 1200     
12408 3AB4 170C  14        jnc  TA10                       ; BCC TA10          ; return from the subroutine (TA10 contains an RTS)
12409                                                                          ; without slowing down, as it still has quite a bit of
12410                                                                          ; turning to do to get on course
12411               
12412 3AB6 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Otherwise set A = -1
     3AB8 FF00     
12413               
12414 3ABA D060  30        movb @TYPE,rx                   ; LDX TYPE          ; If this is not a missile then skip the ASL instruction
     3ABC 009B     
12415 3ABE 0281  22        ci   rx,(MSL)*256               ; CPX #MSL
     3AC0 0900     
12416 3AC2 1603  14        jne  B36                        ; BNE B36
12417               
12418                      .asla                           ; ASL A             ; This is a missile, so set A = -2, as missiles are more
     **** ****     > ASLA
0001 3AC4 0240  22        andi ra,>ff00
     3AC6 FF00     
0002 3AC8 0A10  18        sla  ra,1
                   < elite.a99
12419                                                                          ; nimble and can brake more quickly
12420               
12421               B36:
12422 3ACA D800  30        movb ra,@INWK+28                ; STA INWK+28       ; Set the ship's acceleration to A
     3ACC 006F     
12423               
12424               TA10:
12425 3ACE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3AD0 FF1C     
12426               
12427               * ******************************************************************************
12428               *
12429               * Name: TAS1
12430               * Type: Subroutine
12431               * Category: Maths (Arithmetic)
12432               * Summary: Calculate K3 = (x_sign x_hi x_lo) - V(1 0)
12433               *
12434               * ------------------------------------------------------------------------------
12435               *
12436               * Calculate one of the following, depending on the value in Y:
12437               *
12438               * K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in V(1 0)
12439               *
12440               * K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate in V(1 0)
12441               *
12442               * K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate in V(1 0)
12443               *
12444               * where the first coordinate is from the ship data block in INWK, and the second
12445               * coordinate is from the ship data block pointed to by V(1 0).
12446               *
12447               * ------------------------------------------------------------------------------
12448               *
12449               * Arguments:
12450               *
12451               * V(1 0)              The address of the ship data block to subtract
12452               *
12453               * Y                   The coordinate in the V(1 0) block to subtract:
12454               *
12455               * * If Y = 2, subtract the x-coordinate and store the
12456               * result in K3(2 1 0)
12457               *
12458               * * If Y = 5, subtract the y-coordinate and store the
12459               * result in K3(5 4 3)
12460               *
12461               * * If Y = 8, subtract the z-coordinate and store the
12462               * result in K3(8 7 6)
12463               *
12464               * ******************************************************************************
12465               
12466               TAS1:
12467                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Copy the sign byte of the V(1 0) coordinate into K+3,
     **** ****     > LD_IND_Y_IDX
0001 3AD2 D820  50        movb @V,@rtmplb
     3AD4 0022     
     3AD6 2079     
0002 3AD8 D1A0  30        movb @V+1,rtmp
     3ADA 0023     
0003 3ADC A182  18        a    ry,rtmp
0004 3ADE D016  26        movb *rtmp,RA
                   < elite.a99
12468                      .eoi (>80*256)                  ; EOR #%10000000    ; flipping it in the process
     **** ****     > EOI
0001 3AE0 0206  20        li   rtmp,(>80*256)
     3AE2 8000     
0002 3AE4 2806  18        xor  rtmp,ra
                   < elite.a99
12469 3AE6 D800  30        movb ra,@K+3                    ; STA K+3
     3AE8 0040     
12470               
12471 3AEA 7084  18        sb   rone,ry                    ; DEY               ; Copy the high byte of the V(1 0) coordinate into K+2
12472                      .ld_ind_y_idx @V,ra             ; LDA (V),Y
     **** ****     > LD_IND_Y_IDX
0001 3AEC D820  50        movb @V,@rtmplb
     3AEE 0022     
     3AF0 2079     
0002 3AF2 D1A0  30        movb @V+1,rtmp
     3AF4 0023     
0003 3AF6 A182  18        a    ry,rtmp
0004 3AF8 D016  26        movb *rtmp,RA
                   < elite.a99
12473 3AFA D800  30        movb ra,@K+2                    ; STA K+2
     3AFC 003F     
12474               
12475 3AFE 7084  18        sb   rone,ry                    ; DEY               ; Copy the high byte of the V(1 0) coordinate into K+1,
12476                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; so now:
     **** ****     > LD_IND_Y_IDX
0001 3B00 D820  50        movb @V,@rtmplb
     3B02 0022     
     3B04 2079     
0002 3B06 D1A0  30        movb @V+1,rtmp
     3B08 0023     
0003 3B0A A182  18        a    ry,rtmp
0004 3B0C D016  26        movb *rtmp,RA
                   < elite.a99
12477 3B0E D800  30        movb ra,@K+1                    ; STA K+1           ;
     3B10 003E     
12478                                                                          ; K(3 2 1) = - coordinate in V(1 0)
12479               
12480 3B12 D802  30        movb ry,@U                      ; STY U             ; Copy the index (now 0, 3 or 6) into U and X
     3B14 008F     
12481 3B16 D060  30        movb @U,rx                      ; LDX U
     3B18 008F     
12482               
12483 3B1A 0206  20        li   rtmp,MVT3                  ; JSR MVT3          ; Call MVT3 to add the same coordinates, but this time
     3B1C 1C88     
12484 3B1E 06A0  32        bl   @jsr                       ;
     3B20 FF10     
12485                                                                          ; from INWK, so this would look like this for the
12486                                                                          ; x-axis:
12487                                                                          ;
12488                                                                          ; K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
12489                                                                          ; = (x_sign x_hi x_lo) - coordinate in V(1 0)
12490               
12491 3B22 D0A0  30        movb @U,ry                      ; LDY U             ; Restore the index into Y, though this instruction has
     3B24 008F     
12492                                                                          ; no effect, as Y is not used again, either here or
12493                                                                          ; following calls to this routine
12494               
12495 3B26 D840  38        movb ra,@K3+2(rx)               ; STA K3+2,X        ; Store K(3 2 1) in K3+X(2 1 0), starting with the sign
     3B28 00D4     
12496                                                                          ; byte
12497               
12498 3B2A D020  30        movb @K+2,ra                    ; LDA K+2           ; And then doing the high byte
     3B2C 003F     
12499 3B2E D840  38        movb ra,@K3+1(rx)               ; STA K3+1,X
     3B30 00D3     
12500               
12501 3B32 D020  30        movb @K+1,ra                    ; LDA K+1           ; And finally the low byte
     3B34 003E     
12502 3B36 D840  38        movb ra,@K3(rx)                 ; STA K3,X
     3B38 00D2     
12503               
12504 3B3A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3B3C FF1C     
12505               
12506               * ******************************************************************************
12507               *
12508               * Name: HITCH
12509               * Type: Subroutine
12510               * Category: Tactics
12511               * Summary: Work out if the ship in INWK is in our crosshairs
12512               * Deep dive: In the crosshairs
12513               *
12514               * ------------------------------------------------------------------------------
12515               *
12516               * This is called by the main flight loop to see if we have laser or missile lock
12517               * on an enemy ship.
12518               *
12519               * ------------------------------------------------------------------------------
12520               *
12521               * Returns:
12522               *
12523               * C flag              Set if the ship is in our crosshairs, clear if it isn't
12524               *
12525               * ------------------------------------------------------------------------------
12526               *
12527               * Other entry points:
12528               *
12529               * HI1                 Contains an RTS
12530               *
12531               * ******************************************************************************
12532               
12533               HITCH:
12534                      .clc                            ; CLC               ; Clear the C flag so we can return with it cleared if
     **** ****     > CLC
0001 3B3E 0A13  18        sla  rzero,1
                   < elite.a99
12535                                                                          ; our checks fail
12536               
12537 3B40 D020  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set A = z_sign
     3B42 005B     
12538               
12539 3B44 1647  14        jne  HI1                        ; BNE HI1           ; If A is non-zero then the ship is behind us and can't
12540                                                                          ; be in our crosshairs, so return from the subroutine
12541                                                                          ; with the C flag clear (as HI1 contains an RTS)
12542               
12543 3B46 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type has bit 7 set then it is the planet
     3B48 009B     
12544 3B4A 1144  14        jlt  HI1                        ; BMI HI1           ; or sun, which we can't target or hit with lasers, so
12545                                                                          ; return from the subroutine with the C flag clear (as
12546                                                                          ; HI1 contains an RTS)
12547               
12548 3B4C D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch bit 5 of byte #31 (the exploding flag) and OR
     3B4E 0072     
12549 3B50 0240  22        andi ra,>20*256                 ; AND #%00100000    ; with x_hi and y_hi
     3B52 2000     
12550 3B54 F020  30        socb @INWK+1,ra                 ; ORA INWK+1
     3B56 0054     
12551 3B58 F020  30        socb @INWK+4,ra                 ; ORA INWK+4
     3B5A 0057     
12552               
12553 3B5C 163B  14        jne  HI1                        ; BNE HI1           ; If this value is non-zero then either the ship is
12554                                                                          ; exploding (so we can't target it), or the ship is too
12555                                                                          ; far away from our line of fire to be targeted, so
12556                                                                          ; return from the subroutine with the C flag clear (as
12557                                                                          ; HI1 contains an RTS)
12558               
12559 3B5E D020  30        movb @INWK,ra                   ; LDA INWK          ; Set A = x_lo
     3B60 0053     
12560               
12561 3B62 0206  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A = x_lo^2
     3B64 42BA     
12562 3B66 06A0  32        bl   @jsr                       ;
     3B68 FF10     
12563               
12564 3B6A D800  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P) = x_lo^2
     3B6C 0092     
12565 3B6E D020  30        movb @P,ra                      ; LDA P
     3B70 001B     
12566 3B72 D800  30        movb ra,@R                      ; STA R
     3B74 0091     
12567               
12568 3B76 D020  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set A = y_lo
     3B78 0056     
12569               
12570 3B7A 0206  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A = y_lo^2
     3B7C 42BA     
12571 3B7E 06A0  32        bl   @jsr                       ;
     3B80 FF10     
12572               
12573 3B82 D040  18        movb ra,rx                      ; TAX               ; Store the high byte in X
12574               
12575 3B84 D020  30        movb @P,ra                      ; LDA P             ; Add the two low bytes, so:
     3B86 001B     
12576                      .adc @R,ra                      ; ADC R             ;
     **** ****     > ADC
0001 3B88 1701  14        jnc  !
0002 3B8A B004  18        ab   rone,ra
0003               !:
0004 3B8C B020  30        ab   @R,ra
     3B8E 0091     
                   < elite.a99
12577 3B90 D800  30        movb ra,@R                      ; STA R             ; R = P + R
     3B92 0091     
12578               
12579 3B94 D001  18        movb rx,ra                      ; TXA               ; Restore the high byte into A and add S to give the
12580                      .adc @S,ra                      ; ADC S             ; following:
     **** ****     > ADC
0001 3B96 1701  14        jnc  !
0002 3B98 B004  18        ab   rone,ra
0003               !:
0004 3B9A B020  30        ab   @S,ra
     3B9C 0092     
                   < elite.a99
12581                                                                          ;
12582                                                                          ; (A R) = (S R) + (A P) = x_lo^2 + y_lo^2
12583               
12584 3B9E 1702  14        jnc  FIX002                     ; BCC FIX002        ; If the addition just overflowed then there is no way
12585                                                                          ; our crosshairs are within the ship's targetable area,
12586                                                                          ; so return from the subroutine with the C flag clear
12587                                                                          ; (as FR1-2 contains a CLC then an RTS)
12588 3BA0 0460  28        b    @FR1-2                     ; JMP FR1-2
     3BA2 3CF0     
12589               FIX002:
12590 3BA4 D800  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P) = x_lo^2 + y_lo^2
     3BA6 0092     
12591               
12592 3BA8 0202  20        li   ry,>02*256                 ; LDY #2            ; Fetch the ship's blueprint and set A to the high byte
     3BAA 0200     
12593                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; of the targetable area of the ship
     **** ****     > LD_IND_Y_IDX
0001 3BAC D820  50        movb @XX0,@rtmplb
     3BAE 001E     
     3BB0 2079     
0002 3BB2 D1A0  30        movb @XX0+1,rtmp
     3BB4 001F     
0003 3BB6 A182  18        a    ry,rtmp
0004 3BB8 D016  26        movb *rtmp,RA
                   < elite.a99
12594               
12595 3BBA 9020  30        cb   @S,ra                      ; CMP S             ; We now compare the high bytes of the targetable area
     3BBC 0092     
12596                                                                          ; and the calculation in (S R):
12597                                                                          ;
12598                                                                          ; * If A >= S then then the C flag will be set
12599                                                                          ;
12600                                                                          ; * If A < S then the C flag will be C clear
12601               
12602 3BBE 160A  14        jne  HI1                        ; BNE HI1           ; If A <> S we have just set the C flag correctly, so
12603                                                                          ; return from the subroutine (as HI1 contains an RTS)
12604               
12605 3BC0 7084  18        sb   rone,ry                    ; DEY               ; The high bytes were identical, so now we fetch the
12606                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; low byte of the targetable area into A
     **** ****     > LD_IND_Y_IDX
0001 3BC2 D820  50        movb @XX0,@rtmplb
     3BC4 001E     
     3BC6 2079     
0002 3BC8 D1A0  30        movb @XX0+1,rtmp
     3BCA 001F     
0003 3BCC A182  18        a    ry,rtmp
0004 3BCE D016  26        movb *rtmp,RA
                   < elite.a99
12607               
12608 3BD0 9020  30        cb   @R,ra                      ; CMP R             ; We now compare the low bytes of the targetable area
     3BD2 0091     
12609                                                                          ; and the calculation in (S R):
12610                                                                          ;
12611                                                                          ; * If A >= R then the C flag will be set
12612                                                                          ;
12613                                                                          ; * If A < R then the C flag will be C clear
12614               
12615               HI1:
12616 3BD4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3BD6 FF1C     
12617               
12618               * ******************************************************************************
12619               *
12620               * Name: FRS1
12621               * Type: Subroutine
12622               * Category: Tactics
12623               * Summary: Launch a ship straight ahead of us, below the laser sights
12624               *
12625               * ------------------------------------------------------------------------------
12626               *
12627               * This is used in two places:
12628               *
12629               * * When we launch a missile, in which case the missile is the ship that is
12630               * launched ahead of us
12631               *
12632               * * When we launch our escape pod, in which case it's our abandoned Cobra Mk
12633               * III that is launched ahead of us
12634               *
12635               * * The fq1 entry point is used to launch a bunch of cargo canisters ahead of
12636               * us as part of the death screen
12637               *
12638               * ------------------------------------------------------------------------------
12639               *
12640               * Arguments:
12641               *
12642               * X                   The type of ship to launch ahead of us
12643               *
12644               * ------------------------------------------------------------------------------
12645               *
12646               * Returns:
12647               *
12648               * C flag              Set if the ship was successfully launched, clear if it
12649               * wasn't (as there wasn't enough free memory)
12650               *
12651               * ------------------------------------------------------------------------------
12652               *
12653               * Other entry points:
12654               *
12655               * fq1                 Used to add a cargo canister to the universe
12656               *
12657               * ******************************************************************************
12658               
12659               FRS1:
12660 3BD8 0206  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     3BDA BFC0     
12661 3BDC 06A0  32        bl   @jsr                       ;
     3BDE FF10     
12662               
12663 3BE0 0200  20        li   ra,>1c*256                 ; LDA #28           ; Set y_lo = 28
     3BE2 1C00     
12664 3BE4 D800  30        movb ra,@INWK+3                 ; STA INWK+3
     3BE6 0056     
12665               
12666 3BE8 0910  18        srl  ra,1                       ; LSR A             ; Set z_lo = 14, so the launched ship starts out
12667 3BEA D800  30        movb ra,@INWK+6                 ; STA INWK+6        ; ahead of us
     3BEC 0059     
12668               
12669 3BEE 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set y_sign to be negative, so the launched ship is
     3BF0 8000     
12670 3BF2 D800  30        movb ra,@INWK+5                 ; STA INWK+5        ; launched just below our line of sight
     3BF4 0058     
12671               
12672 3BF6 D020  30        movb @MSTG,ra                   ; LDA MSTG          ; Set A to the missile lock target, shifted left so the
     3BF8 0052     
12673                      .asla                           ; ASL A             ; slot number is in bits 1-5
     **** ****     > ASLA
0001 3BFA 0240  22        andi ra,>ff00
     3BFC FF00     
0002 3BFE 0A10  18        sla  ra,1
                   < elite.a99
12674               
12675 3C00 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 and store the result in byte #32, the AI
     3C02 8000     
12676 3C04 D800  30        movb ra,@INWK+32                ; STA INWK+32       ; flag launched ship for the launched ship. For missiles
     3C06 0073     
12677                                                                          ; this enables AI (bit 7), makes it friendly towards us
12678                                                                          ; (bit 6), sets the target to the value of MSTG (bits
12679                                                                          ; 1-5), and sets its lock status as launched (bit 0).
12680                                                                          ; It doesn't matter what it does for our abandoned
12681                                                                          ; Cobra, as the AI flag gets overwritten once we return
12682                                                                          ; from the subroutine back to the ESCAPE routine that
12683                                                                          ; called FRS1 in the first place
12684               
12685               fq1_:
12686 3C08 0200  20        li   ra,>60*256                 ; LDA #&60          ; Set byte #14 (nosev_z_hi) to 1 (&60), so the launched
     3C0A 6000     
12687 3C0C D800  30        movb ra,@INWK+14                ; STA INWK+14       ; ship is pointing away from us
     3C0E 0061     
12688               
12689 3C10 0260  22        ori  ra,>80*256                 ; ORA #128          ; Set byte #22 (sidev_x_hi) to -1 (&D0), so the launched
     3C12 8000     
12690 3C14 D800  30        movb ra,@INWK+22                ; STA INWK+22       ; ship has the same orientation as spawned ships, just
     3C16 0069     
12691                                                                          ; pointing away from us (if we set sidev to +1 instead,
12692                                                                          ; this ship would be a mirror image of all the other
12693                                                                          ; ships, which are spawned with -1 in nosev and +1 in
12694                                                                          ; sidev)
12695               
12696 3C18 D020  30        movb @DELTA,ra                  ; LDA DELTA         ; Set byte #27 (speed) to 2 * DELTA, so the launched
     3C1A 008C     
12697 3C1C 06A0  32        bl   @rola                      ; ROL A             ; ship flies off at twice our speed
     3C1E FF26     
12698 3C20 D800  30        movb ra,@INWK+27                ; STA INWK+27
     3C22 006E     
12699               
12700 3C24 D001  18        movb rx,ra                      ; TXA               ; Add a new ship of type X to our local bubble of
12701 3C26 0460  28        b    @NWSHP                     ; JMP NWSHP         ; universe and return from the subroutine using a tail
     3C28 AF7A     
12702                                                                          ; call
12703               
12704               * ******************************************************************************
12705               *
12706               * Name: FRMIS
12707               * Type: Subroutine
12708               * Category: Tactics
12709               * Summary: Fire a missile from our ship
12710               *
12711               * ------------------------------------------------------------------------------
12712               *
12713               * We fired a missile, so send it streaking away from us to unleash mayhem and
12714               * destruction on our sworn enemies.
12715               *
12716               * ******************************************************************************
12717               
12718               FRMIS:
12719 3C2A 0201  20        li   rx,(MSL)*256               ; LDX #MSL          ; Call FRS1 to launch a missile straight ahead of us
     3C2C 0900     
12720 3C2E 0206  20        li   rtmp,FRS1                  ; JSR FRS1
     3C30 3BD8     
12721 3C32 06A0  32        bl   @jsr                       ;
     3C34 FF10     
12722               
12723 3C36 175D  14        jnc  FR1                        ; BCC FR1           ; If FRS1 returns with the C flag clear, then there
12724                                                                          ; isn't room in the universe for our missile, so jump
12725                                                                          ; down to FR1 to display a "missile jammed" message
12726               
12727 3C38 D060  30        movb @MSTG,rx                   ; LDX MSTG          ; Fetch the slot number of the missile's target
     3C3A 0052     
12728               
12729 3C3C 0206  20        li   rtmp,GINF                  ; JSR GINF          ; Get the address of the data block for the target ship
     3C3E AF0C     
12730 3C40 06A0  32        bl   @jsr                       ;
     3C42 FF10     
12731                                                                          ; and store it in INF
12732               
12733 3C44 D021  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the ship type of the missile's target into A
     3C46 0D40     
12734               
12735 3C48 0206  20        li   rtmp,ANGRY                 ; JSR ANGRY         ; Call ANGRY to make the target ship hostile
     3C4A 3C66     
12736 3C4C 06A0  32        bl   @jsr                       ;
     3C4E FF10     
12737               
12738 3C50 0202  20        li   ry,>00*256                 ; LDY #0            ; We have just launched a missile, so we need to remove
     3C52 0000     
12739 3C54 0206  20        li   rtmp,ABORT                 ; JSR ABORT         ; missile lock and hide the leftmost indicator on the
     3C56 B0A2     
12740 3C58 06A0  32        bl   @jsr                       ;
     3C5A FF10     
12741                                                                          ; dashboard by setting it to black (Y = 0)
12742               
12743 3C5C 7004  18        sb   rone,ra                    ; DEC NOMSL         ; Reduce the number of missiles we have by 1
12744               
12745 3C5E 0200  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     3C60 3000     
12746 3C62 0460  28        b    @NOISE                     ; JMP NOISE         ; of a missile launch, returning from the subroutine
     3C64 CBB0     
12747                                                                          ; using a tail call
12748               
12749               * ******************************************************************************
12750               *
12751               * Name: ANGRY
12752               * Type: Subroutine
12753               * Category: Tactics
12754               * Summary: Make a ship hostile
12755               *
12756               * ------------------------------------------------------------------------------
12757               *
12758               * All this routine does is set the ship's hostile flag, start it turning and
12759               * give it a kick of acceleration - later calls to TACTICS will make the ship
12760               * start to attack us.
12761               *
12762               * ------------------------------------------------------------------------------
12763               *
12764               * Arguments:
12765               *
12766               * A                   The type of ship we're going to irritate
12767               *
12768               * INF                 The address of the data block for the ship we're going
12769               * to infuriate
12770               *
12771               * ******************************************************************************
12772               
12773               ANGRY:
12774 3C66 0280  22        ci   ra,(SST)*256               ; CMP #SST          ; If this is the space station, jump to AN2 to make the
     3C68 0800     
12775 3C6A 1334  14        jeq  AN2                        ; BEQ AN2           ; space station hostile
12776               
12777 3C6C 18B3  14        joc  HI1                        ; BCS HI1           ; If A >= #SST then this is a missile, asteroid, cargo
12778                                                                          ; canister, Thargon or escape pod, and they can't get
12779                                                                          ; hostile, so return from the subroutine (as HI1
12780                                                                          ; contains an RTS)
12781               
12782 3C6E 0280  22        ci   ra,(CYL)*256               ; CMP #CYL          ; If this is not a Cobra Mk III trader, skip the
     3C70 0700     
12783 3C72 1604  14        jne  B37                        ; BNE B37           ; following instruction
12784               
12785 3C74 0206  20        li   rtmp,AN2                   ; JSR AN2           ; Call AN2 to make the space station hostile
     3C76 3CD4     
12786 3C78 06A0  32        bl   @jsr                       ;
     3C7A FF10     
12787               
12788               B37:
12789 3C7C 0202  20        li   ry,>20*256                 ; LDY #32           ; Fetch the ship's byte #32 (AI flag)
     3C7E 2000     
12790                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y
     **** ****     > LD_IND_Y_IDX
0001 3C80 D820  50        movb @INF,@rtmplb
     3C82 0020     
     3C84 2079     
0002 3C86 D1A0  30        movb @INF+1,rtmp
     3C88 0021     
0003 3C8A A182  18        a    ry,rtmp
0004 3C8C D016  26        movb *rtmp,RA
                   < elite.a99
12791               
12792 3C8E 13A2  14        jeq  HI1                        ; BEQ HI1           ; If the AI flag is zero then this ship has no AI and
12793                                                                          ; it can't get hostile, so return from the subroutine
12794                                                                          ; (as HI1 contains an RTS)
12795               
12796 3C90 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Otherwise set bit 7 (AI enabled) to ensure AI is
     3C92 8000     
12797                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; definitely enabled
     **** ****     > ST_IND_Y_IDX
0001 3C94 D820  50        movb @INF,@rtmplb
     3C96 0020     
     3C98 2079     
0002 3C9A D1A0  30        movb @INF+1,rtmp
     3C9C 0021     
0003 3C9E A182  18        a    ry,rtmp
0004 3CA0 D580  30        movb RA,*rtmp
                   < elite.a99
12798               
12799 3CA2 0202  20        li   ry,>1c*256                 ; LDY #28           ; Set the ship's byte #28 (acceleration) to 2, so it
     3CA4 1C00     
12800 3CA6 0200  20        li   ra,>02*256                 ; LDA #2            ; speeds up
     3CA8 0200     
12801                      .st_ind_y_idx @INF,ra           ; STA (INF),Y
     **** ****     > ST_IND_Y_IDX
0001 3CAA D820  50        movb @INF,@rtmplb
     3CAC 0020     
     3CAE 2079     
0002 3CB0 D1A0  30        movb @INF+1,rtmp
     3CB2 0021     
0003 3CB4 A182  18        a    ry,rtmp
0004 3CB6 D580  30        movb RA,*rtmp
                   < elite.a99
12802               
12803                      .asla                           ; ASL A             ; Set the ship's byte #30 (pitch counter) to 4, so it
     **** ****     > ASLA
0001 3CB8 0240  22        andi ra,>ff00
     3CBA FF00     
0002 3CBC 0A10  18        sla  ra,1
                   < elite.a99
12804 3CBE 0202  20        li   ry,>1e*256                 ; LDY #30           ; starts diving
     3CC0 1E00     
12805                      .st_ind_y_idx @INF,ra           ; STA (INF),Y
     **** ****     > ST_IND_Y_IDX
0001 3CC2 D820  50        movb @INF,@rtmplb
     3CC4 0020     
     3CC6 2079     
0002 3CC8 D1A0  30        movb @INF+1,rtmp
     3CCA 0021     
0003 3CCC A182  18        a    ry,rtmp
0004 3CCE D580  30        movb RA,*rtmp
                   < elite.a99
12806               
12807 3CD0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3CD2 FF1C     
12808               
12809               AN2:
12810                      .asl @K.+NI.+32                 ; ASL K%+NI%+32     ; Fetch the AI counter (byte #32) of the second ship
     **** ****     > ASL
0001 3CD4 D1A0  30        movb @K.+NI.+32,rtmp
     3CD6 0944     
0002 3CD8 0246  22        andi rtmp,>ff00
     3CDA FF00     
0003 3CDC 0A16  18        sla  rtmp,1
0004 3CDE D806  30        movb rtmp,@K.+NI.+32
     3CE0 0944     
                   < elite.a99
12811                      .sec                            ; SEC               ; in the ship data workspace at K%, which is reserved
     **** ****     > SEC
0001 3CE2 0A15  18        sla  rmone,1
                   < elite.a99
12812 3CE4 0208  20        li   rarg1,K.+NI.+32            ; ROR K%+NI%+32     ; for the sun or the space station (in this case it's
     3CE6 0944     
12813 3CE8 06A0  32        bl   @ror                       ;
     3CEA FF62     
12814                                                                          ; the latter), and set bit 7 to make it hostile
12815               
12816                      .clc                            ; CLC               ; Clear the C flag, which isn't used by calls to this
     **** ****     > CLC
0001 3CEC 0A13  18        sla  rzero,1
                   < elite.a99
12817                                                                          ; routine, but it does set up the entry point FR1-2
12818                                                                          ; so that it clears the C flag and does an RTS
12819               
12820 3CEE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3CF0 FF1C     
12821               
12822               * ******************************************************************************
12823               *
12824               * Name: FR1
12825               * Type: Subroutine
12826               * Category: Tactics
12827               * Summary: Display the "missile jammed" message
12828               *
12829               * ------------------------------------------------------------------------------
12830               *
12831               * This is shown if there isn't room in the local bubble of universe for a new
12832               * missile.
12833               *
12834               * ------------------------------------------------------------------------------
12835               *
12836               * Other entry points:
12837               *
12838               * FR1-2               Clear the C flag and return from the subroutine
12839               *
12840               * ******************************************************************************
12841               
12842               FR1:
12843 3CF2 0200  20        li   ra,>c9*256                 ; LDA #201          ; Print recursive token 41 ("MISSILE JAMMED") as an
     3CF4 C900     
12844 3CF6 0460  28        b    @MESS                      ; JMP MESS          ; in-flight message and return from the subroutine using
     3CF8 CE5E     
12845                                                                          ; a tail call
12846               
12847               * ******************************************************************************
12848               *
12849               * Name: SESCP
12850               * Type: Subroutine
12851               * Category: Flight
12852               * Summary: Spawn an escape pod from the current (parent) ship
12853               *
12854               * ------------------------------------------------------------------------------
12855               *
12856               * This is called when an enemy ship has run out of both energy and luck, so it's
12857               * time to bail.
12858               *
12859               * ******************************************************************************
12860               
12861               SESCP:
12862 3CFA 0201  20        li   rx,(ESC)*256               ; LDX #ESC          ; Set X to the ship type for an escape pod
     3CFC 0D00     
12863               
12864 3CFE 0200  20        li   ra,>fe*256                 ; LDA #%11111110    ; Set A to an AI flag that has AI enabled, is hostile,
     3D00 FE00     
12865                                                                          ; but has no E.C.M.
12866               
12867                                                                          ; Fall through into SFS1 to spawn the escape pod
12868               
12869               * ******************************************************************************
12870               *
12871               * Name: SFS1
12872               * Type: Subroutine
12873               * Category: Universe
12874               * Summary: Spawn a child ship from the current (parent) ship
12875               *
12876               * ------------------------------------------------------------------------------
12877               *
12878               * If the parent is a space station then the child ship is spawned coming out of
12879               * the slot, and if the child is a cargo canister, it is sent tumbling through
12880               * space. Otherwise the child ship is spawned with the same ship data as the
12881               * parent, just with damping disabled and the ship type and AI flag that are
12882               * passed in A and X.
12883               *
12884               * ------------------------------------------------------------------------------
12885               *
12886               * Arguments:
12887               *
12888               * A                   AI flag for the new ship (see the documentation on ship
12889               * data byte #32 for details)
12890               *
12891               * X                   The ship type of the child to spawn
12892               *
12893               * INF                 Address of the parent's ship data block
12894               *
12895               * TYPE                The type of the parent ship
12896               *
12897               * ------------------------------------------------------------------------------
12898               *
12899               * Returns:
12900               *
12901               * C flag              Set if ship successfully added, clear if it failed
12902               *
12903               * INF                 INF is preserved
12904               *
12905               * XX0                 XX0 is preserved
12906               *
12907               * INWK                The whole INWK workspace is preserved
12908               *
12909               * ------------------------------------------------------------------------------
12910               *
12911               * Other entry points:
12912               *
12913               * SFS1-2              Add a missile to the local bubble that has AI enabled,
12914               * is hostile, but has no E.C.M.
12915               *
12916               * ******************************************************************************
12917               
12918               SFS1:
12919 3D02 D800  30        movb ra,@T1                     ; STA T1            ; Store the child ship's AI flag in T1
     3D04 0006     
12920               
12921                                                                          ; Before spawning our child ship, we need to save the
12922                                                                          ; INF and XX00 variables and the whole INWK workspace,
12923                                                                          ; so we can restore them later when returning from the
12924                                                                          ; subroutine
12925               
12926 3D06 D020  30        movb @XX0,ra                    ; LDA XX0           ; Store XX0(1 0) on the stack, so we can restore it
     3D08 001E     
12927                      .pha                            ; PHA               ; later when returning from the subroutine
     **** ****     > PHA
0001 3D0A D680  30        movb ra,*rsp
0002 3D0C 060A  14        dec  rsp
                   < elite.a99
12928 3D0E D020  30        movb @XX0+1,ra                  ; LDA XX0+1
     3D10 001F     
12929                      .pha                            ; PHA
     **** ****     > PHA
0001 3D12 D680  30        movb ra,*rsp
0002 3D14 060A  14        dec  rsp
                   < elite.a99
12930               
12931 3D16 D020  30        movb @INF,ra                    ; LDA INF           ; Store INF(1 0) on the stack, so we can restore it
     3D18 0020     
12932                      .pha                            ; PHA               ; later when returning from the subroutine
     **** ****     > PHA
0001 3D1A D680  30        movb ra,*rsp
0002 3D1C 060A  14        dec  rsp
                   < elite.a99
12933 3D1E D020  30        movb @INF+1,ra                  ; LDA INF+1
     3D20 0021     
12934                      .pha                            ; PHA
     **** ****     > PHA
0001 3D22 D680  30        movb ra,*rsp
0002 3D24 060A  14        dec  rsp
                   < elite.a99
12935               
12936 3D26 0202  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; Now we want to store the current INWK data block in
     3D28 2300     
12937                                                                          ; temporary memory so we can restore it when we are
12938                                                                          ; done, and we also want to copy the parent's ship data
12939                                                                          ; into INWK, which we can do at the same time, so set up
12940                                                                          ; a counter in Y for NI% bytes
12941               
12942               FRL2:
12943 3D2A D022  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Copy the Y-th byte of INWK to the Y-th byte of
     3D2C 0053     
12944 3D2E D880  38        movb ra,@XX3(ry)                ; STA XX3,Y         ; temporary memory in XX3, so we can restore it later
     3D30 0100     
12945                                                                          ; when returning from the subroutine
12946               
12947                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Copy the Y-th byte of the parent ship's data block to
     **** ****     > LD_IND_Y_IDX
0001 3D32 D820  50        movb @INF,@rtmplb
     3D34 0020     
     3D36 2079     
0002 3D38 D1A0  30        movb @INF+1,rtmp
     3D3A 0021     
0003 3D3C A182  18        a    ry,rtmp
0004 3D3E D016  26        movb *rtmp,RA
                   < elite.a99
12948 3D40 D880  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; the Y-th byte of INWK
     3D42 0053     
12949               
12950 3D44 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
12951               
12952 3D46 15F1  14        jgt  FRL2                       ; BPL FRL2          ; Loop back to copy the next byte until we have done
12953                                                                          ; them all
12954               
12955                                                                          ; INWK now contains the ship data for the parent ship,
12956                                                                          ; so now we need to tweak the data before creating the
12957                                                                          ; new child ship (in this way, the child inherits things
12958                                                                          ; like location from the parent)
12959               
12960 3D48 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship type of the parent into A
     3D4A 009B     
12961               
12962 3D4C 0280  22        ci   ra,(SST)*256               ; CMP #SST          ; If the parent is not a space station, jump to rx to
     3D4E 0800     
12963 3D50 1622  14        jne  rx_                        ; BNE rx            ; skip the following
12964               
12965                                                                          ; The parent is a space station, so the child needs to
12966                                                                          ; launch out of the space station's slot. The space
12967                                                                          ; station's nosev vector points out of the station's
12968                                                                          ; slot, so we want to move the ship along this vector.
12969                                                                          ; We do this by taking the unit vector in nosev and
12970                                                                          ; doubling it, so we spawn our ship 2 units along the
12971                                                                          ; vector from the space station's centre
12972               
12973 3D52 D001  18        movb rx,ra                      ; TXA               ; Store the child's ship type in X on the stack
12974                      .pha                            ; PHA
     **** ****     > PHA
0001 3D54 D680  30        movb ra,*rsp
0002 3D56 060A  14        dec  rsp
                   < elite.a99
12975               
12976 3D58 0200  20        li   ra,>20*256                 ; LDA #32           ; Set the child's byte #27 (speed) to 32
     3D5A 2000     
12977 3D5C D800  30        movb ra,@INWK+27                ; STA INWK+27
     3D5E 006E     
12978               
12979 3D60 0201  20        li   rx,>00*256                 ; LDX #0            ; Add 2 * nosev_x_hi to (x_lo, x_hi, x_sign) to get the
     3D62 0000     
12980 3D64 D020  30        movb @INWK+10,ra                ; LDA INWK+10       ; child's x-coordinate
     3D66 005D     
12981 3D68 0206  20        li   rtmp,SFS2                  ; JSR SFS2
     3D6A 3E26     
12982 3D6C 06A0  32        bl   @jsr                       ;
     3D6E FF10     
12983               
12984 3D70 0201  20        li   rx,>03*256                 ; LDX #3            ; Add 2 * nosev_y_hi to (y_lo, y_hi, y_sign) to get the
     3D72 0300     
12985 3D74 D020  30        movb @INWK+12,ra                ; LDA INWK+12       ; child's y-coordinate
     3D76 005F     
12986 3D78 0206  20        li   rtmp,SFS2                  ; JSR SFS2
     3D7A 3E26     
12987 3D7C 06A0  32        bl   @jsr                       ;
     3D7E FF10     
12988               
12989 3D80 0201  20        li   rx,>06*256                 ; LDX #6            ; Add 2 * nosev_z_hi to (z_lo, z_hi, z_sign) to get the
     3D82 0600     
12990 3D84 D020  30        movb @INWK+14,ra                ; LDA INWK+14       ; child's z-coordinate
     3D86 0061     
12991 3D88 0206  20        li   rtmp,SFS2                  ; JSR SFS2
     3D8A 3E26     
12992 3D8C 06A0  32        bl   @jsr                       ;
     3D8E FF10     
12993               
12994                      .pla                            ; PLA               ; Restore the child's ship type from the stack into X
     **** ****     > PLA
0001 3D90 058A  14        inc  rsp
0002 3D92 D01A  26        movb *rsp,ra
                   < elite.a99
12995 3D94 D040  18        movb ra,rx                      ; TAX
12996               
12997               rx_:
12998 3D96 D020  30        movb @T1,ra                     ; LDA T1            ; Restore the child ship's AI flag from T1 and store it
     3D98 0006     
12999 3D9A D800  30        movb ra,@INWK+32                ; STA INWK+32       ; in the child's byte #32 (AI)
     3D9C 0073     
13000               
13001                      .lsr @INWK+29                   ; LSR INWK+29       ; Clear bit 0 of the child's byte #29 (roll counter) so
     **** ****     > LSR
0001 3D9E D1A0  30        movb @INWK+29,rtmp
     3DA0 0070     
0002 3DA2 0916  18        srl  rtmp,1
0003 3DA4 D806  30        movb rtmp,@INWK+29
     3DA6 0070     
                   < elite.a99
13002                      .asl @INWK+29                   ; ASL INWK+29       ; that its roll dampens (so if we are spawning from a
     **** ****     > ASL
0001 3DA8 D1A0  30        movb @INWK+29,rtmp
     3DAA 0070     
0002 3DAC 0246  22        andi rtmp,>ff00
     3DAE FF00     
0003 3DB0 0A16  18        sla  rtmp,1
0004 3DB2 D806  30        movb rtmp,@INWK+29
     3DB4 0070     
                   < elite.a99
13003                                                                          ; space station, for example, the spawned ship won't
13004                                                                          ; keep rolling forever)
13005               
13006 3DB6 D001  18        movb rx,ra                      ; TXA               ; Copy the child's ship type from X into A
13007               
13008 3DB8 0280  22        ci   ra,(OIL)*256               ; CMP #OIL          ; If the child we are spawning is not a cargo canister,
     3DBA 0B00     
13009 3DBC 1616  14        jne  NOIL                       ; BNE NOIL          ; jump to NOIL to skip us setting up the pitch and roll
13010                                                                          ; for the canister
13011               
13012 3DBE 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3DC0 C07C     
13013 3DC2 06A0  32        bl   @jsr                       ;
     3DC4 FF10     
13014               
13015                      .asla                           ; ASL A             ; Set the child's byte #30 (pitch counter) to a random
     **** ****     > ASLA
0001 3DC6 0240  22        andi ra,>ff00
     3DC8 FF00     
0002 3DCA 0A10  18        sla  ra,1
                   < elite.a99
13016 3DCC D800  30        movb ra,@INWK+30                ; STA INWK+30       ; value, and at the same time set the C flag randomly
     3DCE 0071     
13017               
13018 3DD0 D001  18        movb rx,ra                      ; TXA               ; Set the child's byte #27 (speed) to a random value
13019 3DD2 0240  22        andi ra,>0f*256                 ; AND #%00001111    ; between 0 and 15
     3DD4 0F00     
13020 3DD6 D800  30        movb ra,@INWK+27                ; STA INWK+27
     3DD8 006E     
13021               
13022 3DDA 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Set the child's byte #29 (roll counter) to a full
     3DDC FF00     
13023 3DDE 06A0  32        bl   @rora                      ; ROR A             ; roll with no damping (as bits 0 to 6 are set), so the
     3DE0 FF4A     
13024 3DE2 D800  30        movb ra,@INWK+29                ; STA INWK+29       ; canister tumbles through space, with the direction in
     3DE4 0070     
13025                                                                          ; bit 7 set randomly, depending on the C flag from above
13026               
13027 3DE6 0200  20        li   ra,(OIL)*256               ; LDA #OIL          ; Set A to the ship type of a cargo canister
     3DE8 0B00     
13028               
13029               NOIL:
13030 3DEA 0206  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Add a new ship of type A to the local bubble
     3DEC AF7A     
13031 3DEE 06A0  32        bl   @jsr                       ;
     3DF0 FF10     
13032               
13033                                                                          ; We have now created our child ship, so we need to
13034                                                                          ; restore all the variables we saved at the start of
13035                                                                          ; the routine, so they are preserved when we return
13036                                                                          ; from the subroutine
13037               
13038                      .pla                            ; PLA               ; Restore INF(1 0) from the stack
     **** ****     > PLA
0001 3DF2 058A  14        inc  rsp
0002 3DF4 D01A  26        movb *rsp,ra
                   < elite.a99
13039 3DF6 D800  30        movb ra,@INF+1                  ; STA INF+1
     3DF8 0021     
13040                      .pla                            ; PLA
     **** ****     > PLA
0001 3DFA 058A  14        inc  rsp
0002 3DFC D01A  26        movb *rsp,ra
                   < elite.a99
13041 3DFE D800  30        movb ra,@INF                    ; STA INF
     3E00 0020     
13042               
13043 3E02 0201  20        li   rx,(NI.-1)*256             ; LDX #NI%-1        ; Now to restore the INWK workspace that we saved into
     3E04 2300     
13044                                                                          ; XX3 above, so set a counter in X for NI% bytes
13045               
13046               FRL3:
13047 3E06 D021  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Copy the Y-th byte of XX3 to the Y-th byte of INWK
     3E08 0100     
13048 3E0A D840  38        movb ra,@INWK(rx)               ; STA INWK,X
     3E0C 0053     
13049               
13050 3E0E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
13051               
13052 3E10 15FA  14        jgt  FRL3                       ; BPL FRL3          ; Loop back to copy the next byte until we have done
13053                                                                          ; them all
13054               
13055                      .pla                            ; PLA               ; Restore XX0(1 0) from the stack
     **** ****     > PLA
0001 3E12 058A  14        inc  rsp
0002 3E14 D01A  26        movb *rsp,ra
                   < elite.a99
13056 3E16 D800  30        movb ra,@XX0+1                  ; STA XX0+1
     3E18 001F     
13057                      .pla                            ; PLA
     **** ****     > PLA
0001 3E1A 058A  14        inc  rsp
0002 3E1C D01A  26        movb *rsp,ra
                   < elite.a99
13058 3E1E D800  30        movb ra,@XX0                    ; STA XX0
     3E20 001E     
13059               
13060 3E22 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3E24 FF1C     
13061               
13062               * ******************************************************************************
13063               *
13064               * Name: SFS2
13065               * Type: Subroutine
13066               * Category: Moving
13067               * Summary: Move a ship in space along one of the coordinate axes
13068               *
13069               * ------------------------------------------------------------------------------
13070               *
13071               * Move a ship's coordinates by a certain amount in the direction of one of the
13072               * axes, where X determines the axis. Mathematically speaking, this routine
13073               * translates the ship along a single axis by a signed delta.
13074               *
13075               * ------------------------------------------------------------------------------
13076               *
13077               * Arguments:
13078               *
13079               * A                   The amount of movement, i.e. the signed delta
13080               *
13081               * X                   Determines which coordinate axis of INWK to move:
13082               *
13083               * * X = 0 moves the ship along the x-axis
13084               *
13085               * * X = 3 moves the ship along the y-axis
13086               *
13087               * * X = 6 moves the ship along the z-axis
13088               *
13089               * ******************************************************************************
13090               
13091               SFS2:
13092                      .asla                           ; ASL A             ; Set R = |A * 2|, with the C flag set to bit 7 of A
     **** ****     > ASLA
0001 3E26 0240  22        andi ra,>ff00
     3E28 FF00     
0002 3E2A 0A10  18        sla  ra,1
                   < elite.a99
13093 3E2C D800  30        movb ra,@R                      ; STA R
     3E2E 0091     
13094               
13095 3E30 0200  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 of A to the C flag, i.e. the sign bit from
     3E32 0000     
13096 3E34 06A0  32        bl   @rora                      ; ROR A             ; the original argument in A
     3E36 FF4A     
13097               
13098 3E38 0460  24        b    @MVT1                      ; JMP MVT1          ; Add the delta R with sign A to (x_lo, x_hi, x_sign)
     3E3A 1BAA     
13099                                                                          ; (or y or z, depending on the value in X) and return
13100                                                                          ; from the subroutine using a tail call
13101               
13102               * ******************************************************************************
13103               *
13104               * Name: LL164
13105               * Type: Subroutine
13106               * Category: Drawing circles
13107               * Summary: Make the hyperspace sound and draw the hyperspace tunnel
13108               *
13109               * ------------------------------------------------------------------------------
13110               *
13111               * See the IRQ1 routine for details on the multi-coloured effect that's used.
13112               *
13113               * ******************************************************************************
13114               
13115               LL164:
13116 3E3C 0200  20        li   ra,>38*256                 ; LDA #56           ; Call the NOISE routine with A = 56 to make the sound
     3E3E 3800     
13117 3E40 0206  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the hyperspace drive being engaged
     3E42 CBB0     
13118 3E44 06A0  32        bl   @jsr                       ;
     3E46 FF10     
13119               
13120 3E48 0200  20        li   ra,>01*256                 ; LDA #1            ; Set HFX to 1, which switches the screen mode to a full
     3E4A 0100     
13121 3E4C D800  30        movb ra,@HFX                    ; STA HFX           ; mode 5 screen, therefore making the hyperspace rings
     3E4E 0D62     
13122                                                                          ; multi-coloured and all zig-zaggy (see the IRQ1 routine
13123                                                                          ; for details)
13124               
13125 3E50 0200  20        li   ra,>04*256                 ; LDA #4            ; Set the step size for the hyperspace rings to 4, so
     3E52 0400     
13126                                                                          ; there are more sections in the rings and they are
13127                                                                          ; quite round (compared to the step size of 8 used in
13128                                                                          ; the much more polygonal launch rings)
13129               
13130 3E54 0206  20        li   rtmp,HFS2                  ; JSR HFS2          ; Call HFS2 to draw the hyperspace tunnel rings
     3E56 3E72     
13131 3E58 06A0  32        bl   @jsr                       ;
     3E5A FF10     
13132               
13133 3E5C 7004  18        sb   rone,ra                    ; DEC HFX           ; Set HFX back to 0, so we switch back to the normal
13134                                                                          ; split-screen mode
13135               
13136 3E5E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3E60 FF1C     
13137               
13138               * ******************************************************************************
13139               *
13140               * Name: LAUN
13141               * Type: Subroutine
13142               * Category: Drawing circles
13143               * Summary: Make the launch sound and draw the launch tunnel
13144               *
13145               * ------------------------------------------------------------------------------
13146               *
13147               * This is shown when launching from or docking with the space station.
13148               *
13149               * ******************************************************************************
13150               
13151               LAUN:
13152 3E62 0200  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     3E64 3000     
13153 3E66 0206  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the ship launching from the station
     3E68 CBB0     
13154 3E6A 06A0  32        bl   @jsr                       ;
     3E6C FF10     
13155               
13156 3E6E 0200  20        li   ra,>08*256                 ; LDA #8            ; Set the step size for the launch tunnel rings to 8, so
     3E70 0800     
13157                                                                          ; there are fewer sections in the rings and they are
13158                                                                          ; quite polygonal (compared to the step size of 4 used
13159                                                                          ; in the much rounder hyperspace rings)
13160               
13161                                                                          ; Fall through into HFS2 to draw the launch tunnel rings
13162               
13163               * ******************************************************************************
13164               *
13165               * Name: HFS2
13166               * Type: Subroutine
13167               * Category: Drawing circles
13168               * Summary: Draw the launch or hyperspace tunnel
13169               *
13170               * ------------------------------------------------------------------------------
13171               *
13172               * The animation gets drawn like this. First, we draw a circle of radius 8 at the
13173               * centre, and then double the radius, draw another circle, double the radius
13174               * again and draw a circle, and we keep doing this until the radius is bigger
13175               * than 160 (which goes beyond the edge of the screen, which is 256 pixels wide,
13176               * equivalent to a radius of 128). We then repeat this whole process for an
13177               * initial circle of radius 9, then radius 10, all the way up to radius 15.
13178               *
13179               * This has the effect of making the tunnel appear to be racing towards us as we
13180               * hurtle out into hyperspace or through the space station's docking tunnel.
13181               *
13182               * The hyperspace effect is done in a full mode 5 screen, which makes the rings
13183               * all coloured and zig-zaggy, while the launch screen is in the normal
13184               * monochrome mode 4 screen.
13185               *
13186               * ------------------------------------------------------------------------------
13187               *
13188               * Arguments:
13189               *
13190               * A                   The step size of the straight lines making up the rings
13191               * (4 for launch, 8 for hyperspace)
13192               *
13193               * ******************************************************************************
13194               
13195               HFS2:
13196 3E72 D800  30        movb ra,@STP                    ; STA STP           ; Store the step size in A
     3E74 00A6     
13197               
13198 3E76 0206  20        li   rtmp,TTX66                 ; JSR TTX66         ; Clear the screen and draw a white border
     3E78 4B2E     
13199 3E7A 06A0  32        bl   @jsr                       ;
     3E7C FF10     
13200               
13201 3E7E 0206  20        li   rtmp,HFS1                  ; JSR HFS1          ; Call HFS1 below and then fall through into the same
     3E80 3E86     
13202 3E82 06A0  32        bl   @jsr                       ;
     3E84 FF10     
13203                                                                          ; routine, so this effectively runs HFS1 twice, and as
13204                                                                          ; HFS1 draws 8 concentric rings, this means we draw 16
13205                                                                          ; of them in all
13206               
13207               HFS1:
13208 3E86 0200  20        li   ra,>80*256                 ; LDA #128          ; Set K3 = 128 (the x-coordinate of the centre of the
     3E88 8000     
13209 3E8A D800  30        movb ra,@K3                     ; STA K3            ; screen)
     3E8C 00D2     
13210               
13211 3E8E 0201  20        li   rx,(Y)*256                 ; LDX #Y            ; Set K4 = #Y (the y-coordinate of the centre of the
     3E90 6000     
13212 3E92 D801  30        movb rx,@K4                     ; STX K4            ; screen)
     3E94 00E0     
13213               
13214                      .asla                           ; ASL A             ; Set A = 0
     **** ****     > ASLA
0001 3E96 0240  22        andi ra,>ff00
     3E98 FF00     
0002 3E9A 0A10  18        sla  ra,1
                   < elite.a99
13215               
13216 3E9C D800  30        movb ra,@XX4                    ; STA XX4           ; Set XX4 = 0, which we will use as a counter for
     3E9E 00A7     
13217                                                                          ; drawing eight concentric rings
13218               
13219 3EA0 D800  30        movb ra,@K3+1                   ; STA K3+1          ; Set the high bytes of K3(1 0) and K4(1 0) to 0
     3EA2 00D3     
13220 3EA4 D800  30        movb ra,@K4+1                   ; STA K4+1
     3EA6 00E1     
13221               
13222               HFL5:
13223 3EA8 0206  20        li   rtmp,HFL1                  ; JSR HFL1          ; Call HFL1 below to draw a set of rings, with each one
     3EAA 3EC0     
13224 3EAC 06A0  32        bl   @jsr                       ;
     3EAE FF10     
13225                                                                          ; twice the radius of the previous one, until they won't
13226                                                                          ; fit on-screen
13227               
13228 3EB0 B004  18        ab   rone,ra                    ; INC XX4           ; Increment the counter and fetch it into X
13229 3EB2 D060  30        movb @XX4,rx                    ; LDX XX4
     3EB4 00A7     
13230               
13231 3EB6 0281  22        ci   rx,>08*256                 ; CPX #8            ; If we haven't drawn 8 sets of rings yet, loop back to
     3EB8 0800     
13232 3EBA 16F6  14        jne  HFL5                       ; BNE HFL5          ; HFL5 to draw the next ring
13233               
13234 3EBC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3EBE FF1C     
13235               
13236               HFL1:
13237 3EC0 D020  30        movb @XX4,ra                    ; LDA XX4           ; Set K to the ring number in XX4 (0-7) + 8, so K has
     3EC2 00A7     
13238 3EC4 0240  22        andi ra,>07*256                 ; AND #7            ; a value of 8 to 15, which we will use as the starting
     3EC6 0700     
13239                      .clc                            ; CLC               ; radius for our next set of rings
     **** ****     > CLC
0001 3EC8 0A13  18        sla  rzero,1
                   < elite.a99
13240                      .adi (>08*256)                  ; ADC #8
     **** ****     > ADI
0001 3ECA 1701  14        jnc  !
0002 3ECC B004  18        ab   rone,ra
0003               !:
0004 3ECE 0220  22        ai   ra,(>08*256)
     3ED0 0800     
                   < elite.a99
13241 3ED2 D800  30        movb ra,@K                      ; STA K
     3ED4 003D     
13242               
13243               HFL2:
13244 3ED6 0200  20        li   ra,>01*256                 ; LDA #1            ; Set LSP = 1 to reset the ball line heap
     3ED8 0100     
13245 3EDA D800  30        movb ra,@LSP                    ; STA LSP
     3EDC 0077     
13246               
13247 3EDE 0206  20        li   rtmp,CIRCLE2               ; JSR CIRCLE2       ; Call CIRCLE2 to draw a circle with the centre at
     3EE0 B82C     
13248 3EE2 06A0  32        bl   @jsr                       ;
     3EE4 FF10     
13249                                                                          ; (K3(1 0), K4(1 0)) and radius K
13250               
13251                      .asl @K                         ; ASL K             ; Double the radius in K
     **** ****     > ASL
0001 3EE6 D1A0  30        movb @K,rtmp
     3EE8 003D     
0002 3EEA 0246  22        andi rtmp,>ff00
     3EEC FF00     
0003 3EEE 0A16  18        sla  rtmp,1
0004 3EF0 D806  30        movb rtmp,@K
     3EF2 003D     
                   < elite.a99
13252               
13253 3EF4 1805  14        joc  HF8                        ; BCS HF8           ; If the radius had a 1 in bit 7 before the above shift,
13254                                                                          ; then doubling K will means the circle will no longer
13255                                                                          ; fit on the screen (which is width 256), so jump to
13256                                                                          ; HF8 to stop drawing circles
13257               
13258 3EF6 D020  30        movb @K,ra                      ; LDA K             ; If the radius in K <= 160, loop back to HFL2 to draw
     3EF8 003D     
13259 3EFA 0280  22        ci   ra,>a0*256                 ; CMP #160          ; another one
     3EFC A000     
13260 3EFE 17EB  14        jnc  HFL2                       ; BCC HFL2
13261               
13262               HF8:
13263 3F00 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3F02 FF1C     
13264               
13265               * ******************************************************************************
13266               *
13267               * Name: STARS2
13268               * Type: Subroutine
13269               * Category: Stardust
13270               * Summary: Process the stardust for the left or right view
13271               * Deep dive: Stardust in the side views
13272               *
13273               * ------------------------------------------------------------------------------
13274               *
13275               * This moves the stardust sideways according to our speed and which side we are
13276               * looking out of, and applies our current pitch and roll to each particle of
13277               * dust, so the stardust moves correctly when we steer our ship.
13278               *
13279               * These are the calculations referred to in the commentary:
13280               *
13281               * 1. delta_x = 8 * 256 * speed / z_hi
13282               * 2. x = x + delta_x
13283               *
13284               * 3. x = x + beta * y
13285               * 4. y = y - beta * x
13286               *
13287               * 5. x = x - alpha * x * y
13288               * 6. y = y + alpha * y * y + alpha
13289               *
13290               * For more information see the deep dive on "Stardust in the side views".
13291               *
13292               * ------------------------------------------------------------------------------
13293               *
13294               * Arguments:
13295               *
13296               * X                   The view to process:
13297               *
13298               * * X = 1 for left view
13299               *
13300               * * X = 2 for right view
13301               *
13302               * ******************************************************************************
13303               
13304               STARS2:
13305 3F04 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can use it to capture a sign bit
     3F06 0000     
13306               
13307 3F08 0281  22        ci   rx,>02*256                 ; CPX #2            ; If X >= 2 then the C flag is set
     3F0A 0200     
13308               
13309 3F0C 06A0  32        bl   @rora                      ; ROR A             ; Roll the C flag into the sign bit of A and store in
     3F0E FF4A     
13310 3F10 D800  30        movb ra,@RAT                    ; STA RAT           ; RAT, so:
     3F12 00AA     
13311                                                                          ;
13312                                                                          ; * Left view, C is clear so RAT = 0 (positive)
13313                                                                          ;
13314                                                                          ; * Right view, C is set so RAT = 128 (negative)
13315                                                                          ;
13316                                                                          ; RAT represents the end of the x-axis where we want new
13317                                                                          ; stardust particles to come from: positive for the left
13318                                                                          ; view where new particles come in from the right,
13319                                                                          ; negative for the right view where new particles come
13320                                                                          ; in from the left
13321               
13322                      .eoi (>80*256)                  ; EOR #%10000000    ; Set RAT2 to the opposite sign, so:
     **** ****     > EOI
0001 3F14 0206  20        li   rtmp,(>80*256)
     3F16 8000     
0002 3F18 2806  18        xor  rtmp,ra
                   < elite.a99
13323 3F1A D800  30        movb ra,@RAT2                   ; STA RAT2          ;
     3F1C 00AB     
13324                                                                          ; * Left view, RAT2 = 128 (negative)
13325                                                                          ;
13326                                                                          ; * Right view, RAT2 = 0 (positive)
13327                                                                          ;
13328                                                                          ; RAT2 represents the direction in which stardust
13329                                                                          ; particles should move along the x-axis: negative for
13330                                                                          ; the left view where particles go from right to left,
13331                                                                          ; positive for the right view where particles go from
13332                                                                          ; left to right
13333               
13334 3F1E 0206  20        li   rtmp,ST2                   ; JSR ST2           ; Call ST2 to flip the signs of the following if this is
     3F20 4078     
13335 3F22 06A0  32        bl   @jsr                       ;
     3F24 FF10     
13336                                                                          ; the right view: ALPHA, ALP2, ALP2+1, BET2 and BET2+1
13337               
13338 3F26 D0A0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     3F28 0F33     
13339                                                                          ; we can use it as a counter through all the stardust
13340               
13341               STL2:
13342 3F2A D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Set A = ZZ = z_hi
     3F2C 0EE8     
13343               
13344 3F2E D800  30        movb ra,@ZZ                     ; STA ZZ            ; We also set ZZ to the original value of z_hi, which we
     3F30 0097     
13345                                                                          ; use below to remove the existing particle
13346               
13347 3F32 0910  18        srl  ra,1                       ; LSR A             ; Set A = z_hi / 8
13348 3F34 0910  18        srl  ra,1                       ; LSR A
13349 3F36 0910  18        srl  ra,1                       ; LSR A
13350               
13351 3F38 0206  20        li   rtmp,DV41                  ; JSR DV41          ; Call DV41 to set the following:
     3F3A 45A8     
13352 3F3C 06A0  32        bl   @jsr                       ;
     3F3E FF10     
13353                                                                          ;
13354                                                                          ; (P R) = 256 * DELTA / A
13355                                                                          ; = 256 * speed / (z_hi / 8)
13356                                                                          ; = 8 * 256 * speed / z_hi
13357                                                                          ;
13358                                                                          ; This represents the distance we should move this
13359                                                                          ; particle along the x-axis, let's call it delta_x
13360               
13361 3F40 D020  30        movb @P,ra                      ; LDA P             ; Set S = P but with the sign from RAT2, so we now have
     3F42 001B     
13362                      .eor @RAT2                      ; EOR RAT2          ; the distance delta_x with the correct sign in (S R):
     **** ****     > EOR
0001 3F44 D1A0  30        movb @RAT2,rtmp
     3F46 00AB     
0002 3F48 2806  18        xor  rtmp,ra
                   < elite.a99
13363 3F4A D800  30        movb ra,@S                      ; STA S             ;
     3F4C 0092     
13364                                                                          ; (S R) = delta_x
13365                                                                          ; = 8 * 256 * speed / z_hi
13366                                                                          ;
13367                                                                          ; So (S R) is the delta, signed to match the direction
13368                                                                          ; the stardust should move in, which is result 1 above
13369               
13370 3F4E D022  34        movb @SXL(ry),ra                ; LDA SXL,Y         ; Set (A P) = (x_hi x_lo)
     3F50 035F     
13371 3F52 D800  30        movb ra,@P                      ; STA P             ; = x
     3F54 001B     
13372 3F56 D022  34        movb @SX(ry),ra                 ; LDA SX,Y
     3F58 034C     
13373               
13374 3F5A D800  30        movb ra,@X1                     ; STA X1            ; Set X1 = A, so X1 contains the original value of x_hi,
     3F5C 0031     
13375                                                                          ; which we use below to remove the existing particle
13376               
13377 3F5E 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     3F60 44BA     
13378 3F62 06A0  32        bl   @jsr                       ;
     3F64 FF10     
13379                                                                          ;
13380                                                                          ; (A X) = (A P) + (S R)
13381                                                                          ; = x + delta_x
13382               
13383 3F66 D800  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     3F68 0092     
13384 3F6A D801  30        movb rx,@R                      ; STX R             ; = x + delta_x
     3F6C 0091     
13385               
13386 3F6E D022  34        movb @SY(ry),ra                 ; LDA SY,Y          ; Set A = y_hi
     3F70 0EC2     
13387               
13388 3F72 D800  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 = A, so Y1 contains the original value of y_hi,
     3F74 0032     
13389                                                                          ; which we use below to remove the existing particle
13390               
13391                      .eor @BET2                      ; EOR BET2          ; Give A the correct sign of A * beta, i.e. y_hi * beta
     **** ****     > EOR
0001 3F76 D1A0  30        movb @BET2,rtmp
     3F78 008A     
0002 3F7A 2806  18        xor  rtmp,ra
                   < elite.a99
13392               
13393 3F7C D060  30        movb @BET1,rx                   ; LDX BET1          ; Fetch |beta| from BET1, the pitch angle
     3F7E 002B     
13394               
13395 3F80 0206  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     3F82 41F4     
13396 3F84 06A0  32        bl   @jsr                       ;
     3F86 FF10     
13397                                                                          ;
13398                                                                          ; (A P) = X * A
13399                                                                          ; = beta * y_hi
13400               
13401 3F88 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     3F8A 44BA     
13402 3F8C 06A0  32        bl   @jsr                       ;
     3F8E FF10     
13403                                                                          ;
13404                                                                          ; (A X) = (A P) + (S R)
13405                                                                          ; = beta * y + x + delta_x
13406               
13407 3F90 D801  30        movb rx,@XX                     ; STX XX            ; Set XX(1 0) = (A X), which gives us results 2 and 3
     3F92 0024     
13408 3F94 D800  30        movb ra,@XX+1                   ; STA XX+1          ; above, done at the same time:
     3F96 0025     
13409                                                                          ;
13410                                                                          ; x = x + delta_x + beta * y
13411               
13412 3F98 D062  34        movb @SYL(ry),rx                ; LDX SYL,Y         ; Set (S R) = (y_hi y_lo)
     3F9A 0ED5     
13413 3F9C D801  30        movb rx,@R                      ; STX R             ; = y
     3F9E 0091     
13414 3FA0 D060  30        movb @Y1,rx                     ; LDX Y1
     3FA2 0032     
13415 3FA4 D801  30        movb rx,@S                      ; STX S
     3FA6 0092     
13416               
13417 3FA8 D060  30        movb @BET1,rx                   ; LDX BET1          ; Fetch |beta| from BET1, the pitch angle
     3FAA 002B     
13418               
13419                      .eor @BET2+1                    ; EOR BET2+1        ; Give A the opposite sign to x * beta
     **** ****     > EOR
0001 3FAC D1A0  30        movb @BET2+1,rtmp
     3FAE 008B     
0002 3FB0 2806  18        xor  rtmp,ra
                   < elite.a99
13420               
13421 3FB2 0206  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     3FB4 41F4     
13422 3FB6 06A0  32        bl   @jsr                       ;
     3FB8 FF10     
13423                                                                          ;
13424                                                                          ; (A P) = X * A
13425                                                                          ; = -beta * x
13426               
13427 3FBA 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     3FBC 44BA     
13428 3FBE 06A0  32        bl   @jsr                       ;
     3FC0 FF10     
13429                                                                          ;
13430                                                                          ; (A X) = (A P) + (S R)
13431                                                                          ; = -beta * x + y
13432               
13433 3FC2 D801  30        movb rx,@YY                     ; STX YY            ; Set YY(1 0) = (A X), which gives us result 4 above:
     3FC4 0026     
13434 3FC6 D800  30        movb ra,@YY+1                   ; STA YY+1          ;
     3FC8 0027     
13435                                                                          ; y = y - beta * x
13436               
13437 3FCA D060  30        movb @ALP1,rx                   ; LDX ALP1          ; Set X = |alpha| from ALP2, the roll angle
     3FCC 0087     
13438               
13439                      .eor @ALP2                      ; EOR ALP2          ; Give A the correct sign of A * alpha, i.e. y_hi *
     **** ****     > EOR
0001 3FCE D1A0  30        movb @ALP2,rtmp
     3FD0 0088     
0002 3FD2 2806  18        xor  rtmp,ra
                   < elite.a99
13440                                                                          ; alpha
13441               
13442 3FD4 0206  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     3FD6 41F4     
13443 3FD8 06A0  32        bl   @jsr                       ;
     3FDA FF10     
13444                                                                          ;
13445                                                                          ; (A P) = X * A
13446                                                                          ; = alpha * y
13447               
13448 3FDC D800  30        movb ra,@Q                      ; STA Q             ; Set Q = high byte of alpha * y
     3FDE 0090     
13449               
13450 3FE0 D020  30        movb @XX,ra                     ; LDA XX            ; Set (S R) = XX(1 0)
     3FE2 0024     
13451 3FE4 D800  30        movb ra,@R                      ; STA R             ; = x
     3FE6 0091     
13452 3FE8 D020  30        movb @XX+1,ra                   ; LDA XX+1          ;
     3FEA 0025     
13453 3FEC D800  30        movb ra,@S                      ; STA S             ; and set A = y_hi at the same time
     3FEE 0092     
13454               
13455                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A = -x_hi
     **** ****     > EOI
0001 3FF0 0206  20        li   rtmp,(>80*256)
     3FF2 8000     
0002 3FF4 2806  18        xor  rtmp,ra
                   < elite.a99
13456               
13457 3FF6 0206  20        li   rtmp,MAD                   ; JSR MAD           ; Call MAD to calculate:
     3FF8 44B2     
13458 3FFA 06A0  32        bl   @jsr                       ;
     3FFC FF10     
13459                                                                          ;
13460                                                                          ; (A X) = Q * A + (S R)
13461                                                                          ; = alpha * y * -x + x
13462               
13463 3FFE D800  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     4000 0025     
13464               
13465 4002 D001  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
13466 4004 D880  38        movb ra,@SXL(ry)                ; STA SXL,Y
     4006 035F     
13467               
13468                                                                          ; So (XX+1 x_lo) now contains result 5 above:
13469                                                                          ;
13470                                                                          ; x = x - alpha * x * y
13471               
13472 4008 D020  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0)
     400A 0026     
13473 400C D800  30        movb ra,@R                      ; STA R             ; = y
     400E 0091     
13474 4010 D020  30        movb @YY+1,ra                   ; LDA YY+1          ;
     4012 0027     
13475 4014 D800  30        movb ra,@S                      ; STA S             ; and set A = y_hi at the same time
     4016 0092     
13476               
13477 4018 0206  20        li   rtmp,MAD                   ; JSR MAD           ; Call MAD to calculate:
     401A 44B2     
13478 401C 06A0  32        bl   @jsr                       ;
     401E FF10     
13479                                                                          ;
13480                                                                          ; (A X) = Q * A + (S R)
13481                                                                          ; = alpha * y * y_hi + y
13482               
13483 4020 D800  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     4022 0092     
13484 4024 D801  30        movb rx,@R                      ; STX R             ; = y + alpha * y * y
     4026 0091     
13485               
13486 4028 0200  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     402A 0000     
13487 402C D800  30        movb ra,@P                      ; STA P
     402E 001B     
13488               
13489 4030 D020  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set A = alpha, so:
     4032 009E     
13490                                                                          ;
13491                                                                          ; (A P) = (alpha 0)
13492                                                                          ; = alpha / 256
13493               
13494 4034 0206  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     4036 275A     
13495 4038 06A0  32        bl   @jsr                       ;
     403A FF10     
13496                                                                          ;
13497                                                                          ; (YY+1 y_lo) = (A P) + (S R)
13498                                                                          ; = alpha * 256 + y + alpha * y * y
13499                                                                          ;
13500                                                                          ; i.e. y = y + alpha / 256 + alpha * y^2, which is
13501                                                                          ; result 6 above
13502                                                                          ;
13503                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
13504                                                                          ; ZZ, which will remove the old stardust particle, as we
13505                                                                          ; set X1, Y1 and ZZ to the original values for this
13506                                                                          ; particle during the calculations above
13507               
13508                                                                          ; We now have our newly moved stardust particle at
13509                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
13510                                                                          ; and distance z_hi, so we draw it if it's still on
13511                                                                          ; screen, otherwise we recycle it as a new bit of
13512                                                                          ; stardust and draw that
13513               
13514 403C D020  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     403E 0025     
13515 4040 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; the new x-coordinate is in (x_hi x_lo) and the high
     4042 034C     
13516 4044 D800  30        movb ra,@X1                     ; STA X1            ; byte is in X1
     4046 0031     
13517               
13518 4048 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; If |x_hi| >= 116 then jump to KILL2 to recycle this
     404A 7F00     
13519 404C 0280  22        ci   ra,>74*256                 ; CMP #116          ; particle, as it's gone off the side of the screen,
     404E 7400     
13520 4050 1834  14        joc  KILL2                      ; BCS KILL2         ; and rejoin at STC2 with the new particle
13521               
13522 4052 D020  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     4054 0027     
13523 4056 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     4058 0EC2     
13524 405A D800  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     405C 0032     
13525               
13526 405E 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 116 then jump to ST5 to recycle this
     4060 7F00     
13527 4062 0280  22        ci   ra,>74*256                 ; CMP #116          ; particle, as it's gone off the top or bottom of the
     4064 7400     
13528 4066 183A  14        joc  ST5                        ; BCS ST5           ; screen, and rejoin at STC2 with the new particle
13529               
13530               STC2:
13531 4068 0206  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     406A 276C     
13532 406C 06A0  32        bl   @jsr                       ;
     406E FF10     
13533                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
13534                                                                          ; with distance z_hi
13535               
13536 4070 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
13537                                                                          ; stardust particle
13538               
13539 4072 1302  14        jeq  ST2                        ; BEQ ST2           ; If we have just done the last particle, skip the next
13540                                                                          ; instruction to return from the subroutine
13541               
13542 4074 0460  28        b    @STL2                      ; JMP STL2          ; We have more stardust to process, so jump back up to
     4076 3F2A     
13543                                                                          ; STL2 for the next particle
13544               
13545                                                                          ; Fall through into ST2 to restore the signs of the
13546                                                                          ; following if this is the right view: ALPHA, ALP2,
13547                                                                          ; ALP2+1, BET2 and BET2+1
13548               
13549               ST2:
13550 4078 D020  30        movb @ALPHA,ra                  ; LDA ALPHA         ; If this is the right view, flip the sign of ALPHA
     407A 009E     
13551                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 407C D1A0  30        movb @RAT,rtmp
     407E 00AA     
0002 4080 2806  18        xor  rtmp,ra
                   < elite.a99
13552 4082 D800  30        movb ra,@ALPHA                  ; STA ALPHA
     4084 009E     
13553               
13554 4086 D020  30        movb @ALP2,ra                   ; LDA ALP2          ; If this is the right view, flip the sign of ALP2
     4088 0088     
13555                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 408A D1A0  30        movb @RAT,rtmp
     408C 00AA     
0002 408E 2806  18        xor  rtmp,ra
                   < elite.a99
13556 4090 D800  30        movb ra,@ALP2                   ; STA ALP2
     4092 0088     
13557               
13558                      .eoi (>80*256)                  ; EOR #%10000000    ; If this is the right view, flip the sign of ALP2+1
     **** ****     > EOI
0001 4094 0206  20        li   rtmp,(>80*256)
     4096 8000     
0002 4098 2806  18        xor  rtmp,ra
                   < elite.a99
13559 409A D800  30        movb ra,@ALP2+1                 ; STA ALP2+1
     409C 0089     
13560               
13561 409E D020  30        movb @BET2,ra                   ; LDA BET2          ; If this is the right view, flip the sign of BET2
     40A0 008A     
13562                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 40A2 D1A0  30        movb @RAT,rtmp
     40A4 00AA     
0002 40A6 2806  18        xor  rtmp,ra
                   < elite.a99
13563 40A8 D800  30        movb ra,@BET2                   ; STA BET2
     40AA 008A     
13564               
13565                      .eoi (>80*256)                  ; EOR #%10000000    ; If this is the right view, flip the sign of BET2+1
     **** ****     > EOI
0001 40AC 0206  20        li   rtmp,(>80*256)
     40AE 8000     
0002 40B0 2806  18        xor  rtmp,ra
                   < elite.a99
13566 40B2 D800  30        movb ra,@BET2+1                 ; STA BET2+1
     40B4 008B     
13567               
13568 40B6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     40B8 FF1C     
13569               
13570               KILL2:
13571 40BA 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     40BC C07C     
13572 40BE 06A0  32        bl   @jsr                       ;
     40C0 FF10     
13573               
13574 40C2 D800  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to random numbers, so the particle
     40C4 0032     
13575 40C6 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; starts anywhere along the y-axis
     40C8 0EC2     
13576               
13577 40CA 0200  20        li   ra,>73*256                 ; LDA #115          ; Make sure A is at least 115 and has the sign in RAT
     40CC 7300     
13578 40CE F020  30        socb @RAT,ra                    ; ORA RAT
     40D0 00AA     
13579               
13580 40D2 D800  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to A, so this particle starts on the
     40D4 0031     
13581 40D6 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; correct edge of the screen for new particles
     40D8 034C     
13582               
13583 40DA 1610  14        jne  STF1                       ; BNE STF1          ; Jump down to STF1 to set the z-coordinate (this BNE is
13584                                                                          ; effectively a JMP as A will never be zero)
13585               
13586               ST5:
13587 40DC 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     40DE C07C     
13588 40E0 06A0  32        bl   @jsr                       ;
     40E2 FF10     
13589               
13590 40E4 D800  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to random numbers, so the particle
     40E6 0031     
13591 40E8 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; starts anywhere along the x-axis
     40EA 034C     
13592               
13593 40EC 0200  20        li   ra,>6e*256                 ; LDA #110          ; Make sure A is at least 110 and has the sign in AL2+1,
     40EE 6E00     
13594 40F0 F020  30        socb @ALP2+1,ra                 ; ORA ALP2+1        ; the flipped sign of the roll angle alpha
     40F2 0089     
13595               
13596 40F4 D800  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to A, so the particle starts at the
     40F6 0032     
13597 40F8 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; top or bottom edge, depending on the current roll
     40FA 0EC2     
13598                                                                          ; angle alpha
13599               
13600               STF1:
13601 40FC 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     40FE C07C     
13602 4100 06A0  32        bl   @jsr                       ;
     4102 FF10     
13603               
13604 4104 0260  22        ori  ra,>08*256                 ; ORA #8            ; Make sure A is at least 8 and store it in z_hi and
     4106 0800     
13605 4108 D800  30        movb ra,@ZZ                     ; STA ZZ            ; ZZ, so the new particle starts at any distance from
     410A 0097     
13606 410C D880  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; us, but not too close
     410E 0EE8     
13607               
13608 4110 16AB  14        jne  STC2                       ; BNE STC2          ; Jump up to STC2 to draw this new particle (this BNE is
13609                                                                          ; effectively a JMP as A will never be zero)
13610               
13611               * ******************************************************************************
13612               *
13613               * Name: SNE
13614               * Type: Variable
13615               * Category: Maths (Geometry)
13616               * Summary: Sine/cosine table
13617               * Deep dive: The sine, cosine and arctan tables
13618               * Drawing circles
13619               * Drawing ellipses
13620               *
13621               * ------------------------------------------------------------------------------
13622               *
13623               * This lookup table contains sine values for the first half of a circle, from 0
13624               * to 180 degrees (0 to PI radians). In terms of circle or ellipse line segments,
13625               * there are 64 segments in a circle, so this contains sine values for segments
13626               * 0 to 31.
13627               *
13628               * In terms of segments, to calculate the sine of the angle at segment x, we look
13629               * up the value in SNE + x, and to calculate the cosine of the angle we look up
13630               * the value in SNE + ((x + 16) mod 32).
13631               *
13632               * In terms of radians, to calculate the following:
13633               *
13634               * sin(theta) * 256
13635               *
13636               * where theta is in radians, we look up the value in:
13637               *
13638               * SNE + (theta * 10)
13639               *
13640               * To calculate the following:
13641               *
13642               * cos(theta) * 256
13643               *
13644               * where theta is in radians, look up the value in:
13645               *
13646               * SNE + ((theta * 10) + 16) mod 32
13647               *
13648               * Theta must be between 0 and 3.1 radians, so theta * 10 is between 0 and 31.
13649               *
13650               * ******************************************************************************
13651               
13652               SNE:
13653                      ; FOR I%, 0, 31
13654               
13655                      ; N = ABS(SIN((I% / 64) * 2 * PI)) ;
13656               
13657                      ; IF N >= 1                     ;
13658                      ; B% = 255                      ;
13659                      ; ELSE                          ;
13660                      ; B% = INT(256 * N + 0.5)       ;
13661                      ; ENDIF                         ;
13662               
13663                      ; EQUB B%                       ;
13664               
13665                      ; NEXT
13666               
13667 4112 00              byte >00
13668 4113   19            byte >19
13669 4114 32              byte >32
13670 4115   4A            byte >4a
13671 4116 62              byte >62
13672 4117   79            byte >79
13673 4118 8E              byte >8e
13674 4119   A2            byte >a2
13675 411A B5              byte >b5
13676 411B   C6            byte >c6
13677 411C D5              byte >d5
13678 411D   E2            byte >e2
13679 411E ED              byte >ed
13680 411F   F5            byte >f5
13681 4120 FB              byte >fb
13682 4121   FF            byte >ff
13683 4122 FF              byte >ff
13684 4123   FF            byte >ff
13685 4124 FB              byte >fb
13686 4125   F5            byte >f5
13687 4126 ED              byte >ed
13688 4127   E2            byte >e2
13689 4128 D5              byte >d5
13690 4129   C6            byte >c6
13691 412A B5              byte >b5
13692 412B   A2            byte >a2
13693 412C 8E              byte >8e
13694 412D   79            byte >79
13695 412E 62              byte >62
13696 412F   4A            byte >4a
13697 4130 32              byte >32
13698 4131   19            byte >19
13699               
13700               * ******************************************************************************
13701               *
13702               * Name: MU5
13703               * Type: Subroutine
13704               * Category: Maths (Arithmetic)
13705               * Summary: Set K(3 2 1 0) = (A A A A) and clear the C flag
13706               *
13707               * ------------------------------------------------------------------------------
13708               *
13709               * In practice this is only called via a BEQ following an AND instruction, in
13710               * which case A = 0, so this routine effectively does this:
13711               *
13712               * K(3 2 1 0) = 0
13713               *
13714               * ******************************************************************************
13715               
13716               MU5:
13717 4132 D800  30        movb ra,@K                      ; STA K             ; Set K(3 2 1 0) to (A A A A)
     4134 003D     
13718 4136 D800  30        movb ra,@K+1                    ; STA K+1
     4138 003E     
13719 413A D800  30        movb ra,@K+2                    ; STA K+2
     413C 003F     
13720 413E D800  30        movb ra,@K+3                    ; STA K+3
     4140 0040     
13721               
13722                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 4142 0A13  18        sla  rzero,1
                   < elite.a99
13723               
13724 4144 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4146 FF1C     
13725               
13726               * ******************************************************************************
13727               *
13728               * Name: MULT3
13729               * Type: Subroutine
13730               * Category: Maths (Arithmetic)
13731               * Summary: Calculate K(3 2 1 0) = (A P+1 P) * Q
13732               * Deep dive: Shift-and-add multiplication
13733               *
13734               * ------------------------------------------------------------------------------
13735               *
13736               * Calculate the following multiplication between a signed 24-bit number and a
13737               * signed 8-bit number, returning the result as a signed 32-bit number:
13738               *
13739               * K(3 2 1 0) = (A P+1 P) * Q
13740               *
13741               * The algorithm is the same shift-and-add algorithm as in routine MULT1, but
13742               * extended to cope with more bits.
13743               *
13744               * ------------------------------------------------------------------------------
13745               *
13746               * Returns:
13747               *
13748               * C flag              The C flag is cleared
13749               *
13750               * ******************************************************************************
13751               
13752               MULT3:
13753 4148 D800  30        movb ra,@R                      ; STA R             ; Store the high byte of (A P+1 P) in R
     414A 0091     
13754               
13755 414C 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Set K+2 to |A|, the high byte of K(2 1 0)
     414E 7F00     
13756 4150 D800  30        movb ra,@K+2                    ; STA K+2
     4152 003F     
13757               
13758 4154 D020  30        movb @Q,ra                      ; LDA Q             ; Set A to bits 0-6 of Q, so A = |Q|
     4156 0090     
13759 4158 0240  22        andi ra,>7f*256                 ; AND #%01111111
     415A 7F00     
13760               
13761 415C 13EA  14        jeq  MU5                        ; BEQ MU5           ; If |Q| = 0, jump to MU5 to set K(3 2 1 0) to 0,
13762                                                                          ; returning from the subroutine using a tail call
13763               
13764                      .sec                            ; SEC               ; Set T = |Q| - 1
     **** ****     > SEC
0001 415E 0A15  18        sla  rmone,1
                   < elite.a99
13765                      .sbi (>01*256)                  ; SBC #1
     **** ****     > SBI
0001 4160 1801  14        joc  !
0002 4162 7004  18        sb   rone,ra
0003               !:
0004 4164 0220  22        ai   ra,-(>01*256)
     4166 FF00     
                   < elite.a99
13766 4168 D800  30        movb ra,@T                      ; STA T
     416A 00D1     
13767               
13768                                                                          ; We now use the same shift-and-add algorithm as MULT1
13769                                                                          ; to calculate the following:
13770                                                                          ;
13771                                                                          ; K(2 1 0) = K(2 1 0) * |Q|
13772                                                                          ;
13773                                                                          ; so we start with the first shift right, in which we
13774                                                                          ; take (K+2 P+1 P) and shift it right, storing the
13775                                                                          ; result in K(2 1 0), ready for the multiplication loop
13776                                                                          ; (so the multiplication loop actually calculates
13777                                                                          ; (|A| P+1 P) * |Q|, as the following sets K(2 1 0) to
13778                                                                          ; (|A| P+1 P) shifted right)
13779               
13780 416C D020  30        movb @P+1,ra                    ; LDA P+1           ; Set A = P+1
     416E 001C     
13781               
13782                      .lsr @K+2                       ; LSR K+2           ; Shift the high byte in K+2 to the right
     **** ****     > LSR
0001 4170 D1A0  30        movb @K+2,rtmp
     4172 003F     
0002 4174 0916  18        srl  rtmp,1
0003 4176 D806  30        movb rtmp,@K+2
     4178 003F     
                   < elite.a99
13783               
13784 417A 06A0  32        bl   @rora                      ; ROR A             ; Shift the middle byte in A to the right and store in
     417C FF4A     
13785 417E D800  30        movb ra,@K+1                    ; STA K+1           ; K+1 (so K+1 contains P+1 shifted right)
     4180 003E     
13786               
13787 4182 D020  30        movb @P,ra                      ; LDA P             ; Shift the middle byte in P to the right and store in
     4184 001B     
13788 4186 06A0  32        bl   @rora                      ; ROR A             ; K, so K(2 1 0) now contains (|A| P+1 P) shifted right
     4188 FF4A     
13789 418A D800  30        movb ra,@K                      ; STA K
     418C 003D     
13790               
13791                                                                          ; We now use the same shift-and-add algorithm as MULT1
13792                                                                          ; to calculate the following:
13793                                                                          ;
13794                                                                          ; K(2 1 0) = K(2 1 0) * |Q|
13795               
13796 418E 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4190 0000     
13797               
13798 4192 0201  20        li   rx,>18*256                 ; LDX #24           ; Set up a counter in X to count the 24 bits in K(2 1 0)
     4194 1800     
13799               
13800               MUL2:
13801 4196 1704  14        jnc  B38                        ; BCC B38           ; If C (i.e. the next bit from K) is set, do the
13802                      .adc @T,ra                      ; ADC T             ; addition for this bit of K:
     **** ****     > ADC
0001 4198 1701  14        jnc  !
0002 419A B004  18        ab   rone,ra
0003               !:
0004 419C B020  30        ab   @T,ra
     419E 00D1     
                   < elite.a99
13803                                                                          ;
13804                                                                          ; A = A + T + C
13805                                                                          ; = A + |Q| - 1 + 1
13806                                                                          ; = A + |Q|
13807               
13808               B38:
13809 41A0 06A0  32        bl   @rora                      ; ROR A             ; Shift A right by one place to catch the next digit
     41A2 FF4A     
13810 41A4 0208  20        li   rarg1,K+2                  ; ROR K+2           ; next digit of our result in the left end of K(2 1 0),
     41A6 003F     
13811 41A8 06A0  32        bl   @ror                       ;
     41AA FF62     
13812 41AC 0208  20        li   rarg1,K+1                  ; ROR K+1           ; while also shifting K(2 1 0) right to fetch the next
     41AE 003E     
13813 41B0 06A0  32        bl   @ror                       ;
     41B2 FF62     
13814 41B4 0208  20        li   rarg1,K                    ; ROR K             ; bit for the calculation into the C flag
     41B6 003D     
13815 41B8 06A0  32        bl   @ror                       ;
     41BA FF62     
13816                                                                          ;
13817                                                                          ; On the last iteration of this loop, the bit falling
13818                                                                          ; off the end of K will be bit 0 of the original A, as
13819                                                                          ; we did one shift before the loop and we are doing 24
13820                                                                          ; iterations. We set A to 0 before looping, so this
13821                                                                          ; means the loop exits with the C flag clear
13822               
13823 41BC 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
13824               
13825 41BE 16EB  14        jne  MUL2                       ; BNE MUL2          ; Loop back for the next bit until K(2 1 0) has been
13826                                                                          ; rotated all the way
13827               
13828                                                                          ; The result (|A| P+1 P) * |Q| is now in (A K+2 K+1 K),
13829                                                                          ; but it is positive and doesn't have the correct sign
13830                                                                          ; of the final result yet
13831               
13832 41C0 D800  30        movb ra,@T                      ; STA T             ; Save the high byte of the result into T
     41C2 00D1     
13833               
13834 41C4 D020  30        movb @R,ra                      ; LDA R             ; Fetch the sign byte from the original (A P+1 P)
     41C6 0091     
13835                                                                          ; argument that we stored in R
13836               
13837                      .eor @Q                         ; EOR Q             ; EOR with Q so the sign bit is the same as that of
     **** ****     > EOR
0001 41C8 D1A0  30        movb @Q,rtmp
     41CA 0090     
0002 41CC 2806  18        xor  rtmp,ra
                   < elite.a99
13838                                                                          ; (A P+1 P) * Q
13839               
13840 41CE 0240  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign bit
     41D0 8000     
13841               
13842 41D2 F020  30        socb @T,ra                      ; ORA T             ; Apply this to the high byte of the result in T, so
     41D4 00D1     
13843                                                                          ; that A now has the correct sign for the result, and
13844                                                                          ; (A K+2 K+1 K) therefore contains the correctly signed
13845                                                                          ; result
13846               
13847 41D6 D800  30        movb ra,@K+3                    ; STA K+3           ; Store A in K+3, so K(3 2 1 0) now contains the result
     41D8 0040     
13848               
13849 41DA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     41DC FF1C     
13850               
13851               * ******************************************************************************
13852               *
13853               * Name: MLS2
13854               * Type: Subroutine
13855               * Category: Maths (Arithmetic)
13856               * Summary: Calculate (S R) = XX(1 0) and (A P) = A * ALP1
13857               *
13858               * ------------------------------------------------------------------------------
13859               *
13860               * Calculate the following:
13861               *
13862               * (S R) = XX(1 0)
13863               *
13864               * (A P) = A * ALP1
13865               *
13866               * where ALP1 is the magnitude of the current roll angle alpha, in the range
13867               * 0-31.
13868               *
13869               * ******************************************************************************
13870               
13871               MLS2:
13872 41DE D060  30        movb @XX,rx                     ; LDX XX            ; Set (S R) = XX(1 0), starting with the low bytes
     41E0 0024     
13873 41E2 D801  30        movb rx,@R                      ; STX R
     41E4 0091     
13874               
13875 41E6 D060  30        movb @XX+1,rx                   ; LDX XX+1          ; And then doing the high bytes
     41E8 0025     
13876 41EA D801  30        movb rx,@S                      ; STX S
     41EC 0092     
13877               
13878                                                                          ; Fall through into MLS1 to calculate (A P) = A * ALP1
13879               
13880               * ******************************************************************************
13881               *
13882               * Name: MLS1
13883               * Type: Subroutine
13884               * Category: Maths (Arithmetic)
13885               * Summary: Calculate (A P) = ALP1 * A
13886               *
13887               * ------------------------------------------------------------------------------
13888               *
13889               * Calculate the following:
13890               *
13891               * (A P) = ALP1 * A
13892               *
13893               * where ALP1 is the magnitude of the current roll angle alpha, in the range
13894               * 0-31.
13895               *
13896               * This routine uses an unrolled version of MU11. MU11 calculates P * X, so we
13897               * use the same algorithm but with P set to ALP1 and X set to A. The unrolled
13898               * version here can skip the bit tests for bits 5-7 of P as we know P < 32, so
13899               * only 5 shifts with bit tests are needed (for bits 0-4), while the other 3
13900               * shifts can be done without a test (for bits 5-7).
13901               *
13902               * ------------------------------------------------------------------------------
13903               *
13904               * Other entry points:
13905               *
13906               * MULTS-2             Calculate (A P) = X * A
13907               *
13908               * ******************************************************************************
13909               
13910               MLS1:
13911 41EE D060  30        movb @ALP1,rx                   ; LDX ALP1          ; Set P to the roll angle alpha magnitude in ALP1
     41F0 0087     
13912 41F2 D801  30        movb rx,@P                      ; STX P             ; (0-31), so now we calculate P * A
     41F4 001B     
13913               
13914               MULTS:
13915 41F6 D040  18        movb ra,rx                      ; TAX               ; Set X = A, so now we can calculate P * X instead of
13916                                                                          ; P * A to get our result, and we can use the algorithm
13917                                                                          ; from MU11 to do that, just unrolled (as MU11 returns
13918                                                                          ; P * X)
13919               
13920 41F8 0240  22        andi ra,>80*256                 ; AND #%10000000    ; Set T to the sign bit of A
     41FA 8000     
13921 41FC D800  30        movb ra,@T                      ; STA T
     41FE 00D1     
13922               
13923 4200 D001  18        movb rx,ra                      ; TXA               ; Set A = |A|
13924 4202 0240  22        andi ra,>7f*256                 ; AND #127
     4204 7F00     
13925               
13926 4206 1602  14        jne  FIX003                     ; BNE FIX003        ; If A = 0, jump to MU6 to set P(1 0) = 0 and return
13927                                                                          ; from the subroutine using a tail call
13928 4208 0460  28        b    @MU6                       ; JMP MU6
     420A 431A     
13929               FIX003:
13930 420C D040  18        movb ra,rx                      ; TAX               ; Set T1 = X - 1
13931 420E 7044  18        sb   rone,rx                    ; DEX               ;
13932 4210 D801  30        movb rx,@T1                     ; STX T1            ; We subtract 1 as the C flag will be set when we want
     4212 0006     
13933                                                                          ; to do an addition in the loop below
13934               
13935 4214 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4216 0000     
13936               
13937                      .lsr @P                         ; LSR P             ; Set P = P >> 1
     **** ****     > LSR
0001 4218 D1A0  30        movb @P,rtmp
     421A 001B     
0002 421C 0916  18        srl  rtmp,1
0003 421E D806  30        movb rtmp,@P
     4220 001B     
                   < elite.a99
13938                                                                          ; and C flag = bit 0 of P
13939               
13940                                                                          ; We are now going to work our way through the bits of
13941                                                                          ; P, and do a shift-add for any bits that are set,
13942                                                                          ; keeping the running total in A, but instead of using a
13943                                                                          ; loop like MU11, we just unroll it, starting with bit 0
13944               
13945 4222 1704  14        jnc  B39                        ; BCC B39           ; If C (i.e. the next bit from P) is set, do the
13946                      .adc @T1,ra                     ; ADC T1            ; addition for this bit of P:
     **** ****     > ADC
0001 4224 1701  14        jnc  !
0002 4226 B004  18        ab   rone,ra
0003               !:
0004 4228 B020  30        ab   @T1,ra
     422A 0006     
                   < elite.a99
13947                                                                          ;
13948                                                                          ; A = A + T1 + C
13949                                                                          ; = A + X - 1 + 1
13950                                                                          ; = A + X
13951               
13952               B39:
13953 422C 06A0  32        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result,
     422E FF4A     
13954                                                                          ; which the next ROR sticks into the left end of P while
13955                                                                          ; also extracting the next bit of P
13956               
13957 4230 0208  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     4232 001B     
13958 4234 06A0  32        bl   @ror                       ;
     4236 FF62     
13959                                                                          ; the start of P, and shift P right to fetch the next
13960                                                                          ; bit for the calculation into the C flag
13961               
13962 4238 1704  14        jnc  B40                        ; BCC B40           ; Repeat the shift-and-add loop for bit 1
13963                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 423A 1701  14        jnc  !
0002 423C B004  18        ab   rone,ra
0003               !:
0004 423E B020  30        ab   @T1,ra
     4240 0006     
                   < elite.a99
13964               B40:
13965 4242 06A0  32        bl   @rora                      ; ROR A
     4244 FF4A     
13966 4246 0208  20        li   rarg1,P                    ; ROR P
     4248 001B     
13967 424A 06A0  32        bl   @ror                       ;
     424C FF62     
13968               
13969 424E 1704  14        jnc  B41                        ; BCC B41           ; Repeat the shift-and-add loop for bit 2
13970                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 4250 1701  14        jnc  !
0002 4252 B004  18        ab   rone,ra
0003               !:
0004 4254 B020  30        ab   @T1,ra
     4256 0006     
                   < elite.a99
13971               B41:
13972 4258 06A0  32        bl   @rora                      ; ROR A
     425A FF4A     
13973 425C 0208  20        li   rarg1,P                    ; ROR P
     425E 001B     
13974 4260 06A0  32        bl   @ror                       ;
     4262 FF62     
13975               
13976 4264 1704  14        jnc  B42                        ; BCC B42           ; Repeat the shift-and-add loop for bit 3
13977                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 4266 1701  14        jnc  !
0002 4268 B004  18        ab   rone,ra
0003               !:
0004 426A B020  30        ab   @T1,ra
     426C 0006     
                   < elite.a99
13978               B42:
13979 426E 06A0  32        bl   @rora                      ; ROR A
     4270 FF4A     
13980 4272 0208  20        li   rarg1,P                    ; ROR P
     4274 001B     
13981 4276 06A0  32        bl   @ror                       ;
     4278 FF62     
13982               
13983 427A 1704  14        jnc  B43                        ; BCC B43           ; Repeat the shift-and-add loop for bit 4
13984                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 427C 1701  14        jnc  !
0002 427E B004  18        ab   rone,ra
0003               !:
0004 4280 B020  30        ab   @T1,ra
     4282 0006     
                   < elite.a99
13985               B43:
13986 4284 06A0  32        bl   @rora                      ; ROR A
     4286 FF4A     
13987 4288 0208  20        li   rarg1,P                    ; ROR P
     428A 001B     
13988 428C 06A0  32        bl   @ror                       ;
     428E FF62     
13989               
13990 4290 0910  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 5
13991 4292 0208  20        li   rarg1,P                    ; ROR P
     4294 001B     
13992 4296 06A0  32        bl   @ror                       ;
     4298 FF62     
13993               
13994 429A 0910  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 6
13995 429C 0208  20        li   rarg1,P                    ; ROR P
     429E 001B     
13996 42A0 06A0  32        bl   @ror                       ;
     42A2 FF62     
13997               
13998 42A4 0910  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 7
13999 42A6 0208  20        li   rarg1,P                    ; ROR P
     42A8 001B     
14000 42AA 06A0  32        bl   @ror                       ;
     42AC FF62     
14001               
14002 42AE F020  30        socb @T,ra                      ; ORA T             ; Give A the sign bit of the original argument A that
     42B0 00D1     
14003                                                                          ; we put into T above
14004               
14005 42B2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     42B4 FF1C     
14006               
14007               * ******************************************************************************
14008               *
14009               * Name: SQUA
14010               * Type: Subroutine
14011               * Category: Maths (Arithmetic)
14012               * Summary: Clear bit 7 of A and calculate (A P) = A * A
14013               *
14014               * ------------------------------------------------------------------------------
14015               *
14016               * Do the following multiplication of unsigned 8-bit numbers, after first
14017               * clearing bit 7 of A:
14018               *
14019               * (A P) = A * A
14020               *
14021               * ******************************************************************************
14022               
14023               SQUA:
14024 42B6 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear bit 7 of A and fall through into SQUA2 to set
     42B8 7F00     
14025                                                                          ; (A P) = A * A
14026               
14027               * ******************************************************************************
14028               *
14029               * Name: SQUA2
14030               * Type: Subroutine
14031               * Category: Maths (Arithmetic)
14032               * Summary: Calculate (A P) = A * A
14033               *
14034               * ------------------------------------------------------------------------------
14035               *
14036               * Do the following multiplication of unsigned 8-bit numbers:
14037               *
14038               * (A P) = A * A
14039               *
14040               * ******************************************************************************
14041               
14042               SQUA2:
14043 42BA D800  30        movb ra,@P                      ; STA P             ; Copy A into P and X
     42BC 001B     
14044 42BE D040  18        movb ra,rx                      ; TAX
14045               
14046 42C0 1611  14        jne  MU11                       ; BNE MU11          ; If X = 0 fall through into MU1 to return a 0,
14047                                                                          ; otherwise jump to MU11 to return P * X
14048               
14049               * ******************************************************************************
14050               *
14051               * Name: MU1
14052               * Type: Subroutine
14053               * Category: Maths (Arithmetic)
14054               * Summary: Copy X into P and A, and clear the C flag
14055               *
14056               * ------------------------------------------------------------------------------
14057               *
14058               * Used to return a 0 result quickly from MULTU below.
14059               *
14060               * ******************************************************************************
14061               
14062               MU1:
14063                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 42C2 0A13  18        sla  rzero,1
                   < elite.a99
14064               
14065 42C4 D801  30        movb rx,@P                      ; STX P             ; Copy X into P and A
     42C6 001B     
14066 42C8 D001  18        movb rx,ra                      ; TXA
14067               
14068 42CA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     42CC FF1C     
14069               
14070               * ******************************************************************************
14071               *
14072               * Name: MLU1
14073               * Type: Subroutine
14074               * Category: Maths (Arithmetic)
14075               * Summary: Calculate Y1 = y_hi and (A P) = |y_hi| * Q for Y-th stardust
14076               *
14077               * ------------------------------------------------------------------------------
14078               *
14079               * Do the following assignment, and multiply the Y-th stardust particle's
14080               * y-coordinate with an unsigned number Q:
14081               *
14082               * Y1 = y_hi
14083               *
14084               * (A P) = |y_hi| * Q
14085               *
14086               * ******************************************************************************
14087               
14088               MLU1:
14089 42CE D022  34        movb @SY(ry),ra                 ; LDA SY,Y          ; Set Y1 the Y-th byte of SY
     42D0 0EC2     
14090 42D2 D800  30        movb ra,@Y1                     ; STA Y1
     42D4 0032     
14091               
14092                                                                          ; Fall through into MLU2 to calculate:
14093                                                                          ;
14094                                                                          ; (A P) = |A| * Q
14095               
14096               * ******************************************************************************
14097               *
14098               * Name: MLU2
14099               * Type: Subroutine
14100               * Category: Maths (Arithmetic)
14101               * Summary: Calculate (A P) = |A| * Q
14102               *
14103               * ------------------------------------------------------------------------------
14104               *
14105               * Do the following multiplication of a sign-magnitude 8-bit number P with an
14106               * unsigned number Q:
14107               *
14108               * (A P) = |A| * Q
14109               *
14110               * ******************************************************************************
14111               
14112               MLU2:
14113 42D6 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit in P, so P = |A|
     42D8 7F00     
14114 42DA D800  30        movb ra,@P                      ; STA P
     42DC 001B     
14115               
14116                                                                          ; Fall through into MULTU to calculate:
14117                                                                          ;
14118                                                                          ; (A P) = P * Q
14119                                                                          ; = |A| * Q
14120               
14121               * ******************************************************************************
14122               *
14123               * Name: MULTU
14124               * Type: Subroutine
14125               * Category: Maths (Arithmetic)
14126               * Summary: Calculate (A P) = P * Q
14127               *
14128               * ------------------------------------------------------------------------------
14129               *
14130               * Do the following multiplication of unsigned 8-bit numbers:
14131               *
14132               * (A P) = P * Q
14133               *
14134               * ******************************************************************************
14135               
14136               MULTU:
14137 42DE D060  30        movb @Q,rx                      ; LDX Q             ; Set X = Q
     42E0 0090     
14138               
14139 42E2 13EF  14        jeq  MU1                        ; BEQ MU1           ; If X = Q = 0, jump to MU1 to copy X into P and A,
14140                                                                          ; clear the C flag and return from the subroutine using
14141                                                                          ; a tail call
14142               
14143                                                                          ; Otherwise fall through into MU11 to set (A P) = P * X
14144               
14145               * ******************************************************************************
14146               *
14147               * Name: MU11
14148               * Type: Subroutine
14149               * Category: Maths (Arithmetic)
14150               * Summary: Calculate (A P) = P * X
14151               * Deep dive: Shift-and-add multiplication
14152               *
14153               * ------------------------------------------------------------------------------
14154               *
14155               * Do the following multiplication of two unsigned 8-bit numbers:
14156               *
14157               * (A P) = P * X
14158               *
14159               * This uses the same shift-and-add approach as MULT1, but it's simpler as we
14160               * are dealing with unsigned numbers in P and X. See the deep dive on
14161               * "Shift-and-add multiplication" for a discussion of how this algorithm works.
14162               *
14163               * ******************************************************************************
14164               
14165               MU11:
14166 42E4 7044  18        sb   rone,rx                    ; DEX               ; Set T = X - 1
14167 42E6 D801  30        movb rx,@T                      ; STX T             ;
     42E8 00D1     
14168                                                                          ; We subtract 1 as the C flag will be set when we want
14169                                                                          ; to do an addition in the loop below
14170               
14171 42EA 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     42EC 0000     
14172               
14173 42EE 0201  20        li   rx,>08*256                 ; LDX #8            ; Set up a counter in X to count the 8 bits in P
     42F0 0800     
14174               
14175                      .lsr @P                         ; LSR P             ; Set P = P >> 1
     **** ****     > LSR
0001 42F2 D1A0  30        movb @P,rtmp
     42F4 001B     
0002 42F6 0916  18        srl  rtmp,1
0003 42F8 D806  30        movb rtmp,@P
     42FA 001B     
                   < elite.a99
14176                                                                          ; and C flag = bit 0 of P
14177               
14178                                                                          ; We are now going to work our way through the bits of
14179                                                                          ; P, and do a shift-add for any bits that are set,
14180                                                                          ; keeping the running total in A. We just did the first
14181                                                                          ; shift right, so we now need to do the first add and
14182                                                                          ; loop through the other bits in P
14183               
14184               MUL6:
14185 42FC 1704  14        jnc  B44                        ; BCC B44           ; If C (i.e. the next bit from P) is set, do the
14186                      .adc @T,ra                      ; ADC T             ; addition for this bit of P:
     **** ****     > ADC
0001 42FE 1701  14        jnc  !
0002 4300 B004  18        ab   rone,ra
0003               !:
0004 4302 B020  30        ab   @T,ra
     4304 00D1     
                   < elite.a99
14187                                                                          ;
14188                                                                          ; A = A + T + C
14189                                                                          ; = A + X - 1 + 1
14190                                                                          ; = A + X
14191               
14192               B44:
14193 4306 06A0  32        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result,
     4308 FF4A     
14194                                                                          ; which the next ROR sticks into the left end of P while
14195                                                                          ; also extracting the next bit of P
14196               
14197 430A 0208  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     430C 001B     
14198 430E 06A0  32        bl   @ror                       ;
     4310 FF62     
14199                                                                          ; the start of P, and shift P right to fetch the next
14200                                                                          ; bit for the calculation into the C flag
14201               
14202 4312 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14203               
14204 4314 16F3  14        jne  MUL6                       ; BNE MUL6          ; Loop back for the next bit until P has been rotated
14205                                                                          ; all the way
14206               
14207 4316 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4318 FF1C     
14208               
14209               * ******************************************************************************
14210               *
14211               * Name: MU6
14212               * Type: Subroutine
14213               * Category: Maths (Arithmetic)
14214               * Summary: Set P(1 0) = (A A)
14215               *
14216               * ------------------------------------------------------------------------------
14217               *
14218               * In practice this is only called via a BEQ following an AND instruction, in
14219               * which case A = 0, so this routine effectively does this:
14220               *
14221               * P(1 0) = 0
14222               *
14223               * ******************************************************************************
14224               
14225               MU6:
14226 431A D800  30        movb ra,@P+1                    ; STA P+1           ; Set P(1 0) = (A A)
     431C 001C     
14227 431E D800  30        movb ra,@P                      ; STA P
     4320 001B     
14228               
14229 4322 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4324 FF1C     
14230               
14231               * ******************************************************************************
14232               *
14233               * Name: FMLTU2
14234               * Type: Subroutine
14235               * Category: Maths (Arithmetic)
14236               * Summary: Calculate A = K * sin(A)
14237               * Deep dive: The sine, cosine and arctan tables
14238               *
14239               * ------------------------------------------------------------------------------
14240               *
14241               * Calculate the following:
14242               *
14243               * A = K * sin(A)
14244               *
14245               * Because this routine uses the sine lookup table SNE, we can also call this
14246               * routine to calculate cosine multiplication. To calculate the following:
14247               *
14248               * A = K * cos(B)
14249               *
14250               * call this routine with B + 16 in the accumulator, as sin(B + 16) = cos(B).
14251               *
14252               * ******************************************************************************
14253               
14254               FMLTU2:
14255 4326 0240  22        andi ra,>1f*256                 ; AND #%00011111    ; Restrict A to bits 0-5 (so it's in the range 0-31)
     4328 1F00     
14256               
14257 432A D040  18        movb ra,rx                      ; TAX               ; Set Q = sin(A) * 256
14258 432C D021  34        movb @SNE(rx),ra                ; LDA SNE,X
     432E 4112     
14259 4330 D800  30        movb ra,@Q                      ; STA Q
     4332 0090     
14260               
14261 4334 D020  30        movb @K,ra                      ; LDA K             ; Set A to the radius in K
     4336 003D     
14262               
14263                                                                          ; Fall through into FMLTU to do the following:
14264                                                                          ;
14265                                                                          ; (A ?) = A * Q
14266                                                                          ; = K * sin(A) * 256
14267                                                                          ;
14268                                                                          ; which is equivalent to:
14269                                                                          ;
14270                                                                          ; A = K * sin(A)
14271               
14272               * ******************************************************************************
14273               *
14274               * Name: FMLTU
14275               * Type: Subroutine
14276               * Category: Maths (Arithmetic)
14277               * Summary: Calculate A = A * Q / 256
14278               *
14279               * ------------------------------------------------------------------------------
14280               *
14281               * Do the following multiplication of two unsigned 8-bit numbers, returning only
14282               * the high byte of the result:
14283               *
14284               * (A ?) = A * Q
14285               *
14286               * or, to put it another way:
14287               *
14288               * A = A * Q / 256
14289               *
14290               * ------------------------------------------------------------------------------
14291               *
14292               * Returns:
14293               *
14294               * C flag              The C flag is set
14295               *
14296               * ******************************************************************************
14297               
14298               FMLTU:
14299                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip the bits in A, set the C flag and rotate right,
     **** ****     > EOI
0001 4338 0206  20        li   rtmp,(>FF*256)
     433A FF00     
0002 433C 2806  18        xor  rtmp,ra
                   < elite.a99
14300                      .sec                            ; SEC               ; so the C flag now contains bit 0 of A inverted, and P
     **** ****     > SEC
0001 433E 0A15  18        sla  rmone,1
                   < elite.a99
14301 4340 06A0  32        bl   @rora                      ; ROR A             ; contains A inverted and shifted right by one, with bit
     4342 FF4A     
14302 4344 D800  30        movb ra,@P                      ; STA P             ; 7 set to a 1. We can now use P as our source of bits
     4346 001B     
14303                                                                          ; to shift right, just as in MU11, just with the logic
14304                                                                          ; reversed
14305               
14306 4348 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     434A 0000     
14307               
14308               MUL3:
14309 434C 180E  14        joc  MU7                        ; BCS MU7           ; If C (i.e. the next bit from P) is set, do not do the
14310                                                                          ; addition for this bit of P, and instead skip to MU7
14311                                                                          ; to just do the shifts
14312               
14313                      .adc @Q,ra                      ; ADC Q             ; Do the addition for this bit of P:
     **** ****     > ADC
0001 434E 1701  14        jnc  !
0002 4350 B004  18        ab   rone,ra
0003               !:
0004 4352 B020  30        ab   @Q,ra
     4354 0090     
                   < elite.a99
14314                                                                          ;
14315                                                                          ; A = A + Q + C
14316                                                                          ; = A + Q
14317               
14318 4356 06A0  32        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result.
     4358 FF4A     
14319                                                                          ; If we were interested in the low byte of the result we
14320                                                                          ; would want to save the bit that falls off the end, but
14321                                                                          ; we aren't, so we can ignore it
14322               
14323                      .lsr @P                         ; LSR P             ; Shift P right to fetch the next bit for the
     **** ****     > LSR
0001 435A D1A0  30        movb @P,rtmp
     435C 001B     
0002 435E 0916  18        srl  rtmp,1
0003 4360 D806  30        movb rtmp,@P
     4362 001B     
                   < elite.a99
14324                                                                          ; calculation into the C flag
14325               
14326 4364 16F3  14        jne  MUL3                       ; BNE MUL3          ; Loop back to MUL3 if P still contains some set bits
14327                                                                          ; (so we loop through the bits of P until we get to the
14328                                                                          ; 1 we inserted before the loop, and then we stop)
14329               
14330                                                                          ; If we get here then the C flag is set as we just
14331                                                                          ; rotated a 1 out of the right end of P
14332               
14333 4366 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4368 FF1C     
14334               
14335               MU7:
14336 436A 0910  18        srl  ra,1                       ; LSR A             ; Shift A right to catch the next digit of our result,
14337                                                                          ; pushing a 0 into bit 7 as we aren't adding anything
14338                                                                          ; here (we can't use a ROR here as the C flag is set, so
14339                                                                          ; a ROR would push a 1 into bit 7)
14340               
14341                      .lsr @P                         ; LSR P             ; Fetch the next bit from P into the C flag
     **** ****     > LSR
0001 436C D1A0  30        movb @P,rtmp
     436E 001B     
0002 4370 0916  18        srl  rtmp,1
0003 4372 D806  30        movb rtmp,@P
     4374 001B     
                   < elite.a99
14342               
14343 4376 16EA  14        jne  MUL3                       ; BNE MUL3          ; Loop back to MUL3 if P still contains some set bits
14344                                                                          ; (so we loop through the bits of P until we get to the
14345                                                                          ; 1 we inserted before the loop, and then we stop)
14346               
14347                                                                          ; If we get here then the C flag is set as we just
14348                                                                          ; rotated a 1 out of the right end of P
14349               
14350 4378 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     437A FF1C     
14351               
14352               * ******************************************************************************
14353               *
14354               * Name: Unused duplicate of MULTU
14355               * Type: Subroutine
14356               * Category: Maths (Arithmetic)
14357               * Summary: An unused duplicate of the MULTU routine
14358               *
14359               * ------------------------------------------------------------------------------
14360               *
14361               * This is a duplicate of the MULTU routine, but with no entry label, so it can't
14362               * be called by name. It is unused, and could have been culled to save a few
14363               * bytes (24 to be precise), but it's still here, unnamed, unloved and unvisited,
14364               * through no fault of its own.
14365               *
14366               * ******************************************************************************
14367               
14368               * {
14369               * LDX Q
14370               * BEQ MU1
14371               * DEX
14372               * STX T
14373               * LDA #0
14374               * LDX #8
14375               * LSR P
14376               *
14377               * .MUL6
14378               *
14379               * BCC B45
14380               * ADC T
14381               * .B45
14382               * ROR A
14383               * ROR P
14384               * DEX
14385               * BNE MUL6
14386               * RTS
14387               * }
14388               
14389               * ******************************************************************************
14390               *
14391               * Name: MLTU2
14392               * Type: Subroutine
14393               * Category: Maths (Arithmetic)
14394               * Summary: Calculate (A P+1 P) = (A ~P) * Q
14395               * Deep dive: Shift-and-add multiplication
14396               *
14397               * ------------------------------------------------------------------------------
14398               *
14399               * Do the following multiplication of an unsigned 16-bit number and an unsigned
14400               * 8-bit number:
14401               *
14402               * (A P+1 P) = (A ~P) * Q
14403               *
14404               * where ~P means P EOR %11111111 (i.e. P with all its bits flipped). In other
14405               * words, if you wanted to calculate &1234 * &56, you would:
14406               *
14407               * * Set A to &12
14408               * * Set P to &34 EOR %11111111 = &CB
14409               * * Set Q to &56
14410               *
14411               * before calling MLTU2.
14412               *
14413               * This routine is like a mash-up of MU11 and FMLTU. It uses part of FMLTU's
14414               * inverted argument trick to work out whether or not to do an addition, and like
14415               * MU11 it sets up a counter in X to extract bits from (P+1 P). But this time we
14416               * extract 16 bits from (P+1 P), so the result is a 24-bit number. The core of
14417               * the algorithm is still the shift-and-add approach explained in MULT1, just
14418               * with more bits.
14419               *
14420               * ------------------------------------------------------------------------------
14421               *
14422               * Returns:
14423               *
14424               * Q                   Q is preserved
14425               *
14426               * ------------------------------------------------------------------------------
14427               *
14428               * Other entry points:
14429               *
14430               * MLTU2-2             Set Q to X, so this calculates (A P+1 P) = (A ~P) * X
14431               *
14432               * ******************************************************************************
14433               
14434 437C D801  30        movb rx,@Q                      ; STX Q             ; Store X in Q
     437E 0090     
14435               
14436               MLTU2:
14437                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip the bits in A and rotate right, storing the
     **** ****     > EOI
0001 4380 0206  20        li   rtmp,(>FF*256)
     4382 FF00     
0002 4384 2806  18        xor  rtmp,ra
                   < elite.a99
14438 4386 0910  18        srl  ra,1                       ; LSR A             ; result in P+1, so we now calculate (P+1 P) * Q
14439 4388 D800  30        movb ra,@P+1                    ; STA P+1
     438A 001C     
14440               
14441 438C 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     438E 0000     
14442               
14443 4390 0201  20        li   rx,>10*256                 ; LDX #16           ; Set up a counter in X to count the 16 bits in (P+1 P)
     4392 1000     
14444               
14445 4394 0208  20        li   rarg1,P                    ; ROR P             ; Set P = P >> 1 with bit 7 = bit 0 of A
     4396 001B     
14446 4398 06A0  32        bl   @ror                       ;
     439A FF62     
14447                                                                          ; and C flag = bit 0 of P
14448               
14449               MUL7:
14450 439C 1812  14        joc  MU21                       ; BCS MU21          ; If C (i.e. the next bit from P) is set, do not do the
14451                                                                          ; addition for this bit of P, and instead skip to MU21
14452                                                                          ; to just do the shifts
14453               
14454                      .adc @Q,ra                      ; ADC Q             ; Do the addition for this bit of P:
     **** ****     > ADC
0001 439E 1701  14        jnc  !
0002 43A0 B004  18        ab   rone,ra
0003               !:
0004 43A2 B020  30        ab   @Q,ra
     43A4 0090     
                   < elite.a99
14455                                                                          ;
14456                                                                          ; A = A + Q + C
14457                                                                          ; = A + Q
14458               
14459 43A6 06A0  32        bl   @rora                      ; ROR A             ; Rotate (A P+1 P) to the right, so we capture the next
     43A8 FF4A     
14460 43AA 0208  20        li   rarg1,P+1                  ; ROR P+1           ; digit of the result in P+1, and extract the next digit
     43AC 001C     
14461 43AE 06A0  32        bl   @ror                       ;
     43B0 FF62     
14462 43B2 0208  20        li   rarg1,P                    ; ROR P             ; of (P+1 P) in the C flag
     43B4 001B     
14463 43B6 06A0  32        bl   @ror                       ;
     43B8 FF62     
14464               
14465 43BA 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14466               
14467 43BC 16EF  14        jne  MUL7                       ; BNE MUL7          ; Loop back for the next bit until P has been rotated
14468                                                                          ; all the way
14469               
14470 43BE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     43C0 FF1C     
14471               
14472               MU21:
14473 43C2 0910  18        srl  ra,1                       ; LSR A             ; Shift (A P+1 P) to the right, so we capture the next
14474 43C4 0208  20        li   rarg1,P+1                  ; ROR P+1           ; digit of the result in P+1, and extract the next digit
     43C6 001C     
14475 43C8 06A0  32        bl   @ror                       ;
     43CA FF62     
14476 43CC 0208  20        li   rarg1,P                    ; ROR P             ; of (P+1 P) in the C flag
     43CE 001B     
14477 43D0 06A0  32        bl   @ror                       ;
     43D2 FF62     
14478               
14479 43D4 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14480               
14481 43D6 16E2  14        jne  MUL7                       ; BNE MUL7          ; Loop back for the next bit until P has been rotated
14482                                                                          ; all the way
14483               
14484 43D8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     43DA FF1C     
14485               
14486               * ******************************************************************************
14487               *
14488               * Name: MUT3
14489               * Type: Subroutine
14490               * Category: Maths (Arithmetic)
14491               * Summary: An unused routine that does the same as MUT2
14492               *
14493               * ------------------------------------------------------------------------------
14494               *
14495               * This routine is never actually called, but it is identical to MUT2, as the
14496               * extra instructions have no effect.
14497               *
14498               * ******************************************************************************
14499               
14500               MUT3:
14501 43DC D060  30        movb @ALP1,rx                   ; LDX ALP1          ; Set P = ALP1, though this gets overwritten by the
     43DE 0087     
14502 43E0 D801  30        movb rx,@P                      ; STX P             ; following, so this has no effect
     43E2 001B     
14503               
14504                                                                          ; Fall through into MUT2 to do the following:
14505                                                                          ;
14506                                                                          ; (S R) = XX(1 0)
14507                                                                          ; (A P) = Q * A
14508               
14509               * ******************************************************************************
14510               *
14511               * Name: MUT2
14512               * Type: Subroutine
14513               * Category: Maths (Arithmetic)
14514               * Summary: Calculate (S R) = XX(1 0) and (A P) = Q * A
14515               *
14516               * ------------------------------------------------------------------------------
14517               *
14518               * Do the following assignment, and multiplication of two signed 8-bit numbers:
14519               *
14520               * (S R) = XX(1 0)
14521               * (A P) = Q * A
14522               *
14523               * ******************************************************************************
14524               
14525               MUT2:
14526 43E4 D060  30        movb @XX+1,rx                   ; LDX XX+1          ; Set S = XX+1
     43E6 0025     
14527 43E8 D801  30        movb rx,@S                      ; STX S
     43EA 0092     
14528               
14529                                                                          ; Fall through into MUT1 to do the following:
14530                                                                          ;
14531                                                                          ; R = XX
14532                                                                          ; (A P) = Q * A
14533               
14534               * ******************************************************************************
14535               *
14536               * Name: MUT1
14537               * Type: Subroutine
14538               * Category: Maths (Arithmetic)
14539               * Summary: Calculate R = XX and (A P) = Q * A
14540               *
14541               * ------------------------------------------------------------------------------
14542               *
14543               * Do the following assignment, and multiplication of two signed 8-bit numbers:
14544               *
14545               * R = XX
14546               * (A P) = Q * A
14547               *
14548               * ******************************************************************************
14549               
14550               MUT1:
14551 43EC D060  30        movb @XX,rx                     ; LDX XX            ; Set R = XX
     43EE 0024     
14552 43F0 D801  30        movb rx,@R                      ; STX R
     43F2 0091     
14553               
14554                                                                          ; Fall through into MULT1 to do the following:
14555                                                                          ;
14556                                                                          ; (A P) = Q * A
14557               
14558               * ******************************************************************************
14559               *
14560               * Name: MULT1
14561               * Type: Subroutine
14562               * Category: Maths (Arithmetic)
14563               * Summary: Calculate (A P) = Q * A
14564               * Deep dive: Shift-and-add multiplication
14565               *
14566               * ------------------------------------------------------------------------------
14567               *
14568               * Do the following multiplication of two 8-bit sign-magnitude numbers:
14569               *
14570               * (A P) = Q * A
14571               *
14572               * ******************************************************************************
14573               
14574               MULT1:
14575 43F4 D040  18        movb ra,rx                      ; TAX               ; Store A in X
14576               
14577 43F6 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Set P = |A| >> 1
     43F8 7F00     
14578 43FA 0910  18        srl  ra,1                       ; LSR A             ; and C flag = bit 0 of A
14579 43FC D800  30        movb ra,@P                      ; STA P
     43FE 001B     
14580               
14581 4400 D001  18        movb rx,ra                      ; TXA               ; Restore argument A
14582               
14583                      .eor @Q                         ; EOR Q             ; Set bit 7 of A and T if Q and A have different signs,
     **** ****     > EOR
0001 4402 D1A0  30        movb @Q,rtmp
     4404 0090     
0002 4406 2806  18        xor  rtmp,ra
                   < elite.a99
14584 4408 0240  22        andi ra,>80*256                 ; AND #%10000000    ; clear bit 7 if they have the same signs, 0 all other
     440A 8000     
14585 440C D800  30        movb ra,@T                      ; STA T             ; bits, i.e. T contains the sign bit of Q * A
     440E 00D1     
14586               
14587 4410 D020  30        movb @Q,ra                      ; LDA Q             ; Set A = |Q|
     4412 0090     
14588 4414 0240  22        andi ra,>7f*256                 ; AND #%01111111
     4416 7F00     
14589               
14590 4418 131E  14        jeq  mu10_                      ; BEQ mu10          ; If |Q| = 0 jump to mu10 (with A set to 0)
14591               
14592 441A D040  18        movb ra,rx                      ; TAX               ; Set T1 = |Q| - 1
14593 441C 7044  18        sb   rone,rx                    ; DEX               ;
14594 441E D801  30        movb rx,@T1                     ; STX T1            ; We subtract 1 as the C flag will be set when we want
     4420 0006     
14595                                                                          ; to do an addition in the loop below
14596               
14597                                                                          ; We are now going to work our way through the bits of
14598                                                                          ; P, and do a shift-add for any bits that are set,
14599                                                                          ; keeping the running total in A. We already set up
14600                                                                          ; the first shift at the start of this routine, as
14601                                                                          ; P = |A| >> 1 and C = bit 0 of A, so we now need to set
14602                                                                          ; up a loop to sift through the other 7 bits in P
14603               
14604 4422 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4424 0000     
14605               
14606 4426 0201  20        li   rx,>07*256                 ; LDX #7            ; Set up a counter in X to count the 7 bits remaining
     4428 0700     
14607                                                                          ; in P
14608               
14609               MUL4:
14610 442A 1704  14        jnc  B46                        ; BCC B46           ; If C (i.e. the next bit from P) is set, do the
14611                      .adc @T1,ra                     ; ADC T1            ; addition for this bit of P:
     **** ****     > ADC
0001 442C 1701  14        jnc  !
0002 442E B004  18        ab   rone,ra
0003               !:
0004 4430 B020  30        ab   @T1,ra
     4432 0006     
                   < elite.a99
14612                                                                          ;
14613                                                                          ; A = A + T1 + C
14614                                                                          ; = A + |Q| - 1 + 1
14615                                                                          ; = A + |Q|
14616               
14617               B46:
14618 4434 06A0  32        bl   @rora                      ; ROR A             ; As mentioned above, this ROR shifts A right and
     4436 FF4A     
14619                                                                          ; catches bit 0 in C - giving another digit for our
14620                                                                          ; result - and the next ROR sticks that bit into the
14621                                                                          ; left end of P while also extracting the next bit of P
14622                                                                          ; for the next addition
14623               
14624 4438 0208  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     443A 001B     
14625 443C 06A0  32        bl   @ror                       ;
     443E FF62     
14626                                                                          ; the start of P, and shift P right to fetch the next
14627                                                                          ; bit for the calculation
14628               
14629 4440 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14630               
14631 4442 16F3  14        jne  MUL4                       ; BNE MUL4          ; Loop back for the next bit until P has been rotated
14632                                                                          ; all the way
14633               
14634 4444 0910  18        srl  ra,1                       ; LSR A             ; Rotate (A P) once more to get the final result, as
14635 4446 0208  20        li   rarg1,P                    ; ROR P             ; we only pushed 7 bits through the above process
     4448 001B     
14636 444A 06A0  32        bl   @ror                       ;
     444C FF62     
14637               
14638 444E F020  30        socb @T,ra                      ; ORA T             ; Set the sign bit of the result that we stored in T
     4450 00D1     
14639               
14640 4452 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4454 FF1C     
14641               
14642               mu10_:
14643 4456 D800  30        movb ra,@P                      ; STA P             ; If we get here, the result is 0 and A = 0, so set
     4458 001B     
14644                                                                          ; P = 0 so (A P) = 0
14645               
14646 445A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     445C FF1C     
14647               
14648               * ******************************************************************************
14649               *
14650               * Name: MULT12
14651               * Type: Subroutine
14652               * Category: Maths (Arithmetic)
14653               * Summary: Calculate (S R) = Q * A
14654               *
14655               * ------------------------------------------------------------------------------
14656               *
14657               * Calculate:
14658               *
14659               * (S R) = Q * A
14660               *
14661               * ******************************************************************************
14662               
14663               MULT12:
14664 445E 0206  20        li   rtmp,MULT1                 ; JSR MULT1         ; Set (A P) = Q * A
     4460 43F4     
14665 4462 06A0  32        bl   @jsr                       ;
     4464 FF10     
14666               
14667 4466 D800  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P)
     4468 0092     
14668 446A D020  30        movb @P,ra                      ; LDA P             ; = Q * A
     446C 001B     
14669 446E D800  30        movb ra,@R                      ; STA R
     4470 0091     
14670               
14671 4472 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4474 FF1C     
14672               
14673               * ******************************************************************************
14674               *
14675               * Name: TAS3
14676               * Type: Subroutine
14677               * Category: Maths (Geometry)
14678               * Summary: Calculate the dot product of XX15 and an orientation vector
14679               *
14680               * ------------------------------------------------------------------------------
14681               *
14682               * Calculate the dot product of the vector in XX15 and one of the orientation
14683               * vectors, as determined by the value of Y. If vect is the orientation vector,
14684               * we calculate this:
14685               *
14686               * (A X) = vect . XX15
14687               * = vect_x * XX15 + vect_y * XX15+1 + vect_z * XX15+2
14688               *
14689               * ------------------------------------------------------------------------------
14690               *
14691               * Arguments:
14692               *
14693               * Y                   The orientation vector:
14694               *
14695               * * If Y = 10, calculate nosev . XX15
14696               *
14697               * * If Y = 16, calculate roofv . XX15
14698               *
14699               * * If Y = 22, calculate sidev . XX15
14700               *
14701               * ------------------------------------------------------------------------------
14702               *
14703               * Returns:
14704               *
14705               * (A X)               The result of the dot product
14706               *
14707               * ******************************************************************************
14708               
14709               TAS3:
14710 4476 D062  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; Set Q = the Y-th byte of INWK, i.e. vect_x
     4478 0053     
14711 447A D801  30        movb rx,@Q                      ; STX Q
     447C 0090     
14712               
14713 447E D020  30        movb @XX15,ra                   ; LDA XX15          ; Set A = XX15
     4480 0031     
14714               
14715 4482 0206  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A
     4484 445E     
14716 4486 06A0  32        bl   @jsr                       ;
     4488 FF10     
14717                                                                          ; = vect_x * XX15
14718               
14719 448A D062  34        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set Q = the Y+2-th byte of INWK, i.e. vect_y
     448C 0055     
14720 448E D801  30        movb rx,@Q                      ; STX Q
     4490 0090     
14721               
14722 4492 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A = XX15+1
     4494 0032     
14723               
14724 4496 0206  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     4498 44B2     
14725 449A 06A0  32        bl   @jsr                       ;
     449C FF10     
14726                                                                          ; = vect_y * XX15+1 + vect_x * XX15
14727               
14728 449E D800  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     44A0 0092     
14729 44A2 D801  30        movb rx,@R                      ; STX R
     44A4 0091     
14730               
14731 44A6 D062  34        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; Set Q = the Y+2-th byte of INWK, i.e. vect_z
     44A8 0057     
14732 44AA D801  30        movb rx,@Q                      ; STX Q
     44AC 0090     
14733               
14734 44AE D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set A = XX15+2
     44B0 0033     
14735               
14736                                                                          ; Fall through into MAD to set:
14737                                                                          ;
14738                                                                          ; (A X) = Q * A + (S R)
14739                                                                          ; = vect_z * XX15+2 + vect_y * XX15+1 +
14740                                                                          ; vect_x * XX15
14741               
14742               * ******************************************************************************
14743               *
14744               * Name: MAD
14745               * Type: Subroutine
14746               * Category: Maths (Arithmetic)
14747               * Summary: Calculate (A X) = Q * A + (S R)
14748               *
14749               * ------------------------------------------------------------------------------
14750               *
14751               * Calculate
14752               *
14753               * (A X) = Q * A + (S R)
14754               *
14755               * ******************************************************************************
14756               
14757               MAD:
14758 44B2 0206  20        li   rtmp,MULT1                 ; JSR MULT1         ; Call MULT1 to set (A P) = Q * A
     44B4 43F4     
14759 44B6 06A0  32        bl   @jsr                       ;
     44B8 FF10     
14760               
14761                                                                          ; Fall through into ADD to do:
14762                                                                          ;
14763                                                                          ; (A X) = (A P) + (S R)
14764                                                                          ; = Q * A + (S R)
14765               
14766               * ******************************************************************************
14767               *
14768               * Name: ADD
14769               * Type: Subroutine
14770               * Category: Maths (Arithmetic)
14771               * Summary: Calculate (A X) = (A P) + (S R)
14772               * Deep dive: Adding sign-magnitude numbers
14773               *
14774               * ------------------------------------------------------------------------------
14775               *
14776               * Add two 16-bit sign-magnitude numbers together, calculating:
14777               *
14778               * (A X) = (A P) + (S R)
14779               *
14780               * ******************************************************************************
14781               
14782               ADD:
14783 44BA D800  30        movb ra,@T1                     ; STA T1            ; Store argument A in T1
     44BC 0006     
14784               
14785 44BE 0240  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign (bit 7) of A and store it in T
     44C0 8000     
14786 44C2 D800  30        movb ra,@T                      ; STA T
     44C4 00D1     
14787               
14788                      .eor @S                         ; EOR S             ; EOR bit 7 of A with S. If they have different bit 7s
     **** ****     > EOR
0001 44C6 D1A0  30        movb @S,rtmp
     44C8 0092     
0002 44CA 2806  18        xor  rtmp,ra
                   < elite.a99
14789 44CC 1112  14        jlt  MU8                        ; BMI MU8           ; (i.e. they have different signs) then bit 7 in the
14790                                                                          ; EOR result will be 1, which means the EOR result is
14791                                                                          ; negative. So the AND, EOR and BMI together mean "jump
14792                                                                          ; to MU8 if A and S have different signs"
14793               
14794                                                                          ; If we reach here, then A and S have the same sign, so
14795                                                                          ; we can add them and set the sign to get the result
14796               
14797 44CE D020  30        movb @R,ra                      ; LDA R             ; Add the least significant bytes together into X:
     44D0 0091     
14798                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 44D2 0A13  18        sla  rzero,1
                   < elite.a99
14799                      .adc @P,ra                      ; ADC P             ; X = P + R
     **** ****     > ADC
0001 44D4 1701  14        jnc  !
0002 44D6 B004  18        ab   rone,ra
0003               !:
0004 44D8 B020  30        ab   @P,ra
     44DA 001B     
                   < elite.a99
14800 44DC D040  18        movb ra,rx                      ; TAX
14801               
14802 44DE D020  30        movb @S,ra                      ; LDA S             ; Add the most significant bytes together into A. We
     44E0 0092     
14803                      .adc @T1,ra                     ; ADC T1            ; stored the original argument A in T1 earlier, so we
     **** ****     > ADC
0001 44E2 1701  14        jnc  !
0002 44E4 B004  18        ab   rone,ra
0003               !:
0004 44E6 B020  30        ab   @T1,ra
     44E8 0006     
                   < elite.a99
14804                                                                          ; can do this with:
14805                                                                          ;
14806                                                                          ; A = A  + S + C
14807                                                                          ; = T1 + S + C
14808               
14809 44EA F020  30        socb @T,ra                      ; ORA T             ; If argument A was negative (and therefore S was also
     44EC 00D1     
14810                                                                          ; negative) then make sure result A is negative by
14811                                                                          ; OR'ing the result with the sign bit from argument A
14812                                                                          ; (which we stored in T)
14813               
14814 44EE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     44F0 FF1C     
14815               
14816               MU8:
14817                                                                          ; If we reach here, then A and S have different signs,
14818                                                                          ; so we can subtract their absolute values and set the
14819                                                                          ; sign to get the result
14820 44F2 D020  30        movb @S,ra                      ; LDA S             ; Clear the sign (bit 7) in S and store the result in
     44F4 0092     
14821 44F6 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; U, so U now contains |S|
     44F8 7F00     
14822 44FA D800  30        movb ra,@U                      ; STA U
     44FC 008F     
14823               
14824 44FE D020  30        movb @P,ra                      ; LDA P             ; Subtract the least significant bytes into X:
     4500 001B     
14825                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 4502 0A15  18        sla  rmone,1
                   < elite.a99
14826                      .sbc @R,ra                      ; SBC R             ; X = P - R
     **** ****     > SBC
0001 4504 1801  14        joc  !
0002 4506 7004  18        sb   rone,ra
0003               !:
0004 4508 7020  30        sb   @R,ra
     450A 0091     
                   < elite.a99
14827 450C D040  18        movb ra,rx                      ; TAX
14828               
14829 450E D020  30        movb @T1,ra                     ; LDA T1            ; Restore the A of the argument (A P) from T1 and
     4510 0006     
14830 4512 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; clear the sign (bit 7), so A now contains |A|
     4514 7F00     
14831               
14832                      .sbc @U,ra                      ; SBC U             ; Set A = |A| - |S|
     **** ****     > SBC
0001 4516 1801  14        joc  !
0002 4518 7004  18        sb   rone,ra
0003               !:
0004 451A 7020  30        sb   @U,ra
     451C 008F     
                   < elite.a99
14833               
14834                                                                          ; At this point we have |A P| - |S R| in (A X), so we
14835                                                                          ; need to check whether the subtraction above was the
14836                                                                          ; right way round (i.e. that we subtracted the smaller
14837                                                                          ; absolute value from the larger absolute value)
14838               
14839 451E 1813  14        joc  MU9                        ; BCS MU9           ; If |A| >= |S|, our subtraction was the right way
14840                                                                          ; round, so jump to MU9 to set the sign
14841               
14842                                                                          ; If we get here, then |A| < |S|, so our subtraction
14843                                                                          ; above was the wrong way round (we actually subtracted
14844                                                                          ; the larger absolute value from the smaller absolute
14845                                                                          ; value). So let's subtract the result we have in (A X)
14846                                                                          ; from zero, so that the subtraction is the right way
14847                                                                          ; round
14848               
14849 4520 D800  30        movb ra,@U                      ; STA U             ; Store A in U
     4522 008F     
14850               
14851 4524 D001  18        movb rx,ra                      ; TXA               ; Set X = 0 - X using two's complement (to negate a
14852                      .eoi (>ff*256)                  ; EOR #&FF          ; number in two's complement, you can invert the bits
     **** ****     > EOI
0001 4526 0206  20        li   rtmp,(>FF*256)
     4528 FF00     
0002 452A 2806  18        xor  rtmp,ra
                   < elite.a99
14853                      .adi (>01*256)                  ; ADC #1            ; and add one - and we know the C flag is clear as we
     **** ****     > ADI
0001 452C 1701  14        jnc  !
0002 452E B004  18        ab   rone,ra
0003               !:
0004 4530 0220  22        ai   ra,(>01*256)
     4532 0100     
                   < elite.a99
14854 4534 D040  18        movb ra,rx                      ; TAX               ; didn't take the BCS branch above, so the ADC will do
14855                                                                          ; the correct addition)
14856               
14857 4536 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 - A, which we can do this time using a
     4538 0000     
14858                      .sbc @U,ra                      ; SBC U             ; subtraction with the C flag clear
     **** ****     > SBC
0001 453A 1801  14        joc  !
0002 453C 7004  18        sb   rone,ra
0003               !:
0004 453E 7020  30        sb   @U,ra
     4540 008F     
                   < elite.a99
14859               
14860 4542 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now set the sign bit of A, so that the EOR on the
     4544 8000     
14861                                                                          ; next line will give the result the opposite sign to
14862                                                                          ; argument A (as T contains the sign bit of argument
14863                                                                          ; A). This is the same as giving the result the same
14864                                                                          ; sign as argument S (as A and S have different signs),
14865                                                                          ; which is what we want, as S has the larger absolute
14866                                                                          ; value
14867               
14868               MU9:
14869                      .eor @T                         ; EOR T             ; If we get here from the BCS above, then |A| >= |S|,
     **** ****     > EOR
0001 4546 D1A0  30        movb @T,rtmp
     4548 00D1     
0002 454A 2806  18        xor  rtmp,ra
                   < elite.a99
14870                                                                          ; so we want to give the result the same sign as
14871                                                                          ; argument A, so if argument A was negative, we flip
14872                                                                          ; the sign of the result with an EOR (to make it
14873                                                                          ; negative)
14874               
14875 454C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     454E FF1C     
14876               
14877               * ******************************************************************************
14878               *
14879               * Name: TIS1
14880               * Type: Subroutine
14881               * Category: Maths (Arithmetic)
14882               * Summary: Calculate (A ?) = (-X * A + (S R)) / 96
14883               * Deep dive: Shift-and-subtract division
14884               *
14885               * ------------------------------------------------------------------------------
14886               *
14887               * Calculate the following expression between sign-magnitude numbers, ignoring
14888               * the low byte of the result:
14889               *
14890               * (A ?) = (-X * A + (S R)) / 96
14891               *
14892               * This uses the same shift-and-subtract algorithm as TIS2, just with the
14893               * quotient A hard-coded to 96.
14894               *
14895               * ------------------------------------------------------------------------------
14896               *
14897               * Returns:
14898               *
14899               * Q                   Gets set to the value of argument X
14900               *
14901               * ******************************************************************************
14902               
14903               TIS1:
14904 4550 D801  30        movb rx,@Q                      ; STX Q             ; Set Q = X
     4552 0090     
14905               
14906                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign bit in A
     **** ****     > EOI
0001 4554 0206  20        li   rtmp,(>80*256)
     4556 8000     
0002 4558 2806  18        xor  rtmp,ra
                   < elite.a99
14907               
14908 455A 0206  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     455C 44B2     
14909 455E 06A0  32        bl   @jsr                       ;
     4560 FF10     
14910                                                                          ; = X * -A + (S R)
14911               
14912               DVID96:
14913 4562 D040  18        movb ra,rx                      ; TAX               ; Set T to the sign bit of the result
14914 4564 0240  22        andi ra,>80*256                 ; AND #%10000000
     4566 8000     
14915 4568 D800  30        movb ra,@T                      ; STA T
     456A 00D1     
14916               
14917 456C D001  18        movb rx,ra                      ; TXA               ; Set A to the high byte of the result with the sign bit
14918 456E 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; cleared, so (A ?) = |X * A + (S R)|
     4570 7F00     
14919               
14920                                                                          ; The following is identical to TIS2, except Q is
14921                                                                          ; hard-coded to 96, so this does A = A / 96
14922               
14923 4572 0201  20        li   rx,>fe*256                 ; LDX #254          ; Set T1 to have bits 1-7 set, so we can rotate through
     4574 FE00     
14924 4576 D801  30        movb rx,@T1                     ; STX T1            ; 7 loop iterations, getting a 1 each time, and then
     4578 0006     
14925                                                                          ; getting a 0 on the 8th iteration... and we can also
14926                                                                          ; use T1 to catch our result bits into bit 0 each time
14927               
14928               DVL3:
14929                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 457A 0240  22        andi ra,>ff00
     457C FF00     
0002 457E 0A10  18        sla  ra,1
                   < elite.a99
14930               
14931 4580 0280  22        ci   ra,>60*256                 ; CMP #96           ; If A < 96 skip the following subtraction
     4582 6000     
14932 4584 1704  14        jnc  DV4                        ; BCC DV4
14933               
14934                      .sbi (>60*256)                  ; SBC #96           ; Set A = A - 96
     **** ****     > SBI
0001 4586 1801  14        joc  !
0002 4588 7004  18        sb   rone,ra
0003               !:
0004 458A 0220  22        ai   ra,-(>60*256)
     458C A000     
                   < elite.a99
14935                                                                          ;
14936                                                                          ; Going into this subtraction we know the C flag is
14937                                                                          ; set as we passed through the BCC above, and we also
14938                                                                          ; know that A >= 96, so the C flag will still be set
14939                                                                          ; once we are done
14940               
14941               DV4:
14942 458E 0208  20        li   rarg1,T1                   ; ROL T1            ; Rotate the counter in T1 to the left, and catch the
     4590 0006     
14943 4592 06A0  32        bl   @rol                       ;
     4594 FF36     
14944                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
14945                                                                          ; do the subtraction, or 1 if we did)
14946               
14947 4596 18F1  14        joc  DVL3                       ; BCS DVL3          ; If we still have set bits in T1, loop back to DVL3 to
14948                                                                          ; do the next iteration of 7
14949               
14950 4598 D020  30        movb @T1,ra                     ; LDA T1            ; Fetch the result from T1 into A
     459A 0006     
14951               
14952 459C F020  30        socb @T,ra                      ; ORA T             ; Give A the sign of the result that we stored above
     459E 00D1     
14953               
14954 45A0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     45A2 FF1C     
14955               
14956               * ******************************************************************************
14957               *
14958               * Name: DV42
14959               * Type: Subroutine
14960               * Category: Maths (Arithmetic)
14961               * Summary: Calculate (P R) = 256 * DELTA / z_hi
14962               *
14963               * ------------------------------------------------------------------------------
14964               *
14965               * Calculate the following division and remainder:
14966               *
14967               * P = DELTA / (the Y-th stardust particle's z_hi coordinate)
14968               *
14969               * R = remainder as a fraction of A, where 1.0 = 255
14970               *
14971               * Another way of saying the above is this:
14972               *
14973               * (P R) = 256 * DELTA / z_hi
14974               *
14975               * DELTA is a value between 1 and 40, and the minimum z_hi is 16 (dust particles
14976               * are removed at lower values than this), so this means P is between 0 and 2
14977               * (as 40 / 16 = 2.5, so the maximum result is P = 2 and R = 128.
14978               *
14979               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
14980               * keep the remainder.
14981               *
14982               * ------------------------------------------------------------------------------
14983               *
14984               * Arguments:
14985               *
14986               * Y                   The number of the stardust particle to process
14987               *
14988               * ------------------------------------------------------------------------------
14989               *
14990               * Returns:
14991               *
14992               * C flag              The C flag is cleared
14993               *
14994               * ******************************************************************************
14995               
14996               DV42:
14997 45A4 D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Fetch the Y-th dust particle's z_hi coordinate into A
     45A6 0EE8     
14998               
14999                                                                          ; Fall through into DV41 to do:
15000                                                                          ;
15001                                                                          ; (P R) = 256 * DELTA / A
15002                                                                          ; = 256 * DELTA / Y-th stardust particle's z_hi
15003               
15004               * ******************************************************************************
15005               *
15006               * Name: DV41
15007               * Type: Subroutine
15008               * Category: Maths (Arithmetic)
15009               * Summary: Calculate (P R) = 256 * DELTA / A
15010               *
15011               * ------------------------------------------------------------------------------
15012               *
15013               * Calculate the following division and remainder:
15014               *
15015               * P = DELTA / A
15016               *
15017               * R = remainder as a fraction of A, where 1.0 = 255
15018               *
15019               * Another way of saying the above is this:
15020               *
15021               * (P R) = 256 * DELTA / A
15022               *
15023               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
15024               * keep the remainder.
15025               *
15026               * ------------------------------------------------------------------------------
15027               *
15028               * Returns:
15029               *
15030               * C flag              The C flag is cleared
15031               *
15032               * ******************************************************************************
15033               
15034               DV41:
15035 45A8 D800  30        movb ra,@Q                      ; STA Q             ; Store A in Q
     45AA 0090     
15036               
15037 45AC D020  30        movb @DELTA,ra                  ; LDA DELTA         ; Fetch the speed from DELTA into A
     45AE 008C     
15038               
15039                                                                          ; Fall through into DVID4 to do:
15040                                                                          ;
15041                                                                          ; (P R) = 256 * A / Q
15042                                                                          ; = 256 * DELTA / A
15043               
15044               * ******************************************************************************
15045               *
15046               * Name: DVID4
15047               * Type: Subroutine
15048               * Category: Maths (Arithmetic)
15049               * Summary: Calculate (P R) = 256 * A / Q
15050               * Deep dive: Shift-and-subtract division
15051               *
15052               * ------------------------------------------------------------------------------
15053               *
15054               * Calculate the following division and remainder:
15055               *
15056               * P = A / Q
15057               *
15058               * R = remainder as a fraction of Q, where 1.0 = 255
15059               *
15060               * Another way of saying the above is this:
15061               *
15062               * (P R) = 256 * A / Q
15063               *
15064               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
15065               * keep the remainder.
15066               *
15067               * ------------------------------------------------------------------------------
15068               *
15069               * Returns:
15070               *
15071               * C flag              The C flag is cleared
15072               *
15073               * ******************************************************************************
15074               
15075               DVID4:
15076 45B0 0201  20        li   rx,>08*256                 ; LDX #8            ; Set a counter in X to count the 8 bits in A
     45B2 0800     
15077               
15078                      .asla                           ; ASL A             ; Shift A left and store in P (we will build the result
     **** ****     > ASLA
0001 45B4 0240  22        andi ra,>ff00
     45B6 FF00     
0002 45B8 0A10  18        sla  ra,1
                   < elite.a99
15079 45BA D800  30        movb ra,@P                      ; STA P             ; in P)
     45BC 001B     
15080               
15081 45BE 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 for us to build a remainder
     45C0 0000     
15082               
15083               DVL4:
15084 45C2 06A0  32        bl   @rola                      ; ROL A             ; Shift A to the left
     45C4 FF26     
15085               
15086 45C6 1803  14        joc  DV8                        ; BCS DV8           ; If the C flag is set (i.e. bit 7 of A was set) then
15087                                                                          ; skip straight to the subtraction
15088               
15089 45C8 9020  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     45CA 0090     
15090 45CC 1705  14        jnc  DV5                        ; BCC DV5
15091               
15092               DV8:
15093                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 45CE 1801  14        joc  !
0002 45D0 7004  18        sb   rone,ra
0003               !:
0004 45D2 7020  30        sb   @Q,ra
     45D4 0090     
                   < elite.a99
15094               
15095                      .sec                            ; SEC               ; Set the C flag, so that P gets a 1 shifted into bit 0
     **** ****     > SEC
0001 45D6 0A15  18        sla  rmone,1
                   < elite.a99
15096               
15097               DV5:
15098 45D8 0208  20        li   rarg1,P                    ; ROL P             ; Shift P to the left, pulling the C flag into bit 0
     45DA 001B     
15099 45DC 06A0  32        bl   @rol                       ;
     45DE FF36     
15100               
15101 45E0 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
15102               
15103 45E2 16EF  14        jne  DVL4                       ; BNE DVL4          ; Loop back for the next bit until we have done all 8
15104                                                                          ; bits of P
15105               
15106 45E4 0460  28        b    @LL28+4                    ; JMP LL28+4        ; Jump to LL28+4 to convert the remainder in A into an
     45E6 D348     
15107                                                                          ; integer representation of the fractional value A / Q,
15108                                                                          ; in R, where 1.0 = 255. LL28+4 always returns with the
15109                                                                          ; C flag cleared, and we return from the subroutine
15110                                                                          ; using a tail call
15111               
15112               * ******************************************************************************
15113               *
15114               * Name: DVID3B2
15115               * Type: Subroutine
15116               * Category: Maths (Arithmetic)
15117               * Summary: Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
15118               * Deep dive: Shift-and-subtract division
15119               *
15120               * ------------------------------------------------------------------------------
15121               *
15122               * Calculate the following:
15123               *
15124               * K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
15125               *
15126               * The actual division here is done as an 8-bit calculation using LL31, but this
15127               * routine shifts both the numerator (the top part of the division) and the
15128               * denominator (the bottom part of the division) around to get the multi-byte
15129               * result we want.
15130               *
15131               * Specifically, it shifts both of them to the left as far as possible, keeping a
15132               * tally of how many shifts get done in each one - and specifically, the
15133               * difference in the number of shifts between the top and bottom (as shifting
15134               * both of them once in the same direction won't change the result). It then
15135               * divides the two highest bytes with the simple 8-bit routine in LL31, and
15136               * shifts the result by the difference in the number of shifts, which acts as a
15137               * scale factor to get the correct result.
15138               *
15139               * ------------------------------------------------------------------------------
15140               *
15141               * Returns:
15142               *
15143               * K(3 2 1 0)          The result of the division
15144               *
15145               * X                   X is preserved
15146               *
15147               * ******************************************************************************
15148               
15149               DVID3B2:
15150 45E8 D800  30        movb ra,@P+2                    ; STA P+2           ; Set P+2 = A
     45EA 001D     
15151               
15152 45EC D020  30        movb @INWK+6,ra                 ; LDA INWK+6        ; Set Q = z_lo
     45EE 0059     
15153 45F0 D800  30        movb ra,@Q                      ; STA Q
     45F2 0090     
15154               
15155 45F4 D020  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set R = z_hi
     45F6 005A     
15156 45F8 D800  30        movb ra,@R                      ; STA R
     45FA 0091     
15157               
15158 45FC D020  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set S = z_sign
     45FE 005B     
15159 4600 D800  30        movb ra,@S                      ; STA S
     4602 0092     
15160               
15161               DVID3B:
15162                                                                          ; Given the above assignments, we now want to calculate
15163                                                                          ; the following to get the result we want:
15164                                                                          ;
15165                                                                          ; K(3 2 1 0) = P(2 1 0) / (S R Q)
15166 4604 D020  30        movb @P,ra                      ; LDA P             ; Make sure P(2 1 0) is at least 1
     4606 001B     
15167 4608 0260  22        ori  ra,>01*256                 ; ORA #1
     460A 0100     
15168 460C D800  30        movb ra,@P                      ; STA P
     460E 001B     
15169               
15170 4610 D020  30        movb @P+2,ra                    ; LDA P+2           ; Set T to the sign of P+2 * S (i.e. the sign of the
     4612 001D     
15171                      .eor @S                         ; EOR S             ; result) and store it in T
     **** ****     > EOR
0001 4614 D1A0  30        movb @S,rtmp
     4616 0092     
0002 4618 2806  18        xor  rtmp,ra
                   < elite.a99
15172 461A 0240  22        andi ra,>80*256                 ; AND #%10000000
     461C 8000     
15173 461E D800  30        movb ra,@T                      ; STA T
     4620 00D1     
15174               
15175 4622 0202  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0 to store the scale factor
     4624 0000     
15176               
15177 4626 D020  30        movb @P+2,ra                    ; LDA P+2           ; Clear the sign bit of P+2, so the division can be done
     4628 001D     
15178 462A 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; with positive numbers and we'll set the correct sign
     462C 7F00     
15179                                                                          ; below, once all the maths is done
15180                                                                          ;
15181                                                                          ; This also leaves A = P+2, which we use below
15182               
15183               DVL9:
15184                                                                          ; We now shift (A P+1 P) left until A >= 64, counting
15185                                                                          ; the number of shifts in Y. This makes the top part of
15186                                                                          ; the division as large as possible, thus retaining as
15187                                                                          ; much accuracy as we can.  When we come to return the
15188                                                                          ; final result, we shift the result by the number of
15189                                                                          ; places in Y, and in the correct direction
15190 462E 0280  22        ci   ra,>40*256                 ; CMP #64           ; If A >= 64, jump down to DV14
     4630 4000     
15191 4632 180F  14        joc  DV14                       ; BCS DV14
15192               
15193                      .asl @P                         ; ASL P             ; Shift (A P+1 P) to the left
     **** ****     > ASL
0001 4634 D1A0  30        movb @P,rtmp
     4636 001B     
0002 4638 0246  22        andi rtmp,>ff00
     463A FF00     
0003 463C 0A16  18        sla  rtmp,1
0004 463E D806  30        movb rtmp,@P
     4640 001B     
                   < elite.a99
15194 4642 0208  20        li   rarg1,P+1                  ; ROL P+1
     4644 001C     
15195 4646 06A0  32        bl   @rol                       ;
     4648 FF36     
15196 464A 06A0  32        bl   @rola                      ; ROL A
     464C FF26     
15197               
15198 464E B084  18        ab   rone,ry                    ; INY               ; Increment the scale factor in Y
15199               
15200 4650 16EE  14        jne  DVL9                       ; BNE DVL9          ; Loop up to DVL9 (this BNE is effectively a JMP, as Y
15201                                                                          ; will never be zero)
15202               
15203               DV14:
15204                                                                          ; If we get here, A >= 64 and contains the highest byte
15205                                                                          ; of the numerator, scaled up by the number of left
15206                                                                          ; shifts in Y
15207 4652 D800  30        movb ra,@P+2                    ; STA P+2           ; Store A in P+2, so we now have the scaled value of
     4654 001D     
15208                                                                          ; the numerator in P(2 1 0)
15209               
15210 4656 D020  30        movb @S,ra                      ; LDA S             ; Set A = |S|
     4658 0092     
15211 465A 0240  22        andi ra,>7f*256                 ; AND #%01111111
     465C 7F00     
15212               
15213 465E 110F  14        jlt  DV9                        ; BMI DV9           ; If bit 7 of A is set, jump down to DV9 to skip the
15214                                                                          ; left-shifting of the denominator (though this branch
15215                                                                          ; instruction has no effect as bit 7 of the above AND
15216                                                                          ; can never be set, which is why this instruction was
15217                                                                          ; removed from later versions)
15218               
15219               DVL6:
15220                                                                          ; We now shift (S R Q) left until bit 7 of S is set,
15221                                                                          ; reducing Y by the number of shifts. This makes the
15222                                                                          ; bottom part of the division as large as possible, thus
15223                                                                          ; retaining as much accuracy as we can. When we come to
15224                                                                          ; return the final result, we shift the result by the
15225                                                                          ; total number of places in Y, and in the correct
15226                                                                          ; direction, to give us the correct result
15227                                                                          ;
15228                                                                          ; We set A to |S| above, so the following actually
15229                                                                          ; shifts (A R Q)
15230 4660 7084  18        sb   rone,ry                    ; DEY               ; Decrement the scale factor in Y
15231               
15232                      .asl @Q                         ; ASL Q             ; Shift (A R Q) to the left
     **** ****     > ASL
0001 4662 D1A0  30        movb @Q,rtmp
     4664 0090     
0002 4666 0246  22        andi rtmp,>ff00
     4668 FF00     
0003 466A 0A16  18        sla  rtmp,1
0004 466C D806  30        movb rtmp,@Q
     466E 0090     
                   < elite.a99
15233 4670 0208  20        li   rarg1,R                    ; ROL R
     4672 0091     
15234 4674 06A0  32        bl   @rol                       ;
     4676 FF36     
15235 4678 06A0  32        bl   @rola                      ; ROL A
     467A FF26     
15236               
15237 467C 15F1  14        jgt  DVL6                       ; BPL DVL6          ; Loop up to DVL6 to do another shift, until bit 7 of A
15238                                                                          ; is set and we can't shift left any further
15239               
15240               DV9:
15241                                                                          ; We have now shifted both the numerator and denominator
15242                                                                          ; left as far as they will go, keeping a tally of the
15243                                                                          ; overall scale factor of the various shifts in Y. We
15244                                                                          ; can now divide just the two highest bytes to get our
15245                                                                          ; result
15246 467E D800  30        movb ra,@Q                      ; STA Q             ; Set Q = A, the highest byte of the denominator
     4680 0090     
15247               
15248 4682 0200  20        li   ra,>fe*256                 ; LDA #254          ; Set R to have bits 1-7 set, so we can pass this to
     4684 FE00     
15249 4686 D800  30        movb ra,@R                      ; STA R             ; LL31 to act as the bit counter in the division
     4688 0091     
15250               
15251 468A D020  30        movb @P+2,ra                    ; LDA P+2           ; Set A to the highest byte of the numerator
     468C 001D     
15252               
15253 468E 0206  20        li   rtmp,LL31                  ; JSR LL31          ; Call LL31 to calculate:
     4690 D352     
15254 4692 06A0  32        bl   @jsr                       ;
     4694 FF10     
15255                                                                          ;
15256                                                                          ; R = 256 * A / Q
15257                                                                          ; = 256 * numerator / denominator
15258               
15259                                                                          ; The result of our division is now in R, so we just
15260                                                                          ; need to shift it back by the scale factor in Y
15261               
15262 4696 0200  20        li   ra,>00*256                 ; LDA #0            ; Set K(3 2 1) = 0 to hold the result (we populate K
     4698 0000     
15263 469A D800  30        movb ra,@K+1                    ; STA K+1           ; next)
     469C 003E     
15264 469E D800  30        movb ra,@K+2                    ; STA K+2
     46A0 003F     
15265 46A2 D800  30        movb ra,@K+3                    ; STA K+3
     46A4 0040     
15266               
15267 46A6 D002  18        movb ry,ra                      ; TYA               ; If Y is positive, jump to DV12
15268 46A8 1527  14        jgt  DV12                       ; BPL DV12
15269               
15270                                                                          ; If we get here then Y is negative, so we need to shift
15271                                                                          ; the result R to the left by Y places, and then set the
15272                                                                          ; correct sign for the result
15273               
15274 46AA D020  30        movb @R,ra                      ; LDA R             ; Set A = R
     46AC 0091     
15275               
15276               DVL8:
15277                      .asla                           ; ASL A             ; Shift (K+3 K+2 K+1 A) left
     **** ****     > ASLA
0001 46AE 0240  22        andi ra,>ff00
     46B0 FF00     
0002 46B2 0A10  18        sla  ra,1
                   < elite.a99
15278 46B4 0208  20        li   rarg1,K+1                  ; ROL K+1
     46B6 003E     
15279 46B8 06A0  32        bl   @rol                       ;
     46BA FF36     
15280 46BC 0208  20        li   rarg1,K+2                  ; ROL K+2
     46BE 003F     
15281 46C0 06A0  32        bl   @rol                       ;
     46C2 FF36     
15282 46C4 0208  20        li   rarg1,K+3                  ; ROL K+3
     46C6 0040     
15283 46C8 06A0  32        bl   @rol                       ;
     46CA FF36     
15284               
15285 46CC B084  18        ab   rone,ry                    ; INY               ; Increment the scale factor in Y
15286               
15287 46CE 16EF  14        jne  DVL8                       ; BNE DVL8          ; Loop back to DVL8 until we have shifted left by Y
15288                                                                          ; places
15289               
15290 46D0 D800  30        movb ra,@K                      ; STA K             ; Store A in K so the result is now in K(3 2 1 0)
     46D2 003D     
15291               
15292 46D4 D020  30        movb @K+3,ra                    ; LDA K+3           ; Set K+3 to the sign in T, which we set above to the
     46D6 0040     
15293 46D8 F020  30        socb @T,ra                      ; ORA T             ; correct sign for the result
     46DA 00D1     
15294 46DC D800  30        movb ra,@K+3                    ; STA K+3
     46DE 0040     
15295               
15296 46E0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     46E2 FF1C     
15297               
15298               DV13:
15299                                                                          ; If we get here then Y is zero, so we don't need to
15300                                                                          ; shift the result R, we just need to set the correct
15301                                                                          ; sign for the result
15302 46E4 D020  30        movb @R,ra                      ; LDA R             ; Store R in K so the result is now in K(3 2 1 0)
     46E6 0091     
15303 46E8 D800  30        movb ra,@K                      ; STA K
     46EA 003D     
15304               
15305 46EC D020  30        movb @T,ra                      ; LDA T             ; Set K+3 to the sign in T, which we set above to the
     46EE 00D1     
15306 46F0 D800  30        movb ra,@K+3                    ; STA K+3           ; correct sign for the result
     46F2 0040     
15307               
15308 46F4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     46F6 FF1C     
15309               
15310               DV12:
15311 46F8 13F5  14        jeq  DV13                       ; BEQ DV13          ; We jumped here having set A to the scale factor in Y,
15312                                                                          ; so this jumps up to DV13 if Y = 0
15313               
15314                                                                          ; If we get here then Y is positive and non-zero, so we
15315                                                                          ; need to shift the result R to the right by Y places
15316                                                                          ; and then set the correct sign for the result. We also
15317                                                                          ; know that K(3 2 1) will stay 0, as we are shifting the
15318                                                                          ; lowest byte to the right, so no set bits will make
15319                                                                          ; their way into the top three bytes
15320               
15321 46FA D020  30        movb @R,ra                      ; LDA R             ; Set A = R
     46FC 0091     
15322               
15323               DVL10:
15324 46FE 0910  18        srl  ra,1                       ; LSR A             ; Shift A right
15325               
15326 4700 7084  18        sb   rone,ry                    ; DEY               ; Decrement the scale factor in Y
15327               
15328 4702 16FD  14        jne  DVL10                      ; BNE DVL10         ; Loop back to DVL10 until we have shifted right by Y
15329                                                                          ; places
15330               
15331 4704 D800  30        movb ra,@K                      ; STA K             ; Store the shifted A in K so the result is now in
     4706 003D     
15332                                                                          ; K(3 2 1 0)
15333               
15334 4708 D020  30        movb @T,ra                      ; LDA T             ; Set K+3 to the sign in T, which we set above to the
     470A 00D1     
15335 470C D800  30        movb ra,@K+3                    ; STA K+3           ; correct sign for the result
     470E 0040     
15336               
15337 4710 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4712 FF1C     
15338               
15339               * ******************************************************************************
15340               *
15341               * Name: cntr
15342               * Type: Subroutine
15343               * Category: Dashboard
15344               * Summary: Apply damping to the pitch or roll dashboard indicator
15345               *
15346               * ------------------------------------------------------------------------------
15347               *
15348               * Apply damping to the value in X, where X ranges from 1 to 255 with 128 as the
15349               * centre point (so X represents a position on a centre-based dashboard slider,
15350               * such as pitch or roll). If the value is in the left-hand side of the slider
15351               * (1-127) then it bumps the value up by 1 so it moves towards the centre, and
15352               * if it's in the right-hand side, it reduces it by 1, also moving it towards the
15353               * centre.
15354               *
15355               * ******************************************************************************
15356               
15357               cntr_:
15358 4714 D020  30        movb @DAMP,ra                   ; LDA DAMP          ; If DAMP is non-zero, then keyboard damping is not
     4716 0F4A     
15359 4718 1608  14        jne  RE1                        ; BNE RE1           ; enabled, so jump to RE1 to return from the subroutine
15360               
15361 471A D001  18        movb rx,ra                      ; TXA               ; If X < 128, then it's in the left-hand side of the
15362 471C 1502  14        jgt  BUMP                       ; BPL BUMP          ; dashboard slider, so jump to BUMP to bump it up by 1,
15363                                                                          ; to move it closer to the centre
15364               
15365 471E 7044  18        sb   rone,rx                    ; DEX               ; Otherwise X >= 128, so it's in the right-hand side
15366 4720 1104  14        jlt  RE1                        ; BMI RE1           ; of the dashboard slider, so decrement X by 1, and if
15367                                                                          ; it's still >= 128, jump to RE1 to return from the
15368                                                                          ; subroutine, otherwise fall through to BUMP to undo
15369                                                                          ; the bump and then return
15370               
15371               BUMP:
15372 4722 B044  18        ab   rone,rx                    ; INX               ; Bump X up by 1, and if it hasn't overshot the end of
15373 4724 1602  14        jne  RE1                        ; BNE RE1           ; the dashboard slider, jump to RE1 to return from the
15374                                                                          ; subroutine, otherwise fall through to REDU to drop
15375                                                                          ; it down by 1 again
15376               
15377               REDU:
15378 4726 7044  18        sb   rone,rx                    ; DEX               ; Reduce X by 1, and if we have reached 0 jump up to
15379 4728 13FC  14        jeq  BUMP                       ; BEQ BUMP          ; BUMP to add 1, because we need the value to be in the
15380                                                                          ; range 1 to 255
15381               
15382               RE1:
15383 472A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     472C FF1C     
15384               
15385               * ******************************************************************************
15386               *
15387               * Name: BUMP2
15388               * Type: Subroutine
15389               * Category: Dashboard
15390               * Summary: Bump up the value of the pitch or roll dashboard indicator
15391               *
15392               * ------------------------------------------------------------------------------
15393               *
15394               * Increase ("bump up") X by A, where X is either the current rate of pitch or
15395               * the current rate of roll.
15396               *
15397               * The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
15398               * This is the amount by which the pitch or roll is currently changing, so 1
15399               * means it is decreasing at the maximum rate, 128 means it is not changing,
15400               * and 255 means it is increasing at the maximum rate. These values correspond
15401               * to the line on the DC or RL indicators on the dashboard, with 1 meaning full
15402               * left, 128 meaning the middle, and 255 meaning full right.
15403               *
15404               * If bumping up X would push it past 255, then X is set to 255.
15405               *
15406               * If keyboard auto-recentre is configured and the result is less than 128, we
15407               * bump X up to the mid-point, 128. This is the equivalent of having a roll or
15408               * pitch in the left half of the indicator, when increasing the roll or pitch
15409               * should jump us straight to the mid-point.
15410               *
15411               * ------------------------------------------------------------------------------
15412               *
15413               * Other entry points:
15414               *
15415               * RE2+2               Restore A from T and return from the subroutine
15416               *
15417               * ******************************************************************************
15418               
15419               BUMP2:
15420 472E D800  30        movb ra,@T                      ; STA T             ; Store argument A in T so we can restore it later
     4730 00D1     
15421               
15422 4732 D001  18        movb rx,ra                      ; TXA               ; Copy argument X into A
15423               
15424                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 4734 0A13  18        sla  rzero,1
                   < elite.a99
15425                                                                          ; C flag affecting the result
15426               
15427                      .adc @T,ra                      ; ADC T             ; Set X = A = argument X + argument A
     **** ****     > ADC
0001 4736 1701  14        jnc  !
0002 4738 B004  18        ab   rone,ra
0003               !:
0004 473A B020  30        ab   @T,ra
     473C 00D1     
                   < elite.a99
15428 473E D040  18        movb ra,rx                      ; TAX
15429               
15430 4740 1702  14        jnc  RE2                        ; BCC RE2           ; If the C flag is clear, then we didn't overflow, so
15431                                                                          ; jump to RE2 to auto-recentre and return the result
15432               
15433 4742 0201  20        li   rx,>ff*256                 ; LDX #255          ; We have an overflow, so set X to the maximum possible
     4744 FF00     
15434                                                                          ; value of 255
15435               
15436               RE2:
15437 4746 1511  14        jgt  RE3+2                      ; BPL RE3+2         ; If X has bit 7 clear (i.e. the result < 128), then
15438                                                                          ; jump to RE3+2 in routine REDU2 to do an auto-recentre,
15439                                                                          ; if configured, because the result is on the left side
15440                                                                          ; of the centre point of 128
15441               
15442                                                                          ; Jumps to RE2+2 end up here
15443               
15444 4748 D020  30        movb @T,ra                      ; LDA T             ; Restore the original argument A from T into A
     474A 00D1     
15445               
15446 474C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     474E FF1C     
15447               
15448               * ******************************************************************************
15449               *
15450               * Name: REDU2
15451               * Type: Subroutine
15452               * Category: Dashboard
15453               * Summary: Reduce the value of the pitch or roll dashboard indicator
15454               *
15455               * ------------------------------------------------------------------------------
15456               *
15457               * Reduce X by A, where X is either the current rate of pitch or the current
15458               * rate of roll.
15459               *
15460               * The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
15461               * This is the amount by which the pitch or roll is currently changing, so 1
15462               * means it is decreasing at the maximum rate, 128 means it is not changing,
15463               * and 255 means it is increasing at the maximum rate. These values correspond
15464               * to the line on the DC or RL indicators on the dashboard, with 1 meaning full
15465               * left, 128 meaning the middle, and 255 meaning full right.
15466               *
15467               * If reducing X would bring it below 1, then X is set to 1.
15468               *
15469               * If keyboard auto-recentre is configured and the result is greater than 128, we
15470               * reduce X down to the mid-point, 128. This is the equivalent of having a roll
15471               * or pitch in the right half of the indicator, when decreasing the roll or pitch
15472               * should jump us straight to the mid-point.
15473               *
15474               * ------------------------------------------------------------------------------
15475               *
15476               * Other entry points:
15477               *
15478               * RE3+2               Auto-recentre the value in X, if keyboard auto-recentre
15479               * is configured
15480               *
15481               * ******************************************************************************
15482               
15483               REDU2:
15484 4750 D800  30        movb ra,@T                      ; STA T             ; Store argument A in T so we can restore it later
     4752 00D1     
15485               
15486 4754 D001  18        movb rx,ra                      ; TXA               ; Copy argument X into A
15487               
15488                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 4756 0A15  18        sla  rmone,1
                   < elite.a99
15489                                                                          ; C flag affecting the result
15490               
15491                      .sbc @T,ra                      ; SBC T             ; Set X = A = argument X - argument A
     **** ****     > SBC
0001 4758 1801  14        joc  !
0002 475A 7004  18        sb   rone,ra
0003               !:
0004 475C 7020  30        sb   @T,ra
     475E 00D1     
                   < elite.a99
15492 4760 D040  18        movb ra,rx                      ; TAX
15493               
15494 4762 1802  14        joc  RE3                        ; BCS RE3           ; If the C flag is set, then we didn't underflow, so
15495                                                                          ; jump to RE3 to auto-recentre and return the result
15496               
15497 4764 0201  20        li   rx,>01*256                 ; LDX #1            ; We have an underflow, so set X to the minimum possible
     4766 0100     
15498                                                                          ; value, 1
15499               
15500               RE3:
15501 4768 15EF  14        jgt  RE2+2                      ; BPL RE2+2         ; If X has bit 7 clear (i.e. the result < 128), then
15502                                                                          ; jump to RE2+2 above to return the result as is,
15503                                                                          ; because the result is on the left side of the centre
15504                                                                          ; point of 128, so we don't need to auto-centre
15505               
15506                                                                          ; Jumps to RE3+2 end up here
15507               
15508                                                                          ; If we get here, then we need to apply auto-recentre,
15509                                                                          ; if it is configured
15510               
15511 476A D020  30        movb @DJD,ra                    ; LDA DJD           ; If keyboard auto-recentre is disabled, then
     476C 0F4B     
15512 476E 16EC  14        jne  RE2+2                      ; BNE RE2+2         ; jump to RE2+2 to restore A and return
15513               
15514 4770 0201  20        li   rx,>80*256                 ; LDX #128          ; If we get here then keyboard auto-recentre is enabled,
     4772 8000     
15515 4774 11E9  14        jlt  RE2+2                      ; BMI RE2+2         ; so set X to 128 (the middle of our range) and jump to
15516                                                                          ; RE2+2 to restore A and return from the subroutine
15517                                                                          ; (this BMI is effectively a JMP as bit 7 of X is always
15518                                                                          ; set)
15519               
15520               * ******************************************************************************
15521               *
15522               * Name: ARCTAN
15523               * Type: Subroutine
15524               * Category: Maths (Geometry)
15525               * Summary: Calculate A = arctan(P / Q)
15526               * Deep dive: The sine, cosine and arctan tables
15527               *
15528               * ------------------------------------------------------------------------------
15529               *
15530               * Calculate the following:
15531               *
15532               * A = arctan(P / Q)
15533               *
15534               * In other words, this finds the angle in the right-angled triangle where the
15535               * opposite side to angle A is length P and the adjacent side to angle A has
15536               * length Q, so:
15537               *
15538               * tan(A) = P / Q
15539               *
15540               * The result in A is an integer representing the angle in radians. The routine
15541               * returns values in the range 0 to 128, which covers 0 to 180 degrees (or 0 to
15542               * PI radians).
15543               *
15544               * ******************************************************************************
15545               
15546               ARCTAN:
15547 4776 D020  30        movb @P,ra                      ; LDA P             ; Set T1 = P EOR Q, which will have the sign of P * Q
     4778 001B     
15548                      .eor @Q                         ; EOR Q             ;
     **** ****     > EOR
0001 477A D1A0  30        movb @Q,rtmp
     477C 0090     
0002 477E 2806  18        xor  rtmp,ra
                   < elite.a99
15549               * AND #%10000000         \ The AND is commented out in the original source
15550 4780 D800  30        movb ra,@T1                     ; STA T1
     4782 0006     
15551               
15552 4784 D020  30        movb @Q,ra                      ; LDA Q             ; If Q = 0, jump to AR2 to return a right angle
     4786 0090     
15553 4788 132B  14        jeq  AR2                        ; BEQ AR2
15554               
15555                      .asla                           ; ASL A             ; Set Q = |Q| * 2 (this is a quick way of clearing the
     **** ****     > ASLA
0001 478A 0240  22        andi ra,>ff00
     478C FF00     
0002 478E 0A10  18        sla  ra,1
                   < elite.a99
15556 4790 D800  30        movb ra,@Q                      ; STA Q             ; sign bit, and we don't need to shift right again as we
     4792 0090     
15557                                                                          ; only ever use this value in the division with |P| * 2,
15558                                                                          ; which we set next)
15559               
15560 4794 D020  30        movb @P,ra                      ; LDA P             ; Set A = |P| * 2
     4796 001B     
15561                      .asla                           ; ASL A
     **** ****     > ASLA
0001 4798 0240  22        andi ra,>ff00
     479A FF00     
0002 479C 0A10  18        sla  ra,1
                   < elite.a99
15562               
15563 479E 9020  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, i.e. |P| > |Q|, jump to AR1 to swap P
     47A0 0090     
15564 47A2 180A  14        joc  AR1                        ; BCS AR1           ; and Q around, so we can still use the lookup table
15565               
15566 47A4 0206  20        li   rtmp,ARS1                  ; JSR ARS1          ; Call ARS1 to set the following from the lookup table:
     47A6 47FC     
15567 47A8 06A0  32        bl   @jsr                       ;
     47AA FF10     
15568                                                                          ;
15569                                                                          ; A = arctan(A / Q)
15570                                                                          ; = arctan(|P / Q|)
15571               
15572                      .sec                            ; SEC               ; Set the C flag so the SBC instruction in AR3 will be
     **** ****     > SEC
0001 47AC 0A15  18        sla  rmone,1
                   < elite.a99
15573                                                                          ; correct, should we jump there
15574               
15575               AR4:
15576 47AE D060  30        movb @T1,rx                     ; LDX T1            ; If T1 is negative, i.e. P and Q have different signs,
     47B0 0006     
15577 47B2 111A  14        jlt  AR3                        ; BMI AR3           ; jump down to AR3 to return arctan(-|P / Q|)
15578               
15579 47B4 0460  28        b    @rts                       ; RTS               ; Otherwise P and Q have the same sign, so our result is
     47B6 FF1C     
15580                                                                          ; correct and we can return from the subroutine
15581               
15582               AR1:
15583                                                                          ; We want to calculate arctan(t) where |t| > 1, so we
15584                                                                          ; can use the calculation described in the documentation
15585                                                                          ; for the ACT table, i.e. 64 - arctan(1 / t)
15586 47B8 D060  30        movb @Q,rx                      ; LDX Q             ; Swap the values in Q and P, using the fact that we
     47BA 0090     
15587 47BC D800  30        movb ra,@Q                      ; STA Q             ; called AR1 with A = P
     47BE 0090     
15588 47C0 D801  30        movb rx,@P                      ; STX P             ;
     47C2 001B     
15589 47C4 D001  18        movb rx,ra                      ; TXA               ; This also sets A = P (which now contains the original
15590                                                                          ; argument |Q|)
15591               
15592 47C6 0206  20        li   rtmp,ARS1                  ; JSR ARS1          ; Call ARS1 to set the following from the lookup table:
     47C8 47FC     
15593 47CA 06A0  32        bl   @jsr                       ;
     47CC FF10     
15594                                                                          ;
15595                                                                          ; A = arctan(A / Q)
15596                                                                          ; = arctan(|Q / P|)
15597                                                                          ; = arctan(1 / |P / Q|)
15598               
15599 47CE D800  30        movb ra,@T                      ; STA T             ; Set T = 64 - T
     47D0 00D1     
15600 47D2 0200  20        li   ra,>40*256                 ; LDA #64
     47D4 4000     
15601                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 47D6 1801  14        joc  !
0002 47D8 7004  18        sb   rone,ra
0003               !:
0004 47DA 7020  30        sb   @T,ra
     47DC 00D1     
                   < elite.a99
15602               
15603 47DE 18E7  14        joc  AR4                        ; BCS AR4           ; Jump to AR4 to continue the calculation (this BCS is
15604                                                                          ; effectively a JMP as the subtraction will never
15605                                                                          ; underflow, as ARS1 returns values in the range 0-31)
15606               
15607               AR2:
15608                                                                          ; If we get here then Q = 0, so tan(A) = infinity and
15609                                                                          ; A is a right angle, or 0.25 of a circle. We allocate
15610                                                                          ; 255 to a full circle, so we should return 63 for a
15611                                                                          ; right angle
15612 47E0 0200  20        li   ra,>3f*256                 ; LDA #63           ; Set A to 63, to represent a right angle
     47E2 3F00     
15613               
15614 47E4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     47E6 FF1C     
15615               
15616               AR3:
15617                                                                          ; A contains arctan(|P / Q|) but P and Q have different
15618                                                                          ; signs, so we need to return arctan(-|P / Q|), using
15619                                                                          ; the calculation described in the documentation for the
15620                                                                          ; ACT table, i.e. 128 - A
15621 47E8 D800  30        movb ra,@T                      ; STA T             ; Set A = 128 - A
     47EA 00D1     
15622 47EC 0200  20        li   ra,>80*256                 ; LDA #128          ;
     47EE 8000     
15623               * SEC                    \ The SEC instruction is commented out in the original
15624                      .sbc @T,ra                      ; SBC T             ; source, and isn't required as we did a SEC before
     **** ****     > SBC
0001 47F0 1801  14        joc  !
0002 47F2 7004  18        sb   rone,ra
0003               !:
0004 47F4 7020  30        sb   @T,ra
     47F6 00D1     
                   < elite.a99
15625                                                                          ; calling AR3
15626               
15627 47F8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     47FA FF1C     
15628               
15629               ARS1:
15630                                                                          ; This routine fetches arctan(A / Q) from the ACT table,
15631                                                                          ; so A will be set to an integer in the range 0 to 31
15632                                                                          ; that represents an angle from 0 to 45 degrees (or 0 to
15633                                                                          ; PI / 4 radians)
15634 47FC 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     47FE D344     
15635 4800 06A0  32        bl   @jsr                       ;
     4802 FF10     
15636                                                                          ;
15637                                                                          ; R = 256 * A / Q
15638               
15639 4804 D020  30        movb @R,ra                      ; LDA R             ; Set X = R / 8
     4806 0091     
15640 4808 0910  18        srl  ra,1                       ; LSR A             ; = 32 * A / Q
15641 480A 0910  18        srl  ra,1                       ; LSR A             ;
15642 480C 0910  18        srl  ra,1                       ; LSR A             ; so X has the value t * 32 where t = A / Q, which is
15643 480E D040  18        movb ra,rx                      ; TAX               ; what we need to look up values in the ACT table
15644               
15645 4810 D021  34        movb @ACT(rx),ra                ; LDA ACT,X         ; Fetch ACT+X from the ACT table into A, so now:
     4812 4818     
15646                                                                          ;
15647                                                                          ; A = value in ACT + X
15648                                                                          ; = value in ACT + (32 * A / Q)
15649                                                                          ; = arctan(A / Q)
15650               
15651 4814 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4816 FF1C     
15652               
15653               * ******************************************************************************
15654               *
15655               * Name: ACT
15656               * Type: Variable
15657               * Category: Maths (Geometry)
15658               * Summary: Arctan table
15659               * Deep dive: The sine, cosine and arctan tables
15660               *
15661               * ------------------------------------------------------------------------------
15662               *
15663               * This table contains lookup values for arctangent calculations involving angles
15664               * in the range 0 to 45 degrees (or 0 to PI / 4 radians).
15665               *
15666               * To calculate the value of theta in the following:
15667               *
15668               * theta = arctan(t)
15669               *
15670               * where 0 <= t < 1, we look up the value in:
15671               *
15672               * ACT + (t * 32)
15673               *
15674               * The result will be an integer representing the angle in radians, where 256
15675               * represents a full circle of 360 degrees (2 * PI radians). The result of the
15676               * lookup will therefore be an integer in the range 0 to 31, as this represents
15677               * 0 to 45 degrees (0 to PI / 4 radians).
15678               *
15679               * The table does not support values of t >= 1 or t < 0 directly, so if we need
15680               * to calculate the arctangent for an angle greater than 45 degrees, we can apply
15681               * the following calculation to the result from the table:
15682               *
15683               * * For t > 1, arctan(t) = 64 - arctan(1 / t)
15684               *
15685               * For negative values of t where -1 < t < 0, we can apply the following
15686               * calculation to the result from the table:
15687               *
15688               * * For t < 0, arctan(-t) = 128 - arctan(t)
15689               *
15690               * Finally, if t < -1, we can do the first calculation to get arctan(|t|), and
15691               * the second to get arctan(-|t|).
15692               *
15693               * ******************************************************************************
15694               
15695               ACT:
15696                      ; FOR I%, 0, 31
15697               
15698                      ; EQUB INT((128 / PI) * ATN(I% / 32) + 0.5) ;
15699               
15700                      ; NEXT
15701               
15702 4818 12              byte >12
15703 4819   13            byte >13
15704 481A 14              byte >14
15705 481B   15            byte >15
15706 481C 16              byte >16
15707 481D   17            byte >17
15708 481E 18              byte >18
15709 481F   19            byte >19
15710 4820 1A              byte >1a
15711 4821   1B            byte >1b
15712 4822 1B              byte >1b
15713 4823   1C            byte >1c
15714 4824 1D              byte >1d
15715 4825   1D            byte >1d
15716 4826 1E              byte >1e
15717 4827   1F            byte >1f
15718 4828 20              byte >20
15719 4829   20            byte >20
15720 482A 21              byte >21
15721 482B   21            byte >21
15722 482C 22              byte >22
15723 482D   22            byte >22
15724 482E 23              byte >23
15725 482F   24            byte >24
15726 4830 24              byte >24
15727 4831   24            byte >24
15728 4832 25              byte >25
15729 4833   25            byte >25
15730 4834 26              byte >26
15731 4835   26            byte >26
15732 4836 27              byte >27
15733 4837   27            byte >27
15734               
15735               * ******************************************************************************
15736               *
15737               * Name: WARP
15738               * Type: Subroutine
15739               * Category: Flight
15740               * Summary: Perform an in-system jump
15741               *
15742               * ------------------------------------------------------------------------------
15743               *
15744               * This is called when we press "J" during flight. The following checks are
15745               * performed:
15746               *
15747               * * Make sure we don't have any ships or space stations in the vicinity
15748               *
15749               * * Make sure we are not in witchspace
15750               *
15751               * * If we are facing the planet, make sure we aren't too close
15752               *
15753               * * If we are facing the sun, make sure we aren't too close
15754               *
15755               * If the above checks are passed, then we perform an in-system jump by moving
15756               * the sun and planet in the opposite direction to travel, so we appear to jump
15757               * in space. This means that any asteroids, cargo canisters or escape pods get
15758               * dragged along for the ride.
15759               *
15760               * ******************************************************************************
15761               
15762               WARP:
15773               
15774 4838 D020  30        movb @MANY+AST,ra               ; LDA MANY+AST      ; Set X to the total number of asteroids, escape pods
     483A 0D57     
15775                      .clc                            ; CLC               ; and cargo canisters in the vicinity
     **** ****     > CLC
0001 483C 0A13  18        sla  rzero,1
                   < elite.a99
15776                      .adc @MANY+ESC,ra               ; ADC MANY+ESC      ;
     **** ****     > ADC
0001 483E 1701  14        jnc  !
0002 4840 B004  18        ab   rone,ra
0003               !:
0004 4842 B020  30        ab   @MANY+ESC,ra
     4844 0D5A     
                   < elite.a99
15777                      .adc @MANY+OIL,ra               ; ADC MANY+OIL      ; This code saves one byte of memory over the code in
     **** ****     > ADC
0001 4846 1701  14        jnc  !
0002 4848 B004  18        ab   rone,ra
0003               !:
0004 484A B020  30        ab   @MANY+OIL,ra
     484C 0D58     
                   < elite.a99
15778 484E D040  18        movb ra,rx                      ; TAX               ; the source disc version. The second CLC is not needed
15779                                                                          ; as there is no way that adding the number of asteroids
15780                                                                          ; and the number of escape pods will cause a carry
15781               
15783               
15784 4850 D021  34        movb @FRIN+2(rx),ra             ; LDA FRIN+2,X      ; If the slot at FRIN+2+X is non-zero, then we have
     4852 0D42     
15785                                                                          ; something else in the vicinity besides asteroids,
15786                                                                          ; escape pods and cargo canisters, so to check whether
15787                                                                          ; we can jump, we first grab the slot contents into A
15788               
15789 4854 F020  30        socb @SSPR,ra                   ; ORA SSPR          ; If there is a space station nearby, then SSPR will
     4856 0D55     
15790                                                                          ; be non-zero, so OR'ing with SSPR will produce a
15791                                                                          ; non-zero result if either A or SSPR are non-zero
15792               
15793 4858 F020  30        socb @MJ,ra                     ; ORA MJ            ; If we are in witchspace, then MJ will be non-zero, so
     485A 0D5C     
15794                                                                          ; OR'ing with MJ will produce a non-zero result if
15795                                                                          ; either A or SSPR or MJ are non-zero
15796               
15797 485C 163A  14        jne  WA1                        ; BNE WA1           ; A is non-zero if we have either a ship or a space
15798                                                                          ; station in the vicinity, or we are in witchspace, in
15799                                                                          ; which case jump to WA1 to make a low beep to show that
15800                                                                          ; we can't do an in-system jump
15801               
15802 485E D0A0  30        movb @K.+8,ry                   ; LDY K%+8          ; Otherwise we can do an in-system jump, so now we fetch
     4860 0908     
15803                                                                          ; the byte at K%+8, which contains the z_sign for the
15804                                                                          ; first ship slot, i.e. the distance of the planet
15805               
15806 4862 1107  14        jlt  WA3                        ; BMI WA3           ; If the planet's z_sign is negative, then the planet
15807                                                                          ; is behind us, so jump to WA3 to skip the following
15808               
15809 4864 D080  18        movb ra,ry                      ; TAY               ; Set A = Y = 0 (as we didn't BNE above) so the call
15810                                                                          ; to MAS2 measures the distance to the planet
15811               
15812 4866 0206  20        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to set A to the largest distance to the
     4868 1786     
15813 486A 06A0  32        bl   @jsr                       ;
     486C FF10     
15814                                                                          ; planet in any of the three axes (we could also call
15815                                                                          ; routine m to do the same thing, as A = 0)
15816               
15824               
15825 486E 0910  18        srl  ra,1                       ; LSR A             ; If A < 2 then jump to WA1 to abort the in-system jump
15826 4870 1330  14        jeq  WA1                        ; BEQ WA1           ; with a low beep, as we are facing the planet and are
15827                                                                          ; too close to jump in that direction
15828                                                                          ;
15829                                                                          ; These instructions between them save one byte of
15830                                                                          ; memory over the CMP-based code in the source disc
15831                                                                          ; version, as LSR A is a one-byte opcode, while CMP #2
15832                                                                          ; takes up two bytes (though the code does exactly the
15833                                                                          ; same thing)
15834               
15836               
15837               WA3:
15838 4872 D0A0  30        movb @K.+NI.+8,ry               ; LDY K%+NI%+8      ; Fetch the z_sign (byte #8) of the second ship in the
     4874 092C     
15839                                                                          ; ship data workspace at K%, which is reserved for the
15840                                                                          ; sun or the space station (in this case it's the
15841                                                                          ; former, as we already confirmed there isn't a space
15842                                                                          ; station in the vicinity)
15843               
15844 4876 1108  14        jlt  WA2                        ; BMI WA2           ; If the sun's z_sign is negative, then the sun is
15845                                                                          ; behind us, so jump to WA2 to skip the following
15846               
15847 4878 0202  20        li   ry,(NI.)*256               ; LDY #NI%          ; Set Y to point to the offset of the ship data block
     487A 2400     
15848                                                                          ; for the sun, which is NI% (as each block is NI% bytes
15849                                                                          ; long, and the sun is the second block)
15850               
15851 487C 0206  20        li   rtmp,m_                    ; JSR m             ; Call m to set A to the largest distance to the sun
     487E 1782     
15852 4880 06A0  32        bl   @jsr                       ;
     4882 FF10     
15853                                                                          ; in any of the three axes
15854               
15862               
15863 4884 0910  18        srl  ra,1                       ; LSR A             ; If A < 2 then jump to WA1 to abort the in-system jump
15864 4886 1325  14        jeq  WA1                        ; BEQ WA1           ; with a low beep, as we are facing the planet and are
15865                                                                          ; too close to jump in that direction
15866                                                                          ;
15867                                                                          ; These instructions between them save one byte of
15868                                                                          ; memory over the CMP-based code in the source disc
15869                                                                          ; version, as LSR A is a one-byte opcode, while CMP #2
15870                                                                          ; takes up two bytes (though the code does exactly the
15871                                                                          ; same thing)
15872               
15874               
15875               WA2:
15876                                                                          ; If we get here, then we can do an in-system jump, as
15877                                                                          ; we don't have any ships or space stations in the
15878                                                                          ; vicinity, we are not in witchspace, and if we are
15879                                                                          ; facing the planet or the sun, we aren't too close to
15880                                                                          ; jump towards it
15881                                                                          ;
15882                                                                          ; We do an in-system jump by moving the sun and planet,
15883                                                                          ; rather than moving our own local bubble (this is why
15884                                                                          ; in-system jumps drag asteroids, cargo canisters and
15885                                                                          ; escape pods along for the ride). Specifically, we move
15886                                                                          ; them in the z-axis by a fixed amount in the opposite
15887                                                                          ; direction to travel, thus performing a jump towards
15888                                                                          ; our destination
15889 4888 0200  20        li   ra,>81*256                 ; LDA #&81          ; Set R = R = P = &81
     488A 8100     
15890 488C D800  30        movb ra,@S                      ; STA S
     488E 0092     
15891 4890 D800  30        movb ra,@R                      ; STA R
     4892 0091     
15892 4894 D800  30        movb ra,@P                      ; STA P
     4896 001B     
15893               
15894 4898 D020  30        movb @K.+8,ra                   ; LDA K%+8          ; Set A = z_sign for the planet
     489A 0908     
15895               
15896 489C 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     489E 44BA     
15897 48A0 06A0  32        bl   @jsr                       ;
     48A2 FF10     
15898                                                                          ; = (z_sign &81) + &8181
15899                                                                          ; = (z_sign &81) - &0181
15900                                                                          ;
15901                                                                          ; This moves the planet against the direction of travel
15902                                                                          ; by reducing z_sign by 1, as the above maths is:
15903                                                                          ;
15904                                                                          ; z_sign 00000000
15905                                                                          ; +   00000000 10000001
15906                                                                          ; -   00000001 10000001
15907                                                                          ;
15908                                                                          ; or:
15909                                                                          ;
15910                                                                          ; z_sign 00000000
15911                                                                          ; +   00000000 00000000
15912                                                                          ; -   00000001 00000000
15913                                                                          ;
15914                                                                          ; i.e. the high byte is z_sign - 1, making sure the sign
15915                                                                          ; is preserved
15916               
15917 48A4 D800  30        movb ra,@K.+8                   ; STA K%+8          ; Set the planet's z_sign to the high byte of the result
     48A6 0908     
15918               
15919 48A8 D020  30        movb @K.+NI.+8,ra               ; LDA K%+NI%+8      ; Set A = z_sign for the sun
     48AA 092C     
15920               
15921 48AC 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     48AE 44BA     
15922 48B0 06A0  32        bl   @jsr                       ;
     48B2 FF10     
15923                                                                          ; = (z_sign &81) + &8181
15924                                                                          ; = (z_sign &81) - &0181
15925                                                                          ;
15926                                                                          ; which moves the sun against the direction of travel
15927                                                                          ; by reducing z_sign by 1
15928               
15929 48B4 D800  30        movb ra,@K.+NI.+8               ; STA K%+NI%+8      ; Set the planet's z_sign to the high byte of the result
     48B6 092C     
15930               
15931 48B8 0200  20        li   ra,>01*256                 ; LDA #1            ; Temporarily set the view type to a non-zero value, so
     48BA 0100     
15932 48BC D800  30        movb ra,@QQ11                   ; STA QQ11          ; the call to LOOK1 below clears the screen before
     48BE 0096     
15933                                                                          ; switching to the space view
15934               
15935 48C0 D800  30        movb ra,@MCNT                   ; STA MCNT          ; Set the main loop counter to 1, so the next iteration
     48C2 0099     
15936                                                                          ; through the main loop will potentially spawn ships
15937                                                                          ; (see part 2 of the main game loop at me3)
15938               
15939 48C4 0910  18        srl  ra,1                       ; LSR A             ; Set EV, the extra vessels spawning counter, to 0
15940 48C6 D800  30        movb ra,@EV                     ; STA EV            ; (the LSR produces a 0 as A was previously 1)
     48C8 0D63     
15941               
15942 48CA D060  30        movb @VIEW,rx                   ; LDX VIEW          ; Set X to the current view (front, rear, left or right)
     48CC 0D5F     
15943 48CE 0460  28        b    @LOOK1                     ; JMP LOOK1         ; and jump to LOOK1 to initialise that view, returning
     48D0 4AC4     
15944                                                                          ; from the subroutine using a tail call
15945               
15946               WA1:
15947 48D2 0200  20        li   ra,>28*256                 ; LDA #40           ; If we get here then we can't do an in-system jump, so
     48D4 2800     
15948 48D6 0460  28        b    @NOISE                     ; JMP NOISE         ; call the NOISE routine with A = 40 to make a long, low
     48D8 CBB0     
15949                                                                          ; beep and return from the subroutine using a tail call
15950               
15951               * ******************************************************************************
15952               *
15953               * Name: LASLI
15954               * Type: Subroutine
15955               * Category: Drawing lines
15956               * Summary: Draw the laser lines for when we fire our lasers
15957               *
15958               * ------------------------------------------------------------------------------
15959               *
15960               * Draw the laser lines, aiming them to slightly different place each time so
15961               * they appear to flicker and dance. Also heat up the laser temperature and drain
15962               * some energy.
15963               *
15964               * ------------------------------------------------------------------------------
15965               *
15966               * Other entry points:
15967               *
15968               * LASLI2              Just draw the current laser lines without moving the
15969               * centre point, draining energy or heating up. This has
15970               * the effect of removing the lines from the screen
15971               *
15972               * LASLI-1             Contains an RTS
15973               *
15974               * ******************************************************************************
15975               
15976               LASLI:
15977 48DA 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     48DC C07C     
15978 48DE 06A0  32        bl   @jsr                       ;
     48E0 FF10     
15979               
15980 48E2 0240  22        andi ra,>07*256                 ; AND #7            ; Restrict A to a random value in the range 0 to 7
     48E4 0700     
15981               
15982                      .adi ((Y-4)*256)                ; ADC #Y-4          ; Set LASY to four pixels above the centre of the
     **** ****     > ADI
0001 48E6 1701  14        jnc  !
0002 48E8 B004  18        ab   rone,ra
0003               !:
0004 48EA 0220  22        ai   ra,((Y-4)*256)
     48EC 5C00     
                   < elite.a99
15983 48EE D800  30        movb ra,@LASY                   ; STA LASY          ; screen (#Y), plus our random number, so the laser
     48F0 0F15     
15984                                                                          ; dances above and below the centre point
15985               
15986 48F2 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     48F4 C07C     
15987 48F6 06A0  32        bl   @jsr                       ;
     48F8 FF10     
15988               
15989 48FA 0240  22        andi ra,>07*256                 ; AND #7            ; Restrict A to a random value in the range 0 to 7
     48FC 0700     
15990               
15991                      .adi ((X-4)*256)                ; ADC #X-4          ; Set LASX to four pixels left of the centre of the
     **** ****     > ADI
0001 48FE 1701  14        jnc  !
0002 4900 B004  18        ab   rone,ra
0003               !:
0004 4902 0220  22        ai   ra,((X-4)*256)
     4904 7C00     
                   < elite.a99
15992 4906 D800  30        movb ra,@LASX                   ; STA LASX          ; screen (#X), plus our random number, so the laser
     4908 0F14     
15993                                                                          ; dances to the left and right of the centre point
15994               
15995 490A D020  30        movb @GNTMP,ra                  ; LDA GNTMP         ; Add 8 to the laser temperature in GNTMP
     490C 0D61     
15996                      .adi (>08*256)                  ; ADC #8
     **** ****     > ADI
0001 490E 1701  14        jnc  !
0002 4910 B004  18        ab   rone,ra
0003               !:
0004 4912 0220  22        ai   ra,(>08*256)
     4914 0800     
                   < elite.a99
15997 4916 D800  30        movb ra,@GNTMP                  ; STA GNTMP
     4918 0D61     
15998               
15999 491A 0206  20        li   rtmp,DENGY                 ; JSR DENGY         ; Call DENGY to deplete our energy banks by 1
     491C ACE2     
16000 491E 06A0  32        bl   @jsr                       ;
     4920 FF10     
16001               
16002               LASLI2:
16003 4922 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view (i.e. QQ11 is non-zero)
     4924 0096     
16004 4926 1632  14        jne  PU1-1                      ; BNE PU1-1         ; then jump to MA9 to return from the main flight loop
16005                                                                          ; (as PU1-1 is an RTS)
16006               
16007 4928 0200  20        li   ra,>20*256                 ; LDA #32           ; Set A = 32 and Y = 224 for the first set of laser
     492A 2000     
16008 492C 0202  20        li   ry,>e0*256                 ; LDY #224          ; lines (the wider pair of lines)
     492E E000     
16009               
16010 4930 0206  20        li   rtmp,las_                  ; JSR las           ; Call las below to draw the first set of laser lines
     4932 4940     
16011 4934 06A0  32        bl   @jsr                       ;
     4936 FF10     
16012               
16013 4938 0200  20        li   ra,>30*256                 ; LDA #48           ; Fall through into las with A = 48 and Y = 208 to draw
     493A 3000     
16014 493C 0202  20        li   ry,>d0*256                 ; LDY #208          ; a second set of lines (the narrower pair)
     493E D000     
16015               
16016                                                                          ; The following routine draws two laser lines, one from
16017                                                                          ; the centre point down to point A on the bottom row,
16018                                                                          ; and the other from the centre point down to point Y
16019                                                                          ; on the bottom row. We therefore get lines from the
16020                                                                          ; centre point to points 32, 48, 208 and 224 along the
16021                                                                          ; bottom row, giving us the triangular laser effect
16022                                                                          ; we're after
16023               
16024               las_:
16025 4940 D800  30        movb ra,@X2                     ; STA X2            ; Set X2 = A
     4942 0033     
16026               
16027 4944 D020  30        movb @LASX,ra                   ; LDA LASX          ; Set (X1, Y1) to the random centre point we set above
     4946 0F14     
16028 4948 D800  30        movb ra,@X1                     ; STA X1
     494A 0031     
16029 494C D020  30        movb @LASY,ra                   ; LDA LASY
     494E 0F15     
16030 4950 D800  30        movb ra,@Y1                     ; STA Y1
     4952 0032     
16031               
16032 4954 0200  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
     4956 BF00     
16033 4958 D800  30        movb ra,@Y2                     ; STA Y2            ; y-coordinate of the mid-point of the space view, so
     495A 0034     
16034                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
16035                                                                          ; pixel row of the space view
16036               
16037 495C 0206  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
     495E 224E     
16038 4960 06A0  32        bl   @jsr                       ;
     4962 FF10     
16039                                                                          ; the centre point to (A, 191)
16040               
16041 4964 D020  30        movb @LASX,ra                   ; LDA LASX          ; Set (X1, Y1) to the random centre point we set above
     4966 0F14     
16042 4968 D800  30        movb ra,@X1                     ; STA X1
     496A 0031     
16043 496C D020  30        movb @LASY,ra                   ; LDA LASY
     496E 0F15     
16044 4970 D800  30        movb ra,@Y1                     ; STA Y1
     4972 0032     
16045               
16046 4974 D802  30        movb ry,@X2                     ; STY X2            ; Set X2 = Y
     4976 0033     
16047               
16048 4978 0200  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1, the y-coordinate of the bottom
     497A BF00     
16049 497C D800  30        movb ra,@Y2                     ; STA Y2            ; pixel row of the space view (as before)
     497E 0034     
16050               
16051 4980 0460  28        b    @LOIN                      ; JMP LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
     4982 224E     
16052                                                                          ; the centre point to (Y, 191), and return from
16053                                                                          ; the subroutine using a tail call
16054               
16055               * ******************************************************************************
16056               *
16057               * Name: PLUT
16058               * Type: Subroutine
16059               * Category: Flight
16060               * Summary: Flip the coordinate axes for the four different views
16061               * Deep dive: Flipping axes between space views
16062               *
16063               * ------------------------------------------------------------------------------
16064               *
16065               * This routine flips the relevant geometric axes in INWK depending on which
16066               * view we are looking through (front, rear, left, right).
16067               *
16068               * ------------------------------------------------------------------------------
16069               *
16070               * Other entry points:
16071               *
16072               * PU1-1               Contains an RTS
16073               *
16074               * ******************************************************************************
16075               
16076               PLUT:
16077 4984 D060  30        movb @VIEW,rx                   ; LDX VIEW          ; Load the current view into X:
     4986 0D5F     
16078                                                                          ;
16079                                                                          ; 0 = front
16080                                                                          ; 1 = rear
16081                                                                          ; 2 = left
16082                                                                          ; 3 = right
16083               
16084 4988 1602  14        jne  PU1                        ; BNE PU1           ; If the current view is the front view, return from the
16085 498A 0460  28        b    @rts                       ; RTS               ; subroutine, as the geometry in INWK is already correct
     498C FF1C     
16086               
16087               PU1:
16088 498E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the view, so now:
16089                                                                          ;
16090                                                                          ; 0 = rear
16091                                                                          ; 1 = left
16092                                                                          ; 2 = right
16093               
16094 4990 163A  14        jne  PU2                        ; BNE PU2           ; If the current view is left or right, jump to PU2,
16095                                                                          ; otherwise this is the rear view, so continue on
16096               
16097 4992 D020  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Flip the sign of x_sign
     4994 0055     
16098                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4996 0206  20        li   rtmp,(>80*256)
     4998 8000     
0002 499A 2806  18        xor  rtmp,ra
                   < elite.a99
16099 499C D800  30        movb ra,@INWK+2                 ; STA INWK+2
     499E 0055     
16100               
16101 49A0 D020  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Flip the sign of z_sign
     49A2 005B     
16102                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49A4 0206  20        li   rtmp,(>80*256)
     49A6 8000     
0002 49A8 2806  18        xor  rtmp,ra
                   < elite.a99
16103 49AA D800  30        movb ra,@INWK+8                 ; STA INWK+8
     49AC 005B     
16104               
16105 49AE D020  30        movb @INWK+10,ra                ; LDA INWK+10       ; Flip the sign of nosev_x_hi
     49B0 005D     
16106                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49B2 0206  20        li   rtmp,(>80*256)
     49B4 8000     
0002 49B6 2806  18        xor  rtmp,ra
                   < elite.a99
16107 49B8 D800  30        movb ra,@INWK+10                ; STA INWK+10
     49BA 005D     
16108               
16109 49BC D020  30        movb @INWK+14,ra                ; LDA INWK+14       ; Flip the sign of nosev_z_hi
     49BE 0061     
16110                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49C0 0206  20        li   rtmp,(>80*256)
     49C2 8000     
0002 49C4 2806  18        xor  rtmp,ra
                   < elite.a99
16111 49C6 D800  30        movb ra,@INWK+14                ; STA INWK+14
     49C8 0061     
16112               
16113 49CA D020  30        movb @INWK+16,ra                ; LDA INWK+16       ; Flip the sign of roofv_x_hi
     49CC 0063     
16114                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49CE 0206  20        li   rtmp,(>80*256)
     49D0 8000     
0002 49D2 2806  18        xor  rtmp,ra
                   < elite.a99
16115 49D4 D800  30        movb ra,@INWK+16                ; STA INWK+16
     49D6 0063     
16116               
16117 49D8 D020  30        movb @INWK+20,ra                ; LDA INWK+20       ; Flip the sign of roofv_z_hi
     49DA 0067     
16118                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49DC 0206  20        li   rtmp,(>80*256)
     49DE 8000     
0002 49E0 2806  18        xor  rtmp,ra
                   < elite.a99
16119 49E2 D800  30        movb ra,@INWK+20                ; STA INWK+20
     49E4 0067     
16120               
16121 49E6 D020  30        movb @INWK+22,ra                ; LDA INWK+22       ; Flip the sign of sidev_x_hi
     49E8 0069     
16122                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49EA 0206  20        li   rtmp,(>80*256)
     49EC 8000     
0002 49EE 2806  18        xor  rtmp,ra
                   < elite.a99
16123 49F0 D800  30        movb ra,@INWK+22                ; STA INWK+22
     49F2 0069     
16124               
16125 49F4 D020  30        movb @INWK+26,ra                ; LDA INWK+26       ; Flip the sign of roofv_z_hi
     49F6 006D     
16126                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49F8 0206  20        li   rtmp,(>80*256)
     49FA 8000     
0002 49FC 2806  18        xor  rtmp,ra
                   < elite.a99
16127 49FE D800  30        movb ra,@INWK+26                ; STA INWK+26
     4A00 006D     
16128               
16129 4A02 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4A04 FF1C     
16130               
16131               PU2:
16132                                                                          ; We enter this with X set to the view, as follows:
16133                                                                          ;
16134                                                                          ; 1 = left
16135                                                                          ; 2 = right
16136 4A06 0200  20        li   ra,>00*256                 ; LDA #0            ; Set RAT2 = 0 (left view) or -1 (right view)
     4A08 0000     
16137 4A0A 0281  22        ci   rx,>02*256                 ; CPX #2
     4A0C 0200     
16138 4A0E 06A0  32        bl   @rora                      ; ROR A
     4A10 FF4A     
16139 4A12 D800  30        movb ra,@RAT2                   ; STA RAT2
     4A14 00AB     
16140               
16141                      .eoi (>80*256)                  ; EOR #%10000000    ; Set RAT = -1 (left view) or 0 (right view)
     **** ****     > EOI
0001 4A16 0206  20        li   rtmp,(>80*256)
     4A18 8000     
0002 4A1A 2806  18        xor  rtmp,ra
                   < elite.a99
16142 4A1C D800  30        movb ra,@RAT                    ; STA RAT
     4A1E 00AA     
16143               
16144 4A20 D020  30        movb @INWK,ra                   ; LDA INWK          ; Swap x_lo and z_lo
     4A22 0053     
16145 4A24 D060  30        movb @INWK+6,rx                 ; LDX INWK+6
     4A26 0059     
16146 4A28 D800  30        movb ra,@INWK+6                 ; STA INWK+6
     4A2A 0059     
16147 4A2C D801  30        movb rx,@INWK                   ; STX INWK
     4A2E 0053     
16148               
16149 4A30 D020  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Swap x_hi and z_hi
     4A32 0054     
16150 4A34 D060  30        movb @INWK+7,rx                 ; LDX INWK+7
     4A36 005A     
16151 4A38 D800  30        movb ra,@INWK+7                 ; STA INWK+7
     4A3A 005A     
16152 4A3C D801  30        movb rx,@INWK+1                 ; STX INWK+1
     4A3E 0054     
16153               
16154 4A40 D020  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Swap x_sign and z_sign
     4A42 0055     
16155                      .eor @RAT                       ; EOR RAT           ; If left view, flip sign of new z_sign
     **** ****     > EOR
0001 4A44 D1A0  30        movb @RAT,rtmp
     4A46 00AA     
0002 4A48 2806  18        xor  rtmp,ra
                   < elite.a99
16156 4A4A D040  18        movb ra,rx                      ; TAX               ; If right view, flip sign of new x_sign
16157 4A4C D020  30        movb @INWK+8,ra                 ; LDA INWK+8
     4A4E 005B     
16158                      .eor @RAT2                      ; EOR RAT2
     **** ****     > EOR
0001 4A50 D1A0  30        movb @RAT2,rtmp
     4A52 00AB     
0002 4A54 2806  18        xor  rtmp,ra
                   < elite.a99
16159 4A56 D800  30        movb ra,@INWK+2                 ; STA INWK+2
     4A58 0055     
16160 4A5A D801  30        movb rx,@INWK+8                 ; STX INWK+8
     4A5C 005B     
16161               
16162 4A5E 0202  20        li   ry,>09*256                 ; LDY #9            ; Swap nosev_x_lo and nosev_z_lo
     4A60 0900     
16163 4A62 0206  20        li   rtmp,PUS1                  ; JSR PUS1          ; Swap nosev_x_hi and nosev_z_hi
     4A64 4A7A     
16164 4A66 06A0  32        bl   @jsr                       ;
     4A68 FF10     
16165                                                                          ; If left view, flip sign of new nosev_z_hi
16166                                                                          ; If right view, flip sign of new nosev_x_hi
16167               
16168 4A6A 0202  20        li   ry,>0f*256                 ; LDY #15           ; Swap roofv_x_lo and roofv_z_lo
     4A6C 0F00     
16169 4A6E 0206  20        li   rtmp,PUS1                  ; JSR PUS1          ; Swap roofv_x_hi and roofv_z_hi
     4A70 4A7A     
16170 4A72 06A0  32        bl   @jsr                       ;
     4A74 FF10     
16171                                                                          ; If left view, flip sign of new roofv_z_hi
16172                                                                          ; If right view, flip sign of new roofv_x_hi
16173               
16174 4A76 0202  20        li   ry,>15*256                 ; LDY #21           ; Swap sidev_x_lo and sidev_z_lo
     4A78 1500     
16175                                                                          ; Swap sidev_x_hi and sidev_z_hi
16176                                                                          ; If left view, flip sign of new sidev_z_hi
16177                                                                          ; If right view, flip sign of new sidev_x_hi
16178               
16179               PUS1:
16180 4A7A D022  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Swap the low x and z bytes for the vector in Y:
     4A7C 0053     
16181 4A7E D062  34        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ;
     4A80 0057     
16182 4A82 D880  38        movb ra,@INWK+4(ry)             ; STA INWK+4,Y      ; * For Y =  9 swap nosev_x_lo and nosev_z_lo
     4A84 0057     
16183 4A86 D881  38        movb rx,@INWK(ry)               ; STX INWK,Y        ; * For Y = 15 swap roofv_x_lo and roofv_z_lo
     4A88 0053     
16184                                                                          ; * For Y = 21 swap sidev_x_lo and sidev_z_lo
16185               
16186 4A8A D022  34        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Swap the high x and z bytes for the offset in Y:
     4A8C 0054     
16187                      .eor @RAT                       ; EOR RAT           ;
     **** ****     > EOR
0001 4A8E D1A0  30        movb @RAT,rtmp
     4A90 00AA     
0002 4A92 2806  18        xor  rtmp,ra
                   < elite.a99
16188 4A94 D040  18        movb ra,rx                      ; TAX               ; * If left view, flip sign of new z-coordinate
16189 4A96 D022  34        movb @INWK+5(ry),ra             ; LDA INWK+5,Y      ; * If right view, flip sign of new x-coordinate
     4A98 0058     
16190                      .eor @RAT2                      ; EOR RAT2
     **** ****     > EOR
0001 4A9A D1A0  30        movb @RAT2,rtmp
     4A9C 00AB     
0002 4A9E 2806  18        xor  rtmp,ra
                   < elite.a99
16191 4AA0 D880  38        movb ra,@INWK+1(ry)             ; STA INWK+1,Y
     4AA2 0054     
16192 4AA4 D881  38        movb rx,@INWK+5(ry)             ; STX INWK+5,Y
     4AA6 0058     
16193               
16194                                                                          ; Fall through into LOOK1 to return from the subroutine
16195               
16196               * ******************************************************************************
16197               *
16198               * Name: LOOK1
16199               * Type: Subroutine
16200               * Category: Flight
16201               * Summary: Initialise the space view
16202               *
16203               * ------------------------------------------------------------------------------
16204               *
16205               * Initialise the space view, with the direction of view given in X. This clears
16206               * the upper screen and draws the laser crosshairs, if the view in X has lasers
16207               * fitted. It also wipes all the ships from the scanner, so we can recalculate
16208               * ship positions for the new view (they get put back in the main flight loop).
16209               *
16210               * ------------------------------------------------------------------------------
16211               *
16212               * Arguments:
16213               *
16214               * X                   The space view to set:
16215               *
16216               * * 0 = front
16217               * * 1 = rear
16218               * * 2 = left
16219               * * 3 = right
16220               *
16221               * ------------------------------------------------------------------------------
16222               *
16223               * Other entry points:
16224               *
16225               * LO2                 Contains an RTS
16226               *
16227               * ******************************************************************************
16228               
16229               LO2:
16230 4AA8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4AAA FF1C     
16231               
16232               LQ:
16233 4AAC D801  30        movb rx,@VIEW                   ; STX VIEW          ; Set the current space view to X
     4AAE 0D5F     
16234               
16235 4AB0 0206  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     4AB2 4B2A     
16236 4AB4 06A0  32        bl   @jsr                       ;
     4AB6 FF10     
16237                                                                          ; and set the current view type in QQ11 to 0 (space
16238                                                                          ; view)
16239               
16240 4AB8 0206  20        li   rtmp,SIGHT                 ; JSR SIGHT         ; Draw the laser crosshairs
     4ABA 4AF0     
16241 4ABC 06A0  32        bl   @jsr                       ;
     4ABE FF10     
16242               
16243 4AC0 0460  28        b    @NWSTARS                   ; JMP NWSTARS       ; Set up a new stardust field and return from the
     4AC2 ABE6     
16244                                                                          ; subroutine using a tail call
16245               
16246               LOOK1:
16247 4AC4 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0, the type number of a space view
     4AC6 0000     
16248               
16249 4AC8 D0A0  30        movb @QQ11,ry                   ; LDY QQ11          ; If the current view is not a space view, jump up to LQ
     4ACA 0096     
16250 4ACC 16EF  14        jne  LQ                         ; BNE LQ            ; to set up a new space view
16251               
16252 4ACE 9060  30        cb   @VIEW,rx                   ; CPX VIEW          ; If the current view is already of type X, jump to LO2
     4AD0 0D5F     
16253 4AD2 13EA  14        jeq  LO2                        ; BEQ LO2           ; to return from the subroutine (as LO2 contains an RTS)
16254               
16255 4AD4 D801  30        movb rx,@VIEW                   ; STX VIEW          ; Change the current space view to X
     4AD6 0D5F     
16256               
16257 4AD8 0206  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     4ADA 4B2A     
16258 4ADC 06A0  32        bl   @jsr                       ;
     4ADE FF10     
16259                                                                          ; and set the current view type in QQ11 to 0 (space
16260                                                                          ; view)
16261               
16262 4AE0 0206  20        li   rtmp,FLIP                  ; JSR FLIP          ; Swap the x- and y-coordinates of all the stardust
     4AE2 2964     
16263 4AE4 06A0  32        bl   @jsr                       ;
     4AE6 FF10     
16264                                                                          ; particles and redraw the stardust field
16265               
16266 4AE8 0206  20        li   rtmp,WPSHPS                ; JSR WPSHPS        ; Wipe all the ships from the scanner and mark them all
     4AEA AC30     
16267 4AEC 06A0  32        bl   @jsr                       ;
     4AEE FF10     
16268                                                                          ; as not being shown on-screen
16269               
16270                                                                          ; And fall through into SIGHT to draw the laser
16271                                                                          ; crosshairs
16272               
16273               * ******************************************************************************
16274               *
16275               * Name: SIGHT
16276               * Type: Subroutine
16277               * Category: Flight
16278               * Summary: Draw the laser crosshairs
16279               *
16280               * ******************************************************************************
16281               
16282               SIGHT:
16283 4AF0 D0A0  30        movb @VIEW,ry                   ; LDY VIEW          ; Fetch the laser power for our new view
     4AF2 0D5F     
16284 4AF4 D022  34        movb @LASER(ry),ra              ; LDA LASER,Y
     4AF6 0310     
16285               
16286 4AF8 13D7  14        jeq  LO2                        ; BEQ LO2           ; If it is zero (i.e. there is no laser fitted to this
16287                                                                          ; view), jump to LO2 to return from the subroutine (as
16288                                                                          ; LO2 contains an RTS)
16289               
16290 4AFA 0200  20        li   ra,>80*256                 ; LDA #128          ; Set QQ19 to the x-coordinate of the centre of the
     4AFC 8000     
16291 4AFE D800  30        movb ra,@QQ19                   ; STA QQ19          ; screen
     4B00 007F     
16292               
16293 4B02 0200  20        li   ra,(Y-24)*256              ; LDA #Y-24         ; Set QQ19+1 to the y-coordinate of the centre of the
     4B04 4800     
16294 4B06 D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; screen, minus 24 (because TT15 will add 24 to the
     4B08 0080     
16295                                                                          ; coordinate when it draws the crosshairs)
16296               
16297 4B0A 0200  20        li   ra,>14*256                 ; LDA #20           ; Set QQ19+2 to size 20 for the crosshairs size
     4B0C 1400     
16298 4B0E D800  30        movb ra,@QQ19+2                 ; STA QQ19+2
     4B10 0081     
16299               
16300 4B12 0206  20        li   rtmp,TT15                  ; JSR TT15          ; Call TT15 to draw crosshairs of size 20 just to the
     4B14 5316     
16301 4B16 06A0  32        bl   @jsr                       ;
     4B18 FF10     
16302                                                                          ; left of the middle of the screen
16303               
16304 4B1A 0200  20        li   ra,>0a*256                 ; LDA #10           ; Set QQ19+2 to size 10 for the crosshairs size
     4B1C 0A00     
16305 4B1E D800  30        movb ra,@QQ19+2                 ; STA QQ19+2
     4B20 0081     
16306               
16307 4B22 0460  28        b    @TT15                      ; JMP TT15          ; Call TT15 to draw crosshairs of size 10 at the same
     4B24 5316     
16308                                                                          ; location, which will remove the centre part from the
16309                                                                          ; laser crosshairs, leaving a gap in the middle, and
16310                                                                          ; return from the subroutine using a tail call
16311               
16312               * ******************************************************************************
16313               *
16314               * Name: TT66
16315               * Type: Subroutine
16316               * Category: Drawing the screen
16317               * Summary: Clear the screen and set the current view type
16318               *
16319               * ------------------------------------------------------------------------------
16320               *
16321               * Clear the top part of the screen, draw a white border, and set the current
16322               * view type in QQ11 to A.
16323               *
16324               * ------------------------------------------------------------------------------
16325               *
16326               * Arguments:
16327               *
16328               * A                   The type of the new current view (see QQ11 for a list of
16329               * view types)
16330               *
16331               * ------------------------------------------------------------------------------
16332               *
16333               * Other entry points:
16334               *
16335               * TT66-2              Call TT66 with A = 1
16336               *
16337               * ******************************************************************************
16338               
16339 4B26 0200  20        li   ra,>01*256                 ; LDA #1            ; Set the view type to 1 when this is called via the
     4B28 0100     
16340                                                                          ; TT66-2 entry point
16341               
16342               TT66:
16343 4B2A D800  30        movb ra,@QQ11                   ; STA QQ11          ; Set the current view type in QQ11 to A
     4B2C 0096     
16344               
16345                                                                          ; Fall through into TTX66 to clear the screen and draw a
16346                                                                          ; white border
16347               
16348               * ******************************************************************************
16349               *
16350               * Name: TTX66
16351               * Type: Subroutine
16352               * Category: Drawing the screen
16353               * Summary: Clear the top part of the screen and draw a white border
16354               *
16355               * ------------------------------------------------------------------------------
16356               *
16357               * Clear the top part of the screen (the space view) and draw a white border
16358               * along the top and sides.
16359               *
16360               * ------------------------------------------------------------------------------
16361               *
16362               * Other entry points:
16363               *
16364               * BOX                 Just draw the border and (if this is a space view) the
16365               * view name. This can be used to remove the border and
16366               * view name, as it is drawn using EOR logic
16367               *
16368               * ******************************************************************************
16369               
16370               TTX66:
16371 4B2E 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     4B30 8000     
16372 4B32 D800  30        movb ra,@QQ17                   ; STA QQ17
     4B34 007E     
16373               
16380               
16381                      .asla                           ; ASL A             ; Set LAS2 to 0, as 128 << 1 = %10000000 << 1 = 0. This
     **** ****     > ASLA
0001 4B36 0240  22        andi ra,>ff00
     4B38 FF00     
0002 4B3A 0A10  18        sla  ra,1
                   < elite.a99
16382 4B3C D800  30        movb ra,@LAS2                   ; STA LAS2          ; stops any laser pulsing
     4B3E 0D5D     
16383               
16385               
16386 4B40 D800  30        movb ra,@DLY                    ; STA DLY           ; Set the delay in DLY to 0, to indicate that we are
     4B42 0D64     
16387                                                                          ; no longer showing an in-flight message, so any new
16388                                                                          ; in-flight messages will be shown instantly
16389               
16390 4B44 D800  30        movb ra,@de_                    ; STA de            ; Clear de, the flag that appends " DESTROYED" to the
     4B46 0D65     
16391                                                                          ; end of the next text token, so that it doesn't
16392               
16393 4B48 0201  20        li   rx,>60*256                 ; LDX #&60          ; Set X to the screen memory page for the top row of the
     4B4A 6000     
16394                                                                          ; screen (as screen memory starts at &6000)
16395               
16396               BOL1:
16397 4B4C 0206  20        li   rtmp,ZES1                  ; JSR ZES1          ; Call ZES1 to zero-fill the page in X, which clears
     4B4E C81E     
16398 4B50 06A0  32        bl   @jsr                       ;
     4B52 FF10     
16399                                                                          ; that character row on the screen
16400               
16401 4B54 B044  18        ab   rone,rx                    ; INX               ; Increment X to point to the next page, i.e. the next
16402                                                                          ; character row
16403               
16404 4B56 0281  22        ci   rx,>78*256                 ; CPX #&78          ; Loop back to BOL1 until we have cleared page &7700,
     4B58 7800     
16405 4B5A 16F8  14        jne  BOL1                       ; BNE BOL1          ; the last character row in the space view part of the
16406                                                                          ; screen (the top part)
16407               
16408 4B5C D060  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Fetch into X the number that's shown on-screen during
     4B5E 002F     
16409                                                                          ; the hyperspace countdown
16410               
16411 4B60 1304  14        jeq  BOX                        ; BEQ BOX           ; If the counter is zero then we are not counting down
16412                                                                          ; to hyperspace, so jump to BOX to skip the next
16413                                                                          ; instruction
16414               
16415 4B62 0206  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1),
     4B64 5D36     
16416 4B66 06A0  32        bl   @jsr                       ;
     4B68 FF10     
16417                                                                          ; i.e. print the hyperspace countdown in the top-left
16418                                                                          ; corner
16419               
16420               BOX:
16421 4B6A 0202  20        li   ry,>01*256                 ; LDY #1            ; Move the text cursor to row 1
     4B6C 0100     
16422 4B6E D802  30        movb ry,@YC                     ; STY YC
     4B70 002D     
16423               
16424 4B72 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to tt66 to skip
     4B74 0096     
16425 4B76 1616  14        jne  tt66_                      ; BNE tt66          ; displaying the view name
16426               
16427 4B78 0202  20        li   ry,>0b*256                 ; LDY #11           ; Move the text cursor to row 11
     4B7A 0B00     
16428 4B7C D802  30        movb ry,@XC                     ; STY XC
     4B7E 002C     
16429               
16430 4B80 D020  30        movb @VIEW,ra                   ; LDA VIEW          ; Load the current view into A:
     4B82 0D5F     
16431                                                                          ;
16432                                                                          ; 0 = front
16433                                                                          ; 1 = rear
16434                                                                          ; 2 = left
16435                                                                          ; 3 = right
16436               
16437 4B84 0260  22        ori  ra,>60*256                 ; ORA #&60          ; OR with &60 so we get a value of &60 to &63 (96 to 99)
     4B86 6000     
16438               
16439 4B88 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print recursive token 96 to 99, which will be in the
     4B8A A6E8     
16440 4B8C 06A0  32        bl   @jsr                       ;
     4B8E FF10     
16441                                                                          ; range "FRONT" to "RIGHT"
16442               
16443 4B90 0206  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     4B92 5E64     
16444 4B94 06A0  32        bl   @jsr                       ;
     4B96 FF10     
16445               
16446 4B98 0200  20        li   ra,>af*256                 ; LDA #175          ; Print recursive token 15 ("VIEW ")
     4B9A AF00     
16447 4B9C 0206  20        li   rtmp,TT27                  ; JSR TT27
     4B9E A6E8     
16448 4BA0 06A0  32        bl   @jsr                       ;
     4BA2 FF10     
16449               
16450               tt66_:
16451 4BA4 0201  20        li   rx,>00*256                 ; LDX #0            ; Set (X1, Y1) to (0, 0)
     4BA6 0000     
16452 4BA8 D801  30        movb rx,@X1                     ; STX X1
     4BAA 0031     
16453 4BAC D801  30        movb rx,@Y1                     ; STX Y1
     4BAE 0032     
16454               
16455 4BB0 D801  30        movb rx,@QQ17                   ; STX QQ17          ; Set QQ17 = 0 to switch to ALL CAPS
     4BB2 007E     
16456               
16457 4BB4 7044  18        sb   rone,rx                    ; DEX               ; Set X2 = 255
16458 4BB6 D801  30        movb rx,@X2                     ; STX X2
     4BB8 0033     
16459               
16460 4BBA 0206  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1), so
     4BBC 25EE     
16461 4BBE 06A0  32        bl   @jsr                       ;
     4BC0 FF10     
16462                                                                          ; that's (0, 0) to (255, 0), along the very top of the
16463                                                                          ; screen
16464               
16465 4BC2 0200  20        li   ra,>02*256                 ; LDA #2            ; Set X1 = X2 = 2
     4BC4 0200     
16466 4BC6 D800  30        movb ra,@X1                     ; STA X1
     4BC8 0031     
16467 4BCA D800  30        movb ra,@X2                     ; STA X2
     4BCC 0033     
16468               
16469 4BCE 0206  20        li   rtmp,BOS2                  ; JSR BOS2          ; Call BOS2 below, which will call BOS1 twice, and then
     4BD0 4BD6     
16470 4BD2 06A0  32        bl   @jsr                       ;
     4BD4 FF10     
16471                                                                          ; fall through into BOS2 again, so we effectively do
16472                                                                          ; BOS1 four times, decrementing X1 and X2 each time
16473                                                                          ; before calling LOIN, so this whole loop-within-a-loop
16474                                                                          ; mind-bender ends up drawing these four lines:
16475                                                                          ;
16476                                                                          ; (1, 0)   to (1, 191)
16477                                                                          ; (0, 0)   to (0, 191)
16478                                                                          ; (255, 0) to (255, 191)
16479                                                                          ; (254, 0) to (254, 191)
16480                                                                          ;
16481                                                                          ; So that's a 2-pixel wide vertical border along the
16482                                                                          ; left edge of the upper part of the screen, and a
16483                                                                          ; 2-pixel wide vertical border along the right edge
16484               
16485               BOS2:
16486 4BD6 0206  20        li   rtmp,BOS1                  ; JSR BOS1          ; Call BOS1 below and then fall through into it, which
     4BD8 4BDE     
16487 4BDA 06A0  32        bl   @jsr                       ;
     4BDC FF10     
16488                                                                          ; ends up running BOS1 twice. This is all part of the
16489                                                                          ; loop-the-loop border-drawing mind-bender explained
16490                                                                          ; above
16491               
16492               BOS1:
16493 4BDE 0200  20        li   ra,>00*256                 ; LDA #0            ; Set Y1 = 0
     4BE0 0000     
16494 4BE2 D800  30        movb ra,@Y1                     ; STA Y1
     4BE4 0032     
16495               
16496 4BE6 0200  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
     4BE8 BF00     
16497 4BEA D800  30        movb ra,@Y2                     ; STA Y2            ; y-coordinate of the mid-point of the space view, so
     4BEC 0034     
16498                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
16499                                                                          ; pixel row of the space view
16500               
16501 4BEE 7004  18        sb   rone,ra                    ; DEC X1            ; Decrement X1 and X2
16502 4BF0 7004  18        sb   rone,ra                    ; DEC X2
16503               
16504 4BF2 0460  28        b    @LOIN                      ; JMP LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), and return from
     4BF4 224E     
16505                                                                          ; the subroutine using a tail call
16506               
16507               * ******************************************************************************
16508               *
16509               * Name: DELAY
16510               * Type: Subroutine
16511               * Category: Utility routines
16512               * Summary: Wait for a specified time, in 1/50s of a second
16513               *
16514               * ------------------------------------------------------------------------------
16515               *
16516               * Wait for the number of vertical syncs given in Y, so this effectively waits
16517               * for Y/50 of a second (as the vertical sync occurs 50 times a second).
16518               *
16519               * ------------------------------------------------------------------------------
16520               *
16521               * Arguments:
16522               *
16523               * Y                   The number of vertical sync events to wait for
16524               *
16525               * ------------------------------------------------------------------------------
16526               *
16527               * Other entry points:
16528               *
16529               * DEL8                Wait for 8/50 of a second (0.16 seconds)
16530               *
16531               * DELAY-5             Wait for 2/50 of a second (0.04 seconds)
16532               *
16533               * ******************************************************************************
16534               
16535 4BF6 0202  20        li   ry,>02*256                 ; LDY #2            ; Set Y to 2 vertical syncs
     4BF8 0200     
16536               
16537 4BFA 2C              byte >2c                                            ; Skip the next instruction by turning it into
16538                                                                          ; &2C &A0 &08, or BIT &08A0, which does nothing apart
16539                                                                          ; from affect the flags
16540               
16541               DEL8:
16542 4BFC 0202  20        li   ry,>08*256                 ; LDY #8            ; Set Y to 8 vertical syncs and fall through into DELAY
     4BFE 0800     
16543                                                                          ; to wait for this long
16544               
16545               DELAY:
16546 4C00 0206  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     4C02 4DE2     
16547 4C04 06A0  32        bl   @jsr                       ;
     4C06 FF10     
16548                                                                          ; screen gets drawn
16549               
16550 4C08 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter in Y
16551               
16552 4C0A 16FA  14        jne  DELAY                      ; BNE DELAY         ; If Y isn't yet at zero, jump back to DELAY to wait
16553                                                                          ; for another vertical sync
16554               
16555 4C0C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4C0E FF1C     
16556               
16557               * ******************************************************************************
16558               *
16559               * Name: hm
16560               * Type: Subroutine
16561               * Category: Charts
16562               * Summary: Select the closest system and redraw the chart crosshairs
16563               *
16564               * ------------------------------------------------------------------------------
16565               *
16566               * Set the system closest to galactic coordinates (QQ9, QQ10) as the selected
16567               * system, redraw the crosshairs on the chart accordingly (if they are being
16568               * shown), and, if this is not a space view, clear the bottom three text rows of
16569               * the screen.
16570               *
16571               * ******************************************************************************
16572               
16573               hm_:
16574 4C10 0206  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     4C12 5872     
16575 4C14 06A0  32        bl   @jsr                       ;
     4C16 FF10     
16576                                                                          ; which will erase the crosshairs currently there
16577               
16578 4C18 0206  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     4C1A 5AB8     
16579 4C1C 06A0  32        bl   @jsr                       ;
     4C1E FF10     
16580                                                                          ; (QQ9, QQ10)
16581               
16582 4C20 0206  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     4C22 5872     
16583 4C24 06A0  32        bl   @jsr                       ;
     4C26 FF10     
16584                                                                          ; which will draw the crosshairs at our current home
16585                                                                          ; system
16586               
16587 4C28 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is a space view, return from the subroutine
     4C2A 0096     
16588 4C2C 132A  14        jeq  SC5                        ; BEQ SC5           ; (as SC5 contains an RTS)
16589               
16590                                                                          ; Otherwise fall through into CLYNS to clear space at
16591                                                                          ; the bottom of the screen
16592               
16593               * ******************************************************************************
16594               *
16595               * Name: CLYNS
16596               * Type: Subroutine
16597               * Category: Drawing the screen
16598               * Summary: Clear the bottom three text rows of the mode 4 screen
16599               *
16600               * ------------------------------------------------------------------------------
16601               *
16602               * This routine clears some space at the bottom of the screen and moves the text
16603               * cursor to column 1, row 21.
16604               *
16605               * Specifically, it zeroes the following screen locations:
16606               *
16607               * &7507 to &75F0
16608               * &7607 to &76F0
16609               * &7707 to &77F0
16610               *
16611               * which clears the three bottom text rows of the mode 4 screen (rows 21 to 23),
16612               * clearing each row from text column 1 to 30 (so it doesn't overwrite the box
16613               * border in columns 0 and 32, or the last usable column in column 31).
16614               *
16615               * ------------------------------------------------------------------------------
16616               *
16617               * Returns:
16618               *
16619               * A                   A is set to 0
16620               *
16621               * Y                   Y is set to 0
16622               *
16623               * ******************************************************************************
16624               
16625               CLYNS:
16626 4C2E 0200  20        li   ra,>14*256                 ; LDA #20           ; Move the text cursor to row 20, near the bottom of
     4C30 1400     
16627 4C32 D800  30        movb ra,@YC                     ; STA YC            ; the screen
     4C34 002D     
16628               
16629 4C36 0200  20        li   ra,>75*256                 ; LDA #&75          ; Set the two-byte value in SC to &7507
     4C38 7500     
16630 4C3A D800  30        movb ra,@SC+1                   ; STA SC+1
     4C3C 0008     
16631 4C3E 0200  20        li   ra,>07*256                 ; LDA #7
     4C40 0700     
16632 4C42 D800  30        movb ra,@SC                     ; STA SC
     4C44 0007     
16633               
16634 4C46 0206  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline, which will move the text cursor down
     4C48 4EE6     
16635 4C4A 06A0  32        bl   @jsr                       ;
     4C4C FF10     
16636                                                                          ; a line (to row 21) and back to column 1
16637               
16638 4C4E 0200  20        li   ra,>00*256                 ; LDA #0            ; Call LYN to clear the pixels from &7507 to &75F0
     4C50 0000     
16639 4C52 0206  20        li   rtmp,LYN                   ; JSR LYN
     4C54 4C6C     
16640 4C56 06A0  32        bl   @jsr                       ;
     4C58 FF10     
16641               
16642 4C5A B004  18        ab   rone,ra                    ; INC SC+1          ; Increment SC+1 so SC points to &7607
16643               
16644 4C5C 0206  20        li   rtmp,LYN                   ; JSR LYN           ; Call LYN to clear the pixels from &7607 to &76F0
     4C5E 4C6C     
16645 4C60 06A0  32        bl   @jsr                       ;
     4C62 FF10     
16646               
16647 4C64 B004  18        ab   rone,ra                    ; INC SC+1          ; Increment SC+1 so SC points to &7707
16648               
16649 4C66 B084  18        ab   rone,ry                    ; INY               ; Move the text cursor to column 1 (as LYN sets Y to 0)
16650 4C68 D802  30        movb ry,@XC                     ; STY XC
     4C6A 002C     
16651               
16652                                                                          ; Fall through into LYN to clear the pixels from &7707
16653                                                                          ; to &77F0
16654               
16655               * ******************************************************************************
16656               *
16657               * Name: LYN
16658               * Type: Subroutine
16659               * Category: Drawing the screen
16660               * Summary: Clear most of a row of pixels
16661               *
16662               * ------------------------------------------------------------------------------
16663               *
16664               * Set pixels 0-233 to the value in A, starting at the pixel pointed to by SC.
16665               *
16666               * ------------------------------------------------------------------------------
16667               *
16668               * Arguments:
16669               *
16670               * A                   The value to store in pixels 1-233 (the only value that
16671               * is actually used is A = 0, which clears those pixels)
16672               *
16673               * ------------------------------------------------------------------------------
16674               *
16675               * Returns:
16676               *
16677               * Y                   Y is set to 0
16678               *
16679               * ------------------------------------------------------------------------------
16680               *
16681               * Other entry points:
16682               *
16683               * SC5                 Contains an RTS
16684               *
16685               * ******************************************************************************
16686               
16687               LYN:
16688 4C6C 0202  20        li   ry,>e9*256                 ; LDY #233          ; Set up a counter in Y to count down from pixel 233
     4C6E E900     
16689               
16690               EE2:
16691                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Store A in the Y-th byte after the address pointed to
     **** ****     > ST_IND_Y_IDX
0001 4C70 D820  50        movb @SC,@rtmplb
     4C72 0007     
     4C74 2079     
0002 4C76 D1A0  30        movb @SC+1,rtmp
     4C78 0008     
0003 4C7A A182  18        a    ry,rtmp
0004 4C7C D580  30        movb RA,*rtmp
                   < elite.a99
16692                                                                          ; by SC
16693               
16694 4C7E 7084  18        sb   rone,ry                    ; DEY               ; Decrement Y
16695               
16696 4C80 16F7  14        jne  EE2                        ; BNE EE2           ; Loop back until Y is zero
16697               
16698               SC5:
16699 4C82 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4C84 FF1C     
16700               
16701               * ******************************************************************************
16702               *
16703               * Name: SCAN
16704               * Type: Subroutine
16705               * Category: Dashboard
16706               * Summary: Display the current ship on the scanner
16707               * Deep dive: The 3D scanner
16708               *
16709               * ------------------------------------------------------------------------------
16710               *
16711               * This is used both to display a ship on the scanner, and to erase it again.
16712               *
16713               * ------------------------------------------------------------------------------
16714               *
16715               * Arguments:
16716               *
16717               * INWK                The ship's data block
16718               *
16719               * ******************************************************************************
16720               
16721               SCAN:
16722 4C86 D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the ship's scanner flag from byte #31
     4C88 0072     
16723               
16724 4C8A 0240  22        andi ra,>10*256                 ; AND #%00010000    ; If bit 4 is clear then the ship should not be shown
     4C8C 1000     
16725 4C8E 13F9  14        jeq  SC5                        ; BEQ SC5           ; on the scanner, so return from the subroutine (as SC5
16726                                                                          ; contains an RTS)
16727               
16728 4C90 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship's type from TYPE into A
     4C92 009B     
16729               
16730 4C94 11F6  14        jlt  SC5                        ; BMI SC5           ; If this is the planet or the sun, then the type will
16731                                                                          ; have bit 7 set and we don't want to display it on the
16732                                                                          ; scanner, so return from the subroutine (as SC5
16733                                                                          ; contains an RTS)
16734               
16735 4C96 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Set X to the default scanner colour of green/cyan
     4C98 FF00     
16736                                                                          ; (a 4-pixel mode 5 byte in colour 3)
16737               
16738               * CMP #TGL               \ These instructions are commented out in the original
16739               * BEQ SC49               \ source. Along with the block just below, they would
16740                                                                          ; set X to colour 1 (red) for asteroids, cargo canisters
16741                                                                          ; and escape pods, rather than green/cyan. Presumably
16742                                                                          ; they decided it didn't work that well against the red
16743                                                                          ; ellipse and took this code out for release
16744               
16745 4C9A 0280  22        ci   ra,(MSL)*256               ; CMP #MSL          ; If this is not a missile, skip the following
     4C9C 0900     
16746 4C9E 1602  14        jne  B47                        ; BNE B47           ; instruction
16747               
16748 4CA0 0201  20        li   rx,>f0*256                 ; LDX #&F0          ; This is a missile, so set X to colour 2 (yellow/white)
     4CA2 F000     
16749               
16750               B47:
16751               * CMP #AST               \ These instructions are commented out in the original
16752               * BCC P%+4               \ source. See above for an explanation of what they do
16753               * LDX #&0F
16754               * .SC49
16755 4CA4 D801  30        movb rx,@COL                    ; STX COL           ; Store X, the colour of this ship on the scanner, in
     4CA6 00A2     
16756                                                                          ; COL
16757               
16758 4CA8 D020  30        movb @INWK+1,ra                 ; LDA INWK+1        ; If any of x_hi, y_hi and z_hi have a 1 in bit 6 or 7,
     4CAA 0054     
16759 4CAC F020  30        socb @INWK+4,ra                 ; ORA INWK+4        ; then the ship is too far away to be shown on the
     4CAE 0057     
16760 4CB0 F020  30        socb @INWK+7,ra                 ; ORA INWK+7        ; scanner, so return from the subroutine (as SC5
     4CB2 005A     
16761 4CB4 0240  22        andi ra,>c0*256                 ; AND #%11000000    ; contains an RTS)
     4CB6 C000     
16762 4CB8 16E4  14        jne  SC5                        ; BNE SC5
16763               
16764                                                                          ; If we get here, we know x_hi, y_hi and z_hi are all
16765                                                                          ; 63 (%00111111) or less
16766               
16767                                                                          ; Now, we convert the x_hi coordinate of the ship into
16768                                                                          ; the screen x-coordinate of the dot on the scanner,
16769                                                                          ; using the following (see the deep dive on "The 3D
16770                                                                          ; scanner" for an explanation):
16771                                                                          ;
16772                                                                          ; X1 = 123 + (x_sign x_hi)
16773               
16774 4CBA D020  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Set A = x_hi
     4CBC 0054     
16775               
16776                      .clc                            ; CLC               ; Clear the C flag so we can do addition below
     **** ****     > CLC
0001 4CBE 0A13  18        sla  rzero,1
                   < elite.a99
16777               
16778 4CC0 D060  30        movb @INWK+2,rx                 ; LDX INWK+2        ; Set X = x_sign
     4CC2 0055     
16779               
16780 4CC4 1507  14        jgt  SC2                        ; BPL SC2           ; If x_sign is positive, skip the following
16781               
16782                      .eoi (>ff*256)                  ; EOR #%11111111    ; x_sign is negative, so flip the bits in A and add 1
     **** ****     > EOI
0001 4CC6 0206  20        li   rtmp,(>FF*256)
     4CC8 FF00     
0002 4CCA 2806  18        xor  rtmp,ra
                   < elite.a99
16783                      .adi (>01*256)                  ; ADC #1            ; to make it a negative number (bit 7 will now be set
     **** ****     > ADI
0001 4CCC 1701  14        jnc  !
0002 4CCE B004  18        ab   rone,ra
0003               !:
0004 4CD0 0220  22        ai   ra,(>01*256)
     4CD2 0100     
                   < elite.a99
16784                                                                          ; as we confirmed above that bits 6 and 7 are clear). So
16785                                                                          ; this gives A the sign of x_sign and gives it a value
16786                                                                          ; range of -63 (%11000001) to 0
16787               
16788               SC2:
16789                      .adi (>7b*256)                  ; ADC #123          ; Set X1 = 123 + (x_sign x_hi)
     **** ****     > ADI
0001 4CD4 1701  14        jnc  !
0002 4CD6 B004  18        ab   rone,ra
0003               !:
0004 4CD8 0220  22        ai   ra,(>7B*256)
     4CDA 7B00     
                   < elite.a99
16790 4CDC D800  30        movb ra,@X1                     ; STA X1
     4CDE 0031     
16791               
16792                                                                          ; Next, we convert the z_hi coordinate of the ship into
16793                                                                          ; the y-coordinate of the base of the ship's stick,
16794                                                                          ; like this (see the deep dive on "The 3D scanner" for
16795                                                                          ; an explanation):
16796                                                                          ;
16797                                                                          ; SC = 220 - (z_sign z_hi) / 4
16798                                                                          ;
16799                                                                          ; though the following code actually does it like this:
16800                                                                          ;
16801                                                                          ; SC = 255 - (35 + z_hi / 4)
16802               
16803 4CE0 D020  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set A = z_hi / 4
     4CE2 005A     
16804 4CE4 0910  18        srl  ra,1                       ; LSR A             ;
16805 4CE6 0910  18        srl  ra,1                       ; LSR A             ; So A is in the range 0-15
16806               
16807                      .clc                            ; CLC               ; Clear the C flag for the addition below
     **** ****     > CLC
0001 4CE8 0A13  18        sla  rzero,1
                   < elite.a99
16808               
16809 4CEA D060  30        movb @INWK+8,rx                 ; LDX INWK+8        ; Set X = z_sign
     4CEC 005B     
16810               
16811 4CEE 1504  14        jgt  SC3                        ; BPL SC3           ; If z_sign is positive, skip the following
16812               
16813                      .eoi (>ff*256)                  ; EOR #%11111111    ; z_sign is negative, so flip the bits in A and set the
     **** ****     > EOI
0001 4CF0 0206  20        li   rtmp,(>FF*256)
     4CF2 FF00     
0002 4CF4 2806  18        xor  rtmp,ra
                   < elite.a99
16814                      .sec                            ; SEC               ; C flag. As above, this makes A negative, this time
     **** ****     > SEC
0001 4CF6 0A15  18        sla  rmone,1
                   < elite.a99
16815                                                                          ; with a range of -16 (%11110000) to -1 (%11111111). And
16816                                                                          ; as we are about to do an ADC, the SEC effectively adds
16817                                                                          ; another 1 to that value, giving a range of -15 to 0
16818               
16819               SC3:
16820                      .adi (>23*256)                  ; ADC #35           ; Set A = 35 + A to give a number in the range 20 to 50
     **** ****     > ADI
0001 4CF8 1701  14        jnc  !
0002 4CFA B004  18        ab   rone,ra
0003               !:
0004 4CFC 0220  22        ai   ra,(>23*256)
     4CFE 2300     
                   < elite.a99
16821               
16822                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip all the bits and store in SC, so SC is in the
     **** ****     > EOI
0001 4D00 0206  20        li   rtmp,(>FF*256)
     4D02 FF00     
0002 4D04 2806  18        xor  rtmp,ra
                   < elite.a99
16823 4D06 D800  30        movb ra,@SC                     ; STA SC            ; range 205 to 235, with a higher z_hi giving a lower SC
     4D08 0007     
16824               
16825                                                                          ; Now for the stick height, which we calculate using the
16826                                                                          ; following (see the deep dive on "The 3D scanner" for
16827                                                                          ; an explanation):
16828                                                                          ;
16829                                                                          ; A = - (y_sign y_hi) / 2
16830               
16831 4D0A D020  30        movb @INWK+4,ra                 ; LDA INWK+4        ; Set A = y_hi / 2
     4D0C 0057     
16832 4D0E 0910  18        srl  ra,1                       ; LSR A
16833               
16834                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 4D10 0A13  18        sla  rzero,1
                   < elite.a99
16835               
16836 4D12 D060  30        movb @INWK+5,rx                 ; LDX INWK+5        ; Set X = y_sign
     4D14 0058     
16837               
16838 4D16 1104  14        jlt  SCD6                       ; BMI SCD6          ; If y_sign is negative, skip the following, as we
16839                                                                          ; already have a positive value in A
16840               
16841                      .eoi (>ff*256)                  ; EOR #%11111111    ; y_sign is positive, so flip the bits in A and set the
     **** ****     > EOI
0001 4D18 0206  20        li   rtmp,(>FF*256)
     4D1A FF00     
0002 4D1C 2806  18        xor  rtmp,ra
                   < elite.a99
16842                      .sec                            ; SEC               ; C flag. This makes A negative, and as we are about to
     **** ****     > SEC
0001 4D1E 0A15  18        sla  rmone,1
                   < elite.a99
16843                                                                          ; do an ADC below, the SEC effectively adds another 1 to
16844                                                                          ; that value to implement two's complement negation, so
16845                                                                          ; we don't need to add another 1 here
16846               
16847               SCD6:
16848                                                                          ; We now have all the information we need to draw this
16849                                                                          ; ship on the scanner, namely:
16850                                                                          ;
16851                                                                          ; X1 = the screen x-coordinate of the ship's dot
16852                                                                          ;
16853                                                                          ; SC = the screen y-coordinate of the base of the
16854                                                                          ; stick
16855                                                                          ;
16856                                                                          ; A = the screen height of the ship's stick, with the
16857                                                                          ; correct sign for adding to the base of the stick
16858                                                                          ; to get the dot's y-coordinate
16859                                                                          ;
16860                                                                          ; First, though, we have to make sure the dot is inside
16861                                                                          ; the dashboard, by moving it if necessary
16862                      .adc @SC,ra                     ; ADC SC            ; Set A = SC + A, so A now contains the y-coordinate of
     **** ****     > ADC
0001 4D20 1701  14        jnc  !
0002 4D22 B004  18        ab   rone,ra
0003               !:
0004 4D24 B020  30        ab   @SC,ra
     4D26 0007     
                   < elite.a99
16863                                                                          ; the end of the stick, plus the length of the stick, to
16864                                                                          ; give us the screen y-coordinate of the dot
16865               
16866 4D28 1508  14        jgt  ld246_                     ; BPL ld246         ; If the result has bit 0 clear, then the result has
16867                                                                          ; overflowed and is bigger than 256, so jump to ld246 to
16868                                                                          ; set A to the maximum allowed value of 246 (this
16869                                                                          ; instruction isn't required as we test both the maximum
16870                                                                          ; and minimum below, but it might save a few cycles)
16871               
16872 4D2A 0280  22        ci   ra,>c2*256                 ; CMP #194          ; If A >= 194, skip the following instruction, as 194 is
     4D2C C200     
16873 4D2E 1802  14        joc  B48                        ; BCS B48           ; the minimum allowed value of A
16874               
16875 4D30 0200  20        li   ra,>c2*256                 ; LDA #194          ; A < 194, so set A to 194, the minimum allowed value
     4D32 C200     
16876                                                                          ; for the y-coordinate of our ship's dot
16877               
16878               B48:
16879 4D34 0280  22        ci   ra,>f7*256                 ; CMP #247          ; If A < 247, skip the following instruction, as 246 is
     4D36 F700     
16880 4D38 1700  14        jnc  B49                        ; BCC B49           ; the maximum allowed value of A
16881               
16882               ld246_:
16883                      equ  $
16884               B49:
16885 4D3A 0200  20        li   ra,>f6*256                 ; LDA #246          ; A >= 247, so set A to 246, the maximum allowed value
     4D3C F600     
16886                                                                          ; for the y-coordinate of our ship's dot
16887               
16888 4D3E D800  30        movb ra,@Y1                     ; STA Y1            ; Store A in Y1, as it now contains the screen
     4D40 0032     
16889                                                                          ; y-coordinate for the ship's dot, clipped so that it
16890                                                                          ; fits within the dashboard
16891               
16892                      .sec                            ; SEC               ; Set A = A - SC to get the stick length, by reversing
     **** ****     > SEC
0001 4D42 0A15  18        sla  rmone,1
                   < elite.a99
16893                      .sbc @SC,ra                     ; SBC SC            ; the ADC SC we did above. This clears the C flag if the
     **** ****     > SBC
0001 4D44 1801  14        joc  !
0002 4D46 7004  18        sb   rone,ra
0003               !:
0004 4D48 7020  30        sb   @SC,ra
     4D4A 0007     
                   < elite.a99
16894                                                                          ; result is negative (i.e. the stick length is negative)
16895                                                                          ; and sets it if the result is positive (i.e. the stick
16896                                                                          ; length is negative)
16897               
16898                                                                          ; So now we have the following:
16899                                                                          ;
16900                                                                          ; X1 = the screen x-coordinate of the ship's dot,
16901                                                                          ; clipped to fit into the dashboard
16902                                                                          ;
16903                                                                          ; Y1 = the screen y-coordinate of the ship's dot,
16904                                                                          ; clipped to fit into the dashboard
16905                                                                          ;
16906                                                                          ; SC = the screen y-coordinate of the base of the
16907                                                                          ; stick
16908                                                                          ;
16909                                                                          ; A = the screen height of the ship's stick, with the
16910                                                                          ; correct sign for adding to the base of the stick
16911                                                                          ; to get the dot's y-coordinate
16912                                                                          ;
16913                                                                          ; C = 0 if A is negative, 1 if A is positive
16914                                                                          ;
16915                                                                          ; and we can get on with drawing the dot and stick
16916               
16917                      .php                            ; PHP               ; Store the flags (specifically the C flag) from the
     **** ****     > PHP
0001 4D4C 02C6  12        stst rtmp
0002 4D4E D686  30        movb rtmp,*rsp
0003 4D50 060A  14        dec  rsp
                   < elite.a99
16918                                                                          ; above subtraction
16919               
16920               * BCS SC48               \ These instructions are commented out in the original
16921               * EOR #&FF               \ source. They would negate A if the C flag were set,
16922               * ADC #1                 \ which would reverse the direction of all the sticks,
16923                                                                          ; so you could turn your joystick around. Perhaps one of
16924                                                                          ; the authors' test sticks was easier to use upside
16925                                                                          ; down? Who knows...
16926               
16927               SC48:
16928                      .pha                            ; PHA               ; Store the stick height in A on the stack
     **** ****     > PHA
0001 4D52 D680  30        movb ra,*rsp
0002 4D54 060A  14        dec  rsp
                   < elite.a99
16929               
16930 4D56 0206  20        li   rtmp,CPIX4                 ; JSR CPIX4         ; Draw a double-height dot at (X1, Y1). This also leaves
     4D58 ADDE     
16931 4D5A 06A0  32        bl   @jsr                       ;
     4D5C FF10     
16932                                                                          ; the following variables set up for the dot's top-right
16933                                                                          ; pixel, the last pixel to be drawn (as the dot gets
16934                                                                          ; drawn from the bottom up):
16935                                                                          ;
16936                                                                          ; SC(1 0) = screen address of the pixel's character
16937                                                                          ; block
16938                                                                          ;
16939                                                                          ; Y = number of the character row containing the pixel
16940                                                                          ;
16941                                                                          ; X = the pixel's number (0-3) in that row
16942                                                                          ;
16943                                                                          ; We can use there as the starting point for drawing the
16944                                                                          ; stick, if there is one
16945               
16946 4D5E D021  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Load the same mode 5 1-pixel byte that we just used
     4D60 224A     
16947                      .and @COL                       ; AND COL           ; for the top-right pixel, and mask it with the same
     **** ****     > AND
0001 4D62 D1A0  30        movb @COL,rtmp
     4D64 00A2     
0002 4D66 0546  14        inv  rtmp
0003 4D68 5006  18        szcb rtmp,ra
                   < elite.a99
16948 4D6A D800  30        movb ra,@X1                     ; STA X1            ; colour, storing the result in X1, so we can use it as
     4D6C 0031     
16949                                                                          ; the character row byte for the stick
16950               
16951                      .pla                            ; PLA               ; Restore the stick height from the stack into A
     **** ****     > PLA
0001 4D6E 058A  14        inc  rsp
0002 4D70 D01A  26        movb *rsp,ra
                   < elite.a99
16952               
16953                      .plp                            ; PLP               ; Restore the flags from above, so the C flag once again
     **** ****     > PLP
0001 4D72 058A  14        INC  rsp
0002 4D74 D19A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
16954                                                                          ; reflects the sign of the stick height
16955               
16956 4D76 D040  18        movb ra,rx                      ; TAX               ; Copy the stick height into X
16957               
16958 4D78 1314  14        jeq  RTS1                       ; BEQ RTS1          ; If the stick height is zero, then there is no stick to
16959                                                                          ; draw, so return from the subroutine (as RTS contains
16960                                                                          ; an RTS)
16961               
16962 4D7A 1715  14        jnc  RTS3                       ; BCC RTS3          ; If the C flag is clear then the stick height in A is
16963                                                                          ; negative, so jump down to RTS+1
16964               
16965               VLL1:
16966                                                                          ; If we get here then the stick length is positive (so
16967                                                                          ; the dot is below the ellipse and the stick is above
16968                                                                          ; the dot, and we need to draw the stick upwards from
16969                                                                          ; the dot)
16970 4D7C 7084  18        sb   rone,ry                    ; DEY               ; We want to draw the stick upwards, so decrement the
16971                                                                          ; pixel row in Y
16972               
16973 4D7E 1503  14        jgt  VL1                        ; BPL VL1           ; If Y is still positive then it correctly points at the
16974                                                                          ; line above, so jump to VL1 to skip the following
16975               
16976 4D80 0202  20        li   ry,>07*256                 ; LDY #7            ; We just decremented Y up through the top of the
     4D82 0700     
16977                                                                          ; character block, so we need to move it to the last row
16978                                                                          ; in the character above, so set Y to 7, the number of
16979                                                                          ; the last row
16980               
16981 4D84 7004  18        sb   rone,ra                    ; DEC SC+1          ; Decrement the high byte of the screen address to move
16982                                                                          ; to the character block above
16983               
16984               VL1:
16985 4D86 D020  30        movb @X1,ra                     ; LDA X1            ; Set A to the character row byte for the stick, which
     4D88 0031     
16986                                                                          ; we stored in X1 above, and which has the same pixel
16987                                                                          ; pattern as the bottom-right pixel of the dot (so the
16988                                                                          ; stick comes out of the right side of the dot)
16989               
16990                      .eor @SC                        ; EOR (SC),Y        ; Draw the stick on row Y of the character block using
     **** ****     > EOR
0001 4D8A D1A0  30        movb @SC,rtmp
     4D8C 0007     
0002 4D8E 2806  18        xor  rtmp,ra
                   < elite.a99
16991                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; EOR logic
     **** ****     > ST_IND_Y_IDX
0001 4D90 D820  50        movb @SC,@rtmplb
     4D92 0007     
     4D94 2079     
0002 4D96 D1A0  30        movb @SC+1,rtmp
     4D98 0008     
0003 4D9A A182  18        a    ry,rtmp
0004 4D9C D580  30        movb RA,*rtmp
                   < elite.a99
16992               
16993 4D9E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the (positive) stick height in X
16994               
16995 4DA0 16ED  14        jne  VLL1                       ; BNE VLL1          ; If we still have more stick to draw, jump up to VLL1
16996                                                                          ; to draw the next pixel
16997               
16998               RTS1:
16999 4DA2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4DA4 FF1C     
17000               
17001                                                                          ; If we get here then the stick length is negative (so
17002                                                                          ; the dot is above the ellipse and the stick is below
17003                                                                          ; the dot, and we need to draw the stick downwards from
17004                                                                          ; the dot)
17005               
17006               RTS3:
17007 4DA6 B084  18        ab   rone,ry                    ; INY               ; We want to draw the stick downwards, so we first
17008                                                                          ; increment the row counter so that it's pointing to the
17009                                                                          ; bottom-right pixel in the dot (as opposed to the top-
17010                                                                          ; right pixel that the call to CPIX4 finished on)
17011               
17012 4DA8 0282  22        ci   ry,>08*256                 ; CPY #8            ; If the row number in Y is less than 8, then it
     4DAA 0800     
17013 4DAC 1603  14        jne  VLL2                       ; BNE VLL2          ; correctly points at the next line down, so jump to
17014                                                                          ; VLL2 to skip the following
17015               
17016 4DAE 0202  20        li   ry,>00*256                 ; LDY #0            ; We just incremented Y down through the bottom of the
     4DB0 0000     
17017                                                                          ; character block, so we need to move it to the first
17018                                                                          ; row in the character below, so set Y to 0, the number
17019                                                                          ; of the first row
17020               
17021 4DB2 B004  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of the screen address to move
17022                                                                          ; to the character block above
17023               
17024               VLL2:
17025 4DB4 B084  18        ab   rone,ry                    ; INY               ; We want to draw the stick itself, heading downwards,
17026                                                                          ; so increment the pixel row in Y
17027               
17028 4DB6 0282  22        ci   ry,>08*256                 ; CPY #8            ; If the row number in Y is less than 8, then it
     4DB8 0800     
17029 4DBA 1603  14        jne  VL2                        ; BNE VL2           ; correctly points at the next line down, so jump to
17030                                                                          ; VL2 to skip the following
17031               
17032 4DBC 0202  20        li   ry,>00*256                 ; LDY #0            ; We just incremented Y down through the bottom of the
     4DBE 0000     
17033                                                                          ; character block, so we need to move it to the first
17034                                                                          ; row in the character below, so set Y to 0, the number
17035                                                                          ; of the first row
17036               
17037 4DC0 B004  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of the screen address to move
17038                                                                          ; to the character block above
17039               
17040               VL2:
17041 4DC2 D020  30        movb @X1,ra                     ; LDA X1            ; Set A to the character row byte for the stick, which
     4DC4 0031     
17042                                                                          ; we stored in X1 above, and which has the same pixel
17043                                                                          ; pattern as the bottom-right pixel of the dot (so the
17044                                                                          ; stick comes out of the right side of the dot)
17045               
17046                      .eor @SC                        ; EOR (SC),Y        ; Draw the stick on row Y of the character block using
     **** ****     > EOR
0001 4DC6 D1A0  30        movb @SC,rtmp
     4DC8 0007     
0002 4DCA 2806  18        xor  rtmp,ra
                   < elite.a99
17047                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; EOR logic
     **** ****     > ST_IND_Y_IDX
0001 4DCC D820  50        movb @SC,@rtmplb
     4DCE 0007     
     4DD0 2079     
0002 4DD2 D1A0  30        movb @SC+1,rtmp
     4DD4 0008     
0003 4DD6 A182  18        a    ry,rtmp
0004 4DD8 D580  30        movb RA,*rtmp
                   < elite.a99
17048               
17049 4DDA B044  18        ab   rone,rx                    ; INX               ; Increment the (negative) stick height in X
17050               
17051 4DDC 16EB  14        jne  VLL2                       ; BNE VLL2          ; If we still have more stick to draw, jump up to VLL2
17052                                                                          ; to draw the next pixel
17053               
17054 4DDE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4DE0 FF1C     
17055               
17056               * ******************************************************************************
17057               *
17058               * Name: WSCAN
17059               * Type: Subroutine
17060               * Category: Drawing the screen
17061               * Summary: Wait for the vertical sync
17062               *
17063               * ------------------------------------------------------------------------------
17064               *
17065               * Wait for vertical sync to occur on the video system - in other words, wait
17066               * for the screen to start its refresh cycle, which it does 50 times a second
17067               * (50Hz).
17068               *
17069               * ******************************************************************************
17070               
17071               WSCAN:
17072 4DE2 0200  20        li   ra,>00*256                 ; LDA #0            ; Set DL to 0
     4DE4 0000     
17073 4DE6 D800  30        movb ra,@DL                     ; STA DL
     4DE8 009A     
17074               
17075               B50:
17076 4DEA D020  30        movb @DL,ra                     ; LDA DL            ; Loop round these two instructions until DL is no
     4DEC 009A     
17077 4DEE 13FD  14        jeq  B50                        ; BEQ B50           ; longer 0 (DL gets set to 30 in the LINSCN routine,
17078                                                                          ; which is run when vertical sync has occurred on the
17079                                                                          ; video system, so DL will change to a non-zero value
17080                                                                          ; at the start of each screen refresh)
17081               
17082 4DF0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4DF2 FF1C     
17083               
17084               * ******************************************************************************
17085               *
17086               * Save ELTC.bin
17087               *
17088               * ******************************************************************************
17089               
17090                      ; PRINT "ELITE C"
17091                      ; PRINT "Assembled at ", ~CODE_C%
17092                      ; PRINT "Ends at ", ~P%
17093                      ; PRINT "Code size is ", ~(P% - CODE_C%)
17094                      ; PRINT "Execute at ", ~LOAD%
17095                      ; PRINT "Reload at ", ~LOAD_C%
17096               
17097                      ; PRINT "S.ELTC ", ~CODE_C%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_C%
17098                      ; SAVE "3-assembled-output/ELTC.bin", CODE_C%, P%, LOAD%
17099               
17100               * ******************************************************************************
17101               *
17102               * ELITE D FILE
17103               *
17104               * Produces the binary file ELTD.bin that gets loaded by elite-bcfs.asm.
17105               *
17106               * ******************************************************************************
17107               
17108               CODE_D.:
17109                      equ $
17110               
17111               LOAD_D.:
17112                      equ LOAD. + $ - CODE.
17113               
17114               * ******************************************************************************
17115               *
17116               * Name: tnpr
17117               * Type: Subroutine
17118               * Category: Market
17119               * Summary: Work out if we have space for a specific amount of cargo
17120               *
17121               * ------------------------------------------------------------------------------
17122               *
17123               * Given a market item and an amount, work out whether there is room in the
17124               * cargo hold for this item.
17125               *
17126               * For standard tonne canisters, the limit is given by the type of cargo hold we
17127               * have, with a standard cargo hold having a capacity of 20t and an extended
17128               * cargo bay being 35t.
17129               *
17130               * For items measured in kg (gold, platinum), g (gem-stones) and alien items,
17131               * the individual limit on each of these is 200 units.
17132               *
17133               * ------------------------------------------------------------------------------
17134               *
17135               * Arguments:
17136               *
17137               * A                   The number of units of this market item
17138               *
17139               * QQ29                The type of market item (see QQ23 for a list of market
17140               * item numbers)
17141               *
17142               * ------------------------------------------------------------------------------
17143               *
17144               * Returns:
17145               *
17146               * A                   A is preserved
17147               *
17148               * C flag              Returns the result:
17149               *
17150               * * Set if there is no room for this item
17151               *
17152               * * Clear if there is room for this item
17153               *
17154               * ******************************************************************************
17155               
17156               tnpr_:
17157                      .pha                            ; PHA               ; Store A on the stack
     **** ****     > PHA
0001 4DF4 D680  30        movb ra,*rsp
0002 4DF6 060A  14        dec  rsp
                   < elite.a99
17158               
17159 4DF8 0201  20        li   rx,>0c*256                 ; LDX #12           ; If QQ29 > 12 then jump to kg below, as this cargo
     4DFA 0C00     
17160 4DFC 9060  30        cb   @QQ29,rx                   ; CPX QQ29          ; type is gold, platinum, gem-stones or alien items,
     4DFE 0F1B     
17161 4E00 170C  14        jnc  kg_                        ; BCC kg            ; and they have different cargo limits to the standard
17162                                                                          ; tonne canisters
17163               
17164               Tml:
17165                                                                          ; Here we count the tonne canisters we have in the hold
17166                                                                          ; and add to A to see if we have enough room for A more
17167                                                                          ; tonnes of cargo, using X as the loop counter, starting
17168                                                                          ; with X = 12
17169                      .adc @QQ20(rx),ra               ; ADC QQ20,X        ; Set A = A + the number of tonnes we have in the hold
     **** ****     > ADC
0001 4E02 1701  14        jnc  !
0002 4E04 B004  18        ab   rone,ra
0003               !:
0004 4E06 B021  34        ab   @QQ20(RX),ra
     4E08 0317     
                   < elite.a99
17170                                                                          ; of market item number X. Note that the first time we
17171                                                                          ; go round this loop, the C flag is set (as we didn't
17172                                                                          ; branch with the BCC above, so the effect of this loop
17173                                                                          ; is to count the number of tonne canisters in the hold,
17174                                                                          ; and add 1
17175               
17176 4E0A 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
17177               
17178 4E0C 15FA  14        jgt  Tml                        ; BPL Tml           ; Loop back to add in the next market item in the hold,
17179                                                                          ; until we have added up all market items from 12
17180                                                                          ; (minerals) down to 0 (food)
17181               
17182 4E0E 9020  30        cb   @CRGO,ra                   ; CMP CRGO          ; If A < CRGO then the C flag will be clear (we have
     4E10 0316     
17183                                                                          ; room in the hold)
17184                                                                          ;
17185                                                                          ; If A >= CRGO then the C flag will be set (we do not
17186                                                                          ; have room in the hold)
17187                                                                          ;
17188                                                                          ; This works because A contains the number of canisters
17189                                                                          ; plus 1, while CRGO contains our cargo capacity plus 2,
17190                                                                          ; so if we actually have "a" canisters and a capacity
17191                                                                          ; of "c", then:
17192                                                                          ;
17193                                                                          ; A < CRGO means: a+1 <  c+2
17194                                                                          ; a   <  c+1
17195                                                                          ; a   <= c
17196                                                                          ;
17197                                                                          ; So this is why the value in CRGO is 2 higher than the
17198                                                                          ; actual cargo bay size, i.e. it's 22 for the standard
17199                                                                          ; 20-tonne bay, and 37 for the large 35-tonne bay
17200               
17201                      .pla                            ; PLA               ; Restore A from the stack
     **** ****     > PLA
0001 4E12 058A  14        inc  rsp
0002 4E14 D01A  26        movb *rsp,ra
                   < elite.a99
17202               
17203 4E16 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4E18 FF1C     
17204               
17205               kg_:
17206                                                                          ; Here we count the number of items of this type that
17207                                                                          ; we already have in the hold, and add to A to see if
17208                                                                          ; we have enough room for A more units
17209 4E1A D0A0  30        movb @QQ29,ry                   ; LDY QQ29          ; Set Y to the item number we want to add
     4E1C 0F1B     
17210               
17211                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; Set A = A + the number of units of this item that we
     **** ****     > ADC
0001 4E1E 1701  14        jnc  !
0002 4E20 B004  18        ab   rone,ra
0003               !:
0004 4E22 B022  34        ab   @QQ20(RY),ra
     4E24 0317     
                   < elite.a99
17212                                                                          ; already have in the hold
17213               
17214 4E26 0280  22        ci   ra,>c8*256                 ; CMP #200          ; Is the result greater than 200 (the limit on
     4E28 C800     
17215                                                                          ; individual stocks of gold, platinum, gem-stones and
17216                                                                          ; alien items)?
17217                                                                          ;
17218                                                                          ; If so, this sets the C flag (no room)
17219                                                                          ;
17220                                                                          ; Otherwise it is clear (we have room)
17221               
17222                      .pla                            ; PLA               ; Restore A from the stack
     **** ****     > PLA
0001 4E2A 058A  14        inc  rsp
0002 4E2C D01A  26        movb *rsp,ra
                   < elite.a99
17223               
17224 4E2E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4E30 FF1C     
17225               
17226               * ******************************************************************************
17227               *
17228               * Name: TT20
17229               * Type: Subroutine
17230               * Category: Universe
17231               * Summary: Twist the selected system's seeds four times
17232               * Deep dive: Twisting the system seeds
17233               * Galaxy and system seeds
17234               *
17235               * ------------------------------------------------------------------------------
17236               *
17237               * Twist the three 16-bit seeds in QQ15 (selected system) four times, to
17238               * generate the next system.
17239               *
17240               * ******************************************************************************
17241               
17242               TT20:
17243 4E32 0206  20        li   rtmp,B51                   ; JSR B51           ; This line calls the line below as a subroutine, which
     4E34 4E3A     
17244 4E36 06A0  32        bl   @jsr                       ;
     4E38 FF10     
17245                                                                          ; does two twists before returning here, and then we
17246                                                                          ; fall through to the line below for another two
17247                                                                          ; twists, so the net effect of these two consecutive
17248                                                                          ; JSR calls is four twists, not counting the ones
17249                                                                          ; inside your head as you try to follow this process
17250               
17251               B51:
17252 4E3A 0206  20        li   rtmp,TT54                  ; JSR TT54          ; This line calls TT54 as a subroutine to do a twist,
     4E3C 4E42     
17253 4E3E 06A0  32        bl   @jsr                       ;
     4E40 FF10     
17254                                                                          ; and then falls through into TT54 to do another twist
17255                                                                          ; before returning from the subroutine
17256               
17257               * ******************************************************************************
17258               *
17259               * Name: TT54
17260               * Type: Subroutine
17261               * Category: Universe
17262               * Summary: Twist the selected system's seeds
17263               * Deep dive: Twisting the system seeds
17264               * Galaxy and system seeds
17265               *
17266               * ------------------------------------------------------------------------------
17267               *
17268               * This routine twists the three 16-bit seeds in QQ15 once.
17269               *
17270               * If we start with seeds s0, s1 and s2 and we want to work out their new values
17271               * after we perform a twist (let's call the new values s0, s1 and s2), then:
17272               *
17273               * s0 = s1
17274               * s1 = s2
17275               * s2 = s0 + s1 + s2
17276               *
17277               * So given an existing set of seeds in s0, s1 and s2, we can get the new values
17278               * s0, s1 and s2 simply by doing the above sums. And if we want to do the
17279               * above in-place without creating three new s variables, then we can do the
17280               * following:
17281               *
17282               * tmp = s0 + s1
17283               * s0 = s1
17284               * s1 = s2
17285               * s2 = tmp + s1
17286               *
17287               * So this is what we do in this routine, where each seed is a 16-bit number.
17288               *
17289               * ******************************************************************************
17290               
17291               TT54:
17292 4E42 D020  30        movb @QQ15,ra                   ; LDA QQ15          ; X = tmp_lo = s0_lo + s1_lo
     4E44 0078     
17293                      .clc                            ; CLC
     **** ****     > CLC
0001 4E46 0A13  18        sla  rzero,1
                   < elite.a99
17294                      .adc @QQ15+2,ra                 ; ADC QQ15+2
     **** ****     > ADC
0001 4E48 1701  14        jnc  !
0002 4E4A B004  18        ab   rone,ra
0003               !:
0004 4E4C B020  30        ab   @QQ15+2,ra
     4E4E 007A     
                   < elite.a99
17295 4E50 D040  18        movb ra,rx                      ; TAX
17296               
17297 4E52 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Y = tmp_hi = s1_hi + s1_hi + C
     4E54 0079     
17298                      .adc @QQ15+3,ra                 ; ADC QQ15+3
     **** ****     > ADC
0001 4E56 1701  14        jnc  !
0002 4E58 B004  18        ab   rone,ra
0003               !:
0004 4E5A B020  30        ab   @QQ15+3,ra
     4E5C 007B     
                   < elite.a99
17299 4E5E D080  18        movb ra,ry                      ; TAY
17300               
17301 4E60 D020  30        movb @QQ15+2,ra                 ; LDA QQ15+2        ; s0_lo = s1_lo
     4E62 007A     
17302 4E64 D800  30        movb ra,@QQ15                   ; STA QQ15
     4E66 0078     
17303               
17304 4E68 D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; s0_hi = s1_hi
     4E6A 007B     
17305 4E6C D800  30        movb ra,@QQ15+1                 ; STA QQ15+1
     4E6E 0079     
17306               
17307 4E70 D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; s1_hi = s2_hi
     4E72 007D     
17308 4E74 D800  30        movb ra,@QQ15+3                 ; STA QQ15+3
     4E76 007B     
17309               
17310 4E78 D020  30        movb @QQ15+4,ra                 ; LDA QQ15+4        ; s1_lo = s2_lo
     4E7A 007C     
17311 4E7C D800  30        movb ra,@QQ15+2                 ; STA QQ15+2
     4E7E 007A     
17312               
17313                      .clc                            ; CLC               ; s2_lo = X + s1_lo
     **** ****     > CLC
0001 4E80 0A13  18        sla  rzero,1
                   < elite.a99
17314 4E82 D001  18        movb rx,ra                      ; TXA
17315                      .adc @QQ15+2,ra                 ; ADC QQ15+2
     **** ****     > ADC
0001 4E84 1701  14        jnc  !
0002 4E86 B004  18        ab   rone,ra
0003               !:
0004 4E88 B020  30        ab   @QQ15+2,ra
     4E8A 007A     
                   < elite.a99
17316 4E8C D800  30        movb ra,@QQ15+4                 ; STA QQ15+4
     4E8E 007C     
17317               
17318 4E90 D002  18        movb ry,ra                      ; TYA               ; s2_hi = Y + s1_hi + C
17319                      .adc @QQ15+3,ra                 ; ADC QQ15+3
     **** ****     > ADC
0001 4E92 1701  14        jnc  !
0002 4E94 B004  18        ab   rone,ra
0003               !:
0004 4E96 B020  30        ab   @QQ15+3,ra
     4E98 007B     
                   < elite.a99
17320 4E9A D800  30        movb ra,@QQ15+5                 ; STA QQ15+5
     4E9C 007D     
17321               
17322 4E9E 0460  28        b    @rts                       ; RTS               ; The twist is complete so return from the subroutine
     4EA0 FF1C     
17323               
17324               * ******************************************************************************
17325               *
17326               * Name: TT146
17327               * Type: Subroutine
17328               * Category: Universe
17329               * Summary: Print the distance to the selected system in light years
17330               *
17331               * ------------------------------------------------------------------------------
17332               *
17333               * If it is non-zero, print the distance to the selected system in light years.
17334               * If it is zero, just move the text cursor down a line.
17335               *
17336               * Specifically, if the distance in QQ8 is non-zero, print token 31 ("DISTANCE"),
17337               * then a colon, then the distance to one decimal place, then token 35 ("LIGHT
17338               * YEARS"). If the distance is zero, move the cursor down one line.
17339               *
17340               * ******************************************************************************
17341               
17342               TT146:
17343 4EA2 D020  30        movb @QQ8,ra                    ; LDA QQ8           ; Take the two bytes of the 16-bit value in QQ8 and
     4EA4 0F2F     
17344 4EA6 F020  30        socb @QQ8+1,ra                  ; ORA QQ8+1         ; OR them together to check whether there are any
     4EA8 0F30     
17345 4EAA 1603  14        jne  TT63                       ; BNE TT63          ; non-zero bits, and if so, jump to TT63 to print the
17346                                                                          ; distance
17347               
17348 4EAC B004  18        ab   rone,ra                    ; INC YC            ; The distance is zero, so we just move the text cursor
17349 4EAE 0460  28        b    @rts                       ; RTS               ; in YC down by one line and return from the subroutine
     4EB0 FF1C     
17350               
17351               TT63:
17352 4EB2 0200  20        li   ra,>bf*256                 ; LDA #191          ; Print recursive token 31 ("DISTANCE") followed by
     4EB4 BF00     
17353 4EB6 0206  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     4EB8 A6DC     
17354 4EBA 06A0  32        bl   @jsr                       ;
     4EBC FF10     
17355               
17356 4EBE D060  30        movb @QQ8,rx                    ; LDX QQ8           ; Load (Y X) from QQ8, which contains the 16-bit
     4EC0 0F2F     
17357 4EC2 D0A0  30        movb @QQ8+1,ry                  ; LDY QQ8+1         ; distance we want to show
     4EC4 0F30     
17358               
17359                      .sec                            ; SEC               ; Set the C flag so that the call to pr5 will include a
     **** ****     > SEC
0001 4EC6 0A15  18        sla  rmone,1
                   < elite.a99
17360                                                                          ; decimal point, and display the value as (Y X) / 10
17361               
17362 4EC8 0206  20        li   rtmp,pr5_                  ; JSR pr5           ; Print (Y X) to 5 digits, including a decimal point
     4ECA 5D46     
17363 4ECC 06A0  32        bl   @jsr                       ;
     4ECE FF10     
17364               
17365 4ED0 0200  20        li   ra,>c3*256                 ; LDA #195          ; Set A to the recursive token 35 (" LIGHT YEARS") and
     4ED2 C300     
17366                                                                          ; fall through into TT60 to print the token followed
17367                                                                          ; by a paragraph break
17368               
17369               * ******************************************************************************
17370               *
17371               * Name: TT60
17372               * Type: Subroutine
17373               * Category: Text
17374               * Summary: Print a text token and a paragraph break
17375               *
17376               * ------------------------------------------------------------------------------
17377               *
17378               * Print a text token (i.e. a character, control code, two-letter token or
17379               * recursive token). Then print a paragraph break (a blank line between
17380               * paragraphs) by moving the cursor down a line, setting Sentence Case, and then
17381               * printing a newline.
17382               *
17383               * ------------------------------------------------------------------------------
17384               *
17385               * Arguments:
17386               *
17387               * A                   The text token to be printed
17388               *
17389               * ******************************************************************************
17390               
17391               TT60:
17392 4ED4 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A and fall through into TTX69
     4ED6 A6E8     
17393 4ED8 06A0  32        bl   @jsr                       ;
     4EDA FF10     
17394                                                                          ; to print the paragraph break
17395               
17396               * ******************************************************************************
17397               *
17398               * Name: TTX69
17399               * Type: Subroutine
17400               * Category: Text
17401               * Summary: Print a paragraph break
17402               *
17403               * ------------------------------------------------------------------------------
17404               *
17405               * Print a paragraph break (a blank line between paragraphs) by moving the cursor
17406               * down a line, setting Sentence Case, and then printing a newline.
17407               *
17408               * ******************************************************************************
17409               
17410               TTX69:
17411 4EDC B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a line
17412               
17413                                                                          ; Fall through into TT69 to set Sentence Case and print
17414                                                                          ; a newline
17415               
17416               * ******************************************************************************
17417               *
17418               * Name: TT69
17419               * Type: Subroutine
17420               * Category: Text
17421               * Summary: Set Sentence Case and print a newline
17422               *
17423               * ******************************************************************************
17424               
17425               TT69:
17426 4EDE 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     4EE0 8000     
17427 4EE2 D800  30        movb ra,@QQ17                   ; STA QQ17
     4EE4 007E     
17428               
17429                                                                          ; Fall through into TT67 to print a newline
17430               
17431               * ******************************************************************************
17432               *
17433               * Name: TT67
17434               * Type: Subroutine
17435               * Category: Text
17436               * Summary: Print a newline
17437               *
17438               * ******************************************************************************
17439               
17440               TT67:
17441 4EE6 0200  20        li   ra,>0d*256                 ; LDA #13           ; Load a newline character into A
     4EE8 0D00     
17442               
17443 4EEA 0460  28        b    @TT27                      ; JMP TT27          ; Print the text token in A and return from the
     4EEC A6E8     
17444                                                                          ; subroutine using a tail call
17445               
17446               * ******************************************************************************
17447               *
17448               * Name: TT70
17449               * Type: Subroutine
17450               * Category: Universe
17451               * Summary: Display "MAINLY " and jump to TT72
17452               *
17453               * ------------------------------------------------------------------------------
17454               *
17455               * This subroutine is called by TT25 when displaying a system's economy.
17456               *
17457               * ******************************************************************************
17458               
17459               TT70:
17460 4EEE 0200  20        li   ra,>ad*256                 ; LDA #173          ; Print recursive token 13 ("MAINLY ")
     4EF0 AD00     
17461 4EF2 0206  20        li   rtmp,TT27                  ; JSR TT27
     4EF4 A6E8     
17462 4EF6 06A0  32        bl   @jsr                       ;
     4EF8 FF10     
17463               
17464 4EFA 0460  28        b    @TT72                      ; JMP TT72          ; Jump to TT72 to continue printing system data as part
     4EFC 4F82     
17465                                                                          ; of routine TT25
17466               
17467               * ******************************************************************************
17468               *
17469               * Name: spc
17470               * Type: Subroutine
17471               * Category: Text
17472               * Summary: Print a text token followed by a space
17473               *
17474               * ------------------------------------------------------------------------------
17475               *
17476               * Print a text token (i.e. a character, control code, two-letter token or
17477               * recursive token) followed by a space.
17478               *
17479               * ------------------------------------------------------------------------------
17480               *
17481               * Arguments:
17482               *
17483               * A                   The text token to be printed
17484               *
17485               * ******************************************************************************
17486               
17487               spc_:
17488 4EFE 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     4F00 A6E8     
17489 4F02 06A0  32        bl   @jsr                       ;
     4F04 FF10     
17490               
17491 4F06 0460  28        b    @TT162                     ; JMP TT162         ; Print a space and return from the subroutine using a
     4F08 5E64     
17492                                                                          ; tail call
17493               
17494               * ******************************************************************************
17495               *
17496               * Name: TT25
17497               * Type: Subroutine
17498               * Category: Universe
17499               * Summary: Show the Data on System screen (red key f6)
17500               * Deep dive: Generating system data
17501               * Galaxy and system seeds
17502               *
17503               * ------------------------------------------------------------------------------
17504               *
17505               * Other entry points:
17506               *
17507               * TT72                Used by TT70 to re-enter the routine after displaying
17508               * "MAINLY" for the economy type
17509               *
17510               * ******************************************************************************
17511               
17512               TT25:
17513 4F0A 0206  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     4F0C 4B28     
17514 4F0E 06A0  32        bl   @jsr                       ;
     4F10 FF10     
17515                                                                          ; and set the current view type in QQ11 to 1
17516               
17517 4F12 0200  20        li   ra,>09*256                 ; LDA #9            ; Move the text cursor to column 9
     4F14 0900     
17518 4F16 D800  30        movb ra,@XC                     ; STA XC
     4F18 002C     
17519               
17520 4F1A 0200  20        li   ra,>a3*256                 ; LDA #163          ; Print recursive token 3 as a title in capitals at
     4F1C A300     
17521 4F1E 0206  20        li   rtmp,TT27                  ; JSR TT27          ; the top ("DATA ON {selected system name}")
     4F20 A6E8     
17522 4F22 06A0  32        bl   @jsr                       ;
     4F24 FF10     
17523               
17524 4F26 0206  20        li   rtmp,NLIN                  ; JSR NLIN          ; Draw a horizontal line underneath the title
     4F28 25BE     
17525 4F2A 06A0  32        bl   @jsr                       ;
     4F2C FF10     
17526               
17527 4F2E 0206  20        li   rtmp,TTX69                 ; JSR TTX69         ; Print a paragraph break and set Sentence Case
     4F30 4EDC     
17528 4F32 06A0  32        bl   @jsr                       ;
     4F34 FF10     
17529               
17530 4F36 B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one more line
17531               
17532 4F38 0206  20        li   rtmp,TT146                 ; JSR TT146         ; If the distance to this system is non-zero, print
     4F3A 4EA2     
17533 4F3C 06A0  32        bl   @jsr                       ;
     4F3E FF10     
17534                                                                          ; "DISTANCE", then the distance, "LIGHT YEARS" and a
17535                                                                          ; paragraph break, otherwise just move the cursor down
17536                                                                          ; a line
17537               
17538 4F40 0200  20        li   ra,>c2*256                 ; LDA #194          ; Print recursive token 34 ("ECONOMY") followed by
     4F42 C200     
17539 4F44 0206  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     4F46 A6DC     
17540 4F48 06A0  32        bl   @jsr                       ;
     4F4A FF10     
17541               
17542 4F4C D020  30        movb @QQ3,ra                    ; LDA QQ3           ; The system economy is determined by the value in QQ3,
     4F4E 0F28     
17543                                                                          ; so fetch it into A. First we work out the system's
17544                                                                          ; prosperity as follows:
17545                                                                          ;
17546                                                                          ; QQ3 = 0 or 5 = %000 or %101 = Rich
17547                                                                          ; QQ3 = 1 or 6 = %001 or %110 = Average
17548                                                                          ; QQ3 = 2 or 7 = %010 or %111 = Poor
17549                                                                          ; QQ3 = 3 or 4 = %011 or %100 = Mainly
17550               
17551                      .clc                            ; CLC               ; If (QQ3 + 1) >> 1 = %10, i.e. if QQ3 = %011 or %100
     **** ****     > CLC
0001 4F50 0A13  18        sla  rzero,1
                   < elite.a99
17552                      .adi (>01*256)                  ; ADC #1            ; (3 or 4), then call TT70, which prints "MAINLY " and
     **** ****     > ADI
0001 4F52 1701  14        jnc  !
0002 4F54 B004  18        ab   rone,ra
0003               !:
0004 4F56 0220  22        ai   ra,(>01*256)
     4F58 0100     
                   < elite.a99
17553 4F5A 0910  18        srl  ra,1                       ; LSR A             ; jumps down to TT72 to print the type of economy
17554 4F5C 0280  22        ci   ra,>02*256                 ; CMP #%00000010
     4F5E 0200     
17555 4F60 13C6  14        jeq  TT70                       ; BEQ TT70
17556               
17557 4F62 D020  30        movb @QQ3,ra                    ; LDA QQ3           ; If (QQ3 + 1) >> 1 < %10, i.e. if QQ3 = %000, %001 or
     4F64 0F28     
17558 4F66 1705  14        jnc  TT71                       ; BCC TT71          ; %010 (0, 1 or 2), then jump to TT71 with A set to the
17559                                                                          ; original value of QQ3
17560               
17561                      .sbi (>05*256)                  ; SBC #5            ; Here QQ3 = %101, %110 or %111 (5, 6 or 7), so subtract
     **** ****     > SBI
0001 4F68 1801  14        joc  !
0002 4F6A 7004  18        sb   rone,ra
0003               !:
0004 4F6C 0220  22        ai   ra,-(>05*256)
     4F6E FB00     
                   < elite.a99
17562                      .clc                            ; CLC               ; 5 to bring it down to 0, 1 or 2 (the C flag is already
     **** ****     > CLC
0001 4F70 0A13  18        sla  rzero,1
                   < elite.a99
17563                                                                          ; set so the SBC will be correct)
17564               
17565               TT71:
17566                      .adi (>aa*256)                  ; ADC #170          ; A is now 0, 1 or 2, so print recursive token 10 + A.
     **** ****     > ADI
0001 4F72 1701  14        jnc  !
0002 4F74 B004  18        ab   rone,ra
0003               !:
0004 4F76 0220  22        ai   ra,(>AA*256)
     4F78 AA00     
                   < elite.a99
17567 4F7A 0206  20        li   rtmp,TT27                  ; JSR TT27          ; This means that:
     4F7C A6E8     
17568 4F7E 06A0  32        bl   @jsr                       ;
     4F80 FF10     
17569                                                                          ;
17570                                                                          ; QQ3 = 0 or 5 prints token 10 ("RICH ")
17571                                                                          ; QQ3 = 1 or 6 prints token 11 ("AVERAGE ")
17572                                                                          ; QQ3 = 2 or 7 prints token 12 ("POOR ")
17573               
17574               TT72:
17575 4F82 D020  30        movb @QQ3,ra                    ; LDA QQ3           ; Now to work out the type of economy, which is
     4F84 0F28     
17576 4F86 0910  18        srl  ra,1                       ; LSR A             ; determined by bit 2 of QQ3, as follows:
17577 4F88 0910  18        srl  ra,1                       ; LSR A             ;
17578                                                                          ; QQ3 bit 2 = 0 = Industrial
17579                                                                          ; QQ3 bit 2 = 1 = Agricultural
17580                                                                          ;
17581                                                                          ; So we fetch QQ3 into A and set A = bit 2 of QQ3 using
17582                                                                          ; two right shifts (which will work as QQ3 is only a
17583                                                                          ; 3-bit number)
17584               
17585                      .clc                            ; CLC               ; Print recursive token 8 + A, followed by a paragraph
     **** ****     > CLC
0001 4F8A 0A13  18        sla  rzero,1
                   < elite.a99
17586                      .adi (>a8*256)                  ; ADC #168          ; break and Sentence Case, so:
     **** ****     > ADI
0001 4F8C 1701  14        jnc  !
0002 4F8E B004  18        ab   rone,ra
0003               !:
0004 4F90 0220  22        ai   ra,(>A8*256)
     4F92 A800     
                   < elite.a99
17587 4F94 0206  20        li   rtmp,TT60                  ; JSR TT60          ;
     4F96 4ED4     
17588 4F98 06A0  32        bl   @jsr                       ;
     4F9A FF10     
17589                                                                          ; QQ3 bit 2 = 0 prints token 8 ("INDUSTRIAL")
17590                                                                          ; QQ3 bit 2 = 1 prints token 9 ("AGRICULTURAL")
17591               
17592 4F9C 0200  20        li   ra,>a2*256                 ; LDA #162          ; Print recursive token 2 ("GOVERNMENT") followed by
     4F9E A200     
17593 4FA0 0206  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     4FA2 A6DC     
17594 4FA4 06A0  32        bl   @jsr                       ;
     4FA6 FF10     
17595               
17596 4FA8 D020  30        movb @QQ4,ra                    ; LDA QQ4           ; The system's government is determined by the value in
     4FAA 0F29     
17597                                                                          ; QQ4, so fetch it into A
17598               
17599                      .clc                            ; CLC               ; Print recursive token 17 + A, followed by a paragraph
     **** ****     > CLC
0001 4FAC 0A13  18        sla  rzero,1
                   < elite.a99
17600                      .adi (>b1*256)                  ; ADC #177          ; break and Sentence Case, so:
     **** ****     > ADI
0001 4FAE 1701  14        jnc  !
0002 4FB0 B004  18        ab   rone,ra
0003               !:
0004 4FB2 0220  22        ai   ra,(>B1*256)
     4FB4 B100     
                   < elite.a99
17601 4FB6 0206  20        li   rtmp,TT60                  ; JSR TT60          ;
     4FB8 4ED4     
17602 4FBA 06A0  32        bl   @jsr                       ;
     4FBC FF10     
17603                                                                          ; QQ4 = 0 prints token 17 ("ANARCHY")
17604                                                                          ; QQ4 = 1 prints token 18 ("FEUDAL")
17605                                                                          ; QQ4 = 2 prints token 19 ("MULTI-GOVERNMENT")
17606                                                                          ; QQ4 = 3 prints token 20 ("DICTATORSHIP")
17607                                                                          ; QQ4 = 4 prints token 21 ("COMMUNIST")
17608                                                                          ; QQ4 = 5 prints token 22 ("CONFEDERACY")
17609                                                                          ; QQ4 = 6 prints token 23 ("DEMOCRACY")
17610                                                                          ; QQ4 = 7 prints token 24 ("CORPORATE STATE")
17611               
17612 4FBE 0200  20        li   ra,>c4*256                 ; LDA #196          ; Print recursive token 36 ("TECH.LEVEL") followed by a
     4FC0 C400     
17613 4FC2 0206  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     4FC4 A6DC     
17614 4FC6 06A0  32        bl   @jsr                       ;
     4FC8 FF10     
17615               
17616 4FCA D060  30        movb @QQ5,rx                    ; LDX QQ5           ; Fetch the tech level from QQ5 and increment it, as it
     4FCC 0F2A     
17617 4FCE B044  18        ab   rone,rx                    ; INX               ; is stored in the range 0-14 but the displayed range
17618                                                                          ; should be 1-15
17619               
17620                      .clc                            ; CLC               ; Call pr2 to print the technology level as a 3-digit
     **** ****     > CLC
0001 4FD0 0A13  18        sla  rzero,1
                   < elite.a99
17621 4FD2 0206  20        li   rtmp,pr2_                  ; JSR pr2           ; number without a decimal point (by clearing the C
     4FD4 2FAC     
17622 4FD6 06A0  32        bl   @jsr                       ;
     4FD8 FF10     
17623                                                                          ; flag)
17624               
17625 4FDA 0206  20        li   rtmp,TTX69                 ; JSR TTX69         ; Print a paragraph break and set Sentence Case
     4FDC 4EDC     
17626 4FDE 06A0  32        bl   @jsr                       ;
     4FE0 FF10     
17627               
17628 4FE2 0200  20        li   ra,>c0*256                 ; LDA #192          ; Print recursive token 32 ("POPULATION") followed by a
     4FE4 C000     
17629 4FE6 0206  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     4FE8 A6DC     
17630 4FEA 06A0  32        bl   @jsr                       ;
     4FEC FF10     
17631               
17632                      .sec                            ; SEC               ; Call pr2 to print the population as a 3-digit number
     **** ****     > SEC
0001 4FEE 0A15  18        sla  rmone,1
                   < elite.a99
17633 4FF0 D060  30        movb @QQ6,rx                    ; LDX QQ6           ; with a decimal point (by setting the C flag), so the
     4FF2 0F2B     
17634 4FF4 0206  20        li   rtmp,pr2_                  ; JSR pr2           ; number printed will be population / 10
     4FF6 2FAC     
17635 4FF8 06A0  32        bl   @jsr                       ;
     4FFA FF10     
17636               
17637 4FFC 0200  20        li   ra,>c6*256                 ; LDA #198          ; Print recursive token 38 (" BILLION"), followed by a
     4FFE C600     
17638 5000 0206  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case
     5002 4ED4     
17639 5004 06A0  32        bl   @jsr                       ;
     5006 FF10     
17640               
17641 5008 0200  20        li   ra,('(')*256               ; LDA #'('          ; Print an opening bracket
     500A 2800     
17642 500C 0206  20        li   rtmp,TT27                  ; JSR TT27
     500E A6E8     
17643 5010 06A0  32        bl   @jsr                       ;
     5012 FF10     
17644               
17645 5014 D020  30        movb @QQ15+4,ra                 ; LDA QQ15+4        ; Now to calculate the species, so first check bit 7 of
     5016 007C     
17646 5018 1108  14        jlt  TT75                       ; BMI TT75          ; s2_lo, and if it is set, jump to TT75 as this is an
17647                                                                          ; alien species
17648               
17649 501A 0200  20        li   ra,>bc*256                 ; LDA #188          ; Bit 7 of s2_lo is clear, so print recursive token 28
     501C BC00     
17650 501E 0206  20        li   rtmp,TT27                  ; JSR TT27          ; ("HUMAN COLONIAL")
     5020 A6E8     
17651 5022 06A0  32        bl   @jsr                       ;
     5024 FF10     
17652               
17653 5026 0460  28        b    @TT76                      ; JMP TT76          ; Jump to TT76 to print "S)" and a paragraph break, so
     5028 50BE     
17654                                                                          ; the whole species string is "(HUMAN COLONIALS)"
17655               
17656               TT75:
17657 502A D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; This is an alien species, and we start with the first
     502C 007D     
17658 502E 0910  18        srl  ra,1                       ; LSR A             ; adjective, so fetch bits 2-7 of s2_hi into A and push
17659 5030 0910  18        srl  ra,1                       ; LSR A             ; onto the stack so we can use this later
17660                      .pha                            ; PHA
     **** ****     > PHA
0001 5032 D680  30        movb ra,*rsp
0002 5034 060A  14        dec  rsp
                   < elite.a99
17661               
17662 5036 0240  22        andi ra,>07*256                 ; AND #%00000111    ; Set A = bits 0-2 of A (so that's bits 2-4 of s2_hi)
     5038 0700     
17663               
17664 503A 0280  22        ci   ra,>03*256                 ; CMP #3            ; If A >= 3, jump to TT205 to skip the first adjective,
     503C 0300     
17665 503E 1808  14        joc  TT205                      ; BCS TT205
17666               
17667                      .adi (>e3*256)                  ; ADC #227          ; Otherwise A = 0, 1 or 2, so print recursive token
     **** ****     > ADI
0001 5040 1701  14        jnc  !
0002 5042 B004  18        ab   rone,ra
0003               !:
0004 5044 0220  22        ai   ra,(>E3*256)
     5046 E300     
                   < elite.a99
17668 5048 0206  20        li   rtmp,spc_                  ; JSR spc           ; 67 + A, followed by a space, so:
     504A 4EFE     
17669 504C 06A0  32        bl   @jsr                       ;
     504E FF10     
17670                                                                          ;
17671                                                                          ; A = 0 prints token 67 ("LARGE") and a space
17672                                                                          ; A = 1 prints token 68 ("FIERCE") and a space
17673                                                                          ; A = 2 prints token 69 ("SMALL") and a space
17674               
17675               TT205:
17676                      .pla                            ; PLA               ; Now for the second adjective, so restore A to bits
     **** ****     > PLA
0001 5050 058A  14        inc  rsp
0002 5052 D01A  26        movb *rsp,ra
                   < elite.a99
17677 5054 0910  18        srl  ra,1                       ; LSR A             ; 2-7 of s2_hi, and throw away bits 2-4 to leave
17678 5056 0910  18        srl  ra,1                       ; LSR A             ; A = bits 5-7 of s2_hi
17679 5058 0910  18        srl  ra,1                       ; LSR A
17680               
17681 505A 0280  22        ci   ra,>06*256                 ; CMP #6            ; If A >= 6, jump to TT206 to skip the second adjective
     505C 0600     
17682 505E 1808  14        joc  TT206                      ; BCS TT206
17683               
17684                      .adi (>e6*256)                  ; ADC #230          ; Otherwise A = 0 to 5, so print recursive token
     **** ****     > ADI
0001 5060 1701  14        jnc  !
0002 5062 B004  18        ab   rone,ra
0003               !:
0004 5064 0220  22        ai   ra,(>E6*256)
     5066 E600     
                   < elite.a99
17685 5068 0206  20        li   rtmp,spc_                  ; JSR spc           ; 70 + A, followed by a space, so:
     506A 4EFE     
17686 506C 06A0  32        bl   @jsr                       ;
     506E FF10     
17687                                                                          ;
17688                                                                          ; A = 0 prints token 70 ("GREEN") and a space
17689                                                                          ; A = 1 prints token 71 ("RED") and a space
17690                                                                          ; A = 2 prints token 72 ("YELLOW") and a space
17691                                                                          ; A = 3 prints token 73 ("BLUE") and a space
17692                                                                          ; A = 4 prints token 74 ("BLACK") and a space
17693                                                                          ; A = 5 prints token 75 ("HARMLESS") and a space
17694               
17695               TT206:
17696 5070 D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Now for the third adjective, so EOR the high bytes of
     5072 007B     
17697                      .eor @QQ15+1                    ; EOR QQ15+1        ; s0 and s1 and extract bits 0-2 of the result:
     **** ****     > EOR
0001 5074 D1A0  30        movb @QQ15+1,rtmp
     5076 0079     
0002 5078 2806  18        xor  rtmp,ra
                   < elite.a99
17698 507A 0240  22        andi ra,>07*256                 ; AND #%00000111    ;
     507C 0700     
17699 507E D800  30        movb ra,@QQ19                   ; STA QQ19          ; A = (s0_hi EOR s1_hi) AND %111
     5080 007F     
17700                                                                          ;
17701                                                                          ; storing the result in QQ19 so we can use it later
17702               
17703 5082 0280  22        ci   ra,>06*256                 ; CMP #6            ; If A >= 6, jump to TT207 to skip the third adjective
     5084 0600     
17704 5086 1808  14        joc  TT207                      ; BCS TT207
17705               
17706                      .adi (>ec*256)                  ; ADC #236          ; Otherwise A = 0 to 5, so print recursive token
     **** ****     > ADI
0001 5088 1701  14        jnc  !
0002 508A B004  18        ab   rone,ra
0003               !:
0004 508C 0220  22        ai   ra,(>EC*256)
     508E EC00     
                   < elite.a99
17707 5090 0206  20        li   rtmp,spc_                  ; JSR spc           ; 76 + A, followed by a space, so:
     5092 4EFE     
17708 5094 06A0  32        bl   @jsr                       ;
     5096 FF10     
17709                                                                          ;
17710                                                                          ; A = 0 prints token 76 ("SLIMY") and a space
17711                                                                          ; A = 1 prints token 77 ("BUG-EYED") and a space
17712                                                                          ; A = 2 prints token 78 ("HORNED") and a space
17713                                                                          ; A = 3 prints token 79 ("BONY") and a space
17714                                                                          ; A = 4 prints token 80 ("FAT") and a space
17715                                                                          ; A = 5 prints token 81 ("FURRY") and a space
17716               
17717               TT207:
17718 5098 D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Now for the actual species, so take bits 0-1 of
     509A 007D     
17719 509C 0240  22        andi ra,>03*256                 ; AND #%00000011    ; s2_hi, add this to the value of A that we used for
     509E 0300     
17720                      .clc                            ; CLC               ; the third adjective, and take bits 0-2 of the result
     **** ****     > CLC
0001 50A0 0A13  18        sla  rzero,1
                   < elite.a99
17721                      .adc @QQ19,ra                   ; ADC QQ19
     **** ****     > ADC
0001 50A2 1701  14        jnc  !
0002 50A4 B004  18        ab   rone,ra
0003               !:
0004 50A6 B020  30        ab   @QQ19,ra
     50A8 007F     
                   < elite.a99
17722 50AA 0240  22        andi ra,>07*256                 ; AND #%00000111
     50AC 0700     
17723               
17724                      .adi (>f2*256)                  ; ADC #242          ; A = 0 to 7, so print recursive token 82 + A, so:
     **** ****     > ADI
0001 50AE 1701  14        jnc  !
0002 50B0 B004  18        ab   rone,ra
0003               !:
0004 50B2 0220  22        ai   ra,(>F2*256)
     50B4 F200     
                   < elite.a99
17725 50B6 0206  20        li   rtmp,TT27                  ; JSR TT27          ;
     50B8 A6E8     
17726 50BA 06A0  32        bl   @jsr                       ;
     50BC FF10     
17727                                                                          ; A = 0 prints token 82 ("RODENT")
17728                                                                          ; A = 1 prints token 83 ("FROG")
17729                                                                          ; A = 2 prints token 84 ("LIZARD")
17730                                                                          ; A = 3 prints token 85 ("LOBSTER")
17731                                                                          ; A = 4 prints token 86 ("BIRD")
17732                                                                          ; A = 5 prints token 87 ("HUMANOID")
17733                                                                          ; A = 6 prints token 88 ("FELINE")
17734                                                                          ; A = 7 prints token 89 ("INSECT")
17735               
17736               TT76:
17737 50BE 0200  20        li   ra,('S')*256               ; LDA #'S'          ; Print an "S" to pluralise the species
     50C0 5300     
17738 50C2 0206  20        li   rtmp,TT27                  ; JSR TT27
     50C4 A6E8     
17739 50C6 06A0  32        bl   @jsr                       ;
     50C8 FF10     
17740               
17741 50CA 0200  20        li   ra,(')')*256               ; LDA #')'          ; And finally, print a closing bracket, followed by a
     50CC 2900     
17742 50CE 0206  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case, to end the species
     50D0 4ED4     
17743 50D2 06A0  32        bl   @jsr                       ;
     50D4 FF10     
17744                                                                          ; section
17745               
17746 50D6 0200  20        li   ra,>c1*256                 ; LDA #193          ; Print recursive token 33 ("GROSS PRODUCTIVITY"),
     50D8 C100     
17747 50DA 0206  20        li   rtmp,TT68                  ; JSR TT68          ; followed by a colon
     50DC A6DC     
17748 50DE 06A0  32        bl   @jsr                       ;
     50E0 FF10     
17749               
17750 50E2 D060  30        movb @QQ7,rx                    ; LDX QQ7           ; Fetch the 16-bit productivity value from QQ7 into
     50E4 0F2D     
17751 50E6 D0A0  30        movb @QQ7+1,ry                  ; LDY QQ7+1         ; (Y X)
     50E8 0F2E     
17752               
17753 50EA 0206  20        li   rtmp,pr6_                  ; JSR pr6           ; Print (Y X) to 5 digits with no decimal point
     50EC 5D44     
17754 50EE 06A0  32        bl   @jsr                       ;
     50F0 FF10     
17755               
17756 50F2 0206  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     50F4 5E64     
17757 50F6 06A0  32        bl   @jsr                       ;
     50F8 FF10     
17758               
17759 50FA 0200  20        li   ra,>00*256                 ; LDA #0            ; Set QQ17 = 0 to switch to ALL CAPS
     50FC 0000     
17760 50FE D800  30        movb ra,@QQ17                   ; STA QQ17
     5100 007E     
17761               
17762 5102 0200  20        li   ra,('M')*256               ; LDA #'M'          ; Print "M"
     5104 4D00     
17763 5106 0206  20        li   rtmp,TT27                  ; JSR TT27
     5108 A6E8     
17764 510A 06A0  32        bl   @jsr                       ;
     510C FF10     
17765               
17766 510E 0200  20        li   ra,>e2*256                 ; LDA #226          ; Print recursive token 66 (" CR"), followed by a
     5110 E200     
17767 5112 0206  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case
     5114 4ED4     
17768 5116 06A0  32        bl   @jsr                       ;
     5118 FF10     
17769               
17770 511A 0200  20        li   ra,>fa*256                 ; LDA #250          ; Print recursive token 90 ("AVERAGE RADIUS"), followed
     511C FA00     
17771 511E 0206  20        li   rtmp,TT68                  ; JSR TT68          ; by a colon
     5120 A6DC     
17772 5122 06A0  32        bl   @jsr                       ;
     5124 FF10     
17773               
17774                                                                          ; The average radius is calculated like this:
17775                                                                          ;
17776                                                                          ; ((s2_hi AND %1111) + 11) * 256 + s1_hi
17777                                                                          ;
17778                                                                          ; or, in terms of memory locations:
17779                                                                          ;
17780                                                                          ; ((QQ15+5 AND %1111) + 11) * 256 + QQ15+3
17781                                                                          ;
17782                                                                          ; Because the multiplication is by 256, this is the
17783                                                                          ; same as saying a 16-bit number, with high byte:
17784                                                                          ;
17785                                                                          ; (QQ15+5 AND %1111) + 11
17786                                                                          ;
17787                                                                          ; and low byte:
17788                                                                          ;
17789                                                                          ; QQ15+3
17790                                                                          ;
17791                                                                          ; so we can set this up in (Y X) and call the pr5
17792                                                                          ; routine to print it out
17793               
17794 5126 D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Set A = QQ15+5
     5128 007D     
17795 512A D060  30        movb @QQ15+3,rx                 ; LDX QQ15+3        ; Set X = QQ15+3
     512C 007B     
17796               
17797 512E 0240  22        andi ra,>0f*256                 ; AND #%00001111    ; Set Y = (A AND %1111) + 11
     5130 0F00     
17798                      .clc                            ; CLC
     **** ****     > CLC
0001 5132 0A13  18        sla  rzero,1
                   < elite.a99
17799                      .adi (>0b*256)                  ; ADC #11
     **** ****     > ADI
0001 5134 1701  14        jnc  !
0002 5136 B004  18        ab   rone,ra
0003               !:
0004 5138 0220  22        ai   ra,(>0B*256)
     513A 0B00     
                   < elite.a99
17800 513C D080  18        movb ra,ry                      ; TAY
17801               
17802 513E 0206  20        li   rtmp,pr5_                  ; JSR pr5           ; Print (Y X) to 5 digits, not including a decimal
     5140 5D46     
17803 5142 06A0  32        bl   @jsr                       ;
     5144 FF10     
17804                                                                          ; point, as the C flag will be clear (as the maximum
17805                                                                          ; radius will always fit into 16 bits)
17806               
17807 5146 0206  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     5148 5E64     
17808 514A 06A0  32        bl   @jsr                       ;
     514C FF10     
17809               
17810 514E 0200  20        li   ra,('k')*256               ; LDA #'k'          ; Print "km", returning from the subroutine using a
     5150 6B00     
17811 5152 0206  20        li   rtmp,TT26                  ; JSR TT26          ; tail call
     5154 3172     
17812 5156 06A0  32        bl   @jsr                       ;
     5158 FF10     
17813 515A 0200  20        li   ra,('m')*256               ; LDA #'m'
     515C 6D00     
17814 515E 0460  28        b    @TT26                      ; JMP TT26
     5160 3172     
17815               
17816               * ******************************************************************************
17817               *
17818               * Name: TT24
17819               * Type: Subroutine
17820               * Category: Universe
17821               * Summary: Calculate system data from the system seeds
17822               * Deep dive: Generating system data
17823               * Galaxy and system seeds
17824               *
17825               * ------------------------------------------------------------------------------
17826               *
17827               * Calculate system data from the seeds in QQ15 and store them in the relevant
17828               * locations. Specifically, this routine calculates the following from the three
17829               * 16-bit seeds in QQ15 (using only s0_hi, s1_hi and s1_lo):
17830               *
17831               * QQ3 = economy (0-7)
17832               * QQ4 = government (0-7)
17833               * QQ5 = technology level (0-14)
17834               * QQ6 = population * 10 (1-71)
17835               * QQ7 = productivity (96-62480)
17836               *
17837               * The ranges of the various values are shown in brackets. Note that the radius
17838               * and type of inhabitant are calculated on-the-fly in the TT25 routine when
17839               * the system data gets displayed, so they aren't calculated here.
17840               *
17841               * ******************************************************************************
17842               
17843               TT24:
17844 5162 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch s0_hi and extract bits 0-2 to determine the
     5164 0079     
17845 5166 0240  22        andi ra,>07*256                 ; AND #%00000111    ; system's economy, and store in QQ3
     5168 0700     
17846 516A D800  30        movb ra,@QQ3                    ; STA QQ3
     516C 0F28     
17847               
17848 516E D020  30        movb @QQ15+2,ra                 ; LDA QQ15+2        ; Fetch s1_lo and extract bits 3-5 to determine the
     5170 007A     
17849 5172 0910  18        srl  ra,1                       ; LSR A             ; system's government, and store in QQ4
17850 5174 0910  18        srl  ra,1                       ; LSR A
17851 5176 0910  18        srl  ra,1                       ; LSR A
17852 5178 0240  22        andi ra,>07*256                 ; AND #%00000111
     517A 0700     
17853 517C D800  30        movb ra,@QQ4                    ; STA QQ4
     517E 0F29     
17854               
17855 5180 0910  18        srl  ra,1                       ; LSR A             ; If government isn't anarchy or feudal, skip to TT77,
17856 5182 1606  14        jne  TT77                       ; BNE TT77          ; as we need to fix the economy of anarchy and feudal
17857                                                                          ; systems so they can't be rich
17858               
17859 5184 D020  30        movb @QQ3,ra                    ; LDA QQ3           ; Set bit 1 of the economy in QQ3 to fix the economy
     5186 0F28     
17860 5188 0260  22        ori  ra,>02*256                 ; ORA #%00000010    ; for anarchy and feudal governments
     518A 0200     
17861 518C D800  30        movb ra,@QQ3                    ; STA QQ3
     518E 0F28     
17862               
17863               TT77:
17864 5190 D020  30        movb @QQ3,ra                    ; LDA QQ3           ; Now to work out the tech level, which we do like this:
     5192 0F28     
17865                      .eoi (>07*256)                  ; EOR #%00000111    ;
     **** ****     > EOI
0001 5194 0206  20        li   rtmp,(>07*256)
     5196 0700     
0002 5198 2806  18        xor  rtmp,ra
                   < elite.a99
17866                      .clc                            ; CLC               ; flipped_economy + (s1_hi AND %11) + (government / 2)
     **** ****     > CLC
0001 519A 0A13  18        sla  rzero,1
                   < elite.a99
17867 519C D800  30        movb ra,@QQ5                    ; STA QQ5           ;
     519E 0F2A     
17868                                                                          ; or, in terms of memory locations:
17869                                                                          ;
17870                                                                          ; QQ5 = (QQ3 EOR %111) + (QQ15+3 AND %11) + (QQ4 / 2)
17871                                                                          ;
17872                                                                          ; We start by setting QQ5 = QQ3 EOR %111
17873               
17874 51A0 D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; We then take the first 2 bits of s1_hi (QQ15+3) and
     51A2 007B     
17875 51A4 0240  22        andi ra,>03*256                 ; AND #%00000011    ; add it into QQ5
     51A6 0300     
17876                      .adc @QQ5,ra                    ; ADC QQ5
     **** ****     > ADC
0001 51A8 1701  14        jnc  !
0002 51AA B004  18        ab   rone,ra
0003               !:
0004 51AC B020  30        ab   @QQ5,ra
     51AE 0F2A     
                   < elite.a99
17877 51B0 D800  30        movb ra,@QQ5                    ; STA QQ5
     51B2 0F2A     
17878               
17879 51B4 D020  30        movb @QQ4,ra                    ; LDA QQ4           ; And finally we add QQ4 / 2 and store the result in
     51B6 0F29     
17880 51B8 0910  18        srl  ra,1                       ; LSR A             ; QQ5, using LSR then ADC to divide by 2, which rounds
17881                      .adc @QQ5,ra                    ; ADC QQ5           ; up the result for odd-numbered government types
     **** ****     > ADC
0001 51BA 1701  14        jnc  !
0002 51BC B004  18        ab   rone,ra
0003               !:
0004 51BE B020  30        ab   @QQ5,ra
     51C0 0F2A     
                   < elite.a99
17882 51C2 D800  30        movb ra,@QQ5                    ; STA QQ5
     51C4 0F2A     
17883               
17884                      .asla                           ; ASL A             ; Now to work out the population, like so:
     **** ****     > ASLA
0001 51C6 0240  22        andi ra,>ff00
     51C8 FF00     
0002 51CA 0A10  18        sla  ra,1
                   < elite.a99
17885                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 51CC 0240  22        andi ra,>ff00
     51CE FF00     
0002 51D0 0A10  18        sla  ra,1
                   < elite.a99
17886                      .adc @QQ3,ra                    ; ADC QQ3           ; (tech level * 4) + economy + government + 1
     **** ****     > ADC
0001 51D2 1701  14        jnc  !
0002 51D4 B004  18        ab   rone,ra
0003               !:
0004 51D6 B020  30        ab   @QQ3,ra
     51D8 0F28     
                   < elite.a99
17887                      .adc @QQ4,ra                    ; ADC QQ4           ;
     **** ****     > ADC
0001 51DA 1701  14        jnc  !
0002 51DC B004  18        ab   rone,ra
0003               !:
0004 51DE B020  30        ab   @QQ4,ra
     51E0 0F29     
                   < elite.a99
17888                      .adi (>01*256)                  ; ADC #1            ; or, in terms of memory locations:
     **** ****     > ADI
0001 51E2 1701  14        jnc  !
0002 51E4 B004  18        ab   rone,ra
0003               !:
0004 51E6 0220  22        ai   ra,(>01*256)
     51E8 0100     
                   < elite.a99
17889 51EA D800  30        movb ra,@QQ6                    ; STA QQ6           ;
     51EC 0F2B     
17890                                                                          ; QQ6 = (QQ5 * 4) + QQ3 + QQ4 + 1
17891               
17892 51EE D020  30        movb @QQ3,ra                    ; LDA QQ3           ; Finally, we work out productivity, like this:
     51F0 0F28     
17893                      .eoi (>07*256)                  ; EOR #%00000111    ;
     **** ****     > EOI
0001 51F2 0206  20        li   rtmp,(>07*256)
     51F4 0700     
0002 51F6 2806  18        xor  rtmp,ra
                   < elite.a99
17894                      .adi (>03*256)                  ; ADC #3            ; (flipped_economy + 3) * (government + 4)
     **** ****     > ADI
0001 51F8 1701  14        jnc  !
0002 51FA B004  18        ab   rone,ra
0003               !:
0004 51FC 0220  22        ai   ra,(>03*256)
     51FE 0300     
                   < elite.a99
17895 5200 D800  30        movb ra,@P                      ; STA P             ; * population
     5202 001B     
17896 5204 D020  30        movb @QQ4,ra                    ; LDA QQ4           ; * 8
     5206 0F29     
17897                      .adi (>04*256)                  ; ADC #4            ;
     **** ****     > ADI
0001 5208 1701  14        jnc  !
0002 520A B004  18        ab   rone,ra
0003               !:
0004 520C 0220  22        ai   ra,(>04*256)
     520E 0400     
                   < elite.a99
17898 5210 D800  30        movb ra,@Q                      ; STA Q             ; or, in terms of memory locations:
     5212 0090     
17899 5214 0206  20        li   rtmp,MULTU                 ; JSR MULTU         ;
     5216 42DE     
17900 5218 06A0  32        bl   @jsr                       ;
     521A FF10     
17901                                                                          ; QQ7 = (QQ3 EOR %111 + 3) * (QQ4 + 4) * QQ6 * 8
17902                                                                          ;
17903                                                                          ; We do the first step by setting P to the first
17904                                                                          ; expression in brackets and Q to the second, and
17905                                                                          ; calling MULTU, so now (A P) = P * Q. The highest this
17906                                                                          ; can be is 10 * 11 (as the maximum values of economy
17907                                                                          ; and government are 7), so the high byte of the result
17908                                                                          ; will always be 0, so we actually have:
17909                                                                          ;
17910                                                                          ; P = P * Q
17911                                                                          ; = (flipped_economy + 3) * (government + 4)
17912               
17913 521C D020  30        movb @QQ6,ra                    ; LDA QQ6           ; We now take the result in P and multiply by the
     521E 0F2B     
17914 5220 D800  30        movb ra,@Q                      ; STA Q             ; population to get the productivity, by setting Q to
     5222 0090     
17915 5224 0206  20        li   rtmp,MULTU                 ; JSR MULTU         ; the population from QQ6 and calling MULTU again, so
     5226 42DE     
17916 5228 06A0  32        bl   @jsr                       ;
     522A FF10     
17917                                                                          ; now we have:
17918                                                                          ;
17919                                                                          ; (A P) = P * population
17920               
17921                      .asl @P                         ; ASL P             ; Next we multiply the result by 8, as a 16-bit number,
     **** ****     > ASL
0001 522C D1A0  30        movb @P,rtmp
     522E 001B     
0002 5230 0246  22        andi rtmp,>ff00
     5232 FF00     
0003 5234 0A16  18        sla  rtmp,1
0004 5236 D806  30        movb rtmp,@P
     5238 001B     
                   < elite.a99
17922 523A 06A0  32        bl   @rola                      ; ROL A             ; so we shift both bytes to the left three times, using
     523C FF26     
17923                      .asl @P                         ; ASL P             ; the C flag to carry bits from bit 7 of the low byte
     **** ****     > ASL
0001 523E D1A0  30        movb @P,rtmp
     5240 001B     
0002 5242 0246  22        andi rtmp,>ff00
     5244 FF00     
0003 5246 0A16  18        sla  rtmp,1
0004 5248 D806  30        movb rtmp,@P
     524A 001B     
                   < elite.a99
17924 524C 06A0  32        bl   @rola                      ; ROL A             ; into bit 0 of the high byte
     524E FF26     
17925                      .asl @P                         ; ASL P
     **** ****     > ASL
0001 5250 D1A0  30        movb @P,rtmp
     5252 001B     
0002 5254 0246  22        andi rtmp,>ff00
     5256 FF00     
0003 5258 0A16  18        sla  rtmp,1
0004 525A D806  30        movb rtmp,@P
     525C 001B     
                   < elite.a99
17926 525E 06A0  32        bl   @rola                      ; ROL A
     5260 FF26     
17927               
17928 5262 D800  30        movb ra,@QQ7+1                  ; STA QQ7+1         ; Finally, we store the productivity in two bytes, with
     5264 0F2E     
17929 5266 D020  30        movb @P,ra                      ; LDA P             ; the low byte in QQ7 and the high byte in QQ7+1
     5268 001B     
17930 526A D800  30        movb ra,@QQ7                    ; STA QQ7
     526C 0F2D     
17931               
17932 526E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5270 FF1C     
17933               
17934               * ******************************************************************************
17935               *
17936               * Name: TT22
17937               * Type: Subroutine
17938               * Category: Charts
17939               * Summary: Show the Long-range Chart (red key f4)
17940               *
17941               * ******************************************************************************
17942               
17943               TT22:
17944 5272 0200  20        li   ra,>40*256                 ; LDA #64           ; Clear the top part of the screen, draw a white border,
     5274 4000     
17945 5276 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 32 (Long-
     5278 4B2A     
17946 527A 06A0  32        bl   @jsr                       ;
     527C FF10     
17947                                                                          ; range Chart)
17948               
17949 527E 0200  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     5280 0700     
17950 5282 D800  30        movb ra,@XC                     ; STA XC
     5284 002C     
17951               
17952 5286 0206  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     5288 5AA4     
17953 528A 06A0  32        bl   @jsr                       ;
     528C FF10     
17954                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
17955               
17956 528E 0200  20        li   ra,>c7*256                 ; LDA #199          ; Print recursive token 39 ("GALACTIC CHART{galaxy
     5290 C700     
17957 5292 0206  20        li   rtmp,TT27                  ; JSR TT27          ; number right-aligned to width 3}")
     5294 A6E8     
17958 5296 06A0  32        bl   @jsr                       ;
     5298 FF10     
17959               
17960 529A 0206  20        li   rtmp,NLIN                  ; JSR NLIN          ; Draw a horizontal line at pixel row 23 to box in the
     529C 25BE     
17961 529E 06A0  32        bl   @jsr                       ;
     52A0 FF10     
17962                                                                          ; title and act as the top frame of the chart, and move
17963                                                                          ; the text cursor down one line
17964               
17965 52A2 0200  20        li   ra,>98*256                 ; LDA #152          ; Draw a screen-wide horizontal line at pixel row 152
     52A4 9800     
17966 52A6 0206  20        li   rtmp,NLIN2                 ; JSR NLIN2         ; for the bottom edge of the chart, so the chart itself
     52A8 25C4     
17967 52AA 06A0  32        bl   @jsr                       ;
     52AC FF10     
17968                                                                          ; is 128 pixels high, starting on row 24 and ending on
17969                                                                          ; row 151
17970               
17971 52AE 0206  20        li   rtmp,TT14                  ; JSR TT14          ; Call TT14 to draw a circle with crosshairs at the
     52B0 53FA     
17972 52B2 06A0  32        bl   @jsr                       ;
     52B4 FF10     
17973                                                                          ; current system's galactic coordinates
17974               
17975 52B6 0201  20        li   rx,>00*256                 ; LDX #0            ; We're now going to plot each of the galaxy's systems,
     52B8 0000     
17976                                                                          ; so set up a counter in X for each system, starting at
17977                                                                          ; 0 and looping through to 255
17978               
17979               TT83:
17980 52BA D801  30        movb rx,@XSAV                   ; STX XSAV          ; Store the counter in XSAV
     52BC 0093     
17981               
17982 52BE D060  30        movb @QQ15+3,rx                 ; LDX QQ15+3        ; Fetch the s1_hi seed into X, which gives us the
     52C0 007B     
17983                                                                          ; galactic x-coordinate of this system
17984               
17985 52C2 D0A0  30        movb @QQ15+4,ry                 ; LDY QQ15+4        ; Fetch the s2_lo seed and set bits 4 and 6, storing the
     52C4 007C     
17986 52C6 D002  18        movb ry,ra                      ; TYA               ; result in ZZ to give a random number between 80 and
17987 52C8 0260  22        ori  ra,>50*256                 ; ORA #%01010000    ; (but which will always be the same for this system).
     52CA 5000     
17988 52CC D800  30        movb ra,@ZZ                     ; STA ZZ            ; We use this value to determine the size of the point
     52CE 0097     
17989                                                                          ; for this system on the chart by passing it as the
17990                                                                          ; distance argument to the PIXEL routine below
17991               
17992 52D0 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch the s0_hi seed into A, which gives us the
     52D2 0079     
17993                                                                          ; galactic y-coordinate of this system
17994               
17995 52D4 0910  18        srl  ra,1                       ; LSR A             ; We halve the y-coordinate because the galaxy in
17996                                                                          ; in Elite is rectangular rather than square, and is
17997                                                                          ; twice as wide (x-axis) as it is high (y-axis), so the
17998                                                                          ; chart is 256 pixels wide and 128 high
17999               
18000                      .clc                            ; CLC               ; Add 24 to the halved y-coordinate and store in XX15+1
     **** ****     > CLC
0001 52D6 0A13  18        sla  rzero,1
                   < elite.a99
18001                      .adi (>18*256)                  ; ADC #24           ; (as the top of the chart is on pixel row 24, just
     **** ****     > ADI
0001 52D8 1701  14        jnc  !
0002 52DA B004  18        ab   rone,ra
0003               !:
0004 52DC 0220  22        ai   ra,(>18*256)
     52DE 1800     
                   < elite.a99
18002 52E0 D800  30        movb ra,@XX15+1                 ; STA XX15+1        ; below the line we drew on row 23 above)
     52E2 0032     
18003               
18004 52E4 0206  20        li   rtmp,PIXEL                 ; JSR PIXEL         ; Call PIXEL to draw a point at (X, A), with the size of
     52E6 27BC     
18005 52E8 06A0  32        bl   @jsr                       ;
     52EA FF10     
18006                                                                          ; the point dependent on the distance specified in ZZ
18007                                                                          ; (so a high value of ZZ will produce a 1-pixel point,
18008                                                                          ; a medium value will produce a 2-pixel dash, and a
18009                                                                          ; small value will produce a 4-pixel square)
18010               
18011 52EC 0206  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     52EE 4E32     
18012 52F0 06A0  32        bl   @jsr                       ;
     52F2 FF10     
18013                                                                          ; to twist the three 16-bit seeds in QQ15
18014               
18015 52F4 D060  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the loop counter from XSAV
     52F6 0093     
18016               
18017 52F8 B044  18        ab   rone,rx                    ; INX               ; Increment the counter
18018               
18019 52FA 16DF  14        jne  TT83                       ; BNE TT83          ; If X > 0 then we haven't done all 256 systems yet, so
18020                                                                          ; loop back up to TT83
18021               
18022 52FC D020  30        movb @QQ9,ra                    ; LDA QQ9           ; Set QQ19 to the selected system's x-coordinate
     52FE 0F31     
18023 5300 D800  30        movb ra,@QQ19                   ; STA QQ19
     5302 007F     
18024               
18025 5304 D020  30        movb @QQ10,ra                   ; LDA QQ10          ; Set QQ19+1 to the selected system's y-coordinate,
     5306 0F32     
18026 5308 0910  18        srl  ra,1                       ; LSR A             ; halved to fit it into the chart
18027 530A D800  30        movb ra,@QQ19+1                 ; STA QQ19+1
     530C 0080     
18028               
18029 530E 0200  20        li   ra,>04*256                 ; LDA #4            ; Set QQ19+2 to size 4 for the crosshairs size
     5310 0400     
18030 5312 D800  30        movb ra,@QQ19+2                 ; STA QQ19+2
     5314 0081     
18031               
18032                                                                          ; Fall through into TT15 to draw crosshairs of size 4 at
18033                                                                          ; the selected system's coordinates
18034               
18035               * ******************************************************************************
18036               *
18037               * Name: TT15
18038               * Type: Subroutine
18039               * Category: Drawing lines
18040               * Summary: Draw a set of crosshairs
18041               *
18042               * ------------------------------------------------------------------------------
18043               *
18044               * For all views except the Short-range Chart, the centre is drawn 24 pixels to
18045               * the right of the y-coordinate given.
18046               *
18047               * ------------------------------------------------------------------------------
18048               *
18049               * Arguments:
18050               *
18051               * QQ19                The pixel x-coordinate of the centre of the crosshairs
18052               *
18053               * QQ19+1              The pixel y-coordinate of the centre of the crosshairs
18054               *
18055               * QQ19+2              The size of the crosshairs
18056               *
18057               * ******************************************************************************
18058               
18059               TT15:
18060 5316 0200  20        li   ra,>18*256                 ; LDA #24           ; Set A to 24, which we will use as the minimum
     5318 1800     
18061                                                                          ; screen indent for the crosshairs (i.e. the minimum
18062                                                                          ; distance from the top-left corner of the screen)
18063               
18064 531A D060  30        movb @QQ11,rx                   ; LDX QQ11          ; If the current view is not the Short-range Chart,
     531C 0096     
18065 531E 1502  14        jgt  B52                        ; BPL B52           ; which is the only view with bit 7 set, then skip the
18066                                                                          ; following instruction
18067               
18068 5320 0200  20        li   ra,>00*256                 ; LDA #0            ; This is the Short-range Chart, so set A to 0, so the
     5322 0000     
18069                                                                          ; crosshairs can go right up against the screen edges
18070               
18071               B52:
18072 5324 D800  30        movb ra,@QQ19+5                 ; STA QQ19+5        ; Set QQ19+5 to A, which now contains the correct indent
     5326 0084     
18073                                                                          ; for this view
18074               
18075 5328 D020  30        movb @QQ19,ra                   ; LDA QQ19          ; Set A = crosshairs x-coordinate - crosshairs size
     532A 007F     
18076                      .sec                            ; SEC               ; to get the x-coordinate of the left edge of the
     **** ****     > SEC
0001 532C 0A15  18        sla  rmone,1
                   < elite.a99
18077                      .sbc @QQ19+2,ra                 ; SBC QQ19+2        ; crosshairs
     **** ****     > SBC
0001 532E 1801  14        joc  !
0002 5330 7004  18        sb   rone,ra
0003               !:
0004 5332 7020  30        sb   @QQ19+2,ra
     5334 0081     
                   < elite.a99
18078               
18079 5336 1802  14        joc  TT84                       ; BCS TT84          ; If the above subtraction didn't underflow, then A is
18080                                                                          ; positive, so skip the next instruction
18081               
18082 5338 0200  20        li   ra,>00*256                 ; LDA #0            ; The subtraction underflowed, so set A to 0 so the
     533A 0000     
18083                                                                          ; crosshairs don't spill out of the left of the screen
18084               
18085               TT84:
18086                                                                          ; In the following, the authors have used XX15 for
18087                                                                          ; temporary storage. XX15 shares location with X1, Y1,
18088                                                                          ; X2 and Y2, so in the following, you can consider
18089                                                                          ; the variables like this:
18090                                                                          ;
18091                                                                          ; XX15   is the same as X1
18092                                                                          ; XX15+1 is the same as Y1
18093                                                                          ; XX15+2 is the same as X2
18094                                                                          ; XX15+3 is the same as Y2
18095                                                                          ;
18096                                                                          ; Presumably this routine was written at a different
18097                                                                          ; time to the line-drawing routine, before the two
18098                                                                          ; workspaces were merged to save space
18099 533C D800  30        movb ra,@XX15                   ; STA XX15          ; Set XX15 (X1) = A (the x-coordinate of the left edge
     533E 0031     
18100                                                                          ; of the crosshairs)
18101               
18102 5340 D020  30        movb @QQ19,ra                   ; LDA QQ19          ; Set A = crosshairs x-coordinate + crosshairs size
     5342 007F     
18103                      .clc                            ; CLC               ; to get the x-coordinate of the right edge of the
     **** ****     > CLC
0001 5344 0A13  18        sla  rzero,1
                   < elite.a99
18104                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; crosshairs
     **** ****     > ADC
0001 5346 1701  14        jnc  !
0002 5348 B004  18        ab   rone,ra
0003               !:
0004 534A B020  30        ab   @QQ19+2,ra
     534C 0081     
                   < elite.a99
18105               
18106 534E 1702  14        jnc  B53                        ; BCC B53           ; If the above addition didn't overflow, then A is
18107                                                                          ; correct, so skip the next instruction
18108               
18109 5350 0200  20        li   ra,>ff*256                 ; LDA #255          ; The addition overflowed, so set A to 255 so the
     5352 FF00     
18110                                                                          ; crosshairs don't spill out of the right of the screen
18111                                                                          ; (as 255 is the x-coordinate of the rightmost pixel
18112                                                                          ; on-screen)
18113               
18114               B53:
18115 5354 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 (X2) = A (the x-coordinate of the right
     5356 0033     
18116                                                                          ; edge of the crosshairs)
18117               
18118 5358 D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set XX15+1 (Y1) = crosshairs y-coordinate + indent
     535A 0080     
18119                      .clc                            ; CLC               ; to get the y-coordinate of the centre of the
     **** ****     > CLC
0001 535C 0A13  18        sla  rzero,1
                   < elite.a99
18120                      .adc @QQ19+5,ra                 ; ADC QQ19+5        ; crosshairs
     **** ****     > ADC
0001 535E 1701  14        jnc  !
0002 5360 B004  18        ab   rone,ra
0003               !:
0004 5362 B020  30        ab   @QQ19+5,ra
     5364 0084     
                   < elite.a99
18121 5366 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     5368 0032     
18122               
18123 536A 0206  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1),
     536C 25EE     
18124 536E 06A0  32        bl   @jsr                       ;
     5370 FF10     
18125                                                                          ; which will draw from the left edge of the crosshairs
18126                                                                          ; to the right edge, through the centre of the
18127                                                                          ; crosshairs
18128               
18129 5372 D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set A = crosshairs y-coordinate - crosshairs size
     5374 0080     
18130                      .sec                            ; SEC               ; to get the y-coordinate of the top edge of the
     **** ****     > SEC
0001 5376 0A15  18        sla  rmone,1
                   < elite.a99
18131                      .sbc @QQ19+2,ra                 ; SBC QQ19+2        ; crosshairs
     **** ****     > SBC
0001 5378 1801  14        joc  !
0002 537A 7004  18        sb   rone,ra
0003               !:
0004 537C 7020  30        sb   @QQ19+2,ra
     537E 0081     
                   < elite.a99
18132               
18133 5380 1802  14        joc  TT86                       ; BCS TT86          ; If the above subtraction didn't underflow, then A is
18134                                                                          ; correct, so skip the next instruction
18135               
18136 5382 0200  20        li   ra,>00*256                 ; LDA #0            ; The subtraction underflowed, so set A to 0 so the
     5384 0000     
18137                                                                          ; crosshairs don't spill out of the top of the screen
18138               
18139               TT86:
18140                      .clc                            ; CLC               ; Set XX15+1 (Y1) = A + indent to get the y-coordinate
     **** ****     > CLC
0001 5386 0A13  18        sla  rzero,1
                   < elite.a99
18141                      .adc @QQ19+5,ra                 ; ADC QQ19+5        ; of the top edge of the indented crosshairs
     **** ****     > ADC
0001 5388 1701  14        jnc  !
0002 538A B004  18        ab   rone,ra
0003               !:
0004 538C B020  30        ab   @QQ19+5,ra
     538E 0084     
                   < elite.a99
18142 5390 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     5392 0032     
18143               
18144 5394 D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set A = crosshairs y-coordinate + crosshairs size
     5396 0080     
18145                      .clc                            ; CLC               ; + indent to get the y-coordinate of the bottom edge
     **** ****     > CLC
0001 5398 0A13  18        sla  rzero,1
                   < elite.a99
18146                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; of the indented crosshairs
     **** ****     > ADC
0001 539A 1701  14        jnc  !
0002 539C B004  18        ab   rone,ra
0003               !:
0004 539E B020  30        ab   @QQ19+2,ra
     53A0 0081     
                   < elite.a99
18147                      .adc @QQ19+5,ra                 ; ADC QQ19+5
     **** ****     > ADC
0001 53A2 1701  14        jnc  !
0002 53A4 B004  18        ab   rone,ra
0003               !:
0004 53A6 B020  30        ab   @QQ19+5,ra
     53A8 0084     
                   < elite.a99
18148               
18149 53AA 0280  22        ci   ra,>98*256                 ; CMP #152          ; If A < 152 then skip the following, as the crosshairs
     53AC 9800     
18150 53AE 1705  14        jnc  TT87                       ; BCC TT87          ; won't spill out of the bottom of the screen
18151               
18152 53B0 D060  30        movb @QQ11,rx                   ; LDX QQ11          ; A >= 152, so we need to check whether this will fit in
     53B2 0096     
18153                                                                          ; this view, so fetch the view type
18154               
18155 53B4 1102  14        jlt  TT87                       ; BMI TT87          ; If this is the Short-range Chart then the y-coordinate
18156                                                                          ; is fine, so skip to TT87
18157               
18158 53B6 0200  20        li   ra,>97*256                 ; LDA #151          ; Otherwise this is the Long-range Chart, so we need to
     53B8 9700     
18159                                                                          ; clip the crosshairs at a maximum y-coordinate of 151
18160               
18161               TT87:
18162 53BA D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; Set XX15+3 (Y2) = A (the y-coordinate of the bottom
     53BC 0034     
18163                                                                          ; edge of the crosshairs)
18164               
18165 53BE D020  30        movb @QQ19,ra                   ; LDA QQ19          ; Set XX15 (X1) = the x-coordinate of the centre of the
     53C0 007F     
18166 53C2 D800  30        movb ra,@XX15                   ; STA XX15          ; crosshairs
     53C4 0031     
18167               
18168 53C6 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 (X2) = the x-coordinate of the centre of
     53C8 0033     
18169                                                                          ; the crosshairs
18170               
18171 53CA 0460  28        b    @LL30                      ; JMP LL30          ; Draw a vertical line (X1, Y1) to (X2, Y2), which will
     53CC 224E     
18172                                                                          ; draw from the top edge of the crosshairs to the bottom
18173                                                                          ; edge, through the centre of the crosshairs, returning
18174                                                                          ; from the subroutine using a tail call
18175               
18176               * ******************************************************************************
18177               *
18178               * Name: TT14
18179               * Type: Subroutine
18180               * Category: Drawing circles
18181               * Summary: Draw a circle with crosshairs on a chart
18182               *
18183               * ------------------------------------------------------------------------------
18184               *
18185               * Draw a circle with crosshairs at the current system's galactic coordinates.
18186               *
18187               * ******************************************************************************
18188               
18189               TT126:
18190 53CE 0200  20        li   ra,>68*256                 ; LDA #104          ; Set QQ19 = 104, for the x-coordinate of the centre of
     53D0 6800     
18191 53D2 D800  30        movb ra,@QQ19                   ; STA QQ19          ; the fixed circle on the Short-range Chart
     53D4 007F     
18192               
18193 53D6 0200  20        li   ra,>5a*256                 ; LDA #90           ; Set QQ19+1 = 90, for the y-coordinate of the centre of
     53D8 5A00     
18194 53DA D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; the fixed circle on the Short-range Chart
     53DC 0080     
18195               
18196 53DE 0200  20        li   ra,>10*256                 ; LDA #16           ; Set QQ19+2 = 16, the size of the crosshairs on the
     53E0 1000     
18197 53E2 D800  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Short-range Chart
     53E4 0081     
18198               
18199 53E6 0206  20        li   rtmp,TT15                  ; JSR TT15          ; Draw the set of crosshairs defined in QQ19, at the
     53E8 5316     
18200 53EA 06A0  32        bl   @jsr                       ;
     53EC FF10     
18201                                                                          ; exact coordinates as this is the Short-range Chart
18202               
18203 53EE D020  30        movb @QQ14,ra                   ; LDA QQ14          ; Set K to the fuel level from QQ14, so this can act as
     53F0 030D     
18204 53F2 D800  30        movb ra,@K                      ; STA K             ; the circle's radius (70 being a full tank)
     53F4 003D     
18205               
18206 53F6 0460  28        b    @TT128                     ; JMP TT128         ; Jump to TT128 to draw a circle with the centre at the
     53F8 5440     
18207                                                                          ; same coordinates as the crosshairs, (QQ19, QQ19+1),
18208                                                                          ; and radius K that reflects the current fuel levels,
18209                                                                          ; returning from the subroutine using a tail call
18210               
18211               TT14:
18212 53FA D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is the Short-range Chart, which
     53FC 0096     
18213 53FE 11E7  14        jlt  TT126                      ; BMI TT126         ; is the only view with bit 7 set, then jump up to TT126
18214                                                                          ; to draw the crosshairs and circle for that view
18215               
18216                                                                          ; Otherwise this is the Long-range Chart, so we draw the
18217                                                                          ; crosshairs and circle for that view instead
18218               
18219 5400 D020  30        movb @QQ14,ra                   ; LDA QQ14          ; Set K to the fuel level from QQ14 divided by 4, so
     5402 030D     
18220 5404 0910  18        srl  ra,1                       ; LSR A             ; this can act as the circle's radius (70 being a full
18221 5406 0910  18        srl  ra,1                       ; LSR A             ; tank, which divides down to a radius of 17)
18222 5408 D800  30        movb ra,@K                      ; STA K
     540A 003D     
18223               
18224 540C D020  30        movb @QQ0,ra                    ; LDA QQ0           ; Set QQ19 to the x-coordinate of the current system,
     540E 0301     
18225 5410 D800  30        movb ra,@QQ19                   ; STA QQ19          ; which will be the centre of the circle and crosshairs
     5412 007F     
18226                                                                          ; we draw
18227               
18228 5414 D020  30        movb @QQ1,ra                    ; LDA QQ1           ; Set QQ19+1 to the y-coordinate of the current system,
     5416 0302     
18229 5418 0910  18        srl  ra,1                       ; LSR A             ; halved because the galactic chart is half as high as
18230 541A D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; it is wide, which will again be the centre of the
     541C 0080     
18231                                                                          ; circle and crosshairs we draw
18232               
18233 541E 0200  20        li   ra,>07*256                 ; LDA #7            ; Set QQ19+2 = 7, the size of the crosshairs on the
     5420 0700     
18234 5422 D800  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Long-range Chart
     5424 0081     
18235               
18236 5426 0206  20        li   rtmp,TT15                  ; JSR TT15          ; Draw the set of crosshairs defined in QQ19, which will
     5428 5316     
18237 542A 06A0  32        bl   @jsr                       ;
     542C FF10     
18238                                                                          ; be drawn 24 pixels to the right of QQ19+1
18239               
18240 542E D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Add 24 to the y-coordinate of the crosshairs in QQ19+1
     5430 0080     
18241                      .clc                            ; CLC               ; so that the centre of the circle matches the centre
     **** ****     > CLC
0001 5432 0A13  18        sla  rzero,1
                   < elite.a99
18242                      .adi (>18*256)                  ; ADC #24           ; of the crosshairs
     **** ****     > ADI
0001 5434 1701  14        jnc  !
0002 5436 B004  18        ab   rone,ra
0003               !:
0004 5438 0220  22        ai   ra,(>18*256)
     543A 1800     
                   < elite.a99
18243 543C D800  30        movb ra,@QQ19+1                 ; STA QQ19+1
     543E 0080     
18244               
18245                                                                          ; Fall through into TT128 to draw a circle with the
18246                                                                          ; centre at the same coordinates as the crosshairs,
18247                                                                          ; (QQ19, QQ19+1), and radius K that reflects the
18248                                                                          ; current fuel levels
18249               
18250               * ******************************************************************************
18251               *
18252               * Name: TT128
18253               * Type: Subroutine
18254               * Category: Drawing circles
18255               * Summary: Draw a circle on a chart
18256               * Deep dive: Drawing circles
18257               *
18258               * ------------------------------------------------------------------------------
18259               *
18260               * Draw a circle with the centre at (QQ19, QQ19+1) and radius K.
18261               *
18262               * ------------------------------------------------------------------------------
18263               *
18264               * Arguments:
18265               *
18266               * QQ19                The x-coordinate of the centre of the circle
18267               *
18268               * QQ19+1              The y-coordinate of the centre of the circle
18269               *
18270               * K                   The radius of the circle
18271               *
18272               * ******************************************************************************
18273               
18274               TT128:
18275 5440 D020  30        movb @QQ19,ra                   ; LDA QQ19          ; Set K3 = the x-coordinate of the centre
     5442 007F     
18276 5444 D800  30        movb ra,@K3                     ; STA K3
     5446 00D2     
18277               
18278 5448 D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set K4 = the y-coordinate of the centre
     544A 0080     
18279 544C D800  30        movb ra,@K4                     ; STA K4
     544E 00E0     
18280               
18281 5450 0201  20        li   rx,>00*256                 ; LDX #0            ; Set the high bytes of K3(1 0) and K4(1 0) to 0
     5452 0000     
18282 5454 D801  30        movb rx,@K4+1                   ; STX K4+1
     5456 00E1     
18283 5458 D801  30        movb rx,@K3+1                   ; STX K3+1
     545A 00D3     
18284               
18285               * STX LSX                \ This instruction is commented out in the original
18286                                                                          ; source
18287               
18288 545C B044  18        ab   rone,rx                    ; INX               ; Set LSP = 1 to reset the ball line heap
18289 545E D801  30        movb rx,@LSP                    ; STX LSP
     5460 0077     
18290               
18291 5462 0201  20        li   rx,>02*256                 ; LDX #2            ; Set STP = 2, the step size for the circle
     5464 0200     
18292 5466 D801  30        movb rx,@STP                    ; STX STP
     5468 00A6     
18293               
18294 546A 0206  20        li   rtmp,CIRCLE2               ; JSR CIRCLE2       ; Call CIRCLE2 to draw a circle with the centre at
     546C B82C     
18295 546E 06A0  32        bl   @jsr                       ;
     5470 FF10     
18296                                                                          ; (K3(1 0), K4(1 0)) and radius K
18297               
18298               * LDA #&FF               \ These instructions are commented out in the original
18299               * STA LSX                \ source
18300               
18301 5472 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5474 FF1C     
18302               
18303               * ******************************************************************************
18304               *
18305               * Name: TT219
18306               * Type: Subroutine
18307               * Category: Market
18308               * Summary: Show the Buy Cargo screen (red key f1)
18309               *
18310               * ------------------------------------------------------------------------------
18311               *
18312               * Other entry points:
18313               *
18314               * BAY2                Jump into the main loop at FRCE, setting the key
18315               * "pressed" to red key f9 (so we show the Inventory
18316               * screen)
18317               *
18318               * ******************************************************************************
18319               
18320               TT219:
18321               * LDA #2                 \ This instruction is commented out in the original
18322                                                                          ; source. Perhaps this view originally had a QQ11 value
18323                                                                          ; of 2, but it turned out not to need its own unique ID,
18324                                                                          ; so the authors found they could just use a view value
18325                                                                          ; of 1 and save an instruction at the same time?
18326 5476 0206  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     5478 4B28     
18327 547A 06A0  32        bl   @jsr                       ;
     547C FF10     
18328                                                                          ; and set the current view type in QQ11 to 1
18329               
18330 547E 0206  20        li   rtmp,TT163                 ; JSR TT163         ; Print the column headers for the prices table
     5480 5E8E     
18331 5482 06A0  32        bl   @jsr                       ;
     5484 FF10     
18332               
18333 5486 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     5488 8000     
18334 548A D800  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     548C 007E     
18335               
18336               * JSR FLKB               \ This instruction is commented out in the original
18337                                                                          ; source. It calls a routine to flush the keyboard
18338                                                                          ; buffer (FLKB) that isn't present in the cassette
18339                                                                          ; version but is in other versions
18340               
18341 548E 0200  20        li   ra,>00*256                 ; LDA #0            ; We're going to loop through all the available market
     5490 0000     
18342 5492 D800  30        movb ra,@QQ29                   ; STA QQ29          ; items, so we set up a counter in QQ29 to denote the
     5494 0F1B     
18343                                                                          ; current item and start it at 0
18344               
18345               TT220:
18346 5496 0206  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to print the item name, market price and
     5498 5D62     
18347 549A 06A0  32        bl   @jsr                       ;
     549C FF10     
18348                                                                          ; availability of the current item, and set QQ24 to the
18349                                                                          ; item's price / 4, QQ25 to the quantity available and
18350                                                                          ; QQ19+1 to byte #1 from the market prices table for
18351                                                                          ; this item
18352               
18353 549E D020  30        movb @QQ25,ra                   ; LDA QQ25          ; If there are some of the current item available, jump
     54A0 0F19     
18354 54A2 1611  14        jne  TT224                      ; BNE TT224         ; to TT224 below to see if we want to buy any
18355               
18356 54A4 0460  28        b    @TT222                     ; JMP TT222         ; Otherwise there are none available, so jump down to
     54A6 559C     
18357                                                                          ; TT222 to skip this item
18358               
18359               TQ4:
18360 54A8 0202  20        li   ry,>b0*256                 ; LDY #176          ; Set Y to the recursive token 16 ("QUANTITY")
     54AA B000     
18361               
18362               Tc:
18363 54AC 0206  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     54AE 5E64     
18364 54B0 06A0  32        bl   @jsr                       ;
     54B2 FF10     
18365               
18366 54B4 D002  18        movb ry,ra                      ; TYA               ; Print the recursive token in Y followed by a question
18367 54B6 0206  20        li   rtmp,prq_                  ; JSR prq           ; mark
     54B8 5D52     
18368 54BA 06A0  32        bl   @jsr                       ;
     54BC FF10     
18369               
18370               TTX224:
18371 54BE 0206  20        li   rtmp,dn2_                  ; JSR dn2           ; Call dn2 to make a short, high beep and delay for 1
     54C0 A4E8     
18372 54C2 06A0  32        bl   @jsr                       ;
     54C4 FF10     
18373                                                                          ; second
18374               
18375               TT224:
18376 54C6 0206  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     54C8 4C2E     
18377 54CA 06A0  32        bl   @jsr                       ;
     54CC FF10     
18378                                                                          ; and move the text cursor to column 1 on row 21, i.e.
18379                                                                          ; the start of the top row of the three bottom rows
18380               
18381 54CE 0200  20        li   ra,>cc*256                 ; LDA #204          ; Print recursive token 44 ("QUANTITY OF ")
     54D0 CC00     
18382 54D2 0206  20        li   rtmp,TT27                  ; JSR TT27
     54D4 A6E8     
18383 54D6 06A0  32        bl   @jsr                       ;
     54D8 FF10     
18384               
18385 54DA D020  30        movb @QQ29,ra                   ; LDA QQ29          ; Print recursive token 48 + QQ29, which will be in the
     54DC 0F1B     
18386                      .clc                            ; CLC               ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     **** ****     > CLC
0001 54DE 0A13  18        sla  rzero,1
                   < elite.a99
18387                      .adi (>d0*256)                  ; ADC #208          ; prints the current item's name
     **** ****     > ADI
0001 54E0 1701  14        jnc  !
0002 54E2 B004  18        ab   rone,ra
0003               !:
0004 54E4 0220  22        ai   ra,(>D0*256)
     54E6 D000     
                   < elite.a99
18388 54E8 0206  20        li   rtmp,TT27                  ; JSR TT27
     54EA A6E8     
18389 54EC 06A0  32        bl   @jsr                       ;
     54EE FF10     
18390               
18391 54F0 0200  20        li   ra,('/')*256               ; LDA #'/'          ; Print "/"
     54F2 2F00     
18392 54F4 0206  20        li   rtmp,TT27                  ; JSR TT27
     54F6 A6E8     
18393 54F8 06A0  32        bl   @jsr                       ;
     54FA FF10     
18394               
18395 54FC 0206  20        li   rtmp,TT152                 ; JSR TT152         ; Print the unit ("t", "kg" or "g") for the current item
     54FE 5E4C     
18396 5500 06A0  32        bl   @jsr                       ;
     5502 FF10     
18397                                                                          ; (as the call to TT151 above set QQ19+1 with the
18398                                                                          ; appropriate value)
18399               
18400 5504 0200  20        li   ra,('?')*256               ; LDA #'?'          ; Print "?"
     5506 3F00     
18401 5508 0206  20        li   rtmp,TT27                  ; JSR TT27
     550A A6E8     
18402 550C 06A0  32        bl   @jsr                       ;
     550E FF10     
18403               
18404 5510 0206  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline
     5512 4EE6     
18405 5514 06A0  32        bl   @jsr                       ;
     5516 FF10     
18406               
18407 5518 0201  20        li   rx,>00*256                 ; LDX #0            ; These instructions have no effect, as they are
     551A 0000     
18408 551C D801  30        movb rx,@R                      ; STX R             ; repeated at the start of gnum, which we call next.
     551E 0091     
18409 5520 0201  20        li   rx,>0c*256                 ; LDX #12           ; Perhaps they were left behind when code was moved from
     5522 0C00     
18410 5524 D801  30        movb rx,@T1                     ; STX T1            ; here into gnum, and weren't deleted?
     5526 0006     
18411               
18412               * .TT223                 \ This label is commented out in the original source,
18413                                                                          ; and is a duplicate of a label in gnum, so this could
18414                                                                          ; also be a remnant if the code in gnum was originally
18415                                                                          ; here, but got moved into the gnum subroutine
18416               
18417 5528 0206  20        li   rtmp,gnum_                 ; JSR gnum          ; Call gnum to get a number from the keyboard, which
     552A 55CE     
18418 552C 06A0  32        bl   @jsr                       ;
     552E FF10     
18419                                                                          ; will be the quantity of this item we want to purchase,
18420                                                                          ; returning the number entered in A and R
18421               
18422 5530 18BB  14        joc  TQ4                        ; BCS TQ4           ; If gnum set the C flag, the number entered is greater
18423                                                                          ; than the quantity available, so jump up to TQ4 to
18424                                                                          ; display a "Quantity?" error, beep, clear the number
18425                                                                          ; and try again
18426               
18427 5532 D800  30        movb ra,@P                      ; STA P             ; Otherwise we have a valid purchase quantity entered,
     5534 001B     
18428                                                                          ; so store the amount we want to purchase in P
18429               
18430 5536 0206  20        li   rtmp,tnpr_                 ; JSR tnpr          ; Call tnpr to work out whether there is room in the
     5538 4DF4     
18431 553A 06A0  32        bl   @jsr                       ;
     553C FF10     
18432                                                                          ; cargo hold for this item
18433               
18434 553E 0202  20        li   ry,>ce*256                 ; LDY #206          ; Set Y to recursive token 46 (" CARGO{sentence case}")
     5540 CE00     
18435                                                                          ; to pass to the Tc routine if we call it
18436               
18437 5542 18B4  14        joc  Tc                         ; BCS Tc            ; If the C flag is set, then there is no room in the
18438                                                                          ; cargo hold, jump up to Tc to print a "Cargo?" error,
18439                                                                          ; beep, clear the number and try again
18440               
18441 5544 D020  30        movb @QQ24,ra                   ; LDA QQ24          ; There is room in the cargo hold, so now to check
     5546 0F18     
18442 5548 D800  30        movb ra,@Q                      ; STA Q             ; whether we have enough cash, so fetch the item's
     554A 0090     
18443                                                                          ; price / 4, which was returned in QQ24 by the call
18444                                                                          ; to TT151 above and store it in Q
18445               
18446 554C 0206  20        li   rtmp,GCASH                 ; JSR GCASH         ; Call GCASH to calculate:
     554E A202     
18447 5550 06A0  32        bl   @jsr                       ;
     5552 FF10     
18448                                                                          ;
18449                                                                          ; (Y X) = P * Q * 4
18450                                                                          ;
18451                                                                          ; which will be the total price of this transaction
18452                                                                          ; (as P contains the purchase quantity and Q contains
18453                                                                          ; the item's price / 4)
18454               
18455 5554 0206  20        li   rtmp,LCASH                 ; JSR LCASH         ; Subtract (Y X) cash from the cash pot in CASH
     5556 A172     
18456 5558 06A0  32        bl   @jsr                       ;
     555A FF10     
18457               
18458 555C 0202  20        li   ry,>c5*256                 ; LDY #197          ; If the C flag is clear, we didn't have enough cash,
     555E C500     
18459 5560 17A5  14        jnc  Tc                         ; BCC Tc            ; so set Y to the recursive token 37 ("CASH") and jump
18460                                                                          ; up to Tc to print a "Cash?" error, beep, clear the
18461                                                                          ; number and try again
18462               
18463 5562 D0A0  30        movb @QQ29,ry                   ; LDY QQ29          ; Fetch the current market item number from QQ29 into Y
     5564 0F1B     
18464               
18465 5566 D020  30        movb @R,ra                      ; LDA R             ; Set A to the number of items we just purchased (this
     5568 0091     
18466                                                                          ; was set by gnum above)
18467               
18468                      .pha                            ; PHA               ; Store the quantity just purchased on the stack
     **** ****     > PHA
0001 556A D680  30        movb ra,*rsp
0002 556C 060A  14        dec  rsp
                   < elite.a99
18469               
18470                      .clc                            ; CLC               ; Add the number purchased to the Y-th byte of QQ20,
     **** ****     > CLC
0001 556E 0A13  18        sla  rzero,1
                   < elite.a99
18471                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; which contains the number of items of this type in
     **** ****     > ADC
0001 5570 1701  14        jnc  !
0002 5572 B004  18        ab   rone,ra
0003               !:
0004 5574 B022  34        ab   @QQ20(RY),ra
     5576 0317     
                   < elite.a99
18472 5578 D880  38        movb ra,@QQ20(ry)               ; STA QQ20,Y        ; our hold (so this transfers the bought items into our
     557A 0317     
18473                                                                          ; cargo hold)
18474               
18475 557C D022  34        movb @AVL(ry),ra                ; LDA AVL,Y         ; Subtract the number of items from the Y-th byte of
     557E 0335     
18476                      .sec                            ; SEC               ; AVL, which contains the number of items of this type
     **** ****     > SEC
0001 5580 0A15  18        sla  rmone,1
                   < elite.a99
18477                      .sbc @R,ra                      ; SBC R             ; that are available on the market
     **** ****     > SBC
0001 5582 1801  14        joc  !
0002 5584 7004  18        sb   rone,ra
0003               !:
0004 5586 7020  30        sb   @R,ra
     5588 0091     
                   < elite.a99
18478 558A D880  38        movb ra,@AVL(ry)                ; STA AVL,Y
     558C 0335     
18479               
18480                      .pla                            ; PLA               ; Restore the quantity just purchased
     **** ****     > PLA
0001 558E 058A  14        inc  rsp
0002 5590 D01A  26        movb *rsp,ra
                   < elite.a99
18481               
18482 5592 1304  14        jeq  TT222                      ; BEQ TT222         ; If we didn't buy anything, jump to TT222 to skip the
18483                                                                          ; following instruction
18484               
18485 5594 0206  20        li   rtmp,dn_                   ; JSR dn            ; Call dn to print the amount of cash left in the cash
     5596 A4D4     
18486 5598 06A0  32        bl   @jsr                       ;
     559A FF10     
18487                                                                          ; pot, then make a short, high beep to confirm the
18488                                                                          ; purchase, and delay for 1 second
18489               
18490               TT222:
18491 559C D020  30        movb @QQ29,ra                   ; LDA QQ29          ; Move the text cursor to row QQ29 + 5 (where QQ29 is
     559E 0F1B     
18492                      .clc                            ; CLC               ; the item number, starting from 0)
     **** ****     > CLC
0001 55A0 0A13  18        sla  rzero,1
                   < elite.a99
18493                      .adi (>05*256)                  ; ADC #5
     **** ****     > ADI
0001 55A2 1701  14        jnc  !
0002 55A4 B004  18        ab   rone,ra
0003               !:
0004 55A6 0220  22        ai   ra,(>05*256)
     55A8 0500     
                   < elite.a99
18494 55AA D800  30        movb ra,@YC                     ; STA YC
     55AC 002D     
18495               
18496 55AE 0200  20        li   ra,>00*256                 ; LDA #0            ; Move the text cursor to column 0
     55B0 0000     
18497 55B2 D800  30        movb ra,@XC                     ; STA XC
     55B4 002C     
18498               
18499 55B6 B004  18        ab   rone,ra                    ; INC QQ29          ; Increment QQ29 to point to the next item
18500               
18501 55B8 D020  30        movb @QQ29,ra                   ; LDA QQ29          ; If QQ29 >= 17 then jump to BAY2 as we have done the
     55BA 0F1B     
18502 55BC 0280  22        ci   ra,>11*256                 ; CMP #17           ; last item
     55BE 1100     
18503 55C0 1802  14        joc  BAY2                       ; BCS BAY2
18504               
18505 55C2 0460  28        b    @TT220                     ; JMP TT220         ; Otherwise loop back to TT220 to print the next market
     55C4 5496     
18506                                                                          ; item
18507               
18508               BAY2:
18509 55C6 0200  20        li   ra,(f9_)*256               ; LDA #f9           ; Jump into the main loop at FRCE, setting the key
     55C8 7700     
18510 55CA 0460  28        b    @FRCE                      ; JMP FRCE          ; "pressed" to red key f9 (so we show the Inventory
     55CC C2B8     
18511                                                                          ; screen)
18512               
18513               * ******************************************************************************
18514               *
18515               * Name: gnum
18516               * Type: Subroutine
18517               * Category: Market
18518               * Summary: Get a number from the keyboard
18519               *
18520               * ------------------------------------------------------------------------------
18521               *
18522               * Get a number from the keyboard, up to the maximum number in QQ25, for the
18523               * buying and selling of cargo and equipment.
18524               *
18525               * Pressing a key with an ASCII code less than ASCII "0" will return a 0 in A (so
18526               * that includes pressing Space or Return), while pressing a key with an ASCII
18527               * code greater than ASCII "9" will jump to the Inventory screen (so that
18528               * includes all letters and most punctuation).
18529               *
18530               * ------------------------------------------------------------------------------
18531               *
18532               * Arguments:
18533               *
18534               * QQ25                The maximum number allowed
18535               *
18536               * ------------------------------------------------------------------------------
18537               *
18538               * Returns:
18539               *
18540               * A                   The number entered
18541               *
18542               * R                   Also contains the number entered
18543               *
18544               * C flag              Set if the number is too large (> QQ25), clear otherwise
18545               *
18546               * ******************************************************************************
18547               
18548               gnum_:
18549 55CE 0201  20        li   rx,>00*256                 ; LDX #0            ; We will build the number entered in R, so initialise
     55D0 0000     
18550 55D2 D801  30        movb rx,@R                      ; STX R             ; it with 0
     55D4 0091     
18551               
18552 55D6 0201  20        li   rx,>0c*256                 ; LDX #12           ; We will check for up to 12 key presses, so set a
     55D8 0C00     
18553 55DA D801  30        movb rx,@T1                     ; STX T1            ; counter in T1
     55DC 0006     
18554               
18555               TT223:
18556 55DE 0206  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     55E0 CE00     
18557 55E2 06A0  32        bl   @jsr                       ;
     55E4 FF10     
18558                                                                          ; the key's ASCII code in A (and X)
18559               
18560 55E6 D800  30        movb ra,@Q                      ; STA Q             ; Store the key pressed in Q
     55E8 0090     
18561               
18562                      .sec                            ; SEC               ; Subtract ASCII "0" from the key pressed, to leave the
     **** ****     > SEC
0001 55EA 0A15  18        sla  rmone,1
                   < elite.a99
18563                      .sbi (('0')*256)                ; SBC #'0'          ; numeric value of the key in A (if it was a number key)
     **** ****     > SBI
0001 55EC 1801  14        joc  !
0002 55EE 7004  18        sb   rone,ra
0003               !:
0004 55F0 0220  22        ai   ra,-(('0')*256)
     55F2 D000     
                   < elite.a99
18564               
18565 55F4 172B  14        jnc  OUT                        ; BCC OUT           ; If A < 0, jump to OUT to load the current number and
18566                                                                          ; return from the subroutine, as the key pressed was
18567                                                                          ; RETURN (or some other ncharacter with a value less
18568                                                                          ; than ASCII "0")
18569               
18570 55F6 0280  22        ci   ra,>0a*256                 ; CMP #10           ; If A >= 10, jump to BAY2 to display the Inventory
     55F8 0A00     
18571 55FA 18E5  14        joc  BAY2                       ; BCS BAY2          ; screen, as the key pressed was a letter or other
18572                                                                          ; non-digit and is greater than ASCII "9"
18573               
18574 55FC D800  30        movb ra,@S                      ; STA S             ; Store the numeric value of the key pressed in S
     55FE 0092     
18575               
18576 5600 D020  30        movb @R,ra                      ; LDA R             ; Fetch the result so far into A
     5602 0091     
18577               
18578 5604 0280  22        ci   ra,>1a*256                 ; CMP #26           ; If A >= 26, where A is the number entered so far, then
     5606 1A00     
18579 5608 1821  14        joc  OUT                        ; BCS OUT           ; adding a further digit will make it bigger than 256,
18580                                                                          ; so jump to OUT to return from the subroutine with the
18581                                                                          ; result in R (i.e. ignore the last key press)
18582               
18583                      .asla                           ; ASL A             ; Set A = (A * 2) + (A * 8) = A * 10
     **** ****     > ASLA
0001 560A 0240  22        andi ra,>ff00
     560C FF00     
0002 560E 0A10  18        sla  ra,1
                   < elite.a99
18584 5610 D800  30        movb ra,@T                      ; STA T
     5612 00D1     
18585                      .asla                           ; ASL A
     **** ****     > ASLA
0001 5614 0240  22        andi ra,>ff00
     5616 FF00     
0002 5618 0A10  18        sla  ra,1
                   < elite.a99
18586                      .asla                           ; ASL A
     **** ****     > ASLA
0001 561A 0240  22        andi ra,>ff00
     561C FF00     
0002 561E 0A10  18        sla  ra,1
                   < elite.a99
18587                      .adc @T,ra                      ; ADC T
     **** ****     > ADC
0001 5620 1701  14        jnc  !
0002 5622 B004  18        ab   rone,ra
0003               !:
0004 5624 B020  30        ab   @T,ra
     5626 00D1     
                   < elite.a99
18588               
18589                      .adc @S,ra                      ; ADC S             ; Add the pressed digit to A and store in R, so R now
     **** ****     > ADC
0001 5628 1701  14        jnc  !
0002 562A B004  18        ab   rone,ra
0003               !:
0004 562C B020  30        ab   @S,ra
     562E 0092     
                   < elite.a99
18590 5630 D800  30        movb ra,@R                      ; STA R             ; contains its previous value with the new key press
     5632 0091     
18591                                                                          ; tacked onto the end
18592               
18593 5634 9020  30        cb   @QQ25,ra                   ; CMP QQ25          ; If the result in R = the maximum allowed in QQ25, jump
     5636 0F19     
18594 5638 1301  14        jeq  TT226                      ; BEQ TT226         ; to TT226 to print the key press and keep looping (the
18595                                                                          ; BEQ is needed because the BCS below would jump to OUT
18596                                                                          ; if R >= QQ25, which we don't want)
18597               
18598 563A 1808  14        joc  OUT                        ; BCS OUT           ; If the result in R > QQ25, jump to OUT to return from
18599                                                                          ; the subroutine with the result in R
18600               
18601               TT226:
18602 563C D020  30        movb @Q,ra                      ; LDA Q             ; Print the character in Q (i.e. the key that was
     563E 0090     
18603 5640 0206  20        li   rtmp,TT26                  ; JSR TT26          ; pressed, as we stored the ASCII value in Q earlier)
     5642 3172     
18604 5644 06A0  32        bl   @jsr                       ;
     5646 FF10     
18605               
18606 5648 7004  18        sb   rone,ra                    ; DEC T1            ; Decrement the loop counter
18607               
18608 564A 16C9  14        jne  TT223                      ; BNE TT223         ; Loop back to TT223 until we have checked for 12 digits
18609               
18610               OUT:
18611 564C D020  30        movb @R,ra                      ; LDA R             ; Set A to the result we have been building in R
     564E 0091     
18612               
18613 5650 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5652 FF1C     
18614               
18615               * ******************************************************************************
18616               *
18617               * Name: TT208
18618               * Type: Subroutine
18619               * Category: Market
18620               * Summary: Show the Sell Cargo screen (red key f2)
18621               *
18622               * ******************************************************************************
18623               
18624               TT208:
18625 5654 0200  20        li   ra,>04*256                 ; LDA #4            ; Clear the top part of the screen, draw a white border,
     5656 0400     
18626 5658 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 4 (Sell
     565A 4B2A     
18627 565C 06A0  32        bl   @jsr                       ;
     565E FF10     
18628                                                                          ; Cargo screen)
18629               
18630 5660 0200  20        li   ra,>04*256                 ; LDA #4            ; Move the text cursor to row 4, column 4
     5662 0400     
18631 5664 D800  30        movb ra,@YC                     ; STA YC
     5666 002D     
18632 5668 D800  30        movb ra,@XC                     ; STA XC
     566A 002C     
18633               
18634               * JSR FLKB               \ This instruction is commented out in the original
18635                                                                          ; source. It calls a routine to flush the keyboard
18636                                                                          ; buffer (FLKB) that isn't present in the cassette
18637                                                                          ; version but is in other versions
18638               
18639 566C 0200  20        li   ra,>cd*256                 ; LDA #205          ; Print recursive token 45 ("SELL")
     566E CD00     
18640 5670 0206  20        li   rtmp,TT27                  ; JSR TT27
     5672 A6E8     
18641 5674 06A0  32        bl   @jsr                       ;
     5676 FF10     
18642               
18643 5678 0200  20        li   ra,>ce*256                 ; LDA #206          ; Print recursive token 46 (" CARGO{sentence case}")
     567A CE00     
18644 567C 0206  20        li   rtmp,TT68                  ; JSR TT68          ; followed by a colon
     567E A6DC     
18645 5680 06A0  32        bl   @jsr                       ;
     5682 FF10     
18646               
18647                                                                          ; Fall through into TT210 to show the Inventory screen
18648                                                                          ; with the option to sell
18649               
18650               * ******************************************************************************
18651               *
18652               * Name: TT210
18653               * Type: Subroutine
18654               * Category: Market
18655               * Summary: Show a list of current cargo in our hold, optionally to sell
18656               *
18657               * ------------------------------------------------------------------------------
18658               *
18659               * Show a list of current cargo in our hold, either with the ability to sell (the
18660               * Sell Cargo screen) or without (the Inventory screen), depending on the current
18661               * view.
18662               *
18663               * ------------------------------------------------------------------------------
18664               *
18665               * Arguments:
18666               *
18667               * QQ11                The current view:
18668               *
18669               * * 4 = Sell Cargo
18670               *
18671               * * 8 = Inventory
18672               *
18673               * ******************************************************************************
18674               
18675               TT210:
18676 5684 0202  20        li   ry,>00*256                 ; LDY #0            ; We're going to loop through all the available market
     5686 0000     
18677                                                                          ; items and check whether we have any in the hold (and,
18678                                                                          ; if we are in the Sell Cargo screen, whether we want
18679                                                                          ; to sell any items), so we set up a counter in Y to
18680                                                                          ; denote the current item and start it at 0
18681               
18682               TT211:
18683 5688 D802  30        movb ry,@QQ29                   ; STY QQ29          ; Store the current item number in QQ29
     568A 0F1B     
18684               
18685 568C D062  34        movb @QQ20(ry),rx               ; LDX QQ20,Y        ; Fetch into X the amount of the current item that we
     568E 0317     
18686 5690 135E  14        jeq  TT212                      ; BEQ TT212         ; have in our cargo hold, which is stored in QQ20+Y,
18687                                                                          ; and if there are no items of this type in the hold,
18688                                                                          ; jump down to TT212 to skip to the next item
18689               
18690 5692 D002  18        movb ry,ra                      ; TYA               ; Set Y = Y * 4, so this will act as an index into the
18691                      .asla                           ; ASL A             ; market prices table at QQ23 for this item (as there
     **** ****     > ASLA
0001 5694 0240  22        andi ra,>ff00
     5696 FF00     
0002 5698 0A10  18        sla  ra,1
                   < elite.a99
18692                      .asla                           ; ASL A             ; are four bytes per item in the table)
     **** ****     > ASLA
0001 569A 0240  22        andi ra,>ff00
     569C FF00     
0002 569E 0A10  18        sla  ra,1
                   < elite.a99
18693 56A0 D080  18        movb ra,ry                      ; TAY
18694               
18695 56A2 D022  34        movb @QQ23+1(ry),ra             ; LDA QQ23+1,Y      ; Fetch byte #1 from the market prices table for the
     56A4 CF2F     
18696 56A6 D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; current item and store it in QQ19+1, for use by the
     56A8 0080     
18697                                                                          ; call to TT152 below
18698               
18699 56AA D001  18        movb rx,ra                      ; TXA               ; Store the amount of item in the hold (in X) on the
18700                      .pha                            ; PHA               ; stack
     **** ****     > PHA
0001 56AC D680  30        movb ra,*rsp
0002 56AE 060A  14        dec  rsp
                   < elite.a99
18701               
18702 56B0 0206  20        li   rtmp,TT69                  ; JSR TT69          ; Call TT69 to set Sentence Case and print a newline
     56B2 4EDE     
18703 56B4 06A0  32        bl   @jsr                       ;
     56B6 FF10     
18704               
18705                      .clc                            ; CLC               ; Print recursive token 48 + QQ29, which will be in the
     **** ****     > CLC
0001 56B8 0A13  18        sla  rzero,1
                   < elite.a99
18706 56BA D020  30        movb @QQ29,ra                   ; LDA QQ29          ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     56BC 0F1B     
18707                      .adi (>d0*256)                  ; ADC #208          ; prints the current item's name
     **** ****     > ADI
0001 56BE 1701  14        jnc  !
0002 56C0 B004  18        ab   rone,ra
0003               !:
0004 56C2 0220  22        ai   ra,(>D0*256)
     56C4 D000     
                   < elite.a99
18708 56C6 0206  20        li   rtmp,TT27                  ; JSR TT27
     56C8 A6E8     
18709 56CA 06A0  32        bl   @jsr                       ;
     56CC FF10     
18710               
18711 56CE 0200  20        li   ra,>0e*256                 ; LDA #14           ; Move the text cursor to column 14, for the item's
     56D0 0E00     
18712 56D2 D800  30        movb ra,@XC                     ; STA XC            ; quantity
     56D4 002C     
18713               
18714                      .pla                            ; PLA               ; Restore the amount of item in the hold into X
     **** ****     > PLA
0001 56D6 058A  14        inc  rsp
0002 56D8 D01A  26        movb *rsp,ra
                   < elite.a99
18715 56DA D040  18        movb ra,rx                      ; TAX
18716               
18717                      .clc                            ; CLC               ; Print the 8-bit number in X to 3 digits, without a
     **** ****     > CLC
0001 56DC 0A13  18        sla  rzero,1
                   < elite.a99
18718 56DE 0206  20        li   rtmp,pr2_                  ; JSR pr2           ; decimal point
     56E0 2FAC     
18719 56E2 06A0  32        bl   @jsr                       ;
     56E4 FF10     
18720               
18721 56E6 0206  20        li   rtmp,TT152                 ; JSR TT152         ; Print the unit ("t", "kg" or "g") for the market item
     56E8 5E4C     
18722 56EA 06A0  32        bl   @jsr                       ;
     56EC FF10     
18723                                                                          ; whose byte #1 from the market prices table is in
18724                                                                          ; QQ19+1 (which we set up above)
18725               
18726 56EE D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view type in QQ11 is not 4 (Sell Cargo
     56F0 0096     
18727 56F2 0280  22        ci   ra,>04*256                 ; CMP #4            ; screen), jump to TT212 to skip the option to sell
     56F4 0400     
18728 56F6 162B  14        jne  TT212                      ; BNE TT212         ; items
18729               
18730 56F8 0200  20        li   ra,>cd*256                 ; LDA #205          ; Set A to recursive token 45 ("SELL")
     56FA CD00     
18731               
18732 56FC 0206  20        li   rtmp,TT214                 ; JSR TT214         ; Call TT214 to print "Sell(Y/N)?" and return the
     56FE 57C2     
18733 5700 06A0  32        bl   @jsr                       ;
     5702 FF10     
18734                                                                          ; response in the C flag
18735               
18736 5704 1724  14        jnc  TT212                      ; BCC TT212         ; If the response was "no", jump to TT212 to move on to
18737                                                                          ; the next item
18738               
18739 5706 D020  30        movb @QQ29,ra                   ; LDA QQ29          ; We are selling this item, so fetch the item number
     5708 0F1B     
18740                                                                          ; from QQ29
18741               
18742 570A 0201  20        li   rx,>ff*256                 ; LDX #255          ; Set QQ17 = 255 to disable printing
     570C FF00     
18743 570E D801  30        movb rx,@QQ17                   ; STX QQ17
     5710 007E     
18744               
18745 5712 0206  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to set QQ24 to the item's price / 4 (the
     5714 5D62     
18746 5716 06A0  32        bl   @jsr                       ;
     5718 FF10     
18747                                                                          ; routine doesn't print the item details, as we just
18748                                                                          ; disabled printing)
18749               
18750 571A D0A0  30        movb @QQ29,ry                   ; LDY QQ29          ; Set P to the amount of this item we have in our cargo
     571C 0F1B     
18751 571E D022  34        movb @QQ20(ry),ra               ; LDA QQ20,Y        ; hold (which is the amount to sell)
     5720 0317     
18752 5722 D800  30        movb ra,@P                      ; STA P
     5724 001B     
18753               
18754 5726 D020  30        movb @QQ24,ra                   ; LDA QQ24          ; Set Q to the item's price / 4
     5728 0F18     
18755 572A D800  30        movb ra,@Q                      ; STA Q
     572C 0090     
18756               
18757 572E 0206  20        li   rtmp,GCASH                 ; JSR GCASH         ; Call GCASH to calculate
     5730 A202     
18758 5732 06A0  32        bl   @jsr                       ;
     5734 FF10     
18759                                                                          ;
18760                                                                          ; (Y X) = P * Q * 4
18761                                                                          ;
18762                                                                          ; which will be the total price we make from this sale
18763                                                                          ; (as P contains the quantity we're selling and Q
18764                                                                          ; contains the item's price / 4)
18765               
18766 5736 0206  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH
     5738 A1BE     
18767 573A 06A0  32        bl   @jsr                       ;
     573C FF10     
18768               
18769 573E 0200  20        li   ra,>00*256                 ; LDA #0            ; We've made the sale, so set the amount
     5740 0000     
18770 5742 D0A0  30        movb @QQ29,ry                   ; LDY QQ29
     5744 0F1B     
18771 5746 D880  38        movb ra,@QQ20(ry)               ; STA QQ20,Y
     5748 0317     
18772               
18773 574A D800  30        movb ra,@QQ17                   ; STA QQ17          ; Set QQ17 = 0, which enables printing again
     574C 007E     
18774               
18775               TT212:
18776 574E D0A0  30        movb @QQ29,ry                   ; LDY QQ29          ; Fetch the item number from QQ29 into Y, and increment
     5750 0F1B     
18777 5752 B084  18        ab   rone,ry                    ; INY               ; Y to point to the next item
18778               
18779 5754 0282  22        ci   ry,>11*256                 ; CPY #17           ; If Y >= 17 then skip the next instruction as we have
     5756 1100     
18780 5758 1802  14        joc  B54                        ; BCS B54           ; done the last item
18781               
18782 575A 0460  28        b    @TT211                     ; JMP TT211         ; Otherwise loop back to TT211 to print the next item
     575C 5688     
18783                                                                          ; in the hold
18784               
18785               B54:
18786 575E D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view type in QQ11 is not 4 (Sell Cargo
     5760 0096     
18787 5762 0280  22        ci   ra,>04*256                 ; CMP #4            ; screen), skip the next two instructions and just
     5764 0400     
18788 5766 1606  14        jne  B55                        ; BNE B55           ; return from the subroutine
18789               
18790 5768 0206  20        li   rtmp,dn2_                  ; JSR dn2           ; This is the Sell Cargo screen, so call dn2 to make a
     576A A4E8     
18791 576C 06A0  32        bl   @jsr                       ;
     576E FF10     
18792                                                                          ; short, high beep and delay for 1 second
18793               
18794 5770 0460  28        b    @BAY2                      ; JMP BAY2          ; And then jump to BAY2 to display the Inventory
     5772 55C6     
18795                                                                          ; screen, as we have finished selling cargo
18796               
18797               B55:
18798 5774 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5776 FF1C     
18799               
18800               * ******************************************************************************
18801               *
18802               * Name: TT213
18803               * Type: Subroutine
18804               * Category: Market
18805               * Summary: Show the Inventory screen (red key f9)
18806               *
18807               * ******************************************************************************
18808               
18809               TT213:
18810 5778 0200  20        li   ra,>08*256                 ; LDA #8            ; Clear the top part of the screen, draw a white border,
     577A 0800     
18811 577C 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 8 (Inventory
     577E 4B2A     
18812 5780 06A0  32        bl   @jsr                       ;
     5782 FF10     
18813                                                                          ; screen)
18814               
18815 5784 0200  20        li   ra,>0b*256                 ; LDA #11           ; Move the text cursor to column 11 to print the screen
     5786 0B00     
18816 5788 D800  30        movb ra,@XC                     ; STA XC            ; title
     578A 002C     
18817               
18818 578C 0200  20        li   ra,>a4*256                 ; LDA #164          ; Print recursive token 4 ("INVENTORY{crlf}") followed
     578E A400     
18819 5790 0206  20        li   rtmp,TT60                  ; JSR TT60          ; by a paragraph break and Sentence Case
     5792 4ED4     
18820 5794 06A0  32        bl   @jsr                       ;
     5796 FF10     
18821               
18822 5798 0206  20        li   rtmp,NLIN4                 ; JSR NLIN4         ; Draw a horizontal line at pixel row 19 to box in the
     579A 25B8     
18823 579C 06A0  32        bl   @jsr                       ;
     579E FF10     
18824                                                                          ; title. The authors could have used a call to NLIN3
18825                                                                          ; instead and saved the above call to TT60, but you
18826                                                                          ; just can't optimise everything
18827               
18828 57A0 0206  20        li   rtmp,fwl_                  ; JSR fwl           ; Call fwl to print the fuel and cash levels on two
     57A2 A67E     
18829 57A4 06A0  32        bl   @jsr                       ;
     57A6 FF10     
18830                                                                          ; separate lines
18831               
18832 57A8 D020  30        movb @CRGO,ra                   ; LDA CRGO          ; If our ship's cargo capacity is < 26 (i.e. we do not
     57AA 0316     
18833 57AC 0280  22        ci   ra,>1a*256                 ; CMP #26           ; have a cargo bay extension), skip the following two
     57AE 1A00     
18834 57B0 1706  14        jnc  B56                        ; BCC B56           ; instructions
18835               
18836 57B2 0200  20        li   ra,>6b*256                 ; LDA #107          ; We do have a cargo bay extension, so print recursive
     57B4 6B00     
18837 57B6 0206  20        li   rtmp,TT27                  ; JSR TT27          ; token 107 ("LARGE CARGO{sentence case} BAY")
     57B8 A6E8     
18838 57BA 06A0  32        bl   @jsr                       ;
     57BC FF10     
18839               
18840               B56:
18841 57BE 0460  28        b    @TT210                     ; JMP TT210         ; Jump to TT210 to print the contents of our cargo bay
     57C0 5684     
18842                                                                          ; and return from the subroutine using a tail call
18843               
18844               * ******************************************************************************
18845               *
18846               * Name: TT214
18847               * Type: Subroutine
18848               * Category: Keyboard
18849               * Summary: Ask a question with a "Y/N?" prompt and return the response
18850               *
18851               * ------------------------------------------------------------------------------
18852               *
18853               * Arguments:
18854               *
18855               * A                   The text token to print before the "Y/N?" prompt
18856               *
18857               * ------------------------------------------------------------------------------
18858               *
18859               * Returns:
18860               *
18861               * C flag              Set if the response was "yes", clear otherwise
18862               *
18863               * ******************************************************************************
18864               
18865               TT214:
18866                      .pha                            ; PHA               ; Print a space, using the stack to preserve the value
     **** ****     > PHA
0001 57C2 D680  30        movb ra,*rsp
0002 57C4 060A  14        dec  rsp
                   < elite.a99
18867 57C6 0206  20        li   rtmp,TT162                 ; JSR TT162         ; of A
     57C8 5E64     
18868 57CA 06A0  32        bl   @jsr                       ;
     57CC FF10     
18869                      .pla                            ; PLA
     **** ****     > PLA
0001 57CE 058A  14        inc  rsp
0002 57D0 D01A  26        movb *rsp,ra
                   < elite.a99
18870               
18871               TT221:
18872 57D2 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     57D4 A6E8     
18873 57D6 06A0  32        bl   @jsr                       ;
     57D8 FF10     
18874               
18875 57DA 0200  20        li   ra,>e1*256                 ; LDA #225          ; Print recursive token 65 ("(Y/N)?")
     57DC E100     
18876 57DE 0206  20        li   rtmp,TT27                  ; JSR TT27
     57E0 A6E8     
18877 57E2 06A0  32        bl   @jsr                       ;
     57E4 FF10     
18878               
18879 57E6 0206  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     57E8 CE00     
18880 57EA 06A0  32        bl   @jsr                       ;
     57EC FF10     
18881                                                                          ; the key's ASCII code in A and X
18882               
18883 57EE 0260  22        ori  ra,>20*256                 ; ORA #%00100000    ; Set bit 5 in the value of the key pressed, which
     57F0 2000     
18884                                                                          ; converts it to lower case
18885               
18886 57F2 0280  22        ci   ra,('y')*256               ; CMP #'y'          ; If "y" was pressed, jump to TT218
     57F4 7900     
18887 57F6 1304  14        jeq  TT218                      ; BEQ TT218
18888               
18889 57F8 0200  20        li   ra,('n')*256               ; LDA #'n'          ; Otherwise jump to TT26 to print "n" and return from
     57FA 6E00     
18890 57FC 0460  28        b    @TT26                      ; JMP TT26          ; the subroutine using a tail call (so all other
     57FE 3172     
18891                                                                          ; responses apart from "y" indicate a no)
18892               
18893               TT218:
18894 5800 0206  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character in A, i.e. print "y"
     5802 3172     
18895 5804 06A0  32        bl   @jsr                       ;
     5806 FF10     
18896               
18897                      .sec                            ; SEC               ; Set the C flag to indicate a "yes" response
     **** ****     > SEC
0001 5808 0A15  18        sla  rmone,1
                   < elite.a99
18898               
18899 580A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     580C FF1C     
18900               
18901               * ******************************************************************************
18902               *
18903               * Name: TT16
18904               * Type: Subroutine
18905               * Category: Charts
18906               * Summary: Move the crosshairs on a chart
18907               *
18908               * ------------------------------------------------------------------------------
18909               *
18910               * Move the chart crosshairs by the amount in X and Y.
18911               *
18912               * ------------------------------------------------------------------------------
18913               *
18914               * Arguments:
18915               *
18916               * X                   The amount to move the crosshairs in the x-axis
18917               *
18918               * Y                   The amount to move the crosshairs in the y-axis
18919               *
18920               * ******************************************************************************
18921               
18922               TT16:
18923 580E D001  18        movb rx,ra                      ; TXA               ; Push the change in X onto the stack (let's call this
18924                      .pha                            ; PHA               ; the x-delta)
     **** ****     > PHA
0001 5810 D680  30        movb ra,*rsp
0002 5812 060A  14        dec  rsp
                   < elite.a99
18925               
18926 5814 7084  18        sb   rone,ry                    ; DEY               ; Negate the change in Y and push it onto the stack
18927 5816 D002  18        movb ry,ra                      ; TYA               ; (let's call this the y-delta)
18928                      .eoi (>ff*256)                  ; EOR #&FF
     **** ****     > EOI
0001 5818 0206  20        li   rtmp,(>FF*256)
     581A FF00     
0002 581C 2806  18        xor  rtmp,ra
                   < elite.a99
18929                      .pha                            ; PHA
     **** ****     > PHA
0001 581E D680  30        movb ra,*rsp
0002 5820 060A  14        dec  rsp
                   < elite.a99
18930               
18931 5822 0206  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     5824 4DE2     
18932 5826 06A0  32        bl   @jsr                       ;
     5828 FF10     
18933                                                                          ; screen gets drawn and we can move the crosshairs with
18934                                                                          ; no screen flicker
18935               
18936 582A 0206  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     582C 5872     
18937 582E 06A0  32        bl   @jsr                       ;
     5830 FF10     
18938                                                                          ; which will erase the crosshairs currently there
18939               
18940                      .pla                            ; PLA               ; Store the y-delta in QQ19+3 and fetch the current
     **** ****     > PLA
0001 5832 058A  14        inc  rsp
0002 5834 D01A  26        movb *rsp,ra
                   < elite.a99
18941 5836 D800  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; y-coordinate of the crosshairs from QQ10 into A, ready
     5838 0082     
18942 583A D020  30        movb @QQ10,ra                   ; LDA QQ10          ; for the call to TT123
     583C 0F32     
18943               
18944 583E 0206  20        li   rtmp,TT123                 ; JSR TT123         ; Call TT123 to move the selected system's galactic
     5840 5898     
18945 5842 06A0  32        bl   @jsr                       ;
     5844 FF10     
18946                                                                          ; y-coordinate by the y-delta, putting the new value in
18947                                                                          ; QQ19+4
18948               
18949 5846 D020  30        movb @QQ19+4,ra                 ; LDA QQ19+4        ; Store the updated y-coordinate in QQ10 (the current
     5848 0083     
18950 584A D800  30        movb ra,@QQ10                   ; STA QQ10          ; y-coordinate of the crosshairs)
     584C 0F32     
18951               
18952 584E D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; This instruction has no effect, as QQ19+1 is
     5850 0080     
18953                                                                          ; overwritten below, both in TT103 and TT105
18954               
18955                      .pla                            ; PLA               ; Store the x-delta in QQ19+3 and fetch the current
     **** ****     > PLA
0001 5852 058A  14        inc  rsp
0002 5854 D01A  26        movb *rsp,ra
                   < elite.a99
18956 5856 D800  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; x-coordinate of the crosshairs from QQ10 into A, ready
     5858 0082     
18957 585A D020  30        movb @QQ9,ra                    ; LDA QQ9           ; for the call to TT123
     585C 0F31     
18958               
18959 585E 0206  20        li   rtmp,TT123                 ; JSR TT123         ; Call TT123 to move the selected system's galactic
     5860 5898     
18960 5862 06A0  32        bl   @jsr                       ;
     5864 FF10     
18961                                                                          ; x-coordinate by the x-delta, putting the new value in
18962                                                                          ; QQ19+4
18963               
18964 5866 D020  30        movb @QQ19+4,ra                 ; LDA QQ19+4        ; Store the updated x-coordinate in QQ9 (the current
     5868 0083     
18965 586A D800  30        movb ra,@QQ9                    ; STA QQ9           ; x-coordinate of the crosshairs)
     586C 0F31     
18966               
18967 586E D800  30        movb ra,@QQ19                   ; STA QQ19          ; This instruction has no effect, as QQ19 is overwritten
     5870 007F     
18968                                                                          ; below, both in TT103 and TT105
18969               
18970                                                                          ; Now we've updated the coordinates of the crosshairs,
18971                                                                          ; fall through into TT103 to redraw them at their new
18972                                                                          ; location
18973               
18974               * ******************************************************************************
18975               *
18976               * Name: TT103
18977               * Type: Subroutine
18978               * Category: Charts
18979               * Summary: Draw a small set of crosshairs on a chart
18980               *
18981               * ------------------------------------------------------------------------------
18982               *
18983               * Draw a small set of crosshairs on a galactic chart at the coordinates in
18984               * (QQ9, QQ10).
18985               *
18986               * ******************************************************************************
18987               
18988               TT103:
18989 5872 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; Fetch the current view type into A
     5874 0096     
18990               
18991 5876 1320  14        jeq  TT180                      ; BEQ TT180         ; If this is a space view, return from the subroutine
18992                                                                          ; (as TT180 contains an RTS), as there are no moveable
18993                                                                          ; crosshairs in space
18994               
18995 5878 1121  14        jlt  TT105                      ; BMI TT105         ; If this is the Short-range Chart screen, jump to TT105
18996               
18997 587A D020  30        movb @QQ9,ra                    ; LDA QQ9           ; Store the crosshairs x-coordinate in QQ19
     587C 0F31     
18998 587E D800  30        movb ra,@QQ19                   ; STA QQ19
     5880 007F     
18999               
19000 5882 D020  30        movb @QQ10,ra                   ; LDA QQ10          ; Halve the crosshairs y-coordinate and store it in QQ19
     5884 0F32     
19001 5886 0910  18        srl  ra,1                       ; LSR A             ; (we halve it because the Long-range Chart is half as
19002 5888 D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; high as it is wide)
     588A 0080     
19003               
19004 588C 0200  20        li   ra,>04*256                 ; LDA #4            ; Set QQ19+2 to 4 denote crosshairs of size 4
     588E 0400     
19005 5890 D800  30        movb ra,@QQ19+2                 ; STA QQ19+2
     5892 0081     
19006               
19007 5894 0460  28        b    @TT15                      ; JMP TT15          ; Jump to TT15 to draw crosshairs of size 4 at the
     5896 5316     
19008                                                                          ; crosshairs coordinates, returning from the subroutine
19009                                                                          ; using a tail call
19010               
19011               * ******************************************************************************
19012               *
19013               * Name: TT123
19014               * Type: Subroutine
19015               * Category: Charts
19016               * Summary: Move galactic coordinates by a signed delta
19017               *
19018               * ------------------------------------------------------------------------------
19019               *
19020               * Move an 8-bit galactic coordinate by a certain distance in either direction
19021               * (i.e. a signed 8-bit delta), but only if it doesn't cause the coordinate to
19022               * overflow. The coordinate is in a single axis, so it's either an x-coordinate
19023               * or a y-coordinate.
19024               *
19025               * ------------------------------------------------------------------------------
19026               *
19027               * Arguments:
19028               *
19029               * A                   The galactic coordinate to update
19030               *
19031               * QQ19+3              The delta (can be positive or negative)
19032               *
19033               * ------------------------------------------------------------------------------
19034               *
19035               * Returns:
19036               *
19037               * QQ19+4              The updated coordinate after moving by the delta (this
19038               * will be the same as A if moving by the delta overflows)
19039               *
19040               * ------------------------------------------------------------------------------
19041               *
19042               * Other entry points:
19043               *
19044               * TT180               Contains an RTS
19045               *
19046               * ******************************************************************************
19047               
19048               TT123:
19049 5898 D800  30        movb ra,@QQ19+4                 ; STA QQ19+4        ; Store the original coordinate in temporary storage at
     589A 0083     
19050                                                                          ; QQ19+4
19051               
19052                      .clc                            ; CLC               ; Set A = A + QQ19+3, so A now contains the original
     **** ****     > CLC
0001 589C 0A13  18        sla  rzero,1
                   < elite.a99
19053                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ; coordinate, moved by the delta
     **** ****     > ADC
0001 589E 1701  14        jnc  !
0002 58A0 B004  18        ab   rone,ra
0003               !:
0004 58A2 B020  30        ab   @QQ19+3,ra
     58A4 0082     
                   < elite.a99
19054               
19055 58A6 D060  30        movb @QQ19+3,rx                 ; LDX QQ19+3        ; If the delta is negative, jump to TT124
     58A8 0082     
19056 58AA 1103  14        jlt  TT124                      ; BMI TT124
19057               
19058 58AC 1703  14        jnc  TT125                      ; BCC TT125         ; If the C flag is clear, then the above addition didn't
19059                                                                          ; overflow, so jump to TT125 to return the updated value
19060               
19061 58AE 0460  28        b    @rts                       ; RTS               ; Otherwise the C flag is set and the above addition
     58B0 FF1C     
19062                                                                          ; overflowed, so do not update the return value
19063               
19064               TT124:
19065 58B2 1702  14        jnc  TT180                      ; BCC TT180         ; If the C flag is clear, then because the delta is
19066                                                                          ; negative, this indicates the addition (which is
19067                                                                          ; effectively a subtraction) underflowed, so jump to
19068                                                                          ; TT180 to return from the subroutine without updating
19069                                                                          ; the return value
19070               
19071               TT125:
19072 58B4 D800  30        movb ra,@QQ19+4                 ; STA QQ19+4        ; Store the updated coordinate in QQ19+4
     58B6 0083     
19073               
19074               TT180:
19075 58B8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     58BA FF1C     
19076               
19077               * ******************************************************************************
19078               *
19079               * Name: TT105
19080               * Type: Subroutine
19081               * Category: Charts
19082               * Summary: Draw crosshairs on the Short-range Chart, with clipping
19083               *
19084               * ------------------------------------------------------------------------------
19085               *
19086               * Check whether the crosshairs are close enough to the current system to appear
19087               * on the Short-range Chart, and if so, draw them.
19088               *
19089               * ******************************************************************************
19090               
19091               TT105:
19092 58BC D020  30        movb @QQ9,ra                    ; LDA QQ9           ; Set A = QQ9 - QQ0, the horizontal distance between the
     58BE 0F31     
19093                      .sec                            ; SEC               ; crosshairs (QQ9) and the current system (QQ0)
     **** ****     > SEC
0001 58C0 0A15  18        sla  rmone,1
                   < elite.a99
19094                      .sbc @QQ0,ra                    ; SBC QQ0
     **** ****     > SBC
0001 58C2 1801  14        joc  !
0002 58C4 7004  18        sb   rone,ra
0003               !:
0004 58C6 7020  30        sb   @QQ0,ra
     58C8 0301     
                   < elite.a99
19095               
19096 58CA 0280  22        ci   ra,>26*256                 ; CMP #38           ; If the horizontal distance in A < 38, then the
     58CC 2600     
19097 58CE 1703  14        jnc  TT179                      ; BCC TT179         ; crosshairs are close enough to the current system to
19098                                                                          ; appear in the Short-range Chart, so jump to TT179 to
19099                                                                          ; check the vertical distance
19100               
19101 58D0 0280  22        ci   ra,>e6*256                 ; CMP #230          ; If the horizontal distance in A < -26, then the
     58D2 E600     
19102 58D4 17F1  14        jnc  TT180                      ; BCC TT180         ; crosshairs are too far from the current system to
19103                                                                          ; appear in the Short-range Chart, so jump to TT180 to
19104                                                                          ; return from the subroutine (as TT180 contains an RTS)
19105               
19106               TT179:
19107                      .asla                           ; ASL A             ; Set QQ19 = 104 + A * 4
     **** ****     > ASLA
0001 58D6 0240  22        andi ra,>ff00
     58D8 FF00     
0002 58DA 0A10  18        sla  ra,1
                   < elite.a99
19108                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 58DC 0240  22        andi ra,>ff00
     58DE FF00     
0002 58E0 0A10  18        sla  ra,1
                   < elite.a99
19109                      .clc                            ; CLC               ; 104 is the x-coordinate of the centre of the chart,
     **** ****     > CLC
0001 58E2 0A13  18        sla  rzero,1
                   < elite.a99
19110                      .adi (>68*256)                  ; ADC #104          ; so this sets QQ19 to the screen pixel x-coordinate
     **** ****     > ADI
0001 58E4 1701  14        jnc  !
0002 58E6 B004  18        ab   rone,ra
0003               !:
0004 58E8 0220  22        ai   ra,(>68*256)
     58EA 6800     
                   < elite.a99
19111 58EC D800  30        movb ra,@QQ19                   ; STA QQ19          ; of the crosshairs
     58EE 007F     
19112               
19113 58F0 D020  30        movb @QQ10,ra                   ; LDA QQ10          ; Set A = QQ10 - QQ1, the vertical distance between the
     58F2 0F32     
19114                      .sec                            ; SEC               ; crosshairs (QQ10) and the current system (QQ1)
     **** ****     > SEC
0001 58F4 0A15  18        sla  rmone,1
                   < elite.a99
19115                      .sbc @QQ1,ra                    ; SBC QQ1
     **** ****     > SBC
0001 58F6 1801  14        joc  !
0002 58F8 7004  18        sb   rone,ra
0003               !:
0004 58FA 7020  30        sb   @QQ1,ra
     58FC 0302     
                   < elite.a99
19116               
19117 58FE 0280  22        ci   ra,>26*256                 ; CMP #38           ; If the vertical distance in A is < 38, then the
     5900 2600     
19118 5902 1703  14        jnc  B57                        ; BCC B57           ; crosshairs are close enough to the current system to
19119                                                                          ; appear in the Short-range Chart, so skip the next two
19120                                                                          ; instructions
19121               
19122 5904 0280  22        ci   ra,>dc*256                 ; CMP #220          ; If the horizontal distance in A is < -36, then the
     5906 DC00     
19123 5908 17D7  14        jnc  TT180                      ; BCC TT180         ; crosshairs are too far from the current system to
19124                                                                          ; appear in the Short-range Chart, so jump to TT180 to
19125                                                                          ; return from the subroutine (as TT180 contains an RTS)
19126               
19127               B57:
19128                      .asla                           ; ASL A             ; Set QQ19+1 = 90 + A * 2
     **** ****     > ASLA
0001 590A 0240  22        andi ra,>ff00
     590C FF00     
0002 590E 0A10  18        sla  ra,1
                   < elite.a99
19129                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 5910 0A13  18        sla  rzero,1
                   < elite.a99
19130                      .adi (>5a*256)                  ; ADC #90           ; 90 is the y-coordinate of the centre of the chart,
     **** ****     > ADI
0001 5912 1701  14        jnc  !
0002 5914 B004  18        ab   rone,ra
0003               !:
0004 5916 0220  22        ai   ra,(>5A*256)
     5918 5A00     
                   < elite.a99
19131 591A D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; so this sets QQ19+1 to the screen pixel x-coordinate
     591C 0080     
19132                                                                          ; of the crosshairs
19133               
19134 591E 0200  20        li   ra,>08*256                 ; LDA #8            ; Set QQ19+2 to 8 denote crosshairs of size 8
     5920 0800     
19135 5922 D800  30        movb ra,@QQ19+2                 ; STA QQ19+2
     5924 0081     
19136               
19137 5926 0460  28        b    @TT15                      ; JMP TT15          ; Jump to TT15 to draw crosshairs of size 8 at the
     5928 5316     
19138                                                                          ; crosshairs coordinates, returning from the subroutine
19139                                                                          ; using a tail call
19140               
19141               * ******************************************************************************
19142               *
19143               * Name: TT23
19144               * Type: Subroutine
19145               * Category: Charts
19146               * Summary: Show the Short-range Chart (red key f5)
19147               *
19148               * ******************************************************************************
19149               
19150               TT23:
19151 592A 0200  20        li   ra,>80*256                 ; LDA #128          ; Clear the top part of the screen, draw a white border,
     592C 8000     
19152 592E 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 128 (Short-
     5930 4B2A     
19153 5932 06A0  32        bl   @jsr                       ;
     5934 FF10     
19154                                                                          ; range Chart)
19155               
19156 5936 0200  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     5938 0700     
19157 593A D800  30        movb ra,@XC                     ; STA XC
     593C 002C     
19158               
19159 593E 0200  20        li   ra,>be*256                 ; LDA #190          ; Print recursive token 30 ("SHORT RANGE CHART") and
     5940 BE00     
19160 5942 0206  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; draw a horizontal line at pixel row 19 to box in the
     5944 25B0     
19161 5946 06A0  32        bl   @jsr                       ;
     5948 FF10     
19162                                                                          ; title
19163               
19164 594A 0206  20        li   rtmp,TT14                  ; JSR TT14          ; Call TT14 to draw a circle with crosshairs at the
     594C 53FA     
19165 594E 06A0  32        bl   @jsr                       ;
     5950 FF10     
19166                                                                          ; current system's galactic coordinates
19167               
19168 5952 0206  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     5954 5872     
19169 5956 06A0  32        bl   @jsr                       ;
     5958 FF10     
19170                                                                          ; i.e. at the selected system
19171               
19172 595A 0206  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     595C 5AA4     
19173 595E 06A0  32        bl   @jsr                       ;
     5960 FF10     
19174                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
19175               
19176 5962 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0, which we'll use below to zero out the INWK
     5964 0000     
19177                                                                          ; workspace
19178               
19179 5966 D800  30        movb ra,@XX20                   ; STA XX20          ; We're about to start working our way through each of
     5968 00A8     
19180                                                                          ; the galaxy's systems, so set up a counter in XX20 for
19181                                                                          ; each system, starting at 0 and looping through to 255
19182               
19183 596A 0201  20        li   rx,>18*256                 ; LDX #24           ; First, though, we need to zero out the 25 bytes at
     596C 1800     
19184                                                                          ; INWK so we can use them to work out which systems have
19185                                                                          ; room for a label, so set a counter in X for 25 bytes
19186               
19187               EE3:
19188 596E D840  38        movb ra,@INWK(rx)               ; STA INWK,X        ; Set the X-th byte of INWK to zero
     5970 0053     
19189               
19190 5972 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19191               
19192 5974 15FC  14        jgt  EE3                        ; BPL EE3           ; Loop back to EE3 for the next byte until we've zeroed
19193                                                                          ; all 25 bytes
19194               
19195                                                                          ; We now loop through every single system in the galaxy
19196                                                                          ; and check the distance from the current system whose
19197                                                                          ; coordinates are in (QQ0, QQ1). We get the galactic
19198                                                                          ; coordinates of each system from the system's seeds,
19199                                                                          ; like this:
19200                                                                          ;
19201                                                                          ; x = s1_hi (which is stored in QQ15+3)
19202                                                                          ; y = s0_hi (which is stored in QQ15+1)
19203                                                                          ;
19204                                                                          ; so the following loops through each system in the
19205                                                                          ; galaxy in turn and calculates the distance between
19206                                                                          ; (QQ0, QQ1) and (s1_hi, s0_hi) to find the closest one
19207               
19208               TT182:
19209 5976 D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ0, the horizontal distance between
     5978 007B     
19210                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ0, QQ1)
     **** ****     > SEC
0001 597A 0A15  18        sla  rmone,1
                   < elite.a99
19211                      .sbc @QQ0,ra                    ; SBC QQ0
     **** ****     > SBC
0001 597C 1801  14        joc  !
0002 597E 7004  18        sb   rone,ra
0003               !:
0004 5980 7020  30        sb   @QQ0,ra
     5982 0301     
                   < elite.a99
19212               
19213 5984 1807  14        joc  TT184                      ; BCS TT184         ; If a borrow didn't occur, i.e. s1_hi >= QQ0, then the
19214                                                                          ; result is positive, so jump to TT184 and skip the
19215                                                                          ; following two instructions
19216               
19217                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5986 0206  20        li   rtmp,(>FF*256)
     5988 FF00     
0002 598A 2806  18        xor  rtmp,ra
                   < elite.a99
19218                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s1_hi - QQ0|)
     **** ****     > ADI
0001 598C 1701  14        jnc  !
0002 598E B004  18        ab   rone,ra
0003               !:
0004 5990 0220  22        ai   ra,(>01*256)
     5992 0100     
                   < elite.a99
19219               
19220               TT184:
19221 5994 0280  22        ci   ra,>14*256                 ; CMP #20           ; If the horizontal distance in A is >= 20, then this
     5996 1400     
19222 5998 187D  14        joc  TT187                      ; BCS TT187         ; system is too far away from the current system to
19223                                                                          ; appear in the Short-range Chart, so jump to TT187 to
19224                                                                          ; move on to the next system
19225               
19226 599A D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ1, the vertical distance between
     599C 0079     
19227                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ0, QQ1)
     **** ****     > SEC
0001 599E 0A15  18        sla  rmone,1
                   < elite.a99
19228                      .sbc @QQ1,ra                    ; SBC QQ1
     **** ****     > SBC
0001 59A0 1801  14        joc  !
0002 59A2 7004  18        sb   rone,ra
0003               !:
0004 59A4 7020  30        sb   @QQ1,ra
     59A6 0302     
                   < elite.a99
19229               
19230 59A8 1807  14        joc  TT186                      ; BCS TT186         ; If a borrow didn't occur, i.e. s0_hi >= QQ1, then the
19231                                                                          ; result is positive, so jump to TT186 and skip the
19232                                                                          ; following two instructions
19233               
19234                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 59AA 0206  20        li   rtmp,(>FF*256)
     59AC FF00     
0002 59AE 2806  18        xor  rtmp,ra
                   < elite.a99
19235                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s0_hi - QQ1|)
     **** ****     > ADI
0001 59B0 1701  14        jnc  !
0002 59B2 B004  18        ab   rone,ra
0003               !:
0004 59B4 0220  22        ai   ra,(>01*256)
     59B6 0100     
                   < elite.a99
19236               
19237               TT186:
19238 59B8 0280  22        ci   ra,>26*256                 ; CMP #38           ; If the vertical distance in A is >= 38, then this
     59BA 2600     
19239 59BC 186B  14        joc  TT187                      ; BCS TT187         ; system is too far away from the current system to
19240                                                                          ; appear in the Short-range Chart, so jump to TT187 to
19241                                                                          ; move on to the next system
19242               
19243                                                                          ; This system should be shown on the Short-range Chart,
19244                                                                          ; so now we need to work out where the label should go,
19245                                                                          ; and set up the various variables we need to draw the
19246                                                                          ; system's filled circle on the chart
19247               
19248 59BE D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ0, the horizontal distance between
     59C0 007B     
19249                      .sec                            ; SEC               ; this system and the current system, where |A| < 20.
     **** ****     > SEC
0001 59C2 0A15  18        sla  rmone,1
                   < elite.a99
19250                      .sbc @QQ0,ra                    ; SBC QQ0           ; Let's call this the x-delta, as it's the horizontal
     **** ****     > SBC
0001 59C4 1801  14        joc  !
0002 59C6 7004  18        sb   rone,ra
0003               !:
0004 59C8 7020  30        sb   @QQ0,ra
     59CA 0301     
                   < elite.a99
19251                                                                          ; difference between the current system at the centre of
19252                                                                          ; the chart, and this system (and this time we keep the
19253                                                                          ; sign of A, so it can be negative if it's to the left
19254                                                                          ; of the chart's centre, or positive if it's to the
19255                                                                          ; right)
19256               
19257                      .asla                           ; ASL A             ; Set XX12 = 104 + x-delta * 4
     **** ****     > ASLA
0001 59CC 0240  22        andi ra,>ff00
     59CE FF00     
0002 59D0 0A10  18        sla  ra,1
                   < elite.a99
19258                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 59D2 0240  22        andi ra,>ff00
     59D4 FF00     
0002 59D6 0A10  18        sla  ra,1
                   < elite.a99
19259                      .adi (>68*256)                  ; ADC #104          ; 104 is the x-coordinate of the centre of the chart,
     **** ****     > ADI
0001 59D8 1701  14        jnc  !
0002 59DA B004  18        ab   rone,ra
0003               !:
0004 59DC 0220  22        ai   ra,(>68*256)
     59DE 6800     
                   < elite.a99
19260 59E0 D800  30        movb ra,@XX12                   ; STA XX12          ; so this sets XX12 to the centre 104 +/- 76, the pixel
     59E2 0037     
19261                                                                          ; x-coordinate of this system
19262               
19263 59E4 0910  18        srl  ra,1                       ; LSR A             ; Move the text cursor to column x-delta / 2 + 1
19264 59E6 0910  18        srl  ra,1                       ; LSR A             ; which will be in the range 1-10
19265 59E8 0910  18        srl  ra,1                       ; LSR A
19266 59EA D800  30        movb ra,@XC                     ; STA XC
     59EC 002C     
19267 59EE B004  18        ab   rone,ra                    ; INC XC
19268               
19269 59F0 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ1, the vertical distance between
     59F2 0079     
19270                      .sec                            ; SEC               ; this system and the current system, where |A| < 38.
     **** ****     > SEC
0001 59F4 0A15  18        sla  rmone,1
                   < elite.a99
19271                      .sbc @QQ1,ra                    ; SBC QQ1           ; Let's call this the y-delta, as it's the vertical
     **** ****     > SBC
0001 59F6 1801  14        joc  !
0002 59F8 7004  18        sb   rone,ra
0003               !:
0004 59FA 7020  30        sb   @QQ1,ra
     59FC 0302     
                   < elite.a99
19272                                                                          ; difference between the current system at the centre of
19273                                                                          ; the chart, and this system (and this time we keep the
19274                                                                          ; sign of A, so it can be negative if it's above the
19275                                                                          ; chart's centre, or positive if it's below)
19276               
19277                      .asla                           ; ASL A             ; Set K4 = 90 + y-delta * 2
     **** ****     > ASLA
0001 59FE 0240  22        andi ra,>ff00
     5A00 FF00     
0002 5A02 0A10  18        sla  ra,1
                   < elite.a99
19278                      .adi (>5a*256)                  ; ADC #90           ;
     **** ****     > ADI
0001 5A04 1701  14        jnc  !
0002 5A06 B004  18        ab   rone,ra
0003               !:
0004 5A08 0220  22        ai   ra,(>5A*256)
     5A0A 5A00     
                   < elite.a99
19279 5A0C D800  30        movb ra,@K4                     ; STA K4            ; 90 is the y-coordinate of the centre of the chart,
     5A0E 00E0     
19280                                                                          ; so this sets K4 to the centre 90 +/- 74, the pixel
19281                                                                          ; y-coordinate of this system
19282               
19283 5A10 0910  18        srl  ra,1                       ; LSR A             ; Set Y = K4 / 8, so Y contains the number of the text
19284 5A12 0910  18        srl  ra,1                       ; LSR A             ; row that contains this system
19285 5A14 0910  18        srl  ra,1                       ; LSR A
19286 5A16 D080  18        movb ra,ry                      ; TAY
19287               
19288                                                                          ; Now to see if there is room for this system's label.
19289                                                                          ; Ideally we would print the system name on the same
19290                                                                          ; text row as the system, but we only want to print one
19291                                                                          ; label per row, to prevent overlap, so now we check
19292                                                                          ; this system's row, and if that's already occupied,
19293                                                                          ; the row above, and if that's already occupied, the
19294                                                                          ; row below... and if that's already occupied, we give
19295                                                                          ; up and don't print a label for this system
19296               
19297 5A18 D062  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; If the value in INWK+Y is 0 (i.e. the text row
     5A1A 0053     
19298 5A1C 1309  14        jeq  EE4                        ; BEQ EE4           ; containing this system does not already have another
19299                                                                          ; system's label on it), jump to EE4 to store this
19300                                                                          ; system's label on this row
19301               
19302 5A1E B084  18        ab   rone,ry                    ; INY               ; If the value in INWK+Y+1 is 0 (i.e. the text row below
19303 5A20 D062  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; the one containing this system does not already have
     5A22 0053     
19304 5A24 1305  14        jeq  EE4                        ; BEQ EE4           ; another system's label on it), jump to EE4 to store
19305                                                                          ; this system's label on this row
19306               
19307 5A26 7084  18        sb   rone,ry                    ; DEY               ; If the value in INWK+Y-1 is 0 (i.e. the text row above
19308 5A28 7084  18        sb   rone,ry                    ; DEY               ; the one containing this system does not already have
19309 5A2A D062  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; another system's label on it), fall through into to
     5A2C 0053     
19310 5A2E 1610  14        jne  ee1_                       ; BNE ee1           ; EE4 to store this system's label on this row,
19311                                                                          ; otherwise jump to ee1 to skip printing a label for
19312                                                                          ; this system (as there simply isn't room)
19313               
19314               EE4:
19315 5A30 D802  30        movb ry,@YC                     ; STY YC            ; Now to print the label, so move the text cursor to row
     5A32 002D     
19316                                                                          ; Y (which contains the row where we can print this
19317                                                                          ; system's label)
19318               
19319 5A34 0282  22        ci   ry,>03*256                 ; CPY #3            ; If Y < 3, then the system would clash with the chart
     5A36 0300     
19320 5A38 172D  14        jnc  TT187                      ; BCC TT187         ; title, so jump to TT187 to skip showing the system
19321               
19322 5A3A 7044  18        sb   rone,rx                    ; DEX               ; We entered the EE4 routine with X = 0, so this stores
19323 5A3C D881  38        movb rx,@INWK(ry)               ; STX INWK,Y        ; &FF in INWK+Y, to denote that this row is now occupied
     5A3E 0053     
19324                                                                          ; so we don't try to print another system's label on
19325                                                                          ; this row
19326               
19327 5A40 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     5A42 8000     
19328 5A44 D800  30        movb ra,@QQ17                   ; STA QQ17
     5A46 007E     
19329               
19330 5A48 0206  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print out the system name for the seeds
     5A4A A5C4     
19331 5A4C 06A0  32        bl   @jsr                       ;
     5A4E FF10     
19332                                                                          ; in QQ15 (which now contains the seeds for the current
19333                                                                          ; system)
19334               
19335               ee1_:
19336 5A50 0200  20        li   ra,>00*256                 ; LDA #0            ; Now to plot the star, so set the high bytes of K, K3
     5A52 0000     
19337 5A54 D800  30        movb ra,@K3+1                   ; STA K3+1          ; and K4 to 0
     5A56 00D3     
19338 5A58 D800  30        movb ra,@K4+1                   ; STA K4+1
     5A5A 00E1     
19339 5A5C D800  30        movb ra,@K+1                    ; STA K+1
     5A5E 003E     
19340               
19341 5A60 D020  30        movb @XX12,ra                   ; LDA XX12          ; Set the low byte of K3 to XX12, the pixel x-coordinate
     5A62 0037     
19342 5A64 D800  30        movb ra,@K3                     ; STA K3            ; of this system
     5A66 00D2     
19343               
19344 5A68 D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Fetch s2_hi for this system from QQ15+5, extract bit 0
     5A6A 007D     
19345 5A6C 0240  22        andi ra,>01*256                 ; AND #1            ; and add 2 to get the size of the star, which we store
     5A6E 0100     
19346                      .adi (>02*256)                  ; ADC #2            ; in K. This will be either 2, 3 or 4, depending on the
     **** ****     > ADI
0001 5A70 1701  14        jnc  !
0002 5A72 B004  18        ab   rone,ra
0003               !:
0004 5A74 0220  22        ai   ra,(>02*256)
     5A76 0200     
                   < elite.a99
19347 5A78 D800  30        movb ra,@K                      ; STA K             ; value of bit 0, and whether the C flag is set (which
     5A7A 003D     
19348                                                                          ; will vary depending on what happens in the above call
19349                                                                          ; to cpl). Incidentally, the planet's average radius
19350                                                                          ; also uses s2_hi, bits 0-3 to be precise, but that
19351                                                                          ; doesn't mean the two sizes affect each other
19352               
19353                                                                          ; We now have the following:
19354                                                                          ;
19355                                                                          ; K(1 0)  = radius of star (2, 3 or 4)
19356                                                                          ;
19357                                                                          ; K3(1 0) = pixel x-coordinate of system
19358                                                                          ;
19359                                                                          ; K4(1 0) = pixel y-coordinate of system
19360                                                                          ;
19361                                                                          ; which we can now pass to the SUN routine to draw a
19362                                                                          ; small "sun" on the Short-range Chart for this system
19363               
19364 5A7C 0206  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Call FLFLLS to reset the LSO block
     5A7E ACA6     
19365 5A80 06A0  32        bl   @jsr                       ;
     5A82 FF10     
19366               
19367 5A84 0206  20        li   rtmp,SUN                   ; JSR SUN           ; Call SUN to plot a sun with radius K at pixel
     5A86 B5C4     
19368 5A88 06A0  32        bl   @jsr                       ;
     5A8A FF10     
19369                                                                          ; coordinate (K3, K4)
19370               
19371 5A8C 0206  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Call FLFLLS to reset the LSO block
     5A8E ACA6     
19372 5A90 06A0  32        bl   @jsr                       ;
     5A92 FF10     
19373               
19374               TT187:
19375 5A94 0206  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     5A96 4E32     
19376 5A98 06A0  32        bl   @jsr                       ;
     5A9A FF10     
19377                                                                          ; to twist the three 16-bit seeds in QQ15
19378               
19379 5A9C B004  18        ab   rone,ra                    ; INC XX20          ; Increment the counter
19380               
19381 5A9E 130B  14        jeq  TT111-1                    ; BEQ TT111-1       ; If X = 0 then we have done all 256 systems, so return
19382                                                                          ; from the subroutine (as TT111-1 contains an RTS)
19383               
19384 5AA0 0460  28        b    @TT182                     ; JMP TT182         ; Otherwise jump back up to TT182 to process the next
     5AA2 5976     
19385                                                                          ; system
19386               
19387               * ******************************************************************************
19388               *
19389               * Name: TT81
19390               * Type: Subroutine
19391               * Category: Universe
19392               * Summary: Set the selected system's seeds to those of system 0
19393               *
19394               * ------------------------------------------------------------------------------
19395               *
19396               * Copy the three 16-bit seeds for the current galaxy's system 0 (QQ21) into the
19397               * seeds for the selected system (QQ15) - in other words, set the selected
19398               * system's seeds to those of system 0.
19399               *
19400               * ******************************************************************************
19401               
19402               TT81:
19403 5AA4 0201  20        li   rx,>05*256                 ; LDX #5            ; Set up a counter in X to copy six bytes (for three
     5AA6 0500     
19404                                                                          ; 16-bit numbers)
19405               
19406 5AA8 D021  34        movb @QQ21(rx),ra               ; LDA QQ21,X        ; Copy the X-th byte in QQ21 to the X-th byte in QQ15
     5AAA 0303     
19407 5AAC D840  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     5AAE 0078     
19408               
19409 5AB0 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19410               
19411 5AB2 15F9  14        jgt  TT81+2                     ; BPL TT81+2        ; Loop back up to the LDA instruction if we still have
19412                                                                          ; more bytes to copy
19413               
19414 5AB4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5AB6 FF1C     
19415               
19416               * ******************************************************************************
19417               *
19418               * Name: TT111
19419               * Type: Subroutine
19420               * Category: Universe
19421               * Summary: Set the current system to the nearest system to a point
19422               *
19423               * ------------------------------------------------------------------------------
19424               *
19425               * Given a set of galactic coordinates in (QQ9, QQ10), find the nearest system
19426               * to this point in the galaxy, and set this as the currently selected system.
19427               *
19428               * ------------------------------------------------------------------------------
19429               *
19430               * Arguments:
19431               *
19432               * QQ9                 The x-coordinate near which we want to find a system
19433               *
19434               * QQ10                The y-coordinate near which we want to find a system
19435               *
19436               * ------------------------------------------------------------------------------
19437               *
19438               * Returns:
19439               *
19440               * QQ8(1 0)            The distance from the current system to the nearest
19441               * system to the original coordinates
19442               *
19443               * QQ9                 The x-coordinate of the nearest system to the original
19444               * coordinates
19445               *
19446               * QQ10                The y-coordinate of the nearest system to the original
19447               * coordinates
19448               *
19449               * QQ15 to QQ15+5      The three 16-bit seeds of the nearest system to the
19450               * original coordinates
19451               *
19452               * ------------------------------------------------------------------------------
19453               *
19454               * Other entry points:
19455               *
19456               * TT111-1             Contains an RTS
19457               *
19458               * ******************************************************************************
19459               
19460               TT111:
19461 5AB8 0206  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     5ABA 5AA4     
19462 5ABC 06A0  32        bl   @jsr                       ;
     5ABE FF10     
19463                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
19464               
19465                                                                          ; We now loop through every single system in the galaxy
19466                                                                          ; and check the distance from (QQ9, QQ10). We get the
19467                                                                          ; galactic coordinates of each system from the system's
19468                                                                          ; seeds, like this:
19469                                                                          ;
19470                                                                          ; x = s1_hi (which is stored in QQ15+3)
19471                                                                          ; y = s0_hi (which is stored in QQ15+1)
19472                                                                          ;
19473                                                                          ; so the following loops through each system in the
19474                                                                          ; galaxy in turn and calculates the distance between
19475                                                                          ; (QQ9, QQ10) and (s1_hi, s0_hi) to find the closest one
19476               
19477 5AC0 0202  20        li   ry,>7f*256                 ; LDY #127          ; Set Y = T = 127 to hold the shortest distance we've
     5AC2 7F00     
19478 5AC4 D802  30        movb ry,@T                      ; STY T             ; found so far, which we initially set to half the
     5AC6 00D1     
19479                                                                          ; distance across the galaxy, or 127, as our coordinate
19480                                                                          ; system ranges from (0,0) to (255, 255)
19481               
19482 5AC8 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = U = 0 to act as a counter for each system in
     5ACA 0000     
19483 5ACC D800  30        movb ra,@U                      ; STA U             ; the current galaxy, which we start at system 0 and
     5ACE 008F     
19484                                                                          ; loop through to 255, the last system
19485               
19486               TT130:
19487 5AD0 D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ9, the horizontal distance between
     5AD2 007B     
19488                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ9, QQ10)
     **** ****     > SEC
0001 5AD4 0A15  18        sla  rmone,1
                   < elite.a99
19489                      .sbc @QQ9,ra                    ; SBC QQ9
     **** ****     > SBC
0001 5AD6 1801  14        joc  !
0002 5AD8 7004  18        sb   rone,ra
0003               !:
0004 5ADA 7020  30        sb   @QQ9,ra
     5ADC 0F31     
                   < elite.a99
19490               
19491 5ADE 1807  14        joc  TT132                      ; BCS TT132         ; If a borrow didn't occur, i.e. s1_hi >= QQ9, then the
19492                                                                          ; result is positive, so jump to TT132 and skip the
19493                                                                          ; following two instructions
19494               
19495                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5AE0 0206  20        li   rtmp,(>FF*256)
     5AE2 FF00     
0002 5AE4 2806  18        xor  rtmp,ra
                   < elite.a99
19496                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s1_hi - QQ9|)
     **** ****     > ADI
0001 5AE6 1701  14        jnc  !
0002 5AE8 B004  18        ab   rone,ra
0003               !:
0004 5AEA 0220  22        ai   ra,(>01*256)
     5AEC 0100     
                   < elite.a99
19497               
19498               TT132:
19499 5AEE 0910  18        srl  ra,1                       ; LSR A             ; Set S = A / 2
19500 5AF0 D800  30        movb ra,@S                      ; STA S             ; = |s1_hi - QQ9| / 2
     5AF2 0092     
19501               
19502 5AF4 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ10, the vertical distance between
     5AF6 0079     
19503                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ9, QQ10)
     **** ****     > SEC
0001 5AF8 0A15  18        sla  rmone,1
                   < elite.a99
19504                      .sbc @QQ10,ra                   ; SBC QQ10
     **** ****     > SBC
0001 5AFA 1801  14        joc  !
0002 5AFC 7004  18        sb   rone,ra
0003               !:
0004 5AFE 7020  30        sb   @QQ10,ra
     5B00 0F32     
                   < elite.a99
19505               
19506 5B02 1807  14        joc  TT134                      ; BCS TT134         ; If a borrow didn't occur, i.e. s0_hi >= QQ10, then the
19507                                                                          ; result is positive, so jump to TT134 and skip the
19508                                                                          ; following two instructions
19509               
19510                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5B04 0206  20        li   rtmp,(>FF*256)
     5B06 FF00     
0002 5B08 2806  18        xor  rtmp,ra
                   < elite.a99
19511                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s0_hi - QQ10|)
     **** ****     > ADI
0001 5B0A 1701  14        jnc  !
0002 5B0C B004  18        ab   rone,ra
0003               !:
0004 5B0E 0220  22        ai   ra,(>01*256)
     5B10 0100     
                   < elite.a99
19512               
19513               TT134:
19514 5B12 0910  18        srl  ra,1                       ; LSR A             ; Set A = S + A / 2
19515                      .clc                            ; CLC               ; = |s1_hi - QQ9| / 2 + |s0_hi - QQ10| / 2
     **** ****     > CLC
0001 5B14 0A13  18        sla  rzero,1
                   < elite.a99
19516                      .adc @S,ra                      ; ADC S             ;
     **** ****     > ADC
0001 5B16 1701  14        jnc  !
0002 5B18 B004  18        ab   rone,ra
0003               !:
0004 5B1A B020  30        ab   @S,ra
     5B1C 0092     
                   < elite.a99
19517                                                                          ; So A now contains the sum of the horizontal and
19518                                                                          ; vertical distances, both divided by 2 so the result
19519                                                                          ; fits into one byte, and although this doesn't contain
19520                                                                          ; the actual distance between the systems, it's a good
19521                                                                          ; enough approximation to use for comparing distances
19522               
19523 5B1E 9020  30        cb   @T,ra                      ; CMP T             ; If A >= T, then this system's distance is bigger than
     5B20 00D1     
19524 5B22 180A  14        joc  TT135                      ; BCS TT135         ; our "minimum distance so far" stored in T, so it's no
19525                                                                          ; closer than the systems we have already found, so
19526                                                                          ; skip to TT135 to move on to the next system
19527               
19528 5B24 D800  30        movb ra,@T                      ; STA T             ; This system is the closest to (QQ9, QQ10) so far, so
     5B26 00D1     
19529                                                                          ; update T with the new "distance" approximation
19530               
19531 5B28 0201  20        li   rx,>05*256                 ; LDX #5            ; As this system is the closest we have found yet, we
     5B2A 0500     
19532                                                                          ; want to store the system's seeds in case it ends up
19533                                                                          ; being the closest of all, so we set up a counter in X
19534                                                                          ; to copy six bytes (for three 16-bit numbers)
19535               
19536               TT136:
19537 5B2C D021  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy the X-th byte in QQ15 to the X-th byte in QQ19,
     5B2E 0078     
19538 5B30 D840  38        movb ra,@QQ19(rx)               ; STA QQ19,X        ; where QQ15 contains the seeds for the system we just
     5B32 007F     
19539                                                                          ; found to be the closest so far, and QQ19 is temporary
19540                                                                          ; storage
19541               
19542 5B34 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19543               
19544 5B36 15FA  14        jgt  TT136                      ; BPL TT136         ; Loop back to TT136 if we still have more bytes to
19545                                                                          ; copy
19546               
19547               TT135:
19548 5B38 0206  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     5B3A 4E32     
19549 5B3C 06A0  32        bl   @jsr                       ;
     5B3E FF10     
19550                                                                          ; to twist the three 16-bit seeds in QQ15
19551               
19552 5B40 B004  18        ab   rone,ra                    ; INC U             ; Increment the system counter in U
19553               
19554 5B42 16C6  14        jne  TT130                      ; BNE TT130         ; If U > 0 then we haven't done all 256 systems yet, so
19555                                                                          ; loop back up to TT130
19556               
19557                                                                          ; We have now finished checking all the systems in the
19558                                                                          ; galaxy, and the seeds for the closest system are in
19559                                                                          ; QQ19, so now we want to copy these seeds to QQ15,
19560                                                                          ; to set the selected system to this closest system
19561               
19562 5B44 0201  20        li   rx,>05*256                 ; LDX #5            ; So we set up a counter in X to copy six bytes (for
     5B46 0500     
19563                                                                          ; three 16-bit numbers)
19564               
19565               TT137:
19566 5B48 D021  34        movb @QQ19(rx),ra               ; LDA QQ19,X        ; Copy the X-th byte in QQ19 to the X-th byte in QQ15
     5B4A 007F     
19567 5B4C D840  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     5B4E 0078     
19568               
19569 5B50 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19570               
19571 5B52 15FA  14        jgt  TT137                      ; BPL TT137         ; Loop back to TT137 if we still have more bytes to
19572                                                                          ; copy
19573               
19574 5B54 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; The y-coordinate of the system described by the seeds
     5B56 0079     
19575 5B58 D800  30        movb ra,@QQ10                   ; STA QQ10          ; in QQ15 is in QQ15+1 (s0_hi), so we copy this to QQ10
     5B5A 0F32     
19576                                                                          ; as this is where we store the selected system's
19577                                                                          ; y-coordinate
19578               
19579 5B5C D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; The x-coordinate of the system described by the seeds
     5B5E 007B     
19580 5B60 D800  30        movb ra,@QQ9                    ; STA QQ9           ; in QQ15 is in QQ15+3 (s1_hi), so we copy this to QQ9
     5B62 0F31     
19581                                                                          ; as this is where we store the selected system's
19582                                                                          ; x-coordinate
19583               
19584                                                                          ; We have now found the closest system to (QQ9, QQ10)
19585                                                                          ; and have set it as the selected system, so now we
19586                                                                          ; need to work out the distance between the selected
19587                                                                          ; system and the current system
19588               
19589                      .sec                            ; SEC               ; Set A = QQ9 - QQ0, the horizontal distance between
     **** ****     > SEC
0001 5B64 0A15  18        sla  rmone,1
                   < elite.a99
19590                      .sbc @QQ0,ra                    ; SBC QQ0           ; the selected system's x-coordinate (QQ9) and the
     **** ****     > SBC
0001 5B66 1801  14        joc  !
0002 5B68 7004  18        sb   rone,ra
0003               !:
0004 5B6A 7020  30        sb   @QQ0,ra
     5B6C 0301     
                   < elite.a99
19591                                                                          ; current system's x-coordinate (QQ0)
19592               
19593 5B6E 1807  14        joc  TT139                      ; BCS TT139         ; If a borrow didn't occur, i.e. QQ9 >= QQ0, then the
19594                                                                          ; result is positive, so jump to TT139 and skip the
19595                                                                          ; following two instructions
19596               
19597                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5B70 0206  20        li   rtmp,(>FF*256)
     5B72 FF00     
0002 5B74 2806  18        xor  rtmp,ra
                   < elite.a99
19598                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |QQ9 - QQ0|)
     **** ****     > ADI
0001 5B76 1701  14        jnc  !
0002 5B78 B004  18        ab   rone,ra
0003               !:
0004 5B7A 0220  22        ai   ra,(>01*256)
     5B7C 0100     
                   < elite.a99
19599               
19600                                                                          ; A now contains the difference between the two
19601                                                                          ; systems' x-coordinates, with the sign removed. We
19602                                                                          ; will refer to this as the x-delta ("delta" means
19603                                                                          ; change or difference in maths)
19604               
19605               TT139:
19606 5B7E 0206  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A
     5B80 42BA     
19607 5B82 06A0  32        bl   @jsr                       ;
     5B84 FF10     
19608                                                                          ; = |QQ9 - QQ0| ^ 2
19609                                                                          ; = x_delta ^ 2
19610               
19611 5B86 D800  30        movb ra,@K+1                    ; STA K+1           ; Store (A P) in K(1 0)
     5B88 003E     
19612 5B8A D020  30        movb @P,ra                      ; LDA P
     5B8C 001B     
19613 5B8E D800  30        movb ra,@K                      ; STA K
     5B90 003D     
19614               
19615 5B92 D020  30        movb @QQ10,ra                   ; LDA QQ10          ; Set A = QQ10 - QQ1, the vertical distance between the
     5B94 0F32     
19616                      .sec                            ; SEC               ; selected system's y-coordinate (QQ10) and the current
     **** ****     > SEC
0001 5B96 0A15  18        sla  rmone,1
                   < elite.a99
19617                      .sbc @QQ1,ra                    ; SBC QQ1           ; system's y-coordinate (QQ1)
     **** ****     > SBC
0001 5B98 1801  14        joc  !
0002 5B9A 7004  18        sb   rone,ra
0003               !:
0004 5B9C 7020  30        sb   @QQ1,ra
     5B9E 0302     
                   < elite.a99
19618               
19619 5BA0 1807  14        joc  TT141                      ; BCS TT141         ; If a borrow didn't occur, i.e. QQ10 >= QQ1, then the
19620                                                                          ; result is positive, so jump to TT141 and skip the
19621                                                                          ; following two instructions
19622               
19623                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5BA2 0206  20        li   rtmp,(>FF*256)
     5BA4 FF00     
0002 5BA6 2806  18        xor  rtmp,ra
                   < elite.a99
19624                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |QQ10 - QQ1|)
     **** ****     > ADI
0001 5BA8 1701  14        jnc  !
0002 5BAA B004  18        ab   rone,ra
0003               !:
0004 5BAC 0220  22        ai   ra,(>01*256)
     5BAE 0100     
                   < elite.a99
19625               
19626               TT141:
19627 5BB0 0910  18        srl  ra,1                       ; LSR A             ; Set A = A / 2
19628               
19629                                                                          ; A now contains the difference between the two
19630                                                                          ; systems' y-coordinates, with the sign removed, and
19631                                                                          ; halved. We halve the value because the galaxy in
19632                                                                          ; in Elite is rectangular rather than square, and is
19633                                                                          ; twice as wide (x-axis) as it is high (y-axis), so to
19634                                                                          ; get a distance that matches the shape of the
19635                                                                          ; long-range galaxy chart, we need to halve the
19636                                                                          ; distance between the vertical y-coordinates. We will
19637                                                                          ; refer to this as the y-delta
19638               
19639 5BB2 0206  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A
     5BB4 42BA     
19640 5BB6 06A0  32        bl   @jsr                       ;
     5BB8 FF10     
19641                                                                          ; = (|QQ10 - QQ1| / 2) ^ 2
19642                                                                          ; = y_delta ^ 2
19643               
19644                                                                          ; By this point we have the following results:
19645                                                                          ;
19646                                                                          ; K(1 0) = x_delta ^ 2
19647                                                                          ; (A P) = y_delta ^ 2
19648                                                                          ;
19649                                                                          ; so to find the distance between the two points, we
19650                                                                          ; can use Pythagoras - so first we need to add the two
19651                                                                          ; results together, and then take the square root
19652               
19653                      .pha                            ; PHA               ; Store the high byte of the y-axis value on the stack,
     **** ****     > PHA
0001 5BBA D680  30        movb ra,*rsp
0002 5BBC 060A  14        dec  rsp
                   < elite.a99
19654                                                                          ; so we can use A for another purpose
19655               
19656 5BBE D020  30        movb @P,ra                      ; LDA P             ; Set Q = P + K, which adds the low bytes of the two
     5BC0 001B     
19657                      .clc                            ; CLC               ; calculated values
     **** ****     > CLC
0001 5BC2 0A13  18        sla  rzero,1
                   < elite.a99
19658                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 5BC4 1701  14        jnc  !
0002 5BC6 B004  18        ab   rone,ra
0003               !:
0004 5BC8 B020  30        ab   @K,ra
     5BCA 003D     
                   < elite.a99
19659 5BCC D800  30        movb ra,@Q                      ; STA Q
     5BCE 0090     
19660               
19661                      .pla                            ; PLA               ; Restore the high byte of the y-axis value from the
     **** ****     > PLA
0001 5BD0 058A  14        inc  rsp
0002 5BD2 D01A  26        movb *rsp,ra
                   < elite.a99
19662                                                                          ; stack into A again
19663               
19664                      .adc @K+1,ra                    ; ADC K+1           ; Set R = A + K+1, which adds the high bytes of the two
     **** ****     > ADC
0001 5BD4 1701  14        jnc  !
0002 5BD6 B004  18        ab   rone,ra
0003               !:
0004 5BD8 B020  30        ab   @K+1,ra
     5BDA 003E     
                   < elite.a99
19665 5BDC D800  30        movb ra,@R                      ; STA R             ; calculated values, so we now have:
     5BDE 0091     
19666                                                                          ;
19667                                                                          ; (R Q) = K(1 0) + (A P)
19668                                                                          ; = (x_delta ^ 2) + (y_delta ^ 2)
19669               
19670 5BE0 0206  20        li   rtmp,LL5                   ; JSR LL5           ; Set Q = SQRT(R Q), so Q now contains the distance
     5BE2 D2B6     
19671 5BE4 06A0  32        bl   @jsr                       ;
     5BE6 FF10     
19672                                                                          ; between the two systems, in terms of coordinates
19673               
19674                                                                          ; We now store the distance to the selected system * 4
19675                                                                          ; in the two-byte location QQ8, by taking (0 Q) and
19676                                                                          ; shifting it left twice, storing it in QQ8(1 0)
19677               
19678 5BE8 D020  30        movb @Q,ra                      ; LDA Q             ; First we shift the low byte left by setting
     5BEA 0090     
19679                      .asla                           ; ASL A             ; A = Q * 2, with bit 7 of A going into the C flag
     **** ****     > ASLA
0001 5BEC 0240  22        andi ra,>ff00
     5BEE FF00     
0002 5BF0 0A10  18        sla  ra,1
                   < elite.a99
19680               
19681 5BF2 0201  20        li   rx,>00*256                 ; LDX #0            ; Now we set the high byte in QQ8+1 to 0 and rotate
     5BF4 0000     
19682 5BF6 D801  30        movb rx,@QQ8+1                  ; STX QQ8+1         ; the C flag into bit 0 of QQ8+1
     5BF8 0F30     
19683 5BFA 0208  20        li   rarg1,QQ8+1                ; ROL QQ8+1
     5BFC 0F30     
19684 5BFE 06A0  32        bl   @rol                       ;
     5C00 FF36     
19685               
19686                      .asla                           ; ASL A             ; And then we repeat the shift left of (QQ8+1 A)
     **** ****     > ASLA
0001 5C02 0240  22        andi ra,>ff00
     5C04 FF00     
0002 5C06 0A10  18        sla  ra,1
                   < elite.a99
19687 5C08 0208  20        li   rarg1,QQ8+1                ; ROL QQ8+1
     5C0A 0F30     
19688 5C0C 06A0  32        bl   @rol                       ;
     5C0E FF36     
19689               
19690 5C10 D800  30        movb ra,@QQ8                    ; STA QQ8           ; And store A in the low byte, QQ8, so QQ8(1 0) now
     5C12 0F2F     
19691                                                                          ; contains Q * 4. Given that the width of the galaxy is
19692                                                                          ; 256 in coordinate terms, the width of the galaxy
19693                                                                          ; would be 1024 in the units we store in QQ8
19694               
19695 5C14 0460  28        b    @TT24                      ; JMP TT24          ; Call TT24 to calculate system data from the seeds in
     5C16 5162     
19696                                                                          ; QQ15 and store them in the relevant locations, so our
19697                                                                          ; new selected system is fully set up, and return from
19698                                                                          ; the subroutine using a tail call
19699               
19700               * ******************************************************************************
19701               *
19702               * Name: hy6
19703               * Type: Subroutine
19704               * Category: Flight
19705               * Summary: Print a message to say there is no hyperspacing allowed inside the
19706               * station
19707               *
19708               * ------------------------------------------------------------------------------
19709               *
19710               * Print "Docked" at the bottom of the screen to indicate we can't hyperspace
19711               * when docked.
19712               *
19713               * ******************************************************************************
19714               
19715               hy6_:
19716 5C18 0206  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     5C1A 4C2E     
19717 5C1C 06A0  32        bl   @jsr                       ;
     5C1E FF10     
19718                                                                          ; and move the text cursor to column 1 on row 21, i.e.
19719                                                                          ; the start of the top row of the three bottom rows
19720               
19721 5C20 0200  20        li   ra,>0f*256                 ; LDA #15           ; Move the text cursor to column 15 (the middle of the
     5C22 0F00     
19722 5C24 D800  30        movb ra,@XC                     ; STA XC            ; screen), setting A to 15 at the same time for the
     5C26 002C     
19723                                                                          ; following call to TT27
19724               
19725 5C28 0460  28        b    @TT27                      ; JMP TT27          ; Print recursive token 129 ("{sentence case}DOCKED")
     5C2A A6E8     
19726                                                                          ; and return from the subroutine using a tail call
19727               
19728               * ******************************************************************************
19729               *
19730               * Name: hyp
19731               * Type: Subroutine
19732               * Category: Flight
19733               * Summary: Start the hyperspace process
19734               *
19735               * ------------------------------------------------------------------------------
19736               *
19737               * Called when "H" or CTRL-H is pressed during flight. Checks the following:
19738               *
19739               * * We are in space
19740               *
19741               * * We are not already in a hyperspace countdown
19742               *
19743               * If CTRL is being held down, we jump to Ghy to engage the galactic hyperdrive,
19744               * otherwise we check that:
19745               *
19746               * * The selected system is not the current system
19747               *
19748               * * We have enough fuel to make the jump
19749               *
19750               * and if all the pre-jump checks are passed, we print the destination on-screen
19751               * and start the countdown.
19752               *
19753               * ******************************************************************************
19754               
19755               hyp_:
19756 5C2C D020  30        movb @QQ12,ra                   ; LDA QQ12          ; If we are docked (QQ12 = &FF) then jump to hy6 to
     5C2E 009F     
19757 5C30 16F3  14        jne  hy6_                       ; BNE hy6           ; print an error message and return from the subroutine
19758                                                                          ; using a tail call (as we can't hyperspace when docked)
19759               
19760 5C32 D020  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; Fetch QQ22+1, which contains the number that's shown
     5C34 002F     
19761                                                                          ; on-screen during hyperspace countdown
19762               
19763 5C36 165B  14        jne  zZ_+1                      ; BNE zZ_+1         ; If it is non-zero, return from the subroutine (as zZ+1
19764                                                                          ; contains an RTS), as there is already a countdown in
19765                                                                          ; progress
19766               
19767 5C38 0206  20        li   rtmp,CTRL                  ; JSR CTRL          ; Scan the keyboard to see if CTRL is currently pressed
     5C3A CC24     
19768 5C3C 06A0  32        bl   @jsr                       ;
     5C3E FF10     
19769               
19770 5C40 1136  14        jlt  Ghy                        ; BMI Ghy           ; If it is, then the galactic hyperdrive has been
19771                                                                          ; activated, so jump to Ghy to process it
19772               
19773 5C42 0206  20        li   rtmp,hm_                   ; JSR hm            ; This is a chart view, so call hm to redraw the chart
     5C44 4C10     
19774 5C46 06A0  32        bl   @jsr                       ;
     5C48 FF10     
19775                                                                          ; crosshairs
19776               
19777 5C4A D020  30        movb @QQ8,ra                    ; LDA QQ8           ; If both bytes of the distance to the selected system
     5C4C 0F2F     
19778 5C4E F020  30        socb @QQ8+1,ra                  ; ORA QQ8+1         ; in QQ8 are zero, return from the subroutine (as zZ+1
     5C50 0F30     
19779 5C52 134D  14        jeq  zZ_+1                      ; BEQ zZ_+1         ; contains an RTS), as the selected system is the
19780                                                                          ; current system
19781               
19782 5C54 0200  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7, row 23 (in the
     5C56 0700     
19783 5C58 D800  30        movb ra,@XC                     ; STA XC            ; middle of the bottom text row)
     5C5A 002C     
19784 5C5C 0200  20        li   ra,>17*256                 ; LDA #23
     5C5E 1700     
19785 5C60 D800  30        movb ra,@YC                     ; STA YC
     5C62 002D     
19786               
19787 5C64 0200  20        li   ra,>00*256                 ; LDA #0            ; Set QQ17 = 0 to switch to ALL CAPS
     5C66 0000     
19788 5C68 D800  30        movb ra,@QQ17                   ; STA QQ17
     5C6A 007E     
19789               
19790 5C6C 0200  20        li   ra,>bd*256                 ; LDA #189          ; Print recursive token 29 ("HYPERSPACE ")
     5C6E BD00     
19791 5C70 0206  20        li   rtmp,TT27                  ; JSR TT27
     5C72 A6E8     
19792 5C74 06A0  32        bl   @jsr                       ;
     5C76 FF10     
19793               
19794 5C78 D020  30        movb @QQ8+1,ra                  ; LDA QQ8+1         ; If the high byte of the distance to the selected
     5C7A 0F30     
19795 5C7C 1668  14        jne  TT147                      ; BNE TT147         ; system in QQ8 is > 0, then it is definitely too far to
19796                                                                          ; jump (as our maximum range is 7.0 light years, or a
19797                                                                          ; value of 70 in QQ8(1 0)), so jump to TT147 to print
19798                                                                          ; "RANGE?" and return from the subroutine using a tail
19799                                                                          ; call
19800               
19801 5C7E D020  30        movb @QQ14,ra                   ; LDA QQ14          ; Fetch our current fuel level from Q114 into A
     5C80 030D     
19802               
19803 5C82 9020  30        cb   @QQ8,ra                    ; CMP QQ8           ; If our fuel reserves are less than the distance to the
     5C84 0F2F     
19804 5C86 1763  14        jnc  TT147                      ; BCC TT147         ; selected system, then we don't have enough fuel for
19805                                                                          ; this jump, so jump to TT147 to print "RANGE?" and
19806                                                                          ; return from the subroutine using a tail call
19807               
19808 5C88 0200  20        li   ra,('-')*256               ; LDA #'-'          ; Print a hyphen
     5C8A 2D00     
19809 5C8C 0206  20        li   rtmp,TT27                  ; JSR TT27
     5C8E A6E8     
19810 5C90 06A0  32        bl   @jsr                       ;
     5C92 FF10     
19811               
19812 5C94 0206  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print the name of the selected system
     5C96 A5C4     
19813 5C98 06A0  32        bl   @jsr                       ;
     5C9A FF10     
19814               
19815                                                                          ; Fall through into wW to start the hyperspace countdown
19816               
19817               * ******************************************************************************
19818               *
19819               * Name: wW
19820               * Type: Subroutine
19821               * Category: Flight
19822               * Summary: Start a hyperspace countdown
19823               *
19824               * ------------------------------------------------------------------------------
19825               *
19826               * Start the hyperspace countdown (for both inter-system hyperspace and the
19827               * galactic hyperdrive).
19828               *
19829               * ******************************************************************************
19830               
19831               wW:
19832 5C9C 0200  20        li   ra,>0f*256                 ; LDA #15           ; The hyperspace countdown starts from 15, so set A to
     5C9E 0F00     
19833                                                                          ; 15 so we can set the two hyperspace counters
19834               
19835 5CA0 D800  30        movb ra,@QQ22+1                 ; STA QQ22+1        ; Set the number in QQ22+1 to A, which is the number
     5CA2 002F     
19836                                                                          ; that's shown on-screen during the hyperspace countdown
19837               
19838 5CA4 D800  30        movb ra,@QQ22                   ; STA QQ22          ; Set the number in QQ22 to 15, which is the internal
     5CA6 002E     
19839                                                                          ; counter that counts down by 1 each iteration of the
19840                                                                          ; main game loop, and each time it reaches zero, the
19841                                                                          ; on-screen counter gets decremented, and QQ22 gets set
19842                                                                          ; to 5, so setting QQ22 to 15 here makes the first tick
19843                                                                          ; of the hyperspace counter longer than subsequent ticks
19844               
19845 5CA8 D040  18        movb ra,rx                      ; TAX               ; Print the 8-bit number in X (i.e. 15) at text location
19846 5CAA 0460  28        b    @ee3_                      ; JMP ee3           ; (0, 1), padded to 5 digits, so it appears in the top
     5CAC 5D36     
19847                                                                          ; left corner of the screen, and return from the
19848                                                                          ; subroutine using a tail call
19849               
19850               * .hy5                   \ This instruction and the hy5 label are commented out
19851               * RTS                    \ in the original - they can actually be found at the
19852                                                                          ; end of the jmp routine below, so perhaps this is where
19853                                                                          ; they were originally, but the authors realised they
19854                                                                          ; could save a byte by using a tail call instead of an
19855                                                                          ; RTS?
19856               
19857               * ******************************************************************************
19858               *
19859               * Name: Ghy
19860               * Type: Subroutine
19861               * Category: Flight
19862               * Summary: Perform a galactic hyperspace jump
19863               * Deep dive: Twisting the system seeds
19864               * Galaxy and system seeds
19865               *
19866               * ------------------------------------------------------------------------------
19867               *
19868               * Engage the galactic hyperdrive. Called from the hyp routine above if CTRL-H is
19869               * being pressed.
19870               *
19871               * This routine also updates the galaxy seeds to point to the next galaxy. Using
19872               * a galactic hyperdrive rotates each seed byte to the left, rolling each byte
19873               * left within itself like this:
19874               *
19875               * 01234567 -> 12345670
19876               *
19877               * to get the seeds for the next galaxy. So after 8 galactic jumps, the seeds
19878               * roll round to those of the first galaxy again.
19879               *
19880               * We always arrive in a new galaxy at galactic coordinates (96, 96), and then
19881               * find the nearest system and set that as our location.
19882               *
19883               * ------------------------------------------------------------------------------
19884               *
19885               * Other entry points:
19886               *
19887               * zZ+1                Contains an RTS
19888               *
19889               * ******************************************************************************
19890               
19891               Ghy:
19920               
19921 5CAE D060  30        movb @GHYP,rx                   ; LDX GHYP          ; Fetch GHYP, which tells us whether we own a galactic
     5CB0 032D     
19922 5CB2 133F  14        jeq  hy5_                       ; BEQ hy5           ; hyperdrive, and if it is zero, which means we don't,
19923                                                                          ; return from the subroutine (as hy5 contains an RTS)
19924               
19925 5CB4 B044  18        ab   rone,rx                    ; INX               ; We own a galactic hyperdrive, so X is &FF, so this
19926                                                                          ; instruction sets X = 0
19927               
19934               
19935 5CB6 D801  30        movb rx,@GHYP                   ; STX GHYP          ; The galactic hyperdrive is a one-use item, so set GHYP
     5CB8 032D     
19936                                                                          ; to 0 so we no longer have one fitted
19937               
19938 5CBA D801  30        movb rx,@FIST                   ; STX FIST          ; Changing galaxy also clears our criminal record, so
     5CBC 0334     
19939                                                                          ; set our legal status in FIST to 0 ("clean")
19940               
19941 5CBE 0206  20        li   rtmp,wW                    ; JSR wW            ; Call wW to start the hyperspace countdown
     5CC0 5C9C     
19942 5CC2 06A0  32        bl   @jsr                       ;
     5CC4 FF10     
19943               
19944 5CC6 0201  20        li   rx,>05*256                 ; LDX #5            ; To move galaxy, we rotate the galaxy's seeds left, so
     5CC8 0500     
19945                                                                          ; set a counter in X for the 6 seed bytes
19946               
19947 5CCA B004  18        ab   rone,ra                    ; INC GCNT          ; Increment the current galaxy number in GCNT
19948               
19949 5CCC D020  30        movb @GCNT,ra                   ; LDA GCNT          ; Set GCNT = GCNT mod 8, so we jump from galaxy 7 back
     5CCE 030F     
19950 5CD0 0240  22        andi ra,>07*256                 ; AND #7            ; to galaxy 0 (shown in-game as going from galaxy 8 back
     5CD2 0700     
19951 5CD4 D800  30        movb ra,@GCNT                   ; STA GCNT          ; to the starting point in galaxy 1)
     5CD6 030F     
19952               
19953               G1:
19954 5CD8 D021  34        movb @QQ21(rx),ra               ; LDA QQ21,X        ; Load the X-th seed byte into A
     5CDA 0303     
19955               
19956                      .asla                           ; ASL A             ; Set the C flag to bit 7 of the seed
     **** ****     > ASLA
0001 5CDC 0240  22        andi ra,>ff00
     5CDE FF00     
0002 5CE0 0A10  18        sla  ra,1
                   < elite.a99
19957               
19958 5CE2 0208  20        li   rarg1,QQ21                 ; ROL QQ21,X        ; Rotate the seed in memory, which will add bit 7 back
     5CE4 0303     
19959 5CE6 06A0  32        bl   @rol                       ;
     5CE8 FF36     
19960                                                                          ; in as bit 0, so this rolls the seed around on itself
19961               
19962 5CEA 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19963               
19964 5CEC 15F5  14        jgt  G1                         ; BPL G1            ; Loop back for the next seed byte, until we have
19965                                                                          ; rotated them all
19966               
19967               * JSR DORND              \ This instruction is commented out in the original
19968                                                                          ; source, and would set A and X to random numbers, so
19969                                                                          ; perhaps the original plan was to arrive in each new
19970                                                                          ; galaxy in a random place?
19971               
19972               zZ_:
19973 5CEE 0200  20        li   ra,>60*256                 ; LDA #96           ; Set (QQ9, QQ10) to (96, 96), which is where we always
     5CF0 6000     
19974 5CF2 D800  30        movb ra,@QQ9                    ; STA QQ9           ; arrive in a new galaxy (the selected system will be
     5CF4 0F31     
19975 5CF6 D800  30        movb ra,@QQ10                   ; STA QQ10          ; set to the nearest actual system later on)
     5CF8 0F32     
19976               
19977 5CFA 0206  20        li   rtmp,TT110                 ; JSR TT110         ; Call TT110 to show the front space view
     5CFC A10A     
19978 5CFE 06A0  32        bl   @jsr                       ;
     5D00 FF10     
19979               
19981               
19982 5D02 0206  20        li   rtmp,TT111                 ; JSR TT111         ; Call TT111 to set the current system to the nearest
     5D04 5AB8     
19983 5D06 06A0  32        bl   @jsr                       ;
     5D08 FF10     
19984                                                                          ; system to (QQ9, QQ10), and put the seeds of the
19985                                                                          ; nearest system into QQ15 to QQ15+5
19986                                                                          ;
19987                                                                          ; This call fixes a bug in the early cassette versions,
19988                                                                          ; where the galactic hyperdrive will take us to
19989                                                                          ; coordinates (96, 96) in the new galaxy, even if there
19990                                                                          ; isn't actually a system there, so if we jump when we
19991                                                                          ; are low on fuel, it is possible to get stuck in the
19992                                                                          ; middle of nowhere when changing galaxy
19993                                                                          ;
19994                                                                          ; This call sets the current system correctly, so we
19995                                                                          ; always arrive at the nearest system to (96, 96)
19996               
19998               
20000               
20001 5D0A 0201  20        li   rx,>00*256                 ; LDX #0            ; Set the distance to the selected system in QQ8(1 0)
     5D0C 0000     
20002 5D0E D801  30        movb rx,@QQ8                    ; STX QQ8           ; to 0
     5D10 0F2F     
20003 5D12 D801  30        movb rx,@QQ8+1                  ; STX QQ8+1
     5D14 0F30     
20004               
20006               
20007 5D16 0200  20        li   ra,>74*256                 ; LDA #116          ; Print recursive token 116 ("GALACTIC HYPERSPACE")
     5D18 7400     
20008 5D1A 0206  20        li   rtmp,MESS                  ; JSR MESS          ; as an in-flight message
     5D1C CE5E     
20009 5D1E 06A0  32        bl   @jsr                       ;
     5D20 FF10     
20010               
20011                                                                          ; Fall through into jmp to set the system to the
20012                                                                          ; current system and return from the subroutine there
20013               
20014               * ******************************************************************************
20015               *
20016               * Name: jmp
20017               * Type: Subroutine
20018               * Category: Universe
20019               * Summary: Set the current system to the selected system
20020               *
20021               * ------------------------------------------------------------------------------
20022               *
20023               * Returns:
20024               *
20025               * (QQ0, QQ1)          The galactic coordinates of the new system
20026               *
20027               * ------------------------------------------------------------------------------
20028               *
20029               * Other entry points:
20030               *
20031               * hy5                 Contains an RTS
20032               *
20033               * ******************************************************************************
20034               
20035               jmp_:
20036 5D22 D020  30        movb @QQ9,ra                    ; LDA QQ9           ; Set the current system's galactic x-coordinate to the
     5D24 0F31     
20037 5D26 D800  30        movb ra,@QQ0                    ; STA QQ0           ; x-coordinate of the selected system
     5D28 0301     
20038               
20039 5D2A D020  30        movb @QQ10,ra                   ; LDA QQ10          ; Set the current system's galactic y-coordinate to the
     5D2C 0F32     
20040 5D2E D800  30        movb ra,@QQ1                    ; STA QQ1           ; y-coordinate of the selected system
     5D30 0302     
20041               
20042               hy5_:
20043 5D32 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5D34 FF1C     
20044               
20045               * ******************************************************************************
20046               *
20047               * Name: ee3
20048               * Type: Subroutine
20049               * Category: Flight
20050               * Summary: Print the hyperspace countdown in the top-left of the screen
20051               *
20052               * ------------------------------------------------------------------------------
20053               *
20054               * Print the 8-bit number in X at text location (0, 1). Print the number to
20055               * 5 digits, left-padding with spaces for numbers with fewer than 3 digits (so
20056               * numbers < 10000 are right-aligned), with no decimal point.
20057               *
20058               * ------------------------------------------------------------------------------
20059               *
20060               * Arguments:
20061               *
20062               * X                   The number to print
20063               *
20064               * ******************************************************************************
20065               
20066               ee3_:
20067 5D36 0202  20        li   ry,>01*256                 ; LDY #1            ; Move the text cursor to row 1
     5D38 0100     
20068 5D3A D802  30        movb ry,@YC                     ; STY YC
     5D3C 002D     
20069               
20070 5D3E 7084  18        sb   rone,ry                    ; DEY               ; Decrement Y to 0 for the high byte in pr6
20071               
20072 5D40 D802  30        movb ry,@XC                     ; STY XC            ; Move the text cursor to column 0
     5D42 002C     
20073               
20074                                                                          ; Fall through into pr6 to print X to 5 digits, as the
20075                                                                          ; high byte in Y is 0
20076               
20077               * ******************************************************************************
20078               *
20079               * Name: pr6
20080               * Type: Subroutine
20081               * Category: Text
20082               * Summary: Print 16-bit number, left-padded to 5 digits, no point
20083               *
20084               * ------------------------------------------------------------------------------
20085               *
20086               * Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
20087               * numbers with fewer than 3 digits (so numbers < 10000 are right-aligned),
20088               * with no decimal point.
20089               *
20090               * ------------------------------------------------------------------------------
20091               *
20092               * Arguments:
20093               *
20094               * X                   The low byte of the number to print
20095               *
20096               * Y                   The high byte of the number to print
20097               *
20098               * ******************************************************************************
20099               
20100               pr6_:
20101                      .clc                            ; CLC               ; Do not display a decimal point when printing
     **** ****     > CLC
0001 5D44 0A13  18        sla  rzero,1
                   < elite.a99
20102               
20103                                                                          ; Fall through into pr5 to print X to 5 digits
20104               
20105               * ******************************************************************************
20106               *
20107               * Name: pr5
20108               * Type: Subroutine
20109               * Category: Text
20110               * Summary: Print a 16-bit number, left-padded to 5 digits, and optional point
20111               *
20112               * ------------------------------------------------------------------------------
20113               *
20114               * Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
20115               * numbers with fewer than 3 digits (so numbers < 10000 are right-aligned).
20116               * Optionally include a decimal point.
20117               *
20118               * ------------------------------------------------------------------------------
20119               *
20120               * Arguments:
20121               *
20122               * X                   The low byte of the number to print
20123               *
20124               * Y                   The high byte of the number to print
20125               *
20126               * C flag              If set, include a decimal point
20127               *
20128               * ******************************************************************************
20129               
20130               pr5_:
20131 5D46 0200  20        li   ra,>05*256                 ; LDA #5            ; Set the number of digits to print to 5
     5D48 0500     
20132               
20133 5D4A 0460  28        b    @TT11                      ; JMP TT11          ; Call TT11 to print (Y X) to 5 digits and return from
     5D4C 2FB4     
20134                                                                          ; the subroutine using a tail call
20135               
20136               * ******************************************************************************
20137               *
20138               * Name: TT147
20139               * Type: Subroutine
20140               * Category: Flight
20141               * Summary: Print an error when a system is out of hyperspace range
20142               *
20143               * ------------------------------------------------------------------------------
20144               *
20145               * Print "RANGE?" for when the hyperspace distance is too far
20146               *
20147               * ******************************************************************************
20148               
20149               TT147:
20150 5D4E 0200  20        li   ra,>ca*256                 ; LDA #202          ; Load A with token 42 ("RANGE") and fall through into
     5D50 CA00     
20151                                                                          ; prq to print it, followed by a question mark
20152               
20153               * ******************************************************************************
20154               *
20155               * Name: prq
20156               * Type: Subroutine
20157               * Category: Text
20158               * Summary: Print a text token followed by a question mark
20159               *
20160               * ------------------------------------------------------------------------------
20161               *
20162               * Arguments:
20163               *
20164               * A                   The text token to be printed
20165               *
20166               * ------------------------------------------------------------------------------
20167               *
20168               * Other entry points:
20169               *
20170               * prq+3               Print a question mark
20171               *
20172               * ******************************************************************************
20173               
20174               prq_:
20175 5D52 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     5D54 A6E8     
20176 5D56 06A0  32        bl   @jsr                       ;
     5D58 FF10     
20177               
20178 5D5A 0200  20        li   ra,('?')*256               ; LDA #'?'          ; Print a question mark and return from the
     5D5C 3F00     
20179 5D5E 0460  28        b    @TT27                      ; JMP TT27          ; subroutine using a tail call
     5D60 A6E8     
20180               
20181               * ******************************************************************************
20182               *
20183               * Name: TT151
20184               * Type: Subroutine
20185               * Category: Market
20186               * Summary: Print the name, price and availability of a market item
20187               * Deep dive: Market item prices and availability
20188               * Galaxy and system seeds
20189               *
20190               * ------------------------------------------------------------------------------
20191               *
20192               * Arguments:
20193               *
20194               * A                   The number of the market item to print, 0-16 (see QQ23
20195               * for details of item numbers)
20196               *
20197               * ------------------------------------------------------------------------------
20198               *
20199               * Returns:
20200               *
20201               * QQ19+1              Byte #1 from the market prices table for this item
20202               *
20203               * QQ24                The item's price / 4
20204               *
20205               * QQ25                The item's availability
20206               *
20207               * ******************************************************************************
20208               
20209               TT151:
20210                      .pha                            ; PHA               ; Store the item number on the stack and in QQ19+4
     **** ****     > PHA
0001 5D62 D680  30        movb ra,*rsp
0002 5D64 060A  14        dec  rsp
                   < elite.a99
20211 5D66 D800  30        movb ra,@QQ19+4                 ; STA QQ19+4
     5D68 0083     
20212               
20213                      .asla                           ; ASL A             ; Store the item number * 4 in QQ19, so this will act as
     **** ****     > ASLA
0001 5D6A 0240  22        andi ra,>ff00
     5D6C FF00     
0002 5D6E 0A10  18        sla  ra,1
                   < elite.a99
20214                      .asla                           ; ASL A             ; an index into the market prices table at QQ23 for this
     **** ****     > ASLA
0001 5D70 0240  22        andi ra,>ff00
     5D72 FF00     
0002 5D74 0A10  18        sla  ra,1
                   < elite.a99
20215 5D76 D800  30        movb ra,@QQ19                   ; STA QQ19          ; item (as there are four bytes per item in the table)
     5D78 007F     
20216               
20217 5D7A 0200  20        li   ra,>01*256                 ; LDA #1            ; Move the text cursor to column 1, for the item's name
     5D7C 0100     
20218 5D7E D800  30        movb ra,@XC                     ; STA XC
     5D80 002C     
20219               
20220                      .pla                            ; PLA               ; Restore the item number
     **** ****     > PLA
0001 5D82 058A  14        inc  rsp
0002 5D84 D01A  26        movb *rsp,ra
                   < elite.a99
20221               
20222                      .adi (>d0*256)                  ; ADC #208          ; Print recursive token 48 + A, which will be in the
     **** ****     > ADI
0001 5D86 1701  14        jnc  !
0002 5D88 B004  18        ab   rone,ra
0003               !:
0004 5D8A 0220  22        ai   ra,(>D0*256)
     5D8C D000     
                   < elite.a99
20223 5D8E 0206  20        li   rtmp,TT27                  ; JSR TT27          ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     5D90 A6E8     
20224 5D92 06A0  32        bl   @jsr                       ;
     5D94 FF10     
20225                                                                          ; prints the item's name
20226               
20227 5D96 0200  20        li   ra,>0e*256                 ; LDA #14           ; Move the text cursor to column 14, for the price
     5D98 0E00     
20228 5D9A D800  30        movb ra,@XC                     ; STA XC
     5D9C 002C     
20229               
20230 5D9E D060  30        movb @QQ19,rx                   ; LDX QQ19          ; Fetch byte #1 from the market prices table (units and
     5DA0 007F     
20231 5DA2 D021  34        movb @QQ23+1(rx),ra             ; LDA QQ23+1,X      ; economic_factor) for this item and store in QQ19+1
     5DA4 CF2F     
20232 5DA6 D800  30        movb ra,@QQ19+1                 ; STA QQ19+1
     5DA8 0080     
20233               
20234 5DAA D020  30        movb @QQ26,ra                   ; LDA QQ26          ; Fetch the random number for this system visit and
     5DAC 0346     
20235                      .and @QQ23+3(rx)                ; AND QQ23+3,X      ; AND with byte #3 from the market prices table (mask)
     **** ****     > AND
0001 5DAE D1A1  34        movb @QQ23+3(RX),rtmp
     5DB0 CF31     
0002 5DB2 0546  14        inv  rtmp
0003 5DB4 5006  18        szcb rtmp,ra
                   < elite.a99
20236                                                                          ; to give:
20237                                                                          ;
20238                                                                          ; A = random AND mask
20239               
20240                      .clc                            ; CLC               ; Add byte #0 from the market prices table (base_price),
     **** ****     > CLC
0001 5DB6 0A13  18        sla  rzero,1
                   < elite.a99
20241                      .adc @QQ23(rx),ra               ; ADC QQ23,X        ; so we now have:
     **** ****     > ADC
0001 5DB8 1701  14        jnc  !
0002 5DBA B004  18        ab   rone,ra
0003               !:
0004 5DBC B021  34        ab   @QQ23(RX),ra
     5DBE CF2E     
                   < elite.a99
20242 5DC0 D800  30        movb ra,@QQ24                   ; STA QQ24          ;
     5DC2 0F18     
20243                                                                          ; A = base_price + (random AND mask)
20244               
20245 5DC4 0206  20        li   rtmp,TT152                 ; JSR TT152         ; Call TT152 to print the item's unit ("t", "kg" or
     5DC6 5E4C     
20246 5DC8 06A0  32        bl   @jsr                       ;
     5DCA FF10     
20247                                                                          ; "g"), padded to a width of two characters
20248               
20249 5DCC 0206  20        li   rtmp,var_                  ; JSR var           ; Call var to set QQ19+3 = economy * |economic_factor|
     5DCE 5EF6     
20250 5DD0 06A0  32        bl   @jsr                       ;
     5DD2 FF10     
20251                                                                          ; (and set the availability of alien items to 0)
20252               
20253 5DD4 D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Fetch the byte #1 that we stored above and jump to
     5DD6 0080     
20254 5DD8 1108  14        jlt  TT155                      ; BMI TT155         ; TT155 if it is negative (i.e. if the economic_factor
20255                                                                          ; is negative)
20256               
20257 5DDA D020  30        movb @QQ24,ra                   ; LDA QQ24          ; Set A = QQ24 + QQ19+3
     5DDC 0F18     
20258                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ;
     **** ****     > ADC
0001 5DDE 1701  14        jnc  !
0002 5DE0 B004  18        ab   rone,ra
0003               !:
0004 5DE2 B020  30        ab   @QQ19+3,ra
     5DE4 0082     
                   < elite.a99
20259                                                                          ; = base_price + (random AND mask)
20260                                                                          ; + (economy * |economic_factor|)
20261                                                                          ;
20262                                                                          ; which is the result we want, as the economic_factor
20263                                                                          ; is positive
20264               
20265 5DE6 0460  28        b    @TT156                     ; JMP TT156         ; Jump to TT156 to multiply the result by 4
     5DE8 5DF8     
20266               
20267               TT155:
20268 5DEA D020  30        movb @QQ24,ra                   ; LDA QQ24          ; Set A = QQ24 - QQ19+3
     5DEC 0F18     
20269                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 5DEE 0A15  18        sla  rmone,1
                   < elite.a99
20270                      .sbc @QQ19+3,ra                 ; SBC QQ19+3        ; = base_price + (random AND mask)
     **** ****     > SBC
0001 5DF0 1801  14        joc  !
0002 5DF2 7004  18        sb   rone,ra
0003               !:
0004 5DF4 7020  30        sb   @QQ19+3,ra
     5DF6 0082     
                   < elite.a99
20271                                                                          ; - (economy * |economic_factor|)
20272                                                                          ;
20273                                                                          ; which is the result we want, as economic_factor
20274                                                                          ; is negative
20275               
20276               TT156:
20277 5DF8 D800  30        movb ra,@QQ24                   ; STA QQ24          ; Store the result in QQ24 and P
     5DFA 0F18     
20278 5DFC D800  30        movb ra,@P                      ; STA P
     5DFE 001B     
20279               
20280 5E00 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 and call GC2 to calculate (Y X) = (A P) * 4,
     5E02 0000     
20281 5E04 0206  20        li   rtmp,GC2                   ; JSR GC2           ; which is the same as (Y X) = P * 4 because A = 0
     5E06 A20A     
20282 5E08 06A0  32        bl   @jsr                       ;
     5E0A FF10     
20283               
20284                      .sec                            ; SEC               ; We now have our final price, * 10, so we can call pr5
     **** ****     > SEC
0001 5E0C 0A15  18        sla  rmone,1
                   < elite.a99
20285 5E0E 0206  20        li   rtmp,pr5_                  ; JSR pr5           ; to print (Y X) to 5 digits, including a decimal
     5E10 5D46     
20286 5E12 06A0  32        bl   @jsr                       ;
     5E14 FF10     
20287                                                                          ; point, as the C flag is set
20288               
20289 5E16 D0A0  30        movb @QQ19+4,ry                 ; LDY QQ19+4        ; We now move on to availability, so fetch the market
     5E18 0083     
20290                                                                          ; item number that we stored in QQ19+4 at the start
20291               
20292 5E1A 0200  20        li   ra,>05*256                 ; LDA #5            ; Set A to 5 so we can print the availability to 5
     5E1C 0500     
20293                                                                          ; digits (right-padded with spaces)
20294               
20295 5E1E D062  34        movb @AVL(ry),rx                ; LDX AVL,Y         ; Set X to the item's availability, which is given in
     5E20 0335     
20296                                                                          ; the AVL table
20297               
20298 5E22 D801  30        movb rx,@QQ25                   ; STX QQ25          ; Store the availability in QQ25
     5E24 0F19     
20299               
20300                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 5E26 0A13  18        sla  rzero,1
                   < elite.a99
20301               
20302 5E28 1306  14        jeq  TT172                      ; BEQ TT172         ; If none are available, jump to TT172 to print a tab
20303                                                                          ; and a "-"
20304               
20305 5E2A 0206  20        li   rtmp,pr2_+2                ; JSR pr2+2         ; Otherwise print the 8-bit number in X to 5 digits,
     5E2C 2FAE     
20306 5E2E 06A0  32        bl   @jsr                       ;
     5E30 FF10     
20307                                                                          ; right-aligned with spaces. This works because we set
20308                                                                          ; A to 5 above, and we jump into the pr2 routine just
20309                                                                          ; after the first instruction, which would normally
20310                                                                          ; set the number of digits to 3
20311               
20312 5E32 0460  28        b    @TT152                     ; JMP TT152         ; Print the unit ("t", "kg" or "g") for the market item,
     5E34 5E4C     
20313                                                                          ; with a following space if required to make it two
20314                                                                          ; characters long, and return from the subroutine using
20315                                                                          ; a tail call
20316               
20317               TT172:
20318 5E36 D020  30        movb @XC,ra                     ; LDA XC            ; Move the text cursor in XC to the right by 4 columns,
     5E38 002C     
20319                      .adi (>04*256)                  ; ADC #4            ; so the cursor is where the last digit would be if we
     **** ****     > ADI
0001 5E3A 1701  14        jnc  !
0002 5E3C B004  18        ab   rone,ra
0003               !:
0004 5E3E 0220  22        ai   ra,(>04*256)
     5E40 0400     
                   < elite.a99
20320 5E42 D800  30        movb ra,@XC                     ; STA XC            ; were printing a 5-digit availability number
     5E44 002C     
20321               
20322 5E46 0200  20        li   ra,('-')*256               ; LDA #'-'          ; Print a "-" character by jumping to TT162+2, which
     5E48 2D00     
20323 5E4A 160D  14        jne  TT162+2                    ; BNE TT162+2       ; contains JMP TT27 (this BNE is effectively a JMP as A
20324                                                                          ; will never be zero), and return from the subroutine
20325                                                                          ; using a tail call
20326               
20327               * ******************************************************************************
20328               *
20329               * Name: TT152
20330               * Type: Subroutine
20331               * Category: Market
20332               * Summary: Print the unit ("t", "kg" or "g") for a market item
20333               *
20334               * ------------------------------------------------------------------------------
20335               *
20336               * Print the unit ("t", "kg" or "g") for the market item whose byte #1 from the
20337               * market prices table is in QQ19+1, right-padded with spaces to a width of two
20338               * characters (so that's "t ", "kg" or "g ").
20339               *
20340               * ******************************************************************************
20341               
20342               TT152:
20343 5E4C D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Fetch the economic_factor from QQ19+1
     5E4E 0080     
20344               
20345 5E50 0240  22        andi ra,>60*256                 ; AND #96           ; If bits 5 and 6 are both clear, jump to TT160 to
     5E52 6000     
20346 5E54 130B  14        jeq  TT160                      ; BEQ TT160         ; print "t" for tonne, followed by a space, and return
20347                                                                          ; from the subroutine using a tail call
20348               
20349 5E56 0280  22        ci   ra,>20*256                 ; CMP #32           ; If bit 5 is set, jump to TT161 to print "kg" for
     5E58 2000     
20350 5E5A 130F  14        jeq  TT161                      ; BEQ TT161         ; kilograms, and return from the subroutine using a tail
20351                                                                          ; call
20352               
20353 5E5C 0206  20        li   rtmp,TT16a                 ; JSR TT16a         ; Otherwise call TT16a to print "g" for grams, and fall
     5E5E 5E86     
20354 5E60 06A0  32        bl   @jsr                       ;
     5E62 FF10     
20355                                                                          ; through into TT162 to print a space and return from
20356                                                                          ; the subroutine
20357               
20358               * ******************************************************************************
20359               *
20360               * Name: TT162
20361               * Type: Subroutine
20362               * Category: Text
20363               * Summary: Print a space
20364               *
20365               * ------------------------------------------------------------------------------
20366               *
20367               * Other entry points:
20368               *
20369               * TT162+2             Jump to TT27 to print the text token in A
20370               *
20371               * ******************************************************************************
20372               
20373               TT162:
20374 5E64 0200  20        li   ra,(' ')*256               ; LDA #' '          ; Load a space character into A
     5E66 2000     
20375               
20376 5E68 0460  28        b    @TT27                      ; JMP TT27          ; Print the text token in A and return from the
     5E6A A6E8     
20377                                                                          ; subroutine using a tail call
20378               
20379               * ******************************************************************************
20380               *
20381               * Name: TT160
20382               * Type: Subroutine
20383               * Category: Market
20384               * Summary: Print "t" (for tonne) and a space
20385               *
20386               * ******************************************************************************
20387               
20388               TT160:
20389 5E6C 0200  20        li   ra,('t')*256               ; LDA #'t'          ; Load a "t" character into A
     5E6E 7400     
20390               
20391 5E70 0206  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character, using TT216 so that it doesn't
     5E72 3172     
20392 5E74 06A0  32        bl   @jsr                       ;
     5E76 FF10     
20393                                                                          ; change the character case
20394               
20395 5E78 17F5  14        jnc  TT162                      ; BCC TT162         ; Jump to TT162 to print a space and return from the
20396                                                                          ; subroutine using a tail call (this BCC is effectively
20397                                                                          ; a JMP as the C flag is cleared by TT26)
20398               
20399               * ******************************************************************************
20400               *
20401               * Name: TT161
20402               * Type: Subroutine
20403               * Category: Market
20404               * Summary: Print "kg" (for kilograms)
20405               *
20406               * ******************************************************************************
20407               
20408               TT161:
20409 5E7A 0200  20        li   ra,('k')*256               ; LDA #'k'          ; Load a "k" character into A
     5E7C 6B00     
20410               
20411 5E7E 0206  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character, using TT216 so that it doesn't
     5E80 3172     
20412 5E82 06A0  32        bl   @jsr                       ;
     5E84 FF10     
20413                                                                          ; change the character case, and fall through into
20414                                                                          ; TT16a to print a "g" character
20415               
20416               * ******************************************************************************
20417               *
20418               * Name: TT16a
20419               * Type: Subroutine
20420               * Category: Market
20421               * Summary: Print "g" (for grams)
20422               *
20423               * ******************************************************************************
20424               
20425               TT16a:
20426 5E86 0200  20        li   ra,('g')*256               ; LDA #'g'          ; Load a "g" character into A
     5E88 6700     
20427               
20428 5E8A 0460  28        b    @TT26                      ; JMP TT26          ; Print the character, using TT216 so that it doesn't
     5E8C 3172     
20429                                                                          ; change the character case, and return from the
20430                                                                          ; subroutine using a tail call
20431               
20432               * ******************************************************************************
20433               *
20434               * Name: TT163
20435               * Type: Subroutine
20436               * Category: Market
20437               * Summary: Print the headers for the table of market prices
20438               *
20439               * ------------------------------------------------------------------------------
20440               *
20441               * Print the column headers for the prices table in the Buy Cargo and Market
20442               * Price screens.
20443               *
20444               * ******************************************************************************
20445               
20446               TT163:
20447 5E8E 0200  20        li   ra,>11*256                 ; LDA #17           ; Move the text cursor in XC to column 17
     5E90 1100     
20448 5E92 D800  30        movb ra,@XC                     ; STA XC
     5E94 002C     
20449               
20450 5E96 0200  20        li   ra,>ff*256                 ; LDA #255          ; Print recursive token 95 token ("UNIT  QUANTITY
     5E98 FF00     
20451 5E9A 16E5  14        jne  TT162+2                    ; BNE TT162+2       ; {crlf} PRODUCT   UNIT PRICE FOR SALE{crlf}{lf}") by
20452                                                                          ; jumping to TT162+2, which contains JMP TT27 (this BNE
20453                                                                          ; is effectively a JMP as A will never be zero), and
20454                                                                          ; return from the subroutine using a tail call
20455               
20456               * ******************************************************************************
20457               *
20458               * Name: TT167
20459               * Type: Subroutine
20460               * Category: Market
20461               * Summary: Show the Market Price screen (red key f7)
20462               *
20463               * ******************************************************************************
20464               
20465               TT167:
20466 5E9C 0200  20        li   ra,>10*256                 ; LDA #16           ; Clear the top part of the screen, draw a white border,
     5E9E 1000     
20467 5EA0 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 16 (Market
     5EA2 4B2A     
20468 5EA4 06A0  32        bl   @jsr                       ;
     5EA6 FF10     
20469                                                                          ; Price screen)
20470               
20471 5EA8 0200  20        li   ra,>05*256                 ; LDA #5            ; Move the text cursor to column 5
     5EAA 0500     
20472 5EAC D800  30        movb ra,@XC                     ; STA XC
     5EAE 002C     
20473               
20474 5EB0 0200  20        li   ra,>a7*256                 ; LDA #167          ; Print recursive token 7 ("{current system name} MARKET
     5EB2 A700     
20475 5EB4 0206  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; PRICES") and draw a horizontal line at pixel row 19
     5EB6 25B0     
20476 5EB8 06A0  32        bl   @jsr                       ;
     5EBA FF10     
20477                                                                          ; to box in the title
20478               
20479 5EBC 0200  20        li   ra,>03*256                 ; LDA #3            ; Move the text cursor to row 3
     5EBE 0300     
20480 5EC0 D800  30        movb ra,@YC                     ; STA YC
     5EC2 002D     
20481               
20482 5EC4 0206  20        li   rtmp,TT163                 ; JSR TT163         ; Print the column headers for the prices table
     5EC6 5E8E     
20483 5EC8 06A0  32        bl   @jsr                       ;
     5ECA FF10     
20484               
20485 5ECC 0200  20        li   ra,>00*256                 ; LDA #0            ; We're going to loop through all the available market
     5ECE 0000     
20486 5ED0 D800  30        movb ra,@QQ29                   ; STA QQ29          ; items, so we set up a counter in QQ29 to denote the
     5ED2 0F1B     
20487                                                                          ; current item and start it at 0
20488               
20489               TT168:
20490 5ED4 0201  20        li   rx,>80*256                 ; LDX #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     5ED6 8000     
20491 5ED8 D801  30        movb rx,@QQ17                   ; STX QQ17          ; next letter in capitals
     5EDA 007E     
20492               
20493 5EDC 0206  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to print the item name, market price and
     5EDE 5D62     
20494 5EE0 06A0  32        bl   @jsr                       ;
     5EE2 FF10     
20495                                                                          ; availability of the current item, and set QQ24 to the
20496                                                                          ; item's price / 4, QQ25 to the quantity available and
20497                                                                          ; QQ19+1 to byte #1 from the market prices table for
20498                                                                          ; this item
20499               
20500 5EE4 B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one row
20501               
20502 5EE6 B004  18        ab   rone,ra                    ; INC QQ29          ; Increment QQ29 to point to the next item
20503               
20504 5EE8 D020  30        movb @QQ29,ra                   ; LDA QQ29          ; If QQ29 >= 17 then jump to TT168 as we have done the
     5EEA 0F1B     
20505 5EEC 0280  22        ci   ra,>11*256                 ; CMP #17           ; last item
     5EEE 1100     
20506 5EF0 17F1  14        jnc  TT168                      ; BCC TT168
20507               
20508 5EF2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5EF4 FF1C     
20509               
20510               * ******************************************************************************
20511               *
20512               * Name: var
20513               * Type: Subroutine
20514               * Category: Market
20515               * Summary: Calculate QQ19+3 = economy * |economic_factor|
20516               *
20517               * ------------------------------------------------------------------------------
20518               *
20519               * Set QQ19+3 = economy * |economic_factor|, given byte #1 of the market prices
20520               * table for an item. Also sets the availability of alien items to 0.
20521               *
20522               * This routine forms part of the calculations for market item prices (TT151)
20523               * and availability (GVL).
20524               *
20525               * ------------------------------------------------------------------------------
20526               *
20527               * Arguments:
20528               *
20529               * QQ19+1              Byte #1 of the market prices table for this market item
20530               * (which contains the economic_factor in bits 0-5, and the
20531               * sign of the economic_factor in bit 7)
20532               *
20533               * ******************************************************************************
20534               
20535               var_:
20536 5EF6 D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Extract bits 0-5 from QQ19+1 into A, to get the
     5EF8 0080     
20537 5EFA 0240  22        andi ra,>1f*256                 ; AND #31           ; economic_factor without its sign, in other words:
     5EFC 1F00     
20538                                                                          ;
20539                                                                          ; A = |economic_factor|
20540               
20541 5EFE D0A0  30        movb @QQ28,ry                   ; LDY QQ28          ; Set Y to the economy byte of the current system
     5F00 0F1A     
20542               
20543 5F02 D800  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Store A in QQ19+2
     5F04 0081     
20544               
20545                      .clc                            ; CLC               ; Clear the C flag so we can do additions below
     **** ****     > CLC
0001 5F06 0A13  18        sla  rzero,1
                   < elite.a99
20546               
20547 5F08 0200  20        li   ra,>00*256                 ; LDA #0            ; Set AVL+16 (availability of alien items) to 0,
     5F0A 0000     
20548 5F0C D800  30        movb ra,@AVL+16                 ; STA AVL+16        ; setting A to 0 in the process
     5F0E 0345     
20549               
20550               TT153:
20551                                                                          ; We now do the multiplication by doing a series of
20552                                                                          ; additions in a loop, building the result in A. Each
20553                                                                          ; loop adds QQ19+2 (|economic_factor|) to A, and it
20554                                                                          ; loops the number of times given by the economy byte;
20555                                                                          ; in other words, because A starts at 0, this sets:
20556                                                                          ;
20557                                                                          ; A = economy * |economic_factor|
20558 5F10 7084  18        sb   rone,ry                    ; DEY               ; Decrement the economy in Y, exiting the loop when it
20559 5F12 1106  14        jlt  TT154                      ; BMI TT154         ; becomes negative
20560               
20561                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; Add QQ19+2 to A
     **** ****     > ADC
0001 5F14 1701  14        jnc  !
0002 5F16 B004  18        ab   rone,ra
0003               !:
0004 5F18 B020  30        ab   @QQ19+2,ra
     5F1A 0081     
                   < elite.a99
20562               
20563 5F1C 0460  28        b    @TT153                     ; JMP TT153         ; Loop back to TT153 to do another addition
     5F1E 5F10     
20564               
20565               TT154:
20566 5F20 D800  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; Store the result in QQ19+3
     5F22 0082     
20567               
20568 5F24 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5F26 FF1C     
20569               
20570               * ******************************************************************************
20571               *
20572               * Name: hyp1
20573               * Type: Subroutine
20574               * Category: Universe
20575               * Summary: Process a jump to the system closest to (QQ9, QQ10)
20576               *
20577               * ------------------------------------------------------------------------------
20578               *
20579               * Do a hyperspace jump to the system closest to galactic coordinates
20580               * (QQ9, QQ10), and set up the current system's state to those of the new system.
20581               *
20582               * ------------------------------------------------------------------------------
20583               *
20584               * Returns:
20585               *
20586               * (QQ0, QQ1)          The galactic coordinates of the new system
20587               *
20588               * QQ2 to QQ2+6        The seeds of the new system
20589               *
20590               * EV                  Set to 0
20591               *
20592               * QQ28                The new system's economy
20593               *
20594               * tek                 The new system's tech level
20595               *
20596               * gov                 The new system's government
20597               *
20598               * ------------------------------------------------------------------------------
20599               *
20600               * Other entry points:
20601               *
20602               * hyp1+3              Jump straight to the system at (QQ9, QQ10) without
20603               * first calculating which system is closest. We do this
20604               * if we already know that (QQ9, QQ10) points to a system
20605               *
20606               * ******************************************************************************
20607               
20608               hyp1_:
20609 5F28 0206  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     5F2A 5AB8     
20610 5F2C 06A0  32        bl   @jsr                       ;
     5F2E FF10     
20611                                                                          ; (QQ9, QQ10)
20612               
20613 5F30 0206  20        li   rtmp,jmp_                  ; JSR jmp           ; Set the current system to the selected system
     5F32 5D22     
20614 5F34 06A0  32        bl   @jsr                       ;
     5F36 FF10     
20615               
20616 5F38 0201  20        li   rx,>05*256                 ; LDX #5            ; We now want to copy the seeds for the selected system
     5F3A 0500     
20617                                                                          ; in QQ15 into QQ2, where we store the seeds for the
20618                                                                          ; current system, so set up a counter in X for copying
20619                                                                          ; 6 bytes (for three 16-bit seeds)
20620               
20621               TT112:
20622 5F3C D021  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy the X-th byte in QQ15 to the X-th byte in QQ2, to
     5F3E 0078     
20623 5F40 D840  38        movb ra,@QQ2(rx)                ; STA QQ2,X         ; update the selected system to the new one. Note that
     5F42 0F22     
20624                                                                          ; this approach has a minor bug associated with it: if
20625                                                                          ; your hyperspace counter hits 0 just as you're docking,
20626                                                                          ; then you will magically appear in the station in your
20627                                                                          ; hyperspace destination, without having to go to the
20628                                                                          ; effort of actually flying there. This bug was fixed in
20629                                                                          ; later versions by saving the destination seeds in a
20630                                                                          ; separate location called safehouse, and using those
20631                                                                          ; instead... but that isn't the case in this version
20632               
20633 5F44 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
20634               
20635 5F46 15FA  14        jgt  TT112                      ; BPL TT112         ; Loop back to TT112 if we still have more bytes to
20636                                                                          ; copy
20637               
20638 5F48 B044  18        ab   rone,rx                    ; INX               ; Set X = 0 (as we ended the above loop with X = &FF)
20639               
20640 5F4A D801  30        movb rx,@EV                     ; STX EV            ; Set EV, the extra vessels spawning counter, to 0, as
     5F4C 0D63     
20641                                                                          ; we are entering a new system with no extra vessels
20642                                                                          ; spawned
20643               
20644 5F4E D020  30        movb @QQ3,ra                    ; LDA QQ3           ; Set the current system's economy in QQ28 to the
     5F50 0F28     
20645 5F52 D800  30        movb ra,@QQ28                   ; STA QQ28          ; selected system's economy from QQ3
     5F54 0F1A     
20646               
20647 5F56 D020  30        movb @QQ5,ra                    ; LDA QQ5           ; Set the current system's tech level in tek to the
     5F58 0F2A     
20648 5F5A D800  30        movb ra,@tek_                   ; STA tek           ; selected system's economy from QQ5
     5F5C 0F1D     
20649               
20650 5F5E D020  30        movb @QQ4,ra                    ; LDA QQ4           ; Set the current system's government in gov to the
     5F60 0F29     
20651 5F62 D800  30        movb ra,@gov_                   ; STA gov           ; selected system's government from QQ4
     5F64 0F1C     
20652               
20653 5F66 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5F68 FF1C     
20654               
20655               * ******************************************************************************
20656               *
20657               * Name: GVL
20658               * Type: Subroutine
20659               * Category: Universe
20660               * Summary: Calculate the availability of market items
20661               * Deep dive: Market item prices and availability
20662               * Galaxy and system seeds
20663               *
20664               * ------------------------------------------------------------------------------
20665               *
20666               * Calculate the availability for each market item and store it in AVL. This is
20667               * called on arrival in a new system.
20668               *
20669               * ------------------------------------------------------------------------------
20670               *
20671               * Other entry points:
20672               *
20673               * hyR                 Contains an RTS
20674               *
20675               * ******************************************************************************
20676               
20677               GVL:
20678 5F6A 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     5F6C C07C     
20679 5F6E 06A0  32        bl   @jsr                       ;
     5F70 FF10     
20680               
20681 5F72 D800  30        movb ra,@QQ26                   ; STA QQ26          ; Set QQ26 to the random byte that's used in the market
     5F74 0346     
20682                                                                          ; calculations
20683               
20684 5F76 0201  20        li   rx,>00*256                 ; LDX #0            ; We are now going to loop through the market item
     5F78 0000     
20685 5F7A D801  30        movb rx,@XX4                    ; STX XX4           ; availability table in AVL, so set a counter in XX4
     5F7C 00A7     
20686                                                                          ; (and X) for the market item number, starting with 0
20687               
20688               hy9_:
20689 5F7E D021  34        movb @QQ23+1(rx),ra             ; LDA QQ23+1,X      ; Fetch byte #1 from the market prices table (units and
     5F80 CF2F     
20690 5F82 D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; economic_factor) for item number X and store it in
     5F84 0080     
20691                                                                          ; QQ19+1
20692               
20693 5F86 0206  20        li   rtmp,var_                  ; JSR var           ; Call var to set QQ19+3 = economy * |economic_factor|
     5F88 5EF6     
20694 5F8A 06A0  32        bl   @jsr                       ;
     5F8C FF10     
20695                                                                          ; (and set the availability of alien items to 0)
20696               
20697 5F8E D021  34        movb @QQ23+3(rx),ra             ; LDA QQ23+3,X      ; Fetch byte #3 from the market prices table (mask) and
     5F90 CF31     
20698                      .and @QQ26                      ; AND QQ26          ; AND with the random number for this system visit
     **** ****     > AND
0001 5F92 D1A0  30        movb @QQ26,rtmp
     5F94 0346     
0002 5F96 0546  14        inv  rtmp
0003 5F98 5006  18        szcb rtmp,ra
                   < elite.a99
20699                                                                          ; to give:
20700                                                                          ;
20701                                                                          ; A = random AND mask
20702               
20703                      .clc                            ; CLC               ; Add byte #2 from the market prices table
     **** ****     > CLC
0001 5F9A 0A13  18        sla  rzero,1
                   < elite.a99
20704                      .adc @QQ23+2(rx),ra             ; ADC QQ23+2,X      ; (base_quantity) so we now have:
     **** ****     > ADC
0001 5F9C 1701  14        jnc  !
0002 5F9E B004  18        ab   rone,ra
0003               !:
0004 5FA0 B021  34        ab   @QQ23+2(RX),ra
     5FA2 CF30     
                   < elite.a99
20705                                                                          ;
20706                                                                          ; A = base_quantity + (random AND mask)
20707               
20708 5FA4 D0A0  30        movb @QQ19+1,ry                 ; LDY QQ19+1        ; Fetch the byte #1 that we stored above and jump to
     5FA6 0080     
20709 5FA8 1107  14        jlt  TT157                      ; BMI TT157         ; TT157 if it is negative (i.e. if the economic_factor
20710                                                                          ; is negative)
20711               
20712                      .sec                            ; SEC               ; Set A = A - QQ19+3
     **** ****     > SEC
0001 5FAA 0A15  18        sla  rmone,1
                   < elite.a99
20713                      .sbc @QQ19+3,ra                 ; SBC QQ19+3        ;
     **** ****     > SBC
0001 5FAC 1801  14        joc  !
0002 5FAE 7004  18        sb   rone,ra
0003               !:
0004 5FB0 7020  30        sb   @QQ19+3,ra
     5FB2 0082     
                   < elite.a99
20714                                                                          ; = base_quantity + (random AND mask)
20715                                                                          ; - (economy * |economic_factor|)
20716                                                                          ;
20717                                                                          ; which is the result we want, as the economic_factor
20718                                                                          ; is positive
20719               
20720 5FB4 0460  28        b    @TT158                     ; JMP TT158         ; Jump to TT158 to skip TT157
     5FB6 5FC2     
20721               
20722               TT157:
20723                      .clc                            ; CLC               ; Set A = A + QQ19+3
     **** ****     > CLC
0001 5FB8 0A13  18        sla  rzero,1
                   < elite.a99
20724                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ;
     **** ****     > ADC
0001 5FBA 1701  14        jnc  !
0002 5FBC B004  18        ab   rone,ra
0003               !:
0004 5FBE B020  30        ab   @QQ19+3,ra
     5FC0 0082     
                   < elite.a99
20725                                                                          ; = base_quantity + (random AND mask)
20726                                                                          ; + (economy * |economic_factor|)
20727                                                                          ;
20728                                                                          ; which is the result we want, as the economic_factor
20729                                                                          ; is negative
20730               
20731               TT158:
20732 5FC2 1502  14        jgt  TT159                      ; BPL TT159         ; If A < 0, then set A = 0, so we don't have negative
20733 5FC4 0200  20        li   ra,>00*256                 ; LDA #0            ; availability
     5FC6 0000     
20734               
20735               TT159:
20736 5FC8 D0A0  30        movb @XX4,ry                    ; LDY XX4           ; Fetch the counter (the market item number) into Y
     5FCA 00A7     
20737               
20738 5FCC 0240  22        andi ra,>3f*256                 ; AND #%00111111    ; Take bits 0-5 of A, i.e. A mod 64, and store this as
     5FCE 3F00     
20739 5FD0 D880  38        movb ra,@AVL(ry)                ; STA AVL,Y         ; this item's availability in the Y=th byte of AVL, so
     5FD2 0335     
20740                                                                          ; each item has a maximum availability of 63t
20741               
20742 5FD4 B084  18        ab   rone,ry                    ; INY               ; Increment the counter into XX44, Y and A
20743 5FD6 D002  18        movb ry,ra                      ; TYA
20744 5FD8 D800  30        movb ra,@XX4                    ; STA XX4
     5FDA 00A7     
20745               
20746                      .asla                           ; ASL A             ; Set X = counter * 4, so that X points to the next
     **** ****     > ASLA
0001 5FDC 0240  22        andi ra,>ff00
     5FDE FF00     
0002 5FE0 0A10  18        sla  ra,1
                   < elite.a99
20747                      .asla                           ; ASL A             ; item's entry in the four-byte market prices table,
     **** ****     > ASLA
0001 5FE2 0240  22        andi ra,>ff00
     5FE4 FF00     
0002 5FE6 0A10  18        sla  ra,1
                   < elite.a99
20748 5FE8 D040  18        movb ra,rx                      ; TAX               ; ready for the next loop
20749               
20750 5FEA 0280  22        ci   ra,>3f*256                 ; CMP #63           ; If A < 63, jump back up to hy9 to set the availability
     5FEC 3F00     
20751 5FEE 17C7  14        jnc  hy9_                       ; BCC hy9           ; for the next market item
20752               
20753               hyR:
20754 5FF0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5FF2 FF1C     
20755               
20756               * ******************************************************************************
20757               *
20758               * Name: GTHG
20759               * Type: Subroutine
20760               * Category: Universe
20761               * Summary: Spawn a Thargoid ship and a Thargon companion
20762               * Deep dive: Fixing ship positions
20763               *
20764               * ******************************************************************************
20765               
20766                      aorg CODE_UPPER.                                    ; TI-99/4A upper RAM code
20767               
20768               GTHG:
20769 A000 0206  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK
     A002 C032     
20770 A004 06A0  32        bl   @jsr                       ;
     A006 FF10     
20771                                                                          ;
20772                                                                          ; Note that because Ze uses the value of X returned by
20773                                                                          ; DORND, and X contains the value of A returned by the
20774                                                                          ; previous call to DORND, this does not set the new ship
20775                                                                          ; to a totally random location. See the deep dive on
20776                                                                          ; "Fixing ship positions" for details
20777               
20778 A008 0200  20        li   ra,>ff*256                 ; LDA #%11111111    ; Set the AI flag in byte #32 so that the ship has AI,
     A00A FF00     
20779 A00C D800  30        movb ra,@INWK+32                ; STA INWK+32       ; is extremely and aggressively hostile, and has E.C.M.
     A00E 0073     
20780               
20781 A010 0200  20        li   ra,(THG)*256               ; LDA #THG          ; Call NWSHP to add a new Thargoid ship to our local
     A012 0600     
20782 A014 0206  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; bubble of universe
     A016 AF7A     
20783 A018 06A0  32        bl   @jsr                       ;
     A01A FF10     
20784               
20785 A01C 0200  20        li   ra,(TGL)*256               ; LDA #TGL          ; Call NWSHP to add a new Thargon ship to our local
     A01E 0C00     
20786 A020 0460  28        b    @NWSHP                     ; JMP NWSHP         ; bubble of universe, and return from the subroutine
     A022 AF7A     
20787                                                                          ; using a tail call
20788               
20789               * ******************************************************************************
20790               *
20791               * Name: MJP
20792               * Type: Subroutine
20793               * Category: Flight
20794               * Summary: Process a mis-jump into witchspace
20795               *
20796               * ------------------------------------------------------------------------------
20797               *
20798               * Process a mis-jump into witchspace (which happens very rarely). Witchspace has
20799               * a strange, almost dust-free aspect to it, and it is populated by hostile
20800               * Thargoids. Using our escape pod will be fatal, and our position on the
20801               * galactic chart is in-between systems. It is a scary place...
20802               *
20803               * There is a 0.78% chance that this routine is called from TT18 instead of doing
20804               * a normal hyperspace, or we can manually trigger a mis-jump by holding down
20805               * CTRL after first enabling the "author display" configuration option ("X") when
20806               * paused.
20807               *
20808               * ------------------------------------------------------------------------------
20809               *
20810               * Other entry points:
20811               *
20812               * ptg                 Called when the user manually forces a mis-jump
20813               *
20814               * ******************************************************************************
20815               
20816               ptg_:
20817                      .lsr @COK                       ; LSR COK           ; Set bit 0 of the competition flags in COK, so that the
     **** ****     > LSR
0001 A024 D1A0  30        movb @COK,rtmp
     A026 030E     
0002 A028 0916  18        srl  rtmp,1
0003 A02A D806  30        movb rtmp,@COK
     A02C 030E     
                   < elite.a99
20818                      .sec                            ; SEC               ; competition code will include the fact that we have
     **** ****     > SEC
0001 A02E 0A15  18        sla  rmone,1
                   < elite.a99
20819 A030 0208  20        li   rarg1,COK                  ; ROL COK           ; manually forced a mis-jump into witchspace
     A032 030E     
20820 A034 06A0  32        bl   @rol                       ;
     A036 FF36     
20821               
20822               MJP:
20823               * LDA #1                 \ This instruction is commented out in the original
20824                                                                          ; source - it is not required as a call to TT66-2 sets
20825                                                                          ; A to 1 for us. This is presumably an example of the
20826                                                                          ; authors saving a couple of bytes by calling TT66-2
20827                                                                          ; instead of TT66, while leaving the original LDA
20828                                                                          ; instruction in place
20829 A038 0206  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     A03A 4B28     
20830 A03C 06A0  32        bl   @jsr                       ;
     A03E FF10     
20831                                                                          ; and set the current view type in QQ11 to 1
20832               
20833 A040 0206  20        li   rtmp,LL164                 ; JSR LL164         ; Call LL164 to show the hyperspace tunnel and make the
     A042 3E3C     
20834 A044 06A0  32        bl   @jsr                       ;
     A046 FF10     
20835                                                                          ; hyperspace sound for a second time (as we already
20836                                                                          ; called LL164 in TT18)
20837               
20838 A048 0206  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces, as
     A04A BF32     
20839 A04C 06A0  32        bl   @jsr                       ;
     A04E FF10     
20840                                                                          ; well as setting Y to &FF
20841               
20842 A050 D802  30        movb ry,@MJ                     ; STY MJ            ; Set the mis-jump flag in MJ to &FF, to indicate that
     A052 0D5C     
20843                                                                          ; we are now in witchspace
20844               
20845               MJP1:
20846 A054 0206  20        li   rtmp,GTHG                  ; JSR GTHG          ; Call GTHG to spawn a Thargoid ship and a Thargon
     A056 A000     
20847 A058 06A0  32        bl   @jsr                       ;
     A05A FF10     
20848                                                                          ; companion
20849               
20850 A05C 0200  20        li   ra,>03*256                 ; LDA #3            ; Fetch the number of Thargoid ships from MANY+THG, and
     A05E 0300     
20851 A060 9020  30        cb   @MANY+THG,ra               ; CMP MANY+THG      ; if it is less than or equal to 3, loop back to MJP1 to
     A062 0D53     
20852 A064 18F7  14        joc  MJP1                       ; BCS MJP1          ; spawn another one, until we have four Thargoids
20853               
20854 A066 D800  30        movb ra,@NOSTM                  ; STA NOSTM         ; Set NOSTM (the maximum number of stardust particles)
     A068 0F33     
20855                                                                          ; to 3, so there are fewer bits of stardust in
20856                                                                          ; witchspace (normal space has a maximum of 18)
20857               
20858 A06A 0201  20        li   rx,>00*256                 ; LDX #0            ; Initialise the front space view
     A06C 0000     
20859 A06E 0206  20        li   rtmp,LOOK1                 ; JSR LOOK1
     A070 4AC4     
20860 A072 06A0  32        bl   @jsr                       ;
     A074 FF10     
20861               
20862 A076 D020  30        movb @QQ1,ra                    ; LDA QQ1           ; Fetch the current system's galactic y-coordinate in
     A078 0302     
20863                      .eoi (>1f*256)                  ; EOR #%00011111    ; QQ1 and flip bits 0-5, so we end up somewhere in the
     **** ****     > EOI
0001 A07A 0206  20        li   rtmp,(>1F*256)
     A07C 1F00     
0002 A07E 2806  18        xor  rtmp,ra
                   < elite.a99
20864 A080 D800  30        movb ra,@QQ1                    ; STA QQ1           ; vicinity of our original destination, but above or
     A082 0302     
20865                                                                          ; below it in the galactic chart
20866               ptg1_:
20867 A084 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A086 FF1C     
20868               
20869               * ******************************************************************************
20870               *
20871               * Name: TT18
20872               * Type: Subroutine
20873               * Category: Flight
20874               * Summary: Try to initiate a jump into hyperspace
20875               *
20876               * ------------------------------------------------------------------------------
20877               *
20878               * Try to go through hyperspace. Called from TT102 in the main loop when the
20879               * hyperspace countdown has finished.
20880               *
20881               * ******************************************************************************
20882               
20883               TT18:
20884 A088 D020  30        movb @QQ14,ra                   ; LDA QQ14          ; Subtract the distance to the selected system (in QQ8)
     A08A 030D     
20885                      .sec                            ; SEC               ; from the amount of fuel in our tank (in QQ14) into A
     **** ****     > SEC
0001 A08C 0A15  18        sla  rmone,1
                   < elite.a99
20886                      .sbc @QQ8,ra                    ; SBC QQ8
     **** ****     > SBC
0001 A08E 1801  14        joc  !
0002 A090 7004  18        sb   rone,ra
0003               !:
0004 A092 7020  30        sb   @QQ8,ra
     A094 0F2F     
                   < elite.a99
20887               
20888 A096 D800  30        movb ra,@QQ14                   ; STA QQ14          ; Store the updated fuel amount in QQ14
     A098 030D     
20889               
20890 A09A D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is not a space view, jump to ee5
     A09C 0096     
20891 A09E 1608  14        jne  ee5_                       ; BNE ee5           ; to skip the following
20892               
20893 A0A0 0206  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     A0A2 4B2A     
20894 A0A4 06A0  32        bl   @jsr                       ;
     A0A6 FF10     
20895                                                                          ; and set the current view type in QQ11 to 0 (space
20896                                                                          ; view)
20897               
20898 A0A8 0206  20        li   rtmp,LL164                 ; JSR LL164         ; Call LL164 to show the hyperspace tunnel and make the
     A0AA 3E3C     
20899 A0AC 06A0  32        bl   @jsr                       ;
     A0AE FF10     
20900                                                                          ; hyperspace sound
20901               
20902               ee5_:
20903 A0B0 0206  20        li   rtmp,CTRL                  ; JSR CTRL          ; Scan the keyboard to see if CTRL is currently pressed,
     A0B2 CC24     
20904 A0B4 06A0  32        bl   @jsr                       ;
     A0B6 FF10     
20905                                                                          ; returning a negative value in A if it is
20906               
20907                      .and @PATG                      ; AND PATG          ; If the game is configured to show the author's names
     **** ****     > AND
0001 A0B8 D1A0  30        movb @PATG,rtmp
     A0BA 0F4C     
0002 A0BC 0546  14        inv  rtmp
0003 A0BE 5006  18        szcb rtmp,ra
                   < elite.a99
20908                                                                          ; on the start-up screen, then PATG will contain &FF,
20909                                                                          ; otherwise it will be 0
20910               
20911 A0C0 11B1  14        jlt  ptg_                       ; BMI ptg           ; By now, A will be negative if we are holding down CTRL
20912                                                                          ; and author names are configured, which is what we have
20913                                                                          ; to do in order to trigger a manual mis-jump, so jump
20914                                                                          ; to ptg to do a mis-jump (ptg not only mis-jumps, but
20915                                                                          ; updates the competition flags, so Acornsoft could tell
20916                                                                          ; from the competition code whether this feature had
20917                                                                          ; been used)
20918               
20919 A0C2 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     A0C4 C07C     
20920 A0C6 06A0  32        bl   @jsr                       ;
     A0C8 FF10     
20921               
20922 A0CA 0280  22        ci   ra,>fd*256                 ; CMP #253          ; If A >= 253 (0.78% chance) then jump to MJP to trigger
     A0CC FD00     
20923 A0CE 18B4  14        joc  MJP                        ; BCS MJP           ; a mis-jump into witchspace
20924               
20925               * JSR TT111              \ This instruction is commented out in the original
20926                                                                          ; source. It finds the closest system to coordinates
20927                                                                          ; (QQ9, QQ10), but we don't need to do this as the
20928                                                                          ; crosshairs will already be on a system by this point
20929               
20930 A0D0 0206  20        li   rtmp,hyp1_+3               ; JSR hyp1+3        ; Jump straight to the system at (QQ9, QQ10) without
     A0D2 5F2B     
20931 A0D4 06A0  32        bl   @jsr                       ;
     A0D6 FF10     
20932                                                                          ; first calculating which system is closest
20933               
20934 A0D8 0206  20        li   rtmp,GVL                   ; JSR GVL           ; Calculate the availability for each market item in the
     A0DA 5F6A     
20935 A0DC 06A0  32        bl   @jsr                       ;
     A0DE FF10     
20936                                                                          ; new system
20937               
20938 A0E0 0206  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     A0E2 BF32     
20939 A0E4 06A0  32        bl   @jsr                       ;
     A0E6 FF10     
20940               
20941 A0E8 0206  20        li   rtmp,SOLAR                 ; JSR SOLAR         ; Halve our legal status, update the missile indicators,
     A0EA AB72     
20942 A0EC 06A0  32        bl   @jsr                       ;
     A0EE FF10     
20943                                                                          ; and set up data blocks and slots for the planet and
20944                                                                          ; sun
20945               
20946 A0F0 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view in QQ11 is not a space view (0) or
     A0F2 0096     
20947 A0F4 0240  22        andi ra,>3f*256                 ; AND #%00111111    ; one of the charts (64 or 128), return from the
     A0F6 3F00     
20948 A0F8 16C5  14        jne  ptg1_                      ; BNE ptg1          ; subroutine (as hyR contains an RTS)
20949               
20950 A0FA 0206  20        li   rtmp,TTX66                 ; JSR TTX66         ; Otherwise clear the screen and draw a white border
     A0FC 4B2E     
20951 A0FE 06A0  32        bl   @jsr                       ;
     A100 FF10     
20952               
20953 A102 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is one of the charts, jump to
     A104 0096     
20954 A106 1630  14        jne  TT114                      ; BNE TT114         ; TT114 (from which we jump to the correct routine to
20955                                                                          ; display the chart)
20956               
20957 A108 B004  18        ab   rone,ra                    ; INC QQ11          ; This is a space view, so increment QQ11 to 1
20958               
20959                                                                          ; Fall through into TT110 to show the front space view
20960               
20961               * ******************************************************************************
20962               *
20963               * Name: TT110
20964               * Type: Subroutine
20965               * Category: Flight
20966               * Summary: Launch from a station or show the front space view
20967               *
20968               * ------------------------------------------------------------------------------
20969               *
20970               * Launch the ship (if we are docked), or show the front space view (if we are
20971               * already in space).
20972               *
20973               * Called when red key f0 is pressed while docked (launch), after we arrive in a
20974               * new galaxy, or after a hyperspace if the current view is a space view.
20975               *
20976               * ******************************************************************************
20977               
20978               TT110:
20979 A10A D060  30        movb @QQ12,rx                   ; LDX QQ12          ; If we are not docked (QQ12 = 0) then jump to NLUNCH
     A10C 009F     
20980 A10E 1326  14        jeq  NLUNCH                     ; BEQ NLUNCH        ; to skip the launch tunnel and setup process
20981               
20982 A110 0206  20        li   rtmp,LAUN                  ; JSR LAUN          ; Show the space station launch tunnel
     A112 3E62     
20983 A114 06A0  32        bl   @jsr                       ;
     A116 FF10     
20984               
20985 A118 0206  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     A11A BF32     
20986 A11C 06A0  32        bl   @jsr                       ;
     A11E FF10     
20987               
20988 A120 0206  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     A122 5AB8     
20989 A124 06A0  32        bl   @jsr                       ;
     A126 FF10     
20990                                                                          ; (QQ9, QQ10)
20991               
20992 A128 B004  18        ab   rone,ra                    ; INC INWK+8        ; Increment z_sign ready for the call to SOS, so the
20993                                                                          ; planet appears at a z_sign of 1 in front of us when
20994                                                                          ; we launch
20995               
20996 A12A 0206  20        li   rtmp,SOS1                  ; JSR SOS1          ; Call SOS1 to set up the planet's data block and add it
     A12C AB4E     
20997 A12E 06A0  32        bl   @jsr                       ;
     A130 FF10     
20998                                                                          ; to FRIN, where it will get put in the first slot as
20999                                                                          ; it's the first one to be added to our local bubble of
21000                                                                          ; universe following the call to RES2 above
21001               
21002 A132 0200  20        li   ra,>80*256                 ; LDA #128          ; For the space station, set z_sign to &80, so it's
     A134 8000     
21003 A136 D800  30        movb ra,@INWK+8                 ; STA INWK+8        ; behind us (&80 is negative)
     A138 005B     
21004               
21005 A13A B004  18        ab   rone,ra                    ; INC INWK+7        ; And increment z_hi, so it's only just behind us
21006               
21007 A13C 0206  20        li   rtmp,NWSPS                 ; JSR NWSPS         ; Add a new space station to our local bubble of
     A13E AF2A     
21008 A140 06A0  32        bl   @jsr                       ;
     A142 FF10     
21009                                                                          ; universe
21010               
21011 A144 0200  20        li   ra,>0c*256                 ; LDA #12           ; Set our launch speed in DELTA to 12
     A146 0C00     
21012 A148 D800  30        movb ra,@DELTA                  ; STA DELTA
     A14A 008C     
21013               
21014 A14C 0206  20        li   rtmp,BAD                   ; JSR BAD           ; Call BAD to work out how much illegal contraband we
     A14E C436     
21015 A150 06A0  32        bl   @jsr                       ;
     A152 FF10     
21016                                                                          ; are carrying in our hold (A is up to 40 for a
21017                                                                          ; standard hold crammed with contraband, up to 70 for
21018                                                                          ; an extended cargo hold full of narcotics and slaves)
21019               
21020 A154 F020  30        socb @FIST,ra                   ; ORA FIST          ; OR the value in A with our legal status in FIST to
     A156 0334     
21021                                                                          ; get a new value that is at least as high as both
21022                                                                          ; values, to reflect the fact that launching with a
21023                                                                          ; hold full of contraband can only make matters worse
21024               
21025 A158 D800  30        movb ra,@FIST                   ; STA FIST          ; Update our legal status with the new value
     A15A 0334     
21026               
21027               NLUNCH:
21028 A15C 0201  20        li   rx,>00*256                 ; LDX #0            ; Set QQ12 to 0 to indicate we are not docked
     A15E 0000     
21029 A160 D801  30        movb rx,@QQ12                   ; STX QQ12
     A162 009F     
21030               
21031 A164 0460  28        b    @LOOK1                     ; JMP LOOK1         ; Jump to LOOK1 to switch to the front view (X = 0),
     A166 4AC4     
21032                                                                          ; returning from the subroutine using a tail call
21033               
21034               * ******************************************************************************
21035               *
21036               * Name: TT114
21037               * Type: Subroutine
21038               * Category: Charts
21039               * Summary: Display either the Long-range or Short-range Chart
21040               *
21041               * ------------------------------------------------------------------------------
21042               *
21043               * Display either the Long-range or Short-range Chart, depending on the current
21044               * view setting. Called from TT18 once we know the current view is one of the
21045               * charts.
21046               *
21047               * ------------------------------------------------------------------------------
21048               *
21049               * Arguments:
21050               *
21051               * A                   The current view, loaded from QQ11
21052               *
21053               * ******************************************************************************
21054               
21055               TT114:
21056 A168 1102  14        jlt  TT115                      ; BMI TT115         ; If bit 7 of the current view is set (i.e. the view is
21057                                                                          ; the Short-range Chart, 128), skip to TT115 below to
21058                                                                          ; jump to TT23 to display the chart
21059               
21060 A16A 0460  28        b    @TT22                      ; JMP TT22          ; Otherwise the current view is the Long-range Chart, so
     A16C 5272     
21061                                                                          ; jump to TT22 to display it
21062               
21063               TT115:
21064 A16E 0460  28        b    @TT23                      ; JMP TT23          ; Jump to TT23 to display the Short-range Chart
     A170 592A     
21065               
21066               * ******************************************************************************
21067               *
21068               * Name: LCASH
21069               * Type: Subroutine
21070               * Category: Maths (Arithmetic)
21071               * Summary: Subtract an amount of cash from the cash pot
21072               *
21073               * ------------------------------------------------------------------------------
21074               *
21075               * Subtract (Y X) cash from the cash pot in CASH, but only if there is enough
21076               * cash in the pot. As CASH is a four-byte number, this calculates:
21077               *
21078               * CASH(0 1 2 3) = CASH(0 1 2 3) - (0 0 Y X)
21079               *
21080               * ------------------------------------------------------------------------------
21081               *
21082               * Returns:
21083               *
21084               * C flag              If set, there was enough cash to do the subtraction
21085               *
21086               * If clear, there was not enough cash to do the
21087               * subtraction
21088               *
21089               * ******************************************************************************
21090               
21091               LCASH:
21092 A172 D801  30        movb rx,@T1                     ; STX T1            ; Subtract the least significant bytes:
     A174 0006     
21093 A176 D020  30        movb @CASH+3,ra                 ; LDA CASH+3        ;
     A178 030C     
21094                      .sec                            ; SEC               ; CASH+3 = CASH+3 - X
     **** ****     > SEC
0001 A17A 0A15  18        sla  rmone,1
                   < elite.a99
21095                      .sbc @T1,ra                     ; SBC T1
     **** ****     > SBC
0001 A17C 1801  14        joc  !
0002 A17E 7004  18        sb   rone,ra
0003               !:
0004 A180 7020  30        sb   @T1,ra
     A182 0006     
                   < elite.a99
21096 A184 D800  30        movb ra,@CASH+3                 ; STA CASH+3
     A186 030C     
21097               
21098 A188 D802  30        movb ry,@T1                     ; STY T1            ; Then the second most significant bytes:
     A18A 0006     
21099 A18C D020  30        movb @CASH+2,ra                 ; LDA CASH+2        ;
     A18E 030B     
21100                      .sbc @T1,ra                     ; SBC T1            ; CASH+2 = CASH+2 - Y
     **** ****     > SBC
0001 A190 1801  14        joc  !
0002 A192 7004  18        sb   rone,ra
0003               !:
0004 A194 7020  30        sb   @T1,ra
     A196 0006     
                   < elite.a99
21101 A198 D800  30        movb ra,@CASH+2                 ; STA CASH+2
     A19A 030B     
21102               
21103 A19C D020  30        movb @CASH+1,ra                 ; LDA CASH+1        ; Then the third most significant bytes (which are 0):
     A19E 030A     
21104                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 A1A0 1801  14        joc  !
0002 A1A2 7004  18        sb   rone,ra
0003               !:
0004 A1A4 0220  22        ai   ra,-(>00*256)
     A1A6 0000     
                   < elite.a99
21105 A1A8 D800  30        movb ra,@CASH+1                 ; STA CASH+1        ; CASH+1 = CASH+1 - 0
     A1AA 030A     
21106               
21107 A1AC D020  30        movb @CASH,ra                   ; LDA CASH          ; And finally the most significant bytes (which are 0):
     A1AE 0309     
21108                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 A1B0 1801  14        joc  !
0002 A1B2 7004  18        sb   rone,ra
0003               !:
0004 A1B4 0220  22        ai   ra,-(>00*256)
     A1B6 0000     
                   < elite.a99
21109 A1B8 D800  30        movb ra,@CASH                   ; STA CASH          ; CASH = CASH - 0
     A1BA 0309     
21110               
21111 A1BC 1820  14        joc  TT113                      ; BCS TT113         ; If the C flag is set then the subtraction didn't
21112                                                                          ; underflow, so the value in CASH is correct and we can
21113                                                                          ; jump to TT113 to return from the subroutine with the
21114                                                                          ; C flag set to indicate success (as TT113 contains an
21115                                                                          ; RTS)
21116               
21117                                                                          ; Otherwise we didn't have enough cash in CASH to
21118                                                                          ; subtract (Y X) from it, so fall through into
21119                                                                          ; MCASH to reverse the sum and restore the original
21120                                                                          ; value in CASH, and returning with the C flag clear
21121               
21122               * ******************************************************************************
21123               *
21124               * Name: MCASH
21125               * Type: Subroutine
21126               * Category: Maths (Arithmetic)
21127               * Summary: Add an amount of cash to the cash pot
21128               *
21129               * ------------------------------------------------------------------------------
21130               *
21131               * Add (Y X) cash to the cash pot in CASH. As CASH is a four-byte number, this
21132               * calculates:
21133               *
21134               * CASH(0 1 2 3) = CASH(0 1 2 3) + (Y X)
21135               *
21136               * ------------------------------------------------------------------------------
21137               *
21138               * Other entry points:
21139               *
21140               * TT113               Contains an RTS
21141               *
21142               * ******************************************************************************
21143               
21144               MCASH:
21145 A1BE D001  18        movb rx,ra                      ; TXA               ; Add the least significant bytes:
21146                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 A1C0 0A13  18        sla  rzero,1
                   < elite.a99
21147                      .adc @CASH+3,ra                 ; ADC CASH+3        ; CASH+3 = CASH+3 + X
     **** ****     > ADC
0001 A1C2 1701  14        jnc  !
0002 A1C4 B004  18        ab   rone,ra
0003               !:
0004 A1C6 B020  30        ab   @CASH+3,ra
     A1C8 030C     
                   < elite.a99
21148 A1CA D800  30        movb ra,@CASH+3                 ; STA CASH+3
     A1CC 030C     
21149               
21150 A1CE D002  18        movb ry,ra                      ; TYA               ; Then the second most significant bytes:
21151                      .adc @CASH+2,ra                 ; ADC CASH+2        ;
     **** ****     > ADC
0001 A1D0 1701  14        jnc  !
0002 A1D2 B004  18        ab   rone,ra
0003               !:
0004 A1D4 B020  30        ab   @CASH+2,ra
     A1D6 030B     
                   < elite.a99
21152 A1D8 D800  30        movb ra,@CASH+2                 ; STA CASH+2        ; CASH+2 = CASH+2 + Y
     A1DA 030B     
21153               
21154 A1DC D020  30        movb @CASH+1,ra                 ; LDA CASH+1        ; Then the third most significant bytes (which are 0):
     A1DE 030A     
21155                      .adi (>00*256)                  ; ADC #0            ;
     **** ****     > ADI
0001 A1E0 1701  14        jnc  !
0002 A1E2 B004  18        ab   rone,ra
0003               !:
0004 A1E4 0220  22        ai   ra,(>00*256)
     A1E6 0000     
                   < elite.a99
21156 A1E8 D800  30        movb ra,@CASH+1                 ; STA CASH+1        ; CASH+1 = CASH+1 + 0
     A1EA 030A     
21157               
21158 A1EC D020  30        movb @CASH,ra                   ; LDA CASH          ; And finally the most significant bytes (which are 0):
     A1EE 0309     
21159                      .adi (>00*256)                  ; ADC #0            ;
     **** ****     > ADI
0001 A1F0 1701  14        jnc  !
0002 A1F2 B004  18        ab   rone,ra
0003               !:
0004 A1F4 0220  22        ai   ra,(>00*256)
     A1F6 0000     
                   < elite.a99
21160 A1F8 D800  30        movb ra,@CASH                   ; STA CASH          ; CASH = CASH + 0
     A1FA 0309     
21161               
21162                      .clc                            ; CLC               ; Clear the C flag, so if the above was done following
     **** ****     > CLC
0001 A1FC 0A13  18        sla  rzero,1
                   < elite.a99
21163                                                                          ; a failed LCASH call, the C flag correctly indicates
21164                                                                          ; failure
21165               
21166               TT113:
21167 A1FE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A200 FF1C     
21168               
21169               * ******************************************************************************
21170               *
21171               * Name: GCASH
21172               * Type: Subroutine
21173               * Category: Maths (Arithmetic)
21174               * Summary: Calculate (Y X) = P * Q * 4
21175               *
21176               * ------------------------------------------------------------------------------
21177               *
21178               * Calculate the following multiplication of unsigned 8-bit numbers:
21179               *
21180               * (Y X) = P * Q * 4
21181               *
21182               * ******************************************************************************
21183               
21184               GCASH:
21185 A202 0206  20        li   rtmp,MULTU                 ; JSR MULTU         ; Call MULTU to calculate (A P) = P * Q
     A204 42DE     
21186 A206 06A0  32        bl   @jsr                       ;
     A208 FF10     
21187               
21188               * ******************************************************************************
21189               *
21190               * Name: GC2
21191               * Type: Subroutine
21192               * Category: Maths (Arithmetic)
21193               * Summary: Calculate (Y X) = (A P) * 4
21194               *
21195               * ------------------------------------------------------------------------------
21196               *
21197               * Calculate the following multiplication of unsigned 16-bit numbers:
21198               *
21199               * (Y X) = (A P) * 4
21200               *
21201               * ******************************************************************************
21202               
21203               GC2:
21204                      .asl @P                         ; ASL P             ; Set (A P) = (A P) * 4
     **** ****     > ASL
0001 A20A D1A0  30        movb @P,rtmp
     A20C 001B     
0002 A20E 0246  22        andi rtmp,>ff00
     A210 FF00     
0003 A212 0A16  18        sla  rtmp,1
0004 A214 D806  30        movb rtmp,@P
     A216 001B     
                   < elite.a99
21205 A218 06A0  32        bl   @rola                      ; ROL A
     A21A FF26     
21206                      .asl @P                         ; ASL P
     **** ****     > ASL
0001 A21C D1A0  30        movb @P,rtmp
     A21E 001B     
0002 A220 0246  22        andi rtmp,>ff00
     A222 FF00     
0003 A224 0A16  18        sla  rtmp,1
0004 A226 D806  30        movb rtmp,@P
     A228 001B     
                   < elite.a99
21207 A22A 06A0  32        bl   @rola                      ; ROL A
     A22C FF26     
21208               
21209 A22E D080  18        movb ra,ry                      ; TAY               ; Set (Y X) = (A P)
21210 A230 D060  30        movb @P,rx                      ; LDX P
     A232 001B     
21211               
21212 A234 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A236 FF1C     
21213               
21214               * ******************************************************************************
21215               *
21216               * Name: EQSHP
21217               * Type: Subroutine
21218               * Category: Equipment
21219               * Summary: Show the Equip Ship screen (red key f3)
21220               *
21221               * ------------------------------------------------------------------------------
21222               *
21223               * Other entry points:
21224               *
21225               * err                 Beep, pause and go to the docking bay (i.e. show the
21226               * Status Mode screen)
21227               *
21228               * pres                Given an item number A with the item name in recursive
21229               * token Y, show an error to say that the item is already
21230               * present, refund the cost of the item, and then beep and
21231               * exit to the docking bay (i.e. show the Status Mode
21232               * screen)
21233               *
21234               * ******************************************************************************
21235               
21236               bay_:
21237 A238 0460  28        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     A23A C65C     
21238                                                                          ; screen)
21239               
21240               EQSHP:
21241 A23C 0206  20        li   rtmp,DIALS                 ; JSR DIALS         ; Call DIALS to update the dashboard
     A23E 3272     
21242 A240 06A0  32        bl   @jsr                       ;
     A242 FF10     
21243               
21244 A244 0200  20        li   ra,>20*256                 ; LDA #32           ; Clear the top part of the screen, draw a white border,
     A246 2000     
21245 A248 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 32 (Equip
     A24A 4B2A     
21246 A24C 06A0  32        bl   @jsr                       ;
     A24E FF10     
21247                                                                          ; Ship screen)
21248               
21249 A250 0200  20        li   ra,>0c*256                 ; LDA #12           ; Move the text cursor to column 12
     A252 0C00     
21250 A254 D800  30        movb ra,@XC                     ; STA XC
     A256 002C     
21251               
21252 A258 0200  20        li   ra,>cf*256                 ; LDA #207          ; Print recursive token 47 ("EQUIP") followed by a space
     A25A CF00     
21253 A25C 0206  20        li   rtmp,spc_                  ; JSR spc
     A25E 4EFE     
21254 A260 06A0  32        bl   @jsr                       ;
     A262 FF10     
21255               
21256 A264 0200  20        li   ra,>b9*256                 ; LDA #185          ; Print recursive token 25 ("SHIP") and draw a
     A266 B900     
21257 A268 0206  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; horizontal line at pixel row 19 to box in the title
     A26A 25B0     
21258 A26C 06A0  32        bl   @jsr                       ;
     A26E FF10     
21259               
21260 A270 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     A272 8000     
21261 A274 D800  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     A276 007E     
21262               
21263 A278 B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
21264               
21265 A27A D020  30        movb @tek_,ra                   ; LDA tek           ; Fetch the tech level of the current system from tek
     A27C 0F1D     
21266                      .clc                            ; CLC               ; and add 3 (the tech level is stored as 0-14, so A is
     **** ****     > CLC
0001 A27E 0A13  18        sla  rzero,1
                   < elite.a99
21267                      .adi (>03*256)                  ; ADC #3            ; now set to between 3 and 17)
     **** ****     > ADI
0001 A280 1701  14        jnc  !
0002 A282 B004  18        ab   rone,ra
0003               !:
0004 A284 0220  22        ai   ra,(>03*256)
     A286 0300     
                   < elite.a99
21268               
21269 A288 0280  22        ci   ra,>0c*256                 ; CMP #12           ; If A >= 12 then set A = 12, so A is now set to between
     A28A 0C00     
21270 A28C 1702  14        jnc  B58                        ; BCC B58           ; 3 and 12
21271 A28E 0200  20        li   ra,>0c*256                 ; LDA #12
     A290 0C00     
21272               
21273               B58:
21274 A292 D800  30        movb ra,@Q                      ; STA Q             ; Set QQ25 = A (so QQ25 is in the range 3-12 and
     A294 0090     
21275 A296 D800  30        movb ra,@QQ25                   ; STA QQ25          ; represents number of the most advanced item available
     A298 0F19     
21276 A29A B004  18        ab   rone,ra                    ; INC Q             ; in this system, which we can pass to gnum below when
21277                                                                          ; asking which item we want to buy)
21278                                                                          ;
21279                                                                          ; Set Q = A + 1 (so Q is in the range 4-13 and contains
21280                                                                          ; QQ25 + 1, i.e. the highest item number on sale + 1)
21281               
21282 A29C 0200  20        li   ra,>46*256                 ; LDA #70           ; Set A = 70 - QQ14, where QQ14 contains the current
     A29E 4600     
21283                      .sec                            ; SEC               ; fuel in light years * 10, so this leaves the amount
     **** ****     > SEC
0001 A2A0 0A15  18        sla  rmone,1
                   < elite.a99
21284                      .sbc @QQ14,ra                   ; SBC QQ14          ; of fuel we need to fill 'er up (in light years * 10)
     **** ****     > SBC
0001 A2A2 1801  14        joc  !
0002 A2A4 7004  18        sb   rone,ra
0003               !:
0004 A2A6 7020  30        sb   @QQ14,ra
     A2A8 030D     
                   < elite.a99
21285               
21286                      .asla                           ; ASL A             ; The price of fuel is always 2 Cr per light year, so we
     **** ****     > ASLA
0001 A2AA 0240  22        andi ra,>ff00
     A2AC FF00     
0002 A2AE 0A10  18        sla  ra,1
                   < elite.a99
21287 A2B0 D800  38        movb ra,@PRXS                   ; STA PRXS          ; double A and store it in PRXS, as the first price in
     A2B2 2DF0     
21288                                                                          ; the price list (which is reserved for fuel), and
21289                                                                          ; because the table contains prices as price * 10, it's
21290                                                                          ; in the right format (so tank containing 7.0 light
21291                                                                          ; years of fuel would be 14.0 Cr, or a PRXS value of
21292                                                                          ; 140)
21293               
21294 A2B4 0201  20        li   rx,>01*256                 ; LDX #1            ; We are now going to work our way through the equipment
     A2B6 0100     
21295                                                                          ; price list at PRXS, printing out the equipment that is
21296                                                                          ; available at this station, so set a counter in X,
21297                                                                          ; starting at 1, to hold the number of the current item
21298                                                                          ; plus 1 (so the item number in X loops through 1-13)
21299               
21300               EQL1:
21301 A2B8 D801  30        movb rx,@XX13                   ; STX XX13          ; Store the current item number + 1 in XX13
     A2BA 0098     
21302               
21303 A2BC 0206  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline
     A2BE 4EE6     
21304 A2C0 06A0  32        bl   @jsr                       ;
     A2C2 FF10     
21305               
21306 A2C4 D060  30        movb @XX13,rx                   ; LDX XX13          ; Print the current item number + 1 to 3 digits, left-
     A2C6 0098     
21307                      .clc                            ; CLC               ; padding with spaces, and with no decimal point, so the
     **** ****     > CLC
0001 A2C8 0A13  18        sla  rzero,1
                   < elite.a99
21308 A2CA 0206  20        li   rtmp,pr2_                  ; JSR pr2           ; items are numbered from 1
     A2CC 2FAC     
21309 A2CE 06A0  32        bl   @jsr                       ;
     A2D0 FF10     
21310               
21311 A2D2 0206  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     A2D4 5E64     
21312 A2D6 06A0  32        bl   @jsr                       ;
     A2D8 FF10     
21313               
21314 A2DA D020  30        movb @XX13,ra                   ; LDA XX13          ; Print recursive token 104 + XX13, which will be in the
     A2DC 0098     
21315                      .clc                            ; CLC               ; range 105 ("FUEL") to 116 ("GALACTIC HYPERSPACE ")
     **** ****     > CLC
0001 A2DE 0A13  18        sla  rzero,1
                   < elite.a99
21316                      .adi (>68*256)                  ; ADC #104          ; so this prints the current item's name
     **** ****     > ADI
0001 A2E0 1701  14        jnc  !
0002 A2E2 B004  18        ab   rone,ra
0003               !:
0004 A2E4 0220  22        ai   ra,(>68*256)
     A2E6 6800     
                   < elite.a99
21317 A2E8 0206  20        li   rtmp,TT27                  ; JSR TT27
     A2EA A6E8     
21318 A2EC 06A0  32        bl   @jsr                       ;
     A2EE FF10     
21319               
21320 A2F0 D020  30        movb @XX13,ra                   ; LDA XX13          ; Call prx-3 to set (Y X) to the price of the item with
     A2F2 0098     
21321 A2F4 0206  20        li   rtmp,prx_-3                ; JSR prx-3         ; number XX13 - 1 (as XX13 contains the item number + 1)
     A2F6 A521     
21322 A2F8 06A0  32        bl   @jsr                       ;
     A2FA FF10     
21323               
21324                      .sec                            ; SEC               ; Set the C flag so we will print a decimal point when
     **** ****     > SEC
0001 A2FC 0A15  18        sla  rmone,1
                   < elite.a99
21325                                                                          ; we print the price
21326               
21327 A2FE 0200  20        li   ra,>19*256                 ; LDA #25           ; Move the text cursor to column 25
     A300 1900     
21328 A302 D800  30        movb ra,@XC                     ; STA XC
     A304 002C     
21329               
21330 A306 0200  20        li   ra,>06*256                 ; LDA #6            ; Print the number in (Y X) to 6 digits, left-padding
     A308 0600     
21331 A30A 0206  20        li   rtmp,TT11                  ; JSR TT11          ; with spaces and including a decimal point, which will
     A30C 2FB4     
21332 A30E 06A0  32        bl   @jsr                       ;
     A310 FF10     
21333                                                                          ; be the correct price for this item as (Y X) contains
21334                                                                          ; the price * 10, so the trailing zero will go after the
21335                                                                          ; decimal point (i.e. 5250 will be printed as 525.0)
21336               
21337 A312 D060  30        movb @XX13,rx                   ; LDX XX13          ; Increment the current item number in XX13
     A314 0098     
21338 A316 B044  18        ab   rone,rx                    ; INX
21339               
21340 A318 9060  30        cb   @Q,rx                      ; CPX Q             ; If X < Q, loop back up to print the next item on the
     A31A 0090     
21341 A31C 17CD  14        jnc  EQL1                       ; BCC EQL1          ; list of equipment available at this station
21342               
21343 A31E 0206  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     A320 4C2E     
21344 A322 06A0  32        bl   @jsr                       ;
     A324 FF10     
21345                                                                          ; and move the text cursor to column 1 on row 21, i.e.
21346                                                                          ; the start of the top row of the three bottom rows
21347               
21348 A326 0200  20        li   ra,>7f*256                 ; LDA #127          ; Print recursive token 127 ("ITEM") followed by a
     A328 7F00     
21349 A32A 0206  20        li   rtmp,prq_                  ; JSR prq           ; question mark
     A32C 5D52     
21350 A32E 06A0  32        bl   @jsr                       ;
     A330 FF10     
21351               
21352 A332 0206  20        li   rtmp,gnum_                 ; JSR gnum          ; Call gnum to get a number from the keyboard, which
     A334 55CE     
21353 A336 06A0  32        bl   @jsr                       ;
     A338 FF10     
21354                                                                          ; will be the number of the item we want to purchase,
21355                                                                          ; returning the number entered in A and R, and setting
21356                                                                          ; the C flag if the number is bigger than the highest
21357                                                                          ; item number in QQ25
21358               
21359 A33A 1602  14        jne  FIX004                     ; BNE FIX004        ; If no number was entered, jump up to bay to go to the
21360                                                                          ; docking bay (i.e. show the Status Mode screen)
21361 A33C 0460  28        b    @bay_                      ; JMP bay
     A33E A238     
21362               FIX004:
21363 A340 1702  14        jnc  FIX005                     ; BCC FIX005        ; If the number entered was too big, jump up to bay to
21364                                                                          ; go to the docking bay (i.e. show the Status Mode
21365                                                                          ; screen)
21366 A342 0460  28        b    @bay_                      ; JMP bay
     A344 A238     
21367               FIX005:
21368                      .sbi (>00*256)                  ; SBC #0            ; Set A to the number entered - 1 (because the C flag is
     **** ****     > SBI
0001 A346 1801  14        joc  !
0002 A348 7004  18        sb   rone,ra
0003               !:
0004 A34A 0220  22        ai   ra,-(>00*256)
     A34C 0000     
                   < elite.a99
21369                                                                          ; clear), which will be the actual item number we want
21370                                                                          ; to buy
21371               
21372 A34E 0201  20        li   rx,>02*256                 ; LDX #2            ; Move the text cursor to column 2
     A350 0200     
21373 A352 D801  30        movb rx,@XC                     ; STX XC
     A354 002C     
21374               
21375 A356 B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
21376               
21377                      .pha                            ; PHA               ; While preserving the value in A, call eq to subtract
     **** ****     > PHA
0001 A358 D680  30        movb ra,*rsp
0002 A35A 060A  14        dec  rsp
                   < elite.a99
21378 A35C 0206  20        li   rtmp,eq_                   ; JSR eq            ; the price of the item we want to buy (which is in A)
     A35E A4F8     
21379 A360 06A0  32        bl   @jsr                       ;
     A362 FF10     
21380                      .pla                            ; PLA               ; from our cash pot, but only if we have enough cash in
     **** ****     > PLA
0001 A364 058A  14        inc  rsp
0002 A366 D01A  26        movb *rsp,ra
                   < elite.a99
21381                                                                          ; the pot. If we don't have enough cash, exit to the
21382                                                                          ; docking bay (i.e. show the Status Mode screen)
21383               
21384 A368 1606  14        jne  et0_                       ; BNE et0           ; If A is not 0 (i.e. the item we've just bought is not
21385                                                                          ; fuel), skip to et0
21386               
21387 A36A D800  30        movb ra,@MCNT                   ; STA MCNT          ; We just bought fuel, so we zero the main loop counter
     A36C 0099     
21388               
21389 A36E 0201  20        li   rx,>46*256                 ; LDX #70           ; Set the current fuel level * 10 in QQ14 to 70, or 7.0
     A370 4600     
21390 A372 D801  30        movb rx,@QQ14                   ; STX QQ14          ; light years (a full tank)
     A374 030D     
21391               
21392               et0_:
21393 A376 0280  22        ci   ra,>01*256                 ; CMP #1            ; If A is not 1 (i.e. the item we've just bought is not
     A378 0100     
21394 A37A 160E  14        jne  et1_                       ; BNE et1           ; a missile), skip to et1
21395               
21396 A37C D060  30        movb @NOMSL,rx                  ; LDX NOMSL         ; Fetch the current number of missiles from NOMSL into X
     A37E 0333     
21397               
21398 A380 B044  18        ab   rone,rx                    ; INX               ; Increment X to the new number of missiles
21399               
21400 A382 0202  20        li   ry,>75*256                 ; LDY #117          ; Set Y to recursive token 117 ("ALL")
     A384 7500     
21401               
21402 A386 0281  22        ci   rx,>05*256                 ; CPX #5            ; If buying this missile would give us 5 missiles, this
     A388 0500     
21403 A38A 1856  14        joc  pres_                      ; BCS pres          ; is more than the maximum of 4 missiles that we can
21404                                                                          ; fit, so jump to pres to show the error "All Present",
21405                                                                          ; beep and exit to the docking bay (i.e. show the Status
21406                                                                          ; Mode screen)
21407               
21408 A38C D801  30        movb rx,@NOMSL                  ; STX NOMSL         ; Otherwise update the number of missiles in NOMSL
     A38E 0333     
21409               
21410 A390 0206  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     A392 BFE8     
21411 A394 06A0  32        bl   @jsr                       ;
     A396 FF10     
21412                                                                          ; them are targeted
21413               
21414               et1_:
21415 A398 0202  20        li   ry,>6b*256                 ; LDY #107          ; Set Y to recursive token 107 ("LARGE CARGO{sentence
     A39A 6B00     
21416                                                                          ; case} BAY")
21417               
21418 A39C 0280  22        ci   ra,>02*256                 ; CMP #2            ; If A is not 2 (i.e. the item we've just bought is not
     A39E 0200     
21419 A3A0 1607  14        jne  et2_                       ; BNE et2           ; a large cargo bay), skip to et2
21420               
21421 A3A2 0201  20        li   rx,>25*256                 ; LDX #37           ; If our current cargo capacity in CRGO is 37, then we
     A3A4 2500     
21422 A3A6 9060  30        cb   @CRGO,rx                   ; CPX CRGO          ; already have a large cargo bay fitted, so jump to pres
     A3A8 0316     
21423 A3AA 1346  14        jeq  pres_                      ; BEQ pres          ; to show the error "Large Cargo Bay Present", beep and
21424                                                                          ; exit to the docking bay (i.e. show the Status Mode
21425                                                                          ; screen)
21426               
21427 A3AC D801  30        movb rx,@CRGO                   ; STX CRGO          ; Otherwise we just scored ourselves a large cargo bay,
     A3AE 0316     
21428                                                                          ; so update our current cargo capacity in CRGO to 37
21429               
21430               et2_:
21431 A3B0 0280  22        ci   ra,>03*256                 ; CMP #3            ; If A is not 3 (i.e. the item we've just bought is not
     A3B2 0300     
21432 A3B4 1605  14        jne  et3_                       ; BNE et3           ; an E.C.M. system), skip to et3
21433               
21434 A3B6 B084  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 108 ("E.C.M.SYSTEM")
21435               
21436 A3B8 D060  30        movb @ECM,rx                    ; LDX ECM           ; If we already have an E.C.M. fitted (i.e. ECM is
     A3BA 0328     
21437 A3BC 163D  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "E.C.M.
21438                                                                          ; System Present", beep and exit to the docking bay
21439                                                                          ; (i.e. show the Status Mode screen)
21440               
21441 A3BE 7004  18        sb   rone,ra                    ; DEC ECM           ; Otherwise we just took delivery of a brand new E.C.M.
21442                                                                          ; system, so set ECM to &FF (as ECM was 0 before the DEC
21443                                                                          ; instruction)
21444               
21445               et3_:
21446 A3C0 0280  22        ci   ra,>04*256                 ; CMP #4            ; If A is not 4 (i.e. the item we've just bought is not
     A3C2 0400     
21447 A3C4 1612  14        jne  et4_                       ; BNE et4           ; an extra pulse laser), skip to et4
21448               
21449 A3C6 0206  20        li   rtmp,qv_                   ; JSR qv            ; Print a menu listing the four views, with a "View ?"
     A3C8 A53A     
21450 A3CA 06A0  32        bl   @jsr                       ;
     A3CC FF10     
21451                                                                          ; prompt, and ask for a view number, which is returned
21452                                                                          ; in X (which now contains 0-3)
21453               
21454 A3CE 0200  20        li   ra,>04*256                 ; LDA #4            ; This instruction doesn't appear to do anything, as we
     A3D0 0400     
21455                                                                          ; either don't need it (if we already have this laser)
21456                                                                          ; or we set A to 4 below (if we buy it)
21457               
21458 A3D2 D0A1  34        movb @LASER(rx),ry              ; LDY LASER,X       ; If there is no laser mounted in the chosen view (i.e.
     A3D4 0310     
21459 A3D6 1303  14        jeq  ed4_                       ; BEQ ed4           ; LASER+X, which contains the laser power for view X, is
21460                                                                          ; zero), jump to ed4 to buy a pulse laser
21461               
21462               ed7_:
21463 A3D8 0202  20        li   ry,>bb*256                 ; LDY #187          ; Otherwise we already have a laser mounted in this
     A3DA BB00     
21464 A3DC 162D  14        jne  pres_                      ; BNE pres          ; view, so jump to pres with Y set to token 27
21465                                                                          ; (" LASER") to show the error "Laser Present", beep
21466                                                                          ; and exit to the docking bay (i.e. show the Status
21467                                                                          ; Mode screen)
21468               
21469               ed4_:
21470 A3DE 0200  20        li   ra,(POW)*256               ; LDA #POW          ; We just bought a pulse laser for view X, so we need
     A3E0 0F00     
21471 A3E2 D840  38        movb ra,@LASER(rx)              ; STA LASER,X       ; to fit it by storing the laser power for a pulse laser
     A3E4 0310     
21472                                                                          ; (given in POW) in LASER+X
21473               
21474 A3E6 0200  20        li   ra,>04*256                 ; LDA #4            ; Set A to 4 as we just overwrote the original value,
     A3E8 0400     
21475                                                                          ; and we still need it set correctly so we can continue
21476                                                                          ; through the conditional statements for all the other
21477                                                                          ; equipment
21478               
21479               et4_:
21480 A3EA 0280  22        ci   ra,>05*256                 ; CMP #5            ; If A is not 5 (i.e. the item we've just bought is not
     A3EC 0500     
21481 A3EE 161C  14        jne  et5_                       ; BNE et5           ; an extra beam laser), skip to et5
21482               
21483 A3F0 0206  20        li   rtmp,qv_                   ; JSR qv            ; Print a menu listing the four views, with a "View ?"
     A3F2 A53A     
21484 A3F4 06A0  32        bl   @jsr                       ;
     A3F6 FF10     
21485                                                                          ; prompt, and ask for a view number, which is returned
21486                                                                          ; in X (which now contains 0-3)
21487               
21488 A3F8 D801  30        movb rx,@T1                     ; STX T1            ; Store the view in T1 so we can retrieve it below
     A3FA 0006     
21489               
21490 A3FC 0200  20        li   ra,>05*256                 ; LDA #5            ; Set A to 5 as the call to qv will have overwritten
     A3FE 0500     
21491                                                                          ; the original value, and we still need it set
21492                                                                          ; correctly so we can continue through the conditional
21493                                                                          ; statements for all the other equipment
21494               
21495 A400 D0A1  34        movb @LASER(rx),ry              ; LDY LASER,X       ; If there is no laser mounted in the chosen view (i.e.
     A402 0310     
21496 A404 130B  14        jeq  ed5_                       ; BEQ ed5           ; LASER+X, which contains the laser power for view X,
21497                                                                          ; is zero), jump to ed5 to buy a beam laser
21498               
21499               * BPL P%+4               \ This instruction is commented out in the original
21500                                                                          ; source, though it would have no effect (it would
21501                                                                          ; simply skip the BMI if A is positive, which is what
21502                                                                          ; BMI does anyway)
21503               
21504 A406 11E8  14        jlt  ed7_                       ; BMI ed7           ; If there is a beam laser already mounted in the chosen
21505                                                                          ; view (i.e. LASER+X has bit 7 set, which indicates a
21506                                                                          ; beam laser rather than a pulse laser), skip back to
21507                                                                          ; ed7 to print a "Laser Present" error, beep and exit
21508                                                                          ; to the docking bay (i.e. show the Status Mode screen)
21509               
21510 A408 0200  20        li   ra,>04*256                 ; LDA #4            ; If we get here then we already have a pulse laser in
     A40A 0400     
21511 A40C 0206  20        li   rtmp,prx_                  ; JSR prx           ; the selected view, so we call prx to set (Y X) to the
     A40E A524     
21512 A410 06A0  32        bl   @jsr                       ;
     A412 FF10     
21513                                                                          ; price of equipment item number 4 (extra pulse laser)
21514                                                                          ; so we can give a refund of the pulse laser
21515               
21516 A414 0206  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH, so we refund
     A416 A1BE     
21517 A418 06A0  32        bl   @jsr                       ;
     A41A FF10     
21518                                                                          ; the price of the pulse laser we are exchanging for a
21519                                                                          ; new beam laser
21520               
21521               ed5_:
21522 A41C 0200  20        li   ra,(POW+128)*256           ; LDA #POW+128      ; We just bought a beam laser for view X, so we need
     A41E 8F00     
21523 A420 D060  30        movb @T1,rx                     ; LDX T1            ; to fit it by storing the laser power for a beam laser
     A422 0006     
21524 A424 D840  38        movb ra,@LASER(rx)              ; STA LASER,X       ; (given in POW+128) in LASER+X, using the view number
     A426 0310     
21525                                                                          ; we stored in T1 earlier, as the call to prx will have
21526                                                                          ; overwritten the original value in X
21527               
21528               et5_:
21529 A428 0202  20        li   ry,>6f*256                 ; LDY #111          ; Set Y to recursive token 107 ("FUEL SCOOPS")
     A42A 6F00     
21530               
21531 A42C 0280  22        ci   ra,>06*256                 ; CMP #6            ; If A is not 6 (i.e. the item we've just bought is not
     A42E 0600     
21532 A430 1620  14        jne  et6_                       ; BNE et6           ; a fuel scoop), skip to et6
21533               
21534 A432 D060  30        movb @BST,rx                    ; LDX BST           ; If we already have fuel scoops fitted (i.e. BST is
     A434 0329     
21535 A436 131C  14        jeq  ed9_                       ; BEQ ed9           ; zero), jump to ed9, otherwise fall through into pres
21536                                                                          ; to show the error "Fuel Scoops Present", beep and
21537                                                                          ; exit to the docking bay (i.e. show the Status Mode
21538                                                                          ; screen)
21539               
21540               pres_:
21541                                                                          ; If we get here we need to show an error to say that
21542                                                                          ; the item whose name is in recursive token Y is already
21543                                                                          ; present, and then process a refund for the cost of
21544                                                                          ; item number A
21545 A438 D802  30        movb ry,@K                      ; STY K             ; Store the item's name in K
     A43A 003D     
21546               
21547 A43C 0206  20        li   rtmp,prx_                  ; JSR prx           ; Call prx to set (Y X) to the price of equipment item
     A43E A524     
21548 A440 06A0  32        bl   @jsr                       ;
     A442 FF10     
21549                                                                          ; number A
21550               
21551 A444 0206  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH, as the station
     A446 A1BE     
21552 A448 06A0  32        bl   @jsr                       ;
     A44A FF10     
21553                                                                          ; already took the money for this item in the JSR eq
21554                                                                          ; instruction above, but we can't fit the item, so need
21555                                                                          ; our money back
21556               
21557 A44C D020  30        movb @K,ra                      ; LDA K             ; Print the recursive token in K (the item's name)
     A44E 003D     
21558 A450 0206  20        li   rtmp,spc_                  ; JSR spc           ; followed by a space
     A452 4EFE     
21559 A454 06A0  32        bl   @jsr                       ;
     A456 FF10     
21560               
21561 A458 0200  20        li   ra,>1f*256                 ; LDA #31           ; Print recursive token 145 ("PRESENT")
     A45A 1F00     
21562 A45C 0206  20        li   rtmp,TT27                  ; JSR TT27
     A45E A6E8     
21563 A460 06A0  32        bl   @jsr                       ;
     A462 FF10     
21564               
21565               err_:
21566 A464 0206  20        li   rtmp,dn2_                  ; JSR dn2           ; Call dn2 to make a short, high beep and delay for 1
     A466 A4E8     
21567 A468 06A0  32        bl   @jsr                       ;
     A46A FF10     
21568                                                                          ; second
21569               
21570 A46C 0460  28        b    @BAY                       ; JMP BAY           ; Jump to BAY to go to the docking bay (i.e. show the
     A46E C65C     
21571                                                                          ; Status Mode screen)
21572               
21573               ed9_:
21574 A470 7004  18        sb   rone,ra                    ; DEC BST           ; We just bought a shiny new fuel scoop, so set BST to
21575                                                                          ; &FF (as BST was 0 before the jump to ed9 above)
21576               
21577               et6_:
21578 A472 B084  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 112 ("E.C.M.SYSTEM")
21579               
21580 A474 0280  22        ci   ra,>07*256                 ; CMP #7            ; If A is not 7 (i.e. the item we've just bought is not
     A476 0700     
21581 A478 1604  14        jne  et7_                       ; BNE et7           ; an escape pod), skip to et7
21582               
21583 A47A D060  30        movb @ESCP,rx                   ; LDX ESCP          ; If we already have an escape pod fitted (i.e. ESCP is
     A47C 032E     
21584 A47E 16DC  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "Escape Pod
21585                                                                          ; Present", beep and exit to the docking bay (i.e. show
21586                                                                          ; the Status Mode screen)
21587               
21588 A480 7004  18        sb   rone,ra                    ; DEC ESCP          ; Otherwise we just bought an escape pod, so set ESCP
21589                                                                          ; to &FF (as ESCP was 0 before the DEC instruction)
21590               
21591               et7_:
21592 A482 B084  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 113 ("ENERGY BOMB")
21593               
21594 A484 0280  22        ci   ra,>08*256                 ; CMP #8            ; If A is not 8 (i.e. the item we've just bought is not
     A486 0800     
21595 A488 1607  14        jne  et8_                       ; BNE et8           ; an energy bomb), skip to et8
21596               
21597 A48A D060  30        movb @BOMB,rx                   ; LDX BOMB          ; If we already have an energy bomb fitted (i.e. BOMB
     A48C 032A     
21598 A48E 16D4  14        jne  pres_                      ; BNE pres          ; is non-zero), jump to pres to show the error "Energy
21599                                                                          ; Bomb Present", beep and exit to the docking bay (i.e.
21600                                                                          ; show the Status Mode screen)
21601               
21602 A490 0201  20        li   rx,>7f*256                 ; LDX #&7F          ; Otherwise we just bought an energy bomb, so set BOMB
     A492 7F00     
21603 A494 D801  30        movb rx,@BOMB                   ; STX BOMB          ; to &7F
     A496 032A     
21604               
21605               et8_:
21606 A498 B084  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 114 ("ENERGY UNIT")
21607               
21608 A49A 0280  22        ci   ra,>09*256                 ; CMP #9            ; If A is not 9 (i.e. the item we've just bought is not
     A49C 0900     
21609 A49E 1604  14        jne  etA                        ; BNE etA           ; an energy unit), skip to etA
21610               
21611 A4A0 D060  30        movb @ENGY,rx                   ; LDX ENGY          ; If we already have an energy unit fitted (i.e. ENGY is
     A4A2 032B     
21612 A4A4 16C9  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "Energy Unit
21613                                                                          ; Present", beep and exit to the docking bay (i.e. show
21614                                                                          ; the Status Mode screen)
21615               
21616 A4A6 B004  18        ab   rone,ra                    ; INC ENGY          ; Otherwise we just picked up an energy unit, so set
21617                                                                          ; ENGY to 1 (as ENGY was 0 before the INC instruction)
21618               
21619               etA:
21620 A4A8 B084  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 115 ("DOCKING
21621                                                                          ; COMPUTERS")
21622               
21623 A4AA 0280  22        ci   ra,>0a*256                 ; CMP #10           ; If A is not 10 (i.e. the item we've just bought is not
     A4AC 0A00     
21624 A4AE 1604  14        jne  etB                        ; BNE etB           ; a docking computer), skip to etB
21625               
21626 A4B0 D060  30        movb @DKCMP,rx                  ; LDX DKCMP         ; If we already have a docking computer fitted (i.e.
     A4B2 032C     
21627 A4B4 16C1  14        jne  pres_                      ; BNE pres          ; DKCMP is non-zero), jump to pres to show the error
21628                                                                          ; "Docking Computer Present", beep and exit to the
21629                                                                          ; docking bay (i.e. show the Status Mode screen)
21630               
21631 A4B6 7004  18        sb   rone,ra                    ; DEC DKCMP         ; Otherwise we just got hold of a docking computer, so
21632                                                                          ; set DKCMP to &FF (as DKCMP was 0 before the DEC
21633                                                                          ; instruction)
21634               
21635               etB:
21636 A4B8 B084  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 116 ("GALACTIC
21637                                                                          ; HYPERSPACE ")
21638               
21639 A4BA 0280  22        ci   ra,>0b*256                 ; CMP #11           ; If A is not 11 (i.e. the item we've just bought is not
     A4BC 0B00     
21640 A4BE 1604  14        jne  et9_                       ; BNE et9           ; a galactic hyperdrive), skip to et9
21641               
21642 A4C0 D060  30        movb @GHYP,rx                   ; LDX GHYP          ; If we already have a galactic hyperdrive fitted (i.e.
     A4C2 032D     
21643 A4C4 16B9  14        jne  pres_                      ; BNE pres          ; GHYP is non-zero), jump to pres to show the error
21644                                                                          ; "Galactic Hyperspace Present", beep and exit to the
21645                                                                          ; docking bay (i.e. show the Status Mode screen)
21646               
21647 A4C6 7004  18        sb   rone,ra                    ; DEC GHYP          ; Otherwise we just splashed out on a galactic
21648                                                                          ; hyperdrive, so set GHYP to &FF (as GHYP was 0 before
21649                                                                          ; the DEC instruction)
21650               
21651               et9_:
21652 A4C8 0206  20        li   rtmp,dn_                   ; JSR dn            ; We are done buying equipment, so print the amount of
     A4CA A4D4     
21653 A4CC 06A0  32        bl   @jsr                       ;
     A4CE FF10     
21654                                                                          ; cash left in the cash pot, then make a short, high
21655                                                                          ; beep to confirm the purchase, and delay for 1 second
21656               
21657 A4D0 0460  28        b    @EQSHP                     ; JMP EQSHP         ; Jump back up to EQSHP to show the Equip Ship screen
     A4D2 A23C     
21658                                                                          ; again and see if we can't track down another bargain
21659               
21660               * ******************************************************************************
21661               *
21662               * Name: dn
21663               * Type: Subroutine
21664               * Category: Market
21665               * Summary: Print the amount of money we have left in the cash pot, then make
21666               * a short, high beep and delay for 1 second
21667               *
21668               * ******************************************************************************
21669               
21670               dn_:
21671 A4D4 0206  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     A4D6 5E64     
21672 A4D8 06A0  32        bl   @jsr                       ;
     A4DA FF10     
21673               
21674 A4DC 0200  20        li   ra,>77*256                 ; LDA #119          ; Print recursive token 119 ("CASH:{cash} CR{crlf}")
     A4DE 7700     
21675 A4E0 0206  20        li   rtmp,spc_                  ; JSR spc           ; followed by a space
     A4E2 4EFE     
21676 A4E4 06A0  32        bl   @jsr                       ;
     A4E6 FF10     
21677               
21678                                                                          ; Fall through into dn2 to make a beep and delay for
21679                                                                          ; 1 second before returning from the subroutine
21680               
21681               * ******************************************************************************
21682               *
21683               * Name: dn2
21684               * Type: Subroutine
21685               * Category: Text
21686               * Summary: Make a short, high beep and delay for 1 second
21687               *
21688               * ******************************************************************************
21689               
21690               dn2_:
21691 A4E8 0206  20        li   rtmp,BEEP                  ; JSR BEEP          ; Call the BEEP subroutine to make a short, high beep
     A4EA CBAC     
21692 A4EC 06A0  32        bl   @jsr                       ;
     A4EE FF10     
21693               
21694 A4F0 0202  20        li   ry,>32*256                 ; LDY #50           ; Delay for 50 vertical syncs (50/50 = 1 second) and
     A4F2 3200     
21695 A4F4 0460  28        b    @DELAY                     ; JMP DELAY         ; return from the subroutine using a tail call
     A4F6 4C00     
21696               
21697               * ******************************************************************************
21698               *
21699               * Name: eq
21700               * Type: Subroutine
21701               * Category: Equipment
21702               * Summary: Subtract the price of equipment from the cash pot
21703               *
21704               * ------------------------------------------------------------------------------
21705               *
21706               * If we have enough cash, subtract the price of a specified piece of equipment
21707               * from our cash pot and return from the subroutine. If we don't have enough
21708               * cash, exit to the docking bay (i.e. show the Status Mode screen).
21709               *
21710               * ------------------------------------------------------------------------------
21711               *
21712               * Arguments:
21713               *
21714               * A                   The item number of the piece of equipment (0-11) as
21715               * shown in the table at PRXS
21716               *
21717               * ******************************************************************************
21718               
21719               eq_:
21720 A4F8 0206  20        li   rtmp,prx_                  ; JSR prx           ; Call prx to set (Y X) to the price of equipment item
     A4FA A524     
21721 A4FC 06A0  32        bl   @jsr                       ;
     A4FE FF10     
21722                                                                          ; number A
21723               
21724 A500 0206  20        li   rtmp,LCASH                 ; JSR LCASH         ; Subtract (Y X) cash from the cash pot, but only if
     A502 A172     
21725 A504 06A0  32        bl   @jsr                       ;
     A506 FF10     
21726                                                                          ; we have enough cash
21727               
21728 A508 1816  14        joc  c_                         ; BCS c             ; If the C flag is set then we did have enough cash for
21729                                                                          ; the transaction, so jump to c to return from the
21730                                                                          ; subroutine (as c contains an RTS)
21731               
21732 A50A 0200  20        li   ra,>c5*256                 ; LDA #197          ; Otherwise we don't have enough cash to buy this piece
     A50C C500     
21733 A50E 0206  20        li   rtmp,prq_                  ; JSR prq           ; of equipment, so print recursive token 37 ("CASH")
     A510 5D52     
21734 A512 06A0  32        bl   @jsr                       ;
     A514 FF10     
21735                                                                          ; followed by a question mark
21736               
21737 A516 0460  28        b    @err_                      ; JMP err           ; Jump to err to beep, pause and go to the docking bay
     A518 A464     
21738                                                                          ; (i.e. show the Status Mode screen)
21739               
21740               * ******************************************************************************
21741               *
21742               * Name: prx
21743               * Type: Subroutine
21744               * Category: Equipment
21745               * Summary: Return the price of a piece of equipment
21746               *
21747               * ------------------------------------------------------------------------------
21748               *
21749               * This routine returns the price of equipment as listed in the table at PRXS.
21750               *
21751               * ------------------------------------------------------------------------------
21752               *
21753               * Arguments:
21754               *
21755               * A                   The item number of the piece of equipment (0-11) as
21756               * shown in the table at PRXS
21757               *
21758               * ------------------------------------------------------------------------------
21759               *
21760               * Returns:
21761               *
21762               * (Y X)               The item price in Cr * 10 (Y = high byte, X = low byte)
21763               *
21764               * ------------------------------------------------------------------------------
21765               *
21766               * Other entry points:
21767               *
21768               * prx-3               Return the price of the item with number A - 1
21769               *
21770               * c                   Contains an RTS
21771               *
21772               * ******************************************************************************
21773               
21774                      .sec                            ; SEC               ; Decrement A (for when this routine is called via
     **** ****     > SEC
0001 A51A 0A15  18        sla  rmone,1
                   < elite.a99
21775                      .sbi (>01*256)                  ; SBC #1            ; prx-3)
     **** ****     > SBI
0001 A51C 1801  14        joc  !
0002 A51E 7004  18        sb   rone,ra
0003               !:
0004 A520 0220  22        ai   ra,-(>01*256)
     A522 FF00     
                   < elite.a99
21776               
21777               prx_:
21778                      .asla                           ; ASL A             ; Set Y = A * 2, so it can act as an index into the
     **** ****     > ASLA
0001 A524 0240  22        andi ra,>ff00
     A526 FF00     
0002 A528 0A10  18        sla  ra,1
                   < elite.a99
21779 A52A D080  18        movb ra,ry                      ; TAY               ; PRXS table, which has two bytes per entry
21780               
21781 A52C D062  34        movb @PRXS(ry),rx               ; LDX PRXS,Y        ; Fetch the low byte of the price into X
     A52E 2DF0     
21782               
21783 A530 D022  34        movb @PRXS+1(ry),ra             ; LDA PRXS+1,Y      ; Fetch the high byte of the price into A and transfer
     A532 2DF1     
21784 A534 D080  18        movb ra,ry                      ; TAY               ; it to X, so the price is now in (Y X)
21785               
21786               c_:
21787 A536 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A538 FF1C     
21788               
21789               * ******************************************************************************
21790               *
21791               * Name: qv
21792               * Type: Subroutine
21793               * Category: Equipment
21794               * Summary: Print a menu of the four space views, for buying lasers
21795               *
21796               * ------------------------------------------------------------------------------
21797               *
21798               * Print a menu in the bottom-middle of the screen, at row 16, column 12, that
21799               * lists the four available space views, like this:
21800               *
21801               * 0 Front
21802               * 1 Rear
21803               * 2 Left
21804               * 3 Right
21805               *
21806               * Also print a "View ?" prompt and ask for a view number. The menu is shown
21807               * when we choose to buy a new laser in the Equip Ship screen.
21808               *
21809               * ------------------------------------------------------------------------------
21810               *
21811               * Returns:
21812               *
21813               * X                   The chosen view number (0-3)
21814               *
21815               * ******************************************************************************
21816               
21817               qv_:
21818 A53A 0202  20        li   ry,>10*256                 ; LDY #16           ; Move the text cursor to row 16, and at the same time
     A53C 1000     
21819 A53E D802  30        movb ry,@YC                     ; STY YC            ; set Y to a counter going from 16 to 19 in the loop
     A540 002D     
21820                                                                          ; below
21821               
21822               qv1_:
21823 A542 0201  20        li   rx,>0c*256                 ; LDX #12           ; Move the text cursor to column 12
     A544 0C00     
21824 A546 D801  30        movb rx,@XC                     ; STX XC
     A548 002C     
21825               
21826 A54A D002  18        movb ry,ra                      ; TYA               ; Transfer the counter value from Y to A
21827               
21828                      .clc                            ; CLC               ; Print ASCII character "0" - 16 + A, so as A goes from
     **** ****     > CLC
0001 A54C 0A13  18        sla  rzero,1
                   < elite.a99
21829                      .adi (('0'-16)*256)             ; ADC #'0'-16       ; 16 to 19, this prints "0" through "3" followed by a
     **** ****     > ADI
0001 A54E 1701  14        jnc  !
0002 A550 B004  18        ab   rone,ra
0003               !:
0004 A552 0220  22        ai   ra,(('0'-16)*256)
     A554 2000     
                   < elite.a99
21830 A556 0206  20        li   rtmp,spc_                  ; JSR spc           ; space
     A558 4EFE     
21831 A55A 06A0  32        bl   @jsr                       ;
     A55C FF10     
21832               
21833 A55E D020  30        movb @YC,ra                     ; LDA YC            ; Print recursive text token 80 + YC, so as YC goes from
     A560 002D     
21834                      .clc                            ; CLC               ; 16 to 19, this prints "FRONT", "REAR", "LEFT" and
     **** ****     > CLC
0001 A562 0A13  18        sla  rzero,1
                   < elite.a99
21835                      .adi (>50*256)                  ; ADC #80           ; "RIGHT"
     **** ****     > ADI
0001 A564 1701  14        jnc  !
0002 A566 B004  18        ab   rone,ra
0003               !:
0004 A568 0220  22        ai   ra,(>50*256)
     A56A 5000     
                   < elite.a99
21836 A56C 0206  20        li   rtmp,TT27                  ; JSR TT27
     A56E A6E8     
21837 A570 06A0  32        bl   @jsr                       ;
     A572 FF10     
21838               
21839 A574 B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a row, and increment the
21840                                                                          ; counter in YC at the same time
21841               
21842 A576 D0A0  30        movb @YC,ry                     ; LDY YC            ; Update Y with the incremented counter in YC
     A578 002D     
21843               
21844 A57A 0282  22        ci   ry,>14*256                 ; CPY #20           ; If Y < 20 then loop back up to qv1 to print the next
     A57C 1400     
21845 A57E 17E1  14        jnc  qv1_                       ; BCC qv1           ; view in the menu
21846               
21847               qv3_:
21848 A580 0206  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     A582 4C2E     
21849 A584 06A0  32        bl   @jsr                       ;
     A586 FF10     
21850                                                                          ; and move the text cursor to column 1 on row 21, i.e.
21851                                                                          ; the start of the top row of the three bottom rows
21852               
21853               qv2_:
21854 A588 0200  20        li   ra,>af*256                 ; LDA #175          ; Print recursive text token 15 ("VIEW ") followed by
     A58A AF00     
21855 A58C 0206  20        li   rtmp,prq_                  ; JSR prq           ; a question mark
     A58E 5D52     
21856 A590 06A0  32        bl   @jsr                       ;
     A592 FF10     
21857               
21858 A594 0206  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     A596 CE00     
21859 A598 06A0  32        bl   @jsr                       ;
     A59A FF10     
21860                                                                          ; the key's ASCII code in A (and X)
21861               
21862                      .sec                            ; SEC               ; Subtract ASCII "0" from the key pressed, to leave the
     **** ****     > SEC
0001 A59C 0A15  18        sla  rmone,1
                   < elite.a99
21863                      .sbi (('0')*256)                ; SBC #'0'          ; numeric value of the key in A (if it was a number key)
     **** ****     > SBI
0001 A59E 1801  14        joc  !
0002 A5A0 7004  18        sb   rone,ra
0003               !:
0004 A5A2 0220  22        ai   ra,-(('0')*256)
     A5A4 D000     
                   < elite.a99
21864               
21865 A5A6 0280  22        ci   ra,>04*256                 ; CMP #4            ; If the number entered in A >= 4, then it is not a
     A5A8 0400     
21866 A5AA 18EA  14        joc  qv3_                       ; BCS qv3           ; valid view number, so jump back to qv3 to try again
21867               
21868 A5AC D040  18        movb ra,rx                      ; TAX               ; We have a valid view number, so transfer it to X
21869               
21870 A5AE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A5B0 FF1C     
21871               
21872               * ******************************************************************************
21873               *
21874               * Save ELTD.bin
21875               *
21876               * ******************************************************************************
21877               
21878                      ; PRINT "ELITE D"
21879                      ; PRINT "Assembled at ", ~CODE_D%
21880                      ; PRINT "Ends at ", ~P%
21881                      ; PRINT "Code size is ", ~(P% - CODE_D%)
21882                      ; PRINT "Execute at ", ~LOAD%
21883                      ; PRINT "Reload at ", ~LOAD_D%
21884               
21885                      ; PRINT "S.ELTD ", ~CODE_D%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_D%
21886                      ; SAVE "3-assembled-output/ELTD.bin", CODE_D%, P%, LOAD%
21887               
21888               * ******************************************************************************
21889               *
21890               * ELITE E FILE
21891               *
21892               * Produces the binary file ELTE.bin that gets loaded by elite-bcfs.asm.
21893               *
21894               * ******************************************************************************
21895               
21896               CODE_E.:
21897                      equ $
21898               
21899               LOAD_E.:
21900                      equ LOAD. + $ - CODE.
21901               
21902               * ******************************************************************************
21903               *
21904               * Name: Authors' names
21905               * Type: Variable
21906               * Category: Copy protection
21907               * Summary: The authors' names and a copyright notice, buried in the code
21908               *
21909               * ------------------------------------------------------------------------------
21910               *
21911               * This copyright notice is not used anywhere and it is obfuscated by EOR'ing
21912               * each character with 164, but presumably the authors wanted their names buried
21913               * in the code somewhere. Though they do also have recursive token 94, which
21914               * reads "BY D.BRABEN & I.BELL" and can be displayed on the title screen using
21915               * the "X" configuration option, so this isn't the only author name easter egg
21916               * in the game. It contains the following text:
21917               *
21918               * (C)Bell/Braben1984
21919               *
21920               * ******************************************************************************
21921               
21922 A5B2 8C              byte '(' ^ 164
21923 A5B3   E7            byte 'C' ^ 164
21924 A5B4 8D              byte ')' ^ 164
21925 A5B5   E6            byte 'B' ^ 164
21926 A5B6 C1              byte 'e' ^ 164
21927 A5B7   C8            byte 'l' ^ 164
21928 A5B8 C8              byte 'l' ^ 164
21929 A5B9   8B            byte '/' ^ 164
21930 A5BA E6              byte 'B' ^ 164
21931 A5BB   D6            byte 'r' ^ 164
21932 A5BC C5              byte 'a' ^ 164
21933 A5BD   C6            byte 'b' ^ 164
21934 A5BE C1              byte 'e' ^ 164
21935 A5BF   CA            byte 'n' ^ 164
21936 A5C0 95              byte '1' ^ 164
21937 A5C1   9D            byte '9' ^ 164
21938 A5C2 9C              byte '8' ^ 164
21939 A5C3   90            byte '4' ^ 164
21940               
21941               * ******************************************************************************
21942               *
21943               * Name: cpl
21944               * Type: Subroutine
21945               * Category: Universe
21946               * Summary: Print the selected system name
21947               * Deep dive: Generating system names
21948               * Galaxy and system seeds
21949               *
21950               * ------------------------------------------------------------------------------
21951               *
21952               * Print control code 3 (the selected system name, i.e. the one in the crosshairs
21953               * in the Short-range Chart).
21954               *
21955               * ******************************************************************************
21956               
21957               cpl_:
21958 A5C4 0201  20        li   rx,>05*256                 ; LDX #5            ; First we need to back up the seeds in QQ15, so set up
     A5C6 0500     
21959                                                                          ; a counter in X to cover three 16-bit seeds (i.e.
21960                                                                          ; 6 bytes)
21961               
21962               TT53:
21963 A5C8 D021  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy byte X from QQ15 to QQ19
     A5CA 0078     
21964 A5CC D840  38        movb ra,@QQ19(rx)               ; STA QQ19,X
     A5CE 007F     
21965               
21966 A5D0 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
21967               
21968 A5D2 15FA  14        jgt  TT53                       ; BPL TT53          ; Loop back for the next byte to back up
21969               
21970 A5D4 0202  20        li   ry,>03*256                 ; LDY #3            ; Step 1: Now that the seeds are backed up, we can
     A5D6 0300     
21971                                                                          ; start the name-generation process. We will either
21972                                                                          ; need to loop three or four times, so for now set
21973                                                                          ; up a counter in Y to loop four times
21974               
21975                      .bit @QQ15                      ; BIT QQ15          ; Check bit 6 of s0_lo, which is stored in QQ15
     **** ****     > BIT
0001 A5D8 D1A0  30        movb @QQ15,rtmp
     A5DA 0078     
0002 A5DC 0546  14        inv  rtmp
0003 A5DE D1C4  18        movb rone,rtmp2
0004 A5E0 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
21976               
21977                      .bvs B59                        ; BVS B59           ; If bit 6 is set then skip over the next instruction
     **** ****     > BVS
0001 A5E2 1801  14        joc  !
0002 A5E4 1001  14        jmp  B59
0003               !:
                   < elite.a99
21978               
21979 A5E6 7084  18        sb   rone,ry                    ; DEY               ; Bit 6 is clear, so we only want to loop three times,
21980                                                                          ; so decrement the loop counter in Y
21981               
21982               B59:
21983 A5E8 D802  30        movb ry,@T                      ; STY T             ; Store the loop counter in T
     A5EA 00D1     
21984               
21985               TT55:
21986 A5EC D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Step 2: Load s2_hi, which is stored in QQ15+5, and
     A5EE 007D     
21987 A5F0 0240  22        andi ra,>1f*256                 ; AND #%00011111    ; extract bits 0-4 by AND'ing with %11111
     A5F2 1F00     
21988               
21989 A5F4 1306  14        jeq  B60                        ; BEQ B60           ; If all those bits are zero, then skip the following
21990                                                                          ; two instructions to go to step 3
21991               
21992 A5F6 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now have a number in the range 1-31, which we can
     A5F8 8000     
21993                                                                          ; easily convert into a two-letter token, but first we
21994                                                                          ; need to add 128 (or set bit 7) to get a range of
21995                                                                          ; 129-159
21996               
21997 A5FA 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the two-letter token in A
     A5FC A6E8     
21998 A5FE 06A0  32        bl   @jsr                       ;
     A600 FF10     
21999               
22000               B60:
22001 A602 0206  20        li   rtmp,TT54                  ; JSR TT54          ; Step 3: twist the seeds in QQ15
     A604 4E42     
22002 A606 06A0  32        bl   @jsr                       ;
     A608 FF10     
22003               
22004 A60A 7004  18        sb   rone,ra                    ; DEC T             ; Decrement the loop counter
22005               
22006 A60C 15EF  14        jgt  TT55                       ; BPL TT55          ; Loop back for the next two letters
22007               
22008 A60E 0201  20        li   rx,>05*256                 ; LDX #5            ; We have printed the system name, so we can now
     A610 0500     
22009                                                                          ; restore the seeds we backed up earlier. Set up a
22010                                                                          ; counter in X to cover three 16-bit seeds (i.e. 6
22011                                                                          ; bytes)
22012               
22013               TT56:
22014 A612 D021  34        movb @QQ19(rx),ra               ; LDA QQ19,X        ; Copy byte X from QQ19 to QQ15
     A614 007F     
22015 A616 D840  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     A618 0078     
22016               
22017 A61A 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22018               
22019 A61C 15FA  14        jgt  TT56                       ; BPL TT56          ; Loop back for the next byte to restore
22020               
22021 A61E 0460  28        b    @rts                       ; RTS               ; Once all the seeds are restored, return from the
     A620 FF1C     
22022                                                                          ; subroutine
22023               
22024               * ******************************************************************************
22025               *
22026               * Name: cmn
22027               * Type: Subroutine
22028               * Category: Status
22029               * Summary: Print the commander's name
22030               *
22031               * ------------------------------------------------------------------------------
22032               *
22033               * Print control code 4 (the commander's name).
22034               *
22035               * ------------------------------------------------------------------------------
22036               *
22037               * Other entry points:
22038               *
22039               * cmn-1               Contains an RTS
22040               *
22041               * ******************************************************************************
22042               
22043               cmn_:
22044 A622 0202  20        li   ry,>00*256                 ; LDY #0            ; Set up a counter in Y, starting from 0
     A624 0000     
22045               
22046               QUL4:
22047 A626 D022  34        movb @NA.(ry),ra                ; LDA NA%,Y         ; The commander's name is stored at NA%, so load the
     A628 21C8     
22048                                                                          ; Y-th character from NA%
22049               
22050 A62A 0280  22        ci   ra,>0d*256                 ; CMP #13           ; If we have reached the end of the name, return from
     A62C 0D00     
22051 A62E 1307  14        jeq  ypl_-1                     ; BEQ ypl-1         ; the subroutine (ypl-1 points to the RTS below)
22052               
22053 A630 0206  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character we just loaded
     A632 3172     
22054 A634 06A0  32        bl   @jsr                       ;
     A636 FF10     
22055               
22056 A638 B084  18        ab   rone,ry                    ; INY               ; Increment the loop counter
22057               
22058 A63A 16F5  14        jne  QUL4                       ; BNE QUL4          ; Loop back for the next character
22059               
22060 A63C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A63E FF1C     
22061               
22062               * ******************************************************************************
22063               *
22064               * Name: ypl
22065               * Type: Subroutine
22066               * Category: Universe
22067               * Summary: Print the current system name
22068               *
22069               * ------------------------------------------------------------------------------
22070               *
22071               * Print control code 2 (the current system name).
22072               *
22073               * ------------------------------------------------------------------------------
22074               *
22075               * Other entry points:
22076               *
22077               * ypl-1               Contains an RTS
22078               *
22079               * ******************************************************************************
22080               
22081               ypl_:
22082 A640 D020  30        movb @MJ,ra                     ; LDA MJ            ; Check the mis-jump flag at MJ, and if it is non-zero
     A642 0D5C     
22083 A644 16ED  14        jne  cmn_-1                     ; BNE cmn-1         ; then we are in witchspace, and witchspace doesn't have
22084                                                                          ; a system name, so return from the subroutine (cmn-1
22085                                                                          ; contains an RTS)
22086               
22087 A646 0206  20        li   rtmp,TT62                  ; JSR TT62          ; Call TT62 below to swap the three 16-bit seeds in
     A648 A656     
22088 A64A 06A0  32        bl   @jsr                       ;
     A64C FF10     
22089                                                                          ; QQ2 and QQ15 (before the swap, QQ2 contains the seeds
22090                                                                          ; for the current system, while QQ15 contains the seeds
22091                                                                          ; for the selected system)
22092               
22093 A64E 0206  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print out the system name for the seeds
     A650 A5C4     
22094 A652 06A0  32        bl   @jsr                       ;
     A654 FF10     
22095                                                                          ; in QQ15 (which now contains the seeds for the current
22096                                                                          ; system)
22097               
22098                                                                          ; Now we fall through into the TT62 subroutine, which
22099                                                                          ; will swap QQ2 and QQ15 once again, so everything goes
22100                                                                          ; back into the right place, and the RTS at the end of
22101                                                                          ; TT62 will return from the subroutine
22102               
22103               TT62:
22104 A656 0201  20        li   rx,>05*256                 ; LDX #5            ; Set up a counter in X for the three 16-bit seeds we
     A658 0500     
22105                                                                          ; want to swap (i.e. 6 bytes)
22106               
22107               TT78:
22108 A65A D021  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Swap byte X between QQ2 and QQ15
     A65C 0078     
22109 A65E D0A1  34        movb @QQ2(rx),ry                ; LDY QQ2,X
     A660 0F22     
22110 A662 D840  38        movb ra,@QQ2(rx)                ; STA QQ2,X
     A664 0F22     
22111 A666 D842  38        movb ry,@QQ15(rx)               ; STY QQ15,X
     A668 0078     
22112               
22113 A66A 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22114               
22115 A66C 15F6  14        jgt  TT78                       ; BPL TT78          ; Loop back for the next byte to swap
22116               
22117 A66E 0460  28        b    @rts                       ; RTS               ; Once all bytes are swapped, return from the
     A670 FF1C     
22118                                                                          ; subroutine
22119               
22120               * ******************************************************************************
22121               *
22122               * Name: tal
22123               * Type: Subroutine
22124               * Category: Universe
22125               * Summary: Print the current galaxy number
22126               *
22127               * ------------------------------------------------------------------------------
22128               *
22129               * Print control code 1 (the current galaxy number, right-aligned to width 3).
22130               *
22131               * ******************************************************************************
22132               
22133               tal_:
22134                      .clc                            ; CLC               ; We don't want to print the galaxy number with a
     **** ****     > CLC
0001 A672 0A13  18        sla  rzero,1
                   < elite.a99
22135                                                                          ; decimal point, so clear the C flag for pr2 to take as
22136                                                                          ; an argument
22137               
22138 A674 D060  30        movb @GCNT,rx                   ; LDX GCNT          ; Load the current galaxy number from GCNT into X
     A676 030F     
22139               
22140 A678 B044  18        ab   rone,rx                    ; INX               ; Add 1 to the galaxy number, as the galaxy numbers
22141                                                                          ; are 0-7 internally, but we want to display them as
22142                                                                          ; galaxy 1 through 8
22143               
22144 A67A 0460  28        b    @pr2_                      ; JMP pr2           ; Jump to pr2, which prints the number in X to a width
     A67C 2FAC     
22145                                                                          ; of 3 figures, left-padding with spaces to a width of
22146                                                                          ; 3, and return from the subroutine using a tail call
22147               
22148               * ******************************************************************************
22149               *
22150               * Name: fwl
22151               * Type: Subroutine
22152               * Category: Status
22153               * Summary: Print fuel and cash levels
22154               *
22155               * ------------------------------------------------------------------------------
22156               *
22157               * Print control code 5 ("FUEL: ", fuel level, " LIGHT YEARS", newline, "CASH:",
22158               * control code 0).
22159               *
22160               * ******************************************************************************
22161               
22162               fwl_:
22163 A67E 0200  20        li   ra,>69*256                 ; LDA #105          ; Print recursive token 105 ("FUEL") followed by a
     A680 6900     
22164 A682 0206  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     A684 A6DC     
22165 A686 06A0  32        bl   @jsr                       ;
     A688 FF10     
22166               
22167 A68A D060  30        movb @QQ14,rx                   ; LDX QQ14          ; Load the current fuel level from QQ14
     A68C 030D     
22168               
22169                      .sec                            ; SEC               ; We want to print the fuel level with a decimal point,
     **** ****     > SEC
0001 A68E 0A15  18        sla  rmone,1
                   < elite.a99
22170                                                                          ; so set the C flag for pr2 to take as an argument
22171               
22172 A690 0206  20        li   rtmp,pr2_                  ; JSR pr2           ; Call pr2, which prints the number in X to a width of
     A692 2FAC     
22173 A694 06A0  32        bl   @jsr                       ;
     A696 FF10     
22174                                                                          ; 3 figures (i.e. in the format x.x, which will always
22175                                                                          ; be exactly 3 characters as the maximum fuel is 7.0)
22176               
22177 A698 0200  20        li   ra,>c3*256                 ; LDA #195          ; Print recursive token 35 ("LIGHT YEARS") followed by
     A69A C300     
22178 A69C 0206  20        li   rtmp,plf_                  ; JSR plf           ; a newline
     A69E A6D0     
22179 A6A0 06A0  32        bl   @jsr                       ;
     A6A2 FF10     
22180               
22181               PCASH:
22182 A6A4 0200  20        li   ra,>77*256                 ; LDA #119          ; Print recursive token 119 ("CASH:" then control code
     A6A6 7700     
22183 A6A8 161F  14        jne  TT27                       ; BNE TT27          ; 0, which prints cash levels, then " CR" and newline)
22184               
22185               * ******************************************************************************
22186               *
22187               * Name: csh
22188               * Type: Subroutine
22189               * Category: Status
22190               * Summary: Print the current amount of cash
22191               *
22192               * ------------------------------------------------------------------------------
22193               *
22194               * Print control code 0 (the current amount of cash, right-aligned to width 9,
22195               * followed by " CR" and a newline).
22196               *
22197               * ******************************************************************************
22198               
22199               csh_:
22200 A6AA 0201  20        li   rx,>03*256                 ; LDX #3            ; We are going to use the BPRNT routine to print out
     A6AC 0300     
22201                                                                          ; the current amount of cash, which is stored as a
22202                                                                          ; 32-bit number at location CASH. BPRNT prints out
22203                                                                          ; the 32-bit number stored in K, so before we call
22204                                                                          ; BPRNT, we need to copy the four bytes from CASH into
22205                                                                          ; K, so first we set up a counter in X for the 4 bytes
22206               
22207               pc1_:
22208 A6AE D021  34        movb @CASH(rx),ra               ; LDA CASH,X        ; Copy byte X from CASH to K
     A6B0 0309     
22209 A6B2 D840  38        movb ra,@K(rx)                  ; STA K,X
     A6B4 003D     
22210               
22211 A6B6 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22212               
22213 A6B8 15FA  14        jgt  pc1_                       ; BPL pc1           ; Loop back for the next byte to copy
22214               
22215 A6BA 0200  20        li   ra,>09*256                 ; LDA #9            ; We want to print the cash amount using up to 9 digits
     A6BC 0900     
22216 A6BE D800  30        movb ra,@U                      ; STA U             ; (including the decimal point), so store this in U
     A6C0 008F     
22217                                                                          ; for BRPNT to take as an argument
22218               
22219                      .sec                            ; SEC               ; We want to print the cash amount with a decimal point,
     **** ****     > SEC
0001 A6C2 0A15  18        sla  rmone,1
                   < elite.a99
22220                                                                          ; so set the C flag for BRPNT to take as an argument
22221               
22222 A6C4 0206  20        li   rtmp,BPRNT                 ; JSR BPRNT         ; Print the amount of cash to 9 digits with a decimal
     A6C6 2FCC     
22223 A6C8 06A0  32        bl   @jsr                       ;
     A6CA FF10     
22224                                                                          ; point
22225               
22226 A6CC 0200  20        li   ra,>e2*256                 ; LDA #226          ; Print recursive token 66 (" CR") followed by a
     A6CE E200     
22227                                                                          ; newline by falling through into plf
22228               
22229               * ******************************************************************************
22230               *
22231               * Name: plf
22232               * Type: Subroutine
22233               * Category: Text
22234               * Summary: Print a text token followed by a newline
22235               *
22236               * ------------------------------------------------------------------------------
22237               *
22238               * Arguments:
22239               *
22240               * A                   The text token to be printed
22241               *
22242               * ******************************************************************************
22243               
22244               plf_:
22245 A6D0 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     A6D2 A6E8     
22246 A6D4 06A0  32        bl   @jsr                       ;
     A6D6 FF10     
22247               
22248 A6D8 0460  28        b    @TT67                      ; JMP TT67          ; Jump to TT67 to print a newline and return from the
     A6DA 4EE6     
22249                                                                          ; subroutine using a tail call
22250               
22251               * ******************************************************************************
22252               *
22253               * Name: TT68
22254               * Type: Subroutine
22255               * Category: Text
22256               * Summary: Print a text token followed by a colon
22257               *
22258               * ------------------------------------------------------------------------------
22259               *
22260               * Arguments:
22261               *
22262               * A                   The text token to be printed
22263               *
22264               * ******************************************************************************
22265               
22266               TT68:
22267 A6DC 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A and fall through into TT73
     A6DE A6E8     
22268 A6E0 06A0  32        bl   @jsr                       ;
     A6E2 FF10     
22269                                                                          ; to print a colon
22270               
22271               * ******************************************************************************
22272               *
22273               * Name: TT73
22274               * Type: Subroutine
22275               * Category: Text
22276               * Summary: Print a colon
22277               *
22278               * ******************************************************************************
22279               
22280               TT73:
22281 A6E4 0200  20        li   ra,(':')*256               ; LDA #':'          ; Set A to ASCII ":" and fall through into TT27 to
     A6E6 3A00     
22282                                                                          ; actually print the colon
22283               
22284               * ******************************************************************************
22285               *
22286               * Name: TT27
22287               * Type: Subroutine
22288               * Category: Text
22289               * Summary: Print a text token
22290               * Deep dive: Printing text tokens
22291               *
22292               * ------------------------------------------------------------------------------
22293               *
22294               * Print a text token (i.e. a character, control code, two-letter token or
22295               * recursive token).
22296               *
22297               * ------------------------------------------------------------------------------
22298               *
22299               * Arguments:
22300               *
22301               * A                   The text token to be printed
22302               *
22303               * ******************************************************************************
22304               
22305               TT27:
22306 A6E8 D040  18        movb ra,rx                      ; TAX               ; Copy the token number from A to X. We can then keep
22307                                                                          ; decrementing X and testing it against zero, while
22308                                                                          ; keeping the original token number intact in A; this
22309                                                                          ; effectively implements a switch statement on the
22310                                                                          ; value of the token
22311               
22312 A6EA 13DF  14        jeq  csh_                       ; BEQ csh           ; If token = 0, this is control code 0 (current amount
22313                                                                          ; of cash and newline), so jump to csh to print the
22314                                                                          ; amount of cash and return from the subroutine using
22315                                                                          ; a tail call
22316               
22317 A6EC 116E  14        jlt  TT43                       ; BMI TT43          ; If token > 127, this is either a two-letter token
22318                                                                          ; (128-159) or a recursive token (160-255), so jump
22319                                                                          ; to TT43 to process tokens
22320               
22321 A6EE 7044  18        sb   rone,rx                    ; DEX               ; If token = 1, this is control code 1 (current galaxy
22322 A6F0 13C0  14        jeq  tal_                       ; BEQ tal           ; number), so jump to tal to print the galaxy number and
22323                                                                          ; return from the subroutine using a tail call
22324               
22325 A6F2 7044  18        sb   rone,rx                    ; DEX               ; If token = 2, this is control code 2 (current system
22326 A6F4 13A5  14        jeq  ypl_                       ; BEQ ypl           ; name), so jump to ypl to print the current system name
22327                                                                          ; and return from the subroutine using a tail call
22328               
22329 A6F6 7044  18        sb   rone,rx                    ; DEX               ; If token > 3, skip the following instruction
22330 A6F8 1602  14        jne  B61                        ; BNE B61
22331               
22332 A6FA 0460  28        b    @cpl_                      ; JMP cpl           ; This token is control code 3 (selected system name)
     A6FC A5C4     
22333                                                                          ; so jump to cpl to print the selected system name
22334                                                                          ; and return from the subroutine using a tail call
22335               
22336               B61:
22337 A6FE 7044  18        sb   rone,rx                    ; DEX               ; If token = 4, this is control code 4 (commander
22338 A700 1390  14        jeq  cmn_                       ; BEQ cmn           ; name), so jump to cmm to print the commander name
22339                                                                          ; and return from the subroutine using a tail call
22340               
22341 A702 7044  18        sb   rone,rx                    ; DEX               ; If token = 5, this is control code 5 (fuel, newline,
22342 A704 13BC  14        jeq  fwl_                       ; BEQ fwl           ; cash, newline), so jump to fwl to print the fuel level
22343                                                                          ; and return from the subroutine using a tail call
22344               
22345 A706 7044  18        sb   rone,rx                    ; DEX               ; If token > 6, skip the following three instructions
22346 A708 1606  14        jne  B62                        ; BNE B62
22347               
22348 A70A 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; This token is control code 6 (switch to Sentence
     A70C 8000     
22349 A70E D800  30        movb ra,@QQ17                   ; STA QQ17          ; Case), so set bit 7 of QQ17 to switch to Sentence Case
     A710 007E     
22350 A712 0460  28        b    @rts                       ; RTS               ; and return from the subroutine as we are done
     A714 FF1C     
22351               
22352               B62:
22353 A716 7044  18        sb   rone,rx                    ; DEX               ; If token > 8, skip the following two instructions
22354 A718 7044  18        sb   rone,rx                    ; DEX
22355 A71A 1604  14        jne  B63                        ; BNE B63
22356               
22357 A71C D801  30        movb rx,@QQ17                   ; STX QQ17          ; This token is control code 8 (switch to ALL CAPS), so
     A71E 007E     
22358 A720 0460  28        b    @rts                       ; RTS               ; set QQ17 to 0 to switch to ALL CAPS and return from
     A722 FF1C     
22359                                                                          ; the subroutine as we are done
22360               
22361               B63:
22362 A724 7044  18        sb   rone,rx                    ; DEX               ; If token = 9, this is control code 9 (tab to column
22363 A726 1339  14        jeq  crlf_                      ; BEQ crlf          ; 21 and print a colon), so jump to crlf
22364               
22365 A728 0280  22        ci   ra,>60*256                 ; CMP #96           ; By this point, token is either 7, or in 10-127.
     A72A 6000     
22366 A72C 186A  14        joc  ex_                        ; BCS ex            ; Check token number in A and if token >= 96, then the
22367                                                                          ; token is in 96-127, which is a recursive token, so
22368                                                                          ; jump to ex, which prints recursive tokens in this
22369                                                                          ; range (i.e. where the recursive token number is
22370                                                                          ; correct and doesn't need correcting)
22371               
22372 A72E 0280  22        ci   ra,>0e*256                 ; CMP #14           ; If token < 14, skip the following two instructions
     A730 0E00     
22373 A732 1703  14        jnc  B64                        ; BCC B64
22374               
22375 A734 0280  22        ci   ra,>20*256                 ; CMP #32           ; If token < 32, then this means token is in 14-31, so
     A736 2000     
22376 A738 172B  14        jnc  qw_                        ; BCC qw            ; this is a recursive token that needs 114 adding to it
22377                                                                          ; to get the recursive token number, so jump to qw
22378                                                                          ; which will do this
22379               
22380                                                                          ; By this point, token is either 7 (beep) or in 10-13
22381                                                                          ; (line feeds and carriage returns), or in 32-95
22382                                                                          ; (ASCII letters, numbers and punctuation)
22383               
22384               B64:
22385 A73A D060  30        movb @QQ17,rx                   ; LDX QQ17          ; Fetch QQ17, which controls letter case, into X
     A73C 007E     
22386               
22387 A73E 1343  14        jeq  TT74                       ; BEQ TT74          ; If QQ17 = 0, then ALL CAPS is set, so jump to TT74
22388                                                                          ; to print this character as is (i.e. as a capital)
22389               
22390 A740 1113  14        jlt  TT41                       ; BMI TT41          ; If QQ17 has bit 7 set, then we are using Sentence
22391                                                                          ; Case, so jump to TT41, which will print the
22392                                                                          ; character in upper or lower case, depending on
22393                                                                          ; whether this is the first letter in a word
22394               
22395                      .bit @QQ17                      ; BIT QQ17          ; If we get here, QQ17 is not 0 and bit 7 is clear, so
     **** ****     > BIT
0001 A742 D1A0  30        movb @QQ17,rtmp
     A744 007E     
0002 A746 0546  14        inv  rtmp
0003 A748 D1C4  18        movb rone,rtmp2
0004 A74A 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
22396                      .bvs TT46                       ; BVS TT46          ; either it is bit 6 that is set, or some other flag in
     **** ****     > BVS
0001 A74C 1801  14        joc  !
0002 A74E 1032  14        jmp  TT46
0003               !:
                   < elite.a99
22397                                                                          ; QQ17 is set (bits 0-5). So check whether bit 6 is set.
22398                                                                          ; If it is, then ALL CAPS has been set (as bit 7 is
22399                                                                          ; clear) but bit 6 is still indicating that the next
22400                                                                          ; character should be printed in lower case, so we need
22401                                                                          ; to fix this. We do this with a jump to TT46, which
22402                                                                          ; will print this character in upper case and clear bit
22403                                                                          ; 6, so the flags are consistent with ALL CAPS going
22404                                                                          ; forward
22405               
22406                                                                          ; If we get here, some other flag is set in QQ17 (one
22407                                                                          ; of bits 0-5 is set), which shouldn't happen in this
22408                                                                          ; version of Elite. If this were the case, then we
22409                                                                          ; would fall through into TT42 to print in lower case,
22410                                                                          ; which is how printing all words in lower case could
22411                                                                          ; be supported (by setting QQ17 to 1, say)
22412               
22413               * ******************************************************************************
22414               *
22415               * Name: TT42
22416               * Type: Subroutine
22417               * Category: Text
22418               * Summary: Print a letter in lower case
22419               *
22420               * ------------------------------------------------------------------------------
22421               *
22422               * Arguments:
22423               *
22424               * A                   The character to be printed. Can be one of the
22425               * following:
22426               *
22427               * * 7 (beep)
22428               *
22429               * * 10-13 (line feeds and carriage returns)
22430               *
22431               * * 32-95 (ASCII capital letters, numbers and
22432               * punctuation)
22433               *
22434               * ------------------------------------------------------------------------------
22435               *
22436               * Other entry points:
22437               *
22438               * TT44                Jumps to TT26 to print the character in A (used to
22439               * enable us to use a branch instruction to jump to TT26)
22440               *
22441               * ******************************************************************************
22442               
22443               TT42:
22444 A750 0280  22        ci   ra,('A')*256               ; CMP #'A'          ; If A < ASCII "A", then this is punctuation, so jump
     A752 4100     
22445 A754 1707  14        jnc  TT44                       ; BCC TT44          ; to TT26 (via TT44) to print the character as is, as
22446                                                                          ; we don't care about the character's case
22447               
22448 A756 0280  22        ci   ra,('Z'+1)*256             ; CMP #'Z'+1        ; If A >= (ASCII "Z" + 1), then this is also
     A758 5B00     
22449 A75A 1804  14        joc  TT44                       ; BCS TT44          ; punctuation, so jump to TT26 (via TT44) to print the
22450                                                                          ; character as is, as we don't care about the
22451                                                                          ; character's case
22452               
22453                      .adi (>20*256)                  ; ADC #32           ; Add 32 to the character, to convert it from upper to
     **** ****     > ADI
0001 A75C 1701  14        jnc  !
0002 A75E B004  18        ab   rone,ra
0003               !:
0004 A760 0220  22        ai   ra,(>20*256)
     A762 2000     
                   < elite.a99
22454                                                                          ; lower case
22455               
22456               TT44:
22457 A764 0460  28        b    @TT26                      ; JMP TT26          ; Print the character in A
     A766 3172     
22458               
22459               * ******************************************************************************
22460               *
22461               * Name: TT41
22462               * Type: Subroutine
22463               * Category: Text
22464               * Summary: Print a letter according to Sentence Case
22465               *
22466               * ------------------------------------------------------------------------------
22467               *
22468               * The rules for printing in Sentence Case are as follows:
22469               *
22470               * * If QQ17 bit 6 is set, print lower case (via TT45)
22471               *
22472               * * If QQ17 bit 6 is clear, then:
22473               *
22474               * * If character is punctuation, just print it
22475               *
22476               * * If character is a letter, set QQ17 bit 6 and print letter as a capital
22477               *
22478               * ------------------------------------------------------------------------------
22479               *
22480               * Arguments:
22481               *
22482               * A                   The character to be printed. Can be one of the
22483               * following:
22484               *
22485               * * 7 (beep)
22486               *
22487               * * 10-13 (line feeds and carriage returns)
22488               *
22489               * * 32-95 (ASCII capital letters, numbers and
22490               * punctuation)
22491               *
22492               * X                   Contains the current value of QQ17
22493               *
22494               * QQ17                Bit 7 is set
22495               *
22496               * ******************************************************************************
22497               
22498               TT41:
22499                                                                          ; If we get here, then QQ17 has bit 7 set, so we are in
22500                                                                          ; Sentence Case
22501                      .bit @QQ17                      ; BIT QQ17          ; If QQ17 also has bit 6 set, jump to TT45 to print
     **** ****     > BIT
0001 A768 D1A0  30        movb @QQ17,rtmp
     A76A 007E     
0002 A76C 0546  14        inv  rtmp
0003 A76E D1C4  18        movb rone,rtmp2
0004 A770 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
22502                      .bvs TT45                       ; BVS TT45          ; this character in lower case
     **** ****     > BVS
0001 A772 1801  14        joc  !
0002 A774 1017  14        jmp  TT45
0003               !:
                   < elite.a99
22503               
22504                                                                          ; If we get here, then QQ17 has bit 6 clear and bit 7
22505                                                                          ; set, so we are in Sentence Case and we need to print
22506                                                                          ; the next letter in upper case
22507               
22508 A776 0280  22        ci   ra,('A')*256               ; CMP #'A'          ; If A < ASCII "A", then this is punctuation, so jump
     A778 4100     
22509 A77A 1725  14        jnc  TT74                       ; BCC TT74          ; to TT26 (via TT44) to print the character as is, as
22510                                                                          ; we don't care about the character's case
22511               
22512                      .pha                            ; PHA               ; Otherwise this is a letter, so store the token number
     **** ****     > PHA
0001 A77C D680  30        movb ra,*rsp
0002 A77E 060A  14        dec  rsp
                   < elite.a99
22513               
22514 A780 D001  18        movb rx,ra                      ; TXA               ; Set bit 6 in QQ17 (X contains the current QQ17)
22515 A782 0260  22        ori  ra,>40*256                 ; ORA #%1000000     ; so the next letter after this one is printed in lower
     A784 4000     
22516 A786 D800  30        movb ra,@QQ17                   ; STA QQ17          ; case
     A788 007E     
22517               
22518                      .pla                            ; PLA               ; Restore the token number into A
     **** ****     > PLA
0001 A78A 058A  14        inc  rsp
0002 A78C D01A  26        movb *rsp,ra
                   < elite.a99
22519               
22520 A78E 16EA  14        jne  TT44                       ; BNE TT44          ; Jump to TT26 (via TT44) to print the character in A
22521                                                                          ; (this BNE is effectively a JMP as A will never be
22522                                                                          ; zero)
22523               
22524               * ******************************************************************************
22525               *
22526               * Name: qw
22527               * Type: Subroutine
22528               * Category: Text
22529               * Summary: Print a recursive token in the range 128-145
22530               *
22531               * ------------------------------------------------------------------------------
22532               *
22533               * Print a recursive token where the token number is in 128-145 (so the value
22534               * passed to TT27 is in the range 14-31).
22535               *
22536               * ------------------------------------------------------------------------------
22537               *
22538               * Arguments:
22539               *
22540               * A                   A value from 128-145, which refers to a recursive token
22541               * in the range 14-31
22542               *
22543               * ******************************************************************************
22544               
22545               qw_:
22546                      .adi (>72*256)                  ; ADC #114          ; This is a recursive token in the range 0-95, so add
     **** ****     > ADI
0001 A790 1701  14        jnc  !
0002 A792 B004  18        ab   rone,ra
0003               !:
0004 A794 0220  22        ai   ra,(>72*256)
     A796 7200     
                   < elite.a99
22547 A798 1634  14        jne  ex_                        ; BNE ex            ; 114 to the argument to get the token number 128-145
22548                                                                          ; and jump to ex to print it
22549               
22550               * ******************************************************************************
22551               *
22552               * Name: crlf
22553               * Type: Subroutine
22554               * Category: Text
22555               * Summary: Tab to column 21 and print a colon
22556               *
22557               * ------------------------------------------------------------------------------
22558               *
22559               * Print control code 9 (tab to column 21 and print a colon). The subroutine
22560               * name is pretty misleading, as it doesn't have anything to do with carriage
22561               * returns or line feeds.
22562               *
22563               * ******************************************************************************
22564               
22565               crlf_:
22566 A79A 0200  20        li   ra,>15*256                 ; LDA #21           ; Set the X-column in XC to 21
     A79C 1500     
22567 A79E D800  30        movb ra,@XC                     ; STA XC
     A7A0 002C     
22568               
22569 A7A2 16A0  14        jne  TT73                       ; BNE TT73          ; Jump to TT73, which prints a colon (this BNE is
22570                                                                          ; effectively a JMP as A will never be zero)
22571               
22572               * ******************************************************************************
22573               *
22574               * Name: TT45
22575               * Type: Subroutine
22576               * Category: Text
22577               * Summary: Print a letter in lower case
22578               *
22579               * ------------------------------------------------------------------------------
22580               *
22581               * This routine prints a letter in lower case. Specifically:
22582               *
22583               * * If QQ17 = 255, abort printing this character as printing is disabled
22584               *
22585               * * If this is a letter then print in lower case
22586               *
22587               * * Otherwise this is punctuation, so clear bit 6 in QQ17 and print
22588               *
22589               * ------------------------------------------------------------------------------
22590               *
22591               * Arguments:
22592               *
22593               * A                   The character to be printed. Can be one of the
22594               * following:
22595               *
22596               * * 7 (beep)
22597               *
22598               * * 10-13 (line feeds and carriage returns)
22599               *
22600               * * 32-95 (ASCII capital letters, numbers and
22601               * punctuation)
22602               *
22603               * X                   Contains the current value of QQ17
22604               *
22605               * QQ17                Bits 6 and 7 are set
22606               *
22607               * ******************************************************************************
22608               
22609               TT45:
22610                                                                          ; If we get here, then QQ17 has bit 6 and 7 set, so we
22611                                                                          ; are in Sentence Case and we need to print the next
22612                                                                          ; letter in lower case
22613 A7A4 0281  22        ci   rx,>ff*256                 ; CPX #255          ; If QQ17 = 255 then printing is disabled, so return
     A7A6 FF00     
22614 A7A8 1602  14        jne  FIX006                     ; BNE FIX006        ; from the subroutine (as TT48 contains an RTS)
22615 A7AA 0460  28        b    @TT48                      ; JMP TT48
     A7AC A88C     
22616               
22617               FIX006:
22618 A7AE 0280  22        ci   ra,('A')*256               ; CMP #'A'          ; If A >= ASCII "A", then jump to TT42, which will
     A7B0 4100     
22619 A7B2 18CE  14        joc  TT42                       ; BCS TT42          ; print the letter in lowercase
22620               
22621                                                                          ; Otherwise this is not a letter, it's punctuation, so
22622                                                                          ; this is effectively a word break. We therefore fall
22623                                                                          ; through to TT46 to print the character and set QQ17
22624                                                                          ; to ensure the next word starts with a capital letter
22625               
22626               * ******************************************************************************
22627               *
22628               * Name: TT46
22629               * Type: Subroutine
22630               * Category: Text
22631               * Summary: Print a character and switch to capitals
22632               *
22633               * ------------------------------------------------------------------------------
22634               *
22635               * Print a character and clear bit 6 in QQ17, so that the next letter that gets
22636               * printed after this will start with a capital letter.
22637               *
22638               * ------------------------------------------------------------------------------
22639               *
22640               * Arguments:
22641               *
22642               * A                   The character to be printed. Can be one of the
22643               * following:
22644               *
22645               * * 7 (beep)
22646               *
22647               * * 10-13 (line feeds and carriage returns)
22648               *
22649               * * 32-95 (ASCII capital letters, numbers and
22650               * punctuation)
22651               *
22652               * X                   Contains the current value of QQ17
22653               *
22654               * QQ17                Bits 6 and 7 are set
22655               *
22656               * ******************************************************************************
22657               
22658               TT46:
22659                      .pha                            ; PHA               ; Store the token number
     **** ****     > PHA
0001 A7B4 D680  30        movb ra,*rsp
0002 A7B6 060A  14        dec  rsp
                   < elite.a99
22660               
22661 A7B8 D001  18        movb rx,ra                      ; TXA               ; Clear bit 6 in QQ17 (X contains the current QQ17) so
22662 A7BA 0240  22        andi ra,>bf*256                 ; AND #%10111111    ; the next letter after this one is printed in upper
     A7BC BF00     
22663 A7BE D800  30        movb ra,@QQ17                   ; STA QQ17          ; case
     A7C0 007E     
22664               
22665                      .pla                            ; PLA               ; Restore the token number into A
     **** ****     > PLA
0001 A7C2 058A  14        inc  rsp
0002 A7C4 D01A  26        movb *rsp,ra
                   < elite.a99
22666               
22667                                                                          ; Now fall through into TT74 to print the character
22668               
22669               * ******************************************************************************
22670               *
22671               * Name: TT74
22672               * Type: Subroutine
22673               * Category: Text
22674               * Summary: Print a character
22675               *
22676               * ------------------------------------------------------------------------------
22677               *
22678               * Arguments:
22679               *
22680               * A                   The character to be printed
22681               *
22682               * ******************************************************************************
22683               
22684               TT74:
22685 A7C6 0460  28        b    @TT26                      ; JMP TT26          ; Print the character in A
     A7C8 3172     
22686               
22687               * ******************************************************************************
22688               *
22689               * Name: TT43
22690               * Type: Subroutine
22691               * Category: Text
22692               * Summary: Print a two-letter token or recursive token 0-95
22693               *
22694               * ------------------------------------------------------------------------------
22695               *
22696               * Print a two-letter token, or a recursive token where the token number is in
22697               * 0-95 (so the value passed to TT27 is in the range 160-255).
22698               *
22699               * ------------------------------------------------------------------------------
22700               *
22701               * Arguments:
22702               *
22703               * A                   One of the following:
22704               *
22705               * * 128-159 (two-letter token)
22706               *
22707               * * 160-255 (the argument to TT27 that refers to a
22708               * recursive token in the range 0-95)
22709               *
22710               * ******************************************************************************
22711               
22712               TT43:
22713 A7CA 0280  22        ci   ra,>a0*256                 ; CMP #160          ; If token >= 160, then this is a recursive token, so
     A7CC A000     
22714 A7CE 1815  14        joc  TT47                       ; BCS TT47          ; jump to TT47 below to process it
22715               
22716 A7D0 0240  22        andi ra,>7f*256                 ; AND #127          ; This is a two-letter token with number 128-159. The
     A7D2 7F00     
22717                      .asla                           ; ASL A             ; set of two-letter tokens is stored in a lookup table
     **** ****     > ASLA
0001 A7D4 0240  22        andi ra,>ff00
     A7D6 FF00     
0002 A7D8 0A10  18        sla  ra,1
                   < elite.a99
22718                                                                          ; at QQ16, with each token taking up two bytes, so to
22719                                                                          ; convert this into the token's position in the table,
22720                                                                          ; we subtract 128 (or just clear bit 7) and multiply
22721                                                                          ; by 2 (or shift left)
22722               
22723 A7DA D080  18        movb ra,ry                      ; TAY               ; Transfer the token's position into Y so we can look
22724                                                                          ; up the token using absolute indexed mode
22725               
22726 A7DC D022  34        movb @QQ16(ry),ra               ; LDA QQ16,Y        ; Get the first letter of the token and print it
     A7DE CEEE     
22727 A7E0 0206  20        li   rtmp,TT27                  ; JSR TT27
     A7E2 A6E8     
22728 A7E4 06A0  32        bl   @jsr                       ;
     A7E6 FF10     
22729               
22730 A7E8 D022  34        movb @QQ16+1(ry),ra             ; LDA QQ16+1,Y      ; Get the second letter of the token
     A7EA CEEF     
22731               
22732 A7EC 0280  22        ci   ra,('?')*256               ; CMP #'?'          ; If the second letter of the token is a question mark
     A7EE 3F00     
22733 A7F0 1602  14        jne  FIX007                     ; BNE FIX007        ; then this is a one-letter token, so just return from
22734                                                                          ; the subroutine without printing (as TT48 contains an
22735                                                                          ; RTS)
22736 A7F2 0460  28        b    @TT48                      ; JMP TT48
     A7F4 A88C     
22737               FIX007:
22738 A7F6 0460  28        b    @TT27                      ; JMP TT27          ; Print the second letter and return from the
     A7F8 A6E8     
22739                                                                          ; subroutine
22740               
22741               TT47:
22742                      .sbi (>a0*256)                  ; SBC #160          ; This is a recursive token in the range 160-255, so
     **** ****     > SBI
0001 A7FA 1801  14        joc  !
0002 A7FC 7004  18        sb   rone,ra
0003               !:
0004 A7FE 0220  22        ai   ra,-(>A0*256)
     A800 6000     
                   < elite.a99
22743                                                                          ; subtract 160 from the argument to get the token
22744                                                                          ; number 0-95 and fall through into ex to print it
22745               
22746               * ******************************************************************************
22747               *
22748               * Name: ex
22749               * Type: Subroutine
22750               * Category: Text
22751               * Summary: Print a recursive token
22752               * Deep dive: Printing text tokens
22753               *
22754               * ------------------------------------------------------------------------------
22755               *
22756               * This routine works its way through the recursive text tokens that are stored
22757               * in tokenised form in the table at QQ18, and when it finds token number A,
22758               * it prints it. Tokens are null-terminated in memory and fill three pages,
22759               * but there is no lookup table as that would consume too much memory, so the
22760               * only way to find the correct token is to start at the beginning and look
22761               * through the table byte by byte, counting tokens as we go until we are in the
22762               * right place. This approach might not be terribly speed efficient, but it is
22763               * certainly memory-efficient.
22764               *
22765               * ------------------------------------------------------------------------------
22766               *
22767               * Arguments:
22768               *
22769               * A                   The recursive token to be printed, in the range 0-148
22770               *
22771               * ------------------------------------------------------------------------------
22772               *
22773               * Other entry points:
22774               *
22775               * TT48                Contains an RTS
22776               *
22777               * ******************************************************************************
22778               
22779               ex_:
22780 A802 D040  18        movb ra,rx                      ; TAX               ; Copy the token number into X
22781               
22782 A804 0200  20        li   ra,((QQ18)%256)*256        ; LDA #LO(QQ18)     ; Set V(1 0) to point to the recursive token table at
     A806 0000     
22783 A808 D800  30        movb ra,@V                      ; STA V             ; location QQ18
     A80A 0022     
22784 A80C 0200  20        li   ra,((QQ18)/256)*256        ; LDA #HI(QQ18)
     A80E 0400     
22785 A810 D800  30        movb ra,@V+1                    ; STA V+1
     A812 0023     
22786               
22787 A814 0202  20        li   ry,>00*256                 ; LDY #0            ; Set a counter Y to point to the character offset
     A816 0000     
22788                                                                          ; as we scan through the table
22789               
22790 A818 D001  18        movb rx,ra                      ; TXA               ; Copy the token number back into A, so both A and X
22791                                                                          ; now contain the token number we want to print
22792               
22793 A81A 1311  14        jeq  TT50                       ; BEQ TT50          ; If the token number we want is 0, then we have
22794                                                                          ; already found the token we are looking for, so jump
22795                                                                          ; to TT50, otherwise start working our way through the
22796                                                                          ; null-terminated token table until we find the X-th
22797                                                                          ; token
22798               
22799               TT51:
22800                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch the Y-th character from the token table page
     **** ****     > LD_IND_Y_IDX
0001 A81C D820  50        movb @V,@rtmplb
     A81E 0022     
     A820 2079     
0002 A822 D1A0  30        movb @V+1,rtmp
     A824 0023     
0003 A826 A182  18        a    ry,rtmp
0004 A828 D016  26        movb *rtmp,RA
                   < elite.a99
22801                                                                          ; we are currently scanning
22802               
22803 A82A 1304  14        jeq  TT49                       ; BEQ TT49          ; If the character is null, we've reached the end of
22804                                                                          ; this token, so jump to TT49
22805               
22806 A82C B084  18        ab   rone,ry                    ; INY               ; Increment character pointer and loop back around for
22807 A82E 16F6  14        jne  TT51                       ; BNE TT51          ; the next character in this token, assuming Y hasn't
22808                                                                          ; yet wrapped around to 0
22809               
22810 A830 B004  18        ab   rone,ra                    ; INC V+1           ; If it has wrapped round to 0, we have just crossed
22811 A832 16F4  14        jne  TT51                       ; BNE TT51          ; into a new page, so increment V+1 so that V points
22812                                                                          ; to the start of the new page
22813               
22814               TT49:
22815 A834 B084  18        ab   rone,ry                    ; INY               ; Increment the character pointer
22816               
22817 A836 1601  14        jne  TT59                       ; BNE TT59          ; If Y hasn't just wrapped around to 0, skip the next
22818                                                                          ; instruction
22819               
22820 A838 B004  18        ab   rone,ra                    ; INC V+1           ; We have just crossed into a new page, so increment
22821                                                                          ; V+1 so that V points to the start of the new page
22822               
22823               TT59:
22824 A83A 7044  18        sb   rone,rx                    ; DEX               ; We have just reached a new token, so decrement the
22825                                                                          ; token number we are looking for
22826               
22827 A83C 16EF  14        jne  TT51                       ; BNE TT51          ; Assuming we haven't yet reached the token number in
22828                                                                          ; X, look back up to keep fetching characters
22829               
22830               TT50:
22831                                                                          ; We have now reached the correct token in the token
22832                                                                          ; table, with Y pointing to the start of the token as
22833                                                                          ; an offset within the page pointed to by V, so let's
22834                                                                          ; print the recursive token. Because recursive tokens
22835                                                                          ; can contain other recursive tokens, we need to store
22836                                                                          ; our current state on the stack, so we can retrieve
22837                                                                          ; it after printing each character in this token
22838 A83E D002  18        movb ry,ra                      ; TYA               ; Store the offset in Y on the stack
22839                      .pha                            ; PHA
     **** ****     > PHA
0001 A840 D680  30        movb ra,*rsp
0002 A842 060A  14        dec  rsp
                   < elite.a99
22840               
22841 A844 D020  30        movb @V+1,ra                    ; LDA V+1           ; Store the high byte of V (the page containing the
     A846 0023     
22842                      .pha                            ; PHA               ; token we have found) on the stack, so the stack now
     **** ****     > PHA
0001 A848 D680  30        movb ra,*rsp
0002 A84A 060A  14        dec  rsp
                   < elite.a99
22843                                                                          ; contains the address of the start of this token
22844               
22845                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Load the character at offset Y in the token table,
     **** ****     > LD_IND_Y_IDX
0001 A84C D820  50        movb @V,@rtmplb
     A84E 0022     
     A850 2079     
0002 A852 D1A0  30        movb @V+1,rtmp
     A854 0023     
0003 A856 A182  18        a    ry,rtmp
0004 A858 D016  26        movb *rtmp,RA
                   < elite.a99
22846                                                                          ; which is the next character of this token that we
22847                                                                          ; want to print
22848               
22849                      .eoi ((RE)*256)                 ; EOR #RE           ; Tokens are stored in memory having been EOR'd with the
     **** ****     > EOI
0001 A85A 0206  20        li   rtmp,((RE)*256)
     A85C 2300     
0002 A85E 2806  18        xor  rtmp,ra
                   < elite.a99
22850                                                                          ; value of RE - which is 35 for all versions of Elite
22851                                                                          ; except for NES, where RE is 62 - so we repeat the
22852                                                                          ; EOR to get the actual character to print
22853               
22854 A860 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A, which could be a letter,
     A862 A6E8     
22855 A864 06A0  32        bl   @jsr                       ;
     A866 FF10     
22856                                                                          ; number, control code, two-letter token or another
22857                                                                          ; recursive token
22858               
22859                      .pla                            ; PLA               ; Restore the high byte of V (the page containing the
     **** ****     > PLA
0001 A868 058A  14        inc  rsp
0002 A86A D01A  26        movb *rsp,ra
                   < elite.a99
22860 A86C D800  30        movb ra,@V+1                    ; STA V+1           ; token we have found) into V+1
     A86E 0023     
22861               
22862                      .pla                            ; PLA               ; Restore the offset into Y
     **** ****     > PLA
0001 A870 058A  14        inc  rsp
0002 A872 D01A  26        movb *rsp,ra
                   < elite.a99
22863 A874 D080  18        movb ra,ry                      ; TAY
22864               
22865 A876 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next character in the
22866                                                                          ; token we are printing
22867               
22868 A878 1601  14        jne  B65                        ; BNE B65           ; If Y is zero then we have just crossed into a new
22869 A87A B004  18        ab   rone,ra                    ; INC V+1           ; page, so increment V+1 so that V points to the start
22870                                                                          ; of the new page
22871               
22872               B65:
22873                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Load the next character we want to print into A
     **** ****     > LD_IND_Y_IDX
0001 A87C D820  50        movb @V,@rtmplb
     A87E 0022     
     A880 2079     
0002 A882 D1A0  30        movb @V+1,rtmp
     A884 0023     
0003 A886 A182  18        a    ry,rtmp
0004 A888 D016  26        movb *rtmp,RA
                   < elite.a99
22874               
22875 A88A 16D9  14        jne  TT50                       ; BNE TT50          ; If this is not the null character at the end of the
22876                                                                          ; token, jump back up to TT50 to print the next
22877                                                                          ; character, otherwise we are done printing
22878               
22879               TT48:
22880 A88C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A88E FF1C     
22881               
22882               * ******************************************************************************
22883               *
22884               * Name: DOEXP
22885               * Type: Subroutine
22886               * Category: Drawing ships
22887               * Summary: Draw an exploding ship
22888               * Deep dive: Drawing explosion clouds
22889               * Generating random numbers
22890               *
22891               * ******************************************************************************
22892               
22893               EX2:
22894 A890 D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bits 5 and 7 of the ship's byte #31 to denote that
     A892 0072     
22895 A894 0260  22        ori  ra,>a0*256                 ; ORA #%10100000    ; the ship is exploding and has been killed
     A896 A000     
22896 A898 D800  30        movb ra,@INWK+31                ; STA INWK+31
     A89A 0072     
22897               
22898 A89C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A89E FF1C     
22899               
22900               DOEXP:
22901 A8A0 D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; If bit 6 of the ship's byte #31 is clear, then the
     A8A2 0072     
22902 A8A4 0240  22        andi ra,>40*256                 ; AND #%01000000    ; ship is not already exploding so there is no existing
     A8A6 4000     
22903 A8A8 1304  14        jeq  B66                        ; BEQ B66           ; explosion cloud to remove, so skip the following
22904                                                                          ; instruction
22905               
22906 A8AA 0206  20        li   rtmp,PTCLS                 ; JSR PTCLS         ; Call PTCLS to remove the existing cloud by drawing it
     A8AC A9D0     
22907 A8AE 06A0  32        bl   @jsr                       ;
     A8B0 FF10     
22908                                                                          ; again
22909               
22910               B66:
22911 A8B2 D020  30        movb @INWK+6,ra                 ; LDA INWK+6        ; Set T = z_lo
     A8B4 0059     
22912 A8B6 D800  30        movb ra,@T                      ; STA T
     A8B8 00D1     
22913               
22914 A8BA D020  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set A = z_hi, so (A T) = z
     A8BC 005A     
22915               
22916 A8BE 0280  22        ci   ra,>20*256                 ; CMP #32           ; If z_hi < 32, skip the next two instructions
     A8C0 2000     
22917 A8C2 1703  14        jnc  B67                        ; BCC B67
22918               
22919 A8C4 0200  20        li   ra,>fe*256                 ; LDA #&FE          ; Set A = 254 and jump to yy (this BNE is effectively a
     A8C6 FE00     
22920 A8C8 1615  14        jne  yy_                        ; BNE yy            ; JMP, as A is never zero)
22921               
22922               B67:
22923                      .asl @T                         ; ASL T             ; Shift (A T) left twice
     **** ****     > ASL
0001 A8CA D1A0  30        movb @T,rtmp
     A8CC 00D1     
0002 A8CE 0246  22        andi rtmp,>ff00
     A8D0 FF00     
0003 A8D2 0A16  18        sla  rtmp,1
0004 A8D4 D806  30        movb rtmp,@T
     A8D6 00D1     
                   < elite.a99
22924 A8D8 06A0  32        bl   @rola                      ; ROL A
     A8DA FF26     
22925                      .asl @T                         ; ASL T
     **** ****     > ASL
0001 A8DC D1A0  30        movb @T,rtmp
     A8DE 00D1     
0002 A8E0 0246  22        andi rtmp,>ff00
     A8E2 FF00     
0003 A8E4 0A16  18        sla  rtmp,1
0004 A8E6 D806  30        movb rtmp,@T
     A8E8 00D1     
                   < elite.a99
22926 A8EA 06A0  32        bl   @rola                      ; ROL A
     A8EC FF26     
22927               
22928                      .sec                            ; SEC               ; And then shift A left once more, inserting a 1 into
     **** ****     > SEC
0001 A8EE 0A15  18        sla  rmone,1
                   < elite.a99
22929 A8F0 06A0  32        bl   @rola                      ; ROL A             ; bit 0
     A8F2 FF26     
22930               
22931                                                                          ; Overall, the above multiplies A by 8 and makes sure it
22932                                                                          ; is at least 1, to leave a one-byte distance in A. We
22933                                                                          ; can use this as the distance for our cloud, to ensure
22934                                                                          ; that the explosion cloud is visible even for ships
22935                                                                          ; that blow up a long way away
22936               
22937               yy_:
22938 A8F4 D800  30        movb ra,@Q                      ; STA Q             ; Store the distance to the explosion in Q
     A8F6 0090     
22939               
22940 A8F8 0202  20        li   ry,>01*256                 ; LDY #1            ; Fetch byte #1 of the ship line heap, which contains
     A8FA 0100     
22941                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; the cloud counter
     **** ****     > LD_IND_Y_IDX
0001 A8FC D820  50        movb @XX19,@rtmplb
     A8FE 0074     
     A900 2079     
0002 A902 D1A0  30        movb @XX19+1,rtmp
     A904 0075     
0003 A906 A182  18        a    ry,rtmp
0004 A908 D016  26        movb *rtmp,RA
                   < elite.a99
22942               
22943                      .adi (>04*256)                  ; ADC #4            ; Add 4 to the cloud counter, so it ticks onwards every
     **** ****     > ADI
0001 A90A 1701  14        jnc  !
0002 A90C B004  18        ab   rone,ra
0003               !:
0004 A90E 0220  22        ai   ra,(>04*256)
     A910 0400     
                   < elite.a99
22944                                                                          ; we redraw it
22945               
22946 A912 18BE  14        joc  EX2                        ; BCS EX2           ; If the addition overflowed, jump up to EX2 to update
22947                                                                          ; the explosion flags and return from the subroutine
22948               
22949                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store the updated cloud counter in byte #1 of the ship
     **** ****     > ST_IND_Y_IDX
0001 A914 D820  50        movb @XX19,@rtmplb
     A916 0074     
     A918 2079     
0002 A91A D1A0  30        movb @XX19+1,rtmp
     A91C 0075     
0003 A91E A182  18        a    ry,rtmp
0004 A920 D580  30        movb RA,*rtmp
                   < elite.a99
22950                                                                          ; line heap
22951               
22952 A922 0206  20        li   rtmp,DVID4                 ; JSR DVID4         ; Calculate the following:
     A924 45B0     
22953 A926 06A0  32        bl   @jsr                       ;
     A928 FF10     
22954                                                                          ;
22955                                                                          ; (P R) = 256 * A / Q
22956                                                                          ; = 256 * cloud counter / distance
22957                                                                          ;
22958                                                                          ; We are going to use this as our cloud size, so the
22959                                                                          ; further away the cloud, the smaller it is, and as the
22960                                                                          ; cloud counter ticks onward, the cloud expands
22961               
22962 A92A D020  30        movb @P,ra                      ; LDA P             ; Set A = P, so we now have:
     A92C 001B     
22963                                                                          ;
22964                                                                          ; (A R) = 256 * cloud counter / distance
22965               
22966 A92E 0280  22        ci   ra,>1c*256                 ; CMP #&1C          ; If A < 28, skip the next two instructions
     A930 1C00     
22967 A932 1703  14        jnc  B68                        ; BCC B68
22968               
22969 A934 0200  20        li   ra,>fe*256                 ; LDA #&FE          ; Set A = 254 and skip the following (this BNE is
     A936 FE00     
22970 A938 161B  14        jne  LABEL_1                    ; BNE LABEL_1       ; effectively a JMP as A is never zero)
22971               
22972               B68:
22973                      .asl @R                         ; ASL R             ; Shift (A R) left three times to multiply by 8
     **** ****     > ASL
0001 A93A D1A0  30        movb @R,rtmp
     A93C 0091     
0002 A93E 0246  22        andi rtmp,>ff00
     A940 FF00     
0003 A942 0A16  18        sla  rtmp,1
0004 A944 D806  30        movb rtmp,@R
     A946 0091     
                   < elite.a99
22974 A948 06A0  32        bl   @rola                      ; ROL A
     A94A FF26     
22975                      .asl @R                         ; ASL R
     **** ****     > ASL
0001 A94C D1A0  30        movb @R,rtmp
     A94E 0091     
0002 A950 0246  22        andi rtmp,>ff00
     A952 FF00     
0003 A954 0A16  18        sla  rtmp,1
0004 A956 D806  30        movb rtmp,@R
     A958 0091     
                   < elite.a99
22976 A95A 06A0  32        bl   @rola                      ; ROL A
     A95C FF26     
22977                      .asl @R                         ; ASL R
     **** ****     > ASL
0001 A95E D1A0  30        movb @R,rtmp
     A960 0091     
0002 A962 0246  22        andi rtmp,>ff00
     A964 FF00     
0003 A966 0A16  18        sla  rtmp,1
0004 A968 D806  30        movb rtmp,@R
     A96A 0091     
                   < elite.a99
22978 A96C 06A0  32        bl   @rola                      ; ROL A
     A96E FF26     
22979               
22980                                                                          ; Overall, the above multiplies (A R) by 8 to leave a
22981                                                                          ; one-byte cloud size in A, given by the following:
22982                                                                          ;
22983                                                                          ; A = 8 * cloud counter / distance
22984               
22985               LABEL_1:
22986 A970 7084  18        sb   rone,ry                    ; DEY               ; Decrement Y to 0
22987               
22988                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store the cloud size in byte #0 of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 A972 D820  50        movb @XX19,@rtmplb
     A974 0074     
     A976 2079     
0002 A978 D1A0  30        movb @XX19+1,rtmp
     A97A 0075     
0003 A97C A182  18        a    ry,rtmp
0004 A97E D580  30        movb RA,*rtmp
                   < elite.a99
22989               
22990 A980 D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Clear bit 6 of the ship's byte #31 to denote that the
     A982 0072     
22991 A984 0240  22        andi ra,>bf*256                 ; AND #%10111111    ; explosion has not yet been drawn
     A986 BF00     
22992 A988 D800  30        movb ra,@INWK+31                ; STA INWK+31
     A98A 0072     
22993               
22994 A98C 0240  22        andi ra,>08*256                 ; AND #%00001000    ; If bit 3 of the ship's byte #31 is clear, then nothing
     A98E 0800     
22995 A990 1602  14        jne  FIX008                     ; BNE FIX008        ; is being drawn on-screen for this ship anyway, so
22996 A992 0460  28        b    @TT48                      ; JMP TT48          ; return from the subroutine (as TT48 contains an RTS)
     A994 A88C     
22997               
22998               FIX008:
22999 A996 0202  20        li   ry,>02*256                 ; LDY #2            ; Otherwise it's time to draw an explosion cloud, so
     A998 0200     
23000                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; fetch byte #2 of the ship line heap into Y, which we
     **** ****     > LD_IND_Y_IDX
0001 A99A D820  50        movb @XX19,@rtmplb
     A99C 0074     
     A99E 2079     
0002 A9A0 D1A0  30        movb @XX19+1,rtmp
     A9A2 0075     
0003 A9A4 A182  18        a    ry,rtmp
0004 A9A6 D016  26        movb *rtmp,RA
                   < elite.a99
23001 A9A8 D080  18        movb ra,ry                      ; TAY               ; set to the explosion count for this ship (i.e. the
23002                                                                          ; number of vertices used as origins for explosion
23003                                                                          ; clouds)
23004                                                                          ;
23005                                                                          ; The explosion count is stored as 4 * n + 6, where n is
23006                                                                          ; the number of vertices, so the following loop copies
23007                                                                          ; the coordinates of the first n vertices from the heap
23008                                                                          ; at XX3, which is where we stored all the visible
23009                                                                          ; vertex coordinates in part 8 of the LL9 routine, and
23010                                                                          ; sticks them in the ship line heap pointed to by XX19,
23011                                                                          ; starting at byte #7 (so it leaves the first 6 bytes of
23012                                                                          ; the ship line heap alone)
23013               
23014               EXL1:
23015 A9AA D022  34        movb @XX3-7(ry),ra              ; LDA XX3-7,Y       ; Copy byte Y-7 from the XX3 heap, into the Y-th byte of
     A9AC 00F9     
23016                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 A9AE D820  50        movb @XX19,@rtmplb
     A9B0 0074     
     A9B2 2079     
0002 A9B4 D1A0  30        movb @XX19+1,rtmp
     A9B6 0075     
0003 A9B8 A182  18        a    ry,rtmp
0004 A9BA D580  30        movb RA,*rtmp
                   < elite.a99
23017               
23018 A9BC 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
23019               
23020 A9BE 0282  22        ci   ry,>06*256                 ; CPY #6            ; Keep copying vertex coordinates into the ship line
     A9C0 0600     
23021 A9C2 16F3  14        jne  EXL1                       ; BNE EXL1          ; heap until Y = 6 (which will copy n vertices, where n
23022                                                                          ; is the number of vertices we should be exploding)
23023               
23024 A9C4 D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 6 of the ship's byte #31 to denote that the
     A9C6 0072     
23025 A9C8 0260  22        ori  ra,>40*256                 ; ORA #%01000000    ; explosion has been drawn (as it's about to be)
     A9CA 4000     
23026 A9CC D800  30        movb ra,@INWK+31                ; STA INWK+31
     A9CE 0072     
23027               
23028               PTCLS:
23029                                                                          ; This part of the routine actually draws the explosion
23030                                                                          ; cloud
23031 A9D0 0202  20        li   ry,>00*256                 ; LDY #0            ; Fetch byte #0 of the ship line heap, which contains
     A9D2 0000     
23032                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; the cloud size we stored above, and store it in Q
     **** ****     > LD_IND_Y_IDX
0001 A9D4 D820  50        movb @XX19,@rtmplb
     A9D6 0074     
     A9D8 2079     
0002 A9DA D1A0  30        movb @XX19+1,rtmp
     A9DC 0075     
0003 A9DE A182  18        a    ry,rtmp
0004 A9E0 D016  26        movb *rtmp,RA
                   < elite.a99
23033 A9E2 D800  30        movb ra,@Q                      ; STA Q
     A9E4 0090     
23034               
23035 A9E6 B084  18        ab   rone,ry                    ; INY               ; Increment the index in Y to point to byte #1
23036               
23037                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch byte #1 of the ship line heap, which contains
     **** ****     > LD_IND_Y_IDX
0001 A9E8 D820  50        movb @XX19,@rtmplb
     A9EA 0074     
     A9EC 2079     
0002 A9EE D1A0  30        movb @XX19+1,rtmp
     A9F0 0075     
0003 A9F2 A182  18        a    ry,rtmp
0004 A9F4 D016  26        movb *rtmp,RA
                   < elite.a99
23038                                                                          ; the cloud counter. We are now going to process this
23039                                                                          ; into the number of particles in each vertex's cloud
23040               
23041 A9F6 1503  14        jgt  B69                        ; BPL B69           ; If the cloud counter < 128, then we are in the first
23042                                                                          ; half of the cloud's existence, so skip the next
23043                                                                          ; instruction
23044               
23045                      .eoi (>ff*256)                  ; EOR #&FF          ; Flip the value of A so that in the second half of the
     **** ****     > EOI
0001 A9F8 0206  20        li   rtmp,(>FF*256)
     A9FA FF00     
0002 A9FC 2806  18        xor  rtmp,ra
                   < elite.a99
23046                                                                          ; cloud's existence, A counts down instead of up
23047               
23048               B69:
23049 A9FE 0910  18        srl  ra,1                       ; LSR A             ; Divide A by 8 so that is has a maximum value of 15
23050 AA00 0910  18        srl  ra,1                       ; LSR A
23051 AA02 0910  18        srl  ra,1                       ; LSR A
23052               
23053 AA04 0260  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1 and store it in U, to
     AA06 0100     
23054 AA08 D800  30        movb ra,@U                      ; STA U             ; give us the number of particles in the explosion for
     AA0A 008F     
23055                                                                          ; each vertex
23056               
23057 AA0C B084  18        ab   rone,ry                    ; INY               ; Increment the index in Y to point to byte #2
23058               
23059                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch byte #2 of the ship line heap, which contains
     **** ****     > LD_IND_Y_IDX
0001 AA0E D820  50        movb @XX19,@rtmplb
     AA10 0074     
     AA12 2079     
0002 AA14 D1A0  30        movb @XX19+1,rtmp
     AA16 0075     
0003 AA18 A182  18        a    ry,rtmp
0004 AA1A D016  26        movb *rtmp,RA
                   < elite.a99
23060 AA1C D800  30        movb ra,@TGT                    ; STA TGT           ; the explosion count for this ship (i.e. the number of
     AA1E 00A0     
23061                                                                          ; vertices used as origins for explosion clouds) and
23062                                                                          ; store it in TGT
23063               
23064 AA20 D020  30        movb @RAND+1,ra                 ; LDA RAND+1        ; Fetch the current random number seed in RAND+1 and
     AA22 0001     
23065                      .pha                            ; PHA               ; store it on the stack, so we can re-randomise the
     **** ****     > PHA
0001 AA24 D680  30        movb ra,*rsp
0002 AA26 060A  14        dec  rsp
                   < elite.a99
23066                                                                          ; seeds when we are done
23067               
23068 AA28 0202  20        li   ry,>06*256                 ; LDY #6            ; Set Y = 6 to point to the byte before the first vertex
     AA2A 0600     
23069                                                                          ; coordinate we stored on the ship line heap above (we
23070                                                                          ; increment it below so it points to the first vertex)
23071               
23072               EXL5:
23073 AA2C 0201  20        li   rx,>03*256                 ; LDX #3            ; We are about to fetch a pair of coordinates from the
     AA2E 0300     
23074                                                                          ; ship line heap, so set a counter in X for 4 bytes
23075               
23076               EXL3:
23077 AA30 B084  18        ab   rone,ry                    ; INY               ; Increment the index in Y so it points to the next byte
23078                                                                          ; from the coordinate we are copying
23079               
23080                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Copy the Y-th byte from the ship line heap to the X-th
     **** ****     > LD_IND_Y_IDX
0001 AA32 D820  50        movb @XX19,@rtmplb
     AA34 0074     
     AA36 2079     
0002 AA38 D1A0  30        movb @XX19+1,rtmp
     AA3A 0075     
0003 AA3C A182  18        a    ry,rtmp
0004 AA3E D016  26        movb *rtmp,RA
                   < elite.a99
23081 AA40 D840  38        movb ra,@K3(rx)                 ; STA K3,X          ; byte of K3
     AA42 00D2     
23082               
23083 AA44 7044  18        sb   rone,rx                    ; DEX               ; Decrement the X index
23084               
23085 AA46 15F4  14        jgt  EXL3                       ; BPL EXL3          ; Loop back to EXL3 until we have copied all four bytes
23086               
23087                                                                          ; The above loop copies the vertex coordinates from the
23088                                                                          ; ship line heap to K3, reversing them as we go, so it
23089                                                                          ; sets the following:
23090                                                                          ;
23091                                                                          ; K3+3 = x_lo
23092                                                                          ; K3+2 = x_hi
23093                                                                          ; K3+1 = y_lo
23094                                                                          ; K3+0 = y_hi
23095               
23096 AA48 D802  30        movb ry,@CNT                    ; STY CNT           ; Set CNT to the index that points to the next vertex on
     AA4A 00A4     
23097                                                                          ; the ship line heap
23098               
23099 AA4C 0202  20        li   ry,>02*256                 ; LDY #2            ; Set Y = 2, which we will use to point to bytes #3 to
     AA4E 0200     
23100                                                                          ; #6, after incrementing it
23101               
23102                                                                          ; This next loop copies bytes #3 to #6 from the ship
23103                                                                          ; line heap into the four random number seeds in RAND to
23104                                                                          ; RAND+3, EOR'ing them with the vertex index so they are
23105                                                                          ; different for every vertex. This enables us to
23106                                                                          ; generate random numbers for drawing each vertex that
23107                                                                          ; are random but repeatable, which we need when we
23108                                                                          ; redraw the cloud to remove it
23109                                                                          ;
23110                                                                          ; Note that we haven't actually set the values of bytes
23111                                                                          ; #3 to #6 in the ship line heap, so we have no idea
23112                                                                          ; what they are, we just use what's already there. But
23113                                                                          ; the fact that those bytes are stored for this ship
23114                                                                          ; means we can repeat the random generation of the
23115                                                                          ; cloud, which is the important bit
23116               
23117               EXL2:
23118 AA50 B084  18        ab   rone,ry                    ; INY               ; Increment the index in Y so it points to the next
23119                                                                          ; random number seed to copy
23120               
23121                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y-th byte from the ship line heap
     **** ****     > LD_IND_Y_IDX
0001 AA52 D820  50        movb @XX19,@rtmplb
     AA54 0074     
     AA56 2079     
0002 AA58 D1A0  30        movb @XX19+1,rtmp
     AA5A 0075     
0003 AA5C A182  18        a    ry,rtmp
0004 AA5E D016  26        movb *rtmp,RA
                   < elite.a99
23122               
23123                      .eor @CNT                       ; EOR CNT           ; EOR with the vertex index, so the seeds are different
     **** ****     > EOR
0001 AA60 D1A0  30        movb @CNT,rtmp
     AA62 00A4     
0002 AA64 2806  18        xor  rtmp,ra
                   < elite.a99
23124                                                                          ; for each vertex
23125               
23126 AA66 D880  38        movb ra,@>FFFD(ry)              ; STA &FFFD,Y       ; Y is going from 3 to 6, so this stores the four bytes
     AA68 FFFD     
23127                                                                          ; in memory locations &00, &01, &02 and &03, which are
23128                                                                          ; the memory locations of RAND through RAND+3
23129               
23130 AA6A 0282  22        ci   ry,>06*256                 ; CPY #6            ; Loop back to EXL2 until Y = 6, which means we have
     AA6C 0600     
23131 AA6E 16F0  14        jne  EXL2                       ; BNE EXL2          ; copied four bytes
23132               
23133 AA70 D0A0  30        movb @U,ry                      ; LDY U             ; Set Y to the number of particles in the explosion for
     AA72 008F     
23134                                                                          ; each vertex, which we stored in U above. We will now
23135                                                                          ; use this as a loop counter to iterate through all the
23136                                                                          ; particles in the explosion
23137               
23138               EXL4:
23139 AA74 0206  20        li   rtmp,DORND2                ; JSR DORND2        ; Set ZZ to a random number, making sure the C flag
     AA76 C07A     
23140 AA78 06A0  32        bl   @jsr                       ;
     AA7A FF10     
23141 AA7C D800  30        movb ra,@ZZ                     ; STA ZZ            ; doesn't affect the outcome
     AA7E 0097     
23142               
23143 AA80 D020  30        movb @K3+1,ra                   ; LDA K3+1          ; Set (A R) = (y_hi y_lo)
     AA82 00D3     
23144 AA84 D800  30        movb ra,@R                      ; STA R             ; = y
     AA86 0091     
23145 AA88 D020  30        movb @K3,ra                     ; LDA K3
     AA8A 00D2     
23146               
23147 AA8C 0206  20        li   rtmp,EXS1                  ; JSR EXS1          ; Set (A X) = (A R) +/- random * cloud size
     AA8E AAF0     
23148 AA90 06A0  32        bl   @jsr                       ;
     AA92 FF10     
23149                                                                          ; = y +/- random * cloud size
23150               
23151 AA94 1627  14        jne  EX11                       ; BNE EX11          ; If A is non-zero, the particle is off-screen as the
23152                                                                          ; coordinate is bigger than 255), so jump to EX11 to do
23153                                                                          ; the next particle
23154               
23155 AA96 0281  22        ci   rx,(2*Y-1)*256             ; CPX #2*Y-1        ; If X > the y-coordinate of the bottom of the screen,
     AA98 BF00     
23156 AA9A 1824  14        joc  EX11                       ; BCS EX11          ; the particle is off the bottom of the screen, so jump
23157                                                                          ; to EX11 to do the next particle
23158               
23159                                                                          ; Otherwise X contains a random y-coordinate within the
23160                                                                          ; cloud
23161               
23162 AA9C D801  30        movb rx,@Y1                     ; STX Y1            ; Set Y1 = our random y-coordinate within the cloud
     AA9E 0032     
23163               
23164 AAA0 D020  30        movb @K3+3,ra                   ; LDA K3+3          ; Set (A R) = (x_hi x_lo)
     AAA2 00D5     
23165 AAA4 D800  30        movb ra,@R                      ; STA R
     AAA6 0091     
23166 AAA8 D020  30        movb @K3+2,ra                   ; LDA K3+2
     AAAA 00D4     
23167               
23168 AAAC 0206  20        li   rtmp,EXS1                  ; JSR EXS1          ; Set (A X) = (A R) +/- random * cloud size
     AAAE AAF0     
23169 AAB0 06A0  32        bl   @jsr                       ;
     AAB2 FF10     
23170                                                                          ; = x +/- random * cloud size
23171               
23172 AAB4 1606  14        jne  EX4                        ; BNE EX4           ; If A is non-zero, the particle is off-screen as the
23173                                                                          ; coordinate is bigger than 255), so jump to EX11 to do
23174                                                                          ; the next particle
23175               
23176                                                                          ; Otherwise X contains a random x-coordinate within the
23177                                                                          ; cloud
23178               
23179 AAB6 D020  30        movb @Y1,ra                     ; LDA Y1            ; Set A = our random y-coordinate within the cloud
     AAB8 0032     
23180               
23181 AABA 0206  20        li   rtmp,PIXEL                 ; JSR PIXEL         ; Draw a point at screen coordinate (X, A) with the
     AABC 27BC     
23182 AABE 06A0  32        bl   @jsr                       ;
     AAC0 FF10     
23183                                                                          ; point size determined by the distance in ZZ
23184               
23185               EX4:
23186 AAC2 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter for the next particle
23187               
23188 AAC4 15D7  14        jgt  EXL4                       ; BPL EXL4          ; Loop back to EXL4 until we have done all the particles
23189                                                                          ; in the cloud
23190               
23191 AAC6 D0A0  30        movb @CNT,ry                    ; LDY CNT           ; Set Y to the index that points to the next vertex on
     AAC8 00A4     
23192                                                                          ; the ship line heap
23193               
23194 AACA 90A0  30        cb   @TGT,ry                    ; CPY TGT           ; If Y < TGT, which we set to the explosion count for
     AACC 00A0     
23195 AACE 17AE  14        jnc  EXL5                       ; BCC EXL5          ; this ship (i.e. the number of vertices used as origins
23196                                                                          ; for explosion clouds), loop back to EXL5 to do a cloud
23197                                                                          ; for the next vertex
23198               
23199                      .pla                            ; PLA               ; Restore the current random number seed to RAND+1 that
     **** ****     > PLA
0001 AAD0 058A  14        inc  rsp
0002 AAD2 D01A  26        movb *rsp,ra
                   < elite.a99
23200 AAD4 D800  30        movb ra,@RAND+1                 ; STA RAND+1        ; we stored at the start of the routine
     AAD6 0001     
23201               
23202 AAD8 D020  30        movb @K.+6,ra                   ; LDA K%+6          ; Store the z_lo coordinate for the planet (which will
     AADA 0906     
23203 AADC D800  30        movb ra,@RAND+3                 ; STA RAND+3        ; be pretty random) in the RAND+3 seed
     AADE 0003     
23204               
23205 AAE0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AAE2 FF1C     
23206               
23207               EX11:
23208 AAE4 0206  20        li   rtmp,DORND2                ; JSR DORND2        ; Set A and X to random numbers, making sure the C flag
     AAE6 C07A     
23209 AAE8 06A0  32        bl   @jsr                       ;
     AAEA FF10     
23210                                                                          ; doesn't affect the outcome
23211               
23212 AAEC 0460  28        b    @EX4                       ; JMP EX4           ; We just skipped a particle, so jump up to EX4 to do
     AAEE AAC2     
23213                                                                          ; the next one
23214               
23215               EXS1:
23216                                                                          ; This routine calculates the following:
23217                                                                          ;
23218                                                                          ; (A X) = (A R) +/- random * cloud size
23219                                                                          ;
23220                                                                          ; returning with the flags set for the high byte in A
23221 AAF0 D800  30        movb ra,@S                      ; STA S             ; Store A in S so we can use it later
     AAF2 0092     
23222               
23223 AAF4 0206  20        li   rtmp,DORND2                ; JSR DORND2        ; Set A and X to random numbers, making sure the C flag
     AAF6 C07A     
23224 AAF8 06A0  32        bl   @jsr                       ;
     AAFA FF10     
23225                                                                          ; doesn't affect the outcome
23226               
23227 AAFC 06A0  32        bl   @rola                      ; ROL A             ; Set A = A * 2
     AAFE FF26     
23228               
23229 AB00 1811  14        joc  EX5                        ; BCS EX5           ; If bit 7 of A was set (50% chance), jump to EX5
23230               
23231 AB02 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set A = A * Q / 256
     AB04 4338     
23232 AB06 06A0  32        bl   @jsr                       ;
     AB08 FF10     
23233                                                                          ; = random << 1 * projected cloud size / 256
23234               
23235                      .adc @R,ra                      ; ADC R             ; Set (A X) = (S R) + A
     **** ****     > ADC
0001 AB0A 1701  14        jnc  !
0002 AB0C B004  18        ab   rone,ra
0003               !:
0004 AB0E B020  30        ab   @R,ra
     AB10 0091     
                   < elite.a99
23236 AB12 D040  18        movb ra,rx                      ; TAX               ; = (S R) + random * projected cloud size
23237                                                                          ;
23238                                                                          ; where S contains the argument A, starting with the low
23239                                                                          ; bytes
23240               
23241 AB14 D020  30        movb @S,ra                      ; LDA S             ; And then the high bytes
     AB16 0092     
23242                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 AB18 1701  14        jnc  !
0002 AB1A B004  18        ab   rone,ra
0003               !:
0004 AB1C 0220  22        ai   ra,(>00*256)
     AB1E 0000     
                   < elite.a99
23243               
23244 AB20 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AB22 FF1C     
23245               
23246               EX5:
23247 AB24 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     AB26 4338     
23248 AB28 06A0  32        bl   @jsr                       ;
     AB2A FF10     
23249 AB2C D800  30        movb ra,@T                      ; STA T             ; = random << 1 * projected cloud size / 256
     AB2E 00D1     
23250               
23251 AB30 D020  30        movb @R,ra                      ; LDA R             ; Set (A X) = (S R) - T
     AB32 0091     
23252                      .sbc @T,ra                      ; SBC T             ;
     **** ****     > SBC
0001 AB34 1801  14        joc  !
0002 AB36 7004  18        sb   rone,ra
0003               !:
0004 AB38 7020  30        sb   @T,ra
     AB3A 00D1     
                   < elite.a99
23253 AB3C D040  18        movb ra,rx                      ; TAX               ; where S contains the argument A, starting with the low
23254                                                                          ; bytes
23255               
23256 AB3E D020  30        movb @S,ra                      ; LDA S             ; And then the high bytes
     AB40 0092     
23257                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 AB42 1801  14        joc  !
0002 AB44 7004  18        sb   rone,ra
0003               !:
0004 AB46 0220  22        ai   ra,-(>00*256)
     AB48 0000     
                   < elite.a99
23258               
23259 AB4A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AB4C FF1C     
23260               
23261               * ******************************************************************************
23262               *
23263               * Name: SOS1
23264               * Type: Subroutine
23265               * Category: Universe
23266               * Summary: Update the missile indicators, set up the planet data block
23267               *
23268               * ------------------------------------------------------------------------------
23269               *
23270               * Update the missile indicators, and set up a data block for the planet, but
23271               * only setting the pitch and roll counters to 127 (no damping).
23272               *
23273               * ******************************************************************************
23274               
23275               SOS1:
23276 AB4E 0206  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     AB50 BFE8     
23277 AB52 06A0  32        bl   @jsr                       ;
     AB54 FF10     
23278                                                                          ; them are targeted
23279               
23280 AB56 0200  20        li   ra,>7f*256                 ; LDA #127          ; Set the pitch and roll counters to 127, so that's a
     AB58 7F00     
23281 AB5A D800  30        movb ra,@INWK+29                ; STA INWK+29       ; clockwise roll and a diving pitch with no damping, so
     AB5C 0070     
23282 AB5E D800  30        movb ra,@INWK+30                ; STA INWK+30       ; the planet's rotation doesn't slow down
     AB60 0071     
23283               
23284 AB62 D020  30        movb @tek_,ra                   ; LDA tek           ; Set A = 128 or 130 depending on bit 1 of the system's
     AB64 0F1D     
23285 AB66 0240  22        andi ra,>02*256                 ; AND #%00000010    ; tech level in tek
     AB68 0200     
23286 AB6A 0260  22        ori  ra,>80*256                 ; ORA #%10000000
     AB6C 8000     
23287               
23288 AB6E 0460  28        b    @NWSHP                     ; JMP NWSHP         ; Add a new planet to our local bubble of universe,
     AB70 AF7A     
23289                                                                          ; with the planet type defined by A (128 is a planet
23290                                                                          ; with an equator and meridian, 130 is a planet with
23291                                                                          ; a crater)
23292               
23293               * ******************************************************************************
23294               *
23295               * Name: SOLAR
23296               * Type: Subroutine
23297               * Category: Universe
23298               * Summary: Set up various aspects of arriving in a new system
23299               *
23300               * ------------------------------------------------------------------------------
23301               *
23302               * Halve our legal status, update the missile indicators, and set up data blocks
23303               * and slots for the planet and sun.
23304               *
23305               * ******************************************************************************
23306               
23307               SOLAR:
23308                      .lsr @FIST                      ; LSR FIST          ; Halve our legal status in FIST, making us less bad,
     **** ****     > LSR
0001 AB72 D1A0  30        movb @FIST,rtmp
     AB74 0334     
0002 AB76 0916  18        srl  rtmp,1
0003 AB78 D806  30        movb rtmp,@FIST
     AB7A 0334     
                   < elite.a99
23309                                                                          ; and moving bit 0 into the C flag (so every time we
23310                                                                          ; arrive in a new system, our legal status improves a
23311                                                                          ; bit)
23312               
23313 AB7C 0206  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace, which
     AB7E BFC0     
23314 AB80 06A0  32        bl   @jsr                       ;
     AB82 FF10     
23315                                                                          ; doesn't affect the C flag
23316               
23317 AB84 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch s0_hi
     AB86 0079     
23318               
23319 AB88 0240  22        andi ra,>07*256                 ; AND #%00000111    ; Extract bits 0-2 (which also happen to determine the
     AB8A 0700     
23320                                                                          ; economy), which will be between 0 and 7
23321               
23322                      .adi (>06*256)                  ; ADC #6            ; Add 6 + C, and divide by 2, to get a result between 3
     **** ****     > ADI
0001 AB8C 1701  14        jnc  !
0002 AB8E B004  18        ab   rone,ra
0003               !:
0004 AB90 0220  22        ai   ra,(>06*256)
     AB92 0600     
                   < elite.a99
23323 AB94 0910  18        srl  ra,1                       ; LSR A             ; and 7, at the same time shifting bit 0 of the result
23324                                                                          ; of the addition into the C flag
23325               
23326 AB96 D800  30        movb ra,@INWK+8                 ; STA INWK+8        ; Store the result in z_sign in byte #6
     AB98 005B     
23327               
23328 AB9A 06A0  32        bl   @rora                      ; ROR A             ; Halve A, rotating in the C flag, which was previously
     AB9C FF4A     
23329 AB9E D800  30        movb ra,@INWK+2                 ; STA INWK+2        ; bit 0 of s0_hi + 6 + C, so when this is stored in both
     ABA0 0055     
23330 ABA2 D800  30        movb ra,@INWK+5                 ; STA INWK+5        ; x_sign and y_sign, it moves the planet to the upper
     ABA4 0058     
23331                                                                          ; right or lower left
23332               
23333 ABA6 0206  20        li   rtmp,SOS1                  ; JSR SOS1          ; Call SOS1 to set up the planet's data block and add it
     ABA8 AB4E     
23334 ABAA 06A0  32        bl   @jsr                       ;
     ABAC FF10     
23335                                                                          ; to FRIN, where it will get put in the first slot as
23336                                                                          ; it's the first one to be added to our local bubble of
23337                                                                          ; this new system's universe
23338               
23339 ABAE D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Fetch s1_hi, extract bits 0-2, set bits 0 and 7 and
     ABB0 007B     
23340 ABB2 0240  22        andi ra,>07*256                 ; AND #%00000111    ; store in z_sign, so the sun is behind us at a distance
     ABB4 0700     
23341 ABB6 0260  22        ori  ra,>81*256                 ; ORA #%10000001    ; of 1 to 7
     ABB8 8100     
23342 ABBA D800  30        movb ra,@INWK+8                 ; STA INWK+8
     ABBC 005B     
23343               
23344 ABBE D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Fetch s2_hi, extract bits 0-1 and store in x_sign and
     ABC0 007D     
23345 ABC2 0240  22        andi ra,>03*256                 ; AND #%00000011    ; y_sign, so the sun is either dead centre in our rear
     ABC4 0300     
23346 ABC6 D800  30        movb ra,@INWK+2                 ; STA INWK+2        ; laser crosshairs, or off to the top left by a distance
     ABC8 0055     
23347 ABCA D800  30        movb ra,@INWK+1                 ; STA INWK+1        ; of 1 or 2 when we look out the back
     ABCC 0054     
23348               
23349 ABCE 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the pitch and roll counters to 0 (no rotation)
     ABD0 0000     
23350 ABD2 D800  30        movb ra,@INWK+29                ; STA INWK+29
     ABD4 0070     
23351 ABD6 D800  30        movb ra,@INWK+30                ; STA INWK+30
     ABD8 0071     
23352               
23353 ABDA 0200  20        li   ra,>81*256                 ; LDA #129          ; Set A = 129, the ship type for the sun
     ABDC 8100     
23354               
23355 ABDE 0206  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Call NWSHP to set up the sun's data block and add it
     ABE0 AF7A     
23356 ABE2 06A0  32        bl   @jsr                       ;
     ABE4 FF10     
23357                                                                          ; to FRIN, where it will get put in the second slot as
23358                                                                          ; it's the second one to be added to our local bubble
23359                                                                          ; of this new system's universe
23360               
23361               * ******************************************************************************
23362               *
23363               * Name: NWSTARS
23364               * Type: Subroutine
23365               * Category: Stardust
23366               * Summary: Initialise the stardust field
23367               *
23368               * ------------------------------------------------------------------------------
23369               *
23370               * This routine is called when the space view is initialised in routine LOOK1.
23371               *
23372               * ******************************************************************************
23373               
23374               NWSTARS:
23375 ABE6 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to WPSHPS to skip
     ABE8 0096     
23376               * ORA MJ                 \ the initialisation of the SX, SY and SZ tables. The OR
23377 ABEA 1622  14        jne  WPSHPS                     ; BNE WPSHPS        ; instruction is commented out in the original source,
23378                                                                          ; but it would have the effect of also skipping the
23379                                                                          ; initialisation if we had mis-jumped into witchspace
23380               
23381               * ******************************************************************************
23382               *
23383               * Name: nWq
23384               * Type: Subroutine
23385               * Category: Stardust
23386               * Summary: Create a random cloud of stardust
23387               *
23388               * ------------------------------------------------------------------------------
23389               *
23390               * Create a random cloud of stardust containing the correct number of dust
23391               * particles, i.e. NOSTM of them, which is 3 in witchspace and 18 (#NOST) in
23392               * normal space. Also clears the scanner and initialises the LSO block.
23393               *
23394               * This is called by the DEATH routine when it displays our untimely demise.
23395               *
23396               * ******************************************************************************
23397               
23398               nWq:
23399 ABEC D0A0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     ABEE 0F33     
23400                                                                          ; we can use it as a counter through all the stardust
23401               
23402               SAL4:
23403 ABF0 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     ABF2 C07C     
23404 ABF4 06A0  32        bl   @jsr                       ;
     ABF6 FF10     
23405               
23406 ABF8 0260  22        ori  ra,>08*256                 ; ORA #8            ; Set A so that it's at least 8
     ABFA 0800     
23407               
23408 ABFC D880  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; Store A in the Y-th particle's z_hi coordinate at
     ABFE 0EE8     
23409                                                                          ; SZ+Y, so the particle appears in front of us
23410               
23411 AC00 D800  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the particle's z_hi coordinate
     AC02 0097     
23412               
23413 AC04 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     AC06 C07C     
23414 AC08 06A0  32        bl   @jsr                       ;
     AC0A FF10     
23415               
23416 AC0C D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; Store A in the Y-th particle's x_hi coordinate at
     AC0E 034C     
23417                                                                          ; SX+Y, so the particle appears in front of us
23418               
23419 AC10 D800  30        movb ra,@X1                     ; STA X1            ; Set X1 to the particle's x_hi coordinate
     AC12 0031     
23420               
23421 AC14 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     AC16 C07C     
23422 AC18 06A0  32        bl   @jsr                       ;
     AC1A FF10     
23423               
23424 AC1C D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; Store A in the Y-th particle's y_hi coordinate at
     AC1E 0EC2     
23425                                                                          ; SY+Y, so the particle appears in front of us
23426               
23427 AC20 D800  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 to the particle's y_hi coordinate
     AC22 0032     
23428               
23429 AC24 0206  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ
     AC26 276C     
23430 AC28 06A0  32        bl   @jsr                       ;
     AC2A FF10     
23431               
23432 AC2C 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point to the next particle of
23433                                                                          ; stardust
23434               
23435 AC2E 16E0  14        jne  SAL4                       ; BNE SAL4          ; Loop back to SAL4 until we have randomised all the
23436                                                                          ; stardust particles
23437               
23438                                                                          ; Fall through into WPSHPS to clear the scanner and
23439                                                                          ; reset the LSO block
23440               
23441               * ******************************************************************************
23442               *
23443               * Name: WPSHPS
23444               * Type: Subroutine
23445               * Category: Dashboard
23446               * Summary: Clear the scanner, reset the ball line and sun line heaps
23447               *
23448               * ------------------------------------------------------------------------------
23449               *
23450               * Remove all ships from the scanner, reset the sun line heap at LSO, and reset
23451               * the ball line heap at LSX2 and LSY2.
23452               *
23453               * ******************************************************************************
23454               
23455               WPSHPS:
23456 AC30 0201  20        li   rx,>00*256                 ; LDX #0            ; Set up a counter in X to work our way through all the
     AC32 0000     
23457                                                                          ; ship slots in FRIN
23458               
23459               WSL1:
23460 AC34 D021  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the ship type in slot X
     AC36 0D40     
23461               
23462 AC38 1330  14        jeq  WS2                        ; BEQ WS2           ; If the slot contains 0 then it is empty and we have
23463                                                                          ; checked all the slots (as they are always shuffled
23464                                                                          ; down in the main loop to close up and gaps), so jump
23465                                                                          ; to WS2 as we are done
23466               
23467 AC3A 112D  14        jlt  WS1                        ; BMI WS1           ; If the slot contains a ship type with bit 7 set, then
23468                                                                          ; it contains the planet or the sun, so jump down to WS1
23469                                                                          ; to skip this slot, as the planet and sun don't appear
23470                                                                          ; on the scanner
23471               
23472 AC3C D800  30        movb ra,@TYPE                   ; STA TYPE          ; Store the ship type in TYPE
     AC3E 009B     
23473               
23474 AC40 0206  20        li   rtmp,GINF                  ; JSR GINF          ; Call GINF to get the address of the data block for
     AC42 AF0C     
23475 AC44 06A0  32        bl   @jsr                       ;
     AC46 FF10     
23476                                                                          ; ship slot X and store it in INF
23477               
23478 AC48 0202  20        li   ry,>1f*256                 ; LDY #31           ; We now want to copy the first 32 bytes from the ship's
     AC4A 1F00     
23479                                                                          ; data block into INWK, so set a counter in Y
23480               
23481               WSL2:
23482                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Copy the Y-th byte from the data block pointed to by
     **** ****     > LD_IND_Y_IDX
0001 AC4C D820  50        movb @INF,@rtmplb
     AC4E 0020     
     AC50 2079     
0002 AC52 D1A0  30        movb @INF+1,rtmp
     AC54 0021     
0003 AC56 A182  18        a    ry,rtmp
0004 AC58 D016  26        movb *rtmp,RA
                   < elite.a99
23483 AC5A D880  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; INF into the Y-th byte of INWK workspace
     AC5C 0053     
23484               
23485 AC5E 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point at the next byte
23486               
23487 AC60 15F5  14        jgt  WSL2                       ; BPL WSL2          ; Loop back to WSL2 until we have copied all 32 bytes
23488               
23489 AC62 D801  30        movb rx,@XSAV                   ; STX XSAV          ; Store the ship slot number in XSAV while we call SCAN
     AC64 0093     
23490               
23491 AC66 0206  20        li   rtmp,SCAN                  ; JSR SCAN          ; Call SCAN to plot this ship on the scanner, which will
     AC68 4C86     
23492 AC6A 06A0  32        bl   @jsr                       ;
     AC6C FF10     
23493                                                                          ; remove it as it's plotted with EOR logic
23494               
23495 AC6E D060  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the ship slot number from XSAV into X
     AC70 0093     
23496               
23497 AC72 0202  20        li   ry,>1f*256                 ; LDY #31           ; Clear bits 3, 4 and 6 in the ship's byte #31, which
     AC74 1F00     
23498                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; stops drawing the ship on-screen (bit 3), hides it
     **** ****     > LD_IND_Y_IDX
0001 AC76 D820  50        movb @INF,@rtmplb
     AC78 0020     
     AC7A 2079     
0002 AC7C D1A0  30        movb @INF+1,rtmp
     AC7E 0021     
0003 AC80 A182  18        a    ry,rtmp
0004 AC82 D016  26        movb *rtmp,RA
                   < elite.a99
23499 AC84 0240  22        andi ra,>a7*256                 ; AND #%10100111    ; from the scanner (bit 4) and stops any lasers firing
     AC86 A700     
23500                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; (bit 6)
     **** ****     > ST_IND_Y_IDX
0001 AC88 D820  50        movb @INF,@rtmplb
     AC8A 0020     
     AC8C 2079     
0002 AC8E D1A0  30        movb @INF+1,rtmp
     AC90 0021     
0003 AC92 A182  18        a    ry,rtmp
0004 AC94 D580  30        movb RA,*rtmp
                   < elite.a99
23501               
23502               WS1:
23503 AC96 B044  18        ab   rone,rx                    ; INX               ; Increment X to point to the next ship slot
23504               
23505 AC98 16CD  14        jne  WSL1                       ; BNE WSL1          ; Loop back up to process the next slot (this BNE is
23506                                                                          ; effectively a JMP as X will never be zero)
23507               
23508               WS2:
23509 AC9A 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Set LSX2 = LSY2 = &FF to clear the ball line heap
     AC9C FF00     
23510 AC9E D801  30        movb rx,@LSX2                   ; STX LSX2
     ACA0 0E26     
23511 ACA2 D801  30        movb rx,@LSY2                   ; STX LSY2
     ACA4 0E74     
23512               
23513                                                                          ; Fall through into FLFLLS to reset the LSO block
23514               
23515               * ******************************************************************************
23516               *
23517               * Name: FLFLLS
23518               * Type: Subroutine
23519               * Category: Drawing suns
23520               * Summary: Reset the sun line heap
23521               *
23522               * ------------------------------------------------------------------------------
23523               *
23524               * Reset the sun line heap at LSO by zero-filling it and setting the first byte
23525               * to &FF.
23526               *
23527               * ------------------------------------------------------------------------------
23528               *
23529               * Returns:
23530               *
23531               * A                   A is set to 0
23532               *
23533               * ******************************************************************************
23534               
23535               FLFLLS:
23536 ACA6 0202  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     ACA8 BF00     
23537                                                                          ; view, so this sets Y as a counter for the number of
23538                                                                          ; lines in the space view (i.e. 191), which is also the
23539                                                                          ; number of lines in the LSO block
23540               
23541 ACAA 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can zero-fill the LSO block
     ACAC 0000     
23542               
23543               SAL6:
23544 ACAE D880  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; Set the Y-th byte of the LSO block to 0
     ACB0 0D66     
23545               
23546 ACB2 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter
23547               
23548 ACB4 16FC  14        jne  SAL6                       ; BNE SAL6          ; Loop back until we have filled all the way to LSO+1
23549               
23550 ACB6 7084  18        sb   rone,ry                    ; DEY               ; Decrement Y to value of &FF (as we exit the above loop
23551                                                                          ; with Y = 0)
23552               
23553 ACB8 D802  30        movb ry,@LSX                    ; STY LSX           ; Set the first byte of the LSO block, which has its own
     ACBA 0D66     
23554                                                                          ; label LSX, to &FF, to indicate that the sun line heap
23555                                                                          ; is empty
23556               
23557 ACBC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     ACBE FF1C     
23558               
23559               * ******************************************************************************
23560               *
23561               * Name: DET1
23562               * Type: Subroutine
23563               * Category: Drawing the screen
23564               * Summary: Show or hide the dashboard (for when we die)
23565               *
23566               * ------------------------------------------------------------------------------
23567               *
23568               * This routine sets the screen to show the number of text rows given in X.
23569               *
23570               * It is used when we are killed, as reducing the number of rows from the usual
23571               * 31 to 24 has the effect of hiding the dashboard, leaving a monochrome image
23572               * of ship debris and explosion clouds. Increasing the rows back up to 31 makes
23573               * the dashboard reappear, as the dashboard's screen memory doesn't get touched
23574               * by this process.
23575               *
23576               * ------------------------------------------------------------------------------
23577               *
23578               * Arguments:
23579               *
23580               * X                   The number of text rows to display on the screen (24
23581               * will hide the dashboard, 31 will make it reappear)
23582               *
23583               * ------------------------------------------------------------------------------
23584               *
23585               * Returns:
23586               *
23587               * A                   A is set to 6
23588               *
23589               * ******************************************************************************
23590               
23591               DET1:
23592 ACC0 0200  20        li   ra,>06*256                 ; LDA #6            ; Set A to 6 so we can update 6845 register R6 below
     ACC2 0600     
23593               
23594 ACC4 0300  22        limi 0                          ; SEI               ; Disable interrupts so we can update the 6845
     ACC6 0000     
23595               
23596 ACC8 D800  38        movb ra,@VIA+>00                ; STA VIA+&00       ; Set 6845 register R6 to the value in X. Register R6
     ACCA FE00     
23597 ACCC D801  38        movb rx,@VIA+>01                ; STX VIA+&01       ; is the "vertical displayed" register, which sets the
     ACCE FE01     
23598                                                                          ; number of rows shown on the screen
23599               
23600 ACD0 0300  22        limi 2                          ; CLI               ; Re-enable interrupts
     ACD2 0002     
23601               
23602 ACD4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     ACD6 FF1C     
23603               
23604               * ******************************************************************************
23605               *
23606               * Name: SHD
23607               * Type: Subroutine
23608               * Category: Flight
23609               * Summary: Charge a shield and drain some energy from the energy banks
23610               *
23611               * ------------------------------------------------------------------------------
23612               *
23613               * Charge up a shield, and if it needs charging, drain some energy from the
23614               * energy banks.
23615               *
23616               * ------------------------------------------------------------------------------
23617               *
23618               * Arguments:
23619               *
23620               * X                   The value of the shield to recharge
23621               *
23622               * ******************************************************************************
23623               
23624 ACD8 7044  18        sb   rone,rx                    ; DEX               ; Increment the shield value so that it doesn't go past
23625                                                                          ; a maximum of 255
23626               
23627 ACDA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     ACDC FF1C     
23628               
23629               SHD:
23630 ACDE B044  18        ab   rone,rx                    ; INX               ; Increment the shield value
23631               
23632 ACE0 13FD  14        jeq  SHD-2                      ; BEQ SHD-2         ; If the shield value is 0 then this means it was 255
23633                                                                          ; before, which is the maximum value, so jump to SHD-2
23634                                                                          ; to bring it back down to 258 and return
23635               
23636                                                                          ; Otherwise fall through into DENGY to drain our energy
23637                                                                          ; to pay for all this shield charging
23638               
23639               * ******************************************************************************
23640               *
23641               * Name: DENGY
23642               * Type: Subroutine
23643               * Category: Flight
23644               * Summary: Drain some energy from the energy banks
23645               *
23646               * ------------------------------------------------------------------------------
23647               *
23648               * Returns:
23649               *
23650               * Z flag              Set if we have no energy left, clear otherwise
23651               *
23652               * ******************************************************************************
23653               
23654               DENGY:
23655 ACE2 7004  18        sb   rone,ra                    ; DEC ENERGY        ; Decrement the energy banks in ENERGY
23656               
23657                      .php                            ; PHP               ; Save the flags on the stack
     **** ****     > PHP
0001 ACE4 02C6  12        stst rtmp
0002 ACE6 D686  30        movb rtmp,*rsp
0003 ACE8 060A  14        dec  rsp
                   < elite.a99
23658               
23659 ACEA 1601  14        jne  B70                        ; BNE B70           ; If the energy levels are not yet zero, skip the
23660                                                                          ; following instruction
23661               
23662 ACEC B004  18        ab   rone,ra                    ; INC ENERGY        ; The minimum allowed energy level is 1, and we just
23663                                                                          ; reached 0, so increment ENERGY back to 1
23664               
23665               B70:
23666                      .plp                            ; PLP               ; Restore the flags from the stack, so we return with
     **** ****     > PLP
0001 ACEE 058A  14        INC  rsp
0002 ACF0 D19A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
23667                                                                          ; the Z flag from the DEC instruction above
23668               
23669 ACF2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     ACF4 FF1C     
23670               
23671               * ******************************************************************************
23672               *
23673               * Name: COMPAS
23674               * Type: Subroutine
23675               * Category: Dashboard
23676               * Summary: Update the compass
23677               *
23678               * ******************************************************************************
23679               
23680               COMPAS:
23681 ACF6 0206  20        li   rtmp,DOT                   ; JSR DOT           ; Call DOT to redraw (i.e. remove) the current compass
     ACF8 ADC0     
23682 ACFA 06A0  32        bl   @jsr                       ;
     ACFC FF10     
23683                                                                          ; dot
23684               
23685 ACFE D020  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     AD00 0D55     
23686 AD02 1634  14        jne  SP1                        ; BNE SP1           ; SP1 to draw the space station on the compass
23687               
23688 AD04 0206  20        li   rtmp,SPS1                  ; JSR SPS1          ; Otherwise we need to draw the planet on the compass,
     AD06 C97A     
23689 AD08 06A0  32        bl   @jsr                       ;
     AD0A FF10     
23690                                                                          ; so first call SPS1 to calculate the vector to the
23691                                                                          ; planet and store it in XX15
23692               
23693 AD0C 0460  28        b    @SP2                       ; JMP SP2           ; Jump to SP2 to draw XX15 on the compass, returning
     AD0E AD74     
23694                                                                          ; from the subroutine using a tail call
23695               
23696               * ******************************************************************************
23697               *
23698               * Name: SPS2
23699               * Type: Subroutine
23700               * Category: Maths (Arithmetic)
23701               * Summary: Calculate (Y X) = A / 10
23702               *
23703               * ------------------------------------------------------------------------------
23704               *
23705               * Calculate the following, where A is a sign-magnitude 8-bit integer and the
23706               * result is a signed 16-bit integer:
23707               *
23708               * (Y X) = A / 10
23709               *
23710               * ------------------------------------------------------------------------------
23711               *
23712               * Returns:
23713               *
23714               * C flag              The C flag is cleared
23715               *
23716               * ******************************************************************************
23717               
23718               SPS2:
23719                      .asla                           ; ASL A             ; Set X = |A| * 2, and set the C flag to the sign bit of
     **** ****     > ASLA
0001 AD10 0240  22        andi ra,>ff00
     AD12 FF00     
0002 AD14 0A10  18        sla  ra,1
                   < elite.a99
23720 AD16 D040  18        movb ra,rx                      ; TAX               ; A
23721               
23722 AD18 0200  20        li   ra,>00*256                 ; LDA #0            ; Set Y to have the sign bit from A in bit 7, with the
     AD1A 0000     
23723 AD1C 06A0  32        bl   @rora                      ; ROR A             ; rest of its bits zeroed, so Y now contains the sign of
     AD1E FF4A     
23724 AD20 D080  18        movb ra,ry                      ; TAY               ; the original argument
23725               
23726 AD22 0200  20        li   ra,>14*256                 ; LDA #20           ; Set Q = 20
     AD24 1400     
23727 AD26 D800  30        movb ra,@Q                      ; STA Q
     AD28 0090     
23728               
23729 AD2A D001  18        movb rx,ra                      ; TXA               ; Copy X into A, so A now contains the argument A * 2
23730               
23731 AD2C 0206  20        li   rtmp,DVID4                 ; JSR DVID4         ; Calculate the following:
     AD2E 45B0     
23732 AD30 06A0  32        bl   @jsr                       ;
     AD32 FF10     
23733                                                                          ;
23734                                                                          ; P = A / Q
23735                                                                          ; = |argument A| * 2 / 20
23736                                                                          ; = |argument A| / 10
23737               
23738 AD34 D060  30        movb @P,rx                      ; LDX P             ; Set X to the result
     AD36 001B     
23739               
23740 AD38 D002  18        movb ry,ra                      ; TYA               ; If the sign of the original argument A is negative,
23741 AD3A 1104  14        jlt  LL163                      ; BMI LL163         ; jump to LL163 to flip the sign of the result
23742               
23743 AD3C 0202  20        li   ry,>00*256                 ; LDY #0            ; Set the high byte of the result to 0, as the result is
     AD3E 0000     
23744                                                                          ; positive
23745               
23746 AD40 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AD42 FF1C     
23747               
23748               LL163:
23749 AD44 0202  20        li   ry,>ff*256                 ; LDY #&FF          ; The result is negative, so set the high byte to &FF
     AD46 FF00     
23750               
23751 AD48 D001  18        movb rx,ra                      ; TXA               ; Flip the low byte and add 1 to get the negated low
23752                      .eoi (>ff*256)                  ; EOR #&FF          ; byte, using two's complement
     **** ****     > EOI
0001 AD4A 0206  20        li   rtmp,(>FF*256)
     AD4C FF00     
0002 AD4E 2806  18        xor  rtmp,ra
                   < elite.a99
23753 AD50 D040  18        movb ra,rx                      ; TAX
23754 AD52 B044  18        ab   rone,rx                    ; INX
23755               
23756 AD54 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AD56 FF1C     
23757               
23758               * ******************************************************************************
23759               *
23760               * Name: SPS4
23761               * Type: Subroutine
23762               * Category: Maths (Geometry)
23763               * Summary: Calculate the vector to the space station
23764               *
23765               * ------------------------------------------------------------------------------
23766               *
23767               * Calculate the vector between our ship and the space station and store it in
23768               * XX15.
23769               *
23770               * ******************************************************************************
23771               
23772               SPS4:
23773 AD58 0201  20        li   rx,>08*256                 ; LDX #8            ; First we need to copy the space station's coordinates
     AD5A 0800     
23774                                                                          ; into K3, so set a counter to copy the first 9 bytes
23775                                                                          ; (the 3-byte x, y and z coordinates) from the station's
23776                                                                          ; data block at K% + NI% into K3
23777               
23778               SPL1:
23779 AD5C D021  34        movb @K.+NI.(rx),ra             ; LDA K%+NI%,X      ; Copy the X-th byte from the station's data block at
     AD5E 0924     
23780 AD60 D840  38        movb ra,@K3(rx)                 ; STA K3,X          ; K% + NI% to the X-th byte of K3
     AD62 00D2     
23781               
23782 AD64 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
23783               
23784 AD66 15FA  14        jgt  SPL1                       ; BPL SPL1          ; Loop back to SPL1 until we have copied all 9 bytes
23785               
23786 AD68 0460  28        b    @TAS2                      ; JMP TAS2          ; Call TAS2 to build XX15 from K3, returning from the
     AD6A C99E     
23787                                                                          ; subroutine using a tail call
23788               
23789               * ******************************************************************************
23790               *
23791               * Name: SP1
23792               * Type: Subroutine
23793               * Category: Dashboard
23794               * Summary: Draw the space station on the compass
23795               *
23796               * ******************************************************************************
23797               
23798               SP1:
23799 AD6C 0206  20        li   rtmp,SPS4                  ; JSR SPS4          ; Call SPS4 to calculate the vector to the space station
     AD6E AD58     
23800 AD70 06A0  32        bl   @jsr                       ;
     AD72 FF10     
23801                                                                          ; and store it in XX15
23802               
23803                                                                          ; Fall through into SP2 to draw XX15 on the compass
23804               
23805               * ******************************************************************************
23806               *
23807               * Name: SP2
23808               * Type: Subroutine
23809               * Category: Dashboard
23810               * Summary: Draw a dot on the compass, given the planet/station vector
23811               *
23812               * ------------------------------------------------------------------------------
23813               *
23814               * Draw a dot on the compass to represent the planet or station, whose normalised
23815               * vector is in XX15.
23816               *
23817               * XX15 to XX15+2      The normalised vector to the planet or space station,
23818               * stored as x in XX15, y in XX15+1 and z in XX15+2
23819               *
23820               * ******************************************************************************
23821               
23822               SP2:
23823 AD74 D020  30        movb @XX15,ra                   ; LDA XX15          ; Set A to the x-coordinate of the planet or station to
     AD76 0031     
23824                                                                          ; show on the compass, which will be in the range -96 to
23825                                                                          ; +96 as the vector has been normalised
23826               
23827 AD78 0206  20        li   rtmp,SPS2                  ; JSR SPS2          ; Set (Y X) = A / 10, so X will be from -9 to +9, which
     AD7A AD10     
23828 AD7C 06A0  32        bl   @jsr                       ;
     AD7E FF10     
23829                                                                          ; is the x-offset from the centre of the compass of the
23830                                                                          ; dot we want to draw. Returns with the C flag clear
23831               
23832 AD80 D001  18        movb rx,ra                      ; TXA               ; Set COMX = 195 + X, as 186 is the pixel x-coordinate
23833                      .adi (>c3*256)                  ; ADC #195          ; of the leftmost dot possible on the compass, and X can
     **** ****     > ADI
0001 AD82 1701  14        jnc  !
0002 AD84 B004  18        ab   rone,ra
0003               !:
0004 AD86 0220  22        ai   ra,(>C3*256)
     AD88 C300     
                   < elite.a99
23834 AD8A D800  30        movb ra,@COMX                   ; STA COMX          ; be -9, which would be 195 - 9 = 186. This also means
     AD8C 0F16     
23835                                                                          ; that the highest value for COMX is 195 + 9 = 204,
23836                                                                          ; which is the pixel x-coordinate of the rightmost dot
23837                                                                          ; in the compass... but the compass dot is actually two
23838                                                                          ; pixels wide, so the compass dot can overlap the right
23839                                                                          ; edge of the compass, but not the left edge
23840               
23841 AD8E D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A to the y-coordinate of the planet or station to
     AD90 0032     
23842                                                                          ; show on the compass, which will be in the range -96 to
23843                                                                          ; +96 as the vector has been normalised
23844               
23845 AD92 0206  20        li   rtmp,SPS2                  ; JSR SPS2          ; Set (Y X) = A / 10, so X will be from -9 to +9, which
     AD94 AD10     
23846 AD96 06A0  32        bl   @jsr                       ;
     AD98 FF10     
23847                                                                          ; is the x-offset from the centre of the compass of the
23848                                                                          ; dot we want to draw. Returns with the C flag clear
23849               
23850 AD9A D801  30        movb rx,@T                      ; STX T             ; Set COMY = 204 - X, as 203 is the pixel y-coordinate
     AD9C 00D1     
23851 AD9E 0200  20        li   ra,>cc*256                 ; LDA #204          ; of the centre of the compass, the C flag is clear,
     ADA0 CC00     
23852                      .sbc @T,ra                      ; SBC T             ; and the y-axis needs to be flipped around (because
     **** ****     > SBC
0001 ADA2 1801  14        joc  !
0002 ADA4 7004  18        sb   rone,ra
0003               !:
0004 ADA6 7020  30        sb   @T,ra
     ADA8 00D1     
                   < elite.a99
23853 ADAA D800  30        movb ra,@COMY                   ; STA COMY          ; when the planet or station is above us, and the
     ADAC 0F17     
23854                                                                          ; vector is therefore positive, we want to show the dot
23855                                                                          ; higher up on the compass, which has a smaller pixel
23856                                                                          ; y-coordinate). So this calculation does this:
23857                                                                          ;
23858                                                                          ; COMY = 204 - X - (1 - 0) = 203 - X
23859               
23860 ADAE 0200  20        li   ra,>f0*256                 ; LDA #&F0          ; Set A to a 4-pixel mode 5 byte row in colour 2
     ADB0 F000     
23861                                                                          ; (yellow/white), the colour for when the planet or
23862                                                                          ; station in the compass is in front of us
23863               
23864 ADB2 D060  30        movb @XX15+2,rx                 ; LDX XX15+2        ; If the z-coordinate of the XX15 vector is positive,
     ADB4 0033     
23865 ADB6 1502  14        jgt  B71                        ; BPL B71           ; skip the following instruction
23866               
23867 ADB8 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; The z-coordinate of XX15 is negative, so the planet or
     ADBA FF00     
23868                                                                          ; station is behind us and the compass dot should be in
23869                                                                          ; green/cyan, so set A to a 4-pixel mode 5 byte row in
23870                                                                          ; colour 3
23871               
23872               B71:
23873 ADBC D800  30        movb ra,@COMC                   ; STA COMC          ; Store the compass colour in COMC
     ADBE 0F48     
23874               
23875                                                                          ; Fall through into DOT to draw the dot on the compass
23876               
23877               * ******************************************************************************
23878               *
23879               * Name: DOT
23880               * Type: Subroutine
23881               * Category: Dashboard
23882               * Summary: Draw a dash on the compass
23883               *
23884               * ------------------------------------------------------------------------------
23885               *
23886               * Arguments:
23887               *
23888               * COMX                The screen pixel x-coordinate of the dash
23889               *
23890               * COMY                The screen pixel y-coordinate of the dash
23891               *
23892               * COMC                The colour and thickness of the dash:
23893               *
23894               * * &F0 = a double-height dash in yellow/white, for when
23895               * the object in the compass is in front of us
23896               *
23897               * * &FF = a single-height dash in green/cyan, for when
23898               * the object in the compass is behind us
23899               *
23900               * ******************************************************************************
23901               
23902               DOT:
23903 ADC0 D020  30        movb @COMY,ra                   ; LDA COMY          ; Set Y1 = COMY, the y-coordinate of the dash
     ADC2 0F17     
23904 ADC4 D800  30        movb ra,@Y1                     ; STA Y1
     ADC6 0032     
23905               
23906 ADC8 D020  30        movb @COMX,ra                   ; LDA COMX          ; Set X1 = COMX, the x-coordinate of the dash
     ADCA 0F16     
23907 ADCC D800  30        movb ra,@X1                     ; STA X1
     ADCE 0031     
23908               
23909 ADD0 D020  30        movb @COMC,ra                   ; LDA COMC          ; Set COL = COMC, the mode 5 colour byte for the dash
     ADD2 0F48     
23910 ADD4 D800  30        movb ra,@COL                    ; STA COL
     ADD6 00A2     
23911               
23912 ADD8 0280  22        ci   ra,>f0*256                 ; CMP #&F0          ; If COL is &F0 then the planet/station is in front of
     ADDA F000     
23913 ADDC 1605  14        jne  CPIX2                      ; BNE CPIX2         ; us and we want to draw a double-height dash, so if it
23914                                                                          ; isn't &F0 jump to CPIX2 to draw a single-height dash
23915               
23916                                                                          ; Otherwise fall through into CPIX4 to draw a double-
23917                                                                          ; height dash
23918               
23919               * ******************************************************************************
23920               *
23921               * Name: CPIX4
23922               * Type: Subroutine
23923               * Category: Drawing pixels
23924               * Summary: Draw a double-height dot on the dashboard
23925               *
23926               * ------------------------------------------------------------------------------
23927               *
23928               * Draw a double-height mode 5 dot (2 pixels high, 2 pixels wide).
23929               *
23930               * ------------------------------------------------------------------------------
23931               *
23932               * Arguments:
23933               *
23934               * X1                  The screen pixel x-coordinate of the bottom-left corner
23935               * of the dot
23936               *
23937               * Y1                  The screen pixel y-coordinate of the bottom-left corner
23938               * of the dot
23939               *
23940               * COL                 The colour of the dot as a mode 5 character row byte
23941               *
23942               * ******************************************************************************
23943               
23944               CPIX4:
23945 ADDE 0206  20        li   rtmp,CPIX2                 ; JSR CPIX2         ; Call CPIX2 to draw a single-height dash at (X1, Y1)
     ADE0 ADE8     
23946 ADE2 06A0  32        bl   @jsr                       ;
     ADE4 FF10     
23947               
23948 ADE6 7004  18        sb   rone,ra                    ; DEC Y1            ; Decrement Y1
23949               
23950                                                                          ; Fall through into CPIX2 to draw a second single-height
23951                                                                          ; dash on the pixel row above the first one, to create a
23952                                                                          ; double-height dot
23953               
23954               * ******************************************************************************
23955               *
23956               * Name: CPIX2
23957               * Type: Subroutine
23958               * Category: Drawing pixels
23959               * Summary: Draw a single-height dash on the dashboard
23960               * Deep dive: Drawing colour pixels in mode 5
23961               *
23962               * ------------------------------------------------------------------------------
23963               *
23964               * Draw a single-height mode 5 dash (1 pixel high, 2 pixels wide).
23965               *
23966               * ------------------------------------------------------------------------------
23967               *
23968               * Arguments:
23969               *
23970               * X1                  The screen pixel x-coordinate of the dash
23971               *
23972               * Y1                  The screen pixel y-coordinate of the dash
23973               *
23974               * COL                 The colour of the dash as a mode 5 character row byte
23975               *
23976               * ******************************************************************************
23977               
23978               CPIX2:
23979 ADE8 D020  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate into A
     ADEA 0032     
23980               
23981               * .CPIX                  \ This label is commented out in the original source. It
23982                                                                          ; would provide a new entry point with A specifying the
23983                                                                          ; y-coordinate instead of Y1, but it isn't used anywhere
23984               
23985 ADEC D080  18        movb ra,ry                      ; TAY               ; Store the y-coordinate in Y
23986               
23987 ADEE 0910  18        srl  ra,1                       ; LSR A             ; Set A = A / 8, so A now contains the character row we
23988 ADF0 0910  18        srl  ra,1                       ; LSR A             ; need to draw in (as each character row contains 8
23989 ADF2 0910  18        srl  ra,1                       ; LSR A             ; pixel rows)
23990               
23991 ADF4 0260  22        ori  ra,>60*256                 ; ORA #&60          ; Each character row in Elite's screen mode takes up one
     ADF6 6000     
23992                                                                          ; page in memory (256 bytes), so we now OR with &60 to
23993                                                                          ; get the page containing the dash (see the comments in
23994                                                                          ; routine TT26 for more discussion about calculating
23995                                                                          ; screen memory addresses)
23996               
23997 ADF8 D800  30        movb ra,@SCH                    ; STA SCH           ; Store the screen page in the high byte of SC(1 0)
     ADFA 0008     
23998               
23999 ADFC D020  30        movb @X1,ra                     ; LDA X1            ; Each character block contains 8 pixel rows, so to get
     ADFE 0031     
24000 AE00 0240  22        andi ra,>f8*256                 ; AND #%11111000    ; the address of the first byte in the character block
     AE02 F800     
24001                                                                          ; that we need to draw into, as an offset from the start
24002                                                                          ; of the row, we clear bits 0-2
24003               
24004 AE04 D800  30        movb ra,@SC                     ; STA SC            ; Store the address of the character block in the low
     AE06 0007     
24005                                                                          ; byte of SC(1 0), so now SC(1 0) points to the
24006                                                                          ; character block we need to draw into
24007               
24008 AE08 D002  18        movb ry,ra                      ; TYA               ; Set Y to just bits 0-2 of the y-coordinate, which will
24009 AE0A 0240  22        andi ra,>07*256                 ; AND #%00000111    ; be the number of the pixel row we need to draw into
     AE0C 0700     
24010 AE0E D080  18        movb ra,ry                      ; TAY               ; within the character block
24011               
24012 AE10 D020  30        movb @X1,ra                     ; LDA X1            ; Copy bits 0-1 of X1 to bits 1-2 of X, and clear the C
     AE12 0031     
24013 AE14 0240  22        andi ra,>06*256                 ; AND #%00000110    ; flag in the process (using the LSR). X will now be
     AE16 0600     
24014 AE18 0910  18        srl  ra,1                       ; LSR A             ; a value between 0 and 3, and will be the pixel number
24015 AE1A D040  18        movb ra,rx                      ; TAX               ; in the character row for the left pixel in the dash.
24016                                                                          ; This is because each character row is one byte that
24017                                                                          ; contains 4 pixels, but covers 8 screen coordinates, so
24018                                                                          ; this effectively does the division by 2 that we need
24019               
24020 AE1C D021  34        movb @CTWOS(rx),ra              ; LDA CTWOS,X       ; Fetch a mode 5 1-pixel byte with the pixel position
     AE1E 2249     
24021                      .and @COL                       ; AND COL           ; at X, and AND with the colour byte so that pixel takes
     **** ****     > AND
0001 AE20 D1A0  30        movb @COL,rtmp
     AE22 00A2     
0002 AE24 0546  14        inv  rtmp
0003 AE26 5006  18        szcb rtmp,ra
                   < elite.a99
24022                                                                          ; on the colour we want to draw (i.e. A is acting as a
24023                                                                          ; mask on the colour byte)
24024               
24025                      .eor @SC                        ; EOR (SC),Y        ; Draw the pixel on-screen using EOR logic, so we can
     **** ****     > EOR
0001 AE28 D1A0  30        movb @SC,rtmp
     AE2A 0007     
0002 AE2C 2806  18        xor  rtmp,ra
                   < elite.a99
24026                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; remove it later without ruining the background that's
     **** ****     > ST_IND_Y_IDX
0001 AE2E D820  50        movb @SC,@rtmplb
     AE30 0007     
     AE32 2079     
0002 AE34 D1A0  30        movb @SC+1,rtmp
     AE36 0008     
0003 AE38 A182  18        a    ry,rtmp
0004 AE3A D580  30        movb RA,*rtmp
                   < elite.a99
24027                                                                          ; already on-screen
24028               
24029 AE3C D021  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Fetch a mode 5 1-pixel byte with the pixel position
     AE3E 224A     
24030                                                                          ; at X+1, so we can draw the right pixel of the dash
24031               
24032 AE40 150A  14        jgt  CP1                        ; BPL CP1           ; The CTWOS table has an extra row at the end of it that
24033                                                                          ; repeats the first value, %10001000, so if we have not
24034                                                                          ; fetched that value, then the right pixel of the dash
24035                                                                          ; is in the same character block as the left pixel, so
24036                                                                          ; jump to CP1 to draw it
24037               
24038 AE42 D020  30        movb @SC,ra                     ; LDA SC            ; Otherwise the left pixel we drew was at the last
     AE44 0007     
24039                      .adi (>08*256)                  ; ADC #8            ; position of four in this character block, so we add
     **** ****     > ADI
0001 AE46 1701  14        jnc  !
0002 AE48 B004  18        ab   rone,ra
0003               !:
0004 AE4A 0220  22        ai   ra,(>08*256)
     AE4C 0800     
                   < elite.a99
24040 AE4E D800  30        movb ra,@SC                     ; STA SC            ; 8 to the screen address to move onto the next block
     AE50 0007     
24041                                                                          ; along (as there are 8 bytes in a character block).
24042                                                                          ; The C flag was cleared above, so this ADC is correct
24043               
24044 AE52 D021  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Re-fetch the mode 5 1-pixel byte, as we just overwrote
     AE54 224A     
24045                                                                          ; A (the byte will still be the fifth byte from the
24046                                                                          ; table, which is correct as we want to draw the
24047                                                                          ; leftmost pixel in the next character along as the
24048                                                                          ; dash's right pixel)
24049               
24050               CP1:
24051                      .and @COL                       ; AND COL           ; Apply the colour mask to the pixel byte, as above
     **** ****     > AND
0001 AE56 D1A0  30        movb @COL,rtmp
     AE58 00A2     
0002 AE5A 0546  14        inv  rtmp
0003 AE5C 5006  18        szcb rtmp,ra
                   < elite.a99
24052               
24053                      .eor @SC                        ; EOR (SC),Y        ; Draw the dash's right pixel according to the mask in
     **** ****     > EOR
0001 AE5E D1A0  30        movb @SC,rtmp
     AE60 0007     
0002 AE62 2806  18        xor  rtmp,ra
                   < elite.a99
24054                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; A, with the colour in COL, using EOR logic, just as
     **** ****     > ST_IND_Y_IDX
0001 AE64 D820  50        movb @SC,@rtmplb
     AE66 0007     
     AE68 2079     
0002 AE6A D1A0  30        movb @SC+1,rtmp
     AE6C 0008     
0003 AE6E A182  18        a    ry,rtmp
0004 AE70 D580  30        movb RA,*rtmp
                   < elite.a99
24055                                                                          ; above
24056               
24057 AE72 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AE74 FF1C     
24058               
24059               * ******************************************************************************
24060               *
24061               * Name: OOPS
24062               * Type: Subroutine
24063               * Category: Flight
24064               * Summary: Take some damage
24065               *
24066               * ------------------------------------------------------------------------------
24067               *
24068               * We just took some damage, so reduce the shields if we have any, or reduce the
24069               * energy levels and potentially take some damage to the cargo if we don't.
24070               *
24071               * ------------------------------------------------------------------------------
24072               *
24073               * Arguments:
24074               *
24075               * A                   The amount of damage to take
24076               *
24077               * INF                 The address of the ship block for the ship that attacked
24078               * us, or the ship that we just ran into
24079               *
24080               * ******************************************************************************
24081               
24082               OOPS:
24083 AE76 D800  30        movb ra,@T                      ; STA T             ; Store the amount of damage in T
     AE78 00D1     
24084               
24085 AE7A 0202  20        li   ry,>08*256                 ; LDY #8            ; Fetch byte #8 (z_sign) for the ship attacking us, and
     AE7C 0800     
24086 AE7E 0201  20        li   rx,>00*256                 ; LDX #0            ; set X = 0
     AE80 0000     
24087                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y
     **** ****     > LD_IND_Y_IDX
0001 AE82 D820  50        movb @INF,@rtmplb
     AE84 0020     
     AE86 2079     
0002 AE88 D1A0  30        movb @INF+1,rtmp
     AE8A 0021     
0003 AE8C A182  18        a    ry,rtmp
0004 AE8E D016  26        movb *rtmp,RA
                   < elite.a99
24088               
24089 AE90 110E  14        jlt  OO1                        ; BMI OO1           ; If A is negative, then we got hit in the rear, so jump
24090                                                                          ; to OO1 to process damage to the aft shield
24091               
24092 AE92 D020  30        movb @FSH,ra                    ; LDA FSH           ; Otherwise the forward shield was damaged, so fetch the
     AE94 0F11     
24093                      .sbc @T,ra                      ; SBC T             ; shield strength from FSH and subtract the damage in T
     **** ****     > SBC
0001 AE96 1801  14        joc  !
0002 AE98 7004  18        sb   rone,ra
0003               !:
0004 AE9A 7020  30        sb   @T,ra
     AE9C 00D1     
                   < elite.a99
24094               
24095 AE9E 1704  14        jnc  OO2                        ; BCC OO2           ; If the C flag is clear then this amount of damage was
24096                                                                          ; too much for the shields, so jump to OO2 to set the
24097                                                                          ; shield level to 0 and start taking damage directly
24098                                                                          ; from the energy banks
24099               
24100 AEA0 D800  30        movb ra,@FSH                    ; STA FSH           ; Store the new value of the forward shield in FSH
     AEA2 0F11     
24101               
24102 AEA4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AEA6 FF1C     
24103               
24104               OO2:
24105               * LDX #0                 \ This instruction is commented out in the original
24106                                                                          ; source, and isn't required as X is set to 0 above
24107 AEA8 D801  30        movb rx,@FSH                    ; STX FSH           ; Set the forward shield to 0
     AEAA 0F11     
24108               
24109 AEAC 170D  14        jnc  OO3                        ; BCC OO3           ; Jump to OO3 to start taking damage directly from the
24110                                                                          ; energy banks (this BCC is effectively a JMP as the C
24111                                                                          ; flag is clear, as we jumped to OO2 with a BCC)
24112               
24113               OO1:
24114 AEAE D020  30        movb @ASH,ra                    ; LDA ASH           ; The aft shield was damaged, so fetch the shield
     AEB0 0F12     
24115                      .sbc @T,ra                      ; SBC T             ; strength from ASH and subtract the damage in T
     **** ****     > SBC
0001 AEB2 1801  14        joc  !
0002 AEB4 7004  18        sb   rone,ra
0003               !:
0004 AEB6 7020  30        sb   @T,ra
     AEB8 00D1     
                   < elite.a99
24116               
24117 AEBA 1704  14        jnc  OO5                        ; BCC OO5           ; If the C flag is clear then this amount of damage was
24118                                                                          ; too much for the shields, so jump to OO5 to set the
24119                                                                          ; shield level to 0 and start taking damage directly
24120                                                                          ; from the energy banks
24121               
24122 AEBC D800  30        movb ra,@ASH                    ; STA ASH           ; Store the new value of the aft shield in ASH
     AEBE 0F12     
24123               
24124 AEC0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AEC2 FF1C     
24125               
24126               OO5:
24127               * LDX #0                 \ This instruction is commented out in the original
24128                                                                          ; source, and isn't required as X is set to 0 above
24129 AEC4 D801  30        movb rx,@ASH                    ; STX ASH           ; Set the aft shield to 0
     AEC6 0F12     
24130               
24131               OO3:
24132                      .adc @ENERGY,ra                 ; ADC ENERGY        ; A is negative and contains the amount by which the
     **** ****     > ADC
0001 AEC8 1701  14        jnc  !
0002 AECA B004  18        ab   rone,ra
0003               !:
0004 AECC B020  30        ab   @ENERGY,ra
     AECE 0F13     
                   < elite.a99
24133 AED0 D800  30        movb ra,@ENERGY                 ; STA ENERGY        ; damage overwhelmed the shields, so this drains the
     AED2 0F13     
24134                                                                          ; energy banks by that amount (and because the energy
24135                                                                          ; banks are shown over four indicators rather than one,
24136                                                                          ; but with the same value range of 0-255, energy will
24137                                                                          ; appear to drain away four times faster than the
24138                                                                          ; shields did)
24139               
24140 AED4 1301  14        jeq  B72                        ; BEQ B72           ; If we have just run out of energy, skip the next
24141                                                                          ; instruction to jump straight to our death
24142               
24143 AED6 1802  14        joc  B73                        ; BCS B73           ; If the C flag is set, then subtracting the damage from
24144                                                                          ; the energy banks didn't underflow, so we had enough
24145                                                                          ; energy to survive, and we can skip the next
24146                                                                          ; instruction to make a sound and take some damage
24147               
24148               B72:
24149 AED8 0460  28        b    @DEATH                     ; JMP DEATH         ; Otherwise our energy levels are either 0 or negative,
     AEDA C47E     
24150                                                                          ; and in either case that means we jump to our DEATH,
24151                                                                          ; returning from the subroutine using a tail call
24152               
24153               B73:
24154 AEDC 0206  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; We didn't die, so call EXNO3 to make the sound of a
     AEDE CB2E     
24155 AEE0 06A0  32        bl   @jsr                       ;
     AEE2 FF10     
24156                                                                          ; collision
24157               
24158 AEE4 0460  28        b    @OUCH                      ; JMP OUCH          ; And jump to OUCH to take damage and return from the
     AEE6 CEA0     
24159                                                                          ; subroutine using a tail call
24160               
24161               * ******************************************************************************
24162               *
24163               * Name: SPS3
24164               * Type: Subroutine
24165               * Category: Maths (Geometry)
24166               * Summary: Copy a space coordinate from the K% block into K3
24167               *
24168               * ------------------------------------------------------------------------------
24169               *
24170               * Copy one of the planet's coordinates into the corresponding location in the
24171               * temporary variable K3. The high byte and absolute value of the sign byte are
24172               * copied into the first two K3 bytes, and the sign of the sign byte is copied
24173               * into the highest K3 byte.
24174               *
24175               * The comments below are written for copying the planet's x-coordinate into
24176               * K3(2 1 0).
24177               *
24178               * ------------------------------------------------------------------------------
24179               *
24180               * Arguments:
24181               *
24182               * X                   Determines which coordinate to copy, and to where:
24183               *
24184               * * X = 0 copies (x_sign, x_hi) into K3(2 1 0)
24185               *
24186               * * X = 3 copies (y_sign, y_hi) into K3(5 4 3)
24187               *
24188               * * X = 6 copies (z_sign, z_hi) into K3(8 7 6)
24189               *
24190               * ******************************************************************************
24191               
24192               SPS3:
24193 AEE8 D021  34        movb @K.+1(rx),ra               ; LDA K%+1,X        ; Copy x_hi into K3+X
     AEEA 0901     
24194 AEEC D840  38        movb ra,@K3(rx)                 ; STA K3,X
     AEEE 00D2     
24195               
24196 AEF0 D021  34        movb @K.+2(rx),ra               ; LDA K%+2,X        ; Set A = Y = x_sign
     AEF2 0902     
24197 AEF4 D080  18        movb ra,ry                      ; TAY
24198               
24199 AEF6 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Set K3+1 = |x_sign|
     AEF8 7F00     
24200 AEFA D840  38        movb ra,@K3+1(rx)               ; STA K3+1,X
     AEFC 00D3     
24201               
24202 AEFE D002  18        movb ry,ra                      ; TYA               ; Set K3+2 = the sign of x_sign
24203 AF00 0240  22        andi ra,>80*256                 ; AND #%10000000
     AF02 8000     
24204 AF04 D840  38        movb ra,@K3+2(rx)               ; STA K3+2,X
     AF06 00D4     
24205               
24206 AF08 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AF0A FF1C     
24207               
24208               * ******************************************************************************
24209               *
24210               * Name: GINF
24211               * Type: Subroutine
24212               * Category: Universe
24213               * Summary: Fetch the address of a ship's data block into INF
24214               *
24215               * ------------------------------------------------------------------------------
24216               *
24217               * Get the address of the data block for ship slot X and store it in INF. This
24218               * address is fetched from the UNIV table, which stores the addresses of the 13
24219               * ship data blocks in workspace K%.
24220               *
24221               * ------------------------------------------------------------------------------
24222               *
24223               * Arguments:
24224               *
24225               * X                   The ship slot number for which we want the data block
24226               * address
24227               *
24228               * ******************************************************************************
24229               
24230               GINF:
24231 AF0C D001  18        movb rx,ra                      ; TXA               ; Set Y = X * 2
24232                      .asla                           ; ASL A
     **** ****     > ASLA
0001 AF0E 0240  22        andi ra,>ff00
     AF10 FF00     
0002 AF12 0A10  18        sla  ra,1
                   < elite.a99
24233 AF14 D080  18        movb ra,ry                      ; TAY
24234               
24235 AF16 D022  34        movb @UNIV(ry),ra               ; LDA UNIV,Y        ; Get the high byte of the address of the X-th ship
     AF18 221F     
24236 AF1A D800  30        movb ra,@INF                    ; STA INF           ; from UNIV and store it in INF
     AF1C 0020     
24237               
24238 AF1E D022  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y      ; Get the low byte of the address of the X-th ship
     AF20 2220     
24239 AF22 D800  30        movb ra,@INF+1                  ; STA INF+1         ; from UNIV and store it in INF
     AF24 0021     
24240               
24241 AF26 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AF28 FF1C     
24242               
24243               * ******************************************************************************
24244               *
24245               * Name: NWSPS
24246               * Type: Subroutine
24247               * Category: Universe
24248               * Summary: Add a new space station to our local bubble of universe
24249               *
24250               * ******************************************************************************
24251               
24252               NWSPS:
24253 AF2A 0206  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Light up the space station bulb on the dashboard
     AF2C B0E2     
24254 AF2E 06A0  32        bl   @jsr                       ;
     AF30 FF10     
24255               
24256 AF32 0201  20        li   rx,>01*256                 ; LDX #%00000001    ; Set the AI flag in byte #32 to %00000001 (friendly, no
     AF34 0100     
24257 AF36 D801  30        movb rx,@INWK+32                ; STX INWK+32       ; AI, has an E.C.M.)
     AF38 0073     
24258               
24259 AF3A 7044  18        sb   rone,rx                    ; DEX               ; Set pitch counter to 0 (no pitch, roll only)
24260 AF3C D801  30        movb rx,@INWK+30                ; STX INWK+30
     AF3E 0071     
24261               
24262               * STX INWK+31            \ This instruction is commented out in the original
24263                                                                          ; source. It would set the exploding state and missile
24264                                                                          ; count to 0
24265               
24266 AF40 D801  30        movb rx,@FRIN+1                 ; STX FRIN+1        ; Set the second slot in the FRIN table to 0, so when we
     AF42 0D41     
24267                                                                          ; fall through into NWSHP below, the new station that
24268                                                                          ; gets created will go into slot FRIN+1, as this will be
24269                                                                          ; the first empty slot that the routine finds
24270               
24271 AF44 7044  18        sb   rone,rx                    ; DEX               ; Set the roll counter to 255 (maximum anti-clockwise
24272 AF46 D801  30        movb rx,@INWK+29                ; STX INWK+29       ; roll with no damping)
     AF48 0070     
24273               
24274 AF4A 0201  20        li   rx,>0a*256                 ; LDX #10           ; Call NwS1 to flip the sign of nosev_x_hi (byte #10)
     AF4C 0A00     
24275 AF4E 0206  20        li   rtmp,NwS1                  ; JSR NwS1
     AF50 B08C     
24276 AF52 06A0  32        bl   @jsr                       ;
     AF54 FF10     
24277               
24278 AF56 0206  20        li   rtmp,NwS1                  ; JSR NwS1          ; And again to flip the sign of nosev_y_hi (byte #12)
     AF58 B08C     
24279 AF5A 06A0  32        bl   @jsr                       ;
     AF5C FF10     
24280               
24281 AF5E 0206  20        li   rtmp,NwS1                  ; JSR NwS1          ; And again to flip the sign of nosev_z_hi (byte #14)
     AF60 B08C     
24282 AF62 06A0  32        bl   @jsr                       ;
     AF64 FF10     
24283               
24284 AF66 0200  20        li   ra,((LSO)%256)*256         ; LDA #LO(LSO)      ; Set bytes #33 and #34 to point to LSO for the ship
     AF68 6600     
24285 AF6A D800  30        movb ra,@INWK+33                ; STA INWK+33       ; line heap for the space station
     AF6C 0074     
24286 AF6E 0200  20        li   ra,((LSO)/256)*256         ; LDA #HI(LSO)
     AF70 0D00     
24287 AF72 D800  30        movb ra,@INWK+34                ; STA INWK+34
     AF74 0075     
24288               
24289 AF76 0200  20        li   ra,(SST)*256               ; LDA #SST          ; Set A to the space station type, and fall through
     AF78 0800     
24290                                                                          ; into NWSHP to finish adding the space station to the
24291                                                                          ; universe
24292               
24293               * ******************************************************************************
24294               *
24295               * Name: NWSHP
24296               * Type: Subroutine
24297               * Category: Universe
24298               * Summary: Add a new ship to our local bubble of universe
24299               *
24300               * ------------------------------------------------------------------------------
24301               *
24302               * This creates a new block of ship data in the K% workspace, allocates a new
24303               * block in the ship line heap at WP, adds the new ship's type into the first
24304               * empty slot in FRIN, and adds a pointer to the ship data into UNIV. If there
24305               * isn't enough free memory for the new ship, it isn't added.
24306               *
24307               * ------------------------------------------------------------------------------
24308               *
24309               * Arguments:
24310               *
24311               * A                   The type of the ship to add (see variable XX21 for a
24312               * list of ship types)
24313               *
24314               * ------------------------------------------------------------------------------
24315               *
24316               * Returns:
24317               *
24318               * C flag              Set if the ship was successfully added, clear if it
24319               * wasn't (as there wasn't enough free memory)
24320               *
24321               * INF                 Points to the new ship's data block in K%
24322               *
24323               * ******************************************************************************
24324               
24325               NWSHP:
24326 AF7A D800  30        movb ra,@T                      ; STA T             ; Store the ship type in location T
     AF7C 00D1     
24327               
24328 AF7E 0201  20        li   rx,>00*256                 ; LDX #0            ; Before we can add a new ship, we need to check
     AF80 0000     
24329                                                                          ; whether we have an empty slot we can put it in. To do
24330                                                                          ; this, we need to loop through all the slots to look
24331                                                                          ; for an empty one, so set a counter in X that starts
24332                                                                          ; from the first slot at 0. When ships are killed, then
24333                                                                          ; the slots are shuffled down by the KILLSHP routine, so
24334                                                                          ; the first empty slot will always come after the last
24335                                                                          ; filled slot. This allows us to tack the new ship's
24336                                                                          ; data block and ship line heap onto the end of the
24337                                                                          ; existing ship data and heap, as shown in the memory
24338                                                                          ; map below
24339               
24340               NWL1:
24341 AF82 D021  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Load the ship type for the X-th slot
     AF84 0D40     
24342               
24343 AF86 1307  14        jeq  NW1                        ; BEQ NW1           ; If it is zero, then this slot is empty and we can use
24344                                                                          ; it for our new ship, so jump down to NW1
24345               
24346 AF88 B044  18        ab   rone,rx                    ; INX               ; Otherwise increment X to point to the next slot
24347               
24348 AF8A 0281  22        ci   rx,(NOSH)*256              ; CPX #NOSH         ; If we haven't reached the last slot yet, loop back up
     AF8C 0C00     
24349 AF8E 17F9  14        jnc  NWL1                       ; BCC NWL1          ; to NWL1 to check the next slot (note that this means
24350                                                                          ; only slots from 0 to #NOSH - 1 are populated by this
24351                                                                          ; routine, but there is one more slot reserved in FRIN,
24352                                                                          ; which is used to identify the end of the slot list
24353                                                                          ; when shuffling the slots down in the KILLSHP routine)
24354               
24355               NW3:
24356                      .clc                            ; CLC               ; Otherwise we don't have an empty slot, so we can't
     **** ****     > CLC
0001 AF90 0A13  18        sla  rzero,1
                   < elite.a99
24357 AF92 0460  28        b    @rts                       ; RTS               ; add a new ship, so clear the C flag to indicate that
     AF94 FF1C     
24358                                                                          ; we have not managed to create the new ship, and return
24359                                                                          ; from the subroutine
24360               
24361               NW1:
24362                                                                          ; If we get here, then we have found an empty slot at
24363                                                                          ; index X, so we can go ahead and create our new ship.
24364                                                                          ; We do that by creating a ship data block at INWK and,
24365                                                                          ; when we are done, copying the block from INWK into
24366                                                                          ; the K% workspace (specifically, to INF)
24367 AF96 0206  20        li   rtmp,GINF                  ; JSR GINF          ; Get the address of the data block for ship slot X
     AF98 AF0C     
24368 AF9A 06A0  32        bl   @jsr                       ;
     AF9C FF10     
24369                                                                          ; (which is in workspace K%) and store it in INF
24370               
24371 AF9E D020  30        movb @T,ra                      ; LDA T             ; If the type of ship that we want to create is
     AFA0 00D1     
24372 AFA2 115F  14        jlt  NW2                        ; BMI NW2           ; negative, then this indicates a planet or sun, so
24373                                                                          ; jump down to NW2, as the next section sets up a ship
24374                                                                          ; data block, which doesn't apply to planets and suns,
24375                                                                          ; as they don't have things like shields, missiles,
24376                                                                          ; vertices and edges
24377               
24378                                                                          ; This is a ship, so first we need to set up various
24379                                                                          ; pointers to the ship blueprint we will need. The
24380                                                                          ; blueprints for each ship type in Elite are stored
24381                                                                          ; in a table at location XX21, so refer to the comments
24382                                                                          ; on that variable for more details on the data we're
24383                                                                          ; about to access
24384               
24385                      .asla                           ; ASL A             ; Set Y = ship type * 2
     **** ****     > ASLA
0001 AFA4 0240  22        andi ra,>ff00
     AFA6 FF00     
0002 AFA8 0A10  18        sla  ra,1
                   < elite.a99
24386 AFAA D080  18        movb ra,ry                      ; TAY
24387               
24388 AFAC D022  34        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; The ship blueprints at XX21 start with a lookup
     AFAE E7E0     
24389 AFB0 D800  30        movb ra,@XX0                    ; STA XX0           ; table that points to the individual ship blueprints,
     AFB2 001E     
24390                                                                          ; so this fetches the low byte of this particular ship
24391                                                                          ; type's blueprint and stores it in XX0
24392               
24393 AFB4 D022  34        movb @XX21-1(ry),ra             ; LDA XX21-1,Y      ; Fetch the high byte of this particular ship type's
     AFB6 E7E1     
24394 AFB8 D800  30        movb ra,@XX0+1                  ; STA XX0+1         ; blueprint and store it in XX0+1, so XX0(1 0) now
     AFBA 001F     
24395                                                                          ; contains the address of this ship's blueprint
24396               
24397 AFBC 0282  22        ci   ry,(2*SST)*256             ; CPY #2*SST        ; If the ship type is a space station (SST), then jump
     AFBE 1000     
24398 AFC0 1336  14        jeq  NW6                        ; BEQ NW6           ; to NW6, skipping the heap space steps below, as the
24399                                                                          ; space station has its own line heap at LSO (which it
24400                                                                          ; shares with the sun)
24401               
24402                                                                          ; We now want to allocate space for a heap that we can
24403                                                                          ; use to store the lines we draw for our new ship (so it
24404                                                                          ; can easily be erased from the screen again). SLSP
24405                                                                          ; points to the start of the current heap space, and we
24406                                                                          ; can extend it downwards with the heap for our new ship
24407                                                                          ; (as the heap space always ends just before the WP
24408                                                                          ; workspace)
24409               
24410 AFC2 0202  20        li   ry,>05*256                 ; LDY #5            ; Fetch ship blueprint byte #5, which contains the
     AFC4 0500     
24411                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; maximum heap size required for plotting the new ship,
     **** ****     > LD_IND_Y_IDX
0001 AFC6 D820  50        movb @XX0,@rtmplb
     AFC8 001E     
     AFCA 2079     
0002 AFCC D1A0  30        movb @XX0+1,rtmp
     AFCE 001F     
0003 AFD0 A182  18        a    ry,rtmp
0004 AFD2 D016  26        movb *rtmp,RA
                   < elite.a99
24412 AFD4 D800  30        movb ra,@T1                     ; STA T1            ; and store it in T1
     AFD6 0006     
24413               
24414 AFD8 D020  30        movb @SLSP,ra                   ; LDA SLSP          ; Take the 16-bit address in SLSP and subtract T1,
     AFDA 0F1E     
24415                      .sec                            ; SEC               ; storing the 16-bit result in INWK(34 33), so this now
     **** ****     > SEC
0001 AFDC 0A15  18        sla  rmone,1
                   < elite.a99
24416                      .sbc @T1,ra                     ; SBC T1            ; points to the start of the line heap for our new ship
     **** ****     > SBC
0001 AFDE 1801  14        joc  !
0002 AFE0 7004  18        sb   rone,ra
0003               !:
0004 AFE2 7020  30        sb   @T1,ra
     AFE4 0006     
                   < elite.a99
24417 AFE6 D800  30        movb ra,@INWK+33                ; STA INWK+33
     AFE8 0074     
24418 AFEA D020  30        movb @SLSP+1,ra                 ; LDA SLSP+1
     AFEC 0F1F     
24419                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 AFEE 1801  14        joc  !
0002 AFF0 7004  18        sb   rone,ra
0003               !:
0004 AFF2 0220  22        ai   ra,-(>00*256)
     AFF4 0000     
                   < elite.a99
24420 AFF6 D800  30        movb ra,@INWK+34                ; STA INWK+34
     AFF8 0075     
24421               
24422                                                                          ; We now need to check that there is enough free space
24423                                                                          ; for both this new line heap and the new data block
24424                                                                          ; for our ship. In memory, this is the layout of the
24425                                                                          ; ship data blocks and ship line heaps:
24426                                                                          ;
24427                                                                          ; +-----------------------------------+   &0F34
24428                                                                          ; |                                   |
24429                                                                          ; | WP workspace                      |
24430                                                                          ; |                                   |
24431                                                                          ; +-----------------------------------+   &0D40 = WP
24432                                                                          ; |                                   |
24433                                                                          ; | Current ship line heap            |
24434                                                                          ; |                                   |
24435                                                                          ; +-----------------------------------+   SLSP
24436                                                                          ; |                                   |
24437                                                                          ; | Proposed heap for new ship        |
24438                                                                          ; |                                   |
24439                                                                          ; +-----------------------------------+   INWK(34 33)
24440                                                                          ; |                                   |
24441                                                                          ; .                                   .
24442                                                                          ; .                                   .
24443                                                                          ; .                                   .
24444                                                                          ; .                                   .
24445                                                                          ; .                                   .
24446                                                                          ; |                                   |
24447                                                                          ; +-----------------------------------+   INF + NI%
24448                                                                          ; |                                   |
24449                                                                          ; | Proposed data block for new ship  |
24450                                                                          ; |                                   |
24451                                                                          ; +-----------------------------------+   INF
24452                                                                          ; |                                   |
24453                                                                          ; | Existing ship data blocks         |
24454                                                                          ; |                                   |
24455                                                                          ; +-----------------------------------+   &0900 = K%
24456                                                                          ;
24457                                                                          ; So, to work out if we have enough space, we have to
24458                                                                          ; make sure there is room between the end of our new
24459                                                                          ; ship data block at INF + NI%, and the start of the
24460                                                                          ; proposed heap for our new ship at the address we
24461                                                                          ; stored in INWK(34 33). Or, to put it another way, we
24462                                                                          ; and to make sure that:
24463                                                                          ;
24464                                                                          ; INWK(34 33) > INF + NI%
24465                                                                          ;
24466                                                                          ; which is the same as saying:
24467                                                                          ;
24468                                                                          ; INWK+33 - INF > NI%
24469                                                                          ;
24470                                                                          ; because INWK is in zero page, so INWK+34 = 0
24471               
24472 AFFA D020  30        movb @INWK+33,ra                ; LDA INWK+33       ; Calculate INWK+33 - INF, again using 16-bit
     AFFC 0074     
24473               * SEC                    \ arithmetic, and put the result in (A Y), so the high
24474                      .sbc @INF,ra                    ; SBC INF           ; byte is in A and the low byte in Y. The SEC
     **** ****     > SBC
0001 AFFE 1801  14        joc  !
0002 B000 7004  18        sb   rone,ra
0003               !:
0004 B002 7020  30        sb   @INF,ra
     B004 0020     
                   < elite.a99
24475 B006 D080  18        movb ra,ry                      ; TAY               ; instruction is commented out in the original source;
24476 B008 D020  30        movb @INWK+34,ra                ; LDA INWK+34       ; as the previous subtraction will never underflow, it
     B00A 0075     
24477                      .sbc @INF+1,ra                  ; SBC INF+1         ; is superfluous
     **** ****     > SBC
0001 B00C 1801  14        joc  !
0002 B00E 7004  18        sb   rone,ra
0003               !:
0004 B010 7020  30        sb   @INF+1,ra
     B012 0021     
                   < elite.a99
24478               
24479 B014 17BD  14        jnc  NW3+1                      ; BCC NW3+1         ; If we have an underflow from the subtraction, then
24480                                                                          ; INF > INWK+33 and we definitely don't have enough
24481                                                                          ; room for this ship, so jump to NW3+1, which returns
24482                                                                          ; from the subroutine (with the C flag already cleared)
24483               
24484 B016 1603  14        jne  NW4                        ; BNE NW4           ; If the subtraction of the high bytes in A is not
24485                                                                          ; zero, and we don't have underflow, then we definitely
24486                                                                          ; have enough space, so jump to NW4 to continue setting
24487                                                                          ; up the new ship
24488               
24489 B018 0282  22        ci   ry,(NI.)*256               ; CPY #NI%          ; Otherwise the high bytes are the same in our
     B01A 2400     
24490 B01C 17B9  14        jnc  NW3+1                      ; BCC NW3+1         ; subtraction, so now we compare the low byte of the
24491                                                                          ; result (which is in Y) with NI%. This is the same as
24492                                                                          ; doing INWK+33 - INF > NI% (see above). If this isn't
24493                                                                          ; true, the C flag will be clear and we don't have
24494                                                                          ; enough space, so we jump to NW3+1, which returns
24495                                                                          ; from the subroutine (with the C flag already cleared)
24496               
24497               NW4:
24498 B01E D020  30        movb @INWK+33,ra                ; LDA INWK+33       ; If we get here then we do have enough space for our
     B020 0074     
24499 B022 D800  30        movb ra,@SLSP                   ; STA SLSP          ; new ship, so store the new bottom of the ship line
     B024 0F1E     
24500 B026 D020  30        movb @INWK+34,ra                ; LDA INWK+34       ; heap (i.e. INWK+33) in SLSP, doing both the high and
     B028 0075     
24501 B02A D800  30        movb ra,@SLSP+1                 ; STA SLSP+1        ; low bytes
     B02C 0F1F     
24502               
24503               NW6:
24504 B02E 0202  20        li   ry,>0e*256                 ; LDY #14           ; Fetch ship blueprint byte #14, which contains the
     B030 0E00     
24505                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; ship's energy, and store it in byte #35
     **** ****     > LD_IND_Y_IDX
0001 B032 D820  50        movb @XX0,@rtmplb
     B034 001E     
     B036 2079     
0002 B038 D1A0  30        movb @XX0+1,rtmp
     B03A 001F     
0003 B03C A182  18        a    ry,rtmp
0004 B03E D016  26        movb *rtmp,RA
                   < elite.a99
24506 B040 D800  30        movb ra,@INWK+35                ; STA INWK+35
     B042 0076     
24507               
24508 B044 0202  20        li   ry,>13*256                 ; LDY #19           ; Fetch ship blueprint byte #19, which contains the
     B046 1300     
24509                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of missiles and laser power, and AND with %111
     **** ****     > LD_IND_Y_IDX
0001 B048 D820  50        movb @XX0,@rtmplb
     B04A 001E     
     B04C 2079     
0002 B04E D1A0  30        movb @XX0+1,rtmp
     B050 001F     
0003 B052 A182  18        a    ry,rtmp
0004 B054 D016  26        movb *rtmp,RA
                   < elite.a99
24510 B056 0240  22        andi ra,>07*256                 ; AND #%00000111    ; to extract the number of missiles before storing in
     B058 0700     
24511 B05A D800  30        movb ra,@INWK+31                ; STA INWK+31       ; byte #31
     B05C 0072     
24512               
24513 B05E D020  30        movb @T,ra                      ; LDA T             ; Restore the ship type we stored above
     B060 00D1     
24514               
24515               NW2:
24516 B062 D840  38        movb ra,@FRIN(rx)               ; STA FRIN,X        ; Store the ship type in the X-th byte of FRIN, so the
     B064 0D40     
24517                                                                          ; this slot is now shown as occupied in the index table
24518               
24519 B066 D040  18        movb ra,rx                      ; TAX               ; Copy the ship type into X
24520               
24521 B068 1101  14        jlt  B74                        ; BMI B74           ; If the ship type is negative (planet or sun), then
24522                                                                          ; skip the following instruction
24523               
24524 B06A B004  18        ab   rone,ra                    ; INC MANY,X        ; Increment the total number of ships of type X
24525               
24526               B74:
24527 B06C 0202  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; The final step is to copy the new ship's data block
     B06E 2300     
24528                                                                          ; from INWK to INF, so set up a counter for NI% bytes
24529                                                                          ; in Y
24530               
24531               NWL3:
24532 B070 D022  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Load the Y-th byte of INWK and store in the Y-th byte
     B072 0053     
24533                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; of the workspace pointed to by INF
     **** ****     > ST_IND_Y_IDX
0001 B074 D820  50        movb @INF,@rtmplb
     B076 0020     
     B078 2079     
0002 B07A D1A0  30        movb @INF+1,rtmp
     B07C 0021     
0003 B07E A182  18        a    ry,rtmp
0004 B080 D580  30        movb RA,*rtmp
                   < elite.a99
24534               
24535 B082 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
24536               
24537 B084 15F5  14        jgt  NWL3                       ; BPL NWL3          ; Loop back for the next byte until we have copied them
24538                                                                          ; all over
24539               
24540                      .sec                            ; SEC               ; We have successfully created our new ship, so set the
     **** ****     > SEC
0001 B086 0A15  18        sla  rmone,1
                   < elite.a99
24541                                                                          ; C flag to indicate success
24542               
24543 B088 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B08A FF1C     
24544               
24545               * ******************************************************************************
24546               *
24547               * Name: NwS1
24548               * Type: Subroutine
24549               * Category: Universe
24550               * Summary: Flip the sign and double an INWK byte
24551               *
24552               * ------------------------------------------------------------------------------
24553               *
24554               * Flip the sign of the INWK byte at offset X, and increment X by 2. This is
24555               * used by the space station creation routine at NWSPS.
24556               *
24557               * ------------------------------------------------------------------------------
24558               *
24559               * Arguments:
24560               *
24561               * X                   The offset of the INWK byte to be flipped
24562               *
24563               * ------------------------------------------------------------------------------
24564               *
24565               * Returns:
24566               *
24567               * X                   X is incremented by 2
24568               *
24569               * ******************************************************************************
24570               
24571               NwS1:
24572 B08C D021  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Load the X-th byte of INWK into A and flip bit 7,
     B08E 0053     
24573                      .eoi (>80*256)                  ; EOR #%10000000    ; storing the result back in the X-th byte of INWK
     **** ****     > EOI
0001 B090 0206  20        li   rtmp,(>80*256)
     B092 8000     
0002 B094 2806  18        xor  rtmp,ra
                   < elite.a99
24574 B096 D840  38        movb ra,@INWK(rx)               ; STA INWK,X
     B098 0053     
24575               
24576 B09A B044  18        ab   rone,rx                    ; INX               ; Add 2 to X
24577 B09C B044  18        ab   rone,rx                    ; INX
24578               
24579 B09E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B0A0 FF1C     
24580               
24581               * ******************************************************************************
24582               *
24583               * Name: ABORT
24584               * Type: Subroutine
24585               * Category: Dashboard
24586               * Summary: Disarm missiles and update the dashboard indicators
24587               *
24588               * ------------------------------------------------------------------------------
24589               *
24590               * Arguments:
24591               *
24592               * Y                   The new status of the leftmost missile indicator
24593               *
24594               * ******************************************************************************
24595               
24596               ABORT:
24597 B0A2 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Set X to &FF, which is the value of MSTG when we have
     B0A4 FF00     
24598                                                                          ; no target lock for our missile
24599               
24600                                                                          ; Fall through into ABORT2 to set the missile lock to
24601                                                                          ; the value in X, which effectively disarms the missile
24602               
24603               * ******************************************************************************
24604               *
24605               * Name: ABORT2
24606               * Type: Subroutine
24607               * Category: Dashboard
24608               * Summary: Set/unset the lock target for a missile and update the dashboard
24609               *
24610               * ------------------------------------------------------------------------------
24611               *
24612               * Set the lock target for the leftmost missile and update the dashboard.
24613               *
24614               * ------------------------------------------------------------------------------
24615               *
24616               * Arguments:
24617               *
24618               * X                   The slot number of the ship to lock our missile onto, or
24619               * &FF to remove missile lock
24620               *
24621               * Y                   The new colour of the missile indicator:
24622               *
24623               * * &00 = black (no missile)
24624               *
24625               * * &0E = red (armed and locked)
24626               *
24627               * * &E0 = yellow/white (armed)
24628               *
24629               * * &EE = green/cyan (disarmed)
24630               *
24631               * ******************************************************************************
24632               
24633               ABORT2:
24634 B0A6 D801  30        movb rx,@MSTG                   ; STX MSTG          ; Store the target of our missile lock in MSTG
     B0A8 0052     
24635               
24636 B0AA D060  30        movb @NOMSL,rx                  ; LDX NOMSL         ; Call MSBAR to update the leftmost indicator in the
     B0AC 0333     
24637 B0AE 0206  20        li   rtmp,MSBAR                 ; JSR MSBAR         ; dashboard's missile bar, which returns with Y = 0
     B0B0 B10E     
24638 B0B2 06A0  32        bl   @jsr                       ;
     B0B4 FF10     
24639               
24640 B0B6 D802  30        movb ry,@MSAR                   ; STY MSAR          ; Set MSAR = 0 to indicate that the leftmost missile
     B0B8 0D5E     
24641                                                                          ; is no longer seeking a target lock
24642               
24643 B0BA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B0BC FF1C     
24644               
24645               * ******************************************************************************
24646               *
24647               * Name: ECBLB2
24648               * Type: Subroutine
24649               * Category: Dashboard
24650               * Summary: Start up the E.C.M. (light up the indicator, start the countdown
24651               * and make the E.C.M. sound)
24652               *
24653               * ******************************************************************************
24654               
24655               ECBLB2:
24656 B0BE 0200  20        li   ra,>20*256                 ; LDA #32           ; Set the E.C.M. countdown timer in ECMA to 32
     B0C0 2000     
24657 B0C2 D800  30        movb ra,@ECMA                   ; STA ECMA
     B0C4 0030     
24658               
24659                      .asla                           ; ASL A             ; Call the NOISE routine with A = 64 to make the sound
     **** ****     > ASLA
0001 B0C6 0240  22        andi ra,>ff00
     B0C8 FF00     
0002 B0CA 0A10  18        sla  ra,1
                   < elite.a99
24660 B0CC 0206  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the E.C.M. being switched on
     B0CE CBB0     
24661 B0D0 06A0  32        bl   @jsr                       ;
     B0D2 FF10     
24662               
24663                                                                          ; Fall through into ECBLB to light up the E.C.M. bulb
24664               
24665               * ******************************************************************************
24666               *
24667               * Name: ECBLB
24668               * Type: Subroutine
24669               * Category: Dashboard
24670               * Summary: Light up the E.C.M. indicator bulb ("E") on the dashboard
24671               *
24672               * ******************************************************************************
24673               
24674               ECBLB:
24675 B0D4 0200  20        li   ra,(7*8)*256               ; LDA #7*8          ; The E.C.M. bulb is in character block number 7
     B0D6 3800     
24676                                                                          ; with each character taking 8 bytes, so this sets the
24677                                                                          ; low byte of the screen address of the character block
24678                                                                          ; we want to draw to
24679               
24680 B0D8 0201  20        li   rx,((ECBT)%256)*256        ; LDX #LO(ECBT)     ; Set (Y X) to point to the character definition in
     B0DA FE00     
24681 B0DC 0202  20        li   ry,((ECBT)/256)*256        ; LDY #HI(ECBT)     ; ECBT. The LDY has no effect, as we overwrite Y with
     B0DE B200     
24682                                                                          ; the jump to BULB-2, which writes the high byte of SPBT
24683                                                                          ; into Y. This works as long as ECBT and SPBT are in
24684                                                                          ; the same page of memory, so perhaps the BNE below got
24685                                                                          ; changed from BULB to BULB-2 so they could remove the
24686                                                                          ; LDY, but for some reason it didn't get culled? Who
24687                                                                          ; knows...
24688               
24689 B0E0 1605  14        jne  BULB-2                     ; BNE BULB-2        ; Jump down to BULB-2 (this BNE is effectively a JMP as
24690                                                                          ; A will never be zero)
24691               
24692               * ******************************************************************************
24693               *
24694               * Name: SPBLB
24695               * Type: Subroutine
24696               * Category: Dashboard
24697               * Summary: Light up the space station indicator ("S") on the dashboard
24698               *
24699               * ******************************************************************************
24700               
24701               SPBLB:
24702 B0E2 0200  20        li   ra,(24*8)*256              ; LDA #24*8         ; The space station bulb is in character block number 24
     B0E4 C000     
24703                                                                          ; with each character taking 8 bytes, so this sets the
24704                                                                          ; low byte of the screen address of the character block
24705                                                                          ; we want to draw to
24706               
24707 B0E6 0201  20        li   rx,((SPBT)%256)*256        ; LDX #LO(SPBT)     ; Set (Y X) to point to the character definition in SPBT
     B0E8 FB00     
24708 B0EA 0202  20        li   ry,((SPBT)/256)*256        ; LDY #HI(SPBT)
     B0EC B200     
24709               
24710                                                                          ; Fall through into BULB to draw the space station bulb
24711               
24712               * ******************************************************************************
24713               *
24714               * Name: BULB
24715               * Type: Subroutine
24716               * Category: Dashboard
24717               * Summary: Draw an indicator bulb on the dashboard
24718               *
24719               * ------------------------------------------------------------------------------
24720               *
24721               * Arguments:
24722               *
24723               * A                   The y-coordinate of the bulb as a low-byte screen
24724               * address offset within screen page &7D (as both bulbs
24725               * are on this character row in the dashboard)
24726               *
24727               * (Y X)               The address of the character definition of the bulb to
24728               * be drawn (i.e. ECBT for the E.C.M. bulb, or SPBT for the
24729               * space station bulb)
24730               *
24731               * ------------------------------------------------------------------------------
24732               *
24733               * Other entry points:
24734               *
24735               * BULB-2              Set the Y screen address
24736               *
24737               * ******************************************************************************
24738               
24739               BULB:
24740 B0EE D800  30        movb ra,@SC                     ; STA SC            ; Store the low byte of the screen address in SC
     B0F0 0007     
24741               
24742 B0F2 D801  30        movb rx,@P+1                    ; STX P+1           ; Set P(2 1) = (Y X)
     B0F4 001C     
24743 B0F6 D802  30        movb ry,@P+2                    ; STY P+2
     B0F8 001D     
24744               
24745 B0FA 0200  20        li   ra,>7d*256                 ; LDA #&7D          ; Set A to the high byte of the screen address, which is
     B0FC 7D00     
24746                                                                          ; &7D as the bulbs are both in the character row from
24747                                                                          ; &7D00 to &7DFF
24748               
24749 B0FE 0460  28        b    @RREN                      ; JMP RREN          ; Call RREN to print the character definition pointed to
     B100 3226     
24750                                                                          ; by P(2 1) at the screen address pointed to by (A SC),
24751                                                                          ; returning from the subroutine using a tail call
24752               
24753               * ******************************************************************************
24754               *
24755               * Name: ECBT
24756               * Type: Variable
24757               * Category: Dashboard
24758               * Summary: The character bitmap for the E.C.M. indicator bulb
24759               *
24760               * ------------------------------------------------------------------------------
24761               *
24762               * The character bitmap for the E.C.M. indicator's "E" bulb that gets displayed
24763               * on the dashboard.
24764               *
24765               * The E.C.M. indicator uses the first 5 rows of the space station's "S" bulb
24766               * below, as the bottom 5 rows of the "E" match the top 5 rows of the "S".
24767               *
24768               * Each pixel is in mode 5 colour 2 (%10), which is yellow/white.
24769               *
24770               * ******************************************************************************
24771               
24772               ECBT:
24773 B102 E0              byte >e0                                            ; x x x .
24774 B103   E0            byte >e0                                            ; x x x .
24775 B104 80              byte >80                                            ; x . . .
24776                                                                          ; x x x .
24777                                                                          ; x x x .
24778                                                                          ; x . . .
24779                                                                          ; x x x .
24780                                                                          ; x x x .
24781               
24782               * ******************************************************************************
24783               *
24784               * Name: SPBT
24785               * Type: Variable
24786               * Category: Dashboard
24787               * Summary: The bitmap definition for the space station indicator bulb
24788               *
24789               * ------------------------------------------------------------------------------
24790               *
24791               * The bitmap definition for the space station indicator's "S" bulb that gets
24792               * displayed on the dashboard.
24793               *
24794               * Each pixel is in mode 5 colour 2 (%10), which is yellow/white.
24795               *
24796               * ******************************************************************************
24797               
24798               SPBT:
24799 B105   E0            byte >e0                                            ; x x x .
24800 B106 E0              byte >e0                                            ; x x x .
24801 B107   80            byte >80                                            ; x . . .
24802 B108 E0              byte >e0                                            ; x x x .
24803 B109   E0            byte >e0                                            ; x x x .
24804 B10A 20              byte >20                                            ; . . x .
24805 B10B   E0            byte >e0                                            ; x x x .
24806 B10C E0              byte >e0                                            ; x x x .
24807               
24808               * ******************************************************************************
24809               *
24810               * Name: MSBAR
24811               * Type: Subroutine
24812               * Category: Dashboard
24813               * Summary: Draw a specific indicator in the dashboard's missile bar
24814               *
24815               * ------------------------------------------------------------------------------
24816               *
24817               * Each indicator is a rectangle that's 3 pixels wide and 5 pixels high. If the
24818               * indicator is set to black, this effectively removes a missile.
24819               *
24820               * ------------------------------------------------------------------------------
24821               *
24822               * Arguments:
24823               *
24824               * X                   The number of the missile indicator to update (counting
24825               * from right to left, so indicator NOMSL is the leftmost
24826               * indicator)
24827               *
24828               * Y                   The colour of the missile indicator:
24829               *
24830               * * &00 = black (no missile)
24831               *
24832               * * &0E = red (armed and locked)
24833               *
24834               * * &E0 = yellow/white (armed)
24835               *
24836               * * &EE = green/cyan (disarmed)
24837               *
24838               * ------------------------------------------------------------------------------
24839               *
24840               * Returns:
24841               *
24842               * X                   X is preserved
24843               *
24844               * Y                   Y is set to 0
24845               *
24846               * ******************************************************************************
24847               
24848               MSBAR:
24849 B10E D001  18        movb rx,ra                      ; TXA               ; Set T = X * 8
24850                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B110 0240  22        andi ra,>ff00
     B112 FF00     
0002 B114 0A10  18        sla  ra,1
                   < elite.a99
24851                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B116 0240  22        andi ra,>ff00
     B118 FF00     
0002 B11A 0A10  18        sla  ra,1
                   < elite.a99
24852                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B11C 0240  22        andi ra,>ff00
     B11E FF00     
0002 B120 0A10  18        sla  ra,1
                   < elite.a99
24853 B122 D800  30        movb ra,@T                      ; STA T
     B124 00D1     
24854               
24855 B126 0200  20        li   ra,>31*256                 ; LDA #49           ; Set SC = 49 - T
     B128 3100     
24856                      .sbc @T,ra                      ; SBC T             ; = 48 + 1 - (X * 8)
     **** ****     > SBC
0001 B12A 1801  14        joc  !
0002 B12C 7004  18        sb   rone,ra
0003               !:
0004 B12E 7020  30        sb   @T,ra
     B130 00D1     
                   < elite.a99
24857 B132 D800  30        movb ra,@SC                     ; STA SC
     B134 0007     
24858               
24859                                                                          ; So the low byte of SC(1 0) contains the row address
24860                                                                          ; for the rightmost missile indicator, made up as
24861                                                                          ; follows:
24862                                                                          ;
24863                                                                          ; * 48 (character block 7, as byte #7 * 8 = 48), the
24864                                                                          ; character block of the rightmost missile
24865                                                                          ;
24866                                                                          ; * 1 (so we start drawing on the second row of the
24867                                                                          ; character block)
24868                                                                          ;
24869                                                                          ; * Move left one character (8 bytes) for each count
24870                                                                          ; of X, so when X = 0 we are drawing the rightmost
24871                                                                          ; missile, for X = 1 we hop to the left by one
24872                                                                          ; character, and so on
24873               
24874 B136 0200  20        li   ra,>7e*256                 ; LDA #&7E          ; Set the high byte of SC(1 0) to &7E, the character row
     B138 7E00     
24875 B13A D800  30        movb ra,@SCH                    ; STA SCH           ; that contains the missile indicators (i.e. the bottom
     B13C 0008     
24876                                                                          ; row of the screen)
24877               
24878 B13E D002  18        movb ry,ra                      ; TYA               ; Set A to the correct colour, which is a 3-pixel wide
24879                                                                          ; mode 5 character row in the correct colour (for
24880                                                                          ; example, a green block has Y = &EE, or %11101110, so
24881                                                                          ; the missile blocks are 3 pixels wide, with the
24882                                                                          ; fourth pixel on the character row being empty)
24883               
24884 B140 0202  20        li   ry,>05*256                 ; LDY #5            ; We now want to draw this line five times, so set a
     B142 0500     
24885                                                                          ; counter in Y
24886               
24887               MBL1:
24888                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the 3-pixel row, and as we do not use EOR logic,
     **** ****     > ST_IND_Y_IDX
0001 B144 D820  50        movb @SC,@rtmplb
     B146 0007     
     B148 2079     
0002 B14A D1A0  30        movb @SC+1,rtmp
     B14C 0008     
0003 B14E A182  18        a    ry,rtmp
0004 B150 D580  30        movb RA,*rtmp
                   < elite.a99
24889                                                                          ; this will overwrite anything that is already there
24890                                                                          ; (so drawing a black missile will delete what's there)
24891               
24892 B152 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter for the next row
24893               
24894 B154 16F7  14        jne  MBL1                       ; BNE MBL1          ; Loop back to MBL1 if have more rows to draw
24895               
24896 B156 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B158 FF1C     
24897               
24898               * ******************************************************************************
24899               *
24900               * Name: PROJ
24901               * Type: Subroutine
24902               * Category: Maths (Geometry)
24903               * Summary: Project the current ship or planet onto the screen
24904               * Deep dive: Extended screen coordinates
24905               *
24906               * ------------------------------------------------------------------------------
24907               *
24908               * Project the current ship's location or the planet onto the screen, either
24909               * returning the screen coordinates of the projection (if it's on-screen), or
24910               * returning an error via the C flag.
24911               *
24912               * In this context, "on-screen" means that the point is projected into the
24913               * following range:
24914               *
24915               * centre of screen - 1024 < x < centre of screen + 1024
24916               * centre of screen - 1024 < y < centre of screen + 1024
24917               *
24918               * This is to cater for ships (and, more likely, planets and suns) whose centres
24919               * are off-screen but whose edges may still be visible.
24920               *
24921               * The projection calculation is:
24922               *
24923               * K3(1 0) = #X + x / z
24924               * K4(1 0) = #Y + y / z
24925               *
24926               * where #X and #Y are the pixel x-coordinate and y-coordinate of the centre of
24927               * the screen.
24928               *
24929               * ------------------------------------------------------------------------------
24930               *
24931               * Arguments:
24932               *
24933               * INWK                The ship data block for the ship to project on-screen
24934               *
24935               * ------------------------------------------------------------------------------
24936               *
24937               * Returns:
24938               *
24939               * K3(1 0)             The x-coordinate of the ship's projection on-screen
24940               *
24941               * K4(1 0)             The y-coordinate of the ship's projection on-screen
24942               *
24943               * C flag              Set if the ship's projection doesn't fit on the screen,
24944               * clear if it does project onto the screen
24945               *
24946               * A                   Contains K4+1, the high byte of the y-coordinate
24947               *
24948               * ******************************************************************************
24949               
24950               PROJ:
24951 B15A D020  30        movb @INWK,ra                   ; LDA INWK          ; Set P(1 0) = (x_hi x_lo)
     B15C 0053     
24952 B15E D800  30        movb ra,@P                      ; STA P             ; = x
     B160 001B     
24953 B162 D020  30        movb @INWK+1,ra                 ; LDA INWK+1
     B164 0054     
24954 B166 D800  30        movb ra,@P+1                    ; STA P+1
     B168 001C     
24955               
24956 B16A D020  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Set A = x_sign
     B16C 0055     
24957               
24958 B16E 0206  20        li   rtmp,PLS6                  ; JSR PLS6          ; Call PLS6 to calculate:
     B170 BB40     
24959 B172 06A0  32        bl   @jsr                       ;
     B174 FF10     
24960                                                                          ;
24961                                                                          ; (X K) = (A P+1 P) / (z_sign z_hi z_lo)
24962                                                                          ; = (x_sign x_hi x_lo) / (z_sign z_hi z_lo)
24963                                                                          ; = x / z
24964               
24965 B176 1832  14        joc  PL2-1                      ; BCS PL2-1         ; If the C flag is set then the result overflowed and
24966                                                                          ; the coordinate doesn't fit on the screen, so return
24967                                                                          ; from the subroutine with the C flag set (as PL2-1
24968                                                                          ; contains an RTS)
24969               
24970 B178 D020  30        movb @K,ra                      ; LDA K             ; Set K3(1 0) = (X K) + #X
     B17A 003D     
24971                      .adi ((X)*256)                  ; ADC #X            ; = #X + x / z
     **** ****     > ADI
0001 B17C 1701  14        jnc  !
0002 B17E B004  18        ab   rone,ra
0003               !:
0004 B180 0220  22        ai   ra,((X)*256)
     B182 8000     
                   < elite.a99
24972 B184 D800  30        movb ra,@K3                     ; STA K3            ;
     B186 00D2     
24973                                                                          ; first doing the low bytes
24974               
24975 B188 D001  18        movb rx,ra                      ; TXA               ; And then the high bytes. #X is the x-coordinate of
24976                      .adi (>00*256)                  ; ADC #0            ; the centre of the space view, so this converts the
     **** ****     > ADI
0001 B18A 1701  14        jnc  !
0002 B18C B004  18        ab   rone,ra
0003               !:
0004 B18E 0220  22        ai   ra,(>00*256)
     B190 0000     
                   < elite.a99
24977 B192 D800  30        movb ra,@K3+1                   ; STA K3+1          ; space x-coordinate into a screen x-coordinate
     B194 00D3     
24978               
24979 B196 D020  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P(1 0) = (y_hi y_lo)
     B198 0056     
24980 B19A D800  30        movb ra,@P                      ; STA P
     B19C 001B     
24981 B19E D020  30        movb @INWK+4,ra                 ; LDA INWK+4
     B1A0 0057     
24982 B1A2 D800  30        movb ra,@P+1                    ; STA P+1
     B1A4 001C     
24983               
24984 B1A6 D020  30        movb @INWK+5,ra                 ; LDA INWK+5        ; Set A = -y_sign
     B1A8 0058     
24985                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 B1AA 0206  20        li   rtmp,(>80*256)
     B1AC 8000     
0002 B1AE 2806  18        xor  rtmp,ra
                   < elite.a99
24986               
24987 B1B0 0206  20        li   rtmp,PLS6                  ; JSR PLS6          ; Call PLS6 to calculate:
     B1B2 BB40     
24988 B1B4 06A0  32        bl   @jsr                       ;
     B1B6 FF10     
24989                                                                          ;
24990                                                                          ; (X K) = (A P+1 P) / (z_sign z_hi z_lo)
24991                                                                          ; = -(y_sign y_hi y_lo) / (z_sign z_hi z_lo)
24992                                                                          ; = -y / z
24993               
24994 B1B8 1811  14        joc  PL2-1                      ; BCS PL2-1         ; If the C flag is set then the result overflowed and
24995                                                                          ; the coordinate doesn't fit on the screen, so return
24996                                                                          ; from the subroutine with the C flag set (as PL2-1
24997                                                                          ; contains an RTS)
24998               
24999 B1BA D020  30        movb @K,ra                      ; LDA K             ; Set K4(1 0) = (X K) + #Y
     B1BC 003D     
25000                      .adi ((Y)*256)                  ; ADC #Y            ; = #Y - y / z
     **** ****     > ADI
0001 B1BE 1701  14        jnc  !
0002 B1C0 B004  18        ab   rone,ra
0003               !:
0004 B1C2 0220  22        ai   ra,((Y)*256)
     B1C4 6000     
                   < elite.a99
25001 B1C6 D800  30        movb ra,@K4                     ; STA K4            ;
     B1C8 00E0     
25002                                                                          ; first doing the low bytes
25003               
25004 B1CA D001  18        movb rx,ra                      ; TXA               ; And then the high bytes. #Y is the y-coordinate of
25005                      .adi (>00*256)                  ; ADC #0            ; the centre of the space view, so this converts the
     **** ****     > ADI
0001 B1CC 1701  14        jnc  !
0002 B1CE B004  18        ab   rone,ra
0003               !:
0004 B1D0 0220  22        ai   ra,(>00*256)
     B1D2 0000     
                   < elite.a99
25006 B1D4 D800  30        movb ra,@K4+1                   ; STA K4+1          ; space x-coordinate into a screen y-coordinate
     B1D6 00E1     
25007               
25008                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 B1D8 0A13  18        sla  rzero,1
                   < elite.a99
25009               
25010 B1DA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B1DC FF1C     
25011               
25012               * ******************************************************************************
25013               *
25014               * Name: PL2
25015               * Type: Subroutine
25016               * Category: Drawing planets
25017               * Summary: Remove the planet or sun from the screen
25018               *
25019               * ------------------------------------------------------------------------------
25020               *
25021               * Other entry points:
25022               *
25023               * PL2-1               Contains an RTS
25024               *
25025               * ******************************************************************************
25026               
25027               PL2:
25028 B1DE D020  30        movb @TYPE,ra                   ; LDA TYPE          ; Shift bit 0 of the planet/sun's type into the C flag
     B1E0 009B     
25029 B1E2 0910  18        srl  ra,1                       ; LSR A
25030               
25031 B1E4 1802  14        joc  B75                        ; BCS B75           ; If the planet/sun's type has bit 0 clear, then it's
25032                                                                          ; either 128 or 130, which is a planet; meanwhile, the
25033                                                                          ; sun has type 129, which has bit 0 set. So if this is
25034                                                                          ; the sun, skip the following instruction
25035               
25036 B1E6 0460  28        b    @WPLS2                     ; JMP WPLS2         ; This is the planet, so jump to WPLS2 to remove it from
     B1E8 B90A     
25037                                                                          ; screen, returning from the subroutine using a tail
25038                                                                          ; call
25039               
25040               B75:
25041 B1EA 0460  28        b    @WPLS                      ; JMP WPLS          ; This is the sun, so jump to WPLS to remove it from
     B1EC B97C     
25042                                                                          ; screen, returning from the subroutine using a tail
25043                                                                          ; call
25044               
25045               * ******************************************************************************
25046               *
25047               * Name: PLANET
25048               * Type: Subroutine
25049               * Category: Drawing planets
25050               * Summary: Draw the planet or sun
25051               *
25052               * ------------------------------------------------------------------------------
25053               *
25054               * Arguments:
25055               *
25056               * INWK                The planet or sun's ship data block
25057               *
25058               * ******************************************************************************
25059               
25060               PLANET:
25061 B1EE D020  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set A = z_sign (the highest byte in the planet/sun's
     B1F0 005B     
25062                                                                          ; coordinates)
25063               
25064 B1F2 11F5  14        jlt  PL2                        ; BMI PL2           ; If A is negative then the planet/sun is behind us, so
25065                                                                          ; jump to PL2 to remove it from the screen, returning
25066                                                                          ; from the subroutine using a tail call
25067               
25068 B1F4 0280  22        ci   ra,>30*256                 ; CMP #48           ; If A >= 48 then the planet/sun is too far away to be
     B1F6 3000     
25069 B1F8 18F2  14        joc  PL2                        ; BCS PL2           ; seen, so jump to PL2 to remove it from the screen,
25070                                                                          ; returning from the subroutine using a tail call
25071               
25072 B1FA F020  30        socb @INWK+7,ra                 ; ORA INWK+7        ; Set A to 0 if both z_sign and z_hi are 0
     B1FC 005A     
25073               
25074 B1FE 13EF  14        jeq  PL2                        ; BEQ PL2           ; If both z_sign and z_hi are 0, then the planet/sun is
25075                                                                          ; too close to be shown, so jump to PL2 to remove it
25076                                                                          ; from the screen, returning from the subroutine using a
25077                                                                          ; tail call
25078               
25079 B200 0206  20        li   rtmp,PROJ                  ; JSR PROJ          ; Project the planet/sun onto the screen, returning the
     B202 B15A     
25080 B204 06A0  32        bl   @jsr                       ;
     B206 FF10     
25081                                                                          ; centre's coordinates in K3(1 0) and K4(1 0)
25082               
25083 B208 18EA  14        joc  PL2                        ; BCS PL2           ; If the C flag is set by PROJ then the planet/sun is
25084                                                                          ; not visible on-screen, so jump to PL2 to remove it
25085                                                                          ; from the screen, returning from the subroutine using
25086                                                                          ; a tail call
25087               
25088 B20A 0200  20        li   ra,>60*256                 ; LDA #96           ; Set (A P+1 P) = (0 96 0) = 24576
     B20C 6000     
25089 B20E D800  30        movb ra,@P+1                    ; STA P+1           ;
     B210 001C     
25090 B212 0200  20        li   ra,>00*256                 ; LDA #0            ; This represents the planet/sun's radius at a distance
     B214 0000     
25091 B216 D800  30        movb ra,@P                      ; STA P             ; of z = 1
     B218 001B     
25092               
25093 B21A 0206  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     B21C 45E8     
25094 B21E 06A0  32        bl   @jsr                       ;
     B220 FF10     
25095                                                                          ;
25096                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
25097                                                                          ; = (0 96 0) / z
25098                                                                          ; = 24576 / z
25099                                                                          ;
25100                                                                          ; so K now contains the planet/sun's radius, reduced by
25101                                                                          ; the actual distance to the planet/sun. We know that
25102                                                                          ; K+3 and K+2 will be 0, as the number we are dividing,
25103                                                                          ; (0 96 0), fits into the two bottom bytes, so the
25104                                                                          ; result is actually in K(1 0)
25105               
25106 B222 D020  30        movb @K+1,ra                    ; LDA K+1           ; If the high byte of the reduced radius is zero, jump
     B224 003E     
25107 B226 1304  14        jeq  PL82                       ; BEQ PL82          ; to PL82, as K contains the radius on its own
25108               
25109 B228 0200  20        li   ra,>f8*256                 ; LDA #248          ; Otherwise set K = 248, to round up the radius in
     B22A F800     
25110 B22C D800  30        movb ra,@K                      ; STA K             ; K(1 0) to the nearest integer (if we consider the low
     B22E 003D     
25111                                                                          ; byte to be the fractional part)
25112               
25113               PL82:
25114 B230 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; If the planet/sun's type has bit 0 clear, then it's
     B232 009B     
25115 B234 0910  18        srl  ra,1                       ; LSR A             ; either 128 or 130, which is a planet (the sun has type
25116 B236 1702  14        jnc  PL9                        ; BCC PL9           ; 129, which has bit 0 set). So jump to PL9 to draw the
25117                                                                          ; planet with radius K, returning from the subroutine
25118                                                                          ; using a tail call
25119               
25120 B238 0460  28        b    @SUN                       ; JMP SUN           ; Otherwise jump to SUN to draw the sun with radius K,
     B23A B5C4     
25121                                                                          ; returning from the subroutine using a tail call
25122               
25123               * ******************************************************************************
25124               *
25125               * Name: PL9 (Part 1 of 3)
25126               * Type: Subroutine
25127               * Category: Drawing planets
25128               * Summary: Draw the planet, with either an equator and meridian, or a crater
25129               *
25130               * ------------------------------------------------------------------------------
25131               *
25132               * Draw the planet with radius K at pixel coordinate (K3, K4), and with either an
25133               * equator and meridian, or a crater.
25134               *
25135               * ------------------------------------------------------------------------------
25136               *
25137               * Arguments:
25138               *
25139               * K(1 0)              The planet's radius
25140               *
25141               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25142               *
25143               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25144               *
25145               * INWK                The planet's ship data block
25146               *
25147               * ******************************************************************************
25148               
25149               PL9:
25150 B23C 0206  20        li   rtmp,WPLS2                 ; JSR WPLS2         ; Call WPLS2 to remove the planet from the screen
     B23E B90A     
25151 B240 06A0  32        bl   @jsr                       ;
     B242 FF10     
25152               
25153 B244 0206  20        li   rtmp,CIRCLE                ; JSR CIRCLE        ; Call CIRCLE to draw the planet's new circle
     B246 B7FE     
25154 B248 06A0  32        bl   @jsr                       ;
     B24A FF10     
25155               
25156 B24C 1803  14        joc  PL20                       ; BCS PL20          ; If the call to CIRCLE returned with the C flag set,
25157                                                                          ; then the circle does not fit on-screen, so jump to
25158                                                                          ; PL20 to return from the subroutine
25159               
25160 B24E D020  30        movb @K+1,ra                    ; LDA K+1           ; If K+1 is zero, jump to PL25 as K(1 0) < 256, so the
     B250 003E     
25161 B252 1302  14        jeq  PL25                       ; BEQ PL25          ; planet fits on the screen and we can draw meridians or
25162                                                                          ; craters
25163               
25164               PL20:
25165 B254 0460  28        b    @rts                       ; RTS               ; The planet doesn't fit on-screen, so return from the
     B256 FF1C     
25166                                                                          ; subroutine
25167               
25168               PL25:
25169 B258 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; If the planet type is 128 then it has an equator and
     B25A 009B     
25170 B25C 0280  22        ci   ra,>80*256                 ; CMP #128          ; a meridian, so this jumps to PL26 if this is not a
     B25E 8000     
25171 B260 1643  14        jne  PL26                       ; BNE PL26          ; planet with an equator - in other words, if it is a
25172                                                                          ; planet with a crater
25173               
25174                                                                          ; Otherwise this is a planet with an equator and
25175                                                                          ; meridian, so fall through into the following to draw
25176                                                                          ; them
25177               
25178               * ******************************************************************************
25179               *
25180               * Name: PL9 (Part 2 of 3)
25181               * Type: Subroutine
25182               * Category: Drawing planets
25183               * Summary: Draw the planet's equator and meridian
25184               * Deep dive: Drawing meridians and equators
25185               *
25186               * ------------------------------------------------------------------------------
25187               *
25188               * Draw the planet's equator and meridian.
25189               *
25190               * ------------------------------------------------------------------------------
25191               *
25192               * Arguments:
25193               *
25194               * K(1 0)              The planet's radius
25195               *
25196               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25197               *
25198               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25199               *
25200               * INWK                The planet's ship data block
25201               *
25202               * ******************************************************************************
25203               
25204 B262 D020  30        movb @K,ra                      ; LDA K             ; If the planet's radius is less than 6, the planet is
     B264 003D     
25205 B266 0280  22        ci   ra,>06*256                 ; CMP #6            ; too small to show a meridian, so jump to PL20 to
     B268 0600     
25206 B26A 17F4  14        jnc  PL20                       ; BCC PL20          ; return from the subroutine
25207               
25208 B26C D020  30        movb @INWK+14,ra                ; LDA INWK+14       ; Set P = -nosev_z_hi
     B26E 0061     
25209                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 B270 0206  20        li   rtmp,(>80*256)
     B272 8000     
0002 B274 2806  18        xor  rtmp,ra
                   < elite.a99
25210 B276 D800  30        movb ra,@P                      ; STA P
     B278 001B     
25211               
25212 B27A D020  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z_hi
     B27C 0067     
25213               
25214 B27E 0206  20        li   rtmp,PLS4                  ; JSR PLS4          ; Call PLS4 to calculate the following:
     B280 BAF8     
25215 B282 06A0  32        bl   @jsr                       ;
     B284 FF10     
25216                                                                          ;
25217                                                                          ; CNT2 = arctan(P / A) / 4
25218                                                                          ; = arctan(-nosev_z_hi / roofv_z_hi) / 4
25219                                                                          ;
25220                                                                          ; and do the following if nosev_z_hi >= 0:
25221                                                                          ;
25222                                                                          ; CNT2 = CNT2 + PI
25223               
25224 B286 0201  20        li   rx,>09*256                 ; LDX #9            ; Set X to 9 so the call to PLS1 divides nosev_x
     B288 0900     
25225               
25226 B28A 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B28C B3AC     
25227 B28E 06A0  32        bl   @jsr                       ;
     B290 FF10     
25228 B292 D800  30        movb ra,@K2                     ; STA K2            ;
     B294 00AC     
25229 B296 D802  30        movb ry,@XX16                   ; STY XX16          ; (XX16 K2) = nosev_x / z
     B298 0009     
25230                                                                          ;
25231                                                                          ; and increment X to point to nosev_y for the next call
25232               
25233 B29A 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B29C B3AC     
25234 B29E 06A0  32        bl   @jsr                       ;
     B2A0 FF10     
25235 B2A2 D800  30        movb ra,@K2+1                   ; STA K2+1          ;
     B2A4 00AD     
25236 B2A6 D802  30        movb ry,@XX16+1                 ; STY XX16+1        ; (XX16+1 K2+1) = nosev_y / z
     B2A8 000A     
25237               
25238 B2AA 0201  20        li   rx,>0f*256                 ; LDX #15           ; Set X to 15 so the call to PLS5 divides roofv_x
     B2AC 0F00     
25239               
25240 B2AE 0206  20        li   rtmp,PLS5                  ; JSR PLS5          ; Call PLS5 to calculate the following:
     B2B0 BB1C     
25241 B2B2 06A0  32        bl   @jsr                       ;
     B2B4 FF10     
25242                                                                          ;
25243                                                                          ; (XX16+2 K2+2) = roofv_x / z
25244                                                                          ;
25245                                                                          ; (XX16+3 K2+3) = roofv_y / z
25246               
25247 B2B6 0206  20        li   rtmp,PLS2                  ; JSR PLS2          ; Call PLS2 to draw the first meridian
     B2B8 B3EA     
25248 B2BA 06A0  32        bl   @jsr                       ;
     B2BC FF10     
25249               
25250 B2BE D020  30        movb @INWK+14,ra                ; LDA INWK+14       ; Set P = -nosev_z_hi
     B2C0 0061     
25251                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 B2C2 0206  20        li   rtmp,(>80*256)
     B2C4 8000     
0002 B2C6 2806  18        xor  rtmp,ra
                   < elite.a99
25252 B2C8 D800  30        movb ra,@P                      ; STA P
     B2CA 001B     
25253               
25254 B2CC D020  30        movb @INWK+26,ra                ; LDA INWK+26       ; Set A = sidev_z_hi, so the second meridian will be at
     B2CE 006D     
25255                                                                          ; 90 degrees to the first
25256               
25257 B2D0 0206  20        li   rtmp,PLS4                  ; JSR PLS4          ; Call PLS4 to calculate the following:
     B2D2 BAF8     
25258 B2D4 06A0  32        bl   @jsr                       ;
     B2D6 FF10     
25259                                                                          ;
25260                                                                          ; CNT2 = arctan(P / A) / 4
25261                                                                          ; = arctan(-nosev_z_hi / sidev_z_hi) / 4
25262                                                                          ;
25263                                                                          ; and do the following if nosev_z_hi >= 0:
25264                                                                          ;
25265                                                                          ; CNT2 = CNT2 + PI
25266               
25267 B2D8 0201  20        li   rx,>15*256                 ; LDX #21           ; Set X to 21 so the call to PLS5 divides sidev_x
     B2DA 1500     
25268               
25269 B2DC 0206  20        li   rtmp,PLS5                  ; JSR PLS5          ; Call PLS5 to calculate the following:
     B2DE BB1C     
25270 B2E0 06A0  32        bl   @jsr                       ;
     B2E2 FF10     
25271                                                                          ;
25272                                                                          ; (XX16+2 K2+2) = sidev_x / z
25273                                                                          ;
25274                                                                          ; (XX16+3 K2+3) = sidev_y / z
25275               
25276 B2E4 0460  28        b    @PLS2                      ; JMP PLS2          ; Jump to PLS2 to draw the second meridian, returning
     B2E6 B3EA     
25277                                                                          ; from the subroutine using a tail call
25278               
25279               * ******************************************************************************
25280               *
25281               * Name: PL9 (Part 3 of 3)
25282               * Type: Subroutine
25283               * Category: Drawing planets
25284               * Summary: Draw the planet's crater
25285               * Deep dive: Drawing craters
25286               *
25287               * ------------------------------------------------------------------------------
25288               *
25289               * Draw the planet's crater.
25290               *
25291               * ------------------------------------------------------------------------------
25292               *
25293               * Arguments:
25294               *
25295               * K(1 0)              The planet's radius
25296               *
25297               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25298               *
25299               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25300               *
25301               * INWK                The planet's ship data block
25302               *
25303               * ******************************************************************************
25304               
25305               PL26:
25306 B2E8 D020  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z_hi
     B2EA 0067     
25307               
25308 B2EC 11B3  14        jlt  PL20                       ; BMI PL20          ; If A is negative, the crater is on the far side of the
25309                                                                          ; planet, so return from the subroutine (as PL2
25310                                                                          ; contains an RTS)
25311               
25312 B2EE 0201  20        li   rx,>0f*256                 ; LDX #15           ; Set X = 15, so the following call to PLS3 operates on
     B2F0 0F00     
25313                                                                          ; roofv
25314               
25315 B2F2 0206  20        li   rtmp,PLS3                  ; JSR PLS3          ; Call PLS3 to calculate:
     B2F4 BAAC     
25316 B2F6 06A0  32        bl   @jsr                       ;
     B2F8 FF10     
25317                                                                          ;
25318                                                                          ; (Y A P) = 222 * roofv_x / z
25319                                                                          ;
25320                                                                          ; to give the x-coordinate of the crater offset and
25321                                                                          ; increment X to point to roofv_y for the next call
25322               
25323                      .clc                            ; CLC               ; Calculate:
     **** ****     > CLC
0001 B2FA 0A13  18        sla  rzero,1
                   < elite.a99
25324                      .adc @K3,ra                     ; ADC K3            ;
     **** ****     > ADC
0001 B2FC 1701  14        jnc  !
0002 B2FE B004  18        ab   rone,ra
0003               !:
0004 B300 B020  30        ab   @K3,ra
     B302 00D2     
                   < elite.a99
25325 B304 D800  30        movb ra,@K3                     ; STA K3            ; K3(1 0) = (Y A) + K3(1 0)
     B306 00D2     
25326                                                                          ; = 222 * roofv_x / z + x-coordinate of planet
25327                                                                          ; centre
25328                                                                          ;
25329                                                                          ; starting with the high bytes
25330               
25331 B308 D002  18        movb ry,ra                      ; TYA               ; And then doing the low bytes, so now K3(1 0) contains
25332                      .adc @K3+1,ra                   ; ADC K3+1          ; the x-coordinate of the crater offset plus the planet
     **** ****     > ADC
0001 B30A 1701  14        jnc  !
0002 B30C B004  18        ab   rone,ra
0003               !:
0004 B30E B020  30        ab   @K3+1,ra
     B310 00D3     
                   < elite.a99
25333 B312 D800  30        movb ra,@K3+1                   ; STA K3+1          ; centre to give the x-coordinate of the crater's centre
     B314 00D3     
25334               
25335 B316 0206  20        li   rtmp,PLS3                  ; JSR PLS3          ; Call PLS3 to calculate:
     B318 BAAC     
25336 B31A 06A0  32        bl   @jsr                       ;
     B31C FF10     
25337                                                                          ;
25338                                                                          ; (Y A P) = 222 * roofv_y / z
25339                                                                          ;
25340                                                                          ; to give the y-coordinate of the crater offset
25341               
25342 B31E D800  30        movb ra,@P                      ; STA P             ; Calculate:
     B320 001B     
25343 B322 D020  30        movb @K4,ra                     ; LDA K4            ;
     B324 00E0     
25344                      .sec                            ; SEC               ; K4(1 0) = K4(1 0) - (Y A)
     **** ****     > SEC
0001 B326 0A15  18        sla  rmone,1
                   < elite.a99
25345                      .sbc @P,ra                      ; SBC P             ; = 222 * roofv_y / z - y-coordinate of planet
     **** ****     > SBC
0001 B328 1801  14        joc  !
0002 B32A 7004  18        sb   rone,ra
0003               !:
0004 B32C 7020  30        sb   @P,ra
     B32E 001B     
                   < elite.a99
25346 B330 D800  30        movb ra,@K4                     ; STA K4            ; centre
     B332 00E0     
25347                                                                          ;
25348                                                                          ; starting with the low bytes
25349               
25350 B334 D802  30        movb ry,@P                      ; STY P             ; And then doing the low bytes, so now K4(1 0) contains
     B336 001B     
25351 B338 D020  30        movb @K4+1,ra                   ; LDA K4+1          ; the y-coordinate of the crater offset plus the planet
     B33A 00E1     
25352                      .sbc @P,ra                      ; SBC P             ; centre to give the y-coordinate of the crater's centre
     **** ****     > SBC
0001 B33C 1801  14        joc  !
0002 B33E 7004  18        sb   rone,ra
0003               !:
0004 B340 7020  30        sb   @P,ra
     B342 001B     
                   < elite.a99
25353 B344 D800  30        movb ra,@K4+1                   ; STA K4+1
     B346 00E1     
25354               
25355 B348 0201  20        li   rx,>09*256                 ; LDX #9            ; Set X = 9, so the following call to PLS1 operates on
     B34A 0900     
25356                                                                          ; nosev
25357               
25358 B34C 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B34E B3AC     
25359 B350 06A0  32        bl   @jsr                       ;
     B352 FF10     
25360                                                                          ;
25361                                                                          ; (Y A) = nosev_x / z
25362                                                                          ;
25363                                                                          ; and increment X to point to nosev_y for the next call
25364               
25365 B354 0910  18        srl  ra,1                       ; LSR A             ; Set (XX16 K2) = (Y A) / 2
25366 B356 D800  30        movb ra,@K2                     ; STA K2
     B358 00AC     
25367 B35A D802  30        movb ry,@XX16                   ; STY XX16
     B35C 0009     
25368               
25369 B35E 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B360 B3AC     
25370 B362 06A0  32        bl   @jsr                       ;
     B364 FF10     
25371                                                                          ;
25372                                                                          ; (Y A) = nosev_y / z
25373                                                                          ;
25374                                                                          ; and increment X to point to nosev_z for the next call
25375               
25376 B366 0910  18        srl  ra,1                       ; LSR A             ; Set (XX16+1 K2+1) = (Y A) / 2
25377 B368 D800  30        movb ra,@K2+1                   ; STA K2+1
     B36A 00AD     
25378 B36C D802  30        movb ry,@XX16+1                 ; STY XX16+1
     B36E 000A     
25379               
25380 B370 0201  20        li   rx,>15*256                 ; LDX #21           ; Set X = 21, so the following call to PLS1 operates on
     B372 1500     
25381                                                                          ; sidev
25382               
25383 B374 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B376 B3AC     
25384 B378 06A0  32        bl   @jsr                       ;
     B37A FF10     
25385                                                                          ;
25386                                                                          ; (Y A) = sidev_x / z
25387                                                                          ;
25388                                                                          ; and increment X to point to sidev_y for the next call
25389               
25390 B37C 0910  18        srl  ra,1                       ; LSR A             ; Set (XX16+2 K2+2) = (Y A) / 2
25391 B37E D800  30        movb ra,@K2+2                   ; STA K2+2
     B380 00AE     
25392 B382 D802  30        movb ry,@XX16+2                 ; STY XX16+2
     B384 000B     
25393               
25394 B386 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B388 B3AC     
25395 B38A 06A0  32        bl   @jsr                       ;
     B38C FF10     
25396                                                                          ;
25397                                                                          ; (Y A) = sidev_y / z
25398                                                                          ;
25399                                                                          ; and increment X to point to sidev_z for the next call
25400               
25401 B38E 0910  18        srl  ra,1                       ; LSR A             ; Set (XX16+3 K2+3) = (Y A) / 2
25402 B390 D800  30        movb ra,@K2+3                   ; STA K2+3
     B392 00AF     
25403 B394 D802  30        movb ry,@XX16+3                 ; STY XX16+3
     B396 000C     
25404               
25405 B398 0200  20        li   ra,>40*256                 ; LDA #64           ; Set TGT = 64, so we draw a full ellipse in the call to
     B39A 4000     
25406 B39C D800  30        movb ra,@TGT                    ; STA TGT           ; PLS22 below
     B39E 00A0     
25407               
25408 B3A0 0200  20        li   ra,>00*256                 ; LDA #0            ; Set CNT2 = 0 as we are drawing a full ellipse, so we
     B3A2 0000     
25409 B3A4 D800  30        movb ra,@CNT2                   ; STA CNT2          ; don't need to apply an offset
     B3A6 00A5     
25410               
25411 B3A8 0460  28        b    @PLS22                     ; JMP PLS22         ; Jump to PLS22 to draw the crater, returning from the
     B3AA B3F2     
25412                                                                          ; subroutine using a tail call
25413               
25414               * ******************************************************************************
25415               *
25416               * Name: PLS1
25417               * Type: Subroutine
25418               * Category: Drawing planets
25419               * Summary: Calculate (Y A) = nosev_x / z
25420               *
25421               * ------------------------------------------------------------------------------
25422               *
25423               * Calculate the following division of a specified value from one of the
25424               * orientation vectors (in this example, nosev_x):
25425               *
25426               * (Y A) = nosev_x / z
25427               *
25428               * where z is the z-coordinate of the planet from INWK. The result is an 8-bit
25429               * magnitude in A, with maximum value 254, and just a sign bit (bit 7) in Y.
25430               *
25431               * ------------------------------------------------------------------------------
25432               *
25433               * Arguments:
25434               *
25435               * X                   Determines which of the INWK orientation vectors to
25436               * divide:
25437               *
25438               * * X = 9, 11, 13: divides nosev_x, nosev_y, nosev_z
25439               *
25440               * * X = 15, 17, 19: divides roofv_x, roofv_y, roofv_z
25441               *
25442               * * X = 21, 23, 25: divides sidev_x, sidev_y, sidev_z
25443               *
25444               * INWK                The planet's ship data block
25445               *
25446               * ------------------------------------------------------------------------------
25447               *
25448               * Returns:
25449               *
25450               * A                   The result as an 8-bit magnitude with maximum value 254
25451               *
25452               * Y                   The sign of the result in bit 7
25453               *
25454               * K+3                 Also the sign of the result in bit 7
25455               *
25456               * X                   X gets incremented by 2 so it points to the next
25457               * coordinate in this orientation vector (so consecutive
25458               * calls to the routine will start with x, then move onto y
25459               * and then z)
25460               *
25461               * ******************************************************************************
25462               
25463               PLS1:
25464 B3AC D021  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Set P = nosev_x_lo
     B3AE 0053     
25465 B3B0 D800  30        movb ra,@P                      ; STA P
     B3B2 001B     
25466               
25467 B3B4 D021  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Set P+1 = |nosev_x_hi|
     B3B6 0054     
25468 B3B8 0240  22        andi ra,>7f*256                 ; AND #%01111111
     B3BA 7F00     
25469 B3BC D800  30        movb ra,@P+1                    ; STA P+1
     B3BE 001C     
25470               
25471 B3C0 D021  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Set A = sign bit of nosev_x_lo
     B3C2 0054     
25472 B3C4 0240  22        andi ra,>80*256                 ; AND #%10000000
     B3C6 8000     
25473               
25474 B3C8 0206  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     B3CA 45E8     
25475 B3CC 06A0  32        bl   @jsr                       ;
     B3CE FF10     
25476                                                                          ;
25477                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
25478               
25479 B3D0 D020  30        movb @K,ra                      ; LDA K             ; Fetch the lowest byte of the result into A
     B3D2 003D     
25480               
25481 B3D4 D0A0  30        movb @K+1,ry                    ; LDY K+1           ; Fetch the second byte of the result into Y
     B3D6 003E     
25482               
25483 B3D8 1302  14        jeq  B76                        ; BEQ B76           ; If the second byte is 0, skip the next instruction
25484               
25485 B3DA 0200  20        li   ra,>fe*256                 ; LDA #254          ; The second byte is non-zero, so the result won't fit
     B3DC FE00     
25486                                                                          ; into one byte, so set A = 254 as our maximum one-byte
25487                                                                          ; value to return
25488               
25489               B76:
25490 B3DE D0A0  30        movb @K+3,ry                    ; LDY K+3           ; Fetch the sign of the result from K+3 into Y
     B3E0 0040     
25491               
25492 B3E2 B044  18        ab   rone,rx                    ; INX               ; Add 2 to X so the index points to the next coordinate
25493 B3E4 B044  18        ab   rone,rx                    ; INX               ; in this orientation vector (so consecutive calls to
25494                                                                          ; the routine will start with x, then move onto y and z)
25495               
25496 B3E6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B3E8 FF1C     
25497               
25498               * ******************************************************************************
25499               *
25500               * Name: PLS2
25501               * Type: Subroutine
25502               * Category: Drawing planets
25503               * Summary: Draw a half-ellipse
25504               * Deep dive: Drawing ellipses
25505               * Drawing meridians and equators
25506               *
25507               * ------------------------------------------------------------------------------
25508               *
25509               * Draw a half-ellipse, used for the planet's equator and meridian.
25510               *
25511               * ******************************************************************************
25512               
25513               PLS2:
25514 B3EA 0200  20        li   ra,>1f*256                 ; LDA #31           ; Set TGT = 31, so we only draw half an ellipse
     B3EC 1F00     
25515 B3EE D800  30        movb ra,@TGT                    ; STA TGT
     B3F0 00A0     
25516               
25517                                                                          ; Fall through into PLS22 to draw the half-ellipse
25518               
25519               * ******************************************************************************
25520               *
25521               * Name: PLS22
25522               * Type: Subroutine
25523               * Category: Drawing planets
25524               * Summary: Draw an ellipse or half-ellipse
25525               * Deep dive: Drawing ellipses
25526               * Drawing meridians and equators
25527               * Drawing craters
25528               *
25529               * ------------------------------------------------------------------------------
25530               *
25531               * Draw an ellipse or half-ellipse, to be used for the planet's equator and
25532               * meridian (in which case we draw half an ellipse), or crater (in which case we
25533               * draw a full ellipse).
25534               *
25535               * The ellipse is defined by a centre point, plus two conjugate radius vectors,
25536               * u and v, where:
25537               *
25538               * u = [ u_x ]       v = [ v_x ]
25539               * [ u_y ]           [ v_y ]
25540               *
25541               * The individual components of these 2D vectors (i.e. u_x, u_y etc.) are 16-bit
25542               * sign-magnitude numbers, where the high bytes contain only the sign bit (in
25543               * bit 7), with bits 0 to 6 being clear. This means that as we store u_x as
25544               * (XX16 K2), for example, we know that |u_x| = K2.
25545               *
25546               * This routine calls BLINE to draw each line segment in the ellipse, passing the
25547               * coordinates as follows:
25548               *
25549               * K6(1 0) = K3(1 0) + u_x * cos(CNT2) + v_x * sin(CNT2)
25550               *
25551               * K6(3 2) = K4(1 0) - u_y * cos(CNT2) - v_y * sin(CNT2)
25552               *
25553               * The y-coordinates are negated because BLINE expects pixel coordinates but the
25554               * u and v vectors are extracted from the orientation vector. The y-axis runs
25555               * in the opposite direction in 3D space to that on the screen, so we need to
25556               * negate the 3D space coordinates before we can combine them with the ellipse's
25557               * centre coordinates.
25558               *
25559               * ------------------------------------------------------------------------------
25560               *
25561               * Arguments:
25562               *
25563               * K(1 0)              The planet's radius
25564               *
25565               * K3(1 0)             The pixel x-coordinate of the centre of the ellipse
25566               *
25567               * K4(1 0)             The pixel y-coordinate of the centre of the ellipse
25568               *
25569               * (XX16 K2)           The x-component of u (i.e. u_x), where XX16 contains
25570               * just the sign of the sign-magnitude number
25571               *
25572               * (XX16+1 K2+1)       The y-component of u (i.e. u_y), where XX16+1 contains
25573               * just the sign of the sign-magnitude number
25574               *
25575               * (XX16+2 K2+2)       The x-component of v (i.e. v_x), where XX16+2 contains
25576               * just the sign of the sign-magnitude number
25577               *
25578               * (XX16+3 K2+3)       The y-component of v (i.e. v_y), where XX16+3 contains
25579               * just the sign of the sign-magnitude number
25580               *
25581               * TGT                 The number of segments to draw:
25582               *
25583               * * 32 for a half ellipse (a meridian)
25584               *
25585               * * 64 for a full ellipse (a crater)
25586               *
25587               * CNT2                The starting segment for drawing the half-ellipse
25588               *
25589               * ******************************************************************************
25590               
25591               PLS22:
25592 B3F2 0201  20        li   rx,>00*256                 ; LDX #0            ; Set CNT = 0
     B3F4 0000     
25593 B3F6 D801  30        movb rx,@CNT                    ; STX CNT
     B3F8 00A4     
25594               
25595 B3FA 7044  18        sb   rone,rx                    ; DEX               ; Set FLAG = &FF to start a new line in the ball line
25596 B3FC D801  30        movb rx,@FLAG                   ; STX FLAG          ; heap when calling BLIN below, so the crater or
     B3FE 00A3     
25597                                                                          ; meridian is separate from any previous ellipses
25598               
25599               PLL4:
25600 B400 D020  30        movb @CNT2,ra                   ; LDA CNT2          ; Set X = CNT2 mod 32
     B402 00A5     
25601 B404 0240  22        andi ra,>1f*256                 ; AND #31           ;
     B406 1F00     
25602 B408 D040  18        movb ra,rx                      ; TAX               ; So X is the starting segment, reduced to the range 0
25603                                                                          ; to 32, so as there are 64 segments in the circle, this
25604                                                                          ; reduces the starting angle to 0 to 180 degrees, so we
25605                                                                          ; can use X as an index into the sine table (which only
25606                                                                          ; contains values for segments 0 to 31)
25607                                                                          ;
25608                                                                          ; Also, because CNT2 mod 32 is in the range 0 to 180
25609                                                                          ; degrees, we know that sin(CNT2 mod 32) is always
25610                                                                          ; positive, or to put it another way:
25611                                                                          ;
25612                                                                          ; sin(CNT2 mod 32) = |sin(CNT2)|
25613               
25614 B40A D021  34        movb @SNE(rx),ra                ; LDA SNE,X         ; Set Q = sin(X)
     B40C 4112     
25615 B40E D800  30        movb ra,@Q                      ; STA Q             ; = sin(CNT2 mod 32)
     B410 0090     
25616                                                                          ; = |sin(CNT2)|
25617               
25618 B412 D020  30        movb @K2+2,ra                   ; LDA K2+2          ; Set A = K2+2
     B414 00AE     
25619                                                                          ; = |v_x|
25620               
25621 B416 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     B418 4338     
25622 B41A 06A0  32        bl   @jsr                       ;
     B41C FF10     
25623 B41E D800  30        movb ra,@R                      ; STA R             ; = |v_x| * |sin(CNT2)|
     B420 0091     
25624               
25625 B422 D020  30        movb @K2+3,ra                   ; LDA K2+3          ; Set A = K2+3
     B424 00AF     
25626                                                                          ; = |v_y|
25627               
25628 B426 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set K = A * Q / 256
     B428 4338     
25629 B42A 06A0  32        bl   @jsr                       ;
     B42C FF10     
25630 B42E D800  30        movb ra,@K                      ; STA K             ; = |v_y| * |sin(CNT2)|
     B430 003D     
25631               
25632 B432 D060  30        movb @CNT2,rx                   ; LDX CNT2          ; If CNT2 >= 33 then this sets the C flag, otherwise
     B434 00A5     
25633 B436 0281  22        ci   rx,>21*256                 ; CPX #33           ; it's clear, so this means that:
     B438 2100     
25634                                                                          ;
25635                                                                          ; * C is clear if the segment starts in the first half
25636                                                                          ; of the circle, 0 to 180 degrees
25637                                                                          ;
25638                                                                          ; * C is set if the segment starts in the second half
25639                                                                          ; of the circle, 180 to 360 degrees
25640                                                                          ;
25641                                                                          ; In other words, the C flag contains the sign bit for
25642                                                                          ; sin(CNT2), which is positive for 0 to 180 degrees
25643                                                                          ; and negative for 180 to 360 degrees
25644               
25645 B43A 0200  20        li   ra,>00*256                 ; LDA #0            ; Shift the C flag into the sign bit of XX16+5, so
     B43C 0000     
25646 B43E 06A0  32        bl   @rora                      ; ROR A             ; XX16+5 has the correct sign for sin(CNT2)
     B440 FF4A     
25647 B442 D800  30        movb ra,@XX16+5                 ; STA XX16+5        ;
     B444 000E     
25648                                                                          ; Because we set the following above:
25649                                                                          ;
25650                                                                          ; K = |v_y| * |sin(CNT2)|
25651                                                                          ; R = |v_x| * |sin(CNT2)|
25652                                                                          ;
25653                                                                          ; we can add XX16+5 as the high byte to give us the
25654                                                                          ; following:
25655                                                                          ;
25656                                                                          ; (XX16+5 K) = |v_y| * sin(CNT2)
25657                                                                          ; (XX16+5 R) = |v_x| * sin(CNT2)
25658               
25659 B446 D020  30        movb @CNT2,ra                   ; LDA CNT2          ; Set X = (CNT2 + 16) mod 32
     B448 00A5     
25660                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 B44A 0A13  18        sla  rzero,1
                   < elite.a99
25661                      .adi (>10*256)                  ; ADC #16           ; So we can use X as a lookup index into the SNE table
     **** ****     > ADI
0001 B44C 1701  14        jnc  !
0002 B44E B004  18        ab   rone,ra
0003               !:
0004 B450 0220  22        ai   ra,(>10*256)
     B452 1000     
                   < elite.a99
25662 B454 0240  22        andi ra,>1f*256                 ; AND #31           ; to get the cosine (as there are 16 segments in a
     B456 1F00     
25663 B458 D040  18        movb ra,rx                      ; TAX               ; quarter-circle)
25664                                                                          ;
25665                                                                          ; Also, because the sine table only contains positive
25666                                                                          ; values, we know that sin((CNT2 + 16) mod 32) will
25667                                                                          ; always be positive, or to put it another way:
25668                                                                          ;
25669                                                                          ; sin((CNT2 + 16) mod 32) = |cos(CNT2)|
25670               
25671 B45A D021  34        movb @SNE(rx),ra                ; LDA SNE,X         ; Set Q = sin(X)
     B45C 4112     
25672 B45E D800  30        movb ra,@Q                      ; STA Q             ; = sin((CNT2 + 16) mod 32)
     B460 0090     
25673                                                                          ; = |cos(CNT2)|
25674               
25675 B462 D020  30        movb @K2+1,ra                   ; LDA K2+1          ; Set A = K2+1
     B464 00AD     
25676                                                                          ; = |u_y|
25677               
25678 B466 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set K+2 = A * Q / 256
     B468 4338     
25679 B46A 06A0  32        bl   @jsr                       ;
     B46C FF10     
25680 B46E D800  30        movb ra,@K+2                    ; STA K+2           ; = |u_y| * |cos(CNT2)|
     B470 003F     
25681               
25682 B472 D020  30        movb @K2,ra                     ; LDA K2            ; Set A = K2
     B474 00AC     
25683                                                                          ; = |u_x|
25684               
25685 B476 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set P = A * Q / 256
     B478 4338     
25686 B47A 06A0  32        bl   @jsr                       ;
     B47C FF10     
25687 B47E D800  30        movb ra,@P                      ; STA P             ; = |u_x| * |cos(CNT2)|
     B480 001B     
25688                                                                          ;
25689                                                                          ; The call to FMLTU also sets the C flag, so in the
25690                                                                          ; following, ADC #15 adds 16 rather than 15
25691               
25692 B482 D020  30        movb @CNT2,ra                   ; LDA CNT2          ; If (CNT2 + 16) mod 64 >= 33 then this sets the C flag,
     B484 00A5     
25693                      .adi (>0f*256)                  ; ADC #15           ; otherwise it's clear, so this means that:
     **** ****     > ADI
0001 B486 1701  14        jnc  !
0002 B488 B004  18        ab   rone,ra
0003               !:
0004 B48A 0220  22        ai   ra,(>0F*256)
     B48C 0F00     
                   < elite.a99
25694 B48E 0240  22        andi ra,>3f*256                 ; AND #63           ;
     B490 3F00     
25695 B492 0280  22        ci   ra,>21*256                 ; CMP #33           ; * C is clear if the segment starts in the first or
     B494 2100     
25696                                                                          ; last quarter of the circle, 0 to 90 degrees or 270
25697                                                                          ; to 360 degrees
25698                                                                          ;
25699                                                                          ; * C is set if the segment starts in the second or
25700                                                                          ; third quarter of the circle, 90 to 270 degrees
25701                                                                          ;
25702                                                                          ; In other words, the C flag contains the sign bit for
25703                                                                          ; cos(CNT2), which is positive for 0 to 90 degrees or
25704                                                                          ; 270 to 360 degrees, and negative for 90 to 270 degrees
25705               
25706 B496 0200  20        li   ra,>00*256                 ; LDA #0            ; Shift the C flag into the sign bit of XX16+4, so:
     B498 0000     
25707 B49A 06A0  32        bl   @rora                      ; ROR A             ; XX16+4 has the correct sign for cos(CNT2)
     B49C FF4A     
25708 B49E D800  30        movb ra,@XX16+4                 ; STA XX16+4        ;
     B4A0 000D     
25709                                                                          ; Because we set the following above:
25710                                                                          ;
25711                                                                          ; K+2 = |u_y| * |cos(CNT2)|
25712                                                                          ; P   = |u_x| * |cos(CNT2)|
25713                                                                          ;
25714                                                                          ; we can add XX16+4 as the high byte to give us the
25715                                                                          ; following:
25716                                                                          ;
25717                                                                          ; (XX16+4 K+2) = |u_y| * cos(CNT2)
25718                                                                          ; (XX16+4 P)   = |u_x| * cos(CNT2)
25719               
25720 B4A2 D020  30        movb @XX16+5,ra                 ; LDA XX16+5        ; Set S = the sign of XX16+2 * XX16+5
     B4A4 000E     
25721                      .eor @XX16+2                    ; EOR XX16+2        ; = the sign of v_x * XX16+5
     **** ****     > EOR
0001 B4A6 D1A0  30        movb @XX16+2,rtmp
     B4A8 000B     
0002 B4AA 2806  18        xor  rtmp,ra
                   < elite.a99
25722 B4AC D800  30        movb ra,@S                      ; STA S             ;
     B4AE 0092     
25723                                                                          ; So because we set this above:
25724                                                                          ;
25725                                                                          ; (XX16+5 R) = |v_x| * sin(CNT2)
25726                                                                          ;
25727                                                                          ; we now have this:
25728                                                                          ;
25729                                                                          ; (S R) = v_x * sin(CNT2)
25730               
25731 B4B0 D020  30        movb @XX16+4,ra                 ; LDA XX16+4        ; Set A = the sign of XX16 * XX16+4
     B4B2 000D     
25732                      .eor @XX16                      ; EOR XX16          ; = the sign of u_x * XX16+4
     **** ****     > EOR
0001 B4B4 D1A0  30        movb @XX16,rtmp
     B4B6 0009     
0002 B4B8 2806  18        xor  rtmp,ra
                   < elite.a99
25733                                                                          ;
25734                                                                          ; So because we set this above:
25735                                                                          ;
25736                                                                          ; (XX16+4 P)   = |u_x| * cos(CNT2)
25737                                                                          ;
25738                                                                          ; we now have this:
25739                                                                          ;
25740                                                                          ; (A P) = u_x * cos(CNT2)
25741               
25742 B4BA 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     B4BC 44BA     
25743 B4BE 06A0  32        bl   @jsr                       ;
     B4C0 FF10     
25744                                                                          ; = u_x * cos(CNT2) + v_x * sin(CNT2)
25745               
25746 B4C2 D800  30        movb ra,@T                      ; STA T             ; Store the high byte in T, so the result is now:
     B4C4 00D1     
25747                                                                          ;
25748                                                                          ; (T X) = u_x * cos(CNT2) + v_x * sin(CNT2)
25749               
25750 B4C6 1515  14        jgt  PL42                       ; BPL PL42          ; If the result is positive, jump down to PL42
25751               
25752 B4C8 D001  18        movb rx,ra                      ; TXA               ; The result is negative, so we need to negate the
25753                      .eoi (>ff*256)                  ; EOR #%11111111    ; magnitude using two's complement, first doing the low
     **** ****     > EOI
0001 B4CA 0206  20        li   rtmp,(>FF*256)
     B4CC FF00     
0002 B4CE 2806  18        xor  rtmp,ra
                   < elite.a99
25754                      .clc                            ; CLC               ; byte in X
     **** ****     > CLC
0001 B4D0 0A13  18        sla  rzero,1
                   < elite.a99
25755                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 B4D2 1701  14        jnc  !
0002 B4D4 B004  18        ab   rone,ra
0003               !:
0004 B4D6 0220  22        ai   ra,(>01*256)
     B4D8 0100     
                   < elite.a99
25756 B4DA D040  18        movb ra,rx                      ; TAX
25757               
25758 B4DC D020  30        movb @T,ra                      ; LDA T             ; And then the high byte in T, making sure to leave the
     B4DE 00D1     
25759                      .eoi (>7f*256)                  ; EOR #%01111111    ; sign bit alone
     **** ****     > EOI
0001 B4E0 0206  20        li   rtmp,(>7F*256)
     B4E2 7F00     
0002 B4E4 2806  18        xor  rtmp,ra
                   < elite.a99
25760                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 B4E6 1701  14        jnc  !
0002 B4E8 B004  18        ab   rone,ra
0003               !:
0004 B4EA 0220  22        ai   ra,(>00*256)
     B4EC 0000     
                   < elite.a99
25761 B4EE D800  30        movb ra,@T                      ; STA T
     B4F0 00D1     
25762               
25763               PL42:
25764 B4F2 D001  18        movb rx,ra                      ; TXA               ; Set K6(1 0) = K3(1 0) + (T X)
25765                      .adc @K3,ra                     ; ADC K3            ;
     **** ****     > ADC
0001 B4F4 1701  14        jnc  !
0002 B4F6 B004  18        ab   rone,ra
0003               !:
0004 B4F8 B020  30        ab   @K3,ra
     B4FA 00D2     
                   < elite.a99
25766 B4FC D800  30        movb ra,@K6                     ; STA K6            ; starting with the low bytes
     B4FE 0082     
25767               
25768 B500 D020  30        movb @T,ra                      ; LDA T             ; And then doing the high bytes, so we now get:
     B502 00D1     
25769                      .adc @K3+1,ra                   ; ADC K3+1          ;
     **** ****     > ADC
0001 B504 1701  14        jnc  !
0002 B506 B004  18        ab   rone,ra
0003               !:
0004 B508 B020  30        ab   @K3+1,ra
     B50A 00D3     
                   < elite.a99
25770 B50C D800  30        movb ra,@K6+1                   ; STA K6+1          ; K6(1 0) = K3(1 0) + (T X)
     B50E 0083     
25771                                                                          ; = K3(1 0) + u_x * cos(CNT2)
25772                                                                          ; + v_x * sin(CNT2)
25773                                                                          ;
25774                                                                          ; K3(1 0) is the x-coordinate of the centre of the
25775                                                                          ; ellipse, so we now have the correct x-coordinate for
25776                                                                          ; our ellipse segment that we can pass to BLINE below
25777               
25778 B510 D020  30        movb @K,ra                      ; LDA K             ; Set R = K = |v_y| * sin(CNT2)
     B512 003D     
25779 B514 D800  30        movb ra,@R                      ; STA R
     B516 0091     
25780               
25781 B518 D020  30        movb @XX16+5,ra                 ; LDA XX16+5        ; Set S = the sign of XX16+3 * XX16+5
     B51A 000E     
25782                      .eor @XX16+3                    ; EOR XX16+3        ; = the sign of v_y * XX16+5
     **** ****     > EOR
0001 B51C D1A0  30        movb @XX16+3,rtmp
     B51E 000C     
0002 B520 2806  18        xor  rtmp,ra
                   < elite.a99
25783 B522 D800  30        movb ra,@S                      ; STA S             ;
     B524 0092     
25784                                                                          ; So because we set this above:
25785                                                                          ;
25786                                                                          ; (XX16+5 K) = |v_y| * sin(CNT2)
25787                                                                          ;
25788                                                                          ; and we just set R = K, we now have this:
25789                                                                          ;
25790                                                                          ; (S R) = v_y * sin(CNT2)
25791               
25792 B526 D020  30        movb @K+2,ra                    ; LDA K+2           ; Set P = K+2 = |u_y| * cos(CNT2)
     B528 003F     
25793 B52A D800  30        movb ra,@P                      ; STA P
     B52C 001B     
25794               
25795 B52E D020  30        movb @XX16+4,ra                 ; LDA XX16+4        ; Set A = the sign of XX16+1 * XX16+4
     B530 000D     
25796                      .eor @XX16+1                    ; EOR XX16+1        ; = the sign of u_y * XX16+4
     **** ****     > EOR
0001 B532 D1A0  30        movb @XX16+1,rtmp
     B534 000A     
0002 B536 2806  18        xor  rtmp,ra
                   < elite.a99
25797                                                                          ;
25798                                                                          ; So because we set this above:
25799                                                                          ;
25800                                                                          ; (XX16+4 K+2) = |u_y| * cos(CNT2)
25801                                                                          ;
25802                                                                          ; and we just set P = K+2, we now have this:
25803                                                                          ;
25804                                                                          ; (A P) = u_y * cos(CNT2)
25805               
25806 B538 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     B53A 44BA     
25807 B53C 06A0  32        bl   @jsr                       ;
     B53E FF10     
25808                                                                          ; =  u_y * cos(CNT2) + v_y * sin(CNT2)
25809               
25810                      .eoi (>80*256)                  ; EOR #%10000000    ; Store the negated high byte in T, so the result is
     **** ****     > EOI
0001 B540 0206  20        li   rtmp,(>80*256)
     B542 8000     
0002 B544 2806  18        xor  rtmp,ra
                   < elite.a99
25811 B546 D800  30        movb ra,@T                      ; STA T             ; now:
     B548 00D1     
25812                                                                          ;
25813                                                                          ; (T X) = - u_y * cos(CNT2) - v_y * sin(CNT2)
25814                                                                          ;
25815                                                                          ; This negation is necessary because BLINE expects us
25816                                                                          ; to pass pixel coordinates, where y-coordinates get
25817                                                                          ; larger as we go down the screen; u_y and v_y, on the
25818                                                                          ; other hand, are extracted from the orientation
25819                                                                          ; vectors, where y-coordinates get larger as we go up
25820                                                                          ; in space, so to rectify this we need to negate the
25821                                                                          ; result in (T X) before we can add it to the
25822                                                                          ; y-coordinate of the ellipse's centre in BLINE
25823               
25824 B54A 1515  14        jgt  PL43                       ; BPL PL43          ; If the result is positive, jump down to PL43
25825               
25826 B54C D001  18        movb rx,ra                      ; TXA               ; The result is negative, so we need to negate the
25827                      .eoi (>ff*256)                  ; EOR #%11111111    ; magnitude using two's complement, first doing the low
     **** ****     > EOI
0001 B54E 0206  20        li   rtmp,(>FF*256)
     B550 FF00     
0002 B552 2806  18        xor  rtmp,ra
                   < elite.a99
25828                      .clc                            ; CLC               ; byte in X
     **** ****     > CLC
0001 B554 0A13  18        sla  rzero,1
                   < elite.a99
25829                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 B556 1701  14        jnc  !
0002 B558 B004  18        ab   rone,ra
0003               !:
0004 B55A 0220  22        ai   ra,(>01*256)
     B55C 0100     
                   < elite.a99
25830 B55E D040  18        movb ra,rx                      ; TAX
25831               
25832 B560 D020  30        movb @T,ra                      ; LDA T             ; And then the high byte in T, making sure to leave the
     B562 00D1     
25833                      .eoi (>7f*256)                  ; EOR #%01111111    ; sign bit alone
     **** ****     > EOI
0001 B564 0206  20        li   rtmp,(>7F*256)
     B566 7F00     
0002 B568 2806  18        xor  rtmp,ra
                   < elite.a99
25834                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 B56A 1701  14        jnc  !
0002 B56C B004  18        ab   rone,ra
0003               !:
0004 B56E 0220  22        ai   ra,(>00*256)
     B570 0000     
                   < elite.a99
25835 B572 D800  30        movb ra,@T                      ; STA T
     B574 00D1     
25836               
25837               PL43:
25838                                                                          ; We now call BLINE to draw the ellipse line segment
25839                                                                          ;
25840                                                                          ; The first few instructions of BLINE do the following:
25841                                                                          ;
25842                                                                          ; K6(3 2) = K4(1 0) + (T X)
25843                                                                          ;
25844                                                                          ; which gives:
25845                                                                          ;
25846                                                                          ; K6(3 2) = K4(1 0) - u_y * cos(CNT2)
25847                                                                          ; - v_y * sin(CNT2)
25848                                                                          ;
25849                                                                          ; K4(1 0) is the pixel y-coordinate of the centre of the
25850                                                                          ; ellipse, so this gives us the correct y-coordinate for
25851                                                                          ; our ellipse segment (we already calculated the
25852                                                                          ; x-coordinate in K3(1 0) above)
25853 B576 0206  20        li   rtmp,BLINE                 ; JSR BLINE         ; Call BLINE to draw this segment, which also returns
     B578 283E     
25854 B57A 06A0  32        bl   @jsr                       ;
     B57C FF10     
25855                                                                          ; the updated value of CNT in A
25856               
25857 B57E 9020  30        cb   @TGT,ra                    ; CMP TGT           ; If CNT > TGT then jump to PL40 to stop drawing the
     B580 00A0     
25858 B582 1301  14        jeq  B77                        ; BEQ B77           ; ellipse (which is how we draw half-ellipses)
25859 B584 180D  14        joc  PL40                       ; BCS PL40
25860               
25861               B77:
25862 B586 D020  30        movb @CNT2,ra                   ; LDA CNT2          ; Set CNT2 = (CNT2 + STP) mod 64
     B588 00A5     
25863                      .clc                            ; CLC
     **** ****     > CLC
0001 B58A 0A13  18        sla  rzero,1
                   < elite.a99
25864                      .adc @STP,ra                    ; ADC STP
     **** ****     > ADC
0001 B58C 1701  14        jnc  !
0002 B58E B004  18        ab   rone,ra
0003               !:
0004 B590 B020  30        ab   @STP,ra
     B592 00A6     
                   < elite.a99
25865 B594 0240  22        andi ra,>3f*256                 ; AND #63
     B596 3F00     
25866 B598 D800  30        movb ra,@CNT2                   ; STA CNT2
     B59A 00A5     
25867               
25868 B59C 0460  28        b    @PLL4                      ; JMP PLL4          ; Jump back to PLL4 to draw the next segment
     B59E B400     
25869               
25870               PL40:
25871 B5A0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B5A2 FF1C     
25872               
25873               * ******************************************************************************
25874               *
25875               * Name: SUN (Part 1 of 4)
25876               * Type: Subroutine
25877               * Category: Drawing suns
25878               * Summary: Draw the sun: Set up all the variables needed to draw the sun
25879               * Deep dive: Drawing the sun
25880               *
25881               * ------------------------------------------------------------------------------
25882               *
25883               * Draw a new sun with radius K at pixel coordinate (K3, K4), removing the old
25884               * sun if there is one. This routine is used to draw the sun, as well as the
25885               * star systems on the Short-range Chart.
25886               *
25887               * The first part sets up all the variables needed to draw the new sun.
25888               *
25889               * ------------------------------------------------------------------------------
25890               *
25891               * Arguments:
25892               *
25893               * K                   The new sun's radius
25894               *
25895               * K3(1 0)             Pixel x-coordinate of the centre of the new sun
25896               *
25897               * K4(1 0)             Pixel y-coordinate of the centre of the new sun
25898               *
25899               * SUNX(1 0)           The x-coordinate of the vertical centre axis of the old
25900               * sun (the one currently on-screen)
25901               *
25902               * ******************************************************************************
25903               
25904 B5A4 0460  28        b    @WPLS                      ; JMP WPLS          ; Jump to WPLS to remove the old sun from the screen. We
     B5A6 B97C     
25905                                                                          ; only get here via the BCS just after the SUN entry
25906                                                                          ; point below, when there is no new sun to draw
25907               
25908               PLF3:
25909                                                                          ; This is called from below to negate X and set A to
25910                                                                          ; &FF, for when the new sun's centre is off the bottom
25911                                                                          ; of the screen (so we don't need to draw its bottom
25912                                                                          ; half)
25913                                                                          ;
25914                                                                          ; This happens when the y-coordinate of the centre of
25915                                                                          ; the sun is bigger than the y-coordinate of the bottom
25916                                                                          ; of the space view
25917 B5A8 D001  18        movb rx,ra                      ; TXA               ; Negate X using two's complement, so X = ~X + 1
25918                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 B5AA 0206  20        li   rtmp,(>FF*256)
     B5AC FF00     
0002 B5AE 2806  18        xor  rtmp,ra
                   < elite.a99
25919                      .clc                            ; CLC
     **** ****     > CLC
0001 B5B0 0A13  18        sla  rzero,1
                   < elite.a99
25920                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 B5B2 1701  14        jnc  !
0002 B5B4 B004  18        ab   rone,ra
0003               !:
0004 B5B6 0220  22        ai   ra,(>01*256)
     B5B8 0100     
                   < elite.a99
25921 B5BA D040  18        movb ra,rx                      ; TAX
25922               
25923               PLF17:
25924                                                                          ; This is called from below to set A to &FF, for when
25925                                                                          ; the new sun's centre is right on the bottom of the
25926                                                                          ; screen (so we don't need to draw its bottom half)
25927 B5BC 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A = &FF
     B5BE FF00     
25928               
25929 B5C0 0460  28        b    @PLF5                      ; JMP PLF5          ; Jump to PLF5
     B5C2 B64C     
25930               
25931               SUN:
25932 B5C4 0200  20        li   ra,>01*256                 ; LDA #1            ; Set LSX = 1 to indicate the sun line heap is about to
     B5C6 0100     
25933 B5C8 D800  30        movb ra,@LSX                    ; STA LSX           ; be filled up
     B5CA 0D66     
25934               
25935 B5CC 0206  20        li   rtmp,CHKON                 ; JSR CHKON         ; Call CHKON to check whether any part of the new sun's
     B5CE BA20     
25936 B5D0 06A0  32        bl   @jsr                       ;
     B5D2 FF10     
25937                                                                          ; circle appears on-screen, and if it does, set P(2 1)
25938                                                                          ; to the maximum y-coordinate of the new sun on-screen
25939               
25940 B5D4 18E7  14        joc  PLF3-3                     ; BCS PLF3-3        ; If CHKON set the C flag then the new sun's circle does
25941                                                                          ; not appear on-screen, so jump to WPLS (via the JMP at
25942                                                                          ; the top of this routine) to remove the sun from the
25943                                                                          ; screen, returning from the subroutine using a tail
25944                                                                          ; call
25945               
25946 B5D6 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     B5D8 0000     
25947               
25948 B5DA D060  30        movb @K,rx                      ; LDX K             ; Set X = K = radius of the new sun
     B5DC 003D     
25949               
25950 B5DE 0281  22        ci   rx,>60*256                 ; CPX #96           ; If X >= 96, set the C flag and rotate it into bit 0
     B5E0 6000     
25951 B5E2 06A0  32        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     B5E4 FF26     
25952               
25953 B5E6 0281  22        ci   rx,>28*256                 ; CPX #40           ; If X >= 40, set the C flag and rotate it into bit 0
     B5E8 2800     
25954 B5EA 06A0  32        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     B5EC FF26     
25955               
25956 B5EE 0281  22        ci   rx,>10*256                 ; CPX #16           ; If X >= 16, set the C flag and rotate it into bit 0
     B5F0 1000     
25957 B5F2 06A0  32        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     B5F4 FF26     
25958               
25959                                                                          ; By now, A contains the following:
25960                                                                          ;
25961                                                                          ; * If radius is 96-255 then A = %111 = 7
25962                                                                          ;
25963                                                                          ; * If radius is 40-95  then A = %11  = 3
25964                                                                          ;
25965                                                                          ; * If radius is 16-39  then A = %1   = 1
25966                                                                          ;
25967                                                                          ; * If radius is 0-15   then A = %0   = 0
25968                                                                          ;
25969                                                                          ; The value of A determines the size of the new sun's
25970                                                                          ; ragged fringes - the bigger the sun, the bigger the
25971                                                                          ; fringes
25972               
25973               PLF18:
25974 B5F6 D800  30        movb ra,@CNT                    ; STA CNT           ; Store the fringe size in CNT
     B5F8 00A4     
25975               
25976                                                                          ; We now calculate the highest pixel y-coordinate of the
25977                                                                          ; new sun, given that P(2 1) contains the 16-bit maximum
25978                                                                          ; y-coordinate of the new sun on-screen
25979               
25980 B5FA 0200  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     B5FC BF00     
25981                                                                          ; view, so this sets Y to the y-coordinate of the bottom
25982                                                                          ; of the space view
25983               
25984 B5FE D060  30        movb @P+2,rx                    ; LDX P+2           ; If P+2 is non-zero, the maximum y-coordinate is off
     B600 001D     
25985 B602 1608  14        jne  PLF2                       ; BNE PLF2          ; the bottom of the screen, so skip to PLF2 with A set
25986                                                                          ; to the y-coordinate of the bottom of the space view
25987               
25988 B604 9020  30        cb   @P+1,ra                    ; CMP P+1           ; If A < P+1, the maximum y-coordinate is underneath the
     B606 001C     
25989 B608 1705  14        jnc  PLF2                       ; BCC PLF2          ; dashboard, so skip to PLF2 with A set to the
25990                                                                          ; y-coordinate of the bottom of the space view
25991               
25992 B60A D020  30        movb @P+1,ra                    ; LDA P+1           ; Set A = P+1, the low byte of the maximum y-coordinate
     B60C 001C     
25993                                                                          ; of the sun on-screen
25994               
25995 B60E 1602  14        jne  PLF2                       ; BNE PLF2          ; If A is non-zero, skip to PLF2 as it contains the
25996                                                                          ; value we are after
25997               
25998 B610 0200  20        li   ra,>01*256                 ; LDA #1            ; Otherwise set A = 1, the top line of the screen
     B612 0100     
25999               
26000               PLF2:
26001 B614 D800  30        movb ra,@TGT                    ; STA TGT           ; Set TGT to A, the maximum y-coordinate of the sun on
     B616 00A0     
26002                                                                          ; screen
26003               
26004                                                                          ; We now calculate the number of lines we need to draw
26005                                                                          ; and the direction in which we need to draw them, both
26006                                                                          ; from the centre of the new sun
26007               
26008 B618 0200  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set (A X) = y-coordinate of bottom of screen - K4(1 0)
     B61A BF00     
26009                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 B61C 0A15  18        sla  rmone,1
                   < elite.a99
26010                      .sbc @K4,ra                     ; SBC K4            ; Starting with the low bytes
     **** ****     > SBC
0001 B61E 1801  14        joc  !
0002 B620 7004  18        sb   rone,ra
0003               !:
0004 B622 7020  30        sb   @K4,ra
     B624 00E0     
                   < elite.a99
26011 B626 D040  18        movb ra,rx                      ; TAX
26012               
26013 B628 0200  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so (A X) now contains
     B62A 0000     
26014                      .sbc @K4+1,ra                   ; SBC K4+1          ; the number of lines between the centre of the sun and
     **** ****     > SBC
0001 B62C 1801  14        joc  !
0002 B62E 7004  18        sb   rone,ra
0003               !:
0004 B630 7020  30        sb   @K4+1,ra
     B632 00E1     
                   < elite.a99
26015                                                                          ; the bottom of the screen. If it is positive then the
26016                                                                          ; centre of the sun is above the bottom of the screen,
26017                                                                          ; if it is negative then the centre of the sun is below
26018                                                                          ; the bottom of the screen
26019               
26020 B634 11B9  14        jlt  PLF3                       ; BMI PLF3          ; If A < 0, then this means the new sun's centre is off
26021                                                                          ; the bottom of the screen, so jump up to PLF3 to negate
26022                                                                          ; the height in X (so it becomes positive), set A to &FF
26023                                                                          ; and jump down to PLF5
26024               
26025 B636 1606  14        jne  PLF4                       ; BNE PLF4          ; If A > 0, then the new sun's centre is at least a full
26026                                                                          ; screen above the bottom of the space view, so jump
26027                                                                          ; down to PLF4 to set X = radius and A = 0
26028               
26029 B638 B044  18        ab   rone,rx                    ; INX               ; Set the flags depending on the value of X
26030 B63A 7044  18        sb   rone,rx                    ; DEX
26031               
26032 B63C 13BF  14        jeq  PLF17                      ; BEQ PLF17         ; If X = 0 (we already know A = 0 by this point) then
26033                                                                          ; jump up to PLF17 to set A to &FF before jumping down
26034                                                                          ; to PLF5
26035               
26036 B63E 9060  30        cb   @K,rx                      ; CPX K             ; If X < the radius in K, jump down to PLF5, so if
     B640 003D     
26037 B642 1704  14        jnc  PLF5                       ; BCC PLF5          ; X >= the radius in K, we set X = radius and A = 0
26038               
26039               PLF4:
26040 B644 D060  30        movb @K,rx                      ; LDX K             ; Set X to the radius
     B646 003D     
26041               
26042 B648 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     B64A 0000     
26043               
26044               PLF5:
26045 B64C D801  30        movb rx,@V                      ; STX V             ; Store the height in V
     B64E 0022     
26046               
26047 B650 D800  30        movb ra,@V+1                    ; STA V+1           ; Store the direction in V+1
     B652 0023     
26048               
26049 B654 D020  30        movb @K,ra                      ; LDA K             ; Set (A P) = K * K
     B656 003D     
26050 B658 0206  20        li   rtmp,SQUA2                 ; JSR SQUA2
     B65A 42BA     
26051 B65C 06A0  32        bl   @jsr                       ;
     B65E FF10     
26052               
26053 B660 D800  30        movb ra,@K2+1                   ; STA K2+1          ; Set K2(1 0) = (A P) = K * K
     B662 00AD     
26054 B664 D020  30        movb @P,ra                      ; LDA P
     B666 001B     
26055 B668 D800  30        movb ra,@K2                     ; STA K2
     B66A 00AC     
26056               
26057                                                                          ; By the time we get here, the variables should be set
26058                                                                          ; up as shown in the header for part 3 below
26059               
26060               * ******************************************************************************
26061               *
26062               * Name: SUN (Part 2 of 4)
26063               * Type: Subroutine
26064               * Category: Drawing suns
26065               * Summary: Draw the sun: Start from the bottom of the screen and erase the
26066               * old sun line by line
26067               * Deep dive: Drawing the sun
26068               *
26069               * ------------------------------------------------------------------------------
26070               *
26071               * This part erases the old sun, starting at the bottom of the screen and working
26072               * upwards until we reach the bottom of the new sun.
26073               *
26074               * ******************************************************************************
26075               
26076 B66C 0202  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; Set Y = y-coordinate of the bottom of the screen,
     B66E BF00     
26077                                                                          ; which we use as a counter in the following routine to
26078                                                                          ; redraw the old sun
26079               
26080 B670 D020  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     B672 0028     
26081 B674 D800  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     B676 0026     
26082 B678 D020  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     B67A 0029     
26083 B67C D800  30        movb ra,@YY+1                   ; STA YY+1
     B67E 0027     
26084               
26085               PLFL2:
26086 B680 90A0  30        cb   @TGT,ry                    ; CPY TGT           ; If Y = TGT, we have reached the line where we will
     B682 00A0     
26087 B684 1309  14        jeq  PLFL                       ; BEQ PLFL          ; start drawing the new sun, so there is no need to
26088                                                                          ; keep erasing the old one, so jump down to PLFL
26089               
26090 B686 D022  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     B688 0D66     
26091                                                                          ; gives us the half-width of the old sun's line on this
26092                                                                          ; line of the screen
26093               
26094 B68A 1304  14        jeq  PLF13                      ; BEQ PLF13         ; If A = 0, skip the following call to HLOIN2 as there
26095                                                                          ; is no sun line on this line of the screen
26096               
26097 B68C 0206  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     B68E 25DA     
26098 B690 06A0  32        bl   @jsr                       ;
     B692 FF10     
26099                                                                          ; with centre point YY(1 0) and half-width A, and remove
26100                                                                          ; the line from the sun line heap once done
26101               
26102               PLF13:
26103 B694 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
26104               
26105 B696 16F4  14        jne  PLFL2                      ; BNE PLFL2         ; Loop back for the next line in the line heap until
26106                                                                          ; we have either gone through the entire heap, or
26107                                                                          ; reached the bottom row of the new sun
26108               
26109               * ******************************************************************************
26110               *
26111               * Name: SUN (Part 3 of 4)
26112               * Type: Subroutine
26113               * Category: Drawing suns
26114               * Summary: Draw the sun: Continue to move up the screen, drawing the new sun
26115               * line by line
26116               * Deep dive: Drawing the sun
26117               *
26118               * ------------------------------------------------------------------------------
26119               *
26120               * This part draws the new sun. By the time we get to this point, the following
26121               * variables should have been set up by parts 1 and 2:
26122               *
26123               * ------------------------------------------------------------------------------
26124               *
26125               * Arguments:
26126               *
26127               * V                   As we draw lines for the new sun, V contains the
26128               * vertical distance between the line we're drawing and the
26129               * centre of the new sun. As we draw lines and move up the
26130               * screen, we either decrement (bottom half) or increment
26131               * (top half) this value. See the deep dive on "Drawing the
26132               * sun" to see a diagram that shows V in action
26133               *
26134               * V+1                 This determines which half of the new sun we are drawing
26135               * as we work our way up the screen, line by line:
26136               *
26137               * * 0 means we are drawing the bottom half, so the lines
26138               * get wider as we work our way up towards the centre,
26139               * at which point we will move into the top half, and
26140               * V+1 will switch to &FF
26141               *
26142               * * &FF means we are drawing the top half, so the lines
26143               * get smaller as we work our way up, away from the
26144               * centre
26145               *
26146               * TGT                 The maximum y-coordinate of the new sun on-screen (i.e.
26147               * the screen y-coordinate of the bottom row of the new
26148               * sun)
26149               *
26150               * CNT                 The fringe size of the new sun
26151               *
26152               * K2(1 0)             The new sun's radius squared, i.e. K^2
26153               *
26154               * Y                   The y-coordinate of the bottom row of the new sun
26155               *
26156               * ******************************************************************************
26157               
26158               PLFL:
26159 B698 D020  30        movb @V,ra                      ; LDA V             ; Set (T P) = V * V
     B69A 0022     
26160 B69C 0206  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; = V^2
     B69E 42BA     
26161 B6A0 06A0  32        bl   @jsr                       ;
     B6A2 FF10     
26162 B6A4 D800  30        movb ra,@T                      ; STA T
     B6A6 00D1     
26163               
26164 B6A8 D020  30        movb @K2,ra                     ; LDA K2            ; Set (R Q) = K^2 - V^2
     B6AA 00AC     
26165                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 B6AC 0A15  18        sla  rmone,1
                   < elite.a99
26166                      .sbc @P,ra                      ; SBC P             ; First calculating the low bytes
     **** ****     > SBC
0001 B6AE 1801  14        joc  !
0002 B6B0 7004  18        sb   rone,ra
0003               !:
0004 B6B2 7020  30        sb   @P,ra
     B6B4 001B     
                   < elite.a99
26167 B6B6 D800  30        movb ra,@Q                      ; STA Q
     B6B8 0090     
26168               
26169 B6BA D020  30        movb @K2+1,ra                   ; LDA K2+1          ; And then doing the high bytes
     B6BC 00AD     
26170                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 B6BE 1801  14        joc  !
0002 B6C0 7004  18        sb   rone,ra
0003               !:
0004 B6C2 7020  30        sb   @T,ra
     B6C4 00D1     
                   < elite.a99
26171 B6C6 D800  30        movb ra,@R                      ; STA R
     B6C8 0091     
26172               
26173 B6CA D802  30        movb ry,@Y1                     ; STY Y1            ; Store Y in Y1, so we can restore it after the call to
     B6CC 0032     
26174                                                                          ; LL5
26175               
26176 B6CE 0206  20        li   rtmp,LL5                   ; JSR LL5           ; Set Q = SQRT(R Q)
     B6D0 D2B6     
26177 B6D2 06A0  32        bl   @jsr                       ;
     B6D4 FF10     
26178                                                                          ; = SQRT(K^2 - V^2)
26179                                                                          ;
26180                                                                          ; So Q contains the half-width of the new sun's line at
26181                                                                          ; height V from the sun's centre - in other words, it
26182                                                                          ; contains the half-width of the sun's line on the
26183                                                                          ; current pixel row Y
26184               
26185 B6D6 D0A0  30        movb @Y1,ry                     ; LDY Y1            ; Restore Y from Y1
     B6D8 0032     
26186               
26187 B6DA 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     B6DC C07C     
26188 B6DE 06A0  32        bl   @jsr                       ;
     B6E0 FF10     
26189               
26190                      .and @CNT                       ; AND CNT           ; Reduce A to a random number in the range 0 to CNT,
     **** ****     > AND
0001 B6E2 D1A0  30        movb @CNT,rtmp
     B6E4 00A4     
0002 B6E6 0546  14        inv  rtmp
0003 B6E8 5006  18        szcb rtmp,ra
                   < elite.a99
26191                                                                          ; where CNT is the fringe size of the new sun
26192               
26193                      .clc                            ; CLC               ; Set A = A + Q
     **** ****     > CLC
0001 B6EA 0A13  18        sla  rzero,1
                   < elite.a99
26194                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 B6EC 1701  14        jnc  !
0002 B6EE B004  18        ab   rone,ra
0003               !:
0004 B6F0 B020  30        ab   @Q,ra
     B6F2 0090     
                   < elite.a99
26195                                                                          ; So A now contains the half-width of the sun on row
26196                                                                          ; V, plus a random variation based on the fringe size
26197               
26198 B6F4 1702  14        jnc  PLF44                      ; BCC PLF44         ; If the above addition did not overflow, skip the
26199                                                                          ; following instruction
26200               
26201 B6F6 0200  20        li   ra,>ff*256                 ; LDA #255          ; The above overflowed, so set the value of A to 255
     B6F8 FF00     
26202               
26203                                                                          ; So A contains the half-width of the new sun on pixel
26204                                                                          ; line Y, changed by a random amount within the size of
26205                                                                          ; the sun's fringe
26206               
26207               PLF44:
26208 B6FA D062  34        movb @LSO(ry),rx                ; LDX LSO,Y         ; Set X to the line heap value for the old sun's line
     B6FC 0D66     
26209                                                                          ; at row Y
26210               
26211 B6FE D880  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; Store the half-width of the new row Y line in the line
     B700 0D66     
26212                                                                          ; heap
26213               
26214 B702 1346  14        jeq  PLF11                      ; BEQ PLF11         ; If X = 0 then there was no sun line on pixel row Y, so
26215                                                                          ; jump to PLF11
26216               
26217 B704 D020  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     B706 0028     
26218 B708 D800  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     B70A 0026     
26219 B70C D020  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     B70E 0029     
26220 B710 D800  30        movb ra,@YY+1                   ; STA YY+1
     B712 0027     
26221               
26222 B714 D001  18        movb rx,ra                      ; TXA               ; Transfer the line heap value for the old sun's line
26223                                                                          ; from X into A
26224               
26225 B716 0206  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     B718 B9B2     
26226 B71A 06A0  32        bl   @jsr                       ;
     B71C FF10     
26227                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26228                                                                          ; the line for the old sun
26229               
26230 B71E D020  30        movb @X1,ra                     ; LDA X1            ; Store X1 and X2, the ends of the line for the old sun,
     B720 0031     
26231 B722 D800  30        movb ra,@XX                     ; STA XX            ; in XX and XX+1
     B724 0024     
26232 B726 D020  30        movb @X2,ra                     ; LDA X2
     B728 0033     
26233 B72A D800  30        movb ra,@XX+1                   ; STA XX+1
     B72C 0025     
26234               
26235 B72E D020  30        movb @K3,ra                     ; LDA K3            ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
     B730 00D2     
26236 B732 D800  30        movb ra,@YY                     ; STA YY            ; of the new sun
     B734 0026     
26237 B736 D020  30        movb @K3+1,ra                   ; LDA K3+1
     B738 00D3     
26238 B73A D800  30        movb ra,@YY+1                   ; STA YY+1
     B73C 0027     
26239               
26240 B73E D022  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the half-width of the new row Y line from the
     B740 0D66     
26241                                                                          ; line heap (which we stored above)
26242               
26243 B742 0206  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     B744 B9B2     
26244 B746 06A0  32        bl   @jsr                       ;
     B748 FF10     
26245                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26246                                                                          ; the line for the new sun
26247               
26248 B74A 180C  14        joc  PLF23                      ; BCS PLF23         ; If the C flag is set, the new line doesn't fit on the
26249                                                                          ; screen, so jump to PLF23 to just draw the old line
26250                                                                          ; without drawing the new one
26251               
26252                                                                          ; At this point the old line is from XX to XX+1 and the
26253                                                                          ; new line is from X1 to X2, and both fit on-screen. We
26254                                                                          ; now want to remove the old line and draw the new one.
26255                                                                          ; We could do this by simply drawing the old one then
26256                                                                          ; drawing the new one, but instead Elite does this by
26257                                                                          ; drawing first from X1 to XX and then from X2 to XX+1,
26258                                                                          ; which you can see in action by looking at all the
26259                                                                          ; permutations below of the four points on the line and
26260                                                                          ; imagining what happens if you draw from X1 to XX and
26261                                                                          ; X2 to XX+1 using EOR logic. The six possible
26262                                                                          ; permutations are as follows, along with the result of
26263                                                                          ; drawing X1 to XX and then X2 to XX+1:
26264                                                                          ;
26265                                                                          ; X1    X2    XX____XX+1      ->      +__+  +  +
26266                                                                          ;
26267                                                                          ; X1    XX____X2____XX+1      ->      +__+__+  +
26268                                                                          ;
26269                                                                          ; X1    XX____XX+1  X2        ->      +__+__+__+
26270                                                                          ;
26271                                                                          ; XX____X1____XX+1  X2        ->      +  +__+__+
26272                                                                          ;
26273                                                                          ; XX____XX+1  X1    X2        ->      +  +  +__+
26274                                                                          ;
26275                                                                          ; XX____X1____X2____XX+1      ->      +  +__+  +
26276                                                                          ;
26277                                                                          ; They all end up with a line between X1 and X2, which
26278                                                                          ; is what we want. There's probably a mathematical proof
26279                                                                          ; of why this works somewhere, but the above is probably
26280                                                                          ; easier to follow.
26281                                                                          ;
26282                                                                          ; We can draw from X1 to XX and X2 to XX+1 by swapping
26283                                                                          ; XX and X2 and drawing from X1 to X2, and then drawing
26284                                                                          ; from XX to XX+1, so let's do this now
26285               
26286 B74C D020  30        movb @X2,ra                     ; LDA X2            ; Swap XX and X2
     B74E 0033     
26287 B750 D060  30        movb @XX,rx                     ; LDX XX
     B752 0024     
26288 B754 D801  30        movb rx,@X2                     ; STX X2
     B756 0033     
26289 B758 D800  30        movb ra,@XX                     ; STA XX
     B75A 0024     
26290               
26291 B75C 0206  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1)
     B75E 25EE     
26292 B760 06A0  32        bl   @jsr                       ;
     B762 FF10     
26293               
26294               PLF23:
26295                                                                          ; If we jump here from the BCS above when there is no
26296                                                                          ; new line this will just draw the old line
26297 B764 D020  30        movb @XX,ra                     ; LDA XX            ; Set X1 = XX
     B766 0024     
26298 B768 D800  30        movb ra,@X1                     ; STA X1
     B76A 0031     
26299               
26300 B76C D020  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X2 = XX+1
     B76E 0025     
26301 B770 D800  30        movb ra,@X2                     ; STA X2
     B772 0033     
26302               
26303               PLF16:
26304 B774 0206  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1)
     B776 25EE     
26305 B778 06A0  32        bl   @jsr                       ;
     B77A FF10     
26306               
26307               PLF6:
26308 B77C 7084  18        sb   rone,ry                    ; DEY               ; Decrement the line number in Y to move to the line
26309                                                                          ; above
26310               
26311 B77E 1334  14        jeq  PLF8                       ; BEQ PLF8          ; If we have reached the top of the screen, jump to PLF8
26312                                                                          ; as we are done drawing (the top line of the screen is
26313                                                                          ; the border, so we don't draw there)
26314               
26315 B780 D020  30        movb @V+1,ra                    ; LDA V+1           ; If V+1 is non-zero then we are doing the top half of
     B782 0023     
26316 B784 1617  14        jne  PLF10                      ; BNE PLF10         ; the new sun, so jump down to PLF10 to increment V and
26317                                                                          ; decrease the width of the line we draw
26318               
26319 B786 7004  18        sb   rone,ra                    ; DEC V             ; Decrement V, the height of the sun that we use to work
26320                                                                          ; out the width, so this makes the line get wider, as we
26321                                                                          ; move up towards the sun's centre
26322               
26323 B788 1687  14        jne  PLFL                       ; BNE PLFL          ; If V is non-zero, jump back up to PLFL to do the next
26324                                                                          ; screen line up
26325               
26326 B78A 7004  18        sb   rone,ra                    ; DEC V+1           ; Otherwise V is 0 and we have reached the centre of the
26327                                                                          ; sun, so decrement V+1 to -1 so we start incrementing V
26328                                                                          ; each time, thus doing the top half of the new sun
26329               
26330               PLFLS:
26331 B78C 0460  28        b    @PLFL                      ; JMP PLFL          ; Jump back up to PLFL to do the next screen line up
     B78E B698     
26332               
26333               PLF11:
26334                                                                          ; If we get here then there is no old sun line on this
26335                                                                          ; line, so we can just draw the new sun's line
26336 B790 D060  30        movb @K3,rx                     ; LDX K3            ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
     B792 00D2     
26337 B794 D801  30        movb rx,@YY                     ; STX YY            ; of the new sun's line
     B796 0026     
26338 B798 D060  30        movb @K3+1,rx                   ; LDX K3+1
     B79A 00D3     
26339 B79C D801  30        movb rx,@YY+1                   ; STX YY+1
     B79E 0027     
26340               
26341 B7A0 0206  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     B7A2 B9B2     
26342 B7A4 06A0  32        bl   @jsr                       ;
     B7A6 FF10     
26343                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26344                                                                          ; the line for the new sun
26345               
26346 B7A8 17E5  14        jnc  PLF16                      ; BCC PLF16         ; If the line is on-screen, jump up to PLF16 to draw the
26347                                                                          ; line and loop round for the next line up
26348               
26349 B7AA 0200  20        li   ra,>00*256                 ; LDA #0            ; The line is not on-screen, so set the line heap for
     B7AC 0000     
26350 B7AE D880  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; line Y to 0, which means there is no sun line here
     B7B0 0D66     
26351               
26352 B7B2 13E4  14        jeq  PLF6                       ; BEQ PLF6          ; Jump up to PLF6 to loop round for the next line up
26353                                                                          ; (this BEQ is effectively a JMP as A is always zero)
26354               
26355               PLF10:
26356 B7B4 D060  30        movb @V,rx                      ; LDX V             ; Increment V, the height of the sun that we use to work
     B7B6 0022     
26357 B7B8 B044  18        ab   rone,rx                    ; INX               ; out the width, so this makes the line get narrower, as
26358 B7BA D801  30        movb rx,@V                      ; STX V             ; we move up and away from the sun's centre
     B7BC 0022     
26359               
26360 B7BE 9060  30        cb   @K,rx                      ; CPX K             ; If V <= the radius of the sun, we still have lines to
     B7C0 003D     
26361 B7C2 17E4  14        jnc  PLFLS                      ; BCC PLFLS         ; draw, so jump up to PLFL (via PLFLS) to do the next
26362 B7C4 13E3  14        jeq  PLFLS                      ; BEQ PLFLS         ; screen line up
26363               
26364               * ******************************************************************************
26365               *
26366               * Name: SUN (Part 4 of 4)
26367               * Type: Subroutine
26368               * Category: Drawing suns
26369               * Summary: Draw the sun: Continue to the top of the screen, erasing the old
26370               * sun line by line
26371               * Deep dive: Drawing the sun
26372               *
26373               * ------------------------------------------------------------------------------
26374               *
26375               * This part erases any remaining traces of the old sun, now that we have drawn
26376               * all the way to the top of the new sun.
26377               *
26378               * ------------------------------------------------------------------------------
26379               *
26380               * Other entry points:
26381               *
26382               * RTS2                Contains an RTS
26383               *
26384               * ******************************************************************************
26385               
26386 B7C6 D020  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     B7C8 0028     
26387 B7CA D800  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     B7CC 0026     
26388 B7CE D020  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     B7D0 0029     
26389 B7D2 D800  30        movb ra,@YY+1                   ; STA YY+1
     B7D4 0027     
26390               
26391               PLFL3:
26392 B7D6 D022  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     B7D8 0D66     
26393                                                                          ; gives us the half-width of the old sun's line on this
26394                                                                          ; line of the screen
26395               
26396 B7DA 1304  14        jeq  PLF9                       ; BEQ PLF9          ; If A = 0, skip the following call to HLOIN2 as there
26397                                                                          ; is no sun line on this line of the screen
26398               
26399 B7DC 0206  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     B7DE 25DA     
26400 B7E0 06A0  32        bl   @jsr                       ;
     B7E2 FF10     
26401                                                                          ; with centre point YY(1 0) and half-width A, and remove
26402                                                                          ; the line from the sun line heap once done
26403               
26404               PLF9:
26405 B7E4 7084  18        sb   rone,ry                    ; DEY               ; Decrement the line number in Y to move to the line
26406                                                                          ; above
26407               
26408 B7E6 16F7  14        jne  PLFL3                      ; BNE PLFL3         ; Jump up to PLFL3 to redraw the next line up, until we
26409                                                                          ; have reached the top of the screen
26410               
26411               PLF8:
26412                                                                          ; If we get here, we have successfully made it from the
26413                                                                          ; bottom line of the screen to the top, and the old sun
26414                                                                          ; has been replaced by the new one
26415                      .clc                            ; CLC               ; Clear the C flag to indicate success in drawing the
     **** ****     > CLC
0001 B7E8 0A13  18        sla  rzero,1
                   < elite.a99
26416                                                                          ; sun
26417               
26418 B7EA D020  30        movb @K3,ra                     ; LDA K3            ; Set SUNX(1 0) = K3(1 0)
     B7EC 00D2     
26419 B7EE D800  30        movb ra,@SUNX                   ; STA SUNX
     B7F0 0028     
26420 B7F2 D020  30        movb @K3+1,ra                   ; LDA K3+1
     B7F4 00D3     
26421 B7F6 D800  30        movb ra,@SUNX+1                 ; STA SUNX+1
     B7F8 0029     
26422               
26423               RTS2:
26424 B7FA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B7FC FF1C     
26425               
26426               * ******************************************************************************
26427               *
26428               * Name: CIRCLE
26429               * Type: Subroutine
26430               * Category: Drawing circles
26431               * Summary: Draw a circle for the planet
26432               * Deep dive: Drawing circles
26433               *
26434               * ------------------------------------------------------------------------------
26435               *
26436               * Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
26437               * planet's main outline.
26438               *
26439               * ------------------------------------------------------------------------------
26440               *
26441               * Arguments:
26442               *
26443               * K                   The planet's radius
26444               *
26445               * K3(1 0)             Pixel x-coordinate of the centre of the planet
26446               *
26447               * K4(1 0)             Pixel y-coordinate of the centre of the planet
26448               *
26449               * ******************************************************************************
26450               
26451               CIRCLE:
26452 B7FE 0206  20        li   rtmp,CHKON                 ; JSR CHKON         ; Call CHKON to check whether the circle fits on-screen
     B800 BA20     
26453 B802 06A0  32        bl   @jsr                       ;
     B804 FF10     
26454               
26455 B806 18F9  14        joc  RTS2                       ; BCS RTS2          ; If CHKON set the C flag then the circle does not fit
26456                                                                          ; on-screen, so return from the subroutine (as RTS2
26457                                                                          ; contains an RTS)
26458               
26459 B808 0200  20        li   ra,>00*256                 ; LDA #0            ; Set LSX2 = 0 to indicate that the ball line heap is
     B80A 0000     
26460 B80C D800  30        movb ra,@LSX2                   ; STA LSX2          ; not empty, as we are about to fill it
     B80E 0E26     
26461               
26462 B810 D060  30        movb @K,rx                      ; LDX K             ; Set X = K = radius
     B812 003D     
26463               
26464 B814 0200  20        li   ra,>08*256                 ; LDA #8            ; Set A = 8
     B816 0800     
26465               
26466 B818 0281  22        ci   rx,>08*256                 ; CPX #8            ; If the radius < 8, skip to PL89
     B81A 0800     
26467 B81C 1705  14        jnc  PL89                       ; BCC PL89
26468               
26469 B81E 0910  18        srl  ra,1                       ; LSR A             ; Halve A so A = 4
26470               
26471 B820 0281  22        ci   rx,>3c*256                 ; CPX #60           ; If the radius < 60, skip to PL89
     B822 3C00     
26472 B824 1701  14        jnc  PL89                       ; BCC PL89
26473               
26474 B826 0910  18        srl  ra,1                       ; LSR A             ; Halve A so A = 2
26475               
26476               PL89:
26477 B828 D800  30        movb ra,@STP                    ; STA STP           ; Set STP = A. STP is the step size for the circle, so
     B82A 00A6     
26478                                                                          ; the above sets a smaller step size for bigger circles
26479               
26480                                                                          ; Fall through into CIRCLE2 to draw the circle with the
26481                                                                          ; correct step size
26482               
26483               * ******************************************************************************
26484               *
26485               * Name: CIRCLE2
26486               * Type: Subroutine
26487               * Category: Drawing circles
26488               * Summary: Draw a circle (for the planet or chart)
26489               * Deep dive: Drawing circles
26490               *
26491               * ------------------------------------------------------------------------------
26492               *
26493               * Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
26494               * planet and the chart circles.
26495               *
26496               * ------------------------------------------------------------------------------
26497               *
26498               * Arguments:
26499               *
26500               * STP                 The step size for the circle
26501               *
26502               * K                   The circle's radius
26503               *
26504               * K3(1 0)             Pixel x-coordinate of the centre of the circle
26505               *
26506               * K4(1 0)             Pixel y-coordinate of the centre of the circle
26507               *
26508               * ------------------------------------------------------------------------------
26509               *
26510               * Returns:
26511               *
26512               * C flag              The C flag is cleared
26513               *
26514               * ******************************************************************************
26515               
26516               CIRCLE2:
26517 B82C 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Set FLAG = &FF to reset the ball line heap in the call
     B82E FF00     
26518 B830 D801  30        movb rx,@FLAG                   ; STX FLAG          ; to the BLINE routine below
     B832 00A3     
26519               
26520 B834 B044  18        ab   rone,rx                    ; INX               ; Set CNT = 0, our counter that goes up to 64, counting
26521 B836 D801  30        movb rx,@CNT                    ; STX CNT           ; segments in our circle
     B838 00A4     
26522               
26523               PLL3:
26524 B83A D020  30        movb @CNT,ra                    ; LDA CNT           ; Set A = CNT
     B83C 00A4     
26525               
26526 B83E 0206  20        li   rtmp,FMLTU2                ; JSR FMLTU2        ; Call FMLTU2 to calculate:
     B840 4326     
26527 B842 06A0  32        bl   @jsr                       ;
     B844 FF10     
26528                                                                          ;
26529                                                                          ; A = K * sin(A)
26530                                                                          ; = K * sin(CNT)
26531               
26532 B846 0201  20        li   rx,>00*256                 ; LDX #0            ; Set T = 0, so we have the following:
     B848 0000     
26533 B84A D801  30        movb rx,@T                      ; STX T             ;
     B84C 00D1     
26534                                                                          ; (T A) = K * sin(CNT)
26535                                                                          ;
26536                                                                          ; which is the x-coordinate of the circle for this count
26537               
26538 B84E D060  30        movb @CNT,rx                    ; LDX CNT           ; If CNT < 33 then jump to PL37, as this is the right
     B850 00A4     
26539 B852 0281  22        ci   rx,>21*256                 ; CPX #33           ; half of the circle and the sign of the x-coordinate is
     B854 2100     
26540 B856 1712  14        jnc  PL37                       ; BCC PL37          ; correct
26541               
26542                      .eoi (>ff*256)                  ; EOR #%11111111    ; This is the left half of the circle, so we want to
     **** ****     > EOI
0001 B858 0206  20        li   rtmp,(>FF*256)
     B85A FF00     
0002 B85C 2806  18        xor  rtmp,ra
                   < elite.a99
26543                      .adi (>00*256)                  ; ADC #0            ; flip the sign of the x-coordinate in (T A) using two's
     **** ****     > ADI
0001 B85E 1701  14        jnc  !
0002 B860 B004  18        ab   rone,ra
0003               !:
0004 B862 0220  22        ai   ra,(>00*256)
     B864 0000     
                   < elite.a99
26544 B866 D040  18        movb ra,rx                      ; TAX               ; complement, so we start with the low byte and store it
26545                                                                          ; in X (the ADC adds 1 as we know the C flag is set)
26546               
26547 B868 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; And then we flip the high byte in T
     B86A FF00     
26548                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 B86C 1701  14        jnc  !
0002 B86E B004  18        ab   rone,ra
0003               !:
0004 B870 0220  22        ai   ra,(>00*256)
     B872 0000     
                   < elite.a99
26549 B874 D800  30        movb ra,@T                      ; STA T
     B876 00D1     
26550               
26551 B878 D001  18        movb rx,ra                      ; TXA               ; Finally, we restore the low byte from X, so we have
26552                                                                          ; now negated the x-coordinate in (T A)
26553               
26554                      .clc                            ; CLC               ; Clear the C flag so we can do some more addition below
     **** ****     > CLC
0001 B87A 0A13  18        sla  rzero,1
                   < elite.a99
26555               
26556               PL37:
26557                      .adc @K3,ra                     ; ADC K3            ; We now calculate the following:
     **** ****     > ADC
0001 B87C 1701  14        jnc  !
0002 B87E B004  18        ab   rone,ra
0003               !:
0004 B880 B020  30        ab   @K3,ra
     B882 00D2     
                   < elite.a99
26558 B884 D800  30        movb ra,@K6                     ; STA K6            ;
     B886 0082     
26559                                                                          ; K6(1 0) = (T A) + K3(1 0)
26560                                                                          ;
26561                                                                          ; to add the coordinates of the centre to our circle
26562                                                                          ; point, starting with the low bytes
26563               
26564 B888 D020  30        movb @K3+1,ra                   ; LDA K3+1          ; And then doing the high bytes, so we now have:
     B88A 00D3     
26565                      .adc @T,ra                      ; ADC T             ;
     **** ****     > ADC
0001 B88C 1701  14        jnc  !
0002 B88E B004  18        ab   rone,ra
0003               !:
0004 B890 B020  30        ab   @T,ra
     B892 00D1     
                   < elite.a99
26566 B894 D800  30        movb ra,@K6+1                   ; STA K6+1          ; K6(1 0) = K * sin(CNT) + K3(1 0)
     B896 0083     
26567                                                                          ;
26568                                                                          ; which is the result we want for the x-coordinate
26569               
26570 B898 D020  30        movb @CNT,ra                    ; LDA CNT           ; Set A = CNT + 16
     B89A 00A4     
26571                      .clc                            ; CLC
     **** ****     > CLC
0001 B89C 0A13  18        sla  rzero,1
                   < elite.a99
26572                      .adi (>10*256)                  ; ADC #16
     **** ****     > ADI
0001 B89E 1701  14        jnc  !
0002 B8A0 B004  18        ab   rone,ra
0003               !:
0004 B8A2 0220  22        ai   ra,(>10*256)
     B8A4 1000     
                   < elite.a99
26573               
26574 B8A6 0206  20        li   rtmp,FMLTU2                ; JSR FMLTU2        ; Call FMLTU2 to calculate:
     B8A8 4326     
26575 B8AA 06A0  32        bl   @jsr                       ;
     B8AC FF10     
26576                                                                          ;
26577                                                                          ; A = K * sin(A)
26578                                                                          ; = K * sin(CNT + 16)
26579                                                                          ; = K * cos(CNT)
26580               
26581 B8AE D040  18        movb ra,rx                      ; TAX               ; Set X = A
26582                                                                          ; = K * cos(CNT)
26583               
26584 B8B0 0200  20        li   ra,>00*256                 ; LDA #0            ; Set T = 0, so we have the following:
     B8B2 0000     
26585 B8B4 D800  30        movb ra,@T                      ; STA T             ;
     B8B6 00D1     
26586                                                                          ; (T X) = K * cos(CNT)
26587                                                                          ;
26588                                                                          ; which is the y-coordinate of the circle for this count
26589               
26590 B8B8 D020  30        movb @CNT,ra                    ; LDA CNT           ; Set A = (CNT + 15) mod 64
     B8BA 00A4     
26591                      .adi (>0f*256)                  ; ADC #15
     **** ****     > ADI
0001 B8BC 1701  14        jnc  !
0002 B8BE B004  18        ab   rone,ra
0003               !:
0004 B8C0 0220  22        ai   ra,(>0F*256)
     B8C2 0F00     
                   < elite.a99
26592 B8C4 0240  22        andi ra,>3f*256                 ; AND #63
     B8C6 3F00     
26593               
26594 B8C8 0280  22        ci   ra,>21*256                 ; CMP #33           ; If A < 33 (i.e. CNT is 0-16 or 48-64) then jump to
     B8CA 2100     
26595 B8CC 1712  14        jnc  PL38                       ; BCC PL38          ; PL38, as this is the bottom half of the circle and the
26596                                                                          ; sign of the y-coordinate is correct
26597               
26598 B8CE D001  18        movb rx,ra                      ; TXA               ; This is the top half of the circle, so we want to
26599                      .eoi (>ff*256)                  ; EOR #%11111111    ; flip the sign of the y-coordinate in (T X) using two's
     **** ****     > EOI
0001 B8D0 0206  20        li   rtmp,(>FF*256)
     B8D2 FF00     
0002 B8D4 2806  18        xor  rtmp,ra
                   < elite.a99
26600                      .adi (>00*256)                  ; ADC #0            ; complement, so we start with the low byte in X (the
     **** ****     > ADI
0001 B8D6 1701  14        jnc  !
0002 B8D8 B004  18        ab   rone,ra
0003               !:
0004 B8DA 0220  22        ai   ra,(>00*256)
     B8DC 0000     
                   < elite.a99
26601 B8DE D040  18        movb ra,rx                      ; TAX               ; ADC adds 1 as we know the C flag is set)
26602               
26603 B8E0 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; And then we flip the high byte in T, so we have
     B8E2 FF00     
26604                      .adi (>00*256)                  ; ADC #0            ; now negated the y-coordinate in (T X)
     **** ****     > ADI
0001 B8E4 1701  14        jnc  !
0002 B8E6 B004  18        ab   rone,ra
0003               !:
0004 B8E8 0220  22        ai   ra,(>00*256)
     B8EA 0000     
                   < elite.a99
26605 B8EC D800  30        movb ra,@T                      ; STA T
     B8EE 00D1     
26606               
26607                      .clc                            ; CLC               ; Clear the C flag so the addition at the start of BLINE
     **** ****     > CLC
0001 B8F0 0A13  18        sla  rzero,1
                   < elite.a99
26608                                                                          ; will work
26609               
26610               PL38:
26611 B8F2 0206  20        li   rtmp,BLINE                 ; JSR BLINE         ; Call BLINE to draw this segment, which also increases
     B8F4 283E     
26612 B8F6 06A0  32        bl   @jsr                       ;
     B8F8 FF10     
26613                                                                          ; CNT by STP, the step size
26614               
26615 B8FA 0280  22        ci   ra,>41*256                 ; CMP #65           ; If CNT >= 65 then skip the next instruction
     B8FC 4100     
26616 B8FE 1802  14        joc  B78                        ; BCS B78
26617               
26618 B900 0460  28        b    @PLL3                      ; JMP PLL3          ; Jump back for the next segment
     B902 B83A     
26619               
26620               B78:
26621                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 B904 0A13  18        sla  rzero,1
                   < elite.a99
26622               
26623 B906 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B908 FF1C     
26624               
26625               * ******************************************************************************
26626               *
26627               * Name: WPLS2
26628               * Type: Subroutine
26629               * Category: Drawing planets
26630               * Summary: Remove the planet from the screen
26631               * Deep dive: The ball line heap
26632               *
26633               * ------------------------------------------------------------------------------
26634               *
26635               * We do this by redrawing it using the lines stored in the ball line heap when
26636               * the planet was originally drawn by the BLINE routine.
26637               *
26638               * ******************************************************************************
26639               
26640               WPLS2:
26641 B90A D0A0  30        movb @LSX2,ry                   ; LDY LSX2          ; If LSX2 is non-zero (which indicates the ball line
     B90C 0E26     
26642 B90E 162C  14        jne  WP1                        ; BNE WP1           ; heap is empty), jump to WP1 to reset the line heap
26643                                                                          ; without redrawing the planet
26644               
26645                                                                          ; Otherwise Y is now 0, so we can use it as a counter to
26646                                                                          ; loop through the lines in the line heap, redrawing
26647                                                                          ; each one to remove the planet from the screen, before
26648                                                                          ; resetting the line heap once we are done
26649               
26650               WPL1:
26651 B910 90A0  30        cb   @LSP,ry                    ; CPY LSP           ; If Y >= LSP then we have reached the end of the line
     B912 0077     
26652 B914 1829  14        joc  WP1                        ; BCS WP1           ; heap and have finished redrawing the planet (as LSP
26653                                                                          ; points to the end of the heap), so jump to WP1 to
26654                                                                          ; reset the line heap, returning from the subroutine
26655                                                                          ; using a tail call
26656               
26657 B916 D022  34        movb @LSY2(ry),ra               ; LDA LSY2,Y        ; Set A to the y-coordinate of the current heap entry
     B918 0E74     
26658               
26659 B91A 0280  22        ci   ra,>ff*256                 ; CMP #&FF          ; If the y-coordinate is &FF, this indicates that the
     B91C FF00     
26660 B91E 1318  14        jeq  WP2                        ; BEQ WP2           ; next point in the heap denotes the start of a line
26661                                                                          ; segment, so jump to WP2 to put it into (X1, Y1)
26662               
26663 B920 D800  30        movb ra,@Y2                     ; STA Y2            ; Set (X2, Y2) to the x- and y-coordinates from the
     B922 0034     
26664 B924 D022  34        movb @LSX2(ry),ra               ; LDA LSX2,Y        ; heap
     B926 0E26     
26665 B928 D800  30        movb ra,@X2                     ; STA X2
     B92A 0033     
26666               
26667 B92C 0206  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2)
     B92E 224E     
26668 B930 06A0  32        bl   @jsr                       ;
     B932 FF10     
26669               
26670 B934 B084  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
26671               
26672 B936 D020  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP is non-zero then we swapped the coordinates
     B938 00A1     
26673 B93A 16EA  14        jne  WPL1                       ; BNE WPL1          ; when filling the heap in BLINE, so loop back WPL1
26674                                                                          ; for the next point in the heap
26675               
26676 B93C D020  30        movb @X2,ra                     ; LDA X2            ; Swap (X1, Y1) and (X2, Y2), so the next segment will
     B93E 0033     
26677 B940 D800  30        movb ra,@X1                     ; STA X1            ; be drawn from the current (X2, Y2) to the next point
     B942 0031     
26678 B944 D020  30        movb @Y2,ra                     ; LDA Y2            ; in the heap
     B946 0034     
26679 B948 D800  30        movb ra,@Y1                     ; STA Y1
     B94A 0032     
26680               
26681 B94C 0460  28        b    @WPL1                      ; JMP WPL1          ; Loop back to WPL1 for the next point in the heap
     B94E B910     
26682               
26683               WP2:
26684 B950 B084  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
26685               
26686 B952 D022  34        movb @LSX2(ry),ra               ; LDA LSX2,Y        ; Set (X1, Y1) to the x- and y-coordinates from the
     B954 0E26     
26687 B956 D800  30        movb ra,@X1                     ; STA X1            ; heap
     B958 0031     
26688 B95A D022  34        movb @LSY2(ry),ra               ; LDA LSY2,Y
     B95C 0E74     
26689 B95E D800  30        movb ra,@Y1                     ; STA Y1
     B960 0032     
26690               
26691 B962 B084  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
26692               
26693 B964 0460  28        b    @WPL1                      ; JMP WPL1          ; Loop back to WPL1 for the next point in the heap
     B966 B910     
26694               
26695               * ******************************************************************************
26696               *
26697               * Name: WP1
26698               * Type: Subroutine
26699               * Category: Drawing planets
26700               * Summary: Reset the ball line heap
26701               *
26702               * ******************************************************************************
26703               
26704               WP1:
26705 B968 0200  20        li   ra,>01*256                 ; LDA #1            ; Set LSP = 1 to reset the ball line heap pointer
     B96A 0100     
26706 B96C D800  30        movb ra,@LSP                    ; STA LSP
     B96E 0077     
26707               
26708 B970 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Set LSX2 = &FF to indicate the ball line heap is empty
     B972 FF00     
26709 B974 D800  30        movb ra,@LSX2                   ; STA LSX2
     B976 0E26     
26710               
26711 B978 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B97A FF1C     
26712               
26713               * ******************************************************************************
26714               *
26715               * Name: WPLS
26716               * Type: Subroutine
26717               * Category: Drawing suns
26718               * Summary: Remove the sun from the screen
26719               * Deep dive: Drawing the sun
26720               *
26721               * ------------------------------------------------------------------------------
26722               *
26723               * We do this by redrawing it using the lines stored in the sun line heap when
26724               * the sun was originally drawn by the SUN routine.
26725               *
26726               * ------------------------------------------------------------------------------
26727               *
26728               * Arguments:
26729               *
26730               * SUNX(1 0)           The x-coordinate of the vertical centre axis of the sun
26731               *
26732               * ------------------------------------------------------------------------------
26733               *
26734               * Other entry points:
26735               *
26736               * WPLS-1              Contains an RTS
26737               *
26738               * ******************************************************************************
26739               
26740               WPLS:
26741 B97C D020  30        movb @LSX,ra                    ; LDA LSX           ; If LSX < 0, the sun line heap is empty, so return from
     B97E 0D66     
26742 B980 11FC  14        jlt  WPLS-1                     ; BMI WPLS-1        ; the subroutine (as WPLS-1 contains an RTS)
26743               
26744 B982 D020  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     B984 0028     
26745 B986 D800  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the sun that's currently on
     B988 0026     
26746 B98A D020  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; screen
     B98C 0029     
26747 B98E D800  30        movb ra,@YY+1                   ; STA YY+1
     B990 0027     
26748               
26749 B992 0202  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     B994 BF00     
26750                                                                          ; view, so this sets Y as a counter for the number of
26751                                                                          ; lines in the space view (i.e. 191), which is also the
26752                                                                          ; number of lines in the LSO block
26753               
26754               WPL2:
26755 B996 D022  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     B998 0D66     
26756                                                                          ; gives us the half-width of the sun's line on this line
26757                                                                          ; of the screen
26758               
26759 B99A 1304  14        jeq  B79                        ; BEQ B79           ; If A = 0, skip the following call to HLOIN2 as there
26760                                                                          ; is no sun line on this line of the screen
26761               
26762 B99C 0206  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     B99E 25DA     
26763 B9A0 06A0  32        bl   @jsr                       ;
     B9A2 FF10     
26764                                                                          ; with centre point YY(1 0) and half-width A, and remove
26765                                                                          ; the line from the sun line heap once done
26766               
26767               B79:
26768 B9A4 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
26769               
26770 B9A6 16F7  14        jne  WPL2                       ; BNE WPL2          ; Loop back for the next line in the line heap until
26771                                                                          ; we have gone through the entire heap
26772               
26773 B9A8 7084  18        sb   rone,ry                    ; DEY               ; This sets Y to &FF, as we end the loop with Y = 0
26774               
26775 B9AA D802  30        movb ry,@LSX                    ; STY LSX           ; Set LSX to &FF to indicate the sun line heap is empty
     B9AC 0D66     
26776               
26777 B9AE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B9B0 FF1C     
26778               
26779               * ******************************************************************************
26780               *
26781               * Name: EDGES
26782               * Type: Subroutine
26783               * Category: Drawing lines
26784               * Summary: Draw a horizontal line given a centre and a half-width
26785               *
26786               * ------------------------------------------------------------------------------
26787               *
26788               * Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
26789               * centre x-coordinate YY(1 0), and length A in either direction from the centre
26790               * (so a total line length of 2 * A). In other words, this line:
26791               *
26792               * X1             YY(1 0)             X2
26793               * +-----------------+-----------------+
26794               * <- A ->           <- A ->
26795               *
26796               * The resulting line gets clipped to the edges of the screen, if needed. If the
26797               * calculation doesn't overflow, we return with the C flag clear, otherwise the C
26798               * flag gets set to indicate failure and the Y-th LSO entry gets set to 0.
26799               *
26800               * ------------------------------------------------------------------------------
26801               *
26802               * Arguments:
26803               *
26804               * A                   The half-length of the line
26805               *
26806               * YY(1 0)             The centre x-coordinate
26807               *
26808               * ------------------------------------------------------------------------------
26809               *
26810               * Returns:
26811               *
26812               * C flag              Clear if the line fits on-screen, set if it doesn't
26813               *
26814               * X1, X2              The x-coordinates of the clipped line
26815               *
26816               * LSO+Y               If the line doesn't fit, LSO+Y is set to 0
26817               *
26818               * Y                   Y is preserved
26819               *
26820               * ******************************************************************************
26821               
26822               EDGES:
26823 B9B2 D800  30        movb ra,@T                      ; STA T             ; Set T to the line's half-length in argument A
     B9B4 00D1     
26824               
26825                      .clc                            ; CLC               ; We now calculate:
     **** ****     > CLC
0001 B9B6 0A13  18        sla  rzero,1
                   < elite.a99
26826                      .adc @YY,ra                     ; ADC YY            ;
     **** ****     > ADC
0001 B9B8 1701  14        jnc  !
0002 B9BA B004  18        ab   rone,ra
0003               !:
0004 B9BC B020  30        ab   @YY,ra
     B9BE 0026     
                   < elite.a99
26827 B9C0 D800  30        movb ra,@X2                     ; STA X2            ; (A X2) = YY(1 0) + A
     B9C2 0033     
26828                                                                          ;
26829                                                                          ; to set X2 to the x-coordinate of the right end of the
26830                                                                          ; line, starting with the low bytes
26831               
26832 B9C4 D020  30        movb @YY+1,ra                   ; LDA YY+1          ; And then adding the high bytes
     B9C6 0027     
26833                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 B9C8 1701  14        jnc  !
0002 B9CA B004  18        ab   rone,ra
0003               !:
0004 B9CC 0220  22        ai   ra,(>00*256)
     B9CE 0000     
                   < elite.a99
26834               
26835 B9D0 1120  14        jlt  ED1                        ; BMI ED1           ; If the addition is negative then the calculation has
26836                                                                          ; overflowed, so jump to ED1 to return a failure
26837               
26838 B9D2 1304  14        jeq  B80                        ; BEQ B80           ; If the high byte A from the result is 0, skip the
26839                                                                          ; next two instructions, as the result already fits on
26840                                                                          ; the screen
26841               
26842 B9D4 0200  20        li   ra,>fe*256                 ; LDA #254          ; The high byte is positive and non-zero, so we went
     B9D6 FE00     
26843 B9D8 D800  30        movb ra,@X2                     ; STA X2            ; past the right edge of the screen, so clip X2 to the
     B9DA 0033     
26844                                                                          ; x-coordinate of the right edge of the screen
26845               
26846               B80:
26847 B9DC D020  30        movb @YY,ra                     ; LDA YY            ; We now calculate:
     B9DE 0026     
26848                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 B9E0 0A15  18        sla  rmone,1
                   < elite.a99
26849                      .sbc @T,ra                      ; SBC T             ; (A X1) = YY(1 0) - argument A
     **** ****     > SBC
0001 B9E2 1801  14        joc  !
0002 B9E4 7004  18        sb   rone,ra
0003               !:
0004 B9E6 7020  30        sb   @T,ra
     B9E8 00D1     
                   < elite.a99
26850 B9EA D800  30        movb ra,@X1                     ; STA X1            ;
     B9EC 0031     
26851                                                                          ; to set X1 to the x-coordinate of the left end of the
26852                                                                          ; line, starting with the low bytes
26853               
26854 B9EE D020  30        movb @YY+1,ra                   ; LDA YY+1          ; And then subtracting the high bytes
     B9F0 0027     
26855                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 B9F2 1801  14        joc  !
0002 B9F4 7004  18        sb   rone,ra
0003               !:
0004 B9F6 0220  22        ai   ra,-(>00*256)
     B9F8 0000     
                   < elite.a99
26856               
26857 B9FA 1603  14        jne  ED3                        ; BNE ED3           ; If the high byte subtraction is non-zero, then skip
26858                                                                          ; to ED3
26859               
26860                      .clc                            ; CLC               ; Otherwise the high byte of the subtraction was zero,
     **** ****     > CLC
0001 B9FC 0A13  18        sla  rzero,1
                   < elite.a99
26861                                                                          ; so the line fits on-screen and we clear the C flag to
26862                                                                          ; indicate success
26863               
26864 B9FE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BA00 FF1C     
26865               
26866               ED3:
26867 BA02 1507  14        jgt  ED1                        ; BPL ED1           ; If the addition is positive then the calculation has
26868                                                                          ; underflowed, so jump to ED1 to return a failure
26869               
26870 BA04 0200  20        li   ra,>02*256                 ; LDA #2            ; The high byte is negative and non-zero, so we went
     BA06 0200     
26871 BA08 D800  30        movb ra,@X1                     ; STA X1            ; past the left edge of the screen, so clip X1 to the
     BA0A 0031     
26872                                                                          ; x-coordinate of the left edge of the screen
26873               
26874                      .clc                            ; CLC               ; The line does fit on-screen, so clear the C flag to
     **** ****     > CLC
0001 BA0C 0A13  18        sla  rzero,1
                   < elite.a99
26875                                                                          ; indicate success
26876               
26877 BA0E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BA10 FF1C     
26878               
26879               ED1:
26880 BA12 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the Y-th byte of the LSO block to 0
     BA14 0000     
26881 BA16 D880  38        movb ra,@LSO(ry)                ; STA LSO,Y
     BA18 0D66     
26882               
26883                      .sec                            ; SEC               ; The line does not fit on the screen, so set the C flag
     **** ****     > SEC
0001 BA1A 0A15  18        sla  rmone,1
                   < elite.a99
26884                                                                          ; to indicate this result
26885               
26886 BA1C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BA1E FF1C     
26887               
26888               * ******************************************************************************
26889               *
26890               * Name: CHKON
26891               * Type: Subroutine
26892               * Category: Drawing circles
26893               * Summary: Check whether any part of a circle appears on the extended screen
26894               *
26895               * ------------------------------------------------------------------------------
26896               *
26897               * Arguments:
26898               *
26899               * K                   The circle's radius
26900               *
26901               * K3(1 0)             Pixel x-coordinate of the centre of the circle
26902               *
26903               * K4(1 0)             Pixel y-coordinate of the centre of the circle
26904               *
26905               * ------------------------------------------------------------------------------
26906               *
26907               * Returns:
26908               *
26909               * C flag              Clear if any part of the circle appears on-screen, set
26910               * if none of the circle appears on-screen
26911               *
26912               * (A X)               Minimum y-coordinate of the circle on-screen (i.e. the
26913               * y-coordinate of the top edge of the circle)
26914               *
26915               * P(2 1)              Maximum y-coordinate of the circle on-screen (i.e. the
26916               * y-coordinate of the bottom edge of the circle)
26917               *
26918               * ******************************************************************************
26919               
26920               CHKON:
26921 BA20 D020  30        movb @K3,ra                     ; LDA K3            ; Set A = K3 + K
     BA22 00D2     
26922                      .clc                            ; CLC
     **** ****     > CLC
0001 BA24 0A13  18        sla  rzero,1
                   < elite.a99
26923                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 BA26 1701  14        jnc  !
0002 BA28 B004  18        ab   rone,ra
0003               !:
0004 BA2A B020  30        ab   @K,ra
     BA2C 003D     
                   < elite.a99
26924               
26925 BA2E D020  30        movb @K3+1,ra                   ; LDA K3+1          ; Set A = K3+1 + 0 + any carry from above, so this
     BA30 00D3     
26926                      .adi (>00*256)                  ; ADC #0            ; effectively sets A to the high byte of K3(1 0) + K:
     **** ****     > ADI
0001 BA32 1701  14        jnc  !
0002 BA34 B004  18        ab   rone,ra
0003               !:
0004 BA36 0220  22        ai   ra,(>00*256)
     BA38 0000     
                   < elite.a99
26927                                                                          ;
26928                                                                          ; (A ?) = K3(1 0) + K
26929                                                                          ;
26930                                                                          ; so A is the high byte of the x-coordinate of the right
26931                                                                          ; edge of the circle
26932               
26933 BA3A 1135  14        jlt  PL21                       ; BMI PL21          ; If A is negative then the right edge of the circle is
26934                                                                          ; to the left of the screen, so jump to PL21 to set the
26935                                                                          ; C flag and return from the subroutine, as the whole
26936                                                                          ; circle is off-screen to the left
26937               
26938 BA3C D020  30        movb @K3,ra                     ; LDA K3            ; Set A = K3 - K
     BA3E 00D2     
26939                      .sec                            ; SEC
     **** ****     > SEC
0001 BA40 0A15  18        sla  rmone,1
                   < elite.a99
26940                      .sbc @K,ra                      ; SBC K
     **** ****     > SBC
0001 BA42 1801  14        joc  !
0002 BA44 7004  18        sb   rone,ra
0003               !:
0004 BA46 7020  30        sb   @K,ra
     BA48 003D     
                   < elite.a99
26941               
26942 BA4A D020  30        movb @K3+1,ra                   ; LDA K3+1          ; Set A = K3+1 - 0 - any carry from above, so this
     BA4C 00D3     
26943                      .sbi (>00*256)                  ; SBC #0            ; effectively sets A to the high byte of K3(1 0) - K:
     **** ****     > SBI
0001 BA4E 1801  14        joc  !
0002 BA50 7004  18        sb   rone,ra
0003               !:
0004 BA52 0220  22        ai   ra,-(>00*256)
     BA54 0000     
                   < elite.a99
26944                                                                          ;
26945                                                                          ; (A ?) = K3(1 0) - K
26946                                                                          ;
26947                                                                          ; so A is the high byte of the x-coordinate of the left
26948                                                                          ; edge of the circle
26949               
26950 BA56 1101  14        jlt  PL31                       ; BMI PL31          ; If A is negative then the left edge of the circle is
26951                                                                          ; to the left of the screen, and we already know the
26952                                                                          ; right edge is either on-screen or off-screen to the
26953                                                                          ; right, so skip to PL31 to move on to the y-coordinate
26954                                                                          ; checks, as at least part of the circle is on-screen in
26955                                                                          ; terms of the x-axis
26956               
26957 BA58 1626  14        jne  PL21                       ; BNE PL21          ; If A is non-zero, then the left edge of the circle is
26958                                                                          ; to the right of the screen, so jump to PL21 to set the
26959                                                                          ; C flag and return from the subroutine, as the whole
26960                                                                          ; circle is off-screen to the right
26961               
26962               PL31:
26963 BA5A D020  30        movb @K4,ra                     ; LDA K4            ; Set P+1 = K4 + K
     BA5C 00E0     
26964                      .clc                            ; CLC
     **** ****     > CLC
0001 BA5E 0A13  18        sla  rzero,1
                   < elite.a99
26965                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 BA60 1701  14        jnc  !
0002 BA62 B004  18        ab   rone,ra
0003               !:
0004 BA64 B020  30        ab   @K,ra
     BA66 003D     
                   < elite.a99
26966 BA68 D800  30        movb ra,@P+1                    ; STA P+1
     BA6A 001C     
26967               
26968 BA6C D020  30        movb @K4+1,ra                   ; LDA K4+1          ; Set A = K4+1 + 0 + any carry from above, so this
     BA6E 00E1     
26969                      .adi (>00*256)                  ; ADC #0            ; does the following:
     **** ****     > ADI
0001 BA70 1701  14        jnc  !
0002 BA72 B004  18        ab   rone,ra
0003               !:
0004 BA74 0220  22        ai   ra,(>00*256)
     BA76 0000     
                   < elite.a99
26970                                                                          ;
26971                                                                          ; (A P+1) = K4(1 0) + K
26972                                                                          ;
26973                                                                          ; so A is the high byte of the y-coordinate of the
26974                                                                          ; bottom edge of the circle
26975               
26976 BA78 1116  14        jlt  PL21                       ; BMI PL21          ; If A is negative then the bottom edge of the circle is
26977                                                                          ; above the top of the screen, so jump to PL21 to set
26978                                                                          ; the C flag and return from the subroutine, as the
26979                                                                          ; whole circle is off-screen to the top
26980               
26981 BA7A D800  30        movb ra,@P+2                    ; STA P+2           ; Store the high byte in P+2, so now we have:
     BA7C 001D     
26982                                                                          ;
26983                                                                          ; P(2 1) = K4(1 0) + K
26984                                                                          ;
26985                                                                          ; i.e. the maximum y-coordinate of the circle on-screen
26986                                                                          ; (which we return)
26987               
26988 BA7E D020  30        movb @K4,ra                     ; LDA K4            ; Set X = K4 - K
     BA80 00E0     
26989                      .sec                            ; SEC
     **** ****     > SEC
0001 BA82 0A15  18        sla  rmone,1
                   < elite.a99
26990                      .sbc @K,ra                      ; SBC K
     **** ****     > SBC
0001 BA84 1801  14        joc  !
0002 BA86 7004  18        sb   rone,ra
0003               !:
0004 BA88 7020  30        sb   @K,ra
     BA8A 003D     
                   < elite.a99
26991 BA8C D040  18        movb ra,rx                      ; TAX
26992               
26993 BA8E D020  30        movb @K4+1,ra                   ; LDA K4+1          ; Set A = K4+1 - 0 - any carry from above, so this
     BA90 00E1     
26994                      .sbi (>00*256)                  ; SBC #0            ; does the following:
     **** ****     > SBI
0001 BA92 1801  14        joc  !
0002 BA94 7004  18        sb   rone,ra
0003               !:
0004 BA96 0220  22        ai   ra,-(>00*256)
     BA98 0000     
                   < elite.a99
26995                                                                          ;
26996                                                                          ; (A X) = K4(1 0) - K
26997                                                                          ;
26998                                                                          ; so A is the high byte of the y-coordinate of the top
26999                                                                          ; edge of the circle
27000               
27001 BA9A 1179  14        jlt  PL44                       ; BMI PL44          ; If A is negative then the top edge of the circle is
27002                                                                          ; above the top of the screen, and we already know the
27003                                                                          ; bottom edge is either on-screen or below the bottom
27004                                                                          ; of the screen, so skip to PL44 to clear the C flag and
27005                                                                          ; return from the subroutine using a tail call, as part
27006                                                                          ; of the circle definitely appears on-screen
27007               
27008 BA9C 1604  14        jne  PL21                       ; BNE PL21          ; If A is non-zero, then the top edge of the circle is
27009                                                                          ; below the bottom of the screen, so jump to PL21 to set
27010                                                                          ; the C flag and return from the subroutine, as the
27011                                                                          ; whole circle is off-screen to the bottom
27012               
27013 BA9E 0281  22        ci   rx,(2*Y-1)*256             ; CPX #2*Y-1        ; If we get here then A is zero, which means the top
     BAA0 BF00     
27014                                                                          ; edge of the circle is within the screen boundary, so
27015                                                                          ; now we need to check whether it is in the space view
27016                                                                          ; (in which case it is on-screen) or the dashboard (in
27017                                                                          ; which case the top of the circle is hidden by the
27018                                                                          ; dashboard, so the circle isn't on-screen). We do this
27019                                                                          ; by checking the low byte of the result in X against
27020                                                                          ; 2 * #Y - 1, and returning the C flag from this
27021                                                                          ; comparison. The constant #Y is the y-coordinate of the
27022                                                                          ; mid-point of the space view, so 2 * #Y - 1, the
27023                                                                          ; y-coordinate of the bottom pixel row of the space
27024                                                                          ; view. So this does the following:
27025                                                                          ;
27026                                                                          ; * The C flag is set if coordinate (A X) is below the
27027                                                                          ; bottom row of the space view, i.e. the top edge of
27028                                                                          ; the circle is hidden by the dashboard
27029                                                                          ;
27030                                                                          ; * The C flag is clear if coordinate (A X) is above
27031                                                                          ; the bottom row of the space view, i.e. the top
27032                                                                          ; edge of the circle is on-screen
27033               
27034 BAA2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BAA4 FF1C     
27035               
27036               * ******************************************************************************
27037               *
27038               * Name: PL21
27039               * Type: Subroutine
27040               * Category: Drawing planets
27041               * Summary: Return from a planet/sun-drawing routine with a failure flag
27042               *
27043               * ------------------------------------------------------------------------------
27044               *
27045               * Set the C flag and return from the subroutine. This is used to return from a
27046               * planet- or sun-drawing routine with the C flag indicating an overflow in the
27047               * calculation.
27048               *
27049               * ******************************************************************************
27050               
27051               PL21:
27052                      .sec                            ; SEC               ; Set the C flag to indicate an overflow
     **** ****     > SEC
0001 BAA6 0A15  18        sla  rmone,1
                   < elite.a99
27053               
27054 BAA8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BAAA FF1C     
27055               
27056               * ******************************************************************************
27057               *
27058               * Name: PLS3
27059               * Type: Subroutine
27060               * Category: Drawing planets
27061               * Summary: Calculate (Y A P) = 222 * roofv_x / z
27062               *
27063               * ------------------------------------------------------------------------------
27064               *
27065               * Calculate the following, with X determining the vector to use:
27066               *
27067               * (Y A P) = 222 * roofv_x / z
27068               *
27069               * though in reality only (Y A) is used.
27070               *
27071               * Although the code below supports a range of values of X, in practice the
27072               * routine is only called with X = 15, and then again after X has been
27073               * incremented to 17. So the values calculated by PLS1 use roofv_x first, then
27074               * roofv_y. The comments below refer to roofv_x, for the first call.
27075               *
27076               * ------------------------------------------------------------------------------
27077               *
27078               * Arguments:
27079               *
27080               * X                   Determines which of the INWK orientation vectors to
27081               * divide:
27082               *
27083               * * X = 15: divides roofv_x
27084               *
27085               * * X = 17: divides roofv_y
27086               *
27087               * ------------------------------------------------------------------------------
27088               *
27089               * Returns:
27090               *
27091               * X                   X gets incremented by 2 so it points to the next
27092               * coordinate in this orientation vector (so consecutive
27093               * calls to the routine will start with x, then move onto y
27094               * and then z)
27095               *
27096               * ******************************************************************************
27097               
27098               PLS3:
27099 BAAC 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     BAAE B3AC     
27100 BAB0 06A0  32        bl   @jsr                       ;
     BAB2 FF10     
27101 BAB4 D800  30        movb ra,@P                      ; STA P             ;
     BAB6 001B     
27102                                                                          ; P = |roofv_x / z|
27103                                                                          ; K+3 = sign of roofv_x / z
27104                                                                          ;
27105                                                                          ; and increment X to point to roofv_y for the next call
27106               
27107 BAB8 0200  20        li   ra,>de*256                 ; LDA #222          ; Set Q = 222, the offset to the crater
     BABA DE00     
27108 BABC D800  30        movb ra,@Q                      ; STA Q
     BABE 0090     
27109               
27110 BAC0 D801  30        movb rx,@U                      ; STX U             ; Store the vector index X in U for retrieval after the
     BAC2 008F     
27111                                                                          ; call to MULTU
27112               
27113 BAC4 0206  20        li   rtmp,MULTU                 ; JSR MULTU         ; Call MULTU to calculate
     BAC6 42DE     
27114 BAC8 06A0  32        bl   @jsr                       ;
     BACA FF10     
27115                                                                          ;
27116                                                                          ; (A P) = P * Q
27117                                                                          ; = 222 * |roofv_x / z|
27118               
27119 BACC D060  30        movb @U,rx                      ; LDX U             ; Restore the vector index from U into X
     BACE 008F     
27120               
27121 BAD0 D0A0  30        movb @K+3,ry                    ; LDY K+3           ; If the sign of the result in K+3 is positive, skip to
     BAD2 0040     
27122 BAD4 150D  14        jgt  PL12                       ; BPL PL12          ; PL12 to return with Y = 0
27123               
27124                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise the result should be negative, so negate the
     **** ****     > EOI
0001 BAD6 0206  20        li   rtmp,(>FF*256)
     BAD8 FF00     
0002 BADA 2806  18        xor  rtmp,ra
                   < elite.a99
27125                      .clc                            ; CLC               ; high byte of the result using two's complement with
     **** ****     > CLC
0001 BADC 0A13  18        sla  rzero,1
                   < elite.a99
27126                      .adi (>01*256)                  ; ADC #1            ; A = ~A + 1
     **** ****     > ADI
0001 BADE 1701  14        jnc  !
0002 BAE0 B004  18        ab   rone,ra
0003               !:
0004 BAE2 0220  22        ai   ra,(>01*256)
     BAE4 0100     
                   < elite.a99
27127               
27128 BAE6 1304  14        jeq  PL12                       ; BEQ PL12          ; If A = 0, jump to PL12 to return with (Y A) = 0
27129               
27130 BAE8 0202  20        li   ry,>ff*256                 ; LDY #&FF          ; Set Y = &FF to be a negative high byte
     BAEA FF00     
27131               
27132 BAEC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BAEE FF1C     
27133               
27134               PL12:
27135 BAF0 0202  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0 to be a positive high byte
     BAF2 0000     
27136               
27137 BAF4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BAF6 FF1C     
27138               
27139               * ******************************************************************************
27140               *
27141               * Name: PLS4
27142               * Type: Subroutine
27143               * Category: Drawing planets
27144               * Summary: Calculate CNT2 = arctan(P / A) / 4
27145               *
27146               * ------------------------------------------------------------------------------
27147               *
27148               * Calculate the following:
27149               *
27150               * CNT2 = arctan(P / A) / 4
27151               *
27152               * and do the following if nosev_z_hi >= 0:
27153               *
27154               * CNT2 = CNT2 + 32
27155               *
27156               * which is the equivalent of adding 180 degrees to the result (or PI radians),
27157               * as there are 64 segments in a full circle.
27158               *
27159               * This routine is called with the following arguments when calculating the
27160               * equator and meridian for planets:
27161               *
27162               * * A = roofv_z_hi, P = -nosev_z_hi
27163               *
27164               * * A = sidev_z_hi, P = -nosev_z_hi
27165               *
27166               * So it calculates the angle between the planet's orientation vectors, in the
27167               * z-axis.
27168               *
27169               * ******************************************************************************
27170               
27171               PLS4:
27172 BAF8 D800  30        movb ra,@Q                      ; STA Q             ; Set Q = A
     BAFA 0090     
27173               
27174 BAFC 0206  20        li   rtmp,ARCTAN                ; JSR ARCTAN        ; Call ARCTAN to calculate:
     BAFE 4776     
27175 BB00 06A0  32        bl   @jsr                       ;
     BB02 FF10     
27176                                                                          ;
27177                                                                          ; A = arctan(P / Q)
27178                                                                          ; arctan(P / A)
27179                                                                          ;
27180                                                                          ; The result in A will be in the range 0 to 128, which
27181                                                                          ; represents an angle of 0 to 180 degrees (or 0 to PI
27182                                                                          ; radians)
27183               
27184 BB04 D060  30        movb @INWK+14,rx                ; LDX INWK+14       ; If nosev_z_hi is negative, skip the following
     BB06 0061     
27185 BB08 1103  14        jlt  B81                        ; BMI B81           ; instruction to leave the angle in A as a positive
27186                                                                          ; integer in the range 0 to 128 (so when we calculate
27187                                                                          ; CNT2 below, it will be in the right half of the
27188                                                                          ; anti-clockwise arc that we describe when drawing
27189                                                                          ; circles, i.e. from 6 o'clock, through 3 o'clock and
27190                                                                          ; on to 12 o'clock)
27191               
27192                      .eoi (>80*256)                  ; EOR #%10000000    ; If we get here then nosev_z_hi is positive, so flip
     **** ****     > EOI
0001 BB0A 0206  20        li   rtmp,(>80*256)
     BB0C 8000     
0002 BB0E 2806  18        xor  rtmp,ra
                   < elite.a99
27193                                                                          ; bit 7 of the angle in A, which is the same as adding
27194                                                                          ; 128 to give a result in the range 129 to 256 (i.e. 129
27195                                                                          ; to 0), or 180 to 360 degrees (so when we calculate
27196                                                                          ; CNT2 below, it will be in the left half of the
27197                                                                          ; anti-clockwise arc that we describe when drawing
27198                                                                          ; circles, i.e. from 12 o'clock, through 9 o'clock and
27199                                                                          ; on to 6 o'clock)
27200               
27201               B81:
27202 BB10 0910  18        srl  ra,1                       ; LSR A             ; Set CNT2 = A / 4
27203 BB12 0910  18        srl  ra,1                       ; LSR A
27204 BB14 D800  30        movb ra,@CNT2                   ; STA CNT2
     BB16 00A5     
27205               
27206 BB18 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BB1A FF1C     
27207               
27208               * ******************************************************************************
27209               *
27210               * Name: PLS5
27211               * Type: Subroutine
27212               * Category: Drawing planets
27213               * Summary: Calculate roofv_x / z and roofv_y / z
27214               *
27215               * ------------------------------------------------------------------------------
27216               *
27217               * Calculate the following divisions of a specified value from one of the
27218               * orientation vectors (in this example, roofv):
27219               *
27220               * (XX16+2 K2+2) = roofv_x / z
27221               *
27222               * (XX16+3 K2+3) = roofv_y / z
27223               *
27224               * ------------------------------------------------------------------------------
27225               *
27226               * Arguments:
27227               *
27228               * X                   Determines which of the INWK orientation vectors to
27229               * divide:
27230               *
27231               * * X = 15: divides roofv_x and roofv_y
27232               *
27233               * * X = 21: divides sidev_x and sidev_y
27234               *
27235               * INWK                The planet's ship data block
27236               *
27237               * ******************************************************************************
27238               
27239               PLS5:
27240 BB1C 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     BB1E B3AC     
27241 BB20 06A0  32        bl   @jsr                       ;
     BB22 FF10     
27242 BB24 D800  30        movb ra,@K2+2                   ; STA K2+2          ;
     BB26 00AE     
27243 BB28 D802  30        movb ry,@XX16+2                 ; STY XX16+2        ; K+2    = |roofv_x / z|
     BB2A 000B     
27244                                                                          ; XX16+2 = sign of roofv_x / z
27245                                                                          ;
27246                                                                          ; i.e. (XX16+2 K2+2) = roofv_x / z
27247                                                                          ;
27248                                                                          ; and increment X to point to roofv_y for the next call
27249               
27250 BB2C 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     BB2E B3AC     
27251 BB30 06A0  32        bl   @jsr                       ;
     BB32 FF10     
27252 BB34 D800  30        movb ra,@K2+3                   ; STA K2+3          ;
     BB36 00AF     
27253 BB38 D802  30        movb ry,@XX16+3                 ; STY XX16+3        ; K+3    = |roofv_y / z|
     BB3A 000C     
27254                                                                          ; XX16+3 = sign of roofv_y / z
27255                                                                          ;
27256                                                                          ; i.e. (XX16+3 K2+3) = roofv_y / z
27257                                                                          ;
27258                                                                          ; and increment X to point to roofv_z for the next call
27259               
27260 BB3C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BB3E FF1C     
27261               
27262               * ******************************************************************************
27263               *
27264               * Name: PLS6
27265               * Type: Subroutine
27266               * Category: Drawing planets
27267               * Summary: Calculate (X K) = (A P+1 P) / (z_sign z_hi z_lo)
27268               *
27269               * ------------------------------------------------------------------------------
27270               *
27271               * Calculate the following:
27272               *
27273               * (X K) = (A P+1 P) / (z_sign z_hi z_lo)
27274               *
27275               * returning an overflow in the C flag if the result is >= 1024.
27276               *
27277               * ------------------------------------------------------------------------------
27278               *
27279               * Arguments:
27280               *
27281               * INWK                The planet or sun's ship data block
27282               *
27283               * ------------------------------------------------------------------------------
27284               *
27285               * Returns:
27286               *
27287               * C flag              Set if the result >= 1024, clear otherwise
27288               *
27289               * ------------------------------------------------------------------------------
27290               *
27291               * Other entry points:
27292               *
27293               * PL44                Clear the C flag and return from the subroutine
27294               *
27295               * ******************************************************************************
27296               
27297               PLS6:
27298 BB40 0206  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     BB42 45E8     
27299 BB44 06A0  32        bl   @jsr                       ;
     BB46 FF10     
27300                                                                          ;
27301                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
27302               
27303 BB48 D020  30        movb @K+3,ra                    ; LDA K+3           ; Set A = |K+3| OR K+2
     BB4A 0040     
27304 BB4C 0240  22        andi ra,>7f*256                 ; AND #%01111111
     BB4E 7F00     
27305 BB50 F020  30        socb @K+2,ra                    ; ORA K+2
     BB52 003F     
27306               
27307 BB54 16A8  14        jne  PL21                       ; BNE PL21          ; If A is non-zero then the two high bytes of K(3 2 1 0)
27308                                                                          ; are non-zero, so jump to PL21 to set the C flag and
27309                                                                          ; return from the subroutine
27310               
27311                                                                          ; We can now just consider K(1 0), as we know the top
27312                                                                          ; two bytes of K(3 2 1 0) are both 0
27313               
27314 BB56 D060  30        movb @K+1,rx                    ; LDX K+1           ; Set X = K+1, so now (X K) contains the result in
     BB58 003E     
27315                                                                          ; K(1 0), which is the format we want to return the
27316                                                                          ; result in
27317               
27318 BB5A 0281  22        ci   rx,>04*256                 ; CPX #4            ; If the high byte of K(1 0) >= 4 then the result is
     BB5C 0400     
27319 BB5E 1818  14        joc  PL6                        ; BCS PL6           ; >= 1024, so return from the subroutine with the C flag
27320                                                                          ; set to indicate an overflow (as PL6 contains an RTS)
27321               
27322 BB60 D020  30        movb @K+3,ra                    ; LDA K+3           ; Fetch the sign of the result from K+3 (which we know
     BB62 0040     
27323                                                                          ; has zeroes in bits 0-6, so this just fetches the sign)
27324               
27325               * CLC                    \ This instruction is commented out in the original
27326                                                                          ; source. It would have no effect as we know the C flag
27327                                                                          ; is already clear, as we skipped past the BCS above
27328               
27329 BB64 1515  14        jgt  PL6                        ; BPL PL6           ; If the sign bit is clear and the result is positive,
27330                                                                          ; then the result is already correct, so return from
27331                                                                          ; the subroutine with the C flag clear to indicate
27332                                                                          ; success (as PL6 contains an RTS)
27333               
27334 BB66 D020  30        movb @K,ra                      ; LDA K             ; Otherwise we need to negate the result, which we do
     BB68 003D     
27335                      .eoi (>ff*256)                  ; EOR #%11111111    ; using two's complement, starting with the low byte:
     **** ****     > EOI
0001 BB6A 0206  20        li   rtmp,(>FF*256)
     BB6C FF00     
0002 BB6E 2806  18        xor  rtmp,ra
                   < elite.a99
27336                      .adi (>01*256)                  ; ADC #1            ;
     **** ****     > ADI
0001 BB70 1701  14        jnc  !
0002 BB72 B004  18        ab   rone,ra
0003               !:
0004 BB74 0220  22        ai   ra,(>01*256)
     BB76 0100     
                   < elite.a99
27337 BB78 D800  30        movb ra,@K                      ; STA K             ; K = ~K + 1
     BB7A 003D     
27338               
27339 BB7C D001  18        movb rx,ra                      ; TXA               ; And then the high byte:
27340                      .eoi (>ff*256)                  ; EOR #%11111111    ;
     **** ****     > EOI
0001 BB7E 0206  20        li   rtmp,(>FF*256)
     BB80 FF00     
0002 BB82 2806  18        xor  rtmp,ra
                   < elite.a99
27341                      .adi (>00*256)                  ; ADC #0            ; X = ~X
     **** ****     > ADI
0001 BB84 1701  14        jnc  !
0002 BB86 B004  18        ab   rone,ra
0003               !:
0004 BB88 0220  22        ai   ra,(>00*256)
     BB8A 0000     
                   < elite.a99
27342 BB8C D040  18        movb ra,rx                      ; TAX
27343               
27344               PL44:
27345                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 BB8E 0A13  18        sla  rzero,1
                   < elite.a99
27346               
27347               PL6:
27348 BB90 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BB92 FF1C     
27349               
27350               * ******************************************************************************
27351               *
27352               * Name: TT17
27353               * Type: Subroutine
27354               * Category: Keyboard
27355               * Summary: Scan the keyboard for cursor key or joystick movement
27356               *
27357               * ------------------------------------------------------------------------------
27358               *
27359               * Scan the keyboard and joystick for cursor key or stick movement, and return
27360               * the result as deltas (changes) in x- and y-coordinates as follows:
27361               *
27362               * * For joystick, X and Y are integers between -2 and +2 depending on how far
27363               * the stick has moved
27364               *
27365               * * For keyboard, X and Y are integers between -1 and +1 depending on which
27366               * keys are pressed
27367               *
27368               * ------------------------------------------------------------------------------
27369               *
27370               * Returns:
27371               *
27372               * A                   The key pressed, if the arrow keys were used
27373               *
27374               * X                   Change in the x-coordinate according to the cursor keys
27375               * being pressed or joystick movement, as an integer (see
27376               * above)
27377               *
27378               * Y                   Change in the y-coordinate according to the cursor keys
27379               * being pressed or joystick movement, as an integer (see
27380               * above)
27381               *
27382               * ******************************************************************************
27383               
27384               TT17:
27385 BB94 0206  20        li   rtmp,DOKEY                 ; JSR DOKEY         ; Scan the keyboard for flight controls and pause keys,
     BB96 CD0A     
27386 BB98 06A0  32        bl   @jsr                       ;
     BB9A FF10     
27387                                                                          ; (or the equivalent on joystick) and update the key
27388                                                                          ; logger, setting KL to the key pressed
27389               
27390 BB9C D020  30        movb @JSTK,ra                   ; LDA JSTK          ; If the joystick is not configured, jump down to TJ1,
     BB9E 0F50     
27391 BBA0 132D  14        jeq  TJ1                        ; BEQ TJ1           ; otherwise we move the cursor with the joystick
27392               
27393 BBA2 D020  30        movb @JSTX,ra                   ; LDA JSTX          ; Fetch the joystick roll, ranging from 1 to 255 with
     BBA4 009C     
27394                                                                          ; 128 as the centre point
27395               
27396                      .eoi (>ff*256)                  ; EOR #&FF          ; Flip the sign so A = -JSTX, because the joystick roll
     **** ****     > EOI
0001 BBA6 0206  20        li   rtmp,(>FF*256)
     BBA8 FF00     
0002 BBAA 2806  18        xor  rtmp,ra
                   < elite.a99
27397                                                                          ; works in the opposite way to moving a cursor on-screen
27398                                                                          ; in terms of left and right
27399               
27400 BBAC 0206  20        li   rtmp,TJS1                  ; JSR TJS1          ; Call TJS1 just below to set A to a value between -2
     BBAE BBBC     
27401 BBB0 06A0  32        bl   @jsr                       ;
     BBB2 FF10     
27402                                                                          ; and +2 depending on the joystick roll value (moving
27403                                                                          ; the stick sideways)
27404               
27405 BBB4 D002  18        movb ry,ra                      ; TYA               ; Copy Y to A
27406               
27407 BBB6 D040  18        movb ra,rx                      ; TAX               ; Copy A to X, so X contains the joystick roll value
27408               
27409 BBB8 D020  30        movb @JSTY,ra                   ; LDA JSTY          ; Fetch the joystick pitch, ranging from 1 to 255 with
     BBBA 009D     
27410                                                                          ; 128 as the centre point, and fall through into TJS1 to
27411                                                                          ; set Y to the joystick pitch value (moving the stick up
27412                                                                          ; and down)
27413               
27414               TJS1:
27415 BBBC D080  18        movb ra,ry                      ; TAY               ; Store A in Y
27416               
27417 BBBE 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the result, A = 0
     BBC0 0000     
27418               
27419 BBC2 0282  22        ci   ry,>10*256                 ; CPY #16           ; If Y >= 16 set the C flag, so A = A - 1
     BBC4 1000     
27420                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 BBC6 1801  14        joc  !
0002 BBC8 7004  18        sb   rone,ra
0003               !:
0004 BBCA 0220  22        ai   ra,-(>00*256)
     BBCC 0000     
                   < elite.a99
27421               
27422               * CPY #&20               \ These instructions are commented out in the original
27423               * SBC #0                 \ source, but they would make the joystick move the
27424                                                                          ; cursor faster by increasing the range of Y by -1 to +1
27425               
27426 BBCE 0282  22        ci   ry,>40*256                 ; CPY #64           ; If Y >= 64 set the C flag, so A = A - 1
     BBD0 4000     
27427                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 BBD2 1801  14        joc  !
0002 BBD4 7004  18        sb   rone,ra
0003               !:
0004 BBD6 0220  22        ai   ra,-(>00*256)
     BBD8 0000     
                   < elite.a99
27428               
27429 BBDA 0282  22        ci   ry,>c0*256                 ; CPY #192          ; If Y >= 192 set the C flag, so A = A + 1
     BBDC C000     
27430                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 BBDE 1701  14        jnc  !
0002 BBE0 B004  18        ab   rone,ra
0003               !:
0004 BBE2 0220  22        ai   ra,(>00*256)
     BBE4 0000     
                   < elite.a99
27431               
27432 BBE6 0282  22        ci   ry,>e0*256                 ; CPY #224          ; If Y >= 224 set the C flag, so A = A + 1
     BBE8 E000     
27433                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 BBEA 1701  14        jnc  !
0002 BBEC B004  18        ab   rone,ra
0003               !:
0004 BBEE 0220  22        ai   ra,(>00*256)
     BBF0 0000     
                   < elite.a99
27434               
27435               * CPY #&F0               \ These instructions are commented out in the original
27436               * ADC #0                 \ source, but they would make the joystick move the
27437                                                                          ; cursor faster by increasing the range of Y by -1 to +1
27438               
27439 BBF2 D080  18        movb ra,ry                      ; TAY               ; Copy the value of A into Y
27440               
27441 BBF4 D020  30        movb @KL,ra                     ; LDA KL            ; Set A to the value of KL (the key pressed)
     BBF6 0041     
27442               
27443 BBF8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BBFA FF1C     
27444               
27445               TJ1:
27446 BBFC D020  30        movb @KL,ra                     ; LDA KL            ; Set A to the value of KL (the key pressed)
     BBFE 0041     
27447               
27448 BC00 0201  20        li   rx,>00*256                 ; LDX #0            ; Set the initial values for the results, X = Y = 0,
     BC02 0000     
27449 BC04 0202  20        li   ry,>00*256                 ; LDY #0            ; which we now increase or decrease appropriately
     BC06 0000     
27450               
27451 BC08 0280  22        ci   ra,>19*256                 ; CMP #&19          ; If left arrow was pressed, set X = X - 1
     BC0A 1900     
27452 BC0C 1601  14        jne  B82                        ; BNE B82
27453 BC0E 7044  18        sb   rone,rx                    ; DEX
27454               
27455               B82:
27456 BC10 0280  22        ci   ra,>79*256                 ; CMP #&79          ; If right arrow was pressed, set X = X + 1
     BC12 7900     
27457 BC14 1601  14        jne  B83                        ; BNE B83
27458 BC16 B044  18        ab   rone,rx                    ; INX
27459               
27460               B83:
27461 BC18 0280  22        ci   ra,>39*256                 ; CMP #&39          ; If up arrow was pressed, set Y = Y + 1
     BC1A 3900     
27462 BC1C 1601  14        jne  B84                        ; BNE B84
27463 BC1E B084  18        ab   rone,ry                    ; INY
27464               
27465               B84:
27466 BC20 0280  22        ci   ra,>29*256                 ; CMP #&29          ; If down arrow was pressed, set Y = Y - 1
     BC22 2900     
27467 BC24 1601  14        jne  B85                        ; BNE B85
27468 BC26 7084  18        sb   rone,ry                    ; DEY
27469               
27470               B85:
27471 BC28 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BC2A FF1C     
27472               
27473               * ******************************************************************************
27474               *
27475               * Name: ping
27476               * Type: Subroutine
27477               * Category: Universe
27478               * Summary: Set the selected system to the current system
27479               *
27480               * ******************************************************************************
27481               
27482               ping_:
27483 BC2C 0201  20        li   rx,>01*256                 ; LDX #1            ; We want to copy the X- and Y-coordinates of the
     BC2E 0100     
27484                                                                          ; current system in (QQ0, QQ1) to the selected system's
27485                                                                          ; coordinates in (QQ9, QQ10), so set up a counter to
27486                                                                          ; copy two bytes
27487               
27488               pl1_:
27489 BC30 D021  34        movb @QQ0(rx),ra                ; LDA QQ0,X         ; Load byte X from the current system in QQ0/QQ1
     BC32 0301     
27490               
27491 BC34 D840  38        movb ra,@QQ9(rx)                ; STA QQ9,X         ; Store byte X in the selected system in QQ9/QQ10
     BC36 0F31     
27492               
27493 BC38 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
27494               
27495 BC3A 15FA  14        jgt  pl1_                       ; BPL pl1           ; Loop back for the next byte to copy
27496               
27497 BC3C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BC3E FF1C     
27498               
27499               * ******************************************************************************
27500               *
27501               * Save ELTE.bin
27502               *
27503               * ******************************************************************************
27504               
27505                      ; PRINT "ELITE E"
27506                      ; PRINT "Assembled at ", ~CODE_E%
27507                      ; PRINT "Ends at ", ~P%
27508                      ; PRINT "Code size is ", ~(P% - CODE_E%)
27509                      ; PRINT "Execute at ", ~LOAD%
27510                      ; PRINT "Reload at ", ~LOAD_E%
27511               
27512                      ; PRINT "S.ELTE ", ~CODE_E%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_E%
27513                      ; SAVE "3-assembled-output/ELTE.bin", CODE_E%, P%, LOAD%
27514               
27515               * ******************************************************************************
27516               *
27517               * ELITE F FILE
27518               *
27519               * Produces the binary file ELTF.bin that gets loaded by elite-bcfs.asm.
27520               *
27521               * ******************************************************************************
27522               
27523               CODE_F.:
27524                      equ $
27525               
27526               LOAD_F.:
27527                      equ LOAD. + $ - CODE.
27528               
27529               * ******************************************************************************
27530               *
27531               * Name: KS3
27532               * Type: Subroutine
27533               * Category: Universe
27534               * Summary: Set the SLSP ship line heap pointer after shuffling ship slots
27535               *
27536               * ------------------------------------------------------------------------------
27537               *
27538               * The final part of the KILLSHP routine, called after we have shuffled the ship
27539               * slots and sorted out our missiles. This simply sets SLSP to the new bottom of
27540               * the ship line heap.
27541               *
27542               * ------------------------------------------------------------------------------
27543               *
27544               * Arguments:
27545               *
27546               * P(1 0)              Points to the ship line heap of the ship in the last
27547               * occupied slot (i.e. it points to the bottom of the
27548               * descending heap)
27549               *
27550               * ******************************************************************************
27551               
27552               KS3:
27553 BC40 D020  30        movb @P,ra                      ; LDA P             ; After shuffling the ship slots, P(1 0) will point to
     BC42 001B     
27554 BC44 D800  30        movb ra,@SLSP                   ; STA SLSP          ; the new bottom of the ship line heap, so store this in
     BC46 0F1E     
27555 BC48 D020  30        movb @P+1,ra                    ; LDA P+1           ; SLSP(1 0), which stores the bottom of the heap
     BC4A 001C     
27556 BC4C D800  30        movb ra,@SLSP+1                 ; STA SLSP+1
     BC4E 0F1F     
27557               
27558 BC50 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BC52 FF1C     
27559               
27560               * ******************************************************************************
27561               *
27562               * Name: KS1
27563               * Type: Subroutine
27564               * Category: Universe
27565               * Summary: Remove the current ship from our local bubble of universe
27566               *
27567               * ------------------------------------------------------------------------------
27568               *
27569               * Part 12 of the main flight loop calls this routine to remove the ship that is
27570               * currently being analysed by the flight loop. Once the ship is removed, it
27571               * jumps back to MAL1 to rejoin the main flight loop, with X pointing to the
27572               * same slot that we just cleared (and which now contains the next ship in the
27573               * local bubble of universe).
27574               *
27575               * ------------------------------------------------------------------------------
27576               *
27577               * Arguments:
27578               *
27579               * XX0                 The address of the blueprint for this ship
27580               *
27581               * INF                 The address of the data block for this ship
27582               *
27583               * ******************************************************************************
27584               
27585               KS1:
27586 BC54 D060  30        movb @XSAV,rx                   ; LDX XSAV          ; Store the current ship's slot number in XSAV
     BC56 0093     
27587               
27588 BC58 0206  20        li   rtmp,KILLSHP               ; JSR KILLSHP       ; Call KILLSHP to remove the ship in slot X from our
     BC5A BD1C     
27589 BC5C 06A0  32        bl   @jsr                       ;
     BC5E FF10     
27590                                                                          ; local bubble of universe
27591               
27592 BC60 D060  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the current ship's slot number from XSAV,
     BC62 0093     
27593                                                                          ; which now points to the next ship in the bubble
27594               
27595 BC64 0460  24        b    @MAL1                      ; JMP MAL1          ; Jump to MAL1 to rejoin the main flight loop at the
     BC66 118C     
27596                                                                          ; start of the ship analysis loop
27597               
27598               * ******************************************************************************
27599               *
27600               * Name: KS4
27601               * Type: Subroutine
27602               * Category: Universe
27603               * Summary: Remove the space station and replace it with the sun
27604               *
27605               * ******************************************************************************
27606               
27607               KS4:
27608 BC68 0206  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     BC6A BFC0     
27609 BC6C 06A0  32        bl   @jsr                       ;
     BC6E FF10     
27610               
27611 BC70 0206  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Reset the LSO block, returns with A = 0
     BC72 ACA6     
27612 BC74 06A0  32        bl   @jsr                       ;
     BC76 FF10     
27613               
27614 BC78 D800  30        movb ra,@FRIN+1                 ; STA FRIN+1        ; Set the second slot in the FRIN table to 0, which
     BC7A 0D41     
27615                                                                          ; sets this slot to empty, so when we call NWSHP below
27616                                                                          ; the new sun that gets created will go into FRIN+1
27617               
27618 BC7C D800  30        movb ra,@SSPR                   ; STA SSPR          ; Set the "space station present" flag to 0, as we are
     BC7E 0D55     
27619                                                                          ; no longer in the space station's safe zone
27620               
27621 BC80 0206  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Call SPBLB to redraw the space station bulb, which
     BC82 B0E2     
27622 BC84 06A0  32        bl   @jsr                       ;
     BC86 FF10     
27623                                                                          ; will erase it from the dashboard
27624               
27625 BC88 0200  20        li   ra,>06*256                 ; LDA #6            ; Set the sun's y_sign to 6
     BC8A 0600     
27626 BC8C D800  30        movb ra,@INWK+5                 ; STA INWK+5
     BC8E 0058     
27627               
27628 BC90 0200  20        li   ra,>81*256                 ; LDA #129          ; Set A = 129, the ship type for the sun
     BC92 8100     
27629               
27630 BC94 0460  28        b    @NWSHP                     ; JMP NWSHP         ; Call NWSHP to set up the sun's data block and add it
     BC96 AF7A     
27631                                                                          ; to FRIN, where it will get put in the second slot as
27632                                                                          ; we just cleared out the second slot, and the first
27633                                                                          ; slot is already taken by the planet
27634               
27635               * ******************************************************************************
27636               *
27637               * Name: KS2
27638               * Type: Subroutine
27639               * Category: Universe
27640               * Summary: Check the local bubble for missiles with target lock
27641               *
27642               * ------------------------------------------------------------------------------
27643               *
27644               * Check the local bubble of universe to see if there are any missiles with
27645               * target lock in the vicinity. If there are, then check their targets; if we
27646               * just removed their target in the KILLSHP routine, then switch off their AI so
27647               * they just drift in space, otherwise update their targets to reflect the newly
27648               * shuffled slot numbers.
27649               *
27650               * This is called from KILLSHP once the slots have been shuffled down, following
27651               * the removal of a ship.
27652               *
27653               * ------------------------------------------------------------------------------
27654               *
27655               * Arguments:
27656               *
27657               * XX4                 The slot number of the ship we removed just before
27658               * calling this routine
27659               *
27660               * ******************************************************************************
27661               
27662               KS2:
27663 BC98 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; We want to go through the ships in our local bubble
     BC9A FF00     
27664                                                                          ; and pick out all the missiles, so set X to &FF to
27665                                                                          ; use as a counter
27666               
27667               KSL4:
27668 BC9C B044  18        ab   rone,rx                    ; INX               ; Increment the counter (so it starts at 0 on the first
27669                                                                          ; iteration)
27670               
27671 BC9E D021  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; If slot X is empty then we have worked our way through
     BCA0 0D40     
27672 BCA2 13CE  14        jeq  KS3                        ; BEQ KS3           ; all the slots, so jump to KS3 to stop looking
27673               
27674 BCA4 0280  22        ci   ra,(MSL)*256               ; CMP #MSL          ; If the slot does not contain a missile, loop back to
     BCA6 0900     
27675 BCA8 16F9  14        jne  KSL4                       ; BNE KSL4          ; KSL4 to check the next slot
27676               
27677                                                                          ; We have found a slot containing a missile, so now we
27678                                                                          ; want to check whether it has target lock
27679               
27680 BCAA D001  18        movb rx,ra                      ; TXA               ; Set Y = X * 2 and fetch the Y-th address from UNIV
27681                      .asla                           ; ASL A             ; and store it in SC and SC+1 - in other words, set
     **** ****     > ASLA
0001 BCAC 0240  22        andi ra,>ff00
     BCAE FF00     
0002 BCB0 0A10  18        sla  ra,1
                   < elite.a99
27682 BCB2 D080  18        movb ra,ry                      ; TAY               ; SC(1 0) to point to the missile's ship data block
27683 BCB4 D022  34        movb @UNIV(ry),ra               ; LDA UNIV,Y
     BCB6 221F     
27684 BCB8 D800  30        movb ra,@SC                     ; STA SC
     BCBA 0007     
27685 BCBC D022  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y
     BCBE 2220     
27686 BCC0 D800  30        movb ra,@SC+1                   ; STA SC+1
     BCC2 0008     
27687               
27688 BCC4 0202  20        li   ry,>20*256                 ; LDY #32           ; Fetch byte #32 from the missile's ship data (AI)
     BCC6 2000     
27689                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y
     **** ****     > LD_IND_Y_IDX
0001 BCC8 D820  50        movb @SC,@rtmplb
     BCCA 0007     
     BCCC 2079     
0002 BCCE D1A0  30        movb @SC+1,rtmp
     BCD0 0008     
0003 BCD2 A182  18        a    ry,rtmp
0004 BCD4 D016  26        movb *rtmp,RA
                   < elite.a99
27690               
27691 BCD6 15E2  14        jgt  KSL4                       ; BPL KSL4          ; If bit 7 of byte #32 is clear, then the missile is
27692                                                                          ; dumb and has no AI, so loop back to KSL4 to move on
27693                                                                          ; to the next slot
27694               
27695 BCD8 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Otherwise this missile has AI, so clear bit 7 and
     BCDA 7F00     
27696 BCDC 0910  18        srl  ra,1                       ; LSR A             ; shift right to set the C flag to the missile's "is
27697                                                                          ; locked" flag, and A to the target's slot number
27698               
27699 BCDE 9020  30        cb   @XX4,ra                    ; CMP XX4           ; If this missile's target is less than XX4, then the
     BCE0 00A7     
27700 BCE2 17DC  14        jnc  KSL4                       ; BCC KSL4          ; target's slot isn't being shuffled down, so jump to
27701                                                                          ; KSL4 to move on to the next slot
27702               
27703 BCE4 1311  14        jeq  KS6                        ; BEQ KS6           ; If this missile was locked onto the ship that we just
27704                                                                          ; removed in KILLSHP, jump to KS6 to stop the missile
27705                                                                          ; from continuing to hunt it down
27706               
27707                      .sbi (>01*256)                  ; SBC #1            ; Otherwise this missile is locked and has AI enabled,
     **** ****     > SBI
0001 BCE6 1801  14        joc  !
0002 BCE8 7004  18        sb   rone,ra
0003               !:
0004 BCEA 0220  22        ai   ra,-(>01*256)
     BCEC FF00     
                   < elite.a99
27708                                                                          ; and its target will have moved down a slot, so
27709                                                                          ; subtract 1 from the target number (we know C is set
27710                                                                          ; from the BCC above)
27711               
27712                      .asla                           ; ASL A             ; Shift the target number left by 1, so it's in bits
     **** ****     > ASLA
0001 BCEE 0240  22        andi ra,>ff00
     BCF0 FF00     
0002 BCF2 0A10  18        sla  ra,1
                   < elite.a99
27713                                                                          ; 1-6 once again, and also set bit 0 to 1, as the C
27714                                                                          ; flag is still set, so this makes sure the missile is
27715                                                                          ; still set to being locked
27716               
27717 BCF4 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7, so the missile's AI is enabled
     BCF6 8000     
27718               
27719                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Update the missile's AI flag to the value in A
     **** ****     > ST_IND_Y_IDX
0001 BCF8 D820  50        movb @SC,@rtmplb
     BCFA 0007     
     BCFC 2079     
0002 BCFE D1A0  30        movb @SC+1,rtmp
     BD00 0008     
0003 BD02 A182  18        a    ry,rtmp
0004 BD04 D580  30        movb RA,*rtmp
                   < elite.a99
27720               
27721 BD06 16CA  14        jne  KSL4                       ; BNE KSL4          ; Loop back to KSL4 to move on to the next slot (this
27722                                                                          ; BNE is effectively a JMP as A will never be zero)
27723               
27724               KS6:
27725 BD08 0200  20        li   ra,>00*256                 ; LDA #0            ; The missile's target lock just got removed, so set the
     BD0A 0000     
27726                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; AI flag to 0 to make it dumb and not locked
     **** ****     > ST_IND_Y_IDX
0001 BD0C D820  50        movb @SC,@rtmplb
     BD0E 0007     
     BD10 2079     
0002 BD12 D1A0  30        movb @SC+1,rtmp
     BD14 0008     
0003 BD16 A182  18        a    ry,rtmp
0004 BD18 D580  30        movb RA,*rtmp
                   < elite.a99
27727               
27728 BD1A 13C0  14        jeq  KSL4                       ; BEQ KSL4          ; Loop back to KSL4 to move on to the next slot (this
27729                                                                          ; BEQ is effectively a JMP as A is always zero)
27730               
27731               * ******************************************************************************
27732               *
27733               * Name: KILLSHP
27734               * Type: Subroutine
27735               * Category: Universe
27736               * Summary: Remove a ship from our local bubble of universe
27737               *
27738               * ------------------------------------------------------------------------------
27739               *
27740               * Remove the ship in slot X from our local bubble of universe. This happens
27741               * when we kill a ship, collide with a ship and destroy it, or when a ship moves
27742               * outside our local bubble.
27743               *
27744               * We also use this routine when we move out of range of the space station, in
27745               * which case we replace it with the sun.
27746               *
27747               * When removing a ship, this creates a gap in the ship slots at FRIN, so we
27748               * shuffle all the later slots down to close the gap. We also shuffle the ship
27749               * data blocks at K% and ship line heap at WP, to reclaim all the memory that
27750               * the removed ship used to occupy.
27751               *
27752               * ------------------------------------------------------------------------------
27753               *
27754               * Arguments:
27755               *
27756               * X                   The slot number of the ship to remove
27757               *
27758               * XX0                 The address of the blueprint for the ship to remove
27759               *
27760               * INF                 The address of the data block for the ship to remove
27761               *
27762               * ******************************************************************************
27763               
27764               KILLSHP:
27765 BD1C D801  30        movb rx,@XX4                    ; STX XX4           ; Store the slot number of the ship to remove in XX4
     BD1E 00A7     
27766               
27773               
27774 BD20 9060  30        cb   @MSTG,rx                   ; CPX MSTG          ; Check whether this slot matches the slot number in
     BD22 0052     
27775                                                                          ; MSTG, which is the target of our missile lock
27776                                                                          ;
27777                                                                          ; This instructions saves two bytes of memory over the
27778                                                                          ; LDA and CMP-based code in the source disc version, as
27779                                                                          ; CPX MSTG is a two-byte opcode, while LDA MSTG and
27780                                                                          ; CMP XX4 take up four bytes between them (the code does
27781                                                                          ; the same thing)
27782               
27784               
27785 BD24 160C  14        jne  KS5                        ; BNE KS5           ; If our missile is not locked on this ship, jump to KS5
27786               
27787 BD26 0202  20        li   ry,>ee*256                 ; LDY #&EE          ; Otherwise we need to remove our missile lock, so call
     BD28 EE00     
27788 BD2A 0206  20        li   rtmp,ABORT                 ; JSR ABORT         ; ABORT to disarm the missile and update the missile
     BD2C B0A2     
27789 BD2E 06A0  32        bl   @jsr                       ;
     BD30 FF10     
27790                                                                          ; indicators on the dashboard to green/cyan (Y = &EE)
27791               
27792 BD32 0200  20        li   ra,>c8*256                 ; LDA #200          ; Print recursive token 40 ("TARGET LOST") as an
     BD34 C800     
27793 BD36 0206  20        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     BD38 CE5E     
27794 BD3A 06A0  32        bl   @jsr                       ;
     BD3C FF10     
27795               
27796               KS5:
27797 BD3E D0A0  30        movb @XX4,ry                    ; LDY XX4           ; Restore the slot number of the ship to remove into Y
     BD40 00A7     
27798               
27799 BD42 D062  34        movb @FRIN(ry),rx               ; LDX FRIN,Y        ; Fetch the contents of the slot, which contains the
     BD44 0D40     
27800                                                                          ; ship type
27801               
27802 BD46 0281  22        ci   rx,(SST)*256               ; CPX #SST          ; If this is the space station, then jump to KS4 to
     BD48 0800     
27803 BD4A 138E  14        jeq  KS4                        ; BEQ KS4           ; replace the space station with the sun
27804               
27805 BD4C 7004  18        sb   rone,ra                    ; DEC MANY,X        ; Decrease the number of this type of ship in our little
27806                                                                          ; bubble, which is stored in MANY+X (where X is the ship
27807                                                                          ; type)
27808               
27809 BD4E D060  30        movb @XX4,rx                    ; LDX XX4           ; Restore the slot number of the ship to remove into X
     BD50 00A7     
27810               
27811                                                                          ; We now want to remove this ship and reclaim all the
27812                                                                          ; memory that it uses. Removing the ship will leave a
27813                                                                          ; gap in three places, which we need to close up:
27814                                                                          ;
27815                                                                          ; * The ship slots in FRIN
27816                                                                          ;
27817                                                                          ; * The ship data blocks in K%
27818                                                                          ;
27819                                                                          ; * The descending ship line heap at WP down
27820                                                                          ;
27821                                                                          ; The rest of this routine closes up these gaps by
27822                                                                          ; looping through all the occupied ship slots after the
27823                                                                          ; slot we are removing, one by one, and shuffling each
27824                                                                          ; ship's slot, data block and line heap down to close
27825                                                                          ; up the gaps left by the removed ship. As part of this,
27826                                                                          ; we have to make sure we update any address pointers
27827                                                                          ; so they point to the newly shuffled data blocks and
27828                                                                          ; line heaps
27829                                                                          ;
27830                                                                          ; In the following, when shuffling a ship's data down
27831                                                                          ; into the preceding empty slot, we call the ship that
27832                                                                          ; we are shuffling down the "source", and we call the
27833                                                                          ; empty slot we are shuffling it into the "destination"
27834                                                                          ;
27835                                                                          ; Before we start looping through the ships we need to
27836                                                                          ; shuffle down, we need to set up some variables to
27837                                                                          ; point to the source and destination line heaps
27838               
27839 BD52 0202  20        li   ry,>05*256                 ; LDY #5            ; Fetch byte #5 of the removed ship's blueprint into A,
     BD54 0500     
27840                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; which gives the ship's maximum heap size for the ship
     **** ****     > LD_IND_Y_IDX
0001 BD56 D820  50        movb @XX0,@rtmplb
     BD58 001E     
     BD5A 2079     
0002 BD5C D1A0  30        movb @XX0+1,rtmp
     BD5E 001F     
0003 BD60 A182  18        a    ry,rtmp
0004 BD62 D016  26        movb *rtmp,RA
                   < elite.a99
27841                                                                          ; we are removing (i.e. the size of the gap in the heap
27842                                                                          ; created by the ship removal)
27843               
27844                                                                          ; INF currently contains the ship data for the ship we
27845                                                                          ; are removing, and INF(34 33) contains the address of
27846                                                                          ; the bottom of the ship's heap, so we can calculate
27847                                                                          ; the address of the top of the heap by adding the heap
27848                                                                          ; size to this address
27849               
27850 BD64 0202  20        li   ry,>21*256                 ; LDY #33           ; First we add A and the address in INF+33, to get the
     BD66 2100     
27851                      .clc                            ; CLC               ; low byte of the top of the heap, which we store in P
     **** ****     > CLC
0001 BD68 0A13  18        sla  rzero,1
                   < elite.a99
27852                      .adc_ind_y_idx @INF,ra          ; ADC (INF),Y
     **** ****     > ADC_IND_Y_IDX
0001 BD6A 04C0  14        clr  ra
0002 BD6C 1701  14        jnc  !
0003 BD6E B004  18        ab   rone,ra
0004               !:
0005 BD70 D820  50        movb @INF,@rtmplb
     BD72 0020     
     BD74 2079     
0006 BD76 D1A0  30        movb @INF+1,rtmp
     BD78 0021     
0007 BD7A A182  18        a    ry,rtmp
0008 BD7C B016  26        ab   *rtmp,ra
                   < elite.a99
27853 BD7E D800  30        movb ra,@P                      ; STA P
     BD80 001B     
27854               
27855 BD82 B084  18        ab   rone,ry                    ; INY               ; And next we add A and the address in INF+34, with any
27856                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; carry from the previous addition, to get the high byte
     **** ****     > LD_IND_Y_IDX
0001 BD84 D820  50        movb @INF,@rtmplb
     BD86 0020     
     BD88 2079     
0002 BD8A D1A0  30        movb @INF+1,rtmp
     BD8C 0021     
0003 BD8E A182  18        a    ry,rtmp
0004 BD90 D016  26        movb *rtmp,RA
                   < elite.a99
27857                      .adi (>00*256)                  ; ADC #0            ; of the top of the heap, which we store in P+1, so
     **** ****     > ADI
0001 BD92 1701  14        jnc  !
0002 BD94 B004  18        ab   rone,ra
0003               !:
0004 BD96 0220  22        ai   ra,(>00*256)
     BD98 0000     
                   < elite.a99
27858 BD9A D800  30        movb ra,@P+1                    ; STA P+1           ; P(1 0) points to the top of this ship's heap
     BD9C 001C     
27859               
27860                                                                          ; Now, we're ready to start looping through the ships
27861                                                                          ; we want to move, moving the slots, data blocks and
27862                                                                          ; line heap from the source to the destination. In the
27863                                                                          ; following, we set up SC to point to the source data,
27864                                                                          ; and INF (which currently points to the removed ship's
27865                                                                          ; data that we can now overwrite) points to the
27866                                                                          ; destination
27867                                                                          ;
27868                                                                          ; So P(1 0) now points to the top of the line heap for
27869                                                                          ; the destination
27870               
27871               KSL1:
27872 BD9E B044  18        ab   rone,rx                    ; INX               ; On entry, X points to the empty slot we want to
27873                                                                          ; shuffle the next ship into (the destination), so
27874                                                                          ; this increment points X to the next slot - i.e. the
27875                                                                          ; source slot we want to shuffle down
27876               
27877 BDA0 D021  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Copy the contents of the source slot into the
     BDA2 0D40     
27878 BDA4 D840  38        movb ra,@FRIN-1(rx)             ; STA FRIN-1,X      ; destination slot
     BDA6 0D3F     
27879               
27880 BDA8 1602  14        jne  FIX009                     ; BNE FIX009        ; If the slot we just shuffled down contains 0, then
27881 BDAA 0460  28        b    @KS2                       ; JMP KS2           ; the source slot is empty and we are done shuffling,
     BDAC BC98     
27882                                                                          ; so jump to KS2 to move on to processing missiles
27883               FIX009:
27884                      .asla                           ; ASL A             ; Otherwise we have a source ship to shuffle down into
     **** ****     > ASLA
0001 BDAE 0240  22        andi ra,>ff00
     BDB0 FF00     
0002 BDB2 0A10  18        sla  ra,1
                   < elite.a99
27885 BDB4 D080  18        movb ra,ry                      ; TAY               ; the destination, so set Y = A * 2 so it can act as an
27886                                                                          ; index into the two-byte ship blueprint lookup table
27887                                                                          ; at XX21 for the source ship
27888               
27889 BDB6 D022  34        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; Set SC(0 1) to point to the blueprint data for the
     BDB8 E7E0     
27890 BDBA D800  30        movb ra,@SC                     ; STA SC            ; source ship
     BDBC 0007     
27891 BDBE D022  34        movb @XX21-1(ry),ra             ; LDA XX21-1,Y
     BDC0 E7E1     
27892 BDC2 D800  30        movb ra,@SC+1                   ; STA SC+1
     BDC4 0008     
27893               
27894 BDC6 0202  20        li   ry,>05*256                 ; LDY #5            ; Fetch blueprint byte #5 for the source ship, which
     BDC8 0500     
27895                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; gives us its maximum heap size, and store it in T
     **** ****     > LD_IND_Y_IDX
0001 BDCA D820  50        movb @SC,@rtmplb
     BDCC 0007     
     BDCE 2079     
0002 BDD0 D1A0  30        movb @SC+1,rtmp
     BDD2 0008     
0003 BDD4 A182  18        a    ry,rtmp
0004 BDD6 D016  26        movb *rtmp,RA
                   < elite.a99
27896 BDD8 D800  30        movb ra,@T                      ; STA T
     BDDA 00D1     
27897               
27898                                                                          ; We now subtract T from P(1 0), so P(1 0) will point to
27899                                                                          ; the bottom of the line heap for the destination
27900                                                                          ; (which we will use later when closing up the gap in
27901                                                                          ; the heap space)
27902               
27903 BDDC D020  30        movb @P,ra                      ; LDA P             ; First, we subtract the low bytes
     BDDE 001B     
27904                      .sec                            ; SEC
     **** ****     > SEC
0001 BDE0 0A15  18        sla  rmone,1
                   < elite.a99
27905                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 BDE2 1801  14        joc  !
0002 BDE4 7004  18        sb   rone,ra
0003               !:
0004 BDE6 7020  30        sb   @T,ra
     BDE8 00D1     
                   < elite.a99
27906 BDEA D800  30        movb ra,@P                      ; STA P
     BDEC 001B     
27907               
27908 BDEE D020  30        movb @P+1,ra                    ; LDA P+1           ; And then we do the high bytes, for which we subtract
     BDF0 001C     
27909                      .sbi (>00*256)                  ; SBC #0            ; 0 to include any carry, so this is effectively doing
     **** ****     > SBI
0001 BDF2 1801  14        joc  !
0002 BDF4 7004  18        sb   rone,ra
0003               !:
0004 BDF6 0220  22        ai   ra,-(>00*256)
     BDF8 0000     
                   < elite.a99
27910 BDFA D800  30        movb ra,@P+1                    ; STA P+1           ; P(1 0) = P(1 0) - (0 T)
     BDFC 001C     
27911               
27912                                                                          ; Next, we want to set SC(1 0) to point to the source
27913                                                                          ; ship's data block
27914               
27915 BDFE D001  18        movb rx,ra                      ; TXA               ; Set Y = X * 2 so it can act as an index into the
27916                      .asla                           ; ASL A             ; two-byte lookup table at UNIV, which contains the
     **** ****     > ASLA
0001 BE00 0240  22        andi ra,>ff00
     BE02 FF00     
0002 BE04 0A10  18        sla  ra,1
                   < elite.a99
27917 BE06 D080  18        movb ra,ry                      ; TAY               ; addresses of the ship data blocks. In this case we are
27918                                                                          ; multiplying X by 2, and X contains the source ship's
27919                                                                          ; slot number so Y is now an index for the source ship's
27920                                                                          ; entry in UNIV
27921               
27922 BE08 D022  34        movb @UNIV(ry),ra               ; LDA UNIV,Y        ; Set SC(1 0) to the address of the data block for the
     BE0A 221F     
27923 BE0C D800  30        movb ra,@SC                     ; STA SC            ; source ship
     BE0E 0007     
27924 BE10 D022  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y
     BE12 2220     
27925 BE14 D800  30        movb ra,@SC+1                   ; STA SC+1
     BE16 0008     
27926               
27927                                                                          ; We have now set up our variables as follows:
27928                                                                          ;
27929                                                                          ; SC(1 0) points to the source's ship data block
27930                                                                          ;
27931                                                                          ; INF(1 0) points to the destination's ship data block
27932                                                                          ;
27933                                                                          ; P(1 0) points to the destination's line heap
27934                                                                          ;
27935                                                                          ; so let's start copying data from the source to the
27936                                                                          ; destination
27937               
27938 BE18 0202  20        li   ry,>23*256                 ; LDY #35           ; We are going to be using Y as a counter for the 36
     BE1A 2300     
27939                                                                          ; bytes of ship data we want to copy from the source
27940                                                                          ; to the destination, so we set it to 35 to start things
27941                                                                          ; off, and will decrement Y for each byte we copy
27942               
27943                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; Fetch byte #35 of the source's ship data block at SC,
     **** ****     > LD_IND_Y_IDX
0001 BE1C D820  50        movb @SC,@rtmplb
     BE1E 0007     
     BE20 2079     
0002 BE22 D1A0  30        movb @SC+1,rtmp
     BE24 0008     
0003 BE26 A182  18        a    ry,rtmp
0004 BE28 D016  26        movb *rtmp,RA
                   < elite.a99
27944                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; and store it in byte #35 of the destination's block
     **** ****     > ST_IND_Y_IDX
0001 BE2A D820  50        movb @INF,@rtmplb
     BE2C 0020     
     BE2E 2079     
0002 BE30 D1A0  30        movb @INF+1,rtmp
     BE32 0021     
0003 BE34 A182  18        a    ry,rtmp
0004 BE36 D580  30        movb RA,*rtmp
                   < elite.a99
27945                                                                          ; at INF, so that's the ship's energy copied from the
27946                                                                          ; source to the destination. One down, quite a few to
27947                                                                          ; go...
27948               
27949 BE38 7084  18        sb   rone,ry                    ; DEY               ; Fetch byte #34 of the source ship, which is the
27950                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; high byte of the source ship's line heap, and store
     **** ****     > LD_IND_Y_IDX
0001 BE3A D820  50        movb @SC,@rtmplb
     BE3C 0007     
     BE3E 2079     
0002 BE40 D1A0  30        movb @SC+1,rtmp
     BE42 0008     
0003 BE44 A182  18        a    ry,rtmp
0004 BE46 D016  26        movb *rtmp,RA
                   < elite.a99
27951 BE48 D800  30        movb ra,@K+1                    ; STA K+1           ; in K+1
     BE4A 003E     
27952               
27953 BE4C D020  30        movb @P+1,ra                    ; LDA P+1           ; Set the low byte of the destination's heap pointer
     BE4E 001C     
27954                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; to P+1
     **** ****     > ST_IND_Y_IDX
0001 BE50 D820  50        movb @INF,@rtmplb
     BE52 0020     
     BE54 2079     
0002 BE56 D1A0  30        movb @INF+1,rtmp
     BE58 0021     
0003 BE5A A182  18        a    ry,rtmp
0004 BE5C D580  30        movb RA,*rtmp
                   < elite.a99
27955               
27956 BE5E 7084  18        sb   rone,ry                    ; DEY               ; Fetch byte #33 of the source ship, which is the
27957                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; low byte of the source ship's heap, and store in K
     **** ****     > LD_IND_Y_IDX
0001 BE60 D820  50        movb @SC,@rtmplb
     BE62 0007     
     BE64 2079     
0002 BE66 D1A0  30        movb @SC+1,rtmp
     BE68 0008     
0003 BE6A A182  18        a    ry,rtmp
0004 BE6C D016  26        movb *rtmp,RA
                   < elite.a99
27958 BE6E D800  30        movb ra,@K                      ; STA K             ; so now we have the following:
     BE70 003D     
27959                                                                          ;
27960                                                                          ; K(1 0) points to the source's line heap
27961               
27962 BE72 D020  30        movb @P,ra                      ; LDA P             ; Set the low byte of the destination's heap pointer
     BE74 001B     
27963                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; to P, so now the destination's heap pointer is to
     **** ****     > ST_IND_Y_IDX
0001 BE76 D820  50        movb @INF,@rtmplb
     BE78 0020     
     BE7A 2079     
0002 BE7C D1A0  30        movb @INF+1,rtmp
     BE7E 0021     
0003 BE80 A182  18        a    ry,rtmp
0004 BE82 D580  30        movb RA,*rtmp
                   < elite.a99
27964                                                                          ; P(1 0), so that's the heap pointer in bytes #33 and
27965                                                                          ; #34 done
27966               
27967 BE84 7084  18        sb   rone,ry                    ; DEY               ; Luckily, we can just copy the rest of the source's
27968                                                                          ; ship data block into the destination, as there are no
27969                                                                          ; more address pointers, so first we decrement our
27970                                                                          ; counter in Y to point to the next byte (the AI flag)
27971                                                                          ; in byte #32) and then start looping
27972               
27973               KSL2:
27974                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; Copy the Y-th byte of the source to the Y-th byte of
     **** ****     > LD_IND_Y_IDX
0001 BE86 D820  50        movb @SC,@rtmplb
     BE88 0007     
     BE8A 2079     
0002 BE8C D1A0  30        movb @SC+1,rtmp
     BE8E 0008     
0003 BE90 A182  18        a    ry,rtmp
0004 BE92 D016  26        movb *rtmp,RA
                   < elite.a99
27975                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; the destination
     **** ****     > ST_IND_Y_IDX
0001 BE94 D820  50        movb @INF,@rtmplb
     BE96 0020     
     BE98 2079     
0002 BE9A D1A0  30        movb @INF+1,rtmp
     BE9C 0021     
0003 BE9E A182  18        a    ry,rtmp
0004 BEA0 D580  30        movb RA,*rtmp
                   < elite.a99
27976               
27977 BEA2 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter
27978               
27979 BEA4 15F0  14        jgt  KSL2                       ; BPL KSL2          ; Loop back to KSL2 to copy the next byte until we have
27980                                                                          ; copied the whole block
27981               
27982                                                                          ; We have now shuffled the ship's slot and the ship's
27983                                                                          ; data block, so we only have the heap data itself to do
27984               
27985 BEA6 D020  30        movb @SC,ra                     ; LDA SC            ; First, we copy SC into INF, so when we loop round
     BEA8 0007     
27986 BEAA D800  30        movb ra,@INF                    ; STA INF           ; again, INF will correctly point to the destination for
     BEAC 0020     
27987 BEAE D020  30        movb @SC+1,ra                   ; LDA SC+1          ; the next iteration
     BEB0 0008     
27988 BEB2 D800  30        movb ra,@INF+1                  ; STA INF+1
     BEB4 0021     
27989               
27990 BEB6 D0A0  30        movb @T,ry                      ; LDY T             ; Now we want to move the contents of the heap, as all
     BEB8 00D1     
27991                                                                          ; we did above was to update the pointers, so first
27992                                                                          ; we set a counter in Y that is initially set to T
27993                                                                          ; (which we set above to the maximum heap size for the
27994                                                                          ; source ship)
27995                                                                          ;
27996                                                                          ; As a reminder, we have already set the following:
27997                                                                          ;
27998                                                                          ; K(1 0) points to the source's line heap
27999                                                                          ;
28000                                                                          ; P(1 0) points to the destination's line heap
28001                                                                          ;
28002                                                                          ; so we can move the heap data by simply copying the
28003                                                                          ; correct number of bytes from K(1 0) to P(1 0)
28004               KSL3:
28005 BEBA 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter
28006               
28007                      .ld_ind_y_idx @K,ra             ; LDA (K),Y         ; Copy the Y-th byte of the source heap at K(1 0) to
     **** ****     > LD_IND_Y_IDX
0001 BEBC D820  50        movb @K,@rtmplb
     BEBE 003D     
     BEC0 2079     
0002 BEC2 D1A0  30        movb @K+1,rtmp
     BEC4 003E     
0003 BEC6 A182  18        a    ry,rtmp
0004 BEC8 D016  26        movb *rtmp,RA
                   < elite.a99
28008                      .st_ind_y_idx @P,ra             ; STA (P),Y         ; the destination heap at P(1 0)
     **** ****     > ST_IND_Y_IDX
0001 BECA D820  50        movb @P,@rtmplb
     BECC 001B     
     BECE 2079     
0002 BED0 D1A0  30        movb @P+1,rtmp
     BED2 001C     
0003 BED4 A182  18        a    ry,rtmp
0004 BED6 D580  30        movb RA,*rtmp
                   < elite.a99
28009               
28010 BED8 D002  18        movb ry,ra                      ; TYA               ; Loop back to KSL3 to copy the next byte, until we
28011 BEDA 16EF  14        jne  KSL3                       ; BNE KSL3          ; have done them all
28012               
28013 BEDC 1602  14        jne  FIX010                     ; BNE FIX010        ; We have now shuffled everything down one slot, so
28014 BEDE 0460  28        b    @KSL1                      ; JMP KSL1          ; jump back up to KSL1 to see if there is another slot
     BEE0 BD9E     
28015                                                                          ; that needs shuffling down (this BEQ is effectively a
28016                                                                          ; JMP as A will always be zero)
28017               FIX010:
28018               * ******************************************************************************
28019               *
28020               * Name: SFX
28021               * Type: Variable
28022               * Category: Sound
28023               * Summary: Sound data
28024               *
28025               * ------------------------------------------------------------------------------
28026               *
28027               * Sound data. To make a sound, the NOS1 routine copies the four relevant sound
28028               * bytes to XX16, and NO3 then makes the sound. The sound numbers are shown in
28029               * the table, and are always multiples of 8. Generally, sounds are made by
28030               * calling the NOISE routine with the sound number in A.
28031               *
28032               * These bytes are passed to OSWORD 7, and are the equivalents to the parameters
28033               * passed to the SOUND keyword in BASIC. The parameters therefore have these
28034               * meanings:
28035               *
28036               * channel/flush, amplitude (or envelope number if 1-4), pitch, duration
28037               *
28038               * For the channel/flush parameter, the high nibble of the low byte is the flush
28039               * control (where a flush control of 0 queues the sound, and a flush control of
28040               * 1 makes the sound instantly), while the low nibble of the low byte is the
28041               * channel number. When written in hexadecimal, the first figure gives the flush
28042               * control, while the second is the channel (so &13 indicates flush control = 1
28043               * and channel = 3).
28044               *
28045               * So when we call NOISE with A = 40 to make a long, low beep, then this is
28046               * effectively what the NOISE routine does:
28047               *
28048               * SOUND &13, &F4, &0C, &08
28049               *
28050               * which makes a sound with flush control 1 on channel 3, and with amplitude &F4
28051               * (-12), pitch &0C (2) and duration &08 (8). Meanwhile, to make the hyperspace
28052               * sound, the NOISE routine does this:
28053               *
28054               * SOUND &10, &02, &60, &10
28055               *
28056               * which makes a sound with flush control 1 on channel 0, using envelope 2,
28057               * and with pitch &60 (96) and duration &10 (16). The four sound envelopes (1-4)
28058               * are set up by the loading process.
28059               *
28060               * ******************************************************************************
28061                      equ  $
28062               SFX:
28063 BEE2 1201            byte >12,>01,>00,>10                                ; 0  - Lasers fired by us
     BEE4 0010     
28064 BEE6 1202            byte >12,>02,>2c,>08                                ; 8  - We're being hit by lasers
     BEE8 2C08     
28065 BEEA 1103            byte >11,>03,>f0,>18                                ; 16 - We died 1 / We made a hit or kill 2
     BEEC F018     
28066 BEEE 10F1            byte >10,>f1,>07,>1a                                ; 24 - We died 2 / We made a hit or kill 1
     BEF0 071A     
28067 BEF2 03F1            byte >03,>f1,>bc,>01                                ; 32 - Short, high beep
     BEF4 BC01     
28068 BEF6 13F4            byte >13,>f4,>0c,>08                                ; 40 - Long, low beep
     BEF8 0C08     
28069 BEFA 10F1            byte >10,>f1,>06,>0c                                ; 48 - Missile launched / Ship launched from station
     BEFC 060C     
28070 BEFE 1002            byte >10,>02,>60,>10                                ; 56 - Hyperspace drive engaged
     BF00 6010     
28071 BF02 1304            byte >13,>04,>c2,>ff                                ; 64 - E.C.M. on
     BF04 C2FF     
28072 BF06 1300            byte >13,>00,>00,>00                                ; 72 - E.C.M. off
     BF08 0000     
28073               
28074               * ******************************************************************************
28075               *
28076               * Name: RESET
28077               * Type: Subroutine
28078               * Category: Start and end
28079               * Summary: Reset most variables
28080               *
28081               * ------------------------------------------------------------------------------
28082               *
28083               * Reset our ship and various controls, recharge shields and energy, and then
28084               * fall through into RES2 to reset the stardust and the ship workspace at INWK.
28085               *
28086               * In this subroutine, this means zero-filling the following locations:
28087               *
28088               * * Pages &9, &A, &B, &C and &D
28089               *
28090               * * BETA to BETA+6, which covers the following:
28091               *
28092               * * BETA, BET1 - Set pitch to 0
28093               *
28094               * * XC, YC - Set text cursor to (0, 0)
28095               *
28096               * * QQ22 - Set hyperspace counters to 0
28097               *
28098               * * ECMA - Turn E.C.M. off
28099               *
28100               * It also sets QQ12 to &FF, to indicate we are docked, recharges the shields and
28101               * energy banks, and then falls through into RES2.
28102               *
28103               * ------------------------------------------------------------------------------
28104               *
28105               * Other entry points:
28106               *
28107               * RES4                Reset the shields and energy banks, then fall through
28108               * into RES2 to reset the stardust and the ship workspace
28109               * at INWK
28110               *
28111               * ******************************************************************************
28112               
28113               RESET:
28114 BF0A 0206  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     BF0C C80A     
28115 BF0E 06A0  32        bl   @jsr                       ;
     BF10 FF10     
28116                                                                          ; the ship data blocks, the ship line heap, the ship
28117                                                                          ; slots for the local bubble of universe, and various
28118                                                                          ; flight and ship status variables
28119               
28120 BF12 0201  20        li   rx,>06*256                 ; LDX #6            ; Set up a counter for zeroing BETA through BETA+6
     BF14 0600     
28121               
28122               SAL3:
28123 BF16 D840  38        movb ra,@BETA(rx)               ; STA BETA,X        ; Zero the X-th byte after BETA
     BF18 002A     
28124               
28125 BF1A 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
28126               
28127 BF1C 15FC  14        jgt  SAL3                       ; BPL SAL3          ; Loop back for the next byte to zero
28128               
28129 BF1E D801  30        movb rx,@QQ12                   ; STX QQ12          ; X is now negative - i.e. &FF - so this sets QQ12 to
     BF20 009F     
28130                                                                          ; &FF to indicate we are docked
28131               
28132                                                                          ; We now fall through into RES4 to restore shields and
28133                                                                          ; energy, and reset the stardust and ship workspace at
28134                                                                          ; INWK
28135               
28136               RES4:
28137 BF22 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to &FF so we can fill up the shields and energy
     BF24 FF00     
28138                                                                          ; bars with a full charge
28139               
28140 BF26 0201  20        li   rx,>02*256                 ; LDX #2            ; We're now going to recharge both shields and the
     BF28 0200     
28141                                                                          ; energy bank, which live in the three bytes at FSH,
28142                                                                          ; ASH (FSH+1) and ENERGY (FSH+2), so set a loop counter
28143                                                                          ; in X for 3 bytes
28144               
28145               REL5:
28146 BF2A D840  38        movb ra,@FSH(rx)                ; STA FSH,X         ; Set the X-th byte of FSH to &FF to charge up that
     BF2C 0F11     
28147                                                                          ; shield/bank
28148               
28149 BF2E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
28150               
28151 BF30 15FC  14        jgt  REL5                       ; BPL REL5          ; Loop back to REL5 until we have recharged both shields
28152                                                                          ; and the energy bank
28153               
28154                                                                          ; Fall through into RES2 to reset the stardust and ship
28155                                                                          ; workspace at INWK
28156               
28157               * ******************************************************************************
28158               *
28159               * Name: RES2
28160               * Type: Subroutine
28161               * Category: Start and end
28162               * Summary: Reset a number of flight variables and workspaces
28163               *
28164               * ------------------------------------------------------------------------------
28165               *
28166               * This is called after we launch from a space station, arrive in a new system
28167               * after hyperspace, launch an escape pod, or die a cold, lonely death in the
28168               * depths of space.
28169               *
28170               * ------------------------------------------------------------------------------
28171               *
28172               * Returns:
28173               *
28174               * Y                   Y is set to &FF
28175               *
28176               * ******************************************************************************
28177               
28178               RES2:
28179 BF32 0200  20        li   ra,(NOST)*256              ; LDA #NOST         ; Reset NOSTM, the number of stardust particles, to the
     BF34 1200     
28180 BF36 D800  30        movb ra,@NOSTM                  ; STA NOSTM         ; maximum allowed (18)
     BF38 0F33     
28181               
28182 BF3A 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Reset LSX2 and LSY2, the ball line heaps used by the
     BF3C FF00     
28183 BF3E D801  30        movb rx,@LSX2                   ; STX LSX2          ; BLINE routine for drawing circles, to &FF, to set the
     BF40 0E26     
28184 BF42 D801  30        movb rx,@LSY2                   ; STX LSY2          ; heap to empty
     BF44 0E74     
28185               
28186 BF46 D801  30        movb rx,@MSTG                   ; STX MSTG          ; Reset MSTG, the missile target, to &FF (no target)
     BF48 0052     
28187               
28188 BF4A 0200  20        li   ra,>80*256                 ; LDA #128          ; Set the current pitch rate to the mid-point, 128
     BF4C 8000     
28189 BF4E D800  30        movb ra,@JSTY                   ; STA JSTY
     BF50 009D     
28190               
28191 BF52 D800  30        movb ra,@ALP2                   ; STA ALP2          ; Reset ALP2 (roll sign) and BET2 (pitch sign)
     BF54 0088     
28192 BF56 D800  30        movb ra,@BET2                   ; STA BET2          ; to negative, i.e. pitch and roll negative
     BF58 008A     
28193               
28194                      .asla                           ; ASL A             ; This sets A to 0
     **** ****     > ASLA
0001 BF5A 0240  22        andi ra,>ff00
     BF5C FF00     
0002 BF5E 0A10  18        sla  ra,1
                   < elite.a99
28195               
28196 BF60 D800  30        movb ra,@ALP2+1                 ; STA ALP2+1        ; Reset ALP2+1 (flipped roll sign) and BET2+1 (flipped
     BF62 0089     
28197 BF64 D800  30        movb ra,@BET2+1                 ; STA BET2+1        ; pitch sign) to positive, i.e. pitch and roll negative
     BF66 008B     
28198               
28199 BF68 D800  30        movb ra,@MCNT                   ; STA MCNT          ; Reset MCNT (the main loop counter) to 0
     BF6A 0099     
28200               
28201 BF6C 0200  20        li   ra,>03*256                 ; LDA #3            ; Reset DELTA (speed) to 3
     BF6E 0300     
28202 BF70 D800  30        movb ra,@DELTA                  ; STA DELTA
     BF72 008C     
28203               
28204 BF74 D800  30        movb ra,@ALPHA                  ; STA ALPHA         ; Reset ALPHA (roll angle alpha) to 3
     BF76 009E     
28205               
28206 BF78 D800  30        movb ra,@ALP1                   ; STA ALP1          ; Reset ALP1 (magnitude of roll angle alpha) to 3
     BF7A 0087     
28207               
28208 BF7C D020  30        movb @SSPR,ra                   ; LDA SSPR          ; Fetch the "space station present" flag, and if we are
     BF7E 0D55     
28209 BF80 1304  14        jeq  B86                        ; BEQ B86           ; not inside the safe zone, skip the next instruction
28210               
28211 BF82 0206  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Light up the space station bulb on the dashboard
     BF84 B0E2     
28212 BF86 06A0  32        bl   @jsr                       ;
     BF88 FF10     
28213               
28214               B86:
28215 BF8A D020  30        movb @ECMA,ra                   ; LDA ECMA          ; Fetch the E.C.M. status flag, and if E.C.M. is off,
     BF8C 0030     
28216 BF8E 1304  14        jeq  yu_                        ; BEQ yu            ; skip the next instruction
28217               
28218 BF90 0206  20        li   rtmp,ECMOF                 ; JSR ECMOF         ; Turn off the E.C.M. sound
     BF92 CB14     
28219 BF94 06A0  32        bl   @jsr                       ;
     BF96 FF10     
28220               
28221               yu_:
28222 BF98 0206  20        li   rtmp,WPSHPS                ; JSR WPSHPS        ; Wipe all ships from the scanner
     BF9A AC30     
28223 BF9C 06A0  32        bl   @jsr                       ;
     BF9E FF10     
28224               
28225 BFA0 0206  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     BFA2 C80A     
28226 BFA4 06A0  32        bl   @jsr                       ;
     BFA6 FF10     
28227                                                                          ; the ship data blocks, the ship line heap, the ship
28228                                                                          ; slots for the local bubble of universe, and various
28229                                                                          ; flight and ship status variables
28230               
28231 BFA8 0200  20        li   ra,((WP.-1)%256)*256       ; LDA #LO(WP%-1)    ; We have reset the ship line heap, so we now point
     BFAA 3F00     
28232 BFAC D800  30        movb ra,@SLSP                   ; STA SLSP          ; SLSP to the byte before the WP workspace to indicate
     BFAE 0F1E     
28233 BFB0 0200  20        li   ra,((WP.-1)/256)*256       ; LDA #HI(WP%-1)    ; that the heap is empty
     BFB2 0D00     
28234 BFB4 D800  30        movb ra,@SLSP+1                 ; STA SLSP+1
     BFB6 0F1F     
28235               
28236 BFB8 0206  20        li   rtmp,DIALS                 ; JSR DIALS         ; Update the dashboard
     BFBA 3272     
28237 BFBC 06A0  32        bl   @jsr                       ;
     BFBE FF10     
28238               
28239                                                                          ; Finally, fall through into ZINF to reset the INWK
28240                                                                          ; ship workspace
28241               
28242               * ******************************************************************************
28243               *
28244               * Name: ZINF
28245               * Type: Subroutine
28246               * Category: Universe
28247               * Summary: Reset the INWK workspace and orientation vectors
28248               * Deep dive: Orientation vectors
28249               *
28250               * ------------------------------------------------------------------------------
28251               *
28252               * Zero-fill the INWK ship workspace and reset the orientation vectors, with
28253               * nosev pointing out of the screen, towards us.
28254               *
28255               * ------------------------------------------------------------------------------
28256               *
28257               * Returns:
28258               *
28259               * Y                   Y is set to &FF
28260               *
28261               * ******************************************************************************
28262               
28263               ZINF:
28264 BFC0 0202  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; There are NI% bytes in the INWK workspace, so set a
     BFC2 2300     
28265                                                                          ; counter in Y so we can loop through them
28266               
28267 BFC4 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can zero-fill the workspace
     BFC6 0000     
28268               
28269               ZI1:
28270 BFC8 D880  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; Zero the Y-th byte of the INWK workspace
     BFCA 0053     
28271               
28272 BFCC 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
28273               
28274 BFCE 15FC  14        jgt  ZI1                        ; BPL ZI1           ; Loop back for the next byte, ending when we have
28275                                                                          ; zero-filled the last byte at INWK, which leaves Y
28276                                                                          ; with a value of &FF
28277               
28278                                                                          ; Finally, we reset the orientation vectors as follows:
28279                                                                          ;
28280                                                                          ; sidev = (1,  0,  0)
28281                                                                          ; roofv = (0,  1,  0)
28282                                                                          ; nosev = (0,  0, -1)
28283                                                                          ;
28284                                                                          ; 96 * 256 (&6000) represents 1 in the orientation
28285                                                                          ; vectors, while -96 * 256 (&E000) represents -1. We
28286                                                                          ; already set the vectors to zero above, so we just
28287                                                                          ; need to set up the high bytes of the diagonal values
28288                                                                          ; and we're done. The negative nosev makes the ship
28289                                                                          ; point towards us, as the z-axis points into the screen
28290               
28291 BFD0 0200  20        li   ra,>60*256                 ; LDA #96           ; Set A to represent a 1 (in vector terms)
     BFD2 6000     
28292               
28293 BFD4 D800  30        movb ra,@INWK+18                ; STA INWK+18       ; Set byte #18 = roofv_y_hi = 96 = 1
     BFD6 0065     
28294               
28295 BFD8 D800  30        movb ra,@INWK+22                ; STA INWK+22       ; Set byte #22 = sidev_x_hi = 96 = 1
     BFDA 0069     
28296               
28297 BFDC 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Flip the sign of A to represent a -1
     BFDE 8000     
28298               
28299 BFE0 D800  30        movb ra,@INWK+14                ; STA INWK+14       ; Set byte #14 = nosev_z_hi = -96 = -1
     BFE2 0061     
28300               
28301 BFE4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BFE6 FF1C     
28302               
28303               * ******************************************************************************
28304               *
28305               * Name: msblob
28306               * Type: Subroutine
28307               * Category: Dashboard
28308               * Summary: Display the dashboard's missile indicators in green
28309               *
28310               * ------------------------------------------------------------------------------
28311               *
28312               * Display the dashboard's missile indicators, with all the missiles reset to
28313               * green/cyan (i.e. not armed or locked).
28314               *
28315               * ******************************************************************************
28316               
28317               msblob_:
28318 BFE8 0201  20        li   rx,>04*256                 ; LDX #4            ; Set up a loop counter in X to count through all four
     BFEA 0400     
28319                                                                          ; missile indicators
28320               
28321               ss_:
28322 BFEC 9060  30        cb   @NOMSL,rx                  ; CPX NOMSL         ; If the counter is equal to the number of missiles,
     BFEE 0333     
28323 BFF0 130A  14        jeq  SAL8                       ; BEQ SAL8          ; jump down to SAL8 to draw the remaining missiles, as
28324                                                                          ; the rest of them are present and should be drawn in
28325                                                                          ; green/cyan
28326               
28327 BFF2 0202  20        li   ry,>00*256                 ; LDY #0            ; Draw the missile indicator at position X in black
     BFF4 0000     
28328 BFF6 0206  20        li   rtmp,MSBAR                 ; JSR MSBAR
     BFF8 B10E     
28329 BFFA 06A0  32        bl   @jsr                       ;
     BFFC FF10     
28330               
28331 BFFE 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter to point to the next missile
28332               
28333 C000 16F5  14        jne  ss_                        ; BNE ss            ; Loop back to ss if we still have missiles to draw
28334               
28335 C002 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C004 FF1C     
28336               
28337               SAL8:
28338 C006 0202  20        li   ry,>ee*256                 ; LDY #&EE          ; Draw the missile indicator at position X in green/cyan
     C008 EE00     
28339 C00A 0206  20        li   rtmp,MSBAR                 ; JSR MSBAR
     C00C B10E     
28340 C00E 06A0  32        bl   @jsr                       ;
     C010 FF10     
28341               
28342 C012 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter to point to the next missile
28343               
28344 C014 16F8  14        jne  SAL8                       ; BNE SAL8          ; Loop back to SAL8 if we still have missiles to draw
28345               
28346 C016 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C018 FF1C     
28347               
28348               * ******************************************************************************
28349               *
28350               * Name: me2
28351               * Type: Subroutine
28352               * Category: Flight
28353               * Summary: Remove an in-flight message from the space view
28354               *
28355               * ******************************************************************************
28356               
28357               me2_:
28358 C01A D020  30        movb @MCH,ra                    ; LDA MCH           ; Fetch the token number of the current message into A
     C01C 0F10     
28359               
28360 C01E 0206  20        li   rtmp,MESS                  ; JSR MESS          ; Call MESS to print the token, which will remove it
     C020 CE5E     
28361 C022 06A0  32        bl   @jsr                       ;
     C024 FF10     
28362                                                                          ; from the screen as printing uses EOR logic
28363               
28364 C026 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the delay in DLY to 0, so any new in-flight
     C028 0000     
28365 C02A D800  30        movb ra,@DLY                    ; STA DLY           ; messages will be shown instantly
     C02C 0D64     
28366               
28367 C02E 0460  28        b    @me3_                      ; JMP me3           ; Jump back into the main spawning loop at me3
     C030 C0EA     
28368               
28369               * ******************************************************************************
28370               *
28371               * Name: Ze
28372               * Type: Subroutine
28373               * Category: Universe
28374               * Summary: Initialise the INWK workspace to a hostile ship
28375               * Deep dive: Fixing ship positions
28376               *
28377               * ------------------------------------------------------------------------------
28378               *
28379               * Specifically, this routine does the following:
28380               *
28381               * * Reset the INWK ship workspace
28382               *
28383               * * Set the ship to a fair distance away in all axes, in front of us but
28384               * randomly up or down, left or right
28385               *
28386               * * Give the ship a 4% chance of having E.C.M.
28387               *
28388               * * Set the ship to hostile, with AI enabled
28389               *
28390               * This routine also sets A, X, T1 and the C flag to random values.
28391               *
28392               * Note that because this routine uses the value of X returned by DORND, and X
28393               * contains the value of A returned by the previous call to DORND, this routine
28394               * does not necessarily set the new ship to a totally random location. See the
28395               * deep dive on "Fixing ship positions" for details.
28396               *
28397               * ******************************************************************************
28398               
28399               Ze:
28400 C032 0206  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     C034 BFC0     
28401 C036 06A0  32        bl   @jsr                       ;
     C038 FF10     
28402               
28403 C03A 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C03C C07C     
28404 C03E 06A0  32        bl   @jsr                       ;
     C040 FF10     
28405               
28406 C042 D800  30        movb ra,@T1                     ; STA T1            ; Store A in T1
     C044 0006     
28407               
28408 C046 0240  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign of A and store in x_sign
     C048 8000     
28409 C04A D800  30        movb ra,@INWK+2                 ; STA INWK+2
     C04C 0055     
28410               
28411 C04E D001  18        movb rx,ra                      ; TXA               ; Extract the sign of X and store in y_sign
28412 C050 0240  22        andi ra,>80*256                 ; AND #%10000000
     C052 8000     
28413 C054 D800  30        movb ra,@INWK+5                 ; STA INWK+5
     C056 0058     
28414               
28415 C058 0200  20        li   ra,>20*256                 ; LDA #32           ; Set x_hi = y_hi = z_hi = 32, a fair distance away
     C05A 2000     
28416 C05C D800  30        movb ra,@INWK+1                 ; STA INWK+1
     C05E 0054     
28417 C060 D800  30        movb ra,@INWK+4                 ; STA INWK+4
     C062 0057     
28418 C064 D800  30        movb ra,@INWK+7                 ; STA INWK+7
     C066 005A     
28419               
28420 C068 D001  18        movb rx,ra                      ; TXA               ; Set the C flag if X >= 245 (4% chance)
28421 C06A 0280  22        ci   ra,>f5*256                 ; CMP #245
     C06C F500     
28422               
28423 C06E 06A0  32        bl   @rola                      ; ROL A             ; Set bit 0 of A to the C flag (i.e. there's a 4%
     C070 FF26     
28424                                                                          ; chance of this ship having E.C.M.)
28425               
28426 C072 0260  22        ori  ra,>c0*256                 ; ORA #%11000000    ; Set bits 6 and 7 of A, so the ship is hostile (bit 6
     C074 C000     
28427                                                                          ; and has AI (bit 7)
28428               
28429 C076 D800  30        movb ra,@INWK+32                ; STA INWK+32       ; Store A in the AI flag of this ship
     C078 0073     
28430               
28431                                                                          ; Fall through into DORND2 to set A, X and the C flag
28432                                                                          ; randomly
28433               
28434               * ******************************************************************************
28435               *
28436               * Name: DORND
28437               * Type: Subroutine
28438               * Category: Maths (Arithmetic)
28439               * Summary: Generate random numbers
28440               * Deep dive: Generating random numbers
28441               * Fixing ship positions
28442               *
28443               * ------------------------------------------------------------------------------
28444               *
28445               * Set A and X to random numbers (though note that X is set to the random number
28446               * that was returned in A the last time DORND was called).
28447               *
28448               * The C and V flags are also set randomly.
28449               *
28450               * If we want to generate a repeatable sequence of random numbers, when
28451               * generating explosion clouds, for example, then we call DORND2 to ensure that
28452               * the value of the C flag on entry doesn't affect the outcome, as otherwise we
28453               * might not get the same sequence of numbers if the C flag changes.
28454               *
28455               * ------------------------------------------------------------------------------
28456               *
28457               * Other entry points:
28458               *
28459               * DORND2              Make sure the C flag doesn't affect the outcome
28460               *
28461               * ******************************************************************************
28462               
28463               DORND2:
28464                      .clc                            ; CLC               ; Clear the C flag so the value of the C flag on entry
     **** ****     > CLC
0001 C07A 0A13  18        sla  rzero,1
                   < elite.a99
28465                                                                          ; doesn't affect the outcome
28466               
28467               DORND:
28468 C07C D020  30        movb @RAND,ra                   ; LDA RAND          ; Calculate the next two values f2 and f3 in the feeder
     C07E 0000     
28469 C080 06A0  32        bl   @rola                      ; ROL A             ; sequence:
     C082 FF26     
28470 C084 D040  18        movb ra,rx                      ; TAX               ;
28471                      .adc @RAND+2,ra                 ; ADC RAND+2        ; * f2 = (f1 << 1) mod 256 + C flag on entry
     **** ****     > ADC
0001 C086 1701  14        jnc  !
0002 C088 B004  18        ab   rone,ra
0003               !:
0004 C08A B020  30        ab   @RAND+2,ra
     C08C 0002     
                   < elite.a99
28472 C08E D800  30        movb ra,@RAND                   ; STA RAND          ; * f3 = f0 + f2 + (1 if bit 7 of f1 is set)
     C090 0000     
28473 C092 D801  30        movb rx,@RAND+2                 ; STX RAND+2        ; * C flag is set according to the f3 calculation
     C094 0002     
28474               
28475 C096 D020  30        movb @RAND+1,ra                 ; LDA RAND+1        ; Calculate the next value m2 in the main sequence:
     C098 0001     
28476 C09A D040  18        movb ra,rx                      ; TAX               ;
28477                      .adc @RAND+3,ra                 ; ADC RAND+3        ; * A = m2 = m0 + m1 + C flag from feeder calculation
     **** ****     > ADC
0001 C09C 1701  14        jnc  !
0002 C09E B004  18        ab   rone,ra
0003               !:
0004 C0A0 B020  30        ab   @RAND+3,ra
     C0A2 0003     
                   < elite.a99
28478 C0A4 D800  30        movb ra,@RAND+1                 ; STA RAND+1        ; * X = m1
     C0A6 0001     
28479 C0A8 D801  30        movb rx,@RAND+3                 ; STX RAND+3        ; * C and V flags set according to the m2 calculation
     C0AA 0003     
28480               
28481 C0AC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C0AE FF1C     
28482               
28483               * ******************************************************************************
28484               *
28485               * Name: Main game loop (Part 1 of 6)
28486               * Type: Subroutine
28487               * Category: Main loop
28488               * Summary: Spawn a trader (a peaceful Cobra Mk III)
28489               * Deep dive: Program flow of the main game loop
28490               * Ship data blocks
28491               *
28492               * ------------------------------------------------------------------------------
28493               *
28494               * This is part of the main game loop. This is where the core loop of the game
28495               * lives, and it's in two parts. The shorter loop (just parts 5 and 6) is
28496               * iterated when we are docked, while the entire loop from part 1 to 6 iterates
28497               * if we are in space.
28498               *
28499               * This section covers the following:
28500               *
28501               * * Spawn a trader, i.e. a Cobra Mk III that isn't hostile, with a 50% chance
28502               * of it having a missile, a 50% chance of it having an E.C.M., a speed
28503               * between 16 and 31, and a gentle clockwise roll
28504               *
28505               * We call this from within the main loop, with A set to a random number.
28506               *
28507               * ******************************************************************************
28508               
28509               MTT4:
28510 C0B0 0910  18        srl  ra,1                       ; LSR A             ; Clear bit 7 of our random number in A and set the C
28511                                                                          ; flag to bit 0 of A, which is random
28512               
28513 C0B2 D800  30        movb ra,@INWK+32                ; STA INWK+32       ; Store this in the ship's AI flag, so this ship does
     C0B4 0073     
28514                                                                          ; not have AI
28515               
28516 C0B6 D800  30        movb ra,@INWK+29                ; STA INWK+29       ; Store A in the ship's roll counter, giving it a
     C0B8 0070     
28517                                                                          ; clockwise roll (as bit 7 is clear), and a 1 in 127
28518                                                                          ; chance of it having no damping
28519               
28520 C0BA 0208  20        li   rarg1,INWK+31              ; ROL INWK+31       ; Set bit 0 of the ship's missile count randomly (as the
     C0BC 0072     
28521 C0BE 06A0  32        bl   @rol                       ;
     C0C0 FF36     
28522                                                                          ; C flag was set), giving the ship either no missiles or
28523                                                                          ; one missile
28524               
28525 C0C2 0240  22        andi ra,>1f*256                 ; AND #31           ; Set the ship speed to our random number, set to a
     C0C4 1F00     
28526 C0C6 0260  22        ori  ra,>10*256                 ; ORA #16           ; minimum of 16 and a maximum of 31
     C0C8 1000     
28527 C0CA D800  30        movb ra,@INWK+27                ; STA INWK+27
     C0CC 006E     
28528               
28529 C0CE 0200  20        li   ra,(CYL)*256               ; LDA #CYL          ; Add a new Cobra Mk III to the local bubble and fall
     C0D0 0700     
28530 C0D2 0206  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; through into the main game loop again
     C0D4 AF7A     
28531 C0D6 06A0  32        bl   @jsr                       ;
     C0D8 FF10     
28532               
28533               * ******************************************************************************
28534               *
28535               * Name: Main game loop (Part 2 of 6)
28536               * Type: Subroutine
28537               * Category: Main loop
28538               * Summary: Call the main flight loop, and potentially spawn a trader, an
28539               * asteroid, or a cargo canister
28540               * Deep dive: Program flow of the main game loop
28541               * Ship data blocks
28542               * Fixing ship positions
28543               *
28544               * ------------------------------------------------------------------------------
28545               *
28546               * This section covers the following:
28547               *
28548               * * Call M% to do the main flight loop
28549               *
28550               * * Potentially spawn a trader, asteroid or cargo canister
28551               *
28552               * ------------------------------------------------------------------------------
28553               *
28554               * Other entry points:
28555               *
28556               * TT100               The entry point for the start of the main game loop,
28557               * which calls the main flight loop and the moves into the
28558               * spawning routine
28559               *
28560               * me3                 Used by me2 to jump back into the main game loop after
28561               * printing an in-flight message
28562               *
28563               * ******************************************************************************
28564               
28565               TT100:
28566 C0DA 0206  20        li   rtmp,M.                    ; JSR M%            ; Call M% to iterate through the main flight loop
     C0DC 0F52     
28567 C0DE 06A0  32        bl   @jsr                       ;
     C0E0 FF10     
28568               
28569 C0E2 7004  18        sb   rone,ra                    ; DEC DLY           ; Decrement the delay counter in DLY, so any in-flight
28570                                                                          ; messages get removed once the counter reaches zero
28571               
28572 C0E4 139A  14        jeq  me2_                       ; BEQ me2           ; If DLY is now 0, jump to me2 to remove any in-flight
28573                                                                          ; message from the space view, and once done, return to
28574                                                                          ; me3 below, skipping the following two instructions
28575               
28576 C0E6 1501  14        jgt  me3_                       ; BPL me3           ; If DLY is positive, jump to me3 to skip the next
28577                                                                          ; instruction
28578               
28579 C0E8 B004  18        ab   rone,ra                    ; INC DLY           ; If we get here, DLY is negative, so we have gone too
28580                                                                          ; and need to increment DLY back to 0
28581               
28582               me3_:
28583 C0EA 7004  18        sb   rone,ra                    ; DEC MCNT          ; Decrement the main loop counter in MCNT
28584               
28585 C0EC 1302  14        jeq  B87                        ; BEQ B87           ; If the counter has reached zero, which it will do
28586                                                                          ; every 256 main loops, skip the next JMP instruction
28587                                                                          ; (or to put it another way, if the counter hasn't
28588                                                                          ; reached zero, jump down to MLOOP, skipping all the
28589                                                                          ; following checks)
28590               
28591               ytq_:
28592 C0EE 0460  28        b    @MLOOP                     ; JMP MLOOP         ; Jump down to MLOOP to do some end-of-loop tidying and
     C0F0 C276     
28593                                                                          ; restart the main loop
28594               
28595                                                                          ; We only get here once every 256 iterations of the
28596                                                                          ; main loop. If we aren't in witchspace and don't
28597                                                                          ; already have 3 or more asteroids in our local bubble,
28598                                                                          ; then this section has a 13% chance of spawning
28599                                                                          ; something benign (the other 87% of the time we jump
28600                                                                          ; down to consider spawning cops, pirates and bounty
28601                                                                          ; hunters)
28602                                                                          ;
28603                                                                          ; If we are in that 13%, then 50% of the time this will
28604                                                                          ; be a Cobra Mk III trader, and the other 50% of the
28605                                                                          ; time it will either be an asteroid (98.5% chance) or,
28606                                                                          ; very rarely, a cargo canister (1.5% chance)
28607               
28608               B87:
28609 C0F2 D020  30        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace following a mis-jump, skip the
     C0F4 0D5C     
28610 C0F6 16FB  14        jne  ytq_                       ; BNE ytq           ; following by jumping down to MLOOP (via ytq above)
28611               
28612 C0F8 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C0FA C07C     
28613 C0FC 06A0  32        bl   @jsr                       ;
     C0FE FF10     
28614               
28615 C100 0280  22        ci   ra,>23*256                 ; CMP #35           ; If A >= 35 (87% chance), jump down to MTT1 to skip
     C102 2300     
28616 C104 184F  14        joc  MTT1                       ; BCS MTT1          ; the spawning of an asteroid or cargo canister and
28617                                                                          ; potentially spawn something else
28618               
28619 C106 D020  30        movb @MANY+AST,ra               ; LDA MANY+AST      ; If we already have 3 or more asteroids in the local
     C108 0D57     
28620 C10A 0280  22        ci   ra,>03*256                 ; CMP #3            ; bubble, jump down to MTT1 to skip the following and
     C10C 0300     
28621 C10E 184A  14        joc  MTT1                       ; BCS MTT1          ; potentially spawn something else
28622               
28623 C110 0206  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     C112 BFC0     
28624 C114 06A0  32        bl   @jsr                       ;
     C116 FF10     
28625               
28626 C118 0200  20        li   ra,>26*256                 ; LDA #38           ; Set z_hi = 38 (far away)
     C11A 2600     
28627 C11C D800  30        movb ra,@INWK+7                 ; STA INWK+7
     C11E 005A     
28628               
28629 C120 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A, X and C flag to random numbers
     C122 C07C     
28630 C124 06A0  32        bl   @jsr                       ;
     C126 FF10     
28631               
28632 C128 D800  30        movb ra,@INWK                   ; STA INWK          ; Set x_lo = random
     C12A 0053     
28633               
28634 C12C D801  30        movb rx,@INWK+3                 ; STX INWK+3        ; Set y_lo = random
     C12E 0056     
28635                                                                          ;
28636                                                                          ; Note that because we use the value of X returned by
28637                                                                          ; DORND, and X contains the value of A returned by the
28638                                                                          ; previous call to DORND, this does not set the new ship
28639                                                                          ; to a totally random location. See the deep dive on
28640                                                                          ; "Fixing ship positions" for details
28641               
28642 C130 0240  22        andi ra,>80*256                 ; AND #%10000000    ; Set x_sign = bit 7 of x_lo
     C132 8000     
28643 C134 D800  30        movb ra,@INWK+2                 ; STA INWK+2
     C136 0055     
28644               
28645 C138 D001  18        movb rx,ra                      ; TXA               ; Set y_sign = bit 7 of y_lo
28646 C13A 0240  22        andi ra,>80*256                 ; AND #%10000000
     C13C 8000     
28647 C13E D800  30        movb ra,@INWK+5                 ; STA INWK+5
     C140 0058     
28648               
28649 C142 0208  20        li   rarg1,INWK+1               ; ROL INWK+1        ; Set bit 1 of x_hi to the C flag, which is random, so
     C144 0054     
28650 C146 06A0  32        bl   @rol                       ;
     C148 FF36     
28651 C14A 0208  20        li   rarg1,INWK+1               ; ROL INWK+1        ; this randomly moves us off-centre by 512 (as if x_hi
     C14C 0054     
28652 C14E 06A0  32        bl   @rol                       ;
     C150 FF36     
28653                                                                          ; is %00000010, then (x_hi x_lo) is 512 + x_lo)
28654               
28655 C152 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A, X and V flag to random numbers
     C154 C07C     
28656 C156 06A0  32        bl   @jsr                       ;
     C158 FF10     
28657               
28658                      .bvs MTT4                       ; BVS MTT4          ; If V flag is set (50% chance), jump up to MTT4 to
     **** ****     > BVS
0001 C15A 1801  14        joc  !
0002 C15C 10A9  14        jmp  MTT4
0003               !:
                   < elite.a99
28659                                                                          ; spawn a trader
28660               
28661 C15E 0260  22        ori  ra,>6f*256                 ; ORA #%01101111    ; Take the random number in A and set bits 0-3 and 5-6,
     C160 6F00     
28662 C162 D800  30        movb ra,@INWK+29                ; STA INWK+29       ; so the result has a 50% chance of being positive or
     C164 0070     
28663                                                                          ; negative, and a 50% chance of bits 0-6 being 127.
28664                                                                          ; Storing this number in the roll counter therefore
28665                                                                          ; gives our new ship a fast roll speed with a 50%
28666                                                                          ; chance of having no damping, plus a 50% chance of
28667                                                                          ; rolling clockwise or anti-clockwise
28668               
28669 C166 D020  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump
     C168 0D55     
28670 C16A 161C  14        jne  MTT1                       ; BNE MTT1          ; down to MTT1 to skip the following and potentially
28671                                                                          ; spawn something else
28672               
28673 C16C D001  18        movb rx,ra                      ; TXA               ; Set A to the random X we set above, which we haven't
28674 C16E 1807  14        joc  MTT2                       ; BCS MTT2          ; used yet, and if the C flag is set (50% chance) jump
28675                                                                          ; down to MTT2 to skip the following
28676               
28677 C170 0240  22        andi ra,>1f*256                 ; AND #31           ; Set the ship speed to our random number, set to a
     C172 1F00     
28678 C174 0260  22        ori  ra,>10*256                 ; ORA #16           ; minimum of 16 and a maximum of 31
     C176 1000     
28679 C178 D800  30        movb ra,@INWK+27                ; STA INWK+27
     C17A 006E     
28680               
28681 C17C 1704  14        jnc  MTT3                       ; BCC MTT3          ; Jump down to MTT3, skipping the following (this BCC
28682                                                                          ; is effectively a JMP as we know the C flag is clear,
28683                                                                          ; having passed through the BCS above)
28684               
28685               MTT2:
28686 C17E 0260  22        ori  ra,>7f*256                 ; ORA #%01111111    ; Set bits 0-6 of A to 127, leaving bit 7 as random, so
     C180 7F00     
28687 C182 D800  30        movb ra,@INWK+30                ; STA INWK+30       ; storing this number in the pitch counter means we have
     C184 0071     
28688                                                                          ; full pitch with no damping, with a 50% chance of
28689                                                                          ; pitching up or down
28690               
28691               MTT3:
28692 C186 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C188 C07C     
28693 C18A 06A0  32        bl   @jsr                       ;
     C18C FF10     
28694               
28695 C18E 0280  22        ci   ra,>05*256                 ; CMP #5            ; Set A to the ship number of an asteroid, and keep
     C190 0500     
28696 C192 0200  20        li   ra,(AST)*256               ; LDA #AST          ; this value for 98.5% of the time (i.e. if random
     C194 0A00     
28697 C196 1802  14        joc  B88                        ; BCS B88           ; A >= 5 then skip the following instruction)
28698               
28699 C198 0200  20        li   ra,(OIL)*256               ; LDA #OIL          ; Set A to the ship number of a cargo canister
     C19A 0B00     
28700               
28701               B88:
28702 C19C 0206  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Add our new asteroid or canister to the universe
     C19E AF7A     
28703 C1A0 06A0  32        bl   @jsr                       ;
     C1A2 FF10     
28704               
28705               * ******************************************************************************
28706               *
28707               * Name: Main game loop (Part 3 of 6)
28708               * Type: Subroutine
28709               * Category: Main loop
28710               * Summary: Potentially spawn a cop, particularly if we've been bad
28711               * Deep dive: Program flow of the main game loop
28712               * Ship data blocks
28713               * Fixing ship positions
28714               *
28715               * ------------------------------------------------------------------------------
28716               *
28717               * This section covers the following:
28718               *
28719               * * Potentially spawn a cop (in a Viper), very rarely if we have been good,
28720               * more often if have been naughty, and very often if we have been properly
28721               * bad
28722               *
28723               * ******************************************************************************
28724               
28725               MTT1:
28726 C1A4 D020  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station's safe zone, jump
     C1A6 0D55     
28727 C1A8 1666  14        jne  MLOOP                      ; BNE MLOOP         ; to MLOOP to skip the following
28728               
28729 C1AA 0206  20        li   rtmp,BAD                   ; JSR BAD           ; Call BAD to work out how much illegal contraband we
     C1AC C436     
28730 C1AE 06A0  32        bl   @jsr                       ;
     C1B0 FF10     
28731                                                                          ; are carrying in our hold (A is up to 40 for a
28732                                                                          ; standard hold crammed with contraband, up to 70 for
28733                                                                          ; an extended cargo hold full of narcotics and slaves)
28734               
28735                      .asla                           ; ASL A             ; Double A to a maximum of 80 or 140
     **** ****     > ASLA
0001 C1B2 0240  22        andi ra,>ff00
     C1B4 FF00     
0002 C1B6 0A10  18        sla  ra,1
                   < elite.a99
28736               
28737 C1B8 D060  30        movb @MANY+COPS,rx              ; LDX MANY+COPS     ; If there are no cops in the local bubble, skip the
     C1BA 0D4F     
28738 C1BC 1302  14        jeq  B89                        ; BEQ B89           ; next instruction
28739               
28740 C1BE F020  30        socb @FIST,ra                   ; ORA FIST          ; There are cops in the vicinity and we've got a hold
     C1C0 0334     
28741                                                                          ; full of jail time, so OR the value in A with FIST to
28742                                                                          ; get a new value that is at least as high as both
28743                                                                          ; values, to reflect the fact that they have almost
28744                                                                          ; certainly scanned our ship
28745               
28746               B89:
28747 C1C2 D800  30        movb ra,@T                      ; STA T             ; Store our badness level in T
     C1C4 00D1     
28748               
28749 C1C6 0206  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     C1C8 C032     
28750 C1CA 06A0  32        bl   @jsr                       ;
     C1CC FF10     
28751                                                                          ; ship, and set A and X to random values
28752                                                                          ;
28753                                                                          ; Note that because Ze uses the value of X returned by
28754                                                                          ; DORND, and X contains the value of A returned by the
28755                                                                          ; previous call to DORND, this does not set the new ship
28756                                                                          ; to a totally random location. See the deep dive on
28757                                                                          ; "Fixing ship positions" for details
28758               
28759 C1CE 9020  30        cb   @T,ra                      ; CMP T             ; If the random value in A >= our badness level, which
     C1D0 00D1     
28760 C1D2 1806  14        joc  B90                        ; BCS B90           ; will be the case unless we have been really, really
28761                                                                          ; bad, then skip the following two instructions (so
28762                                                                          ; if we are really bad, there's a higher chance of
28763                                                                          ; spawning a cop, otherwise we got away with it, for
28764                                                                          ; now)
28765               
28766 C1D4 0200  20        li   ra,(COPS)*256              ; LDA #COPS         ; Add a new police ship to the local bubble
     C1D6 0200     
28767 C1D8 0206  20        li   rtmp,NWSHP                 ; JSR NWSHP
     C1DA AF7A     
28768 C1DC 06A0  32        bl   @jsr                       ;
     C1DE FF10     
28769               
28770               B90:
28771 C1E0 D020  30        movb @MANY+COPS,ra              ; LDA MANY+COPS     ; If we now have at least one cop in the local bubble,
     C1E2 0D4F     
28772 C1E4 1648  14        jne  MLOOP                      ; BNE MLOOP         ; jump down to MLOOP, otherwise fall through into the
28773                                                                          ; next part to look at spawning something else
28774               
28775               * ******************************************************************************
28776               *
28777               * Name: Main game loop (Part 4 of 6)
28778               * Type: Subroutine
28779               * Category: Main loop
28780               * Summary: Potentially spawn a lone bounty hunter, a Thargoid, or up to four
28781               * pirates
28782               * Deep dive: Program flow of the main game loop
28783               * Ship data blocks
28784               * Fixing ship positions
28785               *
28786               * ------------------------------------------------------------------------------
28787               *
28788               * This section covers the following:
28789               *
28790               * * Potentially spawn (35% chance) either a lone bounty hunter (a Mamba,
28791               * Python or Cobra Mk III), a Thargoid, or a group of up to 4 pirates
28792               * (Sidewinders and/or Mambas)
28793               *
28794               * ******************************************************************************
28795               
28796 C1E6 7004  18        sb   rone,ra                    ; DEC EV            ; Decrement EV, the extra vessels spawning delay, and
28797 C1E8 1546  14        jgt  MLOOP                      ; BPL MLOOP         ; jump to MLOOP if it is still positive, so we only
28798                                                                          ; do the following when the EV counter runs down
28799               
28800 C1EA B004  18        ab   rone,ra                    ; INC EV            ; EV is negative, so bump it up again, setting it back
28801                                                                          ; to 0
28802               
28803 C1EC 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C1EE C07C     
28804 C1F0 06A0  32        bl   @jsr                       ;
     C1F2 FF10     
28805               
28806 C1F4 D0A0  30        movb @gov_,ry                   ; LDY gov           ; If the government of this system is 0 (anarchy), jump
     C1F6 0F1C     
28807 C1F8 1308  14        jeq  LABEL_2                    ; BEQ LABEL_2       ; straight to LABEL_2 to start spawning pirates or a
28808                                                                          ; lone bounty hunter
28809               
28810 C1FA 0280  22        ci   ra,>5a*256                 ; CMP #90           ; If the random number in A >= 90 (65% chance), jump to
     C1FC 5A00     
28811 C1FE 183B  14        joc  MLOOP                      ; BCS MLOOP         ; MLOOP to stop spawning (so there's a 35% chance of
28812                                                                          ; spawning pirates or a lone bounty hunter)
28813               
28814 C200 0240  22        andi ra,>07*256                 ; AND #7            ; Reduce the random number in A to the range 0-7, and
     C202 0700     
28815 C204 9020  30        cb   @gov_,ra                   ; CMP gov           ; if A is less than government of this system, jump
     C206 0F1C     
28816 C208 1736  14        jnc  MLOOP                      ; BCC MLOOP         ; to MLOOP to stop spawning (so safer governments with
28817                                                                          ; larger gov numbers have a greater chance of jumping
28818                                                                          ; out, which is another way of saying that more
28819                                                                          ; dangerous systems spawn pirates and bounty hunters
28820                                                                          ; more often)
28821               
28822               LABEL_2:
28823                                                                          ; Now to spawn a lone bounty hunter, a Thargoid or a
28824                                                                          ; group of pirates
28825 C20A 0206  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     C20C C032     
28826 C20E 06A0  32        bl   @jsr                       ;
     C210 FF10     
28827                                                                          ; ship, and set A and X to random values
28828                                                                          ;
28829                                                                          ; Note that because Ze uses the value of X returned by
28830                                                                          ; DORND, and X contains the value of A returned by the
28831                                                                          ; previous call to DORND, this does not set the new ship
28832                                                                          ; to a totally random location. See the deep dive on
28833                                                                          ; "Fixing ship positions" for details
28834               
28835 C212 0280  22        ci   ra,>c8*256                 ; CMP #200          ; If the random number in A >= 200 (13% chance), jump
     C214 C800     
28836 C216 181B  14        joc  mt1_                       ; BCS mt1           ; to mt1 to spawn pirates, otherwise keep going to
28837                                                                          ; spawn a lone bounty hunter or a Thargoid
28838               
28839 C218 B004  18        ab   rone,ra                    ; INC EV            ; Increase the extra vessels spawning counter, to
28840                                                                          ; prevent the next attempt to spawn extra vessels
28841               
28842 C21A 0240  22        andi ra,>03*256                 ; AND #3            ; Set A = Y = random number in the range 3-6, which
     C21C 0300     
28843                      .adi (>03*256)                  ; ADC #3            ; we will use to determine the type of ship
     **** ****     > ADI
0001 C21E 1701  14        jnc  !
0002 C220 B004  18        ab   rone,ra
0003               !:
0004 C222 0220  22        ai   ra,(>03*256)
     C224 0300     
                   < elite.a99
28844 C226 D080  18        movb ra,ry                      ; TAY
28845               
28846                                                                          ; We now build the AI flag for this ship in A
28847               
28848 C228 D001  18        movb rx,ra                      ; TXA               ; First, copy the random number in X to A
28849               
28850 C22A 0280  22        ci   ra,>c8*256                 ; CMP #200          ; First, set the C flag if X >= 200 (22% chance)
     C22C C800     
28851               
28852 C22E 06A0  32        bl   @rola                      ; ROL A             ; Set bit 0 of A to the C flag (i.e. there's a 22%
     C230 FF26     
28853                                                                          ; chance of this ship having E.C.M.)
28854               
28855 C232 0260  22        ori  ra,>c0*256                 ; ORA #%11000000    ; Set bits 6 and 7 of A, so the ship is hostile (bit 6)
     C234 C000     
28856                                                                          ; and has AI (bit 7)
28857               
28858 C236 0282  22        ci   ry,>06*256                 ; CPY #6            ; If Y = 6 (i.e. a Thargoid), jump down to the tha
     C238 0600     
28859 C23A 1347  14        jeq  tha_                       ; BEQ tha           ; routine in part 6 to decide whether or not to spawn it
28860                                                                          ; (where there's a 22% chance of this happening)
28861               
28862 C23C D800  30        movb ra,@INWK+32                ; STA INWK+32       ; Store A in the AI flag of this ship
     C23E 0073     
28863               
28864 C240 D002  18        movb ry,ra                      ; TYA               ; Add a new ship of type Y to the local bubble, so
28865 C242 0206  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; that's a Mamba, Cobra Mk III or Python
     C244 AF7A     
28866 C246 06A0  32        bl   @jsr                       ;
     C248 FF10     
28867               
28868               mj1_:
28869 C24A 0460  28        b    @MLOOP                     ; JMP MLOOP         ; Jump down to MLOOP, as we are done spawning ships
     C24C C276     
28870               
28871               mt1_:
28872 C24E 0240  22        andi ra,>03*256                 ; AND #3            ; It's time to spawn a group of pirates, so set A to a
     C250 0300     
28873                                                                          ; random number in the range 0-3, which will be the
28874                                                                          ; loop counter for spawning pirates below (so we will
28875                                                                          ; spawn 1-4 pirates)
28876               
28877 C252 D800  30        movb ra,@EV                     ; STA EV            ; Delay further spawnings by this number
     C254 0D63     
28878               
28879 C256 D800  30        movb ra,@XX13                   ; STA XX13          ; Store the number in XX13, the pirate counter
     C258 0098     
28880               
28881               mt3_:
28882 C25A 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C25C C07C     
28883 C25E 06A0  32        bl   @jsr                       ;
     C260 FF10     
28884               
28885 C262 0240  22        andi ra,>03*256                 ; AND #3            ; Set A to a random number in the range 0-3
     C264 0300     
28886               
28887 C266 0260  22        ori  ra,>01*256                 ; ORA #1            ; Set A to %01 or %11 (Sidewinder or Mamba)
     C268 0100     
28888               
28889 C26A 0206  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Try adding a new ship of type A to the local bubble
     C26C AF7A     
28890 C26E 06A0  32        bl   @jsr                       ;
     C270 FF10     
28891               
28892 C272 7004  18        sb   rone,ra                    ; DEC XX13          ; Decrement the pirate counter
28893               
28894 C274 15F2  14        jgt  mt3_                       ; BPL mt3           ; If we need more pirates, loop back up to mt3,
28895                                                                          ; otherwise we are done spawning, so fall through into
28896                                                                          ; the end of the main loop at MLOOP
28897               
28898               * ******************************************************************************
28899               *
28900               * Name: Main game loop (Part 5 of 6)
28901               * Type: Subroutine
28902               * Category: Main loop
28903               * Summary: Cool down lasers, make calls to update the dashboard
28904               * Deep dive: Program flow of the main game loop
28905               * The dashboard indicators
28906               *
28907               * ------------------------------------------------------------------------------
28908               *
28909               * This is the first half of the minimal game loop, which we iterate when we are
28910               * docked. This section covers the following:
28911               *
28912               * * Cool down lasers
28913               *
28914               * * Make calls to update the dashboard
28915               *
28916               * ------------------------------------------------------------------------------
28917               *
28918               * Other entry points:
28919               *
28920               * MLOOP               The entry point for the main game loop. This entry point
28921               * comes after the call to the main flight loop and
28922               * spawning routines, so it marks the start of the main
28923               * game loop for when we are docked (as we don't need to
28924               * call the main flight loop or spawning routines if we
28925               * aren't in space)
28926               *
28927               * ******************************************************************************
28928               
28929               MLOOP:
28930 C276 0200  20        li   ra,>01*256                 ; LDA #%00000001    ; Set 6522 System VIA interrupt enable register IER
     C278 0100     
28931 C27A D800  38        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. disable the CA2 interrupt,
     C27C FE4E     
28932                                                                          ; which comes from the keyboard)
28933               
28934 C27E 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Set the stack pointer to &01FF, which is the standard
     C280 FF00     
28935 C282 D801  38        movb rx,@rsplb                  ; TXS               ; location for the 6502 stack, so this instruction
     C284 2081     
28936                                                                          ; effectively resets the stack
28937               
28938 C286 D060  30        movb @GNTMP,rx                  ; LDX GNTMP         ; If the laser temperature in GNTMP is non-zero,
     C288 0D61     
28939 C28A 1301  14        jeq  EE20                       ; BEQ EE20          ; decrement it (i.e. cool it down a bit)
28940 C28C 7004  18        sb   rone,ra                    ; DEC GNTMP
28941               
28942               EE20:
28943 C28E 0206  20        li   rtmp,DIALS                 ; JSR DIALS         ; Call DIALS to update the dashboard
     C290 3272     
28944 C292 06A0  32        bl   @jsr                       ;
     C294 FF10     
28945               
28946 C296 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is a space view, skip the following four
     C298 0096     
28947 C29A 130A  14        jeq  B91                        ; BEQ B91           ; instructions (i.e. jump to JSR TT17 below)
28948               
28949                      .and @PATG                      ; AND PATG          ; If PATG = &FF (author names are shown on start-up)
     **** ****     > AND
0001 C29C D1A0  30        movb @PATG,rtmp
     C29E 0F4C     
0002 C2A0 0546  14        inv  rtmp
0003 C2A2 5006  18        szcb rtmp,ra
                   < elite.a99
28950 C2A4 0910  18        srl  ra,1                       ; LSR A             ; and bit 0 of QQ11 is 1 (the current view is type 1),
28951 C2A6 1804  14        joc  B91                        ; BCS B91           ; then skip the following instruction
28952               
28953 C2A8 0206  20        li   rtmp,DELAY-5               ; JSR DELAY-5       ; Delay for 8 vertical syncs (8/50 = 0.16 seconds), to
     C2AA 4BFB     
28954 C2AC 06A0  32        bl   @jsr                       ;
     C2AE FF10     
28955                                                                          ; slow the main loop down a bit
28956               
28957               B91:
28958 C2B0 0206  20        li   rtmp,TT17                  ; JSR TT17          ; Scan the keyboard for the cursor keys or joystick,
     C2B2 BB94     
28959 C2B4 06A0  32        bl   @jsr                       ;
     C2B6 FF10     
28960                                                                          ; returning the cursor's delta values in X and Y and
28961                                                                          ; the key pressed in A
28962               
28963               * ******************************************************************************
28964               *
28965               * Name: Main game loop (Part 6 of 6)
28966               * Type: Subroutine
28967               * Category: Main loop
28968               * Summary: Process non-flight key presses (red function keys, docked keys)
28969               * Deep dive: Program flow of the main game loop
28970               *
28971               * ------------------------------------------------------------------------------
28972               *
28973               * This is the second half of the minimal game loop, which we iterate when we are
28974               * docked. This section covers the following:
28975               *
28976               * * Process more key presses (red function keys, docked keys etc.)
28977               *
28978               * It also supports joining the main loop with a key already "pressed", so we can
28979               * jump into the main game loop to perform a specific action. In practice, this
28980               * is used when we enter the docking bay in BAY to display Status Mode (red key
28981               * f8), and when we finish buying or selling cargo in BAY2 to jump to the
28982               * Inventory (red key f9).
28983               *
28984               * ------------------------------------------------------------------------------
28985               *
28986               * Other entry points:
28987               *
28988               * FRCE                The entry point for the main game loop if we want to
28989               * jump straight to a specific screen, by pretending to
28990               * "press" a key, in which case A contains the internal key
28991               * number of the key we want to "press"
28992               *
28993               * tha                 Consider spawning a Thargoid (22% chance)
28994               *
28995               * ******************************************************************************
28996               
28997               FRCE:
28998 C2B8 0206  20        li   rtmp,TT102                 ; JSR TT102         ; Call TT102 to process the key pressed in A
     C2BA C2E4     
28999 C2BC 06A0  32        bl   @jsr                       ;
     C2BE FF10     
29000               
29001 C2C0 D020  30        movb @QQ12,ra                   ; LDA QQ12          ; Fetch the docked flag from QQ12 into A
     C2C2 009F     
29002               
29003 C2C4 16D8  14        jne  MLOOP                      ; BNE MLOOP         ; If we are docked, loop back up to MLOOP just above
29004                                                                          ; to restart the main loop, but skipping all the flight
29005                                                                          ; and spawning code in the top part of the main loop
29006               
29007 C2C6 0460  28        b    @TT100                     ; JMP TT100         ; Otherwise jump to TT100 to restart the main loop from
     C2C8 C0DA     
29008                                                                          ; the start
29009               
29010               tha_:
29011 C2CA 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C2CC C07C     
29012 C2CE 06A0  32        bl   @jsr                       ;
     C2D0 FF10     
29013               
29014 C2D2 0280  22        ci   ra,>c8*256                 ; CMP #200          ; If A < 200 (78% chance), skip the next instruction
     C2D4 C800     
29015 C2D6 1704  14        jnc  B92                        ; BCC B92
29016               
29017 C2D8 0206  20        li   rtmp,GTHG                  ; JSR GTHG          ; Call GTHG to spawn a Thargoid ship and a Thargon
     C2DA A000     
29018 C2DC 06A0  32        bl   @jsr                       ;
     C2DE FF10     
29019                                                                          ; companion
29020               
29021               B92:
29022 C2E0 0460  28        b    @MLOOP                     ; JMP MLOOP         ; Jump back into the main loop at MLOOP, which is just
     C2E2 C276     
29023                                                                          ; after the ship-spawning section
29024               
29025               * ******************************************************************************
29026               *
29027               * Name: TT102
29028               * Type: Subroutine
29029               * Category: Keyboard
29030               * Summary: Process function key, save key, hyperspace and chart key presses
29031               * and update the hyperspace counter
29032               *
29033               * ------------------------------------------------------------------------------
29034               *
29035               * Process function key presses, plus "@" (save commander), "H" (hyperspace),
29036               * "D" (show distance to system) and "O" (move chart cursor back to current
29037               * system). We can also pass cursor position deltas in X and Y to indicate that
29038               * the cursor keys or joystick have been used (i.e. the values that are returned
29039               * by routine TT17).
29040               *
29041               * ------------------------------------------------------------------------------
29042               *
29043               * Arguments:
29044               *
29045               * A                   The internal key number of the key pressed (see p.142 of
29046               * the Advanced User Guide for a list of internal key
29047               * numbers)
29048               *
29049               * X                   The amount to move the crosshairs in the x-axis
29050               *
29051               * Y                   The amount to move the crosshairs in the y-axis
29052               *
29053               * ------------------------------------------------------------------------------
29054               *
29055               * Other entry points:
29056               *
29057               * T95                 Print the distance to the selected system
29058               *
29059               * ******************************************************************************
29060               
29061               TT102:
29062 C2E4 0280  22        ci   ra,(f8_)*256               ; CMP #f8           ; If red key f8 was pressed, jump to STATUS to show the
     C2E6 7600     
29063 C2E8 1602  14        jne  B93                        ; BNE B93           ; Status Mode screen, returning from the subroutine
29064 C2EA 0460  28        b    @STATUS                    ; JMP STATUS        ; using a tail call
     C2EC 2E26     
29065               
29066               B93:
29067 C2EE 0280  22        ci   ra,(f4_)*256               ; CMP #f4           ; If red key f4 was pressed, jump to TT22 to show the
     C2F0 1400     
29068 C2F2 1602  14        jne  B94                        ; BNE B94           ; Long-range Chart, returning from the subroutine using
29069 C2F4 0460  28        b    @TT22                      ; JMP TT22          ; a tail call
     C2F6 5272     
29070               
29071               B94:
29072 C2F8 0280  22        ci   ra,(f5_)*256               ; CMP #f5           ; If red key f5 was pressed, jump to TT23 to show the
     C2FA 7400     
29073 C2FC 1602  14        jne  B95                        ; BNE B95           ; Short-range Chart, returning from the subroutine using
29074 C2FE 0460  28        b    @TT23                      ; JMP TT23          ; a tail call
     C300 592A     
29075               
29076               B95:
29077 C302 0280  22        ci   ra,(f6_)*256               ; CMP #f6           ; If red key f6 was pressed, call TT111 to select the
     C304 7500     
29078 C306 1606  14        jne  TT92                       ; BNE TT92          ; system nearest to galactic coordinates (QQ9, QQ10)
29079 C308 0206  20        li   rtmp,TT111                 ; JSR TT111         ; (the location of the chart crosshairs) and jump to
     C30A 5AB8     
29080 C30C 06A0  32        bl   @jsr                       ;
     C30E FF10     
29081 C310 0460  28        b    @TT25                      ; JMP TT25          ; TT25 to show the Data on System screen, returning
     C312 4F0A     
29082                                                                          ; from the subroutine using a tail call
29083               
29084               TT92:
29085 C314 0280  22        ci   ra,(f9_)*256               ; CMP #f9           ; If red key f9 was pressed, jump to TT213 to show the
     C316 7700     
29086 C318 1602  14        jne  B96                        ; BNE B96           ; Inventory screen, returning from the subroutine
29087 C31A 0460  28        b    @TT213                     ; JMP TT213         ; using a tail call
     C31C 5778     
29088               
29089               B96:
29090 C31E 0280  22        ci   ra,(f7_)*256               ; CMP #f7           ; If red key f7 was pressed, jump to TT167 to show the
     C320 1600     
29091 C322 1602  14        jne  B97                        ; BNE B97           ; Market Price screen, returning from the subroutine
29092 C324 0460  28        b    @TT167                     ; JMP TT167         ; using a tail call
     C326 5E9C     
29093               
29094               B97:
29095 C328 0280  22        ci   ra,(f0_)*256               ; CMP #f0           ; If red key f0 was pressed, jump to TT110 to launch our
     C32A 2000     
29096 C32C 1602  14        jne  fvw_                       ; BNE fvw           ; ship (if docked), returning from the subroutine using
29097 C32E 0460  28        b    @TT110                     ; JMP TT110         ; a tail call
     C330 A10A     
29098               
29099               fvw_:
29100                      .bit @QQ12                      ; BIT QQ12          ; If bit 7 of QQ12 is clear (i.e. we are not docked, but
     **** ****     > BIT
0001 C332 D1A0  30        movb @QQ12,rtmp
     C334 009F     
0002 C336 0546  14        inv  rtmp
0003 C338 D1C4  18        movb rone,rtmp2
0004 C33A 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
29101 C33C 1514  14        jgt  INSP                       ; BPL INSP          ; in space), jump to INSP to skip the following checks
29102                                                                          ; for f1-f3 and "@" (save commander file) key presses
29103               
29104 C33E 0280  22        ci   ra,(f3_)*256               ; CMP #f3           ; If red key f3 was pressed, jump to EQSHP to show the
     C340 7300     
29105 C342 1602  14        jne  B98                        ; BNE B98           ; Equip Ship screen, returning from the subroutine using
29106 C344 0460  28        b    @EQSHP                     ; JMP EQSHP         ; a tail call
     C346 A23C     
29107               
29108               B98:
29109 C348 0280  22        ci   ra,(f1_)*256               ; CMP #f1           ; If red key f1 was pressed, jump to TT219 to show the
     C34A 7100     
29110 C34C 1602  14        jne  B99                        ; BNE B99           ; Buy Cargo screen, returning from the subroutine using
29111 C34E 0460  28        b    @TT219                     ; JMP TT219         ; a tail call
     C350 5476     
29112               
29113               B99:
29114 C352 0280  22        ci   ra,>47*256                 ; CMP #&47          ; If "@" was pressed, jump to SVE to save the commander
     C354 4700     
29115 C356 1602  14        jne  B100                       ; BNE B100          ; file, returning from the subroutine using a tail call
29116 C358 0460  28        b    @SVE                       ; JMP SVE
     C35A C844     
29117               
29118               B100:
29119 C35C 0280  22        ci   ra,(f2_)*256               ; CMP #f2           ; If red key f2 was pressed, jump to TT208 to show the
     C35E 7200     
29120 C360 160D  14        jne  LABEL_3                    ; BNE LABEL_3       ; Sell Cargo screen, returning from the subroutine using
29121 C362 0460  28        b    @TT208                     ; JMP TT208         ; a tail call
     C364 5654     
29122               
29123               INSP:
29124 C366 0280  22        ci   ra,(f1_)*256               ; CMP #f1           ; If the key pressed is < red key f1 or > red key f3,
     C368 7100     
29125 C36A 1708  14        jnc  LABEL_3                    ; BCC LABEL_3       ; jump to LABEL_3 (so only do the following if the key
29126 C36C 0280  22        ci   ra,(f3_+1)*256             ; CMP #f3+1         ; pressed is f1, f2 or f3)
     C36E 7400     
29127 C370 1805  14        joc  LABEL_3                    ; BCS LABEL_3
29128               
29129 C372 0240  22        andi ra,>03*256                 ; AND #3            ; If we get here then we are either in space, or we are
     C374 0300     
29130 C376 D040  18        movb ra,rx                      ; TAX               ; docked and none of f1-f3 were pressed, so we can now
29131 C378 0460  28        b    @LOOK1                     ; JMP LOOK1         ; process f1-f3 with their in-flight functions, i.e.
     C37A 4AC4     
29132                                                                          ; switching space views
29133                                                                          ;
29134                                                                          ; A will contain &71, &72 or &73 (for f1, f2 or f3), so
29135                                                                          ; set X to the last digit (1, 2 or 3) and jump to LOOK1
29136                                                                          ; to switch to view X (rear, left or right), returning
29137                                                                          ; from the subroutine using a tail call
29138               
29139               LABEL_3:
29140 C37C 0280  22        ci   ra,>54*256                 ; CMP #&54          ; If "H" was pressed, jump to hyp to do a hyperspace
     C37E 5400     
29141 C380 1602  14        jne  B101                       ; BNE B101          ; jump (if we are in space), returning from the
29142 C382 0460  28        b    @hyp_                      ; JMP hyp           ; subroutine using a tail call
     C384 5C2C     
29143               
29144               B101:
29145 C386 0280  22        ci   ra,>32*256                 ; CMP #&32          ; If "D" was pressed, jump to T95 to print the distance
     C388 3200     
29146 C38A 133B  14        jeq  T95                        ; BEQ T95           ; to a system (if we are in one of the chart screens)
29147               
29148 C38C D800  30        movb ra,@T1                     ; STA T1            ; Store A (the key that's been pressed) in T1
     C38E 0006     
29149               
29150 C390 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is a chart (QQ11 = 64 or 128),
     C392 0096     
29151 C394 0240  22        andi ra,>c0*256                 ; AND #%11000000    ; keep going, otherwise jump down to TT107 to skip the
     C396 C000     
29152 C398 1318  14        jeq  TT107                      ; BEQ TT107         ; following
29153               
29154 C39A D020  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; If the on-screen hyperspace counter is non-zero,
     C39C 002F     
29155 C39E 1615  14        jne  TT107                      ; BNE TT107         ; then we are already counting down, so jump to TT107
29156                                                                          ; to skip the following
29157               
29158 C3A0 D020  30        movb @T1,ra                     ; LDA T1            ; Restore the original value of A (the key that's been
     C3A2 0006     
29159                                                                          ; pressed) from T1
29160               
29161 C3A4 0280  22        ci   ra,>36*256                 ; CMP #&36          ; If "O" was pressed, do the following three jumps,
     C3A6 3600     
29162 C3A8 160C  14        jne  ee2_                       ; BNE ee2           ; otherwise skip to ee2 to continue
29163               
29164 C3AA 0206  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     C3AC 5872     
29165 C3AE 06A0  32        bl   @jsr                       ;
     C3B0 FF10     
29166                                                                          ; which will erase the crosshairs currently there
29167               
29168 C3B2 0206  20        li   rtmp,ping_                 ; JSR ping          ; Set the target system to the current system (which
     C3B4 BC2C     
29169 C3B6 06A0  32        bl   @jsr                       ;
     C3B8 FF10     
29170                                                                          ; will move the location in (QQ9, QQ10) to the current
29171                                                                          ; home system
29172               
29173 C3BA 0206  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     C3BC 5872     
29174 C3BE 06A0  32        bl   @jsr                       ;
     C3C0 FF10     
29175                                                                          ; which will draw the crosshairs at our current home
29176                                                                          ; system
29177               
29178               ee2_:
29179 C3C2 0206  20        li   rtmp,TT16                  ; JSR TT16          ; Call TT16 to move the crosshairs by the amount in X
     C3C4 580E     
29180 C3C6 06A0  32        bl   @jsr                       ;
     C3C8 FF10     
29181                                                                          ; and Y, which were passed to this subroutine as
29182                                                                          ; arguments
29183               
29184               TT107:
29185 C3CA D020  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; If the on-screen hyperspace counter is zero, return
     C3CC 002F     
29186 C3CE 1317  14        jeq  t95_                       ; BEQ t95           ; from the subroutine (as t95 contains an RTS), as we
29187                                                                          ; are not currently counting down to a hyperspace jump
29188               
29189 C3D0 7004  18        sb   rone,ra                    ; DEC QQ22          ; Decrement the internal hyperspace counter
29190               
29191 C3D2 1615  14        jne  t95_                       ; BNE t95           ; If the internal hyperspace counter is still non-zero,
29192                                                                          ; then we are still counting down, so return from the
29193                                                                          ; subroutine (as t95 contains an RTS)
29194               
29195                                                                          ; If we get here then the internal hyperspace counter
29196                                                                          ; has just reached zero and it wasn't zero before, so
29197                                                                          ; we need to reduce the on-screen counter and update
29198                                                                          ; the screen. We do this by first printing the next
29199                                                                          ; number in the countdown sequence, and then printing
29200                                                                          ; the old number, which will erase the old number
29201                                                                          ; and display the new one because printing uses EOR
29202                                                                          ; logic
29203               
29204 C3D4 D060  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Set X = the on-screen hyperspace counter - 1
     C3D6 002F     
29205 C3D8 7044  18        sb   rone,rx                    ; DEX               ; (i.e. the next number in the sequence)
29206               
29207 C3DA 0206  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1)
     C3DC 5D36     
29208 C3DE 06A0  32        bl   @jsr                       ;
     C3E0 FF10     
29209               
29210 C3E2 0200  20        li   ra,>05*256                 ; LDA #5            ; Reset the internal hyperspace counter to 5
     C3E4 0500     
29211 C3E6 D800  30        movb ra,@QQ22                   ; STA QQ22
     C3E8 002E     
29212               
29213 C3EA D060  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Set X = the on-screen hyperspace counter (i.e. the
     C3EC 002F     
29214                                                                          ; current number in the sequence, which is already
29215                                                                          ; shown on-screen)
29216               
29217 C3EE 0206  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1),
     C3F0 5D36     
29218 C3F2 06A0  32        bl   @jsr                       ;
     C3F4 FF10     
29219                                                                          ; i.e. print the hyperspace countdown in the top-left
29220                                                                          ; corner
29221               
29222 C3F6 7004  18        sb   rone,ra                    ; DEC QQ22+1        ; Decrement the on-screen hyperspace countdown
29223               
29224 C3F8 1602  14        jne  t95_                       ; BNE t95           ; If the countdown is not yet at zero, return from the
29225                                                                          ; subroutine (as t95 contains an RTS)
29226               
29227 C3FA 0460  28        b    @TT18                      ; JMP TT18          ; Otherwise the countdown has finished, so jump to TT18
     C3FC A088     
29228                                                                          ; to do a hyperspace jump, returning from the subroutine
29229                                                                          ; using a tail call
29230               
29231               t95_:
29232 C3FE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C400 FF1C     
29233               
29234               T95:
29235                                                                          ; If we get here, "D" was pressed, so we need to show
29236                                                                          ; the distance to the selected system (if we are in a
29237                                                                          ; chart view)
29238 C402 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is a chart (QQ11 = 64 or 128),
     C404 0096     
29239 C406 0240  22        andi ra,>c0*256                 ; AND #%11000000    ; keep going, otherwise return from the subroutine (as
     C408 C000     
29240 C40A 13F9  14        jeq  t95_                       ; BEQ t95           ; t95 contains an RTS)
29241               
29242 C40C 0206  20        li   rtmp,hm_                   ; JSR hm            ; Call hm to move the crosshairs to the target system
     C40E 4C10     
29243 C410 06A0  32        bl   @jsr                       ;
     C412 FF10     
29244                                                                          ; in (QQ9, QQ10), returning with A = 0
29245               
29246 C414 D800  30        movb ra,@QQ17                   ; STA QQ17          ; Set QQ17 = 0 to switch to ALL CAPS
     C416 007E     
29247               
29248 C418 0206  20        li   rtmp,cpl_                  ; JSR cpl           ; Print control code 3 (the selected system name)
     C41A A5C4     
29249 C41C 06A0  32        bl   @jsr                       ;
     C41E FF10     
29250               
29251 C420 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     C422 8000     
29252 C424 D800  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     C426 007E     
29253               
29254 C428 0200  20        li   ra,>01*256                 ; LDA #1            ; Move the text cursor to column 1 and down one line
     C42A 0100     
29255 C42C D800  30        movb ra,@XC                     ; STA XC            ; (in other words, to the start of the next line)
     C42E 002C     
29256 C430 B004  18        ab   rone,ra                    ; INC YC
29257               
29258 C432 0460  28        b    @TT146                     ; JMP TT146         ; Print the distance to the selected system and return
     C434 4EA2     
29259                                                                          ; from the subroutine using a tail call
29260               
29261               * ******************************************************************************
29262               *
29263               * Name: BAD
29264               * Type: Subroutine
29265               * Category: Status
29266               * Summary: Calculate how bad we have been
29267               *
29268               * ------------------------------------------------------------------------------
29269               *
29270               * Work out how bad we are from the amount of contraband in our hold. The
29271               * formula is:
29272               *
29273               * (slaves + narcotics) * 2 + firearms
29274               *
29275               * so slaves and narcotics are twice as illegal as firearms. The value in FIST
29276               * (our legal status) is set to at least this value whenever we launch from a
29277               * space station, and a FIST of 50 or more gives us fugitive status, so leaving a
29278               * station carrying 25 tonnes of slaves/narcotics, or 50 tonnes of firearms
29279               * across multiple trips, is enough to make us a fugitive.
29280               *
29281               * ------------------------------------------------------------------------------
29282               *
29283               * Returns:
29284               *
29285               * A                   A value that determines how bad we are from the amount
29286               * of contraband in our hold
29287               *
29288               * ******************************************************************************
29289               
29290               BAD:
29291 C436 D020  30        movb @QQ20+3,ra                 ; LDA QQ20+3        ; Set A to the number of tonnes of slaves in the hold
     C438 031A     
29292               
29293                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 C43A 0A13  18        sla  rzero,1
                   < elite.a99
29294                                                                          ; C flag affecting the result
29295               
29296                      .adc @QQ20+6,ra                 ; ADC QQ20+6        ; Add the number of tonnes of narcotics in the hold
     **** ****     > ADC
0001 C43C 1701  14        jnc  !
0002 C43E B004  18        ab   rone,ra
0003               !:
0004 C440 B020  30        ab   @QQ20+6,ra
     C442 031D     
                   < elite.a99
29297               
29298                      .asla                           ; ASL A             ; Double the result and add the number of tonnes of
     **** ****     > ASLA
0001 C444 0240  22        andi ra,>ff00
     C446 FF00     
0002 C448 0A10  18        sla  ra,1
                   < elite.a99
29299                      .adc @QQ20+10,ra                ; ADC QQ20+10       ; firearms in the hold
     **** ****     > ADC
0001 C44A 1701  14        jnc  !
0002 C44C B004  18        ab   rone,ra
0003               !:
0004 C44E B020  30        ab   @QQ20+10,ra
     C450 0321     
                   < elite.a99
29300               
29301 C452 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C454 FF1C     
29302               
29303               * ******************************************************************************
29304               *
29305               * Name: FAROF
29306               * Type: Subroutine
29307               * Category: Maths (Geometry)
29308               * Summary: Compare x_hi, y_hi and z_hi with 224
29309               *
29310               * ------------------------------------------------------------------------------
29311               *
29312               * Compare x_hi, y_hi and z_hi with 224, and set the C flag if all three <= 224,
29313               * otherwise clear the C flag.
29314               *
29315               * ------------------------------------------------------------------------------
29316               *
29317               * Returns:
29318               *
29319               * C flag              Set if x_hi <= 224 and y_hi <= 224 and z_hi <= 224
29320               *
29321               * Clear otherwise (i.e. if any one of them are bigger than
29322               * 224)
29323               *
29324               * ******************************************************************************
29325               
29326               FAROF:
29327 C456 0200  20        li   ra,>e0*256                 ; LDA #224          ; Set A = 224 and fall through into FAROF2 to do the
     C458 E000     
29328                                                                          ; comparison
29329               
29330               * ******************************************************************************
29331               *
29332               * Name: FAROF2
29333               * Type: Subroutine
29334               * Category: Maths (Geometry)
29335               * Summary: Compare x_hi, y_hi and z_hi with A
29336               *
29337               * ------------------------------------------------------------------------------
29338               *
29339               * Compare x_hi, y_hi and z_hi with A, and set the C flag if all three <= A,
29340               * otherwise clear the C flag.
29341               *
29342               * ------------------------------------------------------------------------------
29343               *
29344               * Returns:
29345               *
29346               * C flag              Set if x_hi <= A and y_hi <= A and z_hi <= A
29347               *
29348               * Clear otherwise (i.e. if any one of them are bigger than
29349               * A)
29350               *
29351               * ******************************************************************************
29352               
29353               FAROF2:
29354 C45A 9020  30        cb   @INWK+1,ra                 ; CMP INWK+1        ; If A < x_hi, C will be clear so jump to MA34 to
     C45C 0054     
29355 C45E 1705  14        jnc  MA34                       ; BCC MA34          ; return from the subroutine with C clear, otherwise
29356                                                                          ; C will be set so move on to the next one
29357               
29358 C460 9020  30        cb   @INWK+4,ra                 ; CMP INWK+4        ; If A < y_hi, C will be clear so jump to MA34 to
     C462 0057     
29359 C464 1702  14        jnc  MA34                       ; BCC MA34          ; return from the subroutine with C clear, otherwise
29360                                                                          ; C will be set so move on to the next one
29361               
29362 C466 9020  30        cb   @INWK+7,ra                 ; CMP INWK+7        ; If A < z_hi, C will be clear, otherwise C will be set
     C468 005A     
29363               
29364               MA34:
29365 C46A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C46C FF1C     
29366               
29367               * ******************************************************************************
29368               *
29369               * Name: MAS4
29370               * Type: Subroutine
29371               * Category: Maths (Geometry)
29372               * Summary: Calculate a cap on the maximum distance to a ship
29373               *
29374               * ------------------------------------------------------------------------------
29375               *
29376               * Logical OR the value in A with the high bytes of the ship's position (x_hi,
29377               * y_hi and z_hi).
29378               *
29379               * ------------------------------------------------------------------------------
29380               *
29381               * Returns:
29382               *
29383               * A                   A OR x_hi OR y_hi OR z_hi
29384               *
29385               * ******************************************************************************
29386               
29387               MAS4:
29388 C46E F020  30        socb @INWK+1,ra                 ; ORA INWK+1        ; OR A with x_hi, y_hi and z_hi
     C470 0054     
29389 C472 F020  30        socb @INWK+4,ra                 ; ORA INWK+4
     C474 0057     
29390 C476 F020  30        socb @INWK+7,ra                 ; ORA INWK+7
     C478 005A     
29391               
29392 C47A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C47C FF1C     
29393               
29394               * ******************************************************************************
29395               *
29396               * Name: DEATH
29397               * Type: Subroutine
29398               * Category: Start and end
29399               * Summary: Display the death screen
29400               *
29401               * ------------------------------------------------------------------------------
29402               *
29403               * We have been killed, so display the chaos of our destruction above a "GAME
29404               * OVER" sign, and clean up the mess ready for the next attempt.
29405               *
29406               * ******************************************************************************
29407               
29408               DEATH:
29409 C47E 0206  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of us dying
     C480 CB2E     
29410 C482 06A0  32        bl   @jsr                       ;
     C484 FF10     
29411               
29412 C486 0206  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     C488 BF32     
29413 C48A 06A0  32        bl   @jsr                       ;
     C48C FF10     
29414               
29415                      .asl @DELTA                     ; ASL DELTA         ; Divide our speed in DELTA by 4
     **** ****     > ASL
0001 C48E D1A0  30        movb @DELTA,rtmp
     C490 008C     
0002 C492 0246  22        andi rtmp,>ff00
     C494 FF00     
0003 C496 0A16  18        sla  rtmp,1
0004 C498 D806  30        movb rtmp,@DELTA
     C49A 008C     
                   < elite.a99
29416                      .asl @DELTA                     ; ASL DELTA
     **** ****     > ASL
0001 C49C D1A0  30        movb @DELTA,rtmp
     C49E 008C     
0002 C4A0 0246  22        andi rtmp,>ff00
     C4A2 FF00     
0003 C4A4 0A16  18        sla  rtmp,1
0004 C4A6 D806  30        movb rtmp,@DELTA
     C4A8 008C     
                   < elite.a99
29417               
29418 C4AA 0201  20        li   rx,>18*256                 ; LDX #24           ; Set the screen to only show 24 text rows, which hides
     C4AC 1800     
29419 C4AE 0206  20        li   rtmp,DET1                  ; JSR DET1          ; the dashboard, setting A to 6 in the process
     C4B0 ACC0     
29420 C4B2 06A0  32        bl   @jsr                       ;
     C4B4 FF10     
29421               
29422 C4B6 0206  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     C4B8 4B2A     
29423 C4BA 06A0  32        bl   @jsr                       ;
     C4BC FF10     
29424                                                                          ; and set the current view type in QQ11 to 6 (death
29425                                                                          ; screen)
29426               
29427 C4BE 0206  20        li   rtmp,BOX                   ; JSR BOX           ; Call BOX to redraw the same white border (BOX is part
     C4C0 4B6A     
29428 C4C2 06A0  32        bl   @jsr                       ;
     C4C4 FF10     
29429                                                                          ; of TT66), which removes the border as it is drawn
29430                                                                          ; using EOR logic
29431               
29432 C4C6 0206  20        li   rtmp,nWq                   ; JSR nWq           ; Create a cloud of stardust containing the correct
     C4C8 ABEC     
29433 C4CA 06A0  32        bl   @jsr                       ;
     C4CC FF10     
29434                                                                          ; number of dust particles (i.e. NOSTM of them)
29435               
29436 C4CE 0200  20        li   ra,>0c*256                 ; LDA #12           ; Move the text cursor to column 12 on row 12
     C4D0 0C00     
29437 C4D2 D800  30        movb ra,@YC                     ; STA YC
     C4D4 002D     
29438 C4D6 D800  30        movb ra,@XC                     ; STA XC
     C4D8 002C     
29439               
29440 C4DA 0200  20        li   ra,>92*256                 ; LDA #146          ; Print recursive token 146 ("{all caps}GAME OVER")
     C4DC 9200     
29441 C4DE 0206  20        li   rtmp,ex_                   ; JSR ex
     C4E0 A802     
29442 C4E2 06A0  32        bl   @jsr                       ;
     C4E4 FF10     
29443               
29444               D1:
29445 C4E6 0206  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     C4E8 C032     
29446 C4EA 06A0  32        bl   @jsr                       ;
     C4EC FF10     
29447                                                                          ; ship, and set A and X to random values
29448               
29449 C4EE 0910  18        srl  ra,1                       ; LSR A             ; Set A = A / 4, so A is now between 0 and 63, and
29450 C4F0 0910  18        srl  ra,1                       ; LSR A             ; store in byte #0 (x_lo)
29451 C4F2 D800  30        movb ra,@INWK                   ; STA INWK
     C4F4 0053     
29452               
29453 C4F6 0202  20        li   ry,>00*256                 ; LDY #0            ; Set the following to 0: the current view in QQ11
     C4F8 0000     
29454 C4FA D802  30        movb ry,@QQ11                   ; STY QQ11          ; (space view), x_hi, y_hi, z_hi and the AI flag (no AI
     C4FC 0096     
29455 C4FE D802  30        movb ry,@INWK+1                 ; STY INWK+1        ; or E.C.M. and not hostile)
     C500 0054     
29456 C502 D802  30        movb ry,@INWK+4                 ; STY INWK+4
     C504 0057     
29457 C506 D802  30        movb ry,@INWK+7                 ; STY INWK+7
     C508 005A     
29458 C50A D802  30        movb ry,@INWK+32                ; STY INWK+32
     C50C 0073     
29459               
29460 C50E 7084  18        sb   rone,ry                    ; DEY               ; Set Y = 255
29461               
29462 C510 D802  30        movb ry,@MCNT                   ; STY MCNT          ; Reset the main loop counter to 255, so all timer-based
     C512 0099     
29463                                                                          ; calls will be stopped
29464               
29465 C514 D802  30        movb ry,@LASCT                  ; STY LASCT         ; Set the laser count to 255 to act as a counter in the
     C516 0D60     
29466                                                                          ; D2 loop below, so this setting determines how long the
29467                                                                          ; death animation lasts (it's 5.1 seconds, as LASCT is
29468                                                                          ; decremented every vertical sync, or 50 times a second,
29469                                                                          ; and 255 / 50 = 5.1)
29470               
29471                      .eoi (>2a*256)                  ; EOR #%00101010    ; Flip bits 1, 3 and 5 in A (x_lo) to get another number
     **** ****     > EOI
0001 C518 0206  20        li   rtmp,(>2A*256)
     C51A 2A00     
0002 C51C 2806  18        xor  rtmp,ra
                   < elite.a99
29472 C51E D800  30        movb ra,@INWK+3                 ; STA INWK+3        ; between 48 and 63, and store in byte #3 (y_lo)
     C520 0056     
29473               
29474 C522 0260  22        ori  ra,>50*256                 ; ORA #%01010000    ; Set bits 4 and 6 of A to bump it up to between 112 and
     C524 5000     
29475 C526 D800  30        movb ra,@INWK+6                 ; STA INWK+6        ; 127, and store in byte #6 (z_lo)
     C528 0059     
29476               
29477 C52A D001  18        movb rx,ra                      ; TXA               ; Set A to the random number in X and keep bits 0-3 and
29478 C52C 0240  22        andi ra,>8f*256                 ; AND #%10001111    ; the sign in bit 7 to get a number between -15 and +15,
     C52E 8F00     
29479 C530 D800  30        movb ra,@INWK+29                ; STA INWK+29       ; and store in byte #29 (roll counter) to give our ship
     C532 0070     
29480                                                                          ; a gentle roll with damping
29481               
29482 C534 06A0  32        bl   @rora                      ; ROR A             ; The C flag is randomly set from the above call to Ze,
     C536 FF4A     
29483 C538 0240  22        andi ra,>87*256                 ; AND #%10000111    ; so this sets A to a number between -7 and +7, which
     C53A 8700     
29484 C53C D800  30        movb ra,@INWK+30                ; STA INWK+30       ; we store in byte #30 (the pitch counter) to give our
     C53E 0071     
29485                                                                          ; ship a very gentle pitch with damping
29486               
29487                      .php                            ; PHP               ; Store the processor flags
     **** ****     > PHP
0001 C540 02C6  12        stst rtmp
0002 C542 D686  30        movb rtmp,*rsp
0003 C544 060A  14        dec  rsp
                   < elite.a99
29488               
29489 C546 0201  20        li   rx,(OIL)*256               ; LDX #OIL          ; Call fq1 with X set to #OIL, which adds a new cargo
     C548 0B00     
29490 C54A 0206  20        li   rtmp,fq1_                  ; JSR fq1           ; canister to our local bubble of universe and points it
     C54C 3C08     
29491 C54E 06A0  32        bl   @jsr                       ;
     C550 FF10     
29492                                                                          ; away from us with double DELTA speed (i.e. 6, as DELTA
29493                                                                          ; was set to 3 by the call to RES2 above). INF is set to
29494                                                                          ; point to the canister's ship data block in K%
29495               
29496                      .plp                            ; PLP               ; Restore the processor flags, including our random C
     **** ****     > PLP
0001 C552 058A  14        INC  rsp
0002 C554 D19A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
29497                                                                          ; flag from before
29498               
29499 C556 0200  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 of A to our random C flag and store in byte
     C558 0000     
29500 C55A 06A0  32        bl   @rora                      ; ROR A             ; #31 of the ship's data block, so this has a 50% chance
     C55C FF4A     
29501 C55E 0202  20        li   ry,>1f*256                 ; LDY #31           ; of marking our new canister as being killed (so it
     C560 1F00     
29502                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; will explode)
     **** ****     > ST_IND_Y_IDX
0001 C562 D820  50        movb @INF,@rtmplb
     C564 0020     
     C566 2079     
0002 C568 D1A0  30        movb @INF+1,rtmp
     C56A 0021     
0003 C56C A182  18        a    ry,rtmp
0004 C56E D580  30        movb RA,*rtmp
                   < elite.a99
29503               
29504 C570 D020  30        movb @FRIN+3,ra                 ; LDA FRIN+3        ; The call we made to RES2 before we entered the loop at
     C572 0D43     
29505 C574 13B8  14        jeq  D1                         ; BEQ D1            ; D1 will have reset all the ship slots at FRIN, so this
29506                                                                          ; checks to see if the fourth slot is empty, and if it
29507                                                                          ; is we loop back to D1 to add another canister, until
29508                                                                          ; we have added four of them
29509               
29510 C576 0206  20        li   rtmp,U.                    ; JSR U%            ; Clear the key logger, which also sets A = 0
     C578 CCF6     
29511 C57A 06A0  32        bl   @jsr                       ;
     C57C FF10     
29512               
29513 C57E D800  30        movb ra,@DELTA                  ; STA DELTA         ; Set our speed in DELTA to 0, as we aren't going
     C580 008C     
29514                                                                          ; anywhere any more
29515               
29516               D2:
29517 C582 0206  20        li   rtmp,M.                    ; JSR M%            ; Call the M% routine to do the main flight loop once,
     C584 0F52     
29518 C586 06A0  32        bl   @jsr                       ;
     C588 FF10     
29519                                                                          ; which will display our exploding canister scene and
29520                                                                          ; move everything about
29521               
29522 C58A D020  30        movb @LASCT,ra                  ; LDA LASCT         ; Loop back to D2 to run the main flight loop until
     C58C 0D60     
29523 C58E 16F9  14        jne  D2                         ; BNE D2            ; LASCT reaches zero (which will take 5.1 seconds, as
29524                                                                          ; explained above)
29525               
29526 C590 0201  20        li   rx,>1f*256                 ; LDX #31           ; Set the screen to show all 31 text rows, which shows
     C592 1F00     
29527 C594 0206  20        li   rtmp,DET1                  ; JSR DET1          ; the dashboard
     C596 ACC0     
29528 C598 06A0  32        bl   @jsr                       ;
     C59A FF10     
29529               
29530                                                                          ; Fall through into DEATH2 to reset and restart the game
29531               
29532               * ******************************************************************************
29533               *
29534               * Name: DEATH2
29535               * Type: Subroutine
29536               * Category: Start and end
29537               * Summary: Reset most of the game and restart from the title screen
29538               *
29539               * ------------------------------------------------------------------------------
29540               *
29541               * This routine is called following death, and when the game is quit by pressing
29542               * ESCAPE when paused.
29543               *
29544               * ******************************************************************************
29545               
29546               DEATH2:
29547 C59C 0206  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     C59E BF32     
29548 C5A0 06A0  32        bl   @jsr                       ;
     C5A2 FF10     
29549                                                                          ; and fall through into the entry code for the game
29550                                                                          ; to restart from the title screen
29551               
29552               * ******************************************************************************
29553               *
29554               * Name: TT170
29555               * Type: Subroutine
29556               * Category: Start and end
29557               * Summary: Main entry point for the Elite game code
29558               * Deep dive: Program flow of the main game loop
29559               *
29560               * ------------------------------------------------------------------------------
29561               *
29562               * This is the main entry point for the main game code.
29563               *
29564               * ******************************************************************************
29565               
29566               TT170:
29567 C5A4 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Set the stack pointer to &01FF, which is the standard
     C5A6 FF00     
29568 C5A8 D801  38        movb rx,@rsplb                  ; TXS               ; location for the 6502 stack, so this instruction
     C5AA 2081     
29569                                                                          ; effectively resets the stack. We need to do this
29570                                                                          ; because the loader code in elite-loader.asm pushes
29571                                                                          ; code onto the stack, and this effectively removes that
29572                                                                          ; code so we start afresh
29573               
29574                                                                          ; Fall through into BR1 to start the game
29575               
29576               * ******************************************************************************
29577               *
29578               * Name: BR1 (Part 1 of 2)
29579               * Type: Subroutine
29580               * Category: Start and end
29581               * Summary: Show the "Load New Commander (Y/N)?" screen and start the game
29582               *
29583               * ------------------------------------------------------------------------------
29584               *
29585               * BRKV is set to point to BR1 by the loading process.
29586               *
29587               * ******************************************************************************
29588               
29589               BR1:
29590 C5AC 0201  20        li   rx,>03*256                 ; LDX #3            ; Set XC = 3 (set text cursor to column 3)
     C5AE 0300     
29591 C5B0 D801  30        movb rx,@XC                     ; STX XC
     C5B2 002C     
29592               
29593 C5B4 0206  20        li   rtmp,FX200                 ; JSR FX200         ; Disable the ESCAPE key and clear memory if the BREAK
     C5B6 C96A     
29594 C5B8 06A0  32        bl   @jsr                       ;
     C5BA FF10     
29595                                                                          ; key is pressed (*FX 200,3)
29596               
29597 C5BC 0201  20        li   rx,(CYL)*256               ; LDX #CYL          ; Call TITLE to show a rotating Cobra Mk III (#CYL) and
     C5BE 0700     
29598 C5C0 0200  20        li   ra,>80*256                 ; LDA #128          ; token 128 ("  LOAD NEW COMMANDER (Y/N)?{crlf}{crlf}"),
     C5C2 8000     
29599 C5C4 0206  20        li   rtmp,TITLE                 ; JSR TITLE         ; returning with the internal number of the key pressed
     C5C6 C66C     
29600 C5C8 06A0  32        bl   @jsr                       ;
     C5CA FF10     
29601                                                                          ; in A
29602               
29603 C5CC 0280  22        ci   ra,>44*256                 ; CMP #&44          ; Did we press "Y"? If not, jump to QU5, otherwise
     C5CE 4400     
29604 C5D0 1610  14        jne  QU5                        ; BNE QU5           ; continue on to load a new commander
29605               
29606               * BR1                    \ These instructions are commented out in the original
29607               * LDX #3                 \ source. This block starts with the same *FX call as
29608               * STX XC                 \ above, then clears the screen, calls a routine to
29609               * JSR FX200              \ flush the keyboard buffer (FLKB) that isn't present
29610               * LDA #1                 \ in the cassette version but is in other versions,
29611               * JSR TT66               \ and then it displays "LOAD NEW COMMANDER (Y/N)?" and
29612               * JSR FLKB               \ lists the current cargo, before falling straight into
29613               * LDA #14                \ the load routine below, whether or not we have
29614               * JSR TT214              \ pressed "Y". This may be a bit of testing code, as the
29615               * BCC QU5                \ first line is a commented label, BR1, which is where
29616                                                                          ; BRKV points, so when this is uncommented, pressing
29617                                                                          ; the BREAK key should jump straight to the load screen
29618               
29619 C5D2 0206  20        li   rtmp,GTNME                 ; JSR GTNME         ; We want to load a new commander, so we need to get
     C5D4 C7B0     
29620 C5D6 06A0  32        bl   @jsr                       ;
     C5D8 FF10     
29621                                                                          ; the commander name to load
29622               
29623 C5DA 0206  20        li   rtmp,LOD                   ; JSR LOD           ; We then call the LOD subroutine to load the commander
     C5DC C924     
29624 C5DE 06A0  32        bl   @jsr                       ;
     C5E0 FF10     
29625                                                                          ; file to address NA%+8, which is where we store the
29626                                                                          ; commander save file
29627               
29628 C5E2 0206  20        li   rtmp,TRNME                 ; JSR TRNME         ; Once loaded, we copy the commander name to NA%
     C5E4 C78C     
29629 C5E6 06A0  32        bl   @jsr                       ;
     C5E8 FF10     
29630               
29631 C5EA 0206  20        li   rtmp,TTX66                 ; JSR TTX66         ; And we clear the top part of the screen and draw a
     C5EC 4B2E     
29632 C5EE 06A0  32        bl   @jsr                       ;
     C5F0 FF10     
29633                                                                          ; white border
29634               
29635               * ******************************************************************************
29636               *
29637               * Name: QU5
29638               * Type: Subroutine
29639               * Category: Start and end
29640               * Summary: Reset the current commander data block to the last saved commander
29641               *
29642               * ******************************************************************************
29643               
29644               QU5:
29645                                                                          ; By the time we get here, the correct commander name
29646                                                                          ; is at NA% and the correct commander data is at NA%+8.
29647                                                                          ; Specifically:
29648                                                                          ;
29649                                                                          ; * If we loaded a commander file, then the name and
29650                                                                          ; data from that file will be at NA% and NA%+8
29651                                                                          ;
29652                                                                          ; * If this is a brand new game, then NA% will contain
29653                                                                          ; the default starting commander name ("JAMESON")
29654                                                                          ; and NA%+8 will contain the default commander data
29655                                                                          ;
29656                                                                          ; * If this is not a new game (because they died or
29657                                                                          ; quit) and we didn't want to load a commander file,
29658                                                                          ; then NA% will contain the last saved commander
29659                                                                          ; name, and NA%+8 the last saved commander data. If
29660                                                                          ; the game has never been saved, this will still be
29661                                                                          ; the default commander
29662               * JSR TTX66              \ This instruction is commented out in the original
29663                                                                          ; source; it clears the screen and draws a border
29664 C5F2 0201  20        li   rx,(NT.)*256               ; LDX #NT%          ; The size of the commander data block is NT% bytes,
     C5F4 4B00     
29665                                                                          ; and it starts at NA%+8, so we need to copy the data
29666                                                                          ; from the "last saved" buffer at NA%+8 to the current
29667                                                                          ; commander workspace at TP. So we set up a counter in X
29668                                                                          ; for the NT% bytes that we want to copy
29669               
29670               QUL1:
29671 C5F6 D021  34        movb @NA.+7(rx),ra              ; LDA NA%+7,X       ; Copy the X-th byte of NA%+7 to the X-th byte of TP-1,
     C5F8 21CF     
29672 C5FA D840  38        movb ra,@TP-1(rx)               ; STA TP-1,X        ; (the -1 is because X is counting down from NT% to 1)
     C5FC 02FF     
29673               
29674 C5FE 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
29675               
29676 C600 16FA  14        jne  QUL1                       ; BNE QUL1          ; Loop back for the next byte of the commander data
29677                                                                          ; block
29678               
29679 C602 D801  30        movb rx,@QQ11                   ; STX QQ11          ; X is 0 by the end of the above loop, so this sets QQ11
     C604 0096     
29680                                                                          ; to 0, which means we will be showing a view without a
29681                                                                          ; boxed title at the top (i.e. we're going to use the
29682                                                                          ; screen layout of a space view in the following)
29683               
29684                                                                          ; If the commander check below fails, we keep jumping
29685                                                                          ; back to here to crash the game with an infinite loop
29686               
29687               B102:
29688 C606 0206  20        li   rtmp,CHECK                 ; JSR CHECK         ; Call the CHECK subroutine to calculate the checksum
     C608 C76E     
29689 C60A 06A0  32        bl   @jsr                       ;
     C60C FF10     
29690                                                                          ; for the current commander block at NA%+8 and put it
29691                                                                          ; in A
29692               
29693 C60E 9020  34        cb   @CHK,ra                    ; CMP CHK           ; Test the calculated checksum against CHK
     C610 221E     
29694               
29696               
29697 C612 1000  14        nop                             ; NOP               ; If we have disabled checksums, then ignore the result
29698 C614 1000  14        nop                             ; NOP               ; of the comparison and fall through into the next part
29699               
29708               
29709                                                                          ; The checksum CHK is correct, so now we check whether
29710                                                                          ; CHK2 = CHK EOR A9, and if this check fails, bit 7 of
29711                                                                          ; the competition flags at COK gets set, to indicate
29712                                                                          ; to Acornsoft via the competition code that there has
29713                                                                          ; been some hacking going on with this competition entry
29714               
29715                      .eoi (>a9*256)                  ; EOR #&A9          ; X = checksum EOR &A9
     **** ****     > EOI
0001 C616 0206  20        li   rtmp,(>A9*256)
     C618 A900     
0002 C61A 2806  18        xor  rtmp,ra
                   < elite.a99
29716 C61C D040  18        movb ra,rx                      ; TAX
29717               
29718 C61E D020  30        movb @COK,ra                    ; LDA COK           ; Set A to the competition flags in COK
     C620 030E     
29719               
29720 C622 9060  34        cb   @CHK2,rx                   ; CPX CHK2          ; If X = CHK2, then skip the next instruction
     C624 221D     
29721 C626 1302  14        jeq  tZ                         ; BEQ tZ
29722               
29723 C628 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 of A to indicate this commander file has
     C62A 8000     
29724                                                                          ; been tampered with
29725               
29726               tZ:
29727 C62C 0260  22        ori  ra,>02*256                 ; ORA #%00000010    ; Set bit 1 of A to denote that this is the cassette
     C62E 0200     
29728                                                                          ; version
29729               
29730 C630 D800  30        movb ra,@COK                    ; STA COK           ; Store the updated competition flags in COK
     C632 030E     
29731               
29732               * ******************************************************************************
29733               *
29734               * Name: BR1 (Part 2 of 2)
29735               * Type: Subroutine
29736               * Category: Start and end
29737               * Summary: Show the "Press Fire or Space, Commander" screen and start the
29738               * game
29739               *
29740               * ------------------------------------------------------------------------------
29741               *
29742               * BRKV is set to point to BR1 by the loading process.
29743               *
29744               * ******************************************************************************
29745               
29746 C634 0206  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     C636 BFE8     
29747 C638 06A0  32        bl   @jsr                       ;
     C63A FF10     
29748                                                                          ; them are targeted
29749               
29750 C63C 0200  20        li   ra,>93*256                 ; LDA #147          ; Call TITLE to show a rotating Mamba (#3) and token
     C63E 9300     
29751 C640 0201  20        li   rx,>03*256                 ; LDX #3            ; 147 ("PRESS FIRE OR SPACE,COMMANDER.{crlf}{crlf}"),
     C642 0300     
29752 C644 0206  20        li   rtmp,TITLE                 ; JSR TITLE         ; returning with the internal number of the key pressed
     C646 C66C     
29753 C648 06A0  32        bl   @jsr                       ;
     C64A FF10     
29754                                                                          ; in A
29755               
29756 C64C 0206  20        li   rtmp,ping_                 ; JSR ping          ; Set the target system coordinates (QQ9, QQ10) to the
     C64E BC2C     
29757 C650 06A0  32        bl   @jsr                       ;
     C652 FF10     
29758                                                                          ; current system coordinates (QQ0, QQ1) we just loaded
29759               
29760 C654 0206  20        li   rtmp,hyp1_                 ; JSR hyp1          ; Arrive in the system closest to (QQ9, QQ10)
     C656 5F28     
29761 C658 06A0  32        bl   @jsr                       ;
     C65A FF10     
29762               
29763                                                                          ; Fall through into the docking bay routine below
29764               
29765               * ******************************************************************************
29766               *
29767               * Name: BAY
29768               * Type: Subroutine
29769               * Category: Status
29770               * Summary: Go to the docking bay (i.e. show the Status Mode screen)
29771               *
29772               * ------------------------------------------------------------------------------
29773               *
29774               * We end up here after the start-up process (load commander etc.), as well as
29775               * after a successful save, an escape pod launch, a successful docking, the end
29776               * of a cargo sell, and various errors (such as not having enough cash, entering
29777               * too many items when buying, trying to fit an item to your ship when you
29778               * already have it, running out of cargo space, and so on).
29779               *
29780               * ******************************************************************************
29781               
29782               BAY:
29783 C65C 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Set QQ12 = &FF (the docked flag) to indicate that we
     C65E FF00     
29784 C660 D800  30        movb ra,@QQ12                   ; STA QQ12          ; are docked
     C662 009F     
29785               
29786 C664 0200  20        li   ra,(f8_)*256               ; LDA #f8           ; Jump into the main loop at FRCE, setting the key
     C666 7600     
29787 C668 0460  28        b    @FRCE                      ; JMP FRCE          ; that's "pressed" to red key f8 (so we show the Status
     C66A C2B8     
29788                                                                          ; Mode screen)
29789               
29790               * ******************************************************************************
29791               *
29792               * Name: TITLE
29793               * Type: Subroutine
29794               * Category: Start and end
29795               * Summary: Display a title screen with a rotating ship and prompt
29796               *
29797               * ------------------------------------------------------------------------------
29798               *
29799               * Display the title screen, with a rotating ship and a text token at the bottom
29800               * of the screen.
29801               *
29802               * ------------------------------------------------------------------------------
29803               *
29804               * Arguments:
29805               *
29806               * A                   The number of the recursive token to show below the
29807               * rotating ship (see variable QQ18 for details of
29808               * recursive tokens)
29809               *
29810               * X                   The type of the ship to show (see variable XX21 for a
29811               * list of ship types)
29812               *
29813               * ------------------------------------------------------------------------------
29814               *
29815               * Returns:
29816               *
29817               * X                   If a key is being pressed, X contains the internal key
29818               * number, otherwise it contains 0
29819               *
29820               * ******************************************************************************
29821               
29822               TITLE:
29823                      .pha                            ; PHA               ; Store the token number on the stack for later
     **** ****     > PHA
0001 C66C D680  30        movb ra,*rsp
0002 C66E 060A  14        dec  rsp
                   < elite.a99
29824               
29825 C670 D801  30        movb rx,@TYPE                   ; STX TYPE          ; Store the ship type in location TYPE
     C672 009B     
29826               
29827 C674 0206  20        li   rtmp,RESET                 ; JSR RESET         ; Reset our ship so we can use it for the rotating
     C676 BF0A     
29828 C678 06A0  32        bl   @jsr                       ;
     C67A FF10     
29829                                                                          ; title ship
29830               
29831 C67C 0200  20        li   ra,>01*256                 ; LDA #1            ; Clear the top part of the screen, draw a white border,
     C67E 0100     
29832 C680 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 1
     C682 4B2A     
29833 C684 06A0  32        bl   @jsr                       ;
     C686 FF10     
29834               
29835 C688 7004  18        sb   rone,ra                    ; DEC QQ11          ; Decrement QQ11 to 0, so from here on we are using a
29836                                                                          ; space view
29837               
29838 C68A 0200  20        li   ra,>60*256                 ; LDA #96           ; Set nosev_z hi = 96 (96 is the value of unity in the
     C68C 6000     
29839 C68E D800  30        movb ra,@INWK+14                ; STA INWK+14       ; rotation vector)
     C690 0061     
29840               
29841               * LSR A                  \ This instruction is commented out in the original
29842                                                                          ; source. It would halve the value of z_hi to 48, so the
29843                                                                          ; ship would start off closer to the viewer
29844               
29845 C692 D800  30        movb ra,@INWK+7                 ; STA INWK+7        ; Set z_hi, the high byte of the ship's z-coordinate,
     C694 005A     
29846                                                                          ; to 96, which is the distance at which the rotating
29847                                                                          ; ship starts out before coming towards us
29848               
29849 C696 0201  20        li   rx,>7f*256                 ; LDX #127          ; Set roll counter = 127, so don't dampen the roll and
     C698 7F00     
29850 C69A D801  30        movb rx,@INWK+29                ; STX INWK+29       ; make the roll direction clockwise
     C69C 0070     
29851               
29852 C69E D801  30        movb rx,@INWK+30                ; STX INWK+30       ; Set pitch counter = 127, so don't dampen the pitch and
     C6A0 0071     
29853                                                                          ; set the pitch direction to dive
29854               
29855 C6A2 B044  18        ab   rone,rx                    ; INX               ; Set QQ17 to 128 (so bit 7 is set) to switch to
29856 C6A4 D801  30        movb rx,@QQ17                   ; STX QQ17          ; Sentence Case, with the next letter printing in upper
     C6A6 007E     
29857                                                                          ; case
29858               
29859 C6A8 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; Set up a new ship, using the ship type in TYPE
     C6AA 009B     
29860 C6AC 0206  20        li   rtmp,NWSHP                 ; JSR NWSHP
     C6AE AF7A     
29861 C6B0 06A0  32        bl   @jsr                       ;
     C6B2 FF10     
29862               
29863 C6B4 0202  20        li   ry,>06*256                 ; LDY #6            ; Move the text cursor to column 6
     C6B6 0600     
29864 C6B8 D802  30        movb ry,@XC                     ; STY XC
     C6BA 002C     
29865               
29866 C6BC 0206  20        li   rtmp,DELAY                 ; JSR DELAY         ; Delay for 6 vertical syncs (6/50 = 0.12 seconds)
     C6BE 4C00     
29867 C6C0 06A0  32        bl   @jsr                       ;
     C6C2 FF10     
29868               
29869 C6C4 0200  20        li   ra,>1e*256                 ; LDA #30           ; Print recursive token 144 ("---- E L I T E ----")
     C6C6 1E00     
29870 C6C8 0206  20        li   rtmp,plf_                  ; JSR plf           ; followed by a newline
     C6CA A6D0     
29871 C6CC 06A0  32        bl   @jsr                       ;
     C6CE FF10     
29872               
29873 C6D0 0202  20        li   ry,>06*256                 ; LDY #6            ; Move the text cursor to column 6 again
     C6D2 0600     
29874 C6D4 D802  30        movb ry,@XC                     ; STY XC
     C6D6 002C     
29875               
29876 C6D8 B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a row
29877               
29878 C6DA D020  30        movb @PATG,ra                   ; LDA PATG          ; If PATG = 0, skip the following two lines, which
     C6DC 0F4C     
29879 C6DE 1306  14        jeq  awe_                       ; BEQ awe           ; print the author credits (PATG can be toggled by
29880                                                                          ; pausing the game and pressing "X")
29881               
29882 C6E0 0200  20        li   ra,>fe*256                 ; LDA #254          ; Print recursive token 94 ("BY D.BRABEN & I.BELL")
     C6E2 FE00     
29883 C6E4 0206  20        li   rtmp,TT27                  ; JSR TT27
     C6E6 A6E8     
29884 C6E8 06A0  32        bl   @jsr                       ;
     C6EA FF10     
29885               
29886               awe_:
29887 C6EC 0206  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     C6EE 4C2E     
29888 C6F0 06A0  32        bl   @jsr                       ;
     C6F2 FF10     
29889                                                                          ; and move the text cursor to column 1 on row 21, i.e.
29890                                                                          ; the start of the top row of the three bottom rows.
29891                                                                          ; It also returns with Y = 0
29892               
29893 C6F4 D802  30        movb ry,@DELTA                  ; STY DELTA         ; Set DELTA = 0 (i.e. ship speed = 0)
     C6F6 008C     
29894               
29895 C6F8 D802  30        movb ry,@JSTK                   ; STY JSTK          ; Set JSTK = 0 (i.e. keyboard, not joystick)
     C6FA 0F50     
29896               
29897                      .pla                            ; PLA               ; Restore the recursive token number we stored on the
     **** ****     > PLA
0001 C6FC 058A  14        inc  rsp
0002 C6FE D01A  26        movb *rsp,ra
                   < elite.a99
29898 C700 0206  20        li   rtmp,ex_                   ; JSR ex            ; stack at the start of this subroutine, and print that
     C702 A802     
29899 C704 06A0  32        bl   @jsr                       ;
     C706 FF10     
29900                                                                          ; token
29901               
29902 C708 0200  20        li   ra,>94*256                 ; LDA #148          ; Set A to recursive token 148
     C70A 9400     
29903               
29904 C70C 0201  20        li   rx,>07*256                 ; LDX #7            ; Move the text cursor to column 7
     C70E 0700     
29905 C710 D801  30        movb rx,@XC                     ; STX XC
     C712 002C     
29906               
29907 C714 0206  20        li   rtmp,ex_                   ; JSR ex            ; Print recursive token 148 ("(C) ACORNSOFT 1984")
     C716 A802     
29908 C718 06A0  32        bl   @jsr                       ;
     C71A FF10     
29909               
29910               TLL2:
29911 C71C D020  30        movb @INWK+7,ra                 ; LDA INWK+7        ; If z_hi (the ship's distance) is 1, jump to TL1 to
     C71E 005A     
29912 C720 0280  22        ci   ra,>01*256                 ; CMP #1            ; skip the following decrement
     C722 0100     
29913 C724 1301  14        jeq  TL1                        ; BEQ TL1
29914               
29915 C726 7004  18        sb   rone,ra                    ; DEC INWK+7        ; Decrement the ship's distance, to bring the ship
29916                                                                          ; a bit closer to us
29917               
29918               TL1:
29919 C728 0206  20        li   rtmp,MVEIT                 ; JSR MVEIT         ; Move the ship in space according to the orientation
     C72A 17E2     
29920 C72C 06A0  32        bl   @jsr                       ;
     C72E FF10     
29921                                                                          ; vectors and the new value in z_hi
29922               
29923 C730 0200  20        li   ra,>80*256                 ; LDA #128          ; Set z_lo = 128, so the closest the ship gets to us is
     C732 8000     
29924 C734 D800  30        movb ra,@INWK+6                 ; STA INWK+6        ; z_hi = 1, z_lo = 128, or 256 + 128 = 384
     C736 0059     
29925               
29926                      .asla                           ; ASL A             ; Set A = 0
     **** ****     > ASLA
0001 C738 0240  22        andi ra,>ff00
     C73A FF00     
0002 C73C 0A10  18        sla  ra,1
                   < elite.a99
29927               
29928 C73E D800  30        movb ra,@INWK                   ; STA INWK          ; Set x_lo = 0, so the ship remains in the screen centre
     C740 0053     
29929               
29930 C742 D800  30        movb ra,@INWK+3                 ; STA INWK+3        ; Set y_lo = 0, so the ship remains in the screen centre
     C744 0056     
29931               
29932 C746 0206  20        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to display the ship
     C748 D4B4     
29933 C74A 06A0  32        bl   @jsr                       ;
     C74C FF10     
29934               
29935 C74E 7004  18        sb   rone,ra                    ; DEC MCNT          ; Decrement the main loop counter
29936               
29937 C750 D020  34        movb @VIA+>40,ra                ; LDA VIA+&40       ; Read 6522 System VIA input register IRB (SHEILA &40)
     C752 FE40     
29938               
29939 C754 0240  22        andi ra,>10*256                 ; AND #%00010000    ; Bit 4 of IRB (PB4) is clear if joystick 1's fire
     C756 1000     
29940                                                                          ; button is pressed, otherwise it is set, so AND'ing
29941                                                                          ; the value of IRB with %10000 extracts this bit
29942               
29943               * TAX                    \ This instruction is commented out in the original
29944                                                                          ; source; it would have no effect, as the comparison
29945                                                                          ; flags are already set by the AND, and the value of X
29946                                                                          ; is not used anywhere
29947               
29948 C758 1307  14        jeq  TL2                        ; BEQ TL2           ; If the joystick fire button is pressed, jump to TL2
29949               
29950 C75A 0206  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press
     C75C CAF4     
29951 C75E 06A0  32        bl   @jsr                       ;
     C760 FF10     
29952               
29953 C762 13DC  14        jeq  TLL2                       ; BEQ TLL2          ; If no key was pressed, loop back up to move/rotate
29954                                                                          ; the ship and check again for a key press
29955               
29956 C764 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C766 FF1C     
29957               
29958               TL2:
29959 C768 7004  18        sb   rone,ra                    ; DEC JSTK          ; Joystick fire button was pressed, so set JSTK to &FF
29960                                                                          ; (it was set to 0 above), to disable keyboard and
29961                                                                          ; enable joysticks
29962               
29963 C76A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C76C FF1C     
29964               
29965               * ******************************************************************************
29966               *
29967               * Name: CHECK
29968               * Type: Subroutine
29969               * Category: Save and load
29970               * Summary: Calculate the checksum for the last saved commander data block
29971               * Deep dive: Commander save files
29972               *
29973               * ------------------------------------------------------------------------------
29974               *
29975               * The checksum for the last saved commander data block is saved as part of the
29976               * commander file, in two places (CHK AND CHK2), to protect against file
29977               * tampering. This routine calculates the checksum and returns it in A.
29978               *
29979               * This algorithm is also implemented in elite-checksum.py.
29980               *
29981               * ------------------------------------------------------------------------------
29982               *
29983               * Returns:
29984               *
29985               * A                   The checksum for the last saved commander data block
29986               *
29987               * ******************************************************************************
29988               
29989               CHECK:
29990 C76E 0201  20        li   rx,(NT.-2)*256             ; LDX #NT%-2        ; Set X to the size of the commander data block, less
     C770 4900     
29991                                                                          ; 2 (to omit the checksum bytes and the save count)
29992               
29993                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 C772 0A13  18        sla  rzero,1
                   < elite.a99
29994                                                                          ; C flag affecting the result
29995               
29996 C774 D001  18        movb rx,ra                      ; TXA               ; Seed the checksum calculation by setting A to the
29997                                                                          ; size of the commander data block, less 2
29998               
29999                                                                          ; We now loop through the commander data block,
30000                                                                          ; starting at the end and looping down to the start
30001                                                                          ; (so at the start of this loop, the X-th byte is the
30002                                                                          ; last byte of the commander data block, i.e. the save
30003                                                                          ; count)
30004               
30005               QUL2:
30006                      .adc @NA.+7(rx),ra              ; ADC NA%+7,X       ; Add the X-1-th byte of the data block to A, plus the
     **** ****     > ADC
0001 C776 1701  14        jnc  !
0002 C778 B004  18        ab   rone,ra
0003               !:
0004 C77A B021  34        ab   @NA.+7(RX),ra
     C77C 21CF     
                   < elite.a99
30007                                                                          ; C flag
30008               
30009                      .eor @NA.+8(rx)                 ; EOR NA%+8,X       ; EOR A with the X-th byte of the data block
     **** ****     > EOR
0001 C77E D1A1  34        movb @NA.+8(RX),rtmp
     C780 21D0     
0002 C782 2806  18        xor  rtmp,ra
                   < elite.a99
30010               
30011 C784 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30012               
30013 C786 16F7  14        jne  QUL2                       ; BNE QUL2          ; Loop back for the next byte in the calculation, until
30014                                                                          ; we have added byte #0 and EOR'd with byte #1 of the
30015                                                                          ; data block
30016               
30017 C788 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C78A FF1C     
30018               
30019               * ******************************************************************************
30020               *
30021               * Name: TRNME
30022               * Type: Subroutine
30023               * Category: Save and load
30024               * Summary: Copy the last saved commander's name from INWK to NA%
30025               *
30026               * ******************************************************************************
30027               
30028               TRNME:
30029 C78C 0201  20        li   rx,>07*256                 ; LDX #7            ; The commander's name can contain a maximum of 7
     C78E 0700     
30030                                                                          ; characters, and is terminated by a carriage return,
30031                                                                          ; so set up a counter in X to copy 8 characters
30032               
30033               GTL1:
30034 C790 D021  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Copy the X-th byte of INWK to the X-th byte of NA%
     C792 0053     
30035 C794 D840  38        movb ra,@NA.(rx)                ; STA NA%,X
     C796 21C8     
30036               
30037 C798 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30038               
30039 C79A 15FA  14        jgt  GTL1                       ; BPL GTL1          ; Loop back until we have copied all 8 bytes
30040               
30041                                                                          ; Fall through into TR1 to copy the name back from NA%
30042                                                                          ; to INWK. This isn't necessary as the name is already
30043                                                                          ; there, but it does save one byte, as we don't need an
30044                                                                          ; RTS here
30045               
30046               * ******************************************************************************
30047               *
30048               * Name: TR1
30049               * Type: Subroutine
30050               * Category: Save and load
30051               * Summary: Copy the last saved commander's name from NA% to INWK
30052               *
30053               * ******************************************************************************
30054               
30055               TR1:
30056 C79C 0201  20        li   rx,>07*256                 ; LDX #7            ; The commander's name can contain a maximum of 7
     C79E 0700     
30057                                                                          ; characters, and is terminated by a carriage return,
30058                                                                          ; so set up a counter in X to copy 8 characters
30059               
30060               GTL2:
30061 C7A0 D021  34        movb @NA.(rx),ra                ; LDA NA%,X         ; Copy the X-th byte of NA% to the X-th byte of INWK
     C7A2 21C8     
30062 C7A4 D840  38        movb ra,@INWK(rx)               ; STA INWK,X
     C7A6 0053     
30063               
30064 C7A8 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30065               
30066 C7AA 15FA  14        jgt  GTL2                       ; BPL GTL2          ; Loop back until we have copied all 8 bytes
30067               
30068 C7AC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C7AE FF1C     
30069               
30070               * ******************************************************************************
30071               *
30072               * Name: GTNME
30073               * Type: Subroutine
30074               * Category: Save and load
30075               * Summary: Fetch the name of a commander file to save or load
30076               *
30077               * ------------------------------------------------------------------------------
30078               *
30079               * Get the commander's name for loading or saving a commander file. The name is
30080               * stored in the INWK workspace and is terminated by a return character (13).
30081               *
30082               * If ESCAPE is pressed or a blank name is entered, then the name stored is set
30083               * to the name from the last saved commander block.
30084               *
30085               * ------------------------------------------------------------------------------
30086               *
30087               * Returns:
30088               *
30089               * INWK                The commander name entered, terminated by a return
30090               * character (13)
30091               *
30092               * ******************************************************************************
30093               
30094               GTNME:
30095 C7B0 0200  20        li   ra,>01*256                 ; LDA #1            ; Clear the top part of the screen, draw a white border,
     C7B2 0100     
30096 C7B4 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 1
     C7B6 4B2A     
30097 C7B8 06A0  32        bl   @jsr                       ;
     C7BA FF10     
30098               
30099 C7BC 0200  20        li   ra,>7b*256                 ; LDA #123          ; Print recursive token 123 ("{crlf}COMMANDER'S NAME? ")
     C7BE 7B00     
30100 C7C0 0206  20        li   rtmp,TT27                  ; JSR TT27
     C7C2 A6E8     
30101 C7C4 06A0  32        bl   @jsr                       ;
     C7C6 FF10     
30102               
30103 C7C8 0206  20        li   rtmp,DEL8                  ; JSR DEL8          ; Wait for 8/50 of a second (0.16 seconds)
     C7CA 4BFC     
30104 C7CC 06A0  32        bl   @jsr                       ;
     C7CE FF10     
30105               
30106 C7D0 0200  20        li   ra,>81*256                 ; LDA #%10000001    ; Clear 6522 System VIA interrupt enable register IER
     C7D2 8100     
30107 C7D4 D800  38        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
     C7D6 FE4E     
30108                                                                          ; which comes from the keyboard)
30109               
30110 C7D8 0200  20        li   ra,>0f*256                 ; LDA #15           ; Call OSBYTE with A = 15 (flush all buffers)
     C7DA 0F00     
30111 C7DC D040  18        movb ra,rx                      ; TAX
30112 C7DE 0206  20        li   rtmp,OSBYTE                ; JSR OSBYTE
     C7E0 FFF4     
30113 C7E2 06A0  32        bl   @jsr                       ;
     C7E4 FF10     
30114               
30115 C7E6 0201  20        li   rx,((RLINE)%256)*256       ; LDX #LO(RLINE)    ; Set (Y X) to point to the RLINE parameter block
     C7E8 FC00     
30116 C7EA 0202  20        li   ry,((RLINE)/256)*256       ; LDY #HI(RLINE)    ; configuration block below
     C7EC C900     
30117               
30118 C7EE 0200  20        li   ra,>00*256                 ; LDA #0            ; Call OSWORD with A = 0 to read a line from the current
     C7F0 0000     
30119 C7F2 0206  20        li   rtmp,OSWORD                ; JSR OSWORD        ; input stream (i.e. the keyboard)
     C7F4 FFF1     
30120 C7F6 06A0  32        bl   @jsr                       ;
     C7F8 FF10     
30121               
30122               * LDA #%00000001         \ These instructions are commented out in the original
30123               * STA VIA+&4E            \ source, but they would set 6522 System VIA interrupt
30124                                                                          ; enable register IER (SHEILA &4E) bit 1 (i.e. disable
30125                                                                          ; the CA2 interrupt, which comes from the keyboard)
30126               
30127 C7FA 18D0  14        joc  TR1                        ; BCS TR1           ; The C flag will be set if we pressed ESCAPE when
30128                                                                          ; entering the name, in which case jump to TR1 to copy
30129                                                                          ; the last saved commander's name from NA% to INWK
30130                                                                          ; and return from the subroutine there
30131               
30132 C7FC D002  18        movb ry,ra                      ; TYA               ; The OSWORD call returns the length of the commander's
30133                                                                          ; name in Y, so transfer this to A
30134               
30135 C7FE 13CE  14        jeq  TR1                        ; BEQ TR1           ; If A = 0, no name was entered, so jump to TR1 to copy
30136                                                                          ; the last saved commander's name from NA% to INWK
30137                                                                          ; and return from the subroutine there
30138               
30139 C800 0460  28        b    @TT67                      ; JMP TT67          ; We have a name, so jump to TT67 to print a newline
     C802 4EE6     
30140                                                                          ; and return from the subroutine using a tail call
30141               
30142               * ******************************************************************************
30143               *
30144               * Name: RLINE
30145               * Type: Variable
30146               * Category: Text
30147               * Summary: The OSWORD configuration block used to fetch a line of text from
30148               * the keyboard
30149               *
30150               * ******************************************************************************
30151               
30152               RLINE:
30153 C804 0053            data INWK                                           ; The address to store the input, so the commander's
30154                                                                          ; name will be stored in INWK as it is typed
30155               
30156 C806 07              byte >07                                            ; Maximum line length = 7, as that's the maximum size
30157                                                                          ; for a commander's name
30158               
30159 C807   21            byte '!'                                            ; Allow ASCII characters from "!" through to "z" in
30160 C808 7A              byte 'z'                                            ; the name
30161               
30162               * ******************************************************************************
30163               *
30164               * Name: ZERO
30165               * Type: Subroutine
30166               * Category: Utility routines
30167               * Summary: Zero-fill pages &9, &A, &B, &C and &D
30168               *
30169               * ------------------------------------------------------------------------------
30170               *
30171               * This resets the following workspaces to zero:
30172               *
30173               * * The ship data blocks ascending from K% at &0900
30174               *
30175               * * The ship line heap descending from WP at &0D40
30176               *
30177               * * WP workspace variables from FRIN to de, which include the ship slots for
30178               * the local bubble of universe, and various flight and ship status variables
30179               * (only a portion of the LSX/LSO sun line heap is cleared)
30180               *
30181               * ******************************************************************************
30182               
30183               ZERO:
30184 C80A 0201  20        li   rx,>0d*256                 ; LDX #&D           ; Point X to page &D
     C80C 0D00     
30185               
30186               ZEL:
30187 C80E 0206  20        li   rtmp,ZES1                  ; JSR ZES1          ; Call ZES1 to zero-fill the page in X
     C810 C81E     
30188 C812 06A0  32        bl   @jsr                       ;
     C814 FF10     
30189               
30190 C816 7044  18        sb   rone,rx                    ; DEX               ; Decrement X to point to the next page
30191               
30192 C818 0281  22        ci   rx,>09*256                 ; CPX #9            ; If X is > 9 (i.e. is &A, &B or &C), then loop back
     C81A 0900     
30193 C81C 16F8  14        jne  ZEL                        ; BNE ZEL           ; up to clear the next page
30194               
30195                                                                          ; Then fall through into ZES1 with X set to 9, so we
30196                                                                          ; clear page &9 too
30197               
30198               * ******************************************************************************
30199               *
30200               * Name: ZES1
30201               * Type: Subroutine
30202               * Category: Utility routines
30203               * Summary: Zero-fill the page whose number is in X
30204               *
30205               * ------------------------------------------------------------------------------
30206               *
30207               * Arguments:
30208               *
30209               * X                   The page we want to zero-fill
30210               *
30211               * ******************************************************************************
30212               
30213               ZES1:
30214 C81E 0202  20        li   ry,>00*256                 ; LDY #0            ; If we set Y = SC = 0 and fall through into ZES2
     C820 0000     
30215 C822 D802  30        movb ry,@SC                     ; STY SC            ; below, then we will zero-fill 255 bytes starting from
     C824 0007     
30216                                                                          ; SC - in other words, we will zero-fill the whole of
30217                                                                          ; page X
30218               
30219               * ******************************************************************************
30220               *
30221               * Name: ZES2
30222               * Type: Subroutine
30223               * Category: Utility routines
30224               * Summary: Zero-fill a specific page
30225               *
30226               * ------------------------------------------------------------------------------
30227               *
30228               * Zero-fill from address (X SC) + Y to (X SC) + &FF.
30229               *
30230               * ------------------------------------------------------------------------------
30231               *
30232               * Arguments:
30233               *
30234               * X                   The high byte (i.e. the page) of the starting point of
30235               * the zero-fill
30236               *
30237               * Y                   The offset from (X SC) where we start zeroing, counting
30238               * up to &FF
30239               *
30240               * SC                  The low byte (i.e. the offset into the page) of the
30241               * starting point of the zero-fill
30242               *
30243               * ------------------------------------------------------------------------------
30244               *
30245               * Returns:
30246               *
30247               * Z flag              Z flag is set
30248               *
30249               * ******************************************************************************
30250               
30251               ZES2:
30252 C826 0200  20        li   ra,>00*256                 ; LDA #0            ; Load A with the byte we want to fill the memory block
     C828 0000     
30253                                                                          ; with - i.e. zero
30254               
30255 C82A D801  30        movb rx,@SC+1                   ; STX SC+1          ; We want to zero-fill page X, so store this in the
     C82C 0008     
30256                                                                          ; high byte of SC, so the 16-bit address in SC and
30257                                                                          ; SC+1 is now pointing to the SC-th byte of page X
30258               
30259               ZEL1:
30260                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Zero the Y-th byte of the block pointed to by SC,
     **** ****     > ST_IND_Y_IDX
0001 C82E D820  50        movb @SC,@rtmplb
     C830 0007     
     C832 2079     
0002 C834 D1A0  30        movb @SC+1,rtmp
     C836 0008     
0003 C838 A182  18        a    ry,rtmp
0004 C83A D580  30        movb RA,*rtmp
                   < elite.a99
30261                                                                          ; so that's effectively the Y-th byte before SC
30262               
30263 C83C B084  18        ab   rone,ry                    ; INY               ; Increment the loop counter
30264               
30265 C83E 16F7  14        jne  ZEL1                       ; BNE ZEL1          ; Loop back to zero the next byte
30266               
30267 C840 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C842 FF1C     
30268               
30269               * ******************************************************************************
30270               *
30271               * Name: SVE
30272               * Type: Subroutine
30273               * Category: Save and load
30274               * Summary: Save the commander file
30275               * Deep dive: Commander save files
30276               * The competition code
30277               *
30278               * ******************************************************************************
30279               
30280               SVE:
30281 C844 0206  20        li   rtmp,GTNME                 ; JSR GTNME         ; Clear the screen and ask for the commander filename
     C846 C7B0     
30282 C848 06A0  32        bl   @jsr                       ;
     C84A FF10     
30283                                                                          ; to save, storing the name at INWK
30284               
30285 C84C 0206  20        li   rtmp,TRNME                 ; JSR TRNME         ; Transfer the commander filename from INWK to NA%
     C84E C78C     
30286 C850 06A0  32        bl   @jsr                       ;
     C852 FF10     
30287               
30288 C854 0206  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     C856 C80A     
30289 C858 06A0  32        bl   @jsr                       ;
     C85A FF10     
30290                                                                          ; the ship data blocks, the ship line heap, the ship
30291                                                                          ; slots for the local bubble of universe, and various
30292                                                                          ; flight and ship status variables
30293               
30294                      .lsr @SVC                       ; LSR SVC           ; Halve the save count value in SVC
     **** ****     > LSR
0001 C85C D1A0  30        movb @SVC,rtmp
     C85E 0349     
0002 C860 0916  18        srl  rtmp,1
0003 C862 D806  30        movb rtmp,@SVC
     C864 0349     
                   < elite.a99
30295               
30296 C866 0201  20        li   rx,(NT.)*256               ; LDX #NT%          ; We now want to copy the current commander data block
     C868 4B00     
30297                                                                          ; from location TP to the last saved commander block at
30298                                                                          ; NA%+8, so set a counter in X to copy the NT% bytes in
30299                                                                          ; the commander data block
30300                                                                          ;
30301                                                                          ; We also want to copy the data block to another
30302                                                                          ; location &0B00, which is normally used for the ship
30303                                                                          ; lines heap
30304               
30305               SVL1:
30306 C86A D021  34        movb @TP(rx),ra                 ; LDA TP,X          ; Copy the X-th byte of TP to the X-th byte of &0B00
     C86C 0300     
30307 C86E D840  38        movb ra,@>0B00(rx)              ; STA &0B00,X       ; and NA%+8
     C870 0B00     
30308 C872 D840  38        movb ra,@NA.+8(rx)              ; STA NA%+8,X
     C874 21D0     
30309               
30310 C876 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30311               
30312 C878 15F8  14        jgt  SVL1                       ; BPL SVL1          ; Loop back until we have copied all the bytes in the
30313                                                                          ; commander data block
30314               
30315 C87A 0206  20        li   rtmp,CHECK                 ; JSR CHECK         ; Call CHECK to calculate the checksum for the last
     C87C C76E     
30316 C87E 06A0  32        bl   @jsr                       ;
     C880 FF10     
30317                                                                          ; saved commander and return it in A
30318               
30319 C882 D800  38        movb ra,@CHK                    ; STA CHK           ; Store the checksum in CHK, which is at the end of the
     C884 221E     
30320                                                                          ; last saved commander block
30321               
30322                      .pha                            ; PHA               ; Store the checksum on the stack
     **** ****     > PHA
0001 C886 D680  30        movb ra,*rsp
0002 C888 060A  14        dec  rsp
                   < elite.a99
30323               
30324 C88A 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set K = checksum with bit 7 set
     C88C 8000     
30325 C88E D800  30        movb ra,@K                      ; STA K
     C890 003D     
30326               
30327                      .eor @COK                       ; EOR COK           ; Set K+2 = K EOR COK (the competition flags)
     **** ****     > EOR
0001 C892 D1A0  30        movb @COK,rtmp
     C894 030E     
0002 C896 2806  18        xor  rtmp,ra
                   < elite.a99
30328 C898 D800  30        movb ra,@K+2                    ; STA K+2
     C89A 003F     
30329               
30330                      .eor @CASH+2                    ; EOR CASH+2        ; Set K+1 = K+2 EOR CASH+2 (the third cash byte)
     **** ****     > EOR
0001 C89C D1A0  30        movb @CASH+2,rtmp
     C89E 030B     
0002 C8A0 2806  18        xor  rtmp,ra
                   < elite.a99
30331 C8A2 D800  30        movb ra,@K+1                    ; STA K+1
     C8A4 003E     
30332               
30333                      .eoi (>5a*256)                  ; EOR #&5A          ; Set K+3 = K+1 EOR &5A EOR TALLY+1 (the high byte of
     **** ****     > EOI
0001 C8A6 0206  20        li   rtmp,(>5A*256)
     C8A8 5A00     
0002 C8AA 2806  18        xor  rtmp,ra
                   < elite.a99
30334                      .eor @TALLY+1                   ; EOR TALLY+1       ; the kill tally)
     **** ****     > EOR
0001 C8AC D1A0  30        movb @TALLY+1,rtmp
     C8AE 0348     
0002 C8B0 2806  18        xor  rtmp,ra
                   < elite.a99
30335 C8B2 D800  30        movb ra,@K+3                    ; STA K+3
     C8B4 0040     
30336               
30337 C8B6 0206  20        li   rtmp,BPRNT                 ; JSR BPRNT         ; Print the competition number stored in K to K+3. The
     C8B8 2FCC     
30338 C8BA 06A0  32        bl   @jsr                       ;
     C8BC FF10     
30339                                                                          ; value of U might affect how this is printed, and as
30340                                                                          ; it's a temporary variable in zero page that isn't
30341                                                                          ; reset by ZERO, it might have any value, but as the
30342                                                                          ; competition code is a 10-digit number, this just means
30343                                                                          ; it may or may not have an extra space of padding
30344               
30345 C8BE 0206  20        li   rtmp,TT67                  ; JSR TT67          ; Call TT67 twice to print two newlines
     C8C0 4EE6     
30346 C8C2 06A0  32        bl   @jsr                       ;
     C8C4 FF10     
30347 C8C6 0206  20        li   rtmp,TT67                  ; JSR TT67
     C8C8 4EE6     
30348 C8CA 06A0  32        bl   @jsr                       ;
     C8CC FF10     
30349               
30350                      .pla                            ; PLA               ; Restore the checksum from the stack
     **** ****     > PLA
0001 C8CE 058A  14        inc  rsp
0002 C8D0 D01A  26        movb *rsp,ra
                   < elite.a99
30351               
30352 C8D2 D800  30        movb ra,@>0B00+NT.              ; STA &0B00+NT%     ; Store the checksum in the last byte of the save file
     C8D4 0B4B     
30353                                                                          ; at &0B00 (the equivalent of CHK in the last saved
30354                                                                          ; block)
30355               
30356                      .eoi (>a9*256)                  ; EOR #&A9          ; Store the checksum EOR &A9 in CHK2, the penultimate
     **** ****     > EOI
0001 C8D6 0206  20        li   rtmp,(>A9*256)
     C8D8 A900     
0002 C8DA 2806  18        xor  rtmp,ra
                   < elite.a99
30357 C8DC D800  38        movb ra,@CHK2                   ; STA CHK2          ; byte of the last saved commander block
     C8DE 221D     
30358               
30359 C8E0 D800  30        movb ra,@>0AFF+NT.              ; STA &0AFF+NT%     ; Store the checksum EOR &A9 in the penultimate byte of
     C8E2 0B4A     
30360                                                                          ; the save file at &0B00 (the equivalent of CHK2 in the
30361                                                                          ; last saved block)
30362               
30363 C8E4 0202  20        li   ry,>0b*256                 ; LDY #&B           ; Set up an OSFILE block at &0C00, containing:
     C8E6 0B00     
30364 C8E8 D802  30        movb ry,@>0C0B                  ; STY &0C0B         ;
     C8EA 0C0B     
30365 C8EC B084  18        ab   rone,ry                    ; INY               ; Start address for save = &00000B00 in &0C0A to &0C0D
30366 C8EE D802  30        movb ry,@>0C0F                  ; STY &0C0F         ;
     C8F0 0C0F     
30367                                                                          ; End address for save = &00000C00 in &0C0E to &0C11
30368                                                                          ;
30369                                                                          ; Y is left containing &C which we use below
30370               
30371 C8F2 0200  20        li   ra,>81*256                 ; LDA #%10000001    ; Clear 6522 System VIA interrupt enable register IER
     C8F4 8100     
30372 C8F6 D800  38        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
     C8F8 FE4E     
30373                                                                          ; which comes from the keyboard)
30374               
30375 C8FA B004  18        ab   rone,ra                    ; INC SVN           ; Increment SVN to indicate we are about to start saving
30376               
30377 C8FC 0200  20        li   ra,>00*256                 ; LDA #0            ; Call QUS1 with A = 0, Y = &C to save the commander
     C8FE 0000     
30378 C900 0206  20        li   rtmp,QUS1                  ; JSR QUS1          ; file with the filename we copied to INWK at the start
     C902 C914     
30379 C904 06A0  32        bl   @jsr                       ;
     C906 FF10     
30380                                                                          ; of this routine
30381               
30382 C908 0201  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0 for storing in SVN below
     C90A 0000     
30383               
30384               * STX VIA+&4E            \ This instruction is commented out in the original
30385                                                                          ; source. It would affect the 6522 System VIA interrupt
30386                                                                          ; enable register IER (SHEILA &4E) if any of bits 0-6
30387                                                                          ; of X were set, but they aren't, so this instruction
30388                                                                          ; would have no effect anyway
30389               
30390               * DEX                    \ This instruction is commented out in the original
30391                                                                          ; source. It would end up setting SVN to &FF, which
30392                                                                          ; affects the logic in the IRQ1 handler
30393               
30394 C90C D801  38        movb rx,@SVN                    ; STX SVN           ; Set SVN to 0 to indicate we are done saving
     C90E F2BD     
30395               
30396 C910 0460  28        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show Status Mode)
     C912 C65C     
30397               
30398               * ******************************************************************************
30399               *
30400               * Name: QUS1
30401               * Type: Subroutine
30402               * Category: Save and load
30403               * Summary: Save or load the commander file
30404               * Deep dive: Commander save files
30405               *
30406               * ------------------------------------------------------------------------------
30407               *
30408               * The filename should be stored at INWK, terminated with a carriage return (13).
30409               * The routine should be called with Y set to &C.
30410               *
30411               * ------------------------------------------------------------------------------
30412               *
30413               * Arguments:
30414               *
30415               * A                   File operation to be performed. Can be one of the
30416               * following:
30417               *
30418               * * 0 (save file)
30419               *
30420               * * &FF (load file)
30421               *
30422               * Y                   Points to the page number containing the OSFILE block,
30423               * which must be &C because that's where the pointer to the
30424               * filename in INWK is stored below (by the STX &0C00
30425               * instruction)
30426               *
30427               * ******************************************************************************
30428               
30429               QUS1:
30430 C914 0201  20        li   rx,(INWK)*256              ; LDX #INWK         ; Store a pointer to INWK at the start of the block at
     C916 5300     
30431 C918 D801  30        movb rx,@>0C00                  ; STX &0C00         ; &0C00, storing #INWK in the low byte because INWK is
     C91A 0C00     
30432                                                                          ; in zero page
30433               
30434 C91C 0201  20        li   rx,>00*256                 ; LDX #0            ; Set X to 0 so (Y X) = &0C00
     C91E 0000     
30435               
30436 C920 0460  28        b    @OSFILE                    ; JMP OSFILE        ; Jump to OSFILE to do the file operation specified in
     C922 FFDD     
30437                                                                          ; &0C00 (i.e. save or load a file depending on the value
30438                                                                          ; of A), returning from the subroutine using a tail call
30439               
30440               * ******************************************************************************
30441               *
30442               * Name: LOD
30443               * Type: Subroutine
30444               * Category: Save and load
30445               * Summary: Load a commander file
30446               *
30447               * ------------------------------------------------------------------------------
30448               *
30449               * The filename should be stored at INWK, terminated with a carriage return (13).
30450               *
30451               * ******************************************************************************
30452               
30453               LOD:
30454 C924 0201  20        li   rx,>02*256                 ; LDX #2            ; Enable the ESCAPE key and clear memory if the BREAK
     C926 0200     
30455 C928 0206  20        li   rtmp,FX200                 ; JSR FX200         ; key is pressed (*FX 200,2)
     C92A C96A     
30456 C92C 06A0  32        bl   @jsr                       ;
     C92E FF10     
30457               
30458 C930 0206  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     C932 C80A     
30459 C934 06A0  32        bl   @jsr                       ;
     C936 FF10     
30460                                                                          ; the ship data blocks, the ship line heap, the ship
30461                                                                          ; slots for the local bubble of universe, and various
30462                                                                          ; flight and ship status variables
30463               
30464 C938 0202  20        li   ry,>0b*256                 ; LDY #&B           ; Set up an OSFILE block at &0C00, containing:
     C93A 0B00     
30465 C93C D802  30        movb ry,@>0C03                  ; STY &0C03         ;
     C93E 0C03     
30466 C940 B004  18        ab   rone,ra                    ; INC &0C0B         ; Load address = &00000B00 in &0C02 to &0C05
30467                                                                          ;
30468                                                                          ; Length of file = &00000100 in &0C0A to &0C0D
30469               
30470 C942 B084  18        ab   rone,ry                    ; INY               ; Increment Y to &C, which we use next
30471               
30472 C944 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Call QUS1 with A = &FF, Y = &C to load the commander
     C946 FF00     
30473 C948 0206  20        li   rtmp,QUS1                  ; JSR QUS1          ; file to address &0B00
     C94A C914     
30474 C94C 06A0  32        bl   @jsr                       ;
     C94E FF10     
30475               
30476 C950 D020  30        movb @>0B00,ra                  ; LDA &0B00         ; If the first byte of the loaded file has bit 7 set,
     C952 0B00     
30477 C954 1112  14        jlt  SPS1+1                     ; BMI SPS1+1        ; jump to SPS+1, which is the second byte of an LDA #0
30478                                                                          ; instruction, i.e. a BRK instruction, which will force
30479                                                                          ; an interrupt to call the address in BRKV, which is set
30480                                                                          ; to BR1... so this instruction restarts the game from
30481                                                                          ; the title screen. Valid commander files for the
30482                                                                          ; cassette version of Elite only have 0 for the first
30483                                                                          ; byte, as there are no missions in this version, so
30484                                                                          ; having bit 7 set is invalid anyway
30485               
30486 C956 0201  20        li   rx,(NT.)*256               ; LDX #NT%          ; We have successfully loaded the commander file at
     C958 4B00     
30487                                                                          ; &0B00, so now we want to copy it to the last saved
30488                                                                          ; commander data block at NA%+8, so we set up a counter
30489                                                                          ; in X to copy NT% bytes
30490               
30491               LOL1:
30492 C95A D021  34        movb @>0B00(rx),ra              ; LDA &0B00,X       ; Copy the X-th byte of &0B00 to the X-th byte of NA%+8
     C95C 0B00     
30493 C95E D840  38        movb ra,@NA.+8(rx)              ; STA NA%+8,X
     C960 21D0     
30494               
30495 C962 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30496               
30497 C964 15FA  14        jgt  LOL1                       ; BPL LOL1          ; Loop back until we have copied all NT% bytes
30498               
30499 C966 0201  20        li   rx,>03*256                 ; LDX #3            ; Fall through into FX200 to disable the ESCAPE key and
     C968 0300     
30500                                                                          ; clear memory if the BREAK key is pressed (*FX 200,3)
30501                                                                          ; and return from the subroutine there
30502               
30503               * ******************************************************************************
30504               *
30505               * Name: FX200
30506               * Type: Subroutine
30507               * Category: Utility routines
30508               * Summary: Set the behaviour of the ESCAPE and BREAK keys
30509               *
30510               * ------------------------------------------------------------------------------
30511               *
30512               * This is the equivalent of a *FX 200 command, which controls the behaviour of
30513               * the ESCAPE and BREAK keys.
30514               *
30515               * ------------------------------------------------------------------------------
30516               *
30517               * Arguments:
30518               *
30519               * X                   Controls the behaviour as follows:
30520               *
30521               * * 0 = Enable ESCAPE key
30522               * Normal BREAK key action
30523               *
30524               * * 1 = Disable ESCAPE key
30525               * Normal BREAK key action
30526               *
30527               * * 2 = Enable ESCAPE key
30528               * Clear memory if the BREAK key is pressed
30529               *
30530               * * 3 = Disable ESCAPE key
30531               * Clear memory if the BREAK key is pressed
30532               *
30533               * ******************************************************************************
30534               
30535               FX200:
30536 C96A 0202  20        li   ry,>00*256                 ; LDY #0            ; Call OSBYTE 200 with Y = 0, so the new value is set to
     C96C 0000     
30537 C96E 0200  20        li   ra,>c8*256                 ; LDA #200          ; X, and return from the subroutine using a tail call
     C970 C800     
30538 C972 0460  28        b    @OSBYTE                    ; JMP OSBYTE
     C974 FFF4     
30539               
30540 C976 0460  28        b    @rts                       ; RTS               ; This instruction has no effect, as we already returned
     C978 FF1C     
30541                                                                          ; from the subroutine
30542               
30543               * ******************************************************************************
30544               *
30545               * Name: SPS1
30546               * Type: Subroutine
30547               * Category: Maths (Geometry)
30548               * Summary: Calculate the vector to the planet and store it in XX15
30549               *
30550               * ------------------------------------------------------------------------------
30551               *
30552               * Other entry points:
30553               *
30554               * SPS1+1              A BRK instruction
30555               *
30556               * ******************************************************************************
30557               
30558               SPS1:
30559 C97A 0201  20        li   rx,>00*256                 ; LDX #0            ; Copy the two high bytes of the planet's x-coordinate
     C97C 0000     
30560 C97E 0206  20        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(2 1 0), separating out the sign bit into K3+2
     C980 AEE8     
30561 C982 06A0  32        bl   @jsr                       ;
     C984 FF10     
30562               
30563 C986 0201  20        li   rx,>03*256                 ; LDX #3            ; Copy the two high bytes of the planet's y-coordinate
     C988 0300     
30564 C98A 0206  20        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(5 4 3), separating out the sign bit into K3+5
     C98C AEE8     
30565 C98E 06A0  32        bl   @jsr                       ;
     C990 FF10     
30566               
30567 C992 0201  20        li   rx,>06*256                 ; LDX #6            ; Copy the two high bytes of the planet's z-coordinate
     C994 0600     
30568 C996 0206  20        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(8 7 6), separating out the sign bit into K3+8
     C998 AEE8     
30569 C99A 06A0  32        bl   @jsr                       ;
     C99C FF10     
30570               
30571                                                                          ; Fall through into TAS2 to build XX15 from K3
30572               
30573               * ******************************************************************************
30574               *
30575               * Name: TAS2
30576               * Type: Subroutine
30577               * Category: Maths (Geometry)
30578               * Summary: Normalise the three-coordinate vector in K3
30579               *
30580               * ------------------------------------------------------------------------------
30581               *
30582               * Normalise the vector in K3, which has 16-bit values and separate sign bits,
30583               * and store the normalised version in XX15 as a signed 8-bit vector.
30584               *
30585               * A normalised vector (also known as a unit vector) has length 1, so this
30586               * routine takes an existing vector in K3 and scales it so the length of the
30587               * new vector is 1. This is used in two places: when drawing the compass, and
30588               * when applying AI tactics to ships.
30589               *
30590               * We do this in two stages. This stage shifts the 16-bit vector coordinates in
30591               * K3 to the left as far as they will go without losing any bits off the end, so
30592               * we can then take the high bytes and use them as the most accurate 8-bit vector
30593               * to normalise. Then the next stage (in routine NORM) does the normalisation.
30594               *
30595               * ------------------------------------------------------------------------------
30596               *
30597               * Arguments:
30598               *
30599               * K3(2 1 0)           The 16-bit x-coordinate as (x_sign x_hi x_lo), where
30600               * x_sign is just bit 7
30601               *
30602               * K3(5 4 3)           The 16-bit y-coordinate as (y_sign y_hi y_lo), where
30603               * y_sign is just bit 7
30604               *
30605               * K3(8 7 6)           The 16-bit z-coordinate as (z_sign z_hi z_lo), where
30606               * z_sign is just bit 7
30607               *
30608               * ------------------------------------------------------------------------------
30609               *
30610               * Returns:
30611               *
30612               * XX15                The normalised vector, with:
30613               *
30614               * * The x-coordinate in XX15
30615               *
30616               * * The y-coordinate in XX15+1
30617               *
30618               * * The z-coordinate in XX15+2
30619               *
30620               * ------------------------------------------------------------------------------
30621               *
30622               * Other entry points:
30623               *
30624               * TA2                 Calculate the length of the vector in XX15 (ignoring the
30625               * low coordinates), returning it in Q
30626               *
30627               * ******************************************************************************
30628               
30629               TAS2:
30630 C99E D020  30        movb @K3,ra                     ; LDA K3            ; OR the three low bytes and 1 to get a byte that has
     C9A0 00D2     
30631 C9A2 F020  30        socb @K3+3,ra                   ; ORA K3+3          ; a 1 wherever any of the three low bytes has a 1
     C9A4 00D5     
30632 C9A6 F020  30        socb @K3+6,ra                   ; ORA K3+6          ; (as well as always having bit 0 set), and store in
     C9A8 00D8     
30633 C9AA 0260  22        ori  ra,>01*256                 ; ORA #1            ; K3+9
     C9AC 0100     
30634 C9AE D800  30        movb ra,@K3+9                   ; STA K3+9
     C9B0 00DB     
30635               
30636 C9B2 D020  30        movb @K3+1,ra                   ; LDA K3+1          ; OR the three high bytes to get a byte in A that has a
     C9B4 00D3     
30637 C9B6 F020  30        socb @K3+4,ra                   ; ORA K3+4          ; 1 wherever any of the three high bytes has a 1
     C9B8 00D6     
30638 C9BA F020  30        socb @K3+7,ra                   ; ORA K3+7
     C9BC 00D9     
30639               
30640                                                                          ; (A K3+9) now has a 1 wherever any of the 16-bit
30641                                                                          ; values in K3 has a 1
30642               TAL2:
30643                      .asl @K3+9                      ; ASL K3+9          ; Shift (A K3+9) to the left, so bit 7 of the high byte
     **** ****     > ASL
0001 C9BE D1A0  30        movb @K3+9,rtmp
     C9C0 00DB     
0002 C9C2 0246  22        andi rtmp,>ff00
     C9C4 FF00     
0003 C9C6 0A16  18        sla  rtmp,1
0004 C9C8 D806  30        movb rtmp,@K3+9
     C9CA 00DB     
                   < elite.a99
30644 C9CC 06A0  32        bl   @rola                      ; ROL A             ; goes into the C flag
     C9CE FF26     
30645               
30646 C9D0 1822  14        joc  TA2                        ; BCS TA2           ; If the left shift pushed a 1 out of the end, then we
30647                                                                          ; know that at least one of the coordinates has a 1 in
30648                                                                          ; this position, so jump to TA2 as we can't shift the
30649                                                                          ; values in K3 any further to the left
30650               
30651                      .asl @K3                        ; ASL K3            ; Shift K3(1 0), the x-coordinate, to the left
     **** ****     > ASL
0001 C9D2 D1A0  30        movb @K3,rtmp
     C9D4 00D2     
0002 C9D6 0246  22        andi rtmp,>ff00
     C9D8 FF00     
0003 C9DA 0A16  18        sla  rtmp,1
0004 C9DC D806  30        movb rtmp,@K3
     C9DE 00D2     
                   < elite.a99
30652 C9E0 0208  20        li   rarg1,K3+1                 ; ROL K3+1
     C9E2 00D3     
30653 C9E4 06A0  32        bl   @rol                       ;
     C9E6 FF36     
30654               
30655                      .asl @K3+3                      ; ASL K3+3          ; Shift K3(4 3), the y-coordinate, to the left
     **** ****     > ASL
0001 C9E8 D1A0  30        movb @K3+3,rtmp
     C9EA 00D5     
0002 C9EC 0246  22        andi rtmp,>ff00
     C9EE FF00     
0003 C9F0 0A16  18        sla  rtmp,1
0004 C9F2 D806  30        movb rtmp,@K3+3
     C9F4 00D5     
                   < elite.a99
30656 C9F6 0208  20        li   rarg1,K3+4                 ; ROL K3+4
     C9F8 00D6     
30657 C9FA 06A0  32        bl   @rol                       ;
     C9FC FF36     
30658               
30659                      .asl @K3+6                      ; ASL K3+6          ; Shift K3(6 7), the z-coordinate, to the left
     **** ****     > ASL
0001 C9FE D1A0  30        movb @K3+6,rtmp
     CA00 00D8     
0002 CA02 0246  22        andi rtmp,>ff00
     CA04 FF00     
0003 CA06 0A16  18        sla  rtmp,1
0004 CA08 D806  30        movb rtmp,@K3+6
     CA0A 00D8     
                   < elite.a99
30660 CA0C 0208  20        li   rarg1,K3+7                 ; ROL K3+7
     CA0E 00D9     
30661 CA10 06A0  32        bl   @rol                       ;
     CA12 FF36     
30662               
30663 CA14 17D4  14        jnc  TAL2                       ; BCC TAL2          ; Jump back to TAL2 to do another shift left (this BCC
30664                                                                          ; is effectively a JMP as we know bit 7 of K3+7 is not a
30665                                                                          ; 1, as otherwise bit 7 of A would have been a 1 and we
30666                                                                          ; would have taken the BCS above)
30667               
30668               TA2:
30669 CA16 D020  30        movb @K3+1,ra                   ; LDA K3+1          ; Fetch the high byte of the x-coordinate from our left-
     CA18 00D3     
30670 CA1A 0910  18        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
30671 CA1C F020  30        socb @K3+2,ra                   ; ORA K3+2          ; sign bit in there from the x_sign part of K3, and
     CA1E 00D4     
30672 CA20 D800  30        movb ra,@XX15                   ; STA XX15          ; store the resulting signed 8-bit x-coordinate in XX15
     CA22 0031     
30673               
30674 CA24 D020  30        movb @K3+4,ra                   ; LDA K3+4          ; Fetch the high byte of the y-coordinate from our left-
     CA26 00D6     
30675 CA28 0910  18        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
30676 CA2A F020  30        socb @K3+5,ra                   ; ORA K3+5          ; sign bit in there from the y_sign part of K3, and
     CA2C 00D7     
30677 CA2E D800  30        movb ra,@XX15+1                 ; STA XX15+1        ; store the resulting signed 8-bit y-coordinate in
     CA30 0032     
30678                                                                          ; XX15+1
30679               
30680 CA32 D020  30        movb @K3+7,ra                   ; LDA K3+7          ; Fetch the high byte of the z-coordinate from our left-
     CA34 00D9     
30681 CA36 0910  18        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
30682 CA38 F020  30        socb @K3+8,ra                   ; ORA K3+8          ; sign bit in there from the z_sign part of K3, and
     CA3A 00DA     
30683 CA3C D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; store the resulting signed 8-bit  z-coordinate in
     CA3E 0033     
30684                                                                          ; XX15+2
30685               
30686                                                                          ; Now we have a signed 8-bit version of the vector K3 in
30687                                                                          ; XX15, so fall through into NORM to normalise it
30688               
30689               * ******************************************************************************
30690               *
30691               * Name: NORM
30692               * Type: Subroutine
30693               * Category: Maths (Geometry)
30694               * Summary: Normalise the three-coordinate vector in XX15
30695               * Deep dive: Tidying orthonormal vectors
30696               * Orientation vectors
30697               *
30698               * ------------------------------------------------------------------------------
30699               *
30700               * We do this by dividing each of the three coordinates by the length of the
30701               * vector, which we can calculate using Pythagoras. Once normalised, 96 (&60) is
30702               * used to represent a value of 1, and 96 with bit 7 set (&E0) is used to
30703               * represent -1. This enables us to represent fractional values of less than 1
30704               * using integers.
30705               *
30706               * ------------------------------------------------------------------------------
30707               *
30708               * Arguments:
30709               *
30710               * XX15                The vector to normalise, with:
30711               *
30712               * * The x-coordinate in XX15
30713               *
30714               * * The y-coordinate in XX15+1
30715               *
30716               * * The z-coordinate in XX15+2
30717               *
30718               * ------------------------------------------------------------------------------
30719               *
30720               * Returns:
30721               *
30722               * XX15                The normalised vector
30723               *
30724               * Q                   The length of the original XX15 vector
30725               *
30726               * ------------------------------------------------------------------------------
30727               *
30728               * Other entry points:
30729               *
30730               * NO1                 Contains an RTS
30731               *
30732               * ******************************************************************************
30733               
30734               NORM:
30735 CA40 D020  30        movb @XX15,ra                   ; LDA XX15          ; Fetch the x-coordinate into A
     CA42 0031     
30736               
30737 CA44 0206  20        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = x^2
     CA46 42B6     
30738 CA48 06A0  32        bl   @jsr                       ;
     CA4A FF10     
30739               
30740 CA4C D800  30        movb ra,@R                      ; STA R             ; Set (R Q) = (A P) = x^2
     CA4E 0091     
30741 CA50 D020  30        movb @P,ra                      ; LDA P
     CA52 001B     
30742 CA54 D800  30        movb ra,@Q                      ; STA Q
     CA56 0090     
30743               
30744 CA58 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Fetch the y-coordinate into A
     CA5A 0032     
30745               
30746 CA5C 0206  20        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = y^2
     CA5E 42B6     
30747 CA60 06A0  32        bl   @jsr                       ;
     CA62 FF10     
30748               
30749 CA64 D800  30        movb ra,@T                      ; STA T             ; Set (T P) = (A P) = y^2
     CA66 00D1     
30750               
30751 CA68 D020  30        movb @P,ra                      ; LDA P             ; Set (R Q) = (R Q) + (T P) = x^2 + y^2
     CA6A 001B     
30752                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 CA6C 1701  14        jnc  !
0002 CA6E B004  18        ab   rone,ra
0003               !:
0004 CA70 B020  30        ab   @Q,ra
     CA72 0090     
                   < elite.a99
30753 CA74 D800  30        movb ra,@Q                      ; STA Q             ; First, doing the low bytes, Q = Q + P
     CA76 0090     
30754               
30755 CA78 D020  30        movb @T,ra                      ; LDA T             ; And then the high bytes, R = R + T
     CA7A 00D1     
30756                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 CA7C 1701  14        jnc  !
0002 CA7E B004  18        ab   rone,ra
0003               !:
0004 CA80 B020  30        ab   @R,ra
     CA82 0091     
                   < elite.a99
30757 CA84 D800  30        movb ra,@R                      ; STA R
     CA86 0091     
30758               
30759 CA88 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Fetch the z-coordinate into A
     CA8A 0033     
30760               
30761 CA8C 0206  20        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = z^2
     CA8E 42B6     
30762 CA90 06A0  32        bl   @jsr                       ;
     CA92 FF10     
30763               
30764 CA94 D800  30        movb ra,@T                      ; STA T             ; Set (T P) = (A P) = z^2
     CA96 00D1     
30765               
30766 CA98 D020  30        movb @P,ra                      ; LDA P             ; Set (R Q) = (R Q) + (T P) = x^2 + y^2 + z^2
     CA9A 001B     
30767                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 CA9C 1701  14        jnc  !
0002 CA9E B004  18        ab   rone,ra
0003               !:
0004 CAA0 B020  30        ab   @Q,ra
     CAA2 0090     
                   < elite.a99
30768 CAA4 D800  30        movb ra,@Q                      ; STA Q             ; First, doing the low bytes, Q = Q + P
     CAA6 0090     
30769               
30770 CAA8 D020  30        movb @T,ra                      ; LDA T             ; And then the high bytes, R = R + T
     CAAA 00D1     
30771                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 CAAC 1701  14        jnc  !
0002 CAAE B004  18        ab   rone,ra
0003               !:
0004 CAB0 B020  30        ab   @R,ra
     CAB2 0091     
                   < elite.a99
30772 CAB4 D800  30        movb ra,@R                      ; STA R
     CAB6 0091     
30773               
30774 CAB8 0206  20        li   rtmp,LL5                   ; JSR LL5           ; We now have the following:
     CABA D2B6     
30775 CABC 06A0  32        bl   @jsr                       ;
     CABE FF10     
30776                                                                          ;
30777                                                                          ; (R Q) = x^2 + y^2 + z^2
30778                                                                          ;
30779                                                                          ; so we can call LL5 to use Pythagoras to get:
30780                                                                          ;
30781                                                                          ; Q = SQRT(R Q)
30782                                                                          ; = SQRT(x^2 + y^2 + z^2)
30783                                                                          ;
30784                                                                          ; So Q now contains the length of the vector (x, y, z),
30785                                                                          ; and we can normalise the vector by dividing each of
30786                                                                          ; the coordinates by this value, which we do by calling
30787                                                                          ; routine TIS2. TIS2 returns the divided figure, using
30788                                                                          ; 96 to represent 1 and 96 with bit 7 set for -1
30789               
30790 CAC0 D020  30        movb @XX15,ra                   ; LDA XX15          ; Call TIS2 to divide the x-coordinate in XX15 by Q,
     CAC2 0031     
30791 CAC4 0206  20        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     CAC6 D0CA     
30792 CAC8 06A0  32        bl   @jsr                       ;
     CACA FF10     
30793 CACC D800  30        movb ra,@XX15                   ; STA XX15
     CACE 0031     
30794               
30795 CAD0 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Call TIS2 to divide the y-coordinate in XX15+1 by Q,
     CAD2 0032     
30796 CAD4 0206  20        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     CAD6 D0CA     
30797 CAD8 06A0  32        bl   @jsr                       ;
     CADA FF10     
30798 CADC D800  30        movb ra,@XX15+1                 ; STA XX15+1
     CADE 0032     
30799               
30800 CAE0 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Call TIS2 to divide the z-coordinate in XX15+2 by Q,
     CAE2 0033     
30801 CAE4 0206  20        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     CAE6 D0CA     
30802 CAE8 06A0  32        bl   @jsr                       ;
     CAEA FF10     
30803 CAEC D800  30        movb ra,@XX15+2                 ; STA XX15+2
     CAEE 0033     
30804               
30805               NO1:
30806 CAF0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CAF2 FF1C     
30807               
30808               * ******************************************************************************
30809               *
30810               * Name: RDKEY
30811               * Type: Subroutine
30812               * Category: Keyboard
30813               * Summary: Scan the keyboard for key presses
30814               *
30815               * ------------------------------------------------------------------------------
30816               *
30817               * Scan the keyboard, starting with internal key number 16 ("Q") and working
30818               * through the set of internal key numbers (see p.142 of the Advanced User Guide
30819               * for a list of internal key numbers).
30820               *
30821               * This routine is effectively the same as OSBYTE 122, though the OSBYTE call
30822               * preserves A, unlike this routine.
30823               *
30824               * ------------------------------------------------------------------------------
30825               *
30826               * Returns:
30827               *
30828               * X                   If a key is being pressed, X contains the internal key
30829               * number, otherwise it contains 0
30830               *
30831               * A                   Contains the same as X
30832               *
30833               * ******************************************************************************
30834               
30835               RDKEY:
30836 CAF4 0201  20        li   rx,>10*256                 ; LDX #16           ; Start the scan with internal key number 16 ("Q")
     CAF6 1000     
30837               
30838               Rd1:
30839 CAF8 0206  20        li   rtmp,DKS4                  ; JSR DKS4          ; Scan the keyboard to see if the key in X is currently
     CAFA CC28     
30840 CAFC 06A0  32        bl   @jsr                       ;
     CAFE FF10     
30841                                                                          ; being pressed, returning the result in A and X
30842               
30843 CB00 1103  14        jlt  Rd2                        ; BMI Rd2           ; Jump to Rd2 if this key is being pressed (in which
30844                                                                          ; case DKS4 will have returned the key number with bit
30845                                                                          ; 7 set, which is negative)
30846               
30847 CB02 B044  18        ab   rone,rx                    ; INX               ; Increment the key number, which was unchanged by the
30848                                                                          ; above call to DKS4
30849               
30850 CB04 15F9  14        jgt  Rd1                        ; BPL Rd1           ; Loop back to test the next key, ending the loop when
30851                                                                          ; X is negative (i.e. 128)
30852               
30853 CB06 D001  18        movb rx,ra                      ; TXA               ; If we get here, nothing is being pressed, so copy X
30854                                                                          ; into A so that X = A = 128 = %10000000
30855               
30856               Rd2:
30857                      .eoi (>80*256)                  ; EOR #%10000000    ; EOR A with #%10000000 to flip bit 7, so A now contains
     **** ****     > EOI
0001 CB08 0206  20        li   rtmp,(>80*256)
     CB0A 8000     
0002 CB0C 2806  18        xor  rtmp,ra
                   < elite.a99
30858                                                                          ; 0 if no key has been pressed, or the internal key
30859                                                                          ; number if a key has been pressed
30860               
30861 CB0E D040  18        movb ra,rx                      ; TAX               ; Copy A into X
30862               
30863 CB10 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CB12 FF1C     
30864               
30865               * ******************************************************************************
30866               *
30867               * Name: ECMOF
30868               * Type: Subroutine
30869               * Category: Sound
30870               * Summary: Switch off the E.C.M.
30871               *
30872               * ------------------------------------------------------------------------------
30873               *
30874               * Switch the E.C.M. off, turn off the dashboard bulb and make the sound of the
30875               * E.C.M. switching off).
30876               *
30877               * ******************************************************************************
30878               
30879               ECMOF:
30880 CB14 0200  20        li   ra,>00*256                 ; LDA #0            ; Set ECMA and ECMP to 0 to indicate that no E.C.M. is
     CB16 0000     
30881 CB18 D800  30        movb ra,@ECMA                   ; STA ECMA          ; currently running
     CB1A 0030     
30882 CB1C D800  30        movb ra,@ECMP                   ; STA ECMP
     CB1E 0D5B     
30883               
30884 CB20 0206  20        li   rtmp,ECBLB                 ; JSR ECBLB         ; Update the E.C.M. indicator bulb on the dashboard
     CB22 B0D4     
30885 CB24 06A0  32        bl   @jsr                       ;
     CB26 FF10     
30886               
30887 CB28 0200  20        li   ra,>48*256                 ; LDA #72           ; Call the NOISE routine with A = 72 to make the sound
     CB2A 4800     
30888 CB2C 1641  14        jne  NOISE                      ; BNE NOISE         ; of the E.C.M. being turned off and return from the
30889                                                                          ; subroutine using a tail call (this BNE is effectively
30890                                                                          ; a JMP as A will never be zero)
30891               
30892               * ******************************************************************************
30893               *
30894               * Name: EXNO3
30895               * Type: Subroutine
30896               * Category: Sound
30897               * Summary: Make an explosion sound
30898               *
30899               * ------------------------------------------------------------------------------
30900               *
30901               * Make the sound of death in the cold, hard vacuum of space. Apparently, in
30902               * Elite space, everyone can hear you scream.
30903               *
30904               * This routine also makes the sound of a destroyed cargo canister if we don't
30905               * get scooping right, the sound of us colliding with another ship, and the sound
30906               * of us being hit with depleted shields. It is not a good sound to hear.
30907               *
30908               * ******************************************************************************
30909               
30910               EXNO3:
30911 CB2E 0200  20        li   ra,>10*256                 ; LDA #16           ; Call the NOISE routine with A = 16 to make the first
     CB30 1000     
30912 CB32 0206  20        li   rtmp,NOISE                 ; JSR NOISE         ; death sound
     CB34 CBB0     
30913 CB36 06A0  32        bl   @jsr                       ;
     CB38 FF10     
30914               
30915 CB3A 0200  20        li   ra,>18*256                 ; LDA #24           ; Call the NOISE routine with A = 24 to make the second
     CB3C 1800     
30916 CB3E 1638  14        jne  NOISE                      ; BNE NOISE         ; death sound and return from the subroutine using a
30917                                                                          ; tail call (this BNE is effectively a JMP as A will
30918                                                                          ; never be zero)
30919               
30920               * ******************************************************************************
30921               *
30922               * Name: SFRMIS
30923               * Type: Subroutine
30924               * Category: Tactics
30925               * Summary: Add an enemy missile to our local bubble of universe
30926               *
30927               * ------------------------------------------------------------------------------
30928               *
30929               * An enemy has fired a missile, so add the missile to our universe if there is
30930               * room, and if there is, make the appropriate warnings and noises.
30931               *
30932               * ******************************************************************************
30933               
30934               SFRMIS:
30935 CB40 0201  20        li   rx,(MSL)*256               ; LDX #MSL          ; Set X to the ship type of a missile, and call SFS1-2
     CB42 0900     
30936 CB44 0206  20        li   rtmp,SFS1-2                ; JSR SFS1-2        ; to add the missile to our universe with an AI flag
     CB46 3D00     
30937 CB48 06A0  32        bl   @jsr                       ;
     CB4A FF10     
30938                                                                          ; of %11111110 (AI enabled, hostile, no E.C.M.)
30939               
30940 CB4C 17D1  14        jnc  NO1                        ; BCC NO1           ; The C flag will be set if the call to SFS1-2 was a
30941                                                                          ; success, so if it's clear, jump to NO1 to return from
30942                                                                          ; the subroutine (as NO1 contains an RTS)
30943               
30944 CB4E 0200  20        li   ra,>78*256                 ; LDA #120          ; Print recursive token 120 ("INCOMING MISSILE") as an
     CB50 7800     
30945 CB52 0206  20        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     CB54 CE5E     
30946 CB56 06A0  32        bl   @jsr                       ;
     CB58 FF10     
30947               
30948 CB5A 0200  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     CB5C 3000     
30949 CB5E 1628  14        jne  NOISE                      ; BNE NOISE         ; of the missile being launched and return from the
30950                                                                          ; subroutine using a tail call (this BNE is effectively
30951                                                                          ; a JMP as A will never be zero)
30952               
30953               * ******************************************************************************
30954               *
30955               * Name: EXNO2
30956               * Type: Subroutine
30957               * Category: Status
30958               * Summary: Process us making a kill
30959               * Deep dive: Combat rank
30960               *
30961               * ------------------------------------------------------------------------------
30962               *
30963               * We have killed a ship, so increase the kill tally, displaying an iconic
30964               * message of encouragement if the kill total is a multiple of 256, and then
30965               * make a nearby explosion sound.
30966               *
30967               * ******************************************************************************
30968               
30969               EXNO2:
30970 CB60 B004  18        ab   rone,ra                    ; INC TALLY         ; Increment the low byte of the kill count in TALLY
30971               
30972 CB62 1608  14        jne  EXNO-2                     ; BNE EXNO-2        ; If there is no carry, jump to the LDX #7 below (at
30973                                                                          ; EXNO-2)
30974               
30975 CB64 B004  18        ab   rone,ra                    ; INC TALLY+1       ; Increment the high byte of the kill count in TALLY
30976               
30977 CB66 0200  20        li   ra,>65*256                 ; LDA #101          ; The kill total is a multiple of 256, so it's time
     CB68 6500     
30978 CB6A 0206  20        li   rtmp,MESS                  ; JSR MESS          ; for a pat on the back, so print recursive token 101
     CB6C CE5E     
30979 CB6E 06A0  32        bl   @jsr                       ;
     CB70 FF10     
30980                                                                          ; ("RIGHT ON COMMANDER!") as an in-flight message
30981               
30982 CB72 0201  20        li   rx,>07*256                 ; LDX #7            ; Set X = 7 and fall through into EXNO to make the
     CB74 0700     
30983                                                                          ; sound of a ship exploding
30984               
30985               * ******************************************************************************
30986               *
30987               * Name: EXNO
30988               * Type: Subroutine
30989               * Category: Sound
30990               * Summary: Make the sound of a laser strike or ship explosion
30991               *
30992               * ------------------------------------------------------------------------------
30993               *
30994               * Make the two-part explosion sound of us making a laser strike, or of another
30995               * ship exploding.
30996               *
30997               * The volume of the first explosion is affected by the distance of the ship
30998               * being hit, with more distant ships being quieter. The value in X also affects
30999               * the volume of the first explosion, with a higher X giving a quieter sound
31000               * (so X can be used to differentiate a laser strike from an explosion).
31001               *
31002               * ------------------------------------------------------------------------------
31003               *
31004               * Arguments:
31005               *
31006               * X                   The larger the value of X, the fainter the explosion.
31007               * Allowed values are:
31008               *
31009               * * 7  = explosion is louder (i.e. the ship has just
31010               * exploded)
31011               *
31012               * * 15 = explosion is quieter (i.e. this is just a laser
31013               * strike)
31014               *
31015               * ------------------------------------------------------------------------------
31016               *
31017               * Other entry points:
31018               *
31019               * EXNO-2              Set X = 7 and fall through into EXNO to make the sound
31020               * of a ship exploding
31021               *
31022               * ******************************************************************************
31023               
31024               EXNO:
31025 CB76 D801  30        movb rx,@T                      ; STX T             ; Store the distance in T
     CB78 00D1     
31026               
31027 CB7A 0200  20        li   ra,>18*256                 ; LDA #24           ; Set A = 24 to denote the sound of us making a hit or
     CB7C 1800     
31028 CB7E 0206  20        li   rtmp,NOS1                  ; JSR NOS1          ; kill (part 1 of the explosion), and call NOS1 to set
     CB80 CBCE     
31029 CB82 06A0  32        bl   @jsr                       ;
     CB84 FF10     
31030                                                                          ; up the sound block in XX16
31031               
31032 CB86 D020  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Fetch z_hi, the distance of the ship being hit in
     CB88 005A     
31033 CB8A 0910  18        srl  ra,1                       ; LSR A             ; terms of the z-axis (in and out of the screen), and
31034 CB8C 0910  18        srl  ra,1                       ; LSR A             ; divide by 4. If z_hi has either bit 6 or 7 set then
31035                                                                          ; that ship is too far away to be shown on the scanner
31036                                                                          ; (as per the SCAN routine), so we know the maximum
31037                                                                          ; z_hi at this point is %00111111, and shifting z_hi
31038                                                                          ; to the right twice gives us a maximum value of
31039                                                                          ; %00001111
31040               
31041                      .and @T                         ; AND T             ; This reduces A to a maximum of X; X can be either
     **** ****     > AND
0001 CB8E D1A0  30        movb @T,rtmp
     CB90 00D1     
0002 CB92 0546  14        inv  rtmp
0003 CB94 5006  18        szcb rtmp,ra
                   < elite.a99
31042                                                                          ; 7 = %0111 or 15 = %1111, so AND'ing with 15 will
31043                                                                          ; not affect A, while AND'ing with 7 will clear bit
31044                                                                          ; 3, reducing the maximum value in A to 7
31045               
31046 CB96 0260  22        ori  ra,>f1*256                 ; ORA #%11110001    ; The SOUND statement's amplitude ranges from 0 (for no
     CB98 F100     
31047                                                                          ; sound) to -15 (full volume), so we can set bits 0 and
31048                                                                          ; 4-7 in A, and keep bits 1-3 from the above to get
31049                                                                          ; a value between -15 (%11110001) and -1 (%11111111),
31050                                                                          ; with lower values of z_hi and argument X leading
31051                                                                          ; to a more negative, or quieter number (so the closer
31052                                                                          ; the ship, i.e. the smaller the value of X, the louder
31053                                                                          ; the sound)
31054               
31055 CB9A D800  30        movb ra,@XX16+2                 ; STA XX16+2        ; The amplitude byte of the sound block in XX16 is in
     CB9C 000B     
31056                                                                          ; byte #3 (where it's the low byte of the amplitude), so
31057                                                                          ; this sets the amplitude to the value in A
31058               
31059 CB9E 0206  20        li   rtmp,NO3                   ; JSR NO3           ; Make the sound from our updated sound block in XX16
     CBA0 CBB8     
31060 CBA2 06A0  32        bl   @jsr                       ;
     CBA4 FF10     
31061               
31062 CBA6 0200  20        li   ra,>10*256                 ; LDA #16           ; Set A = 16 to denote we have made a hit or kill
     CBA8 1000     
31063                                                                          ; (part 2 of the explosion), and fall through into NOISE
31064                                                                          ; to make the sound
31065               
31066 CBAA 2C              byte >2c                                            ; Skip the next instruction by turning it into
31067                                                                          ; &2C &A9 &20, or BIT &20A9, which does nothing apart
31068                                                                          ; from affect the flags
31069               
31070               * ******************************************************************************
31071               *
31072               * Name: BEEP
31073               * Type: Subroutine
31074               * Category: Sound
31075               * Summary: Make a short, high beep
31076               *
31077               * ******************************************************************************
31078               
31079               BEEP:
31080 CBAC 0200  20        li   ra,>20*256                 ; LDA #32           ; Set A = 32 to denote a short, high beep, and fall
     CBAE 2000     
31081                                                                          ; through into the NOISE routine to make the sound
31082               
31083               * ******************************************************************************
31084               *
31085               * Name: NOISE
31086               * Type: Subroutine
31087               * Category: Sound
31088               * Summary: Make the sound whose number is in A
31089               *
31090               * ------------------------------------------------------------------------------
31091               *
31092               * Arguments:
31093               *
31094               * A                   The number of the sound to be made. See the
31095               * documentation for variable SFX for a list of sound
31096               * numbers
31097               *
31098               * ******************************************************************************
31099               
31100               NOISE:
31101 CBB0 0206  20        li   rtmp,NOS1                  ; JSR NOS1          ; Set up the sound block in XX16 for the sound in A and
     CBB2 CBCE     
31102 CBB4 06A0  32        bl   @jsr                       ;
     CBB6 FF10     
31103                                                                          ; fall through into NO3 to make the sound
31104               
31105               * ******************************************************************************
31106               *
31107               * Name: NO3
31108               * Type: Subroutine
31109               * Category: Sound
31110               * Summary: Make a sound from a prepared sound block
31111               *
31112               * ------------------------------------------------------------------------------
31113               *
31114               * Make a sound from a prepared sound block in XX16 (if sound is enabled). See
31115               * routine NOS1 for details of preparing the XX16 sound block.
31116               *
31117               * ******************************************************************************
31118               
31119               NO3:
31120 CBB8 D060  30        movb @DNOIZ,rx                  ; LDX DNOIZ         ; Set X to the DNOIZ configuration setting
     CBBA 0F49     
31121               
31122 CBBC 1699  14        jne  NO1                        ; BNE NO1           ; If DNOIZ is non-zero, then sound is disabled, so
31123                                                                          ; return from the subroutine (as NO1 contains an RTS)
31124               
31125 CBBE 0201  20        li   rx,((XX16)%256)*256        ; LDX #LO(XX16)     ; Otherwise set (Y X) to point to the sound block in
     CBC0 0900     
31126 CBC2 0202  20        li   ry,((XX16)/256)*256        ; LDY #HI(XX16)     ; XX16
     CBC4 0000     
31127               
31128 CBC6 0200  20        li   ra,>07*256                 ; LDA #7            ; Call OSWORD 7 to makes the sound, as described in the
     CBC8 0700     
31129 CBCA 0460  28        b    @OSWORD                    ; JMP OSWORD        ; documentation for variable SFX, and return from the
     CBCC FFF1     
31130                                                                          ; subroutine using a tail call
31131               
31132               * ******************************************************************************
31133               *
31134               * Name: NOS1
31135               * Type: Subroutine
31136               * Category: Sound
31137               * Summary: Prepare a sound block
31138               *
31139               * ------------------------------------------------------------------------------
31140               *
31141               * Copy four sound bytes from SFX into XX16, interspersing them with null bytes,
31142               * with Y indicating the sound number to copy (from the values in the sound
31143               * table at SFX). So, for example, if we call this routine with A = 40 (long,
31144               * low beep), the following bytes will be set in XX16 to XX16+7:
31145               *
31146               * &13 &00 &F4 &00 &0C &00 &08 &00
31147               *
31148               * This block will be passed to OSWORD 7 to make the sound, which expects the
31149               * four sound attributes as 16-bit big-endian values - in other words, with the
31150               * low byte first. So the above block would pass the values &0013, &00F4, &000C
31151               * and &0008 to the SOUND statement when used with OSWORD 7, or:
31152               *
31153               * SOUND &13, &F4, &0C, &08
31154               *
31155               * as the high bytes are always zero.
31156               *
31157               * ------------------------------------------------------------------------------
31158               *
31159               * Arguments:
31160               *
31161               * A                   The sound number to copy from SFX to XX16, which is
31162               * always a multiple of 8
31163               *
31164               * ******************************************************************************
31165               
31166               NOS1:
31167 CBCE 0910  18        srl  ra,1                       ; LSR A             ; Divide A by 2, and also clear the C flag, as bit 0 of
31168                                                                          ; A is always zero (as A is a multiple of 8)
31169               
31170                      .adi (>03*256)                  ; ADC #3            ; Set Y = A + 3, so Y now points to the last byte of
     **** ****     > ADI
0001 CBD0 1701  14        jnc  !
0002 CBD2 B004  18        ab   rone,ra
0003               !:
0004 CBD4 0220  22        ai   ra,(>03*256)
     CBD6 0300     
                   < elite.a99
31171 CBD8 D080  18        movb ra,ry                      ; TAY               ; four within the block of four-byte values
31172               
31173 CBDA 0201  20        li   rx,>07*256                 ; LDX #7            ; We want to copy four bytes, spread out into an 8-byte
     CBDC 0700     
31174                                                                          ; block, so set a counter in Y to cover 8 bytes
31175               
31176               NOL1:
31177 CBDE 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the X-th byte of XX16 to 0
     CBE0 0000     
31178 CBE2 D840  38        movb ra,@XX16(rx)               ; STA XX16,X
     CBE4 0009     
31179               
31180 CBE6 7044  18        sb   rone,rx                    ; DEX               ; Decrement the destination byte pointer
31181               
31182 CBE8 D022  34        movb @SFX(ry),ra                ; LDA SFX,Y         ; Set the X-th byte of XX16 to the value from SFX+Y
     CBEA BEE2     
31183 CBEC D840  38        movb ra,@XX16(rx)               ; STA XX16,X
     CBEE 0009     
31184               
31185 CBF0 7084  18        sb   rone,ry                    ; DEY               ; Decrement the source byte pointer again
31186               
31187 CBF2 7044  18        sb   rone,rx                    ; DEX               ; Decrement the destination byte pointer again
31188               
31189 CBF4 15F4  14        jgt  NOL1                       ; BPL NOL1          ; Loop back for the next source byte
31190               
31191 CBF6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CBF8 FF1C     
31192               
31193               * ******************************************************************************
31194               *
31195               * Name: KYTB
31196               * Type: Variable
31197               * Category: Keyboard
31198               * Summary: Lookup table for in-flight keyboard controls
31199               * Deep dive: The key logger
31200               *
31201               * ------------------------------------------------------------------------------
31202               *
31203               * Keyboard table for in-flight controls. This table contains the internal key
31204               * codes for the flight keys (see p.142 of the Advanced User Guide for a list of
31205               * internal key numbers).
31206               *
31207               * The pitch, roll, speed and laser keys (i.e. the seven primary flight
31208               * control keys) have bit 7 set, so they have 128 added to their internal
31209               * values. This doesn't appear to be used anywhere.
31210               *
31211               * ******************************************************************************
31212               
31213               KYTB:                                                      ; Point KYTB to the byte before the start of the table
31214                      equ $ - 1
31215               
31216                                                                          ; These are the primary flight controls (pitch, roll,
31217                                                                          ; speed and lasers):
31218               
31219 CBFA E8              byte >68 + 128                                      ; ?         KYTB+1      Slow down
31220 CBFB   E2            byte >62 + 128                                      ; Space     KYTB+2      Speed up
31221 CBFC E6              byte >66 + 128                                      ; <         KYTB+3      Roll left
31222 CBFD   E7            byte >67 + 128                                      ; >         KYTB+4      Roll right
31223 CBFE C2              byte >42 + 128                                      ; X         KYTB+5      Pitch up
31224 CBFF   D1            byte >51 + 128                                      ; S         KYTB+6      Pitch down
31225 CC00 C1              byte >41 + 128                                      ; A         KYTB+7      Fire lasers
31226               
31227                                                                          ; These are the secondary flight controls:
31228               
31229 CC01   60            byte >60                                            ; TAB       KYTB+8      Energy bomb
31230 CC02 70              byte >70                                            ; ESCAPE    KYTB+9      Launch escape pod
31231 CC03   23            byte >23                                            ; T         KYTB+10     Arm missile
31232 CC04 35              byte >35                                            ; U         KYTB+11     Unarm missile
31233 CC05   65            byte >65                                            ; M         KYTB+12     Fire missile
31234 CC06 22              byte >22                                            ; E         KYTB+13     E.C.M.
31235 CC07   45            byte >45                                            ; J         KYTB+14     In-system jump
31236 CC08 52              byte >52                                            ; C         KYTB+15     Docking computer
31237               
31238               * ******************************************************************************
31239               *
31240               * Name: DKS1
31241               * Type: Subroutine
31242               * Category: Keyboard
31243               * Summary: Scan the keyboard for a flight key
31244               * Deep dive: The key logger
31245               *
31246               * ------------------------------------------------------------------------------
31247               *
31248               * Scan the keyboard for the flight key given in register Y, where Y is the
31249               * offset into the KYTB table above (so we can scan for Space by setting Y to
31250               * 2, for example). If the key is pressed, set the corresponding byte in the
31251               * key logger at KL to &FF.
31252               *
31253               * ------------------------------------------------------------------------------
31254               *
31255               * Arguments:
31256               *
31257               * Y                   The offset into the KYTB table above of the key that we
31258               * want to scan on the keyboard
31259               *
31260               * ******************************************************************************
31261               
31262               DKS1:
31263 CC0A D062  34        movb @KYTB(ry),rx               ; LDX KYTB,Y        ; Get the internal key number from the Y-th byte of the
     CC0C CBF9     
31264                                                                          ; KYTB table above
31265               
31266 CC0E 0206  20        li   rtmp,DKS4                  ; JSR DKS4          ; Call DKS4, which will set A and X to a negative value
     CC10 CC28     
31267 CC12 06A0  32        bl   @jsr                       ;
     CC14 FF10     
31268                                                                          ; if the key is being pressed
31269               
31270 CC16 151E  14        jgt  DKS2-1                     ; BPL DKS2-1        ; The key is not being pressed, so return from the
31271                                                                          ; subroutine (as DKS2-1 contains an RTS)
31272               
31273 CC18 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Store &FF in the Y-th byte of the key logger at KL
     CC1A FF00     
31274 CC1C D881  38        movb rx,@KL(ry)                 ; STX KL,Y
     CC1E 0041     
31275               
31276 CC20 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CC22 FF1C     
31277               
31278               * ******************************************************************************
31279               *
31280               * Name: CTRL
31281               * Type: Subroutine
31282               * Category: Keyboard
31283               * Summary: Scan the keyboard to see if CTRL is currently pressed
31284               *
31285               * ------------------------------------------------------------------------------
31286               *
31287               * Returns:
31288               *
31289               * X                   X = %10000001 (i.e. 129 or -127) if CTRL is being
31290               * pressed
31291               *
31292               * X = 1 if CTRL is not being pressed
31293               *
31294               * A                   Contains the same as X
31295               *
31296               * ******************************************************************************
31297               
31298               CTRL:
31299 CC24 0201  20        li   rx,>01*256                 ; LDX #1            ; Set X to the internal key number for CTRL and fall
     CC26 0100     
31300                                                                          ; through to DKS4 to scan the keyboard
31301               
31302               * ******************************************************************************
31303               *
31304               * Name: DKS4
31305               * Type: Subroutine
31306               * Category: Keyboard
31307               * Summary: Scan the keyboard to see if a specific key is being pressed
31308               * Deep dive: The key logger
31309               *
31310               * ------------------------------------------------------------------------------
31311               *
31312               * Arguments:
31313               *
31314               * X                   The internal number of the key to check (see p.142 of
31315               * the Advanced User Guide for a list of internal key
31316               * numbers)
31317               *
31318               * ------------------------------------------------------------------------------
31319               *
31320               * Returns:
31321               *
31322               * A                   If the key in A is being pressed, A contains the
31323               * original argument A, but with bit 7 set (i.e. A + 128).
31324               * If the key in A is not being pressed, the value in A is
31325               * unchanged
31326               *
31327               * X                   Contains the same as A
31328               *
31329               * ******************************************************************************
31330               
31331               DKS4:
31332 CC28 0200  20        li   ra,>03*256                 ; LDA #%00000011    ; Set A to %00000011, so it's ready to send to SHEILA
     CC2A 0300     
31333                                                                          ; once interrupts have been disabled
31334               
31335 CC2C 0300  22        limi 0                          ; SEI               ; Disable interrupts so we can scan the keyboard
     CC2E 0000     
31336                                                                          ; without being hijacked
31337               
31338 CC30 D800  38        movb ra,@VIA+>40                ; STA VIA+&40       ; Set 6522 System VIA output register ORB (SHEILA &40)
     CC32 FE40     
31339                                                                          ; to %00000011 to stop auto scan of keyboard
31340               
31341 CC34 0200  20        li   ra,>7f*256                 ; LDA #%01111111    ; Set 6522 System VIA data direction register DDRA
     CC36 7F00     
31342 CC38 D800  38        movb ra,@VIA+>43                ; STA VIA+&43       ; (SHEILA &43) to %01111111. This sets the A registers
     CC3A FE43     
31343                                                                          ; (IRA and ORA) so that:
31344                                                                          ;
31345                                                                          ; * Bits 0-6 of ORA will be sent to the keyboard
31346                                                                          ;
31347                                                                          ; * Bit 7 of IRA will be read from the keyboard
31348               
31349 CC3C D801  38        movb rx,@VIA+>4F                ; STX VIA+&4F       ; Set 6522 System VIA output register ORA (SHEILA &4F)
     CC3E FE4F     
31350                                                                          ; to X, the key we want to scan for; bits 0-6 will be
31351                                                                          ; sent to the keyboard, of which bits 0-3 determine the
31352                                                                          ; keyboard column, and bits 4-6 the keyboard row
31353               
31354 CC40 D060  34        movb @VIA+>4F,rx                ; LDX VIA+&4F       ; Read 6522 System VIA output register IRA (SHEILA &4F)
     CC42 FE4F     
31355                                                                          ; into X; bit 7 is the only bit that will have changed.
31356                                                                          ; If the key is pressed, then bit 7 will be set,
31357                                                                          ; otherwise it will be clear
31358               
31359 CC44 0200  20        li   ra,>0b*256                 ; LDA #%00001011    ; Set 6522 System VIA output register ORB (SHEILA &40)
     CC46 0B00     
31360 CC48 D800  38        movb ra,@VIA+>40                ; STA VIA+&40       ; to %00001011 to restart auto scan of keyboard
     CC4A FE40     
31361               
31362 CC4C 0300  22        limi 2                          ; CLI               ; Allow interrupts again
     CC4E 0002     
31363               
31364 CC50 D001  18        movb rx,ra                      ; TXA               ; Transfer X into A
31365               
31366 CC52 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CC54 FF1C     
31367               
31368               * ******************************************************************************
31369               *
31370               * Name: DKS2
31371               * Type: Subroutine
31372               * Category: Keyboard
31373               * Summary: Read the joystick position
31374               *
31375               * ------------------------------------------------------------------------------
31376               *
31377               * Return the value of ADC channel in X (used to read the joystick). The value
31378               * will be inverted if the game has been configured to reverse both joystick
31379               * channels (which can be done by pausing the game and pressing J).
31380               *
31381               * ------------------------------------------------------------------------------
31382               *
31383               * Arguments:
31384               *
31385               * X                   The ADC channel to read:
31386               *
31387               * * 1 = joystick X
31388               *
31389               * * 2 = joystick Y
31390               *
31391               * ------------------------------------------------------------------------------
31392               *
31393               * Returns:
31394               *
31395               * (A X)               The 16-bit value read from channel X, with the value
31396               * inverted if the game has been configured to reverse the
31397               * joystick
31398               *
31399               * ------------------------------------------------------------------------------
31400               *
31401               * Other entry points:
31402               *
31403               * DKS2-1              Contains an RTS
31404               *
31405               * ******************************************************************************
31406               
31407               DKS2:
31408 CC56 0200  20        li   ra,>80*256                 ; LDA #128          ; Call OSBYTE with A = 128 to fetch the 16-bit value
     CC58 8000     
31409 CC5A 0206  20        li   rtmp,OSBYTE                ; JSR OSBYTE        ; from ADC channel X, returning (Y X), i.e. the high
     CC5C FFF4     
31410 CC5E 06A0  32        bl   @jsr                       ;
     CC60 FF10     
31411                                                                          ; byte in Y and the low byte in X
31412                                                                          ;
31413                                                                          ; * Channel 1 is the x-axis: 0 = right, 65520 = left
31414                                                                          ;
31415                                                                          ; * Channel 2 is the y-axis: 0 = down,  65520 = up
31416               
31417 CC62 D002  18        movb ry,ra                      ; TYA               ; Copy Y to A, so the result is now in (A X)
31418               
31419                      .eor @JSTE                      ; EOR JSTE          ; The high byte A is now EOR'd with the value in
     **** ****     > EOR
0001 CC64 D1A0  30        movb @JSTE,rtmp
     CC66 0F4F     
0002 CC68 2806  18        xor  rtmp,ra
                   < elite.a99
31420                                                                          ; location JSTE, which contains &FF if both joystick
31421                                                                          ; channels are reversed and 0 otherwise (so A now
31422                                                                          ; contains the high byte but inverted, if that's what
31423                                                                          ; the current settings say)
31424               
31425 CC6A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CC6C FF1C     
31426               
31427               * ******************************************************************************
31428               *
31429               * Name: DKS3
31430               * Type: Subroutine
31431               * Category: Keyboard
31432               * Summary: Toggle a configuration setting and emit a beep
31433               *
31434               * ------------------------------------------------------------------------------
31435               *
31436               * This is called when the game is paused and a key is pressed that changes the
31437               * game's configuration.
31438               *
31439               * Specifically, this routine toggles the configuration settings for the
31440               * following keys:
31441               *
31442               * * CAPS LOCK toggles keyboard flight damping (&40)
31443               * * A toggles keyboard auto-recentre (&41)
31444               * * X toggles author names on start-up screen (&42)
31445               * * F toggles flashing console bars (&43)
31446               * * Y toggles reverse joystick Y channel (&44)
31447               * * J toggles reverse both joystick channels (&45)
31448               * * K toggles keyboard and joystick (&46)
31449               *
31450               * The numbers in brackets are the internal key numbers (see p.142 of the
31451               * Advanced User Guide for a list of internal key numbers). We pass the key that
31452               * has been pressed in X, and the configuration option to check it against in Y,
31453               * so this routine is typically called in a loop that loops through the various
31454               * configuration options.
31455               *
31456               * ------------------------------------------------------------------------------
31457               *
31458               * Arguments:
31459               *
31460               * X                   The internal number of the key that's been pressed
31461               *
31462               * Y                   The internal number of the configuration key to check
31463               * against, from the list above (i.e. Y must be from &40 to
31464               * &46)
31465               *
31466               * ******************************************************************************
31467               
31468               DKS3:
31469 CC6E D802  30        movb ry,@T                      ; STY T             ; Store the configuration key argument in T
     CC70 00D1     
31470               
31471 CC72 9060  30        cb   @T,rx                      ; CPX T             ; If X <> Y, jump to Dk3 to return from the subroutine
     CC74 00D1     
31472 CC76 1611  14        jne  Dk3                        ; BNE Dk3
31473               
31474                                                                          ; We have a match between X and Y, so now to toggle
31475                                                                          ; the relevant configuration byte. CAPS LOCK has a key
31476                                                                          ; value of &40 and has its configuration byte at
31477                                                                          ; location DAMP, A has a value of &41 and has its byte
31478                                                                          ; at location DJD, which is DAMP+1, and so on. So we
31479                                                                          ; can toggle the configuration byte by changing the
31480                                                                          ; byte at DAMP + (X - &40), or to put it in indexing
31481                                                                          ; terms, DAMP-&40,X. It's no coincidence that the
31482                                                                          ; game's configuration bytes are set up in this order
31483                                                                          ; and with these keys (and this is also why the sound
31484                                                                          ; on/off keys are dealt with elsewhere, as the internal
31485                                                                          ; key for S and Q are &51 and &10, which don't fit
31486                                                                          ; nicely into this approach)
31487               
31488 CC78 D021  34        movb @DAMP->40(rx),ra           ; LDA DAMP-&40,X    ; Fetch the byte from DAMP + (X - &40), invert it and
     CC7A 0F0A     
31489                      .eoi (>ff*256)                  ; EOR #&FF          ; put it back (0 means no and &FF means yes in the
     **** ****     > EOI
0001 CC7C 0206  20        li   rtmp,(>FF*256)
     CC7E FF00     
0002 CC80 2806  18        xor  rtmp,ra
                   < elite.a99
31490 CC82 D840  38        movb ra,@DAMP->40(rx)           ; STA DAMP-&40,X    ; configuration bytes, so this toggles the setting)
     CC84 0F0A     
31491               
31492 CC86 0206  20        li   rtmp,BELL                  ; JSR BELL          ; Make a beep sound so we know something has happened
     CC88 316E     
31493 CC8A 06A0  32        bl   @jsr                       ;
     CC8C FF10     
31494               
31495 CC8E 0206  20        li   rtmp,DELAY                 ; JSR DELAY         ; Wait for Y vertical syncs (Y is between 64 and 70, so
     CC90 4C00     
31496 CC92 06A0  32        bl   @jsr                       ;
     CC94 FF10     
31497                                                                          ; this is always a bit longer than a second)
31498               
31499 CC96 D0A0  30        movb @T,ry                      ; LDY T             ; Restore the configuration key argument into Y
     CC98 00D1     
31500               
31501               Dk3:
31502 CC9A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CC9C FF1C     
31503               
31504               * ******************************************************************************
31505               *
31506               * Name: DKJ1
31507               * Type: Subroutine
31508               * Category: Keyboard
31509               * Summary: Read joystick and flight controls
31510               *
31511               * ------------------------------------------------------------------------------
31512               *
31513               * Specifically, scan the keyboard for the speed up and slow down keys, and read
31514               * the joystick's fire button and X and Y axes, storing the results in the key
31515               * logger and the joystick position variables.
31516               *
31517               * This routine is only called if joysticks are enabled (JSTK = non-zero).
31518               *
31519               * ******************************************************************************
31520               
31521               DKJ1:
31522 CC9E 0202  20        li   ry,>01*256                 ; LDY #1            ; Update the key logger for key 1 in the KYTB table, so
     CCA0 0100     
31523 CCA2 0206  20        li   rtmp,DKS1                  ; JSR DKS1          ; KY1 will be &FF if "?" (slow down) is being pressed
     CCA4 CC0A     
31524 CCA6 06A0  32        bl   @jsr                       ;
     CCA8 FF10     
31525               
31526 CCAA B084  18        ab   rone,ry                    ; INY               ; Update the key logger for key 2 in the KYTB table, so
31527 CCAC 0206  20        li   rtmp,DKS1                  ; JSR DKS1          ; KY2 will be &FF if Space (speed up) is being pressed
     CCAE CC0A     
31528 CCB0 06A0  32        bl   @jsr                       ;
     CCB2 FF10     
31529               
31530 CCB4 D020  34        movb @VIA+>40,ra                ; LDA VIA+&40       ; Read 6522 System VIA input register IRB (SHEILA &40)
     CCB6 FE40     
31531               
31532 CCB8 D040  18        movb ra,rx                      ; TAX               ; This instruction doesn't seem to have any effect, as
31533                                                                          ; X is overwritten in a few instructions. When the
31534                                                                          ; joystick is checked in a similar way in the TITLE
31535                                                                          ; subroutine for the "Press Fire Or Space,Commander."
31536                                                                          ; stage of the start-up screen, there's another
31537                                                                          ; unnecessary TAX instruction present, but there it's
31538                                                                          ; commented out
31539               
31540 CCBA 0240  22        andi ra,>10*256                 ; AND #%00010000    ; Bit 4 of IRB (PB4) is clear if joystick 1's fire
     CCBC 1000     
31541                                                                          ; button is pressed, otherwise it is set, so AND'ing
31542                                                                          ; the value of IRB with %10000 extracts this bit
31543               
31544                      .eoi (>10*256)                  ; EOR #%00010000    ; Flip bit 4 so that it's set if the fire button has
     **** ****     > EOI
0001 CCBE 0206  20        li   rtmp,(>10*256)
     CCC0 1000     
0002 CCC2 2806  18        xor  rtmp,ra
                   < elite.a99
31545 CCC4 D800  30        movb ra,@KY7                    ; STA KY7           ; been pressed, and store the result in the keyboard
     CCC6 0048     
31546                                                                          ; logger at location KY7, which is also where the A key
31547                                                                          ; (fire lasers) key is logged
31548               
31549 CCC8 0201  20        li   rx,>01*256                 ; LDX #1            ; Call DKS2 to fetch the value of ADC channel 1 (the
     CCCA 0100     
31550 CCCC 0206  20        li   rtmp,DKS2                  ; JSR DKS2          ; joystick X value) into (A X), and OR A with 1. This
     CCCE CC56     
31551 CCD0 06A0  32        bl   @jsr                       ;
     CCD2 FF10     
31552 CCD4 0260  22        ori  ra,>01*256                 ; ORA #1            ; ensures that the high byte is at least 1, and then we
     CCD6 0100     
31553 CCD8 D800  30        movb ra,@JSTX                   ; STA JSTX          ; store the result in JSTX
     CCDA 009C     
31554               
31555 CCDC 0201  20        li   rx,>02*256                 ; LDX #2            ; Call DKS2 to fetch the value of ADC channel 2 (the
     CCDE 0200     
31556 CCE0 0206  20        li   rtmp,DKS2                  ; JSR DKS2          ; joystick Y value) into (A X), and EOR A with JSTGY.
     CCE2 CC56     
31557 CCE4 06A0  32        bl   @jsr                       ;
     CCE6 FF10     
31558                      .eor @JSTGY                     ; EOR JSTGY         ; JSTGY will be &FF if the game is configured to
     **** ****     > EOR
0001 CCE8 D1A0  30        movb @JSTGY,rtmp
     CCEA 0F4E     
0002 CCEC 2806  18        xor  rtmp,ra
                   < elite.a99
31559 CCEE D800  30        movb ra,@JSTY                   ; STA JSTY          ; reverse the joystick Y channel, so this EOR does
     CCF0 009D     
31560                                                                          ; exactly that, and then we store the result in JSTY
31561               
31562 CCF2 0460  28        b    @DK4                       ; JMP DK4           ; We are done scanning the joystick flight controls,
     CCF4 CD7A     
31563                                                                          ; so jump to DK4 to scan for other keys, using a tail
31564                                                                          ; call so we can return from the subroutine there
31565               
31566               * ******************************************************************************
31567               *
31568               * Name: U%
31569               * Type: Subroutine
31570               * Category: Keyboard
31571               * Summary: Clear the key logger
31572               *
31573               * ------------------------------------------------------------------------------
31574               *
31575               * Returns:
31576               *
31577               * A                   A is set to 0
31578               *
31579               * Y                   Y is set to 0
31580               *
31581               * ******************************************************************************
31582               
31583               U.:
31584 CCF6 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0, as this means "key not pressed" in the
     CCF8 0000     
31585                                                                          ; key logger at KL
31586               
31587 CCFA 0202  20        li   ry,>0f*256                 ; LDY #15           ; We want to clear the 15 key logger locations from
     CCFC 0F00     
31588                                                                          ; KY1 to KY19, so set a counter in Y
31589               
31590               DKL3:
31591 CCFE D880  38        movb ra,@KL(ry)                 ; STA KL,Y          ; Store 0 in the Y-th byte of the key logger
     CD00 0041     
31592               
31593 CD02 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter
31594               
31595 CD04 16FC  14        jne  DKL3                       ; BNE DKL3          ; And loop back for the next key, until we have just
31596                                                                          ; KL+1. We don't want to clear the first key logger
31597                                                                          ; location at KL, as the keyboard table at KYTB starts
31598                                                                          ; with offset 1, not 0, so KL is not technically part of
31599                                                                          ; the key logger (it's actually used for logging keys
31600                                                                          ; that don't appear in the keyboard table, and which
31601                                                                          ; therefore don't use the key logger)
31602               
31603 CD06 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CD08 FF1C     
31604               
31605               * ******************************************************************************
31606               *
31607               * Name: DOKEY
31608               * Type: Subroutine
31609               * Category: Keyboard
31610               * Summary: Scan for the seven primary flight controls
31611               * Deep dive: The key logger
31612               * The docking computer
31613               *
31614               * ------------------------------------------------------------------------------
31615               *
31616               * Scan for the seven primary flight controls (or the equivalent on joystick),
31617               * pause and configuration keys, and secondary flight controls, and update the
31618               * key logger accordingly. Specifically:
31619               *
31620               * * If we are on keyboard configuration, clear the key logger and update it
31621               * for the seven primary flight controls, and update the pitch and roll
31622               * rates accordingly.
31623               *
31624               * * If we are on joystick configuration, clear the key logger and jump to
31625               * DKJ1, which reads the joystick equivalents of the primary flight
31626               * controls.
31627               *
31628               * Both options end up at DK4 to scan for other keys, beyond the seven primary
31629               * flight controls.
31630               *
31631               * ******************************************************************************
31632               
31633               DOKEY:
31634 CD0A 0206  20        li   rtmp,U.                    ; JSR U%            ; Call U% to clear the key logger
     CD0C CCF6     
31635 CD0E 06A0  32        bl   @jsr                       ;
     CD10 FF10     
31636               
31637 CD12 D020  30        movb @JSTK,ra                   ; LDA JSTK          ; If JSTK is non-zero, then we are configured to use
     CD14 0F50     
31638 CD16 16C3  14        jne  DKJ1                       ; BNE DKJ1          ; the joystick rather than keyboard, so jump to DKJ1
31639                                                                          ; to read the joystick flight controls, before jumping
31640                                                                          ; to DK4 to scan for pause, configuration and secondary
31641                                                                          ; flight keys
31642               
31643 CD18 0202  20        li   ry,>07*256                 ; LDY #7            ; We're going to work our way through the primary flight
     CD1A 0700     
31644                                                                          ; control keys (pitch, roll, speed and laser), so set a
31645                                                                          ; counter in Y so we can loop through all 7
31646               
31647               DKL2:
31648 CD1C 0206  20        li   rtmp,DKS1                  ; JSR DKS1          ; Call DKS1 to see if the KYTB key at offset Y is being
     CD1E CC0A     
31649 CD20 06A0  32        bl   @jsr                       ;
     CD22 FF10     
31650                                                                          ; pressed, and set the key logger accordingly
31651               
31652 CD24 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
31653               
31654 CD26 16FA  14        jne  DKL2                       ; BNE DKL2          ; Loop back for the next key, working our way from A at
31655                                                                          ; KYTB+7 down to ? at KYTB+1
31656               
31657 CD28 D060  30        movb @JSTX,rx                   ; LDX JSTX          ; Set X = JSTX, the current roll rate (as shown in the
     CD2A 009C     
31658                                                                          ; RL indicator on the dashboard)
31659               
31660 CD2C 0200  20        li   ra,>07*256                 ; LDA #7            ; Set A to 7, which is the amount we want to alter the
     CD2E 0700     
31661                                                                          ; roll rate by if the roll keys are being pressed
31662               
31663 CD30 D0A0  30        movb @KL+3,ry                   ; LDY KL+3          ; If the "<" key is being pressed, then call the BUMP2
     CD32 0044     
31664 CD34 1304  14        jeq  B103                       ; BEQ B103          ; routine to increase the roll rate in X by A
31665 CD36 0206  20        li   rtmp,BUMP2                 ; JSR BUMP2
     CD38 472E     
31666 CD3A 06A0  32        bl   @jsr                       ;
     CD3C FF10     
31667               
31668               B103:
31669 CD3E D0A0  30        movb @KL+4,ry                   ; LDY KL+4          ; If the ">" key is being pressed, then call the REDU2
     CD40 0045     
31670 CD42 1304  14        jeq  B104                       ; BEQ B104          ; routine to decrease the roll rate in X by A, taking
31671 CD44 0206  20        li   rtmp,REDU2                 ; JSR REDU2         ; the keyboard auto re-centre setting into account
     CD46 4750     
31672 CD48 06A0  32        bl   @jsr                       ;
     CD4A FF10     
31673               
31674               B104:
31675 CD4C D801  30        movb rx,@JSTX                   ; STX JSTX          ; Store the updated roll rate in JSTX
     CD4E 009C     
31676               
31677                      .asla                           ; ASL A             ; Double the value of A, to 14
     **** ****     > ASLA
0001 CD50 0240  22        andi ra,>ff00
     CD52 FF00     
0002 CD54 0A10  18        sla  ra,1
                   < elite.a99
31678               
31679 CD56 D060  30        movb @JSTY,rx                   ; LDX JSTY          ; Set X = JSTY, the current pitch rate (as shown in the
     CD58 009D     
31680                                                                          ; DC indicator on the dashboard)
31681               
31682 CD5A D0A0  30        movb @KL+5,ry                   ; LDY KL+5          ; If the "X" key is being pressed, then call the REDU2
     CD5C 0046     
31683 CD5E 1304  14        jeq  B105                       ; BEQ B105          ; routine to decrease the pitch rate in X by A, taking
31684 CD60 0206  20        li   rtmp,REDU2                 ; JSR REDU2         ; the keyboard auto re-centre setting into account
     CD62 4750     
31685 CD64 06A0  32        bl   @jsr                       ;
     CD66 FF10     
31686               
31687               B105:
31688 CD68 D0A0  30        movb @KL+6,ry                   ; LDY KL+6          ; If the "S" key is being pressed, then call the BUMP2
     CD6A 0047     
31689 CD6C 1304  14        jeq  B106                       ; BEQ B106          ; routine to increase the pitch rate in X by A
31690 CD6E 0206  20        li   rtmp,BUMP2                 ; JSR BUMP2
     CD70 472E     
31691 CD72 06A0  32        bl   @jsr                       ;
     CD74 FF10     
31692               
31693               B106:
31694 CD76 D801  30        movb rx,@JSTY                   ; STX JSTY          ; Store the updated roll rate in JSTY
     CD78 009D     
31695               
31696                                                                          ; Fall through into DK4 to scan for other keys
31697               
31698               * ******************************************************************************
31699               *
31700               * Name: DK4
31701               * Type: Subroutine
31702               * Category: Keyboard
31703               * Summary: Scan for pause, configuration and secondary flight keys
31704               * Deep dive: The key logger
31705               *
31706               * ------------------------------------------------------------------------------
31707               *
31708               * Scan for pause and configuration keys, and if this is a space view, also scan
31709               * for secondary flight controls.
31710               *
31711               * Specifically:
31712               *
31713               * * Scan for the pause button (COPY) and if it's pressed, pause the game and
31714               * process any configuration key presses until the game is unpaused (DELETE)
31715               *
31716               * * If this is a space view, scan for secondary flight keys and update the
31717               * relevant bytes in the key logger
31718               *
31719               * ******************************************************************************
31720               
31721               DK4:
31722 CD7A 0206  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     CD7C CAF4     
31723 CD7E 06A0  32        bl   @jsr                       ;
     CD80 FF10     
31724                                                                          ; internal key number in X (or 0 for no key press)
31725               
31726 CD82 D801  30        movb rx,@KL                     ; STX KL            ; Store X in KL, byte #0 of the key logger
     CD84 0041     
31727               
31728 CD86 0281  22        ci   rx,>69*256                 ; CPX #&69          ; If COPY is not being pressed, jump to DK2 below,
     CD88 6900     
31729 CD8A 1626  14        jne  DK2                        ; BNE DK2           ; otherwise let's process the configuration keys
31730               
31731               FREEZE:
31732                                                                          ; COPY is being pressed, so we enter a loop that
31733                                                                          ; listens for configuration keys, and we keep looping
31734                                                                          ; until we detect a DELETE key press. This effectively
31735                                                                          ; pauses the game when COPY is pressed, and unpauses
31736                                                                          ; it when DELETE is pressed
31737 CD8C 0206  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     CD8E 4DE2     
31738 CD90 06A0  32        bl   @jsr                       ;
     CD92 FF10     
31739                                                                          ; screen gets drawn
31740               
31741 CD94 0206  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     CD96 CAF4     
31742 CD98 06A0  32        bl   @jsr                       ;
     CD9A FF10     
31743                                                                          ; internal key number in X (or 0 for no key press)
31744               
31745 CD9C 0281  22        ci   rx,>51*256                 ; CPX #&51          ; If "S" is not being pressed, skip to DK6
     CD9E 5100     
31746 CDA0 1604  14        jne  DK6                        ; BNE DK6
31747               
31748 CDA2 0200  20        li   ra,>00*256                 ; LDA #0            ; "S" is being pressed, so set DNOIZ to 0 to turn the
     CDA4 0000     
31749 CDA6 D800  30        movb ra,@DNOIZ                  ; STA DNOIZ         ; sound on
     CDA8 0F49     
31750               
31751               DK6:
31752 CDAA 0202  20        li   ry,>40*256                 ; LDY #&40          ; We now want to loop through the keys that toggle
     CDAC 4000     
31753                                                                          ; various settings. These have internal key numbers
31754                                                                          ; between &40 (CAPS LOCK) and &46 ("K"), so we set up
31755                                                                          ; the first key number in Y to act as a loop counter.
31756                                                                          ; See subroutine DKS3 for more details on this
31757               
31758               DKL4:
31759 CDAE 0206  20        li   rtmp,DKS3                  ; JSR DKS3          ; Call DKS3 to scan for the key given in Y, and toggle
     CDB0 CC6E     
31760 CDB2 06A0  32        bl   @jsr                       ;
     CDB4 FF10     
31761                                                                          ; the relevant setting if it is pressed
31762               
31763 CDB6 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next toggle key
31764               
31765 CDB8 0282  22        ci   ry,>47*256                 ; CPY #&47          ; The last toggle key is &46 (K), so check whether we
     CDBA 4700     
31766                                                                          ; have just done that one
31767               
31768 CDBC 16F8  14        jne  DKL4                       ; BNE DKL4          ; If not, loop back to check for the next toggle key
31769               
31770               DK55:
31771 CDBE 0281  22        ci   rx,>10*256                 ; CPX #&10          ; If "Q" is not being pressed, skip to DK7
     CDC0 1000     
31772 CDC2 1602  14        jne  DK7                        ; BNE DK7
31773               
31774 CDC4 D801  30        movb rx,@DNOIZ                  ; STX DNOIZ         ; "Q" is being pressed, so set DNOIZ to X, which is
     CDC6 0F49     
31775                                                                          ; non-zero (&10), so this will turn the sound off
31776               
31777               DK7:
31778 CDC8 0281  22        ci   rx,>70*256                 ; CPX #&70          ; If ESCAPE is not being pressed, skip over the next
     CDCA 7000     
31779 CDCC 1602  14        jne  B107                       ; BNE B107          ; instruction
31780               
31781 CDCE 0460  28        b    @DEATH2                    ; JMP DEATH2        ; ESCAPE is being pressed, so jump to DEATH2 to end
     CDD0 C59C     
31782                                                                          ; the game
31783               
31784               B107:
31785 CDD2 0281  22        ci   rx,>59*256                 ; CPX #&59          ; If DELETE is not being pressed, we are still paused,
     CDD4 5900     
31786 CDD6 16DA  14        jne  FREEZE                     ; BNE FREEZE        ; so loop back up to keep listening for configuration
31787                                                                          ; keys, otherwise fall through into the rest of the
31788                                                                          ; key detection code, which unpauses the game
31789               
31790               DK2:
31791 CDD8 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is non-zero (i.e. not a space
     CDDA 0096     
31792 CDDC 160F  14        jne  DK5                        ; BNE DK5           ; view), return from the subroutine (as DK5 contains
31793                                                                          ; an RTS)
31794               
31795 CDDE 0202  20        li   ry,>0f*256                 ; LDY #15           ; This is a space view, so now we want to check for all
     CDE0 0F00     
31796                                                                          ; the secondary flight keys. The internal key numbers
31797                                                                          ; are in the keyboard table KYTB from KYTB+8 to
31798                                                                          ; KYTB+15, and their key logger locations are from KL+8
31799                                                                          ; to KL+15. So set a decreasing counter in Y for the
31800                                                                          ; index, starting at 15, so we can loop through them
31801               
31802 CDE2 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to &FF so we can store this in the keyboard
     CDE4 FF00     
31803                                                                          ; logger for keys that are being pressed
31804               
31805               DKL1:
31806 CDE6 D062  34        movb @KYTB(ry),rx               ; LDX KYTB,Y        ; Get the internal key number of the Y-th flight key
     CDE8 CBF9     
31807                                                                          ; the KYTB keyboard table
31808               
31809 CDEA 9060  30        cb   @KL,rx                     ; CPX KL            ; We stored the key that's being pressed in KL above,
     CDEC 0041     
31810                                                                          ; so check to see if the Y-th flight key is being
31811                                                                          ; pressed
31812               
31813 CDEE 1602  14        jne  DK1                        ; BNE DK1           ; If it is not being pressed, skip to DK1 below
31814               
31815 CDF0 D880  38        movb ra,@KL(ry)                 ; STA KL,Y          ; The Y-th flight key is being pressed, so set that
     CDF2 0041     
31816                                                                          ; key's location in the key logger to &FF
31817               
31818               DK1:
31819 CDF4 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
31820               
31821 CDF6 0282  22        ci   ry,>07*256                 ; CPY #7            ; Have we just done the last key?
     CDF8 0700     
31822               
31823 CDFA 16F5  14        jne  DKL1                       ; BNE DKL1          ; If not, loop back to process the next key
31824               
31825               DK5:
31826 CDFC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CDFE FF1C     
31827               
31828               * ******************************************************************************
31829               *
31830               * Name: TT217
31831               * Type: Subroutine
31832               * Category: Keyboard
31833               * Summary: Scan the keyboard until a key is pressed
31834               *
31835               * ------------------------------------------------------------------------------
31836               *
31837               * Scan the keyboard until a key is pressed, and return the key's ASCII code.
31838               * If, on entry, a key is already being held down, then wait until that key is
31839               * released first (so this routine detects the first key down event following
31840               * the subroutine call).
31841               *
31842               * ------------------------------------------------------------------------------
31843               *
31844               * Returns:
31845               *
31846               * X                   The ASCII code of the key that was pressed
31847               *
31848               * A                   Contains the same as X
31849               *
31850               * Y                   Y is preserved
31851               *
31852               * ------------------------------------------------------------------------------
31853               *
31854               * Other entry points:
31855               *
31856               * out                 Contains an RTS
31857               *
31858               * ******************************************************************************
31859               
31860               TT217:
31861 CE00 D802  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y in temporary storage, so we can restore it
     CE02 0094     
31862                                                                          ; later
31863               
31864               t_:
31865 CE04 0206  20        li   rtmp,DELAY-5               ; JSR DELAY-5       ; Delay for 8 vertical syncs (8/50 = 0.16 seconds) so we
     CE06 4BFB     
31866 CE08 06A0  32        bl   @jsr                       ;
     CE0A FF10     
31867                                                                          ; don't take up too much CPU time while looping round
31868               
31869 CE0C 0206  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     CE0E CAF4     
31870 CE10 06A0  32        bl   @jsr                       ;
     CE12 FF10     
31871                                                                          ; internal key number in X (or 0 for no key press)
31872               
31873 CE14 16F7  14        jne  t_                         ; BNE t             ; If a key was already being held down when we entered
31874                                                                          ; this routine, keep looping back up to t, until the
31875                                                                          ; key is released
31876               
31877               t2_:
31878 CE16 0206  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Any pre-existing key press is now gone, so we can
     CE18 CAF4     
31879 CE1A 06A0  32        bl   @jsr                       ;
     CE1C FF10     
31880                                                                          ; start scanning the keyboard again, returning the
31881                                                                          ; internal key number in X (or 0 for no key press)
31882               
31883 CE1E 13FB  14        jeq  t2_                        ; BEQ t2            ; Keep looping up to t2 until a key is pressed
31884               
31885 CE20 D080  18        movb ra,ry                      ; TAY               ; Copy A to Y, so Y contains the internal key number
31886                                                                          ; of the key pressed
31887               
31888                      .ld_ind_y_idx @TRTB.,ra         ; LDA (TRTB%),Y     ; The address in TRTB% points to the MOS key
     **** ****     > LD_IND_Y_IDX
0001 CE22 D820  50        movb @TRTB.,@rtmplb
     CE24 0004     
     CE26 2079     
0002 CE28 D1A0  30        movb @TRTB.+1,rtmp
     CE2A 0005     
0003 CE2C A182  18        a    ry,rtmp
0004 CE2E D016  26        movb *rtmp,RA
                   < elite.a99
31889                                                                          ; translation table, which is used to translate
31890                                                                          ; internal key numbers to ASCII, so this fetches the
31891                                                                          ; key's ASCII code into A
31892               
31893 CE30 D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore the original value of Y we stored above
     CE32 0094     
31894               
31895 CE34 D040  18        movb ra,rx                      ; TAX               ; Copy A into X
31896               
31897               out_:
31898 CE36 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CE38 FF1C     
31899               
31900               * ******************************************************************************
31901               *
31902               * Name: me1
31903               * Type: Subroutine
31904               * Category: Flight
31905               * Summary: Erase an old in-flight message and display a new one
31906               *
31907               * ------------------------------------------------------------------------------
31908               *
31909               * Arguments:
31910               *
31911               * A                   The text token to be printed
31912               *
31913               * X                   Must be set to 0
31914               *
31915               * ******************************************************************************
31916               
31917               me1_:
31918 CE3A D801  30        movb rx,@DLY                    ; STX DLY           ; Set the message delay in DLY to 0, so any new
     CE3C 0D64     
31919                                                                          ; in-flight messages will be shown instantly
31920               
31921                      .pha                            ; PHA               ; Store the new message token we want to print
     **** ****     > PHA
0001 CE3E D680  30        movb ra,*rsp
0002 CE40 060A  14        dec  rsp
                   < elite.a99
31922               
31923 CE42 D020  30        movb @MCH,ra                    ; LDA MCH           ; Set A to the token number of the message that is
     CE44 0F10     
31924 CE46 0206  20        li   rtmp,mes9_                 ; JSR mes9          ; currently on-screen, and call mes9 to print it (which
     CE48 CE84     
31925 CE4A 06A0  32        bl   @jsr                       ;
     CE4C FF10     
31926                                                                          ; will remove it from the screen, as printing is done
31927                                                                          ; using EOR logic)
31928               
31929                      .pla                            ; PLA               ; Restore the new message token
     **** ****     > PLA
0001 CE4E 058A  14        inc  rsp
0002 CE50 D01A  26        movb *rsp,ra
                   < elite.a99
31930               
31931 CE52 2C              byte >2c                                            ; Fall through into ou2 to print the new message, but
31932                                                                          ; skip the first instruction by turning it into
31933                                                                          ; &2C &A9 &6C, or BIT &6CA9, which does nothing apart
31934                                                                          ; from affect the flags
31935               
31936               * ******************************************************************************
31937               *
31938               * Name: ou2
31939               * Type: Subroutine
31940               * Category: Flight
31941               * Summary: Display "E.C.M.SYSTEM DESTROYED" as an in-flight message
31942               *
31943               * ******************************************************************************
31944               
31945               ou2_:
31946 CE54 0200  20        li   ra,>6c*256                 ; LDA #108          ; Set A to recursive token 108 ("E.C.M.SYSTEM")
     CE56 6C00     
31947               
31948 CE58 2C              byte >2c                                            ; Fall through into ou3 to print the new message, but
31949                                                                          ; skip the first instruction by turning it into
31950                                                                          ; &2C &A9 &6F, or BIT &6FA9, which does nothing apart
31951                                                                          ; from affect the flags
31952               
31953               * ******************************************************************************
31954               *
31955               * Name: ou3
31956               * Type: Subroutine
31957               * Category: Flight
31958               * Summary: Display "FUEL SCOOPS DESTROYED" as an in-flight message
31959               *
31960               * ******************************************************************************
31961               
31962               ou3_:
31963 CE5A 0200  20        li   ra,>6f*256                 ; LDA #111          ; Set A to recursive token 111 ("FUEL SCOOPS")
     CE5C 6F00     
31964               
31965               * ******************************************************************************
31966               *
31967               * Name: MESS
31968               * Type: Subroutine
31969               * Category: Flight
31970               * Summary: Display an in-flight message
31971               *
31972               * ------------------------------------------------------------------------------
31973               *
31974               * Display an in-flight message in capitals at the bottom of the space view,
31975               * erasing any existing in-flight message first.
31976               *
31977               * ------------------------------------------------------------------------------
31978               *
31979               * Arguments:
31980               *
31981               * A                   The text token to be printed
31982               *
31983               * ******************************************************************************
31984               
31985               MESS:
31986 CE5E 0201  20        li   rx,>00*256                 ; LDX #0            ; Set QQ17 = 0 to switch to ALL CAPS
     CE60 0000     
31987 CE62 D801  30        movb rx,@QQ17                   ; STX QQ17
     CE64 007E     
31988               
31989 CE66 0202  20        li   ry,>09*256                 ; LDY #9            ; Move the text cursor to column 9, row 22, at the
     CE68 0900     
31990 CE6A D802  30        movb ry,@XC                     ; STY XC            ; bottom middle of the screen, and set Y = 22
     CE6C 002C     
31991 CE6E 0202  20        li   ry,>16*256                 ; LDY #22
     CE70 1600     
31992 CE72 D802  30        movb ry,@YC                     ; STY YC
     CE74 002D     
31993               
31994 CE76 9060  30        cb   @DLY,rx                    ; CPX DLY           ; If the message delay in DLY is not zero, jump up to
     CE78 0D64     
31995 CE7A 16DF  14        jne  me1_                       ; BNE me1           ; me1 to erase the current message first (whose token
31996                                                                          ; number will be in MCH)
31997               
31998 CE7C D802  30        movb ry,@DLY                    ; STY DLY           ; Set the message delay in DLY to 22
     CE7E 0D64     
31999               
32000 CE80 D800  30        movb ra,@MCH                    ; STA MCH           ; Set MCH to the token we are about to display
     CE82 0F10     
32001               
32002                                                                          ; Fall through into mes9 to print the token in A
32003               
32004               * ******************************************************************************
32005               *
32006               * Name: mes9
32007               * Type: Subroutine
32008               * Category: Flight
32009               * Summary: Print a text token, possibly followed by " DESTROYED"
32010               *
32011               * ------------------------------------------------------------------------------
32012               *
32013               * Print a text token, followed by " DESTROYED" if the destruction flag is set
32014               * (for when a piece of equipment is destroyed).
32015               *
32016               * ******************************************************************************
32017               
32018               mes9_:
32019 CE84 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Call TT27 to print the text token in A
     CE86 A6E8     
32020 CE88 06A0  32        bl   @jsr                       ;
     CE8A FF10     
32021               
32022                      .lsr @de_                       ; LSR de            ; If bit 0 of variable de is clear, return from the
     **** ****     > LSR
0001 CE8C D1A0  30        movb @DE_,rtmp
     CE8E 0D65     
0002 CE90 0916  18        srl  rtmp,1
0003 CE92 D806  30        movb rtmp,@DE_
     CE94 0D65     
                   < elite.a99
32023 CE96 17CF  14        jnc  out_                       ; BCC out           ; subroutine (as out contains an RTS)
32024               
32025 CE98 0200  20        li   ra,>fd*256                 ; LDA #253          ; Print recursive token 93 (" DESTROYED") and return
     CE9A FD00     
32026 CE9C 0460  28        b    @TT27                      ; JMP TT27          ; from the subroutine using a tail call
     CE9E A6E8     
32027               
32028               * ******************************************************************************
32029               *
32030               * Name: OUCH
32031               * Type: Subroutine
32032               * Category: Flight
32033               * Summary: Potentially lose cargo or equipment following damage
32034               *
32035               * ------------------------------------------------------------------------------
32036               *
32037               * Our shields are dead and we are taking damage, so there is a small chance of
32038               * losing cargo or equipment.
32039               *
32040               * ******************************************************************************
32041               
32042               OUCH:
32043 CEA0 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     CEA2 C07C     
32044 CEA4 06A0  32        bl   @jsr                       ;
     CEA6 FF10     
32045               
32046 CEA8 11C6  14        jlt  out_                       ; BMI out           ; If A < 0 (50% chance), return from the subroutine
32047                                                                          ; (as out contains an RTS)
32048               
32049 CEAA 0281  22        ci   rx,>16*256                 ; CPX #22           ; If X >= 22 (91% chance), return from the subroutine
     CEAC 1600     
32050 CEAE 18C3  14        joc  out_                       ; BCS out           ; (as out contains an RTS)
32051               
32052 CEB0 D021  34        movb @QQ20(rx),ra               ; LDA QQ20,X        ; If we do not have any of item QQ20+X, return from the
     CEB2 0317     
32053 CEB4 13C0  14        jeq  out_                       ; BEQ out           ; subroutine (as out contains an RTS). X is in the range
32054                                                                          ; 0-21, so this not only checks for cargo, but also for
32055                                                                          ; E.C.M., fuel scoops, energy bomb, energy unit and
32056                                                                          ; docking computer, all of which can be destroyed
32057               
32058 CEB6 D020  30        movb @DLY,ra                    ; LDA DLY           ; If there is already an in-flight message on-screen,
     CEB8 0D64     
32059 CEBA 16BD  14        jne  out_                       ; BNE out           ; return from the subroutine (as out contains an RTS)
32060               
32061 CEBC 0202  20        li   ry,>03*256                 ; LDY #3            ; Set bit 1 of de, the equipment destruction flag, so
     CEBE 0300     
32062 CEC0 D802  30        movb ry,@de_                    ; STY de            ; that when we call MESS below, " DESTROYED" is appended
     CEC2 0D65     
32063                                                                          ; to the in-flight message
32064               
32065 CEC4 D840  38        movb ra,@QQ20(rx)               ; STA QQ20,X        ; A is 0 (as we didn't branch with the BNE above), so
     CEC6 0317     
32066                                                                          ; this sets QQ20+X to 0, which destroys any cargo or
32067                                                                          ; equipment we have of that type
32068               
32069 CEC8 0281  22        ci   rx,>11*256                 ; CPX #17           ; If X >= 17 then we just lost a piece of equipment, so
     CECA 1100     
32070 CECC 1806  14        joc  ou1_                       ; BCS ou1           ; jump to ou1 to print the relevant message
32071               
32072 CECE D001  18        movb rx,ra                      ; TXA               ; Print recursive token 48 + A as an in-flight token,
32073                      .adi (>d0*256)                  ; ADC #208          ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
     **** ****     > ADI
0001 CED0 1701  14        jnc  !
0002 CED2 B004  18        ab   rone,ra
0003               !:
0004 CED4 0220  22        ai   ra,(>D0*256)
     CED6 D000     
                   < elite.a99
32074 CED8 16C2  14        jne  MESS                       ; BNE MESS          ; ITEMS") as the C flag is clear, so this prints the
32075                                                                          ; destroyed item's name, followed by " DESTROYED" (as we
32076                                                                          ; set bit 1 of the de flag above), and returns from the
32077                                                                          ; subroutine using a tail call
32078               
32079               ou1_:
32080 CEDA 13BC  14        jeq  ou2_                       ; BEQ ou2           ; If X = 17, jump to ou2 to print "E.C.M.SYSTEM
32081                                                                          ; DESTROYED" and return from the subroutine using a tail
32082                                                                          ; call
32083               
32084 CEDC 0281  22        ci   rx,>12*256                 ; CPX #18           ; If X = 18, jump to ou3 to print "FUEL SCOOPS
     CEDE 1200     
32085 CEE0 13BC  14        jeq  ou3_                       ; BEQ ou3           ; DESTROYED" and return from the subroutine using a tail
32086                                                                          ; call
32087               
32088 CEE2 D001  18        movb rx,ra                      ; TXA               ; Otherwise X is in the range 19 to 21 and the C flag is
32089                      .adi ((113-20)*256)             ; ADC #113-20       ; set (as we got here via a BCS to ou1), so we set A as
     **** ****     > ADI
0001 CEE4 1701  14        jnc  !
0002 CEE6 B004  18        ab   rone,ra
0003               !:
0004 CEE8 0220  22        ai   ra,((113-20)*256)
     CEEA 5D00     
                   < elite.a99
32090                                                                          ; follows:
32091                                                                          ;
32092                                                                          ; A = 113 - 20 + X + C
32093                                                                          ; = 113 - 19 + X
32094                                                                          ; = 113 to 115
32095               
32096 CEEC 16B8  14        jne  MESS                       ; BNE MESS          ; Print recursive token A ("ENERGY BOMB", "ENERGY UNIT"
32097                                                                          ; or "DOCKING COMPUTERS") as an in-flight message,
32098                                                                          ; followed by " DESTROYED", and return from the
32099                                                                          ; subroutine using a tail call
32100               
32101               * ******************************************************************************
32102               *
32103               * Name: QQ16
32104               * Type: Variable
32105               * Category: Text
32106               * Summary: The two-letter token lookup table
32107               * Deep dive: Printing text tokens
32108               *
32109               * ------------------------------------------------------------------------------
32110               *
32111               * Two-letter token lookup table for tokens 128-159. See the deep dive on
32112               * "Printing text tokens" for details of how the two-letter token system works.
32113               *
32114               * ******************************************************************************
32115               
32116               QQ16:
32117 CEEE 414C            text 'AL'                                           ; Token 128
32118 CEF0 4C45            text 'LE'                                           ; Token 129
32119 CEF2 5845            text 'XE'                                           ; Token 130
32120 CEF4 4745            text 'GE'                                           ; Token 131
32121 CEF6 5A41            text 'ZA'                                           ; Token 132
32122 CEF8 4345            text 'CE'                                           ; Token 133
32123 CEFA 4249            text 'BI'                                           ; Token 134
32124 CEFC 534F            text 'SO'                                           ; Token 135
32125 CEFE 5553            text 'US'                                           ; Token 136
32126 CF00 4553            text 'ES'                                           ; Token 137
32127 CF02 4152            text 'AR'                                           ; Token 138
32128 CF04 4D41            text 'MA'                                           ; Token 139
32129 CF06 494E            text 'IN'                                           ; Token 140
32130 CF08 4449            text 'DI'                                           ; Token 141
32131 CF0A 5245            text 'RE'                                           ; Token 142
32132 CF0C 413F            text 'A?'                                           ; Token 143
32133 CF0E 4552            text 'ER'                                           ; Token 144
32134 CF10 4154            text 'AT'                                           ; Token 145
32135 CF12 454E            text 'EN'                                           ; Token 146
32136 CF14 4245            text 'BE'                                           ; Token 147
32137 CF16 5241            text 'RA'                                           ; Token 148
32138 CF18 4C41            text 'LA'                                           ; Token 149
32139 CF1A 5645            text 'VE'                                           ; Token 150
32140 CF1C 5449            text 'TI'                                           ; Token 151
32141 CF1E 4544            text 'ED'                                           ; Token 152
32142 CF20 4F52            text 'OR'                                           ; Token 153
32143 CF22 5155            text 'QU'                                           ; Token 154
32144 CF24 414E            text 'AN'                                           ; Token 155
32145 CF26 5445            text 'TE'                                           ; Token 156
32146 CF28 4953            text 'IS'                                           ; Token 157
32147 CF2A 5249            text 'RI'                                           ; Token 158
32148 CF2C 4F4E            text 'ON'                                           ; Token 159
32149               
32150               * ******************************************************************************
32151               *
32152               * Name: ITEM
32153               * Type: Macro
32154               * Category: Market
32155               * Summary: Macro definition for the market prices table
32156               * Deep dive: Market item prices and availability
32157               *
32158               * ------------------------------------------------------------------------------
32159               *
32160               * The following macro is used to build the market prices table:
32161               *
32162               * ITEM price, factor, units, quantity, mask
32163               *
32164               * It inserts an item into the market prices table at QQ23. See the deep dive on
32165               * "Market item prices and availability" for more information on how the market
32166               * system works.
32167               *
32168               * ------------------------------------------------------------------------------
32169               *
32170               * Arguments:
32171               *
32172               * price               Base price
32173               *
32174               * factor              Economic factor
32175               *
32176               * units               Units: "t", "g" or "k"
32177               *
32178               * quantity            Base quantity
32179               *
32180               * mask                Fluctuations mask
32181               *
32182               * ******************************************************************************
32183               
32184                      ; MACRO ITEM price, factor, units, quantity, mask
32185               
32186                      ; IF factor < 0                 ;
32187                      ; s = 1 << 7                    ;
32188                      ; ELSE                          ;
32189                      ; s = 0                         ;
32190                      ; ENDIF                         ;
32191               
32192                      ; IF units = 't'                ;
32193                      ; u = 0                         ;
32194                      ; ELIF units = 'k'              ;
32195                      ; u = 1 << 5                    ;
32196                      ; ELSE                          ;
32197                      ; u = 1 << 6                    ;
32198                      ; ENDIF                         ;
32199               
32200                      ; e = ABS(factor)               ;
32201               
32202                      ; EQUB price                    ;
32203                      ; EQUB s + u + e                ;
32204                      ; EQUB quantity                 ;
32205                      ; EQUB mask                     ;
32206               
32207                      ; ENDMACRO
32208               
32209               * ******************************************************************************
32210               *
32211               * Name: QQ23
32212               * Type: Variable
32213               * Category: Market
32214               * Summary: Market prices table
32215               *
32216               * ------------------------------------------------------------------------------
32217               *
32218               * Each item has four bytes of data, like this:
32219               *
32220               * Byte #0 = Base price
32221               * Byte #1 = Economic factor in bits 0-4, with the sign in bit 7
32222               * Unit in bits 5-6
32223               * Byte #2 = Base quantity
32224               * Byte #3 = Mask to control price fluctuations
32225               *
32226               * To make it easier for humans to follow, we've defined a macro called ITEM
32227               * that takes the following arguments and builds the four bytes for us:
32228               *
32229               * ITEM base price, economic factor, units, base quantity, mask
32230               *
32231               * So for food, we have the following:
32232               *
32233               * * Base price = 19
32234               * * Economic factor = -2
32235               * * Unit = tonnes
32236               * * Base quantity = 6
32237               * * Mask = %00000001
32238               *
32239               * ******************************************************************************
32240               
32241               QQ23:
32242 CF2E 1382            byte >13, >82, >06, >01                             ; 0 = Food
     CF30 0601     
32243 CF32 1481            byte >14, >81, >0a, >03                             ; 1 = Textiles
     CF34 0A03     
32244 CF36 4183            byte >41, >83, >02, >07                             ; 2 = Radioactives
     CF38 0207     
32245 CF3A 2885            byte >28, >85, >e2, >1f                             ; 3 = Slaves
     CF3C E21F     
32246 CF3E 5385            byte >53, >85, >fb, >0f                             ; 4 = Liquor/Wines
     CF40 FB0F     
32247 CF42 C408            byte >c4, >08, >36, >03                             ; 5 = Luxuries
     CF44 3603     
32248 CF46 EB1D            byte >eb, >1d, >08, >78                             ; 6 = Narcotics
     CF48 0878     
32249 CF4A 9A0E            byte >9a, >0e, >38, >03                             ; 7 = Computers
     CF4C 3803     
32250 CF4E 7506            byte >75, >06, >28, >07                             ; 8 = Machinery
     CF50 2807     
32251 CF52 4E01            byte >4e, >01, >11, >1f                             ; 9 = Alloys
     CF54 111F     
32252 CF56 7C0D            byte >7c, >0d, >1d, >07                             ; 10 = Firearms
     CF58 1D07     
32253 CF5A B089            byte >b0, >89, >dc, >3f                             ; 11 = Furs
     CF5C DC3F     
32254 CF5E 2081            byte >20, >81, >35, >03                             ; 12 = Minerals
     CF60 3503     
32255 CF62 61A1            byte >61, >a1, >42, >07                             ; 13 = Gold
     CF64 4207     
32256 CF66 ABA2            byte >ab, >a2, >37, >1f                             ; 14 = Platinum
     CF68 371F     
32257 CF6A 2DC1            byte >2d, >c1, >fa, >0f                             ; 15 = Gem-Stones
     CF6C FA0F     
32258 CF6E 350F            byte >35, >0f, >c0, >07                             ; 16 = Alien items
     CF70 C007     
32259               
32260               * ******************************************************************************
32261               *
32262               * Name: TIDY
32263               * Type: Subroutine
32264               * Category: Maths (Geometry)
32265               * Summary: Orthonormalise the orientation vectors for a ship
32266               * Deep dive: Tidying orthonormal vectors
32267               * Orientation vectors
32268               *
32269               * ------------------------------------------------------------------------------
32270               *
32271               * This routine orthonormalises the orientation vectors for a ship. This means
32272               * making the three orientation vectors orthogonal (perpendicular to each other),
32273               * and normal (so each of the vectors has length 1).
32274               *
32275               * We do this because we use the small angle approximation to rotate these
32276               * vectors in space. It is not completely accurate, so the three vectors tend
32277               * to get stretched over time, so periodically we tidy the vectors with this
32278               * routine to ensure they remain as orthonormal as possible.
32279               *
32280               * ******************************************************************************
32281               
32282               TI2:
32283                                                                          ; Called from below with A = 0, X = 0, Y = 4 when
32284                                                                          ; nosev_x and nosev_y are small, so we assume that
32285                                                                          ; nosev_z is big
32286 CF72 D002  18        movb ry,ra                      ; TYA               ; A = Y = 4
32287 CF74 0202  20        li   ry,>02*256                 ; LDY #2
     CF76 0200     
32288 CF78 0206  20        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 0, Y = 2, A = 4, to set roofv_z =
     CF7A D132     
32289 CF7C 06A0  32        bl   @jsr                       ;
     CF7E FF10     
32290 CF80 D800  30        movb ra,@INWK+20                ; STA INWK+20       ; -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
     CF82 0067     
32291               
32292 CF84 0460  28        b    @TI3                       ; JMP TI3           ; Jump to TI3 to keep tidying
     CF86 D002     
32293               
32294               TI1:
32295                                                                          ; Called from below with A = 0, Y = 4 when nosev_x is
32296                                                                          ; small
32297 CF88 D040  18        movb ra,rx                      ; TAX               ; Set X = A = 0
32298               
32299 CF8A D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A = nosev_y, and if the top two magnitude bits
     CF8C 0032     
32300 CF8E 0240  22        andi ra,>60*256                 ; AND #%01100000    ; are both clear, jump to TI2 with A = 0, X = 0, Y = 4
     CF90 6000     
32301 CF92 13EF  14        jeq  TI2                        ; BEQ TI2
32302               
32303 CF94 0200  20        li   ra,>02*256                 ; LDA #2            ; Otherwise nosev_y is big, so set up the index values
     CF96 0200     
32304                                                                          ; to pass to TIS3
32305               
32306 CF98 0206  20        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 0, Y = 4, A = 2, to set roofv_y =
     CF9A D132     
32307 CF9C 06A0  32        bl   @jsr                       ;
     CF9E FF10     
32308 CFA0 D800  30        movb ra,@INWK+18                ; STA INWK+18       ; -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
     CFA2 0065     
32309               
32310 CFA4 0460  28        b    @TI3                       ; JMP TI3           ; Jump to TI3 to keep tidying
     CFA6 D002     
32311               
32312               TIDY:
32313 CFA8 D020  30        movb @INWK+10,ra                ; LDA INWK+10       ; Set (XX15, XX15+1, XX15+2) = nosev
     CFAA 005D     
32314 CFAC D800  30        movb ra,@XX15                   ; STA XX15
     CFAE 0031     
32315 CFB0 D020  30        movb @INWK+12,ra                ; LDA INWK+12
     CFB2 005F     
32316 CFB4 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     CFB6 0032     
32317 CFB8 D020  30        movb @INWK+14,ra                ; LDA INWK+14
     CFBA 0061     
32318 CFBC D800  30        movb ra,@XX15+2                 ; STA XX15+2
     CFBE 0033     
32319               
32320 CFC0 0206  20        li   rtmp,NORM                  ; JSR NORM          ; Call NORM to normalise the vector in XX15, i.e. nosev
     CFC2 CA40     
32321 CFC4 06A0  32        bl   @jsr                       ;
     CFC6 FF10     
32322               
32323 CFC8 D020  30        movb @XX15,ra                   ; LDA XX15          ; Set nosev = (XX15, XX15+1, XX15+2)
     CFCA 0031     
32324 CFCC D800  30        movb ra,@INWK+10                ; STA INWK+10
     CFCE 005D     
32325 CFD0 D020  30        movb @XX15+1,ra                 ; LDA XX15+1
     CFD2 0032     
32326 CFD4 D800  30        movb ra,@INWK+12                ; STA INWK+12
     CFD6 005F     
32327 CFD8 D020  30        movb @XX15+2,ra                 ; LDA XX15+2
     CFDA 0033     
32328 CFDC D800  30        movb ra,@INWK+14                ; STA INWK+14
     CFDE 0061     
32329               
32330 CFE0 0202  20        li   ry,>04*256                 ; LDY #4            ; Set Y = 4
     CFE2 0400     
32331               
32332 CFE4 D020  30        movb @XX15,ra                   ; LDA XX15          ; Set A = nosev_x, and if the top two magnitude bits
     CFE6 0031     
32333 CFE8 0240  22        andi ra,>60*256                 ; AND #%01100000    ; are both clear, jump to TI1 with A = 0, Y = 4
     CFEA 6000     
32334 CFEC 13CD  14        jeq  TI1                        ; BEQ TI1
32335               
32336 CFEE 0201  20        li   rx,>02*256                 ; LDX #2            ; Otherwise nosev_x is big, so set up the index values
     CFF0 0200     
32337 CFF2 0200  20        li   ra,>00*256                 ; LDA #0            ; to pass to TIS3
     CFF4 0000     
32338               
32339 CFF6 0206  20        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 2, Y = 4, A = 0, to set roofv_x =
     CFF8 D132     
32340 CFFA 06A0  32        bl   @jsr                       ;
     CFFC FF10     
32341 CFFE D800  30        movb ra,@INWK+16                ; STA INWK+16       ; -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
     D000 0063     
32342               
32343               TI3:
32344 D002 D020  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set (XX15, XX15+1, XX15+2) = roofv
     D004 0063     
32345 D006 D800  30        movb ra,@XX15                   ; STA XX15
     D008 0031     
32346 D00A D020  30        movb @INWK+18,ra                ; LDA INWK+18
     D00C 0065     
32347 D00E D800  30        movb ra,@XX15+1                 ; STA XX15+1
     D010 0032     
32348 D012 D020  30        movb @INWK+20,ra                ; LDA INWK+20
     D014 0067     
32349 D016 D800  30        movb ra,@XX15+2                 ; STA XX15+2
     D018 0033     
32350               
32351 D01A 0206  20        li   rtmp,NORM                  ; JSR NORM          ; Call NORM to normalise the vector in XX15, i.e. roofv
     D01C CA40     
32352 D01E 06A0  32        bl   @jsr                       ;
     D020 FF10     
32353               
32354 D022 D020  30        movb @XX15,ra                   ; LDA XX15          ; Set roofv = (XX15, XX15+1, XX15+2)
     D024 0031     
32355 D026 D800  30        movb ra,@INWK+16                ; STA INWK+16
     D028 0063     
32356 D02A D020  30        movb @XX15+1,ra                 ; LDA XX15+1
     D02C 0032     
32357 D02E D800  30        movb ra,@INWK+18                ; STA INWK+18
     D030 0065     
32358 D032 D020  30        movb @XX15+2,ra                 ; LDA XX15+2
     D034 0033     
32359 D036 D800  30        movb ra,@INWK+20                ; STA INWK+20
     D038 0067     
32360               
32361 D03A D020  30        movb @INWK+12,ra                ; LDA INWK+12       ; Set Q = nosev_y
     D03C 005F     
32362 D03E D800  30        movb ra,@Q                      ; STA Q
     D040 0090     
32363               
32364 D042 D020  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z
     D044 0067     
32365               
32366 D046 0206  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_y * roofv_z
     D048 445E     
32367 D04A 06A0  32        bl   @jsr                       ;
     D04C FF10     
32368               
32369 D04E D060  30        movb @INWK+14,rx                ; LDX INWK+14       ; Set X = nosev_z
     D050 0061     
32370               
32371 D052 D020  30        movb @INWK+18,ra                ; LDA INWK+18       ; Set A = roofv_y
     D054 0065     
32372               
32373 D056 0206  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     D058 4550     
32374 D05A 06A0  32        bl   @jsr                       ;
     D05C FF10     
32375                                                                          ; = (-nosev_z * roofv_y + nosev_y * roofv_z) / 96
32376                                                                          ;
32377                                                                          ; This also sets Q = nosev_z
32378               
32379                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_x = -A
     **** ****     > EOI
0001 D05E 0206  20        li   rtmp,(>80*256)
     D060 8000     
0002 D062 2806  18        xor  rtmp,ra
                   < elite.a99
32380 D064 D800  30        movb ra,@INWK+22                ; STA INWK+22       ; = (nosev_z * roofv_y - nosev_y * roofv_z) / 96
     D066 0069     
32381               
32382 D068 D020  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set A = roofv_x
     D06A 0063     
32383               
32384 D06C 0206  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_z * roofv_x
     D06E 445E     
32385 D070 06A0  32        bl   @jsr                       ;
     D072 FF10     
32386               
32387 D074 D060  30        movb @INWK+10,rx                ; LDX INWK+10       ; Set X = nosev_x
     D076 005D     
32388               
32389 D078 D020  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z
     D07A 0067     
32390               
32391 D07C 0206  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     D07E 4550     
32392 D080 06A0  32        bl   @jsr                       ;
     D082 FF10     
32393                                                                          ; = (-nosev_x * roofv_z + nosev_z * roofv_x) / 96
32394                                                                          ;
32395                                                                          ; This also sets Q = nosev_x
32396               
32397                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_y = -A
     **** ****     > EOI
0001 D084 0206  20        li   rtmp,(>80*256)
     D086 8000     
0002 D088 2806  18        xor  rtmp,ra
                   < elite.a99
32398 D08A D800  30        movb ra,@INWK+24                ; STA INWK+24       ; = (nosev_x * roofv_z - nosev_z * roofv_x) / 96
     D08C 006B     
32399               
32400 D08E D020  30        movb @INWK+18,ra                ; LDA INWK+18       ; Set A = roofv_y
     D090 0065     
32401               
32402 D092 0206  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_x * roofv_y
     D094 445E     
32403 D096 06A0  32        bl   @jsr                       ;
     D098 FF10     
32404               
32405 D09A D060  30        movb @INWK+12,rx                ; LDX INWK+12       ; Set X = nosev_y
     D09C 005F     
32406               
32407 D09E D020  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set A = roofv_x
     D0A0 0063     
32408               
32409 D0A2 0206  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     D0A4 4550     
32410 D0A6 06A0  32        bl   @jsr                       ;
     D0A8 FF10     
32411                                                                          ; = (-nosev_y * roofv_x + nosev_x * roofv_y) / 96
32412               
32413                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_z = -A
     **** ****     > EOI
0001 D0AA 0206  20        li   rtmp,(>80*256)
     D0AC 8000     
0002 D0AE 2806  18        xor  rtmp,ra
                   < elite.a99
32414 D0B0 D800  30        movb ra,@INWK+26                ; STA INWK+26       ; = (nosev_y * roofv_x - nosev_x * roofv_y) / 96
     D0B2 006D     
32415               
32416 D0B4 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can clear the low bytes of the
     D0B6 0000     
32417                                                                          ; orientation vectors
32418               
32419 D0B8 0201  20        li   rx,>0e*256                 ; LDX #14           ; We want to clear the low bytes, so start from sidev_y
     D0BA 0E00     
32420                                                                          ; at byte #9+14 (we clear all except sidev_z_lo, though
32421                                                                          ; I suspect this is in error and that X should be 16)
32422               
32423               TIL1:
32424 D0BC D840  38        movb ra,@INWK+9(rx)             ; STA INWK+9,X      ; Set the low byte in byte #9+X to zero
     D0BE 005C     
32425               
32426 D0C0 7044  18        sb   rone,rx                    ; DEX               ; Set X = X - 2 to jump down to the next low byte
32427 D0C2 7044  18        sb   rone,rx                    ; DEX
32428               
32429 D0C4 15FB  14        jgt  TIL1                       ; BPL TIL1          ; Loop back until we have zeroed all the low bytes
32430               
32431 D0C6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D0C8 FF1C     
32432               
32433               * ******************************************************************************
32434               *
32435               * Name: TIS2
32436               * Type: Subroutine
32437               * Category: Maths (Arithmetic)
32438               * Summary: Calculate A = A / Q
32439               * Deep dive: Shift-and-subtract division
32440               *
32441               * ------------------------------------------------------------------------------
32442               *
32443               * Calculate the following division, where A is a sign-magnitude number and Q is
32444               * a positive integer:
32445               *
32446               * A = A / Q
32447               *
32448               * The value of A is returned as a sign-magnitude number with 96 representing 1,
32449               * and the maximum value returned is 1 (i.e. 96). This routine is used when
32450               * normalising vectors, where we represent fractions using integers, so this
32451               * gives us an approximation to two decimal places.
32452               *
32453               * ******************************************************************************
32454               
32455               TIS2:
32456 D0CA D080  18        movb ra,ry                      ; TAY               ; Store the argument A in Y
32457               
32458 D0CC 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Strip the sign bit from the argument, so A = |A|
     D0CE 7F00     
32459               
32460 D0D0 9020  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q then jump to TI4 to return a 1 with the
     D0D2 0090     
32461 D0D4 1827  14        joc  TI4                        ; BCS TI4           ; correct sign
32462               
32463 D0D6 0201  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set T to have bits 1-7 set, so we can rotate through 7
     D0D8 FE00     
32464 D0DA D801  30        movb rx,@T                      ; STX T             ; loop iterations, getting a 1 each time, and then
     D0DC 00D1     
32465                                                                          ; getting a 0 on the 8th iteration... and we can also
32466                                                                          ; use T to catch our result bits into bit 0 each time
32467               
32468               TIL2:
32469                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 D0DE 0240  22        andi ra,>ff00
     D0E0 FF00     
0002 D0E2 0A10  18        sla  ra,1
                   < elite.a99
32470               
32471 D0E4 9020  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     D0E6 0090     
32472 D0E8 1704  14        jnc  B108                       ; BCC B108
32473               
32474                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 D0EA 1801  14        joc  !
0002 D0EC 7004  18        sb   rone,ra
0003               !:
0004 D0EE 7020  30        sb   @Q,ra
     D0F0 0090     
                   < elite.a99
32475                                                                          ;
32476                                                                          ; Going into this subtraction we know the C flag is
32477                                                                          ; set as we passed through the BCC above, and we also
32478                                                                          ; know that A >= Q, so the C flag will still be set once
32479                                                                          ; we are done
32480               
32481               B108:
32482 D0F2 0208  20        li   rarg1,T                    ; ROL T             ; Rotate the counter in T to the left, and catch the
     D0F4 00D1     
32483 D0F6 06A0  32        bl   @rol                       ;
     D0F8 FF36     
32484                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
32485                                                                          ; do the subtraction, or 1 if we did)
32486               
32487 D0FA 18F1  14        joc  TIL2                       ; BCS TIL2          ; If we still have set bits in T, loop back to TIL2 to
32488                                                                          ; do the next iteration of 7
32489               
32490                                                                          ; We've done the division and now have a result in the
32491                                                                          ; range 0-255 here, which we need to reduce to the range
32492                                                                          ; 0-96. We can do that by multiplying the result by 3/8,
32493                                                                          ; as 256 * 3/8 = 96
32494               
32495 D0FC D020  30        movb @T,ra                      ; LDA T             ; Set T = T / 4
     D0FE 00D1     
32496 D100 0910  18        srl  ra,1                       ; LSR A
32497 D102 0910  18        srl  ra,1                       ; LSR A
32498 D104 D800  30        movb ra,@T                      ; STA T
     D106 00D1     
32499               
32500 D108 0910  18        srl  ra,1                       ; LSR A             ; Set T = T / 8 + T / 4
32501                      .adc @T,ra                      ; ADC T             ; = 3T / 8
     **** ****     > ADC
0001 D10A 1701  14        jnc  !
0002 D10C B004  18        ab   rone,ra
0003               !:
0004 D10E B020  30        ab   @T,ra
     D110 00D1     
                   < elite.a99
32502 D112 D800  30        movb ra,@T                      ; STA T
     D114 00D1     
32503               
32504 D116 D002  18        movb ry,ra                      ; TYA               ; Fetch the sign bit of the original argument A
32505 D118 0240  22        andi ra,>80*256                 ; AND #%10000000
     D11A 8000     
32506               
32507 D11C F020  30        socb @T,ra                      ; ORA T             ; Apply the sign bit to T
     D11E 00D1     
32508               
32509 D120 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D122 FF1C     
32510               
32511               TI4:
32512 D124 D002  18        movb ry,ra                      ; TYA               ; Fetch the sign bit of the original argument A
32513 D126 0240  22        andi ra,>80*256                 ; AND #%10000000
     D128 8000     
32514               
32515 D12A 0260  22        ori  ra,>60*256                 ; ORA #96           ; Apply the sign bit to 96 (which represents 1)
     D12C 6000     
32516               
32517 D12E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D130 FF1C     
32518               
32519               * ******************************************************************************
32520               *
32521               * Name: TIS3
32522               * Type: Subroutine
32523               * Category: Maths (Arithmetic)
32524               * Summary: Calculate -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
32525               *
32526               * ------------------------------------------------------------------------------
32527               *
32528               * Calculate the following expression:
32529               *
32530               * A = -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
32531               *
32532               * where 1, 2 and 3 are x, y, or z, depending on the values of X, Y and A. This
32533               * routine is called with the following values:
32534               *
32535               * X = 0, Y = 2, A = 4 ->
32536               * A = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
32537               *
32538               * X = 0, Y = 4, A = 2 ->
32539               * A = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
32540               *
32541               * X = 2, Y = 4, A = 0 ->
32542               * A = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
32543               *
32544               * ------------------------------------------------------------------------------
32545               *
32546               * Arguments:
32547               *
32548               * X                   Index 1 (0 = x, 2 = y, 4 = z)
32549               *
32550               * Y                   Index 2 (0 = x, 2 = y, 4 = z)
32551               *
32552               * A                   Index 3 (0 = x, 2 = y, 4 = z)
32553               *
32554               * ******************************************************************************
32555               
32556               TIS3:
32557 D132 D800  30        movb ra,@P+2                    ; STA P+2           ; Store P+2 in A for later
     D134 001D     
32558               
32559 D136 D021  34        movb @INWK+10(rx),ra            ; LDA INWK+10,X     ; Set Q = nosev_x_hi (plus X)
     D138 005D     
32560 D13A D800  30        movb ra,@Q                      ; STA Q
     D13C 0090     
32561               
32562 D13E D021  34        movb @INWK+16(rx),ra            ; LDA INWK+16,X     ; Set A = roofv_x_hi (plus X)
     D140 0063     
32563               
32564 D142 0206  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A
     D144 445E     
32565 D146 06A0  32        bl   @jsr                       ;
     D148 FF10     
32566                                                                          ; = nosev_x_hi * roofv_x_hi
32567               
32568 D14A D062  34        movb @INWK+10(ry),rx            ; LDX INWK+10,Y     ; Set Q = nosev_x_hi (plus Y)
     D14C 005D     
32569 D14E D801  30        movb rx,@Q                      ; STX Q
     D150 0090     
32570               
32571 D152 D022  34        movb @INWK+16(ry),ra            ; LDA INWK+16,Y     ; Set A = roofv_x_hi (plus Y)
     D154 0063     
32572               
32573 D156 0206  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     D158 44B2     
32574 D15A 06A0  32        bl   @jsr                       ;
     D15C FF10     
32575                                                                          ; = (nosev_x,X * roofv_x,X) +
32576                                                                          ; (nosev_x,Y * roofv_x,Y)
32577               
32578 D15E D801  30        movb rx,@P                      ; STX P             ; Store low byte of result in P, so result is now in
     D160 001B     
32579                                                                          ; (A P)
32580               
32581 D162 D0A0  30        movb @P+2,ry                    ; LDY P+2           ; Set Q = roofv_x_hi (plus argument A)
     D164 001D     
32582 D166 D062  34        movb @INWK+10(ry),rx            ; LDX INWK+10,Y
     D168 005D     
32583 D16A D801  30        movb rx,@Q                      ; STX Q
     D16C 0090     
32584               
32585                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A
     **** ****     > EOI
0001 D16E 0206  20        li   rtmp,(>80*256)
     D170 8000     
0002 D172 2806  18        xor  rtmp,ra
                   < elite.a99
32586               
32587                                                                          ; Fall through into DIVDT to do:
32588                                                                          ;
32589                                                                          ; (P+1 A) = (A P) / Q
32590                                                                          ;
32591                                                                          ; = -((nosev_x,X * roofv_x,X) +
32592                                                                          ; (nosev_x,Y * roofv_x,Y))
32593                                                                          ; / nosev_x,A
32594               
32595               * ******************************************************************************
32596               *
32597               * Name: DVIDT
32598               * Type: Subroutine
32599               * Category: Maths (Arithmetic)
32600               * Summary: Calculate (P+1 A) = (A P) / Q
32601               *
32602               * ------------------------------------------------------------------------------
32603               *
32604               * Calculate the following integer division between sign-magnitude numbers:
32605               *
32606               * (P+1 A) = (A P) / Q
32607               *
32608               * This uses the same shift-and-subtract algorithm as TIS2.
32609               *
32610               * ******************************************************************************
32611               
32612               DVIDT:
32613 D174 D800  30        movb ra,@P+1                    ; STA P+1           ; Set P+1 = A, so P(1 0) = (A P)
     D176 001C     
32614               
32615                      .eor @Q                         ; EOR Q             ; Set T = the sign bit of A EOR Q, so it's 1 if A and Q
     **** ****     > EOR
0001 D178 D1A0  30        movb @Q,rtmp
     D17A 0090     
0002 D17C 2806  18        xor  rtmp,ra
                   < elite.a99
32616 D17E 0240  22        andi ra,>80*256                 ; AND #%10000000    ; have different signs, i.e. it's the sign of the result
     D180 8000     
32617 D182 D800  30        movb ra,@T                      ; STA T             ; of A / Q
     D184 00D1     
32618               
32619 D186 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 for us to build a result
     D188 0000     
32620               
32621 D18A 0201  20        li   rx,>10*256                 ; LDX #16           ; Set a counter in X to count the 16 bits in P(1 0)
     D18C 1000     
32622               
32623                      .asl @P                         ; ASL P             ; Shift P(1 0) left
     **** ****     > ASL
0001 D18E D1A0  30        movb @P,rtmp
     D190 001B     
0002 D192 0246  22        andi rtmp,>ff00
     D194 FF00     
0003 D196 0A16  18        sla  rtmp,1
0004 D198 D806  30        movb rtmp,@P
     D19A 001B     
                   < elite.a99
32624 D19C 0208  20        li   rarg1,P+1                  ; ROL P+1
     D19E 001C     
32625 D1A0 06A0  32        bl   @rol                       ;
     D1A2 FF36     
32626               
32627                      .asl @Q                         ; ASL Q             ; Clear the sign bit of Q the C flag at the same time
     **** ****     > ASL
0001 D1A4 D1A0  30        movb @Q,rtmp
     D1A6 0090     
0002 D1A8 0246  22        andi rtmp,>ff00
     D1AA FF00     
0003 D1AC 0A16  18        sla  rtmp,1
0004 D1AE D806  30        movb rtmp,@Q
     D1B0 0090     
                   < elite.a99
32628                      .lsr @Q                         ; LSR Q
     **** ****     > LSR
0001 D1B2 D1A0  30        movb @Q,rtmp
     D1B4 0090     
0002 D1B6 0916  18        srl  rtmp,1
0003 D1B8 D806  30        movb rtmp,@Q
     D1BA 0090     
                   < elite.a99
32629               
32630               DVL2:
32631 D1BC 06A0  32        bl   @rola                      ; ROL A             ; Shift A to the left
     D1BE FF26     
32632               
32633 D1C0 9020  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     D1C2 0090     
32634 D1C4 1704  14        jnc  B109                       ; BCC B109
32635               
32636                      .sbc @Q,ra                      ; SBC Q             ; Set A = A - Q
     **** ****     > SBC
0001 D1C6 1801  14        joc  !
0002 D1C8 7004  18        sb   rone,ra
0003               !:
0004 D1CA 7020  30        sb   @Q,ra
     D1CC 0090     
                   < elite.a99
32637                                                                          ;
32638                                                                          ; Going into this subtraction we know the C flag is
32639                                                                          ; set as we passed through the BCC above, and we also
32640                                                                          ; know that A >= Q, so the C flag will still be set once
32641                                                                          ; we are done
32642               
32643               B109:
32644 D1CE 0208  20        li   rarg1,P                    ; ROL P             ; Rotate P(1 0) to the left, and catch the result bit
     D1D0 001B     
32645 D1D2 06A0  32        bl   @rol                       ;
     D1D4 FF36     
32646 D1D6 0208  20        li   rarg1,P+1                  ; ROL P+1           ; into the C flag (which will be a 0 if we didn't
     D1D8 001C     
32647 D1DA 06A0  32        bl   @rol                       ;
     D1DC FF36     
32648                                                                          ; do the subtraction, or 1 if we did)
32649               
32650 D1DE 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
32651               
32652 D1E0 16ED  14        jne  DVL2                       ; BNE DVL2          ; Loop back for the next bit until we have done all 16
32653                                                                          ; bits of P(1 0)
32654               
32655 D1E2 D020  30        movb @P,ra                      ; LDA P             ; Set A = P so the low byte is in the result in A
     D1E4 001B     
32656               
32657 D1E6 F020  30        socb @T,ra                      ; ORA T             ; Set A to the correct sign bit that we set in T above
     D1E8 00D1     
32658               
32659 D1EA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D1EC FF1C     
32660               
32661               * ******************************************************************************
32662               *
32663               * Save ELTF.bin
32664               *
32665               * ******************************************************************************
32666               
32667                      ; PRINT "ELITE F"
32668                      ; PRINT "Assembled at ", ~CODE_F%
32669                      ; PRINT "Ends at ", ~P%
32670                      ; PRINT "Code size is ", ~(P% - CODE_F%)
32671                      ; PRINT "Execute at ", ~LOAD%
32672                      ; PRINT "Reload at ", ~LOAD_F%
32673               
32674                      ; PRINT "S.ELTF ", ~CODE_F%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_F%
32675                      ; SAVE "3-assembled-output/ELTF.bin", CODE_F%, P%, LOAD%
32676               
32677               * ******************************************************************************
32678               *
32679               * ELITE G FILE
32680               *
32681               * Produces the binary file ELTG.bin that gets loaded by elite-bcfs.asm.
32682               *
32683               * ******************************************************************************
32684               
32685               CODE_G.:
32686                      equ $
32687               
32688               LOAD_G.:
32689                      equ LOAD. + $ - CODE.
32690               
32691               * ******************************************************************************
32692               *
32693               * Name: SHPPT
32694               * Type: Subroutine
32695               * Category: Drawing ships
32696               * Summary: Draw a distant ship as a point rather than a full wireframe
32697               *
32698               * ******************************************************************************
32699               
32700               SHPPT:
32701 D1EE 0206  20        li   rtmp,EE51                  ; JSR EE51          ; Call EE51 to remove the ship's wireframe from the
     D1F0 D588     
32702 D1F2 06A0  32        bl   @jsr                       ;
     D1F4 FF10     
32703                                                                          ; screen, if there is one
32704               
32705 D1F6 0206  20        li   rtmp,PROJ                  ; JSR PROJ          ; Project the ship onto the screen, returning:
     D1F8 B15A     
32706 D1FA 06A0  32        bl   @jsr                       ;
     D1FC FF10     
32707                                                                          ;
32708                                                                          ; * K3(1 0) = the screen x-coordinate
32709                                                                          ; * K4(1 0) = the screen y-coordinate
32710                                                                          ; * A = K4+1
32711               
32712 D1FE F020  30        socb @K3+1,ra                   ; ORA K3+1          ; If either of the high bytes of the screen coordinates
     D200 00D3     
32713 D202 1625  14        jne  nono_                      ; BNE nono          ; are non-zero, jump to nono as the ship is off-screen
32714               
32715 D204 D020  30        movb @K4,ra                     ; LDA K4            ; Set A = the y-coordinate of the dot
     D206 00E0     
32716               
32717 D208 0280  22        ci   ra,(Y*2-2)*256             ; CMP #Y*2-2        ; If the y-coordinate is bigger than the y-coordinate of
     D20A BE00     
32718 D20C 1820  14        joc  nono_                      ; BCS nono          ; the bottom of the screen, jump to nono as the ship's
32719                                                                          ; dot is off the bottom of the space view
32720               
32721 D20E 0202  20        li   ry,>02*256                 ; LDY #2            ; Call Shpt with Y = 2 to set up bytes 1-4 in the ship
     D210 0200     
32722 D212 0206  20        li   rtmp,Shpt                  ; JSR Shpt          ; lines space, aborting the call to LL9 if the dot is
     D214 D262     
32723 D216 06A0  32        bl   @jsr                       ;
     D218 FF10     
32724                                                                          ; off the side of the screen. This call sets up the
32725                                                                          ; first row of the dot (i.e. a four-pixel dash)
32726               
32727 D21A 0202  20        li   ry,>06*256                 ; LDY #6            ; Set Y to 6 for the next call to Shpt
     D21C 0600     
32728               
32729 D21E D020  30        movb @K4,ra                     ; LDA K4            ; Set A = y-coordinate of dot + 1 (so this is the second
     D220 00E0     
32730                      .adi (>01*256)                  ; ADC #1            ; row of the two-pixel-high dot)
     **** ****     > ADI
0001 D222 1701  14        jnc  !
0002 D224 B004  18        ab   rone,ra
0003               !:
0004 D226 0220  22        ai   ra,(>01*256)
     D228 0100     
                   < elite.a99
32731                                                                          ;
32732                                                                          ; The addition works as the Shpt routine clears the C
32733                                                                          ; flag
32734               
32735 D22A 0206  20        li   rtmp,Shpt                  ; JSR Shpt          ; Call Shpt with Y = 6 to set up bytes 5-8 in the ship
     D22C D262     
32736 D22E 06A0  32        bl   @jsr                       ;
     D230 FF10     
32737                                                                          ; lines space, aborting the call to LL9 if the dot is
32738                                                                          ; off the side of the screen. This call sets up the
32739                                                                          ; second row of the dot (i.e. another four-pixel dash,
32740                                                                          ; on the row below the first one)
32741               
32742 D232 0200  20        li   ra,>08*256                 ; LDA #%00001000    ; Set bit 3 of the ship's byte #31 to record that we
     D234 0800     
32743 D236 F020  30        socb @XX1+31,ra                 ; ORA XX1+31        ; have now drawn something on-screen for this ship
     D238 0072     
32744 D23A D800  30        movb ra,@XX1+31                 ; STA XX1+31
     D23C 0072     
32745               
32746 D23E 0200  20        li   ra,>08*256                 ; LDA #8            ; Set A = 8 so when we call LL18+2 next, byte #0 of the
     D240 0800     
32747                                                                          ; heap gets set to 8, for the 8 bytes we just stuck on
32748                                                                          ; the heap
32749               
32750 D242 0460  28        b    @LL81+2                    ; JMP LL81+2        ; Call LL81+2 to draw the ship's dot, returning from the
     D244 E248     
32751                                                                          ; subroutine using a tail call
32752               
32753                      .pla                            ; PLA               ; Pull the return address from the stack, so the RTS
     **** ****     > PLA
0001 D246 058A  14        inc  rsp
0002 D248 D01A  26        movb *rsp,ra
                   < elite.a99
32754                      .pla                            ; PLA               ; below actually returns from the subroutine that called
     **** ****     > PLA
0001 D24A 058A  14        inc  rsp
0002 D24C D01A  26        movb *rsp,ra
                   < elite.a99
32755                                                                          ; LL9 (as we called SHPPT from LL9 with a JMP)
32756               
32757               nono_:
32758 D24E 0200  20        li   ra,>f7*256                 ; LDA #%11110111    ; Clear bit 3 of the ship's byte #31 to record that
     D250 F700     
32759                      .and @XX1+31                    ; AND XX1+31        ; nothing is being drawn on-screen for this ship
     **** ****     > AND
0001 D252 D1A0  30        movb @XX1+31,rtmp
     D254 0072     
0002 D256 0546  14        inv  rtmp
0003 D258 5006  18        szcb rtmp,ra
                   < elite.a99
32760 D25A D800  30        movb ra,@XX1+31                 ; STA XX1+31
     D25C 0072     
32761               
32762 D25E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D260 FF1C     
32763               
32764               Shpt:
32765                                                                          ; This routine sets up four bytes in the ship line heap,
32766                                                                          ; from byte Y-1 to byte Y+2. If the ship's screen point
32767                                                                          ; turns out to be off-screen, then this routine aborts
32768                                                                          ; the entire call to LL9, exiting via nono. The four
32769                                                                          ; bytes define a horizontal 4-pixel dash, for either the
32770                                                                          ; top or the bottom of the ship's dot
32771                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store A in byte Y of the ship line heap (i.e. Y1)
     **** ****     > ST_IND_Y_IDX
0001 D262 D820  50        movb @XX19,@rtmplb
     D264 0074     
     D266 2079     
0002 D268 D1A0  30        movb @XX19+1,rtmp
     D26A 0075     
0003 D26C A182  18        a    ry,rtmp
0004 D26E D580  30        movb RA,*rtmp
                   < elite.a99
32772               
32773 D270 B084  18        ab   rone,ry                    ; INY               ; Store A in byte Y+2 of the ship line heap (i.e. Y2)
32774 D272 B084  18        ab   rone,ry                    ; INY
32775                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 D274 D820  50        movb @XX19,@rtmplb
     D276 0074     
     D278 2079     
0002 D27A D1A0  30        movb @XX19+1,rtmp
     D27C 0075     
0003 D27E A182  18        a    ry,rtmp
0004 D280 D580  30        movb RA,*rtmp
                   < elite.a99
32776               
32777 D282 D020  30        movb @K3,ra                     ; LDA K3            ; Set A = screen x-coordinate of the ship dot
     D284 00D2     
32778               
32779 D286 7084  18        sb   rone,ry                    ; DEY               ; Store A in byte Y+1 of the ship line heap (i.e. X2)
32780                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 D288 D820  50        movb @XX19,@rtmplb
     D28A 0074     
     D28C 2079     
0002 D28E D1A0  30        movb @XX19+1,rtmp
     D290 0075     
0003 D292 A182  18        a    ry,rtmp
0004 D294 D580  30        movb RA,*rtmp
                   < elite.a99
32781               
32782                      .adi (>03*256)                  ; ADC #3            ; Set A = screen x-coordinate of the ship dot + 3
     **** ****     > ADI
0001 D296 1701  14        jnc  !
0002 D298 B004  18        ab   rone,ra
0003               !:
0004 D29A 0220  22        ai   ra,(>03*256)
     D29C 0300     
                   < elite.a99
32783               
32784 D29E 18D6  14        joc  nono_-2                    ; BCS nono-2        ; If the addition pushed the dot off the right side of
32785                                                                          ; the screen, jump to nono-2 to return from the parent
32786                                                                          ; subroutine early (i.e. LL9). This works because we
32787                                                                          ; called Shpt from above with a JSR, so nono-2 removes
32788                                                                          ; that return address from the stack, leaving the next
32789                                                                          ; return address exposed. LL9 called SHPPT with a JMP,
32790                                                                          ; so the next return address is the one that was put on
32791                                                                          ; the stack by the original call to LL9. So the RTS in
32792                                                                          ; nono will actually return us from the original call
32793                                                                          ; to LL9, thus aborting the entire drawing process
32794               
32795 D2A0 7084  18        sb   rone,ry                    ; DEY               ; Store A in byte Y-1 of the ship line heap (i.e. X1)
32796 D2A2 7084  18        sb   rone,ry                    ; DEY
32797                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 D2A4 D820  50        movb @XX19,@rtmplb
     D2A6 0074     
     D2A8 2079     
0002 D2AA D1A0  30        movb @XX19+1,rtmp
     D2AC 0075     
0003 D2AE A182  18        a    ry,rtmp
0004 D2B0 D580  30        movb RA,*rtmp
                   < elite.a99
32798               
32799 D2B2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D2B4 FF1C     
32800               
32801               * ******************************************************************************
32802               *
32803               * Name: LL5
32804               * Type: Subroutine
32805               * Category: Maths (Arithmetic)
32806               * Summary: Calculate Q = SQRT(R Q)
32807               * Deep dive: Calculating square roots
32808               *
32809               * ------------------------------------------------------------------------------
32810               *
32811               * Calculate the following square root:
32812               *
32813               * Q = SQRT(R Q)
32814               *
32815               * ******************************************************************************
32816               
32817               LL5:
32818 D2B6 D0A0  30        movb @R,ry                      ; LDY R             ; Set (Y S) = (R Q)
     D2B8 0091     
32819 D2BA D020  30        movb @Q,ra                      ; LDA Q
     D2BC 0090     
32820 D2BE D800  30        movb ra,@S                      ; STA S
     D2C0 0092     
32821               
32822                                                                          ; So now to calculate Q = SQRT(Y S)
32823               
32824 D2C2 0201  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0, to hold the remainder
     D2C4 0000     
32825               
32826 D2C6 D801  30        movb rx,@Q                      ; STX Q             ; Set Q = 0, to hold the result
     D2C8 0090     
32827               
32828 D2CA 0200  20        li   ra,>08*256                 ; LDA #8            ; Set T = 8, to use as a loop counter
     D2CC 0800     
32829 D2CE D800  30        movb ra,@T                      ; STA T
     D2D0 00D1     
32830               
32831               LL6:
32832 D2D2 9060  30        cb   @Q,rx                      ; CPX Q             ; If X < Q, jump to LL7
     D2D4 0090     
32833 D2D6 1710  14        jnc  LL7                        ; BCC LL7
32834               
32835 D2D8 1603  14        jne  LL8                        ; BNE LL8           ; If X > Q, jump to LL8
32836               
32837 D2DA 0282  22        ci   ry,>40*256                 ; CPY #64           ; If Y < 64, jump to LL7 with the C flag clear,
     D2DC 4000     
32838 D2DE 170C  14        jnc  LL7                        ; BCC LL7           ; otherwise fall through into LL8 with the C flag set
32839               
32840               LL8:
32841 D2E0 D002  18        movb ry,ra                      ; TYA               ; Set Y = Y - 64
32842                      .sbi (>40*256)                  ; SBC #64           ;
     **** ****     > SBI
0001 D2E2 1801  14        joc  !
0002 D2E4 7004  18        sb   rone,ra
0003               !:
0004 D2E6 0220  22        ai   ra,-(>40*256)
     D2E8 C000     
                   < elite.a99
32843 D2EA D080  18        movb ra,ry                      ; TAY               ; This subtraction will work as we know C is set from
32844                                                                          ; the BCC above, and the result will not underflow as we
32845                                                                          ; already checked that Y >= 64, so the C flag is also
32846                                                                          ; set for the next subtraction
32847               
32848 D2EC D001  18        movb rx,ra                      ; TXA               ; Set X = X - Q
32849                      .sbc @Q,ra                      ; SBC Q
     **** ****     > SBC
0001 D2EE 1801  14        joc  !
0002 D2F0 7004  18        sb   rone,ra
0003               !:
0004 D2F2 7020  30        sb   @Q,ra
     D2F4 0090     
                   < elite.a99
32850 D2F6 D040  18        movb ra,rx                      ; TAX
32851               
32852               LL7:
32853 D2F8 0208  20        li   rarg1,Q                    ; ROL Q             ; Shift the result in Q to the left, shifting the C flag
     D2FA 0090     
32854 D2FC 06A0  32        bl   @rol                       ;
     D2FE FF36     
32855                                                                          ; into bit 0 and bit 7 into the C flag
32856               
32857                      .asl @S                         ; ASL S             ; Shift the dividend in (Y S) to the left, inserting
     **** ****     > ASL
0001 D300 D1A0  30        movb @S,rtmp
     D302 0092     
0002 D304 0246  22        andi rtmp,>ff00
     D306 FF00     
0003 D308 0A16  18        sla  rtmp,1
0004 D30A D806  30        movb rtmp,@S
     D30C 0092     
                   < elite.a99
32858 D30E D002  18        movb ry,ra                      ; TYA               ; bit 7 from above into bit 0
32859 D310 06A0  32        bl   @rola                      ; ROL A
     D312 FF26     
32860 D314 D080  18        movb ra,ry                      ; TAY
32861               
32862 D316 D001  18        movb rx,ra                      ; TXA               ; Shift the remainder in X to the left
32863 D318 06A0  32        bl   @rola                      ; ROL A
     D31A FF26     
32864 D31C D040  18        movb ra,rx                      ; TAX
32865               
32866                      .asl @S                         ; ASL S             ; Shift the dividend in (Y S) to the left
     **** ****     > ASL
0001 D31E D1A0  30        movb @S,rtmp
     D320 0092     
0002 D322 0246  22        andi rtmp,>ff00
     D324 FF00     
0003 D326 0A16  18        sla  rtmp,1
0004 D328 D806  30        movb rtmp,@S
     D32A 0092     
                   < elite.a99
32867 D32C D002  18        movb ry,ra                      ; TYA
32868 D32E 06A0  32        bl   @rola                      ; ROL A
     D330 FF26     
32869 D332 D080  18        movb ra,ry                      ; TAY
32870               
32871 D334 D001  18        movb rx,ra                      ; TXA               ; Shift the remainder in X to the left
32872 D336 06A0  32        bl   @rola                      ; ROL A
     D338 FF26     
32873 D33A D040  18        movb ra,rx                      ; TAX
32874               
32875 D33C 7004  18        sb   rone,ra                    ; DEC T             ; Decrement the loop counter
32876               
32877 D33E 16C9  14        jne  LL6                        ; BNE LL6           ; Loop back to LL6 until we have done 8 loops
32878               
32879 D340 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D342 FF1C     
32880               
32881               * ******************************************************************************
32882               *
32883               * Name: LL28
32884               * Type: Subroutine
32885               * Category: Maths (Arithmetic)
32886               * Summary: Calculate R = 256 * A / Q
32887               * Deep dive: Shift-and-subtract division
32888               *
32889               * ------------------------------------------------------------------------------
32890               *
32891               * Calculate the following, where A < Q:
32892               *
32893               * R = 256 * A / Q
32894               *
32895               * This is a sister routine to LL61, which does the division when A >= Q.
32896               *
32897               * If A >= Q then 255 is returned and the C flag is set to indicate an overflow
32898               * (the C flag is clear if the division was a success).
32899               *
32900               * The result is returned in one byte as the result of the division multiplied
32901               * by 256, so we can return fractional results using integers.
32902               *
32903               * This routine uses the same shift-and-subtract algorithm that's documented in
32904               * TIS2, but it leaves the fractional result in the integer range 0-255.
32905               *
32906               * ------------------------------------------------------------------------------
32907               *
32908               * Returns:
32909               *
32910               * C flag              Set if the answer is too big for one byte, clear if the
32911               * division was a success
32912               *
32913               * ------------------------------------------------------------------------------
32914               *
32915               * Other entry points:
32916               *
32917               * LL28+4              Skips the A >= Q check and always returns with C flag
32918               * cleared, so this can be called if we know the division
32919               * will work
32920               *
32921               * LL31                Skips the A >= Q check and does not set the R counter,
32922               * so this can be used for jumping straight into the
32923               * division loop if R is already set to 254 and we know the
32924               * division will work
32925               *
32926               * ******************************************************************************
32927               
32928               LL28:
32929 D344 9020  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, then the answer will not fit in one byte,
     D346 0090     
32930 D348 1822  14        joc  LL2                        ; BCS LL2           ; so jump to LL2 to return 255
32931               
32932 D34A 0201  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set R to have bits 1-7 set, so we can rotate through 7
     D34C FE00     
32933 D34E D801  30        movb rx,@R                      ; STX R             ; loop iterations, getting a 1 each time, and then
     D350 0091     
32934                                                                          ; getting a 0 on the 8th iteration... and we can also
32935                                                                          ; use R to catch our result bits into bit 0 each time
32936               
32937               LL31:
32938                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 D352 0240  22        andi ra,>ff00
     D354 FF00     
0002 D356 0A10  18        sla  ra,1
                   < elite.a99
32939               
32940 D358 180E  14        joc  LL29                       ; BCS LL29          ; If bit 7 of A was set, then jump straight to the
32941                                                                          ; subtraction
32942               
32943 D35A 9020  30        cb   @Q,ra                      ; CMP Q             ; If A < Q, skip the following subtraction
     D35C 0090     
32944 D35E 1704  14        jnc  B110                       ; BCC B110
32945               
32946                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 D360 1801  14        joc  !
0002 D362 7004  18        sb   rone,ra
0003               !:
0004 D364 7020  30        sb   @Q,ra
     D366 0090     
                   < elite.a99
32947               
32948               B110:
32949 D368 0208  20        li   rarg1,R                    ; ROL R             ; Rotate the counter in R to the left, and catch the
     D36A 0091     
32950 D36C 06A0  32        bl   @rol                       ;
     D36E FF36     
32951                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
32952                                                                          ; do the subtraction, or 1 if we did)
32953               
32954 D370 18F0  14        joc  LL31                       ; BCS LL31          ; If we still have set bits in R, loop back to LL31 to
32955                                                                          ; do the next iteration of 7
32956               
32957 D372 0460  28        b    @rts                       ; RTS               ; R left with remainder of division
     D374 FF1C     
32958               
32959               LL29:
32960                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 D376 1801  14        joc  !
0002 D378 7004  18        sb   rone,ra
0003               !:
0004 D37A 7020  30        sb   @Q,ra
     D37C 0090     
                   < elite.a99
32961               
32962                      .sec                            ; SEC               ; Set the C flag to rotate into the result in R
     **** ****     > SEC
0001 D37E 0A15  18        sla  rmone,1
                   < elite.a99
32963               
32964 D380 0208  20        li   rarg1,R                    ; ROL R             ; Rotate the counter in R to the left, and catch the
     D382 0091     
32965 D384 06A0  32        bl   @rol                       ;
     D386 FF36     
32966                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
32967                                                                          ; do the subtraction, or 1 if we did)
32968               
32969 D388 18E4  14        joc  LL31                       ; BCS LL31          ; If we still have set bits in R, loop back to LL31 to
32970                                                                          ; do the next iteration of 7
32971               
32972 D38A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine with R containing the
     D38C FF1C     
32973                                                                          ; remainder of the division
32974               
32975               LL2:
32976 D38E 0200  20        li   ra,>ff*256                 ; LDA #255          ; The division is very close to 1, so return the closest
     D390 FF00     
32977 D392 D800  30        movb ra,@R                      ; STA R             ; possible answer to 256, i.e. R = 255
     D394 0091     
32978               
32979 D396 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D398 FF1C     
32980               
32981               * ******************************************************************************
32982               *
32983               * Name: LL38
32984               * Type: Subroutine
32985               * Category: Maths (Arithmetic)
32986               * Summary: Calculate (S A) = (S R) + (A Q)
32987               *
32988               * ------------------------------------------------------------------------------
32989               *
32990               * Calculate the following between sign-magnitude numbers:
32991               *
32992               * (S A) = (S R) + (A Q)
32993               *
32994               * where the sign bytes only contain the sign bits, not magnitudes.
32995               *
32996               * ------------------------------------------------------------------------------
32997               *
32998               * Returns:
32999               *
33000               * C flag              Set if the addition overflowed, clear otherwise
33001               *
33002               * ******************************************************************************
33003               
33004               LL38:
33005                      .eor @S                         ; EOR S             ; If the sign of A * S is negative, skip to LL35, as
     **** ****     > EOR
0001 D39A D1A0  30        movb @S,rtmp
     D39C 0092     
0002 D39E 2806  18        xor  rtmp,ra
                   < elite.a99
33006 D3A0 1109  14        jlt  LL39                       ; BMI LL39          ; A and S have different signs so we need to subtract
33007               
33008 D3A2 D020  30        movb @Q,ra                      ; LDA Q             ; Otherwise set A = R + Q, which is the result we need,
     D3A4 0090     
33009                      .clc                            ; CLC               ; as S already contains the correct sign
     **** ****     > CLC
0001 D3A6 0A13  18        sla  rzero,1
                   < elite.a99
33010                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 D3A8 1701  14        jnc  !
0002 D3AA B004  18        ab   rone,ra
0003               !:
0004 D3AC B020  30        ab   @R,ra
     D3AE 0091     
                   < elite.a99
33011               
33012 D3B0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D3B2 FF1C     
33013               
33014               LL39:
33015 D3B4 D020  30        movb @R,ra                      ; LDA R             ; Set A = R - Q
     D3B6 0091     
33016                      .sec                            ; SEC
     **** ****     > SEC
0001 D3B8 0A15  18        sla  rmone,1
                   < elite.a99
33017                      .sbc @Q,ra                      ; SBC Q
     **** ****     > SBC
0001 D3BA 1801  14        joc  !
0002 D3BC 7004  18        sb   rone,ra
0003               !:
0004 D3BE 7020  30        sb   @Q,ra
     D3C0 0090     
                   < elite.a99
33018               
33019 D3C2 1701  14        jnc  B111                       ; BCC B111          ; If the subtraction underflowed, skip the next two
33020                                                                          ; instructions so we can negate the result
33021               
33022                      .clc                            ; CLC               ; Otherwise the result is correct, and S contains the
     **** ****     > CLC
0001 D3C4 0A13  18        sla  rzero,1
                   < elite.a99
33023                                                                          ; correct sign of the result as R is the dominant side
33024                                                                          ; of the subtraction, so clear the C flag
33025               
33026               B111:
33027 D3C6 0460  28        b    @rts                       ; RTS               ; And return from the subroutine
     D3C8 FF1C     
33028               
33029                                                                          ; If we get here we need to negate both the result and
33030                                                                          ; the sign in S, as both are the wrong sign
33031               
33032                      .pha                            ; PHA               ; Store the result of the subtraction on the stack
     **** ****     > PHA
0001 D3CA D680  30        movb ra,*rsp
0002 D3CC 060A  14        dec  rsp
                   < elite.a99
33033               
33034 D3CE D020  30        movb @S,ra                      ; LDA S             ; Flip the sign of S
     D3D0 0092     
33035                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 D3D2 0206  20        li   rtmp,(>80*256)
     D3D4 8000     
0002 D3D6 2806  18        xor  rtmp,ra
                   < elite.a99
33036 D3D8 D800  30        movb ra,@S                      ; STA S
     D3DA 0092     
33037               
33038                      .pla                            ; PLA               ; Restore the subtraction result into A
     **** ****     > PLA
0001 D3DC 058A  14        inc  rsp
0002 D3DE D01A  26        movb *rsp,ra
                   < elite.a99
33039               
33040                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A using two's complement, i.e.
     **** ****     > EOI
0001 D3E0 0206  20        li   rtmp,(>FF*256)
     D3E2 FF00     
0002 D3E4 2806  18        xor  rtmp,ra
                   < elite.a99
33041                      .adi (>01*256)                  ; ADC #1            ; set A = ~A + 1
     **** ****     > ADI
0001 D3E6 1701  14        jnc  !
0002 D3E8 B004  18        ab   rone,ra
0003               !:
0004 D3EA 0220  22        ai   ra,(>01*256)
     D3EC 0100     
                   < elite.a99
33042               
33043 D3EE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D3F0 FF1C     
33044               
33045               * ******************************************************************************
33046               *
33047               * Name: LL51
33048               * Type: Subroutine
33049               * Category: Maths (Geometry)
33050               * Summary: Calculate the dot product of XX15 and XX16
33051               *
33052               * ------------------------------------------------------------------------------
33053               *
33054               * Calculate the following dot products:
33055               *
33056               * XX12(1 0) = XX15(5 0) . XX16(5 0)
33057               * XX12(3 2) = XX15(5 0) . XX16(11 6)
33058               * XX12(5 4) = XX15(5 0) . XX16(12 17)
33059               *
33060               * storing the results as sign-magnitude numbers in XX12 through XX12+5.
33061               *
33062               * When called from part 5 of LL9, XX12 contains the vector [x y z] to the ship
33063               * we're drawing, and XX16 contains the orientation vectors, so it returns:
33064               *
33065               * [ x ]   [ sidev_x ]         [ x ]   [ roofv_x ]         [ x ]   [ nosev_x ]
33066               * [ y ] . [ sidev_y ]         [ y ] . [ roofv_y ]         [ y ] . [ nosev_y ]
33067               * [ z ]   [ sidev_z ]         [ z ]   [ roofv_z ]         [ z ]   [ nosev_z ]
33068               *
33069               * When called from part 6 of LL9, XX12 contains the vector [x y z] of the vertex
33070               * we're analysing, and XX16 contains the transposed orientation vectors with
33071               * each of them containing the x, y and z elements of the original vectors, so it
33072               * ------------------------------------------------------------------------------
33073               *
33074               * Returns:
33075               *
33076               * [ x ]   [ sidev_x ]         [ x ]   [ sidev_y ]         [ x ]   [ sidev_z ]
33077               * [ y ] . [ roofv_x ]         [ y ] . [ roofv_y ]         [ y ] . [ roofv_z ]
33078               * [ z ]   [ nosev_x ]         [ z ]   [ nosev_y ]         [ z ]   [ nosev_z ]
33079               *
33080               * ------------------------------------------------------------------------------
33081               *
33082               * Arguments:
33083               *
33084               * XX15(1 0)           The ship (or vertex)'s x-coordinate as (x_sign x_lo)
33085               *
33086               * XX15(3 2)           The ship (or vertex)'s y-coordinate as (y_sign y_lo)
33087               *
33088               * XX15(5 4)           The ship (or vertex)'s z-coordinate as (z_sign z_lo)
33089               *
33090               * XX16 to XX16+5      The scaled sidev (or _x) vector, with:
33091               *
33092               * * x, y, z magnitudes in XX16, XX16+2, XX16+4
33093               *
33094               * * x, y, z signs in XX16+1, XX16+3, XX16+5
33095               *
33096               * XX16+6 to XX16+11   The scaled roofv (or _y) vector, with:
33097               *
33098               * * x, y, z magnitudes in XX16+6, XX16+8, XX16+10
33099               *
33100               * * x, y, z signs in XX16+7, XX16+9, XX16+11
33101               *
33102               * XX16+12 to XX16+17  The scaled nosev (or _z) vector, with:
33103               *
33104               * * x, y, z magnitudes in XX16+12, XX16+14, XX16+16
33105               *
33106               * * x, y, z signs in XX16+13, XX16+15, XX16+17
33107               *
33108               * ------------------------------------------------------------------------------
33109               *
33110               * Returns:
33111               *
33112               * XX12(1 0)           The dot product of [x y z] vector with the sidev (or _x)
33113               * vector, with the sign in XX12+1 and magnitude in XX12
33114               *
33115               * XX12(3 2)           The dot product of [x y z] vector with the roofv (or _y)
33116               * vector, with the sign in XX12+3 and magnitude in XX12+2
33117               *
33118               * XX12(5 4)           The dot product of [x y z] vector with the nosev (or _z)
33119               * vector, with the sign in XX12+5 and magnitude in XX12+4
33120               *
33121               * ******************************************************************************
33122               
33123               LL51:
33124 D3F2 0201  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0, which will contain the offset of the vector
     D3F4 0000     
33125                                                                          ; to use in the calculation, increasing by 6 for each
33126                                                                          ; new vector
33127               
33128 D3F6 0202  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0, which will contain the offset of the
     D3F8 0000     
33129                                                                          ; result bytes in XX12, increasing by 2 for each new
33130                                                                          ; result
33131               
33132               ll51_:
33133 D3FA D020  30        movb @XX15,ra                   ; LDA XX15          ; Set Q = x_lo
     D3FC 0031     
33134 D3FE D800  30        movb ra,@Q                      ; STA Q
     D400 0090     
33135               
33136 D402 D021  34        movb @XX16(rx),ra               ; LDA XX16,X        ; Set A = |sidev_x|
     D404 0009     
33137               
33138 D406 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     D408 4338     
33139 D40A 06A0  32        bl   @jsr                       ;
     D40C FF10     
33140 D40E D800  30        movb ra,@T                      ; STA T             ; = |sidev_x| * x_lo / 256
     D410 00D1     
33141               
33142 D412 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set S to the sign of x_sign * sidev_x
     D414 0032     
33143                      .eor @XX16+1(rx)                ; EOR XX16+1,X
     **** ****     > EOR
0001 D416 D1A1  34        movb @XX16+1(RX),rtmp
     D418 000A     
0002 D41A 2806  18        xor  rtmp,ra
                   < elite.a99
33144 D41C D800  30        movb ra,@S                      ; STA S
     D41E 0092     
33145               
33146 D420 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set Q = y_lo
     D422 0033     
33147 D424 D800  30        movb ra,@Q                      ; STA Q
     D426 0090     
33148               
33149 D428 D021  34        movb @XX16+2(rx),ra             ; LDA XX16+2,X      ; Set A = |sidev_y|
     D42A 000B     
33150               
33151 D42C 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q / 256
     D42E 4338     
33152 D430 06A0  32        bl   @jsr                       ;
     D432 FF10     
33153 D434 D800  30        movb ra,@Q                      ; STA Q             ; = |sidev_y| * y_lo / 256
     D436 0090     
33154               
33155 D438 D020  30        movb @T,ra                      ; LDA T             ; Set R = T
     D43A 00D1     
33156 D43C D800  30        movb ra,@R                      ; STA R             ; = |sidev_x| * x_lo / 256
     D43E 0091     
33157               
33158 D440 D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set A to the sign of y_sign * sidev_y
     D442 0034     
33159                      .eor @XX16+3(rx)                ; EOR XX16+3,X
     **** ****     > EOR
0001 D444 D1A1  34        movb @XX16+3(RX),rtmp
     D446 000C     
0002 D448 2806  18        xor  rtmp,ra
                   < elite.a99
33160               
33161 D44A 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S T) = (S R) + (A Q)
     D44C D39A     
33162 D44E 06A0  32        bl   @jsr                       ;
     D450 FF10     
33163 D452 D800  30        movb ra,@T                      ; STA T             ; = |sidev_x| * x_lo + |sidev_y| * y_lo
     D454 00D1     
33164               
33165 D456 D020  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set Q = z_lo
     D458 0035     
33166 D45A D800  30        movb ra,@Q                      ; STA Q
     D45C 0090     
33167               
33168 D45E D021  34        movb @XX16+4(rx),ra             ; LDA XX16+4,X      ; Set A = |sidev_z|
     D460 000D     
33169               
33170 D462 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q / 256
     D464 4338     
33171 D466 06A0  32        bl   @jsr                       ;
     D468 FF10     
33172 D46A D800  30        movb ra,@Q                      ; STA Q             ; = |sidev_z| * z_lo / 256
     D46C 0090     
33173               
33174 D46E D020  30        movb @T,ra                      ; LDA T             ; Set R = T
     D470 00D1     
33175 D472 D800  30        movb ra,@R                      ; STA R             ; = |sidev_x| * x_lo + |sidev_y| * y_lo
     D474 0091     
33176               
33177 D476 D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A to the sign of z_sign * sidev_z
     D478 0036     
33178                      .eor @XX16+5(rx)                ; EOR XX16+5,X
     **** ****     > EOR
0001 D47A D1A1  34        movb @XX16+5(RX),rtmp
     D47C 000E     
0002 D47E 2806  18        xor  rtmp,ra
                   < elite.a99
33179               
33180 D480 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     D482 D39A     
33181 D484 06A0  32        bl   @jsr                       ;
     D486 FF10     
33182                                                                          ; = |sidev_x| * x_lo + |sidev_y| * y_lo
33183                                                                          ; + |sidev_z| * z_lo
33184               
33185 D488 D880  38        movb ra,@XX12(ry)               ; STA XX12,Y        ; Store the result in XX12+Y(1 0)
     D48A 0037     
33186 D48C D020  30        movb @S,ra                      ; LDA S
     D48E 0092     
33187 D490 D880  38        movb ra,@XX12+1(ry)             ; STA XX12+1,Y
     D492 0038     
33188               
33189 D494 B084  18        ab   rone,ry                    ; INY               ; Set Y = Y + 2
33190 D496 B084  18        ab   rone,ry                    ; INY
33191               
33192 D498 D001  18        movb rx,ra                      ; TXA               ; Set X = X + 6
33193                      .clc                            ; CLC
     **** ****     > CLC
0001 D49A 0A13  18        sla  rzero,1
                   < elite.a99
33194                      .adi (>06*256)                  ; ADC #6
     **** ****     > ADI
0001 D49C 1701  14        jnc  !
0002 D49E B004  18        ab   rone,ra
0003               !:
0004 D4A0 0220  22        ai   ra,(>06*256)
     D4A2 0600     
                   < elite.a99
33195 D4A4 D040  18        movb ra,rx                      ; TAX
33196               
33197 D4A6 0280  22        ci   ra,>11*256                 ; CMP #17           ; If X < 17, loop back to ll51 for the next vector
     D4A8 1100     
33198 D4AA 17A7  14        jnc  ll51_                      ; BCC ll51
33199               
33200 D4AC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D4AE FF1C     
33201               
33202               * ******************************************************************************
33203               *
33204               * Name: LL9 (Part 1 of 12)
33205               * Type: Subroutine
33206               * Category: Drawing ships
33207               * Summary: Draw ship: Check if ship is exploding, check if ship is in front
33208               * Deep dive: Drawing ships
33209               *
33210               * ------------------------------------------------------------------------------
33211               *
33212               * This routine draws the current ship on the screen. This part checks to see if
33213               * the ship is exploding, or if it should start exploding, and if it does it sets
33214               * things up accordingly.
33215               *
33216               * It also does some basic checks to see if we can see the ship, and if not it
33217               * removes it from the screen.
33218               *
33219               * In this code, XX1 is used to point to the current ship's data block at INWK
33220               * (the two labels are interchangeable).
33221               *
33222               * ------------------------------------------------------------------------------
33223               *
33224               * Arguments:
33225               *
33226               * XX1                 XX1 shares its location with INWK, which contains the
33227               * zero-page copy of the data block for this ship from the
33228               * K% workspace
33229               *
33230               * INF                 The address of the data block for this ship in workspace
33231               * K%
33232               *
33233               * XX19(1 0)           XX19(1 0) shares its location with INWK(34 33), which
33234               * contains the ship line heap address pointer
33235               *
33236               * XX0                 The address of the blueprint for this ship
33237               *
33238               * ------------------------------------------------------------------------------
33239               *
33240               * Other entry points:
33241               *
33242               * EE51                Remove the current ship from the screen, called from
33243               * SHPPT before drawing the ship as a point
33244               *
33245               * ******************************************************************************
33246               
33247               LL25:
33248 D4B0 0460  28        b    @PLANET                    ; JMP PLANET        ; Jump to the PLANET routine, returning from the
     D4B2 B1EE     
33249                                                                          ; subroutine using a tail call
33250               
33251               LL9:
33252 D4B4 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is negative then this indicates a
     D4B6 009B     
33253 D4B8 11FB  14        jlt  LL25                       ; BMI LL25          ; planet or sun, so jump to PLANET via LL25 above
33254               
33255 D4BA 0200  20        li   ra,>1f*256                 ; LDA #31           ; Set XX4 = 31 to store the ship's distance for later
     D4BC 1F00     
33256 D4BE D800  30        movb ra,@XX4                    ; STA XX4           ; comparison with the visibility distance. We will
     D4C0 00A7     
33257                                                                          ; update this value below with the actual ship's
33258                                                                          ; distance if it turns out to be visible on-screen
33259               
33260 D4C2 0200  20        li   ra,>20*256                 ; LDA #%00100000    ; If bit 5 of the ship's byte #31 is set, then the ship
     D4C4 2000     
33261                      .bit @XX1+31                    ; BIT XX1+31        ; is currently exploding, so jump down to EE28
     **** ****     > BIT
0001 D4C6 D1A0  30        movb @XX1+31,rtmp
     D4C8 0072     
0002 D4CA 0546  14        inv  rtmp
0003 D4CC D1C4  18        movb rone,rtmp2
0004 D4CE 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
33262 D4D0 164B  14        jne  EE28                       ; BNE EE28
33263               
33264 D4D2 154A  14        jgt  EE28                       ; BPL EE28          ; If bit 7 of the ship's byte #31 is clear then the ship
33265                                                                          ; has not just been killed, so jump down to EE28
33266               
33267                                                                          ; Otherwise bit 5 is clear and bit 7 is set, so the ship
33268                                                                          ; is not yet exploding but it has been killed, so we
33269                                                                          ; need to start an explosion
33270               
33271 D4D4 F020  30        socb @XX1+31,ra                 ; ORA XX1+31        ; Clear bits 6 and 7 of the ship's byte #31, to stop the
     D4D6 0072     
33272 D4D8 0240  22        andi ra,>3f*256                 ; AND #%00111111    ; ship from firing its laser and to mark it as no longer
     D4DA 3F00     
33273 D4DC D800  30        movb ra,@XX1+31                 ; STA XX1+31        ; having just been killed
     D4DE 0072     
33274               
33275 D4E0 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the ship's acceleration in byte #31 to 0, updating
     D4E2 0000     
33276 D4E4 0202  20        li   ry,>1c*256                 ; LDY #28           ; the byte in the workspace K% data block so we don't
     D4E6 1C00     
33277                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; have to copy it back from INWK later
     **** ****     > ST_IND_Y_IDX
0001 D4E8 D820  50        movb @INF,@rtmplb
     D4EA 0020     
     D4EC 2079     
0002 D4EE D1A0  30        movb @INF+1,rtmp
     D4F0 0021     
0003 D4F2 A182  18        a    ry,rtmp
0004 D4F4 D580  30        movb RA,*rtmp
                   < elite.a99
33278               
33279 D4F6 0202  20        li   ry,>1e*256                 ; LDY #30           ; Set the ship's pitch counter in byte #30 to 0, to stop
     D4F8 1E00     
33280                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; the ship from pitching
     **** ****     > ST_IND_Y_IDX
0001 D4FA D820  50        movb @INF,@rtmplb
     D4FC 0020     
     D4FE 2079     
0002 D500 D1A0  30        movb @INF+1,rtmp
     D502 0021     
0003 D504 A182  18        a    ry,rtmp
0004 D506 D580  30        movb RA,*rtmp
                   < elite.a99
33281               
33282 D508 0206  20        li   rtmp,EE51                  ; JSR EE51          ; Call EE51 to remove the ship from the screen
     D50A D588     
33283 D50C 06A0  32        bl   @jsr                       ;
     D50E FF10     
33284               
33285                                                                          ; We now need to set up a new explosion cloud. We
33286                                                                          ; initialise it with a size of 18 (which gets increased
33287                                                                          ; by 4 every time the cloud gets redrawn), and the
33288                                                                          ; explosion count (i.e. the number of particles in the
33289                                                                          ; explosion), which go into bytes 1 and 2 of the ship
33290                                                                          ; line heap. See DOEXP for more details of explosion
33291                                                                          ; clouds
33292               
33293 D510 0202  20        li   ry,>01*256                 ; LDY #1            ; Set byte #1 of the ship line heap to 18, the initial
     D512 0100     
33294 D514 0200  20        li   ra,>12*256                 ; LDA #18           ; size of the explosion cloud
     D516 1200     
33295                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 D518 D820  50        movb @XX19,@rtmplb
     D51A 0074     
     D51C 2079     
0002 D51E D1A0  30        movb @XX19+1,rtmp
     D520 0075     
0003 D522 A182  18        a    ry,rtmp
0004 D524 D580  30        movb RA,*rtmp
                   < elite.a99
33296               
33297 D526 0202  20        li   ry,>07*256                 ; LDY #7            ; Fetch byte #7 from the ship's blueprint, which
     D528 0700     
33298                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; determines the explosion count (i.e. the number of
     **** ****     > LD_IND_Y_IDX
0001 D52A D820  50        movb @XX0,@rtmplb
     D52C 001E     
     D52E 2079     
0002 D530 D1A0  30        movb @XX0+1,rtmp
     D532 001F     
0003 D534 A182  18        a    ry,rtmp
0004 D536 D016  26        movb *rtmp,RA
                   < elite.a99
33299 D538 0202  20        li   ry,>02*256                 ; LDY #2            ; vertices used as origins for explosion clouds), and
     D53A 0200     
33300                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; store it in byte #2 of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 D53C D820  50        movb @XX19,@rtmplb
     D53E 0074     
     D540 2079     
0002 D542 D1A0  30        movb @XX19+1,rtmp
     D544 0075     
0003 D546 A182  18        a    ry,rtmp
0004 D548 D580  30        movb RA,*rtmp
                   < elite.a99
33301               
33302               * LDA XX1+32             \ These instructions are commented out in the original
33303               * AND #&7F               \ source
33304               
33305                                                                          ; The following loop sets bytes 3-6 of the of the ship
33306                                                                          ; line heap to random numbers
33307               
33308               EE55:
33309 D54A B084  18        ab   rone,ry                    ; INY               ; Increment Y (so the loop starts at 3)
33310               
33311 D54C 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     D54E C07C     
33312 D550 06A0  32        bl   @jsr                       ;
     D552 FF10     
33313               
33314                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store A in the Y-th byte of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 D554 D820  50        movb @XX19,@rtmplb
     D556 0074     
     D558 2079     
0002 D55A D1A0  30        movb @XX19+1,rtmp
     D55C 0075     
0003 D55E A182  18        a    ry,rtmp
0004 D560 D580  30        movb RA,*rtmp
                   < elite.a99
33315               
33316 D562 0282  22        ci   ry,>06*256                 ; CPY #6            ; Loop back until we have randomised the 6th byte
     D564 0600     
33317 D566 16F1  14        jne  EE55                       ; BNE EE55
33318               
33319               EE28:
33320 D568 D020  30        movb @XX1+8,ra                  ; LDA XX1+8         ; Set A = z_sign
     D56A 005B     
33321               
33322               EE49:
33323 D56C 151E  14        jgt  LL10                       ; BPL LL10          ; If A is positive, i.e. the ship is in front of us,
33324                                                                          ; jump down to LL10
33325               
33326               LL14:
33327                                                                          ; The following removes the ship from the screen by
33328                                                                          ; redrawing it (or, if it is exploding, by redrawing the
33329                                                                          ; explosion cloud). We call it when the ship is no
33330                                                                          ; longer on-screen, is too far away to be fully drawn,
33331                                                                          ; and so on
33332 D56E D020  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     D570 0072     
33333 D572 0240  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE51
     D574 2000     
33334 D576 1308  14        jeq  EE51                       ; BEQ EE51          ; to redraw its wireframe
33335               
33336 D578 D020  30        movb @XX1+31,ra                 ; LDA XX1+31        ; The ship is exploding, so clear bit 3 of the ship's
     D57A 0072     
33337 D57C 0240  22        andi ra,>f7*256                 ; AND #%11110111    ; byte #31 to denote that the ship is no longer being
     D57E F700     
33338 D580 D800  30        movb ra,@XX1+31                 ; STA XX1+31        ; drawn on-screen
     D582 0072     
33339               
33340 D584 0460  28        b    @DOEXP                     ; JMP DOEXP         ; Jump to DOEXP to display the explosion cloud, which
     D586 A8A0     
33341                                                                          ; will remove it from the screen, returning from the
33342                                                                          ; subroutine using a tail call
33343               
33344               EE51:
33345 D588 0200  20        li   ra,>08*256                 ; LDA #%00001000    ; If bit 3 of the ship's byte #31 is clear, then there
     D58A 0800     
33346                      .bit @XX1+31                    ; BIT XX1+31        ; is already nothing being shown for this ship, so
     **** ****     > BIT
0001 D58C D1A0  30        movb @XX1+31,rtmp
     D58E 0072     
0002 D590 0546  14        inv  rtmp
0003 D592 D1C4  18        movb rone,rtmp2
0004 D594 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
33347 D596 1308  14        jeq  LL10-1                     ; BEQ LL10-1        ; return from the subroutine (as LL10-1 contains an RTS)
33348               
33349                      .eor @XX1+31                    ; EOR XX1+31        ; Otherwise flip bit 3 of byte #31 and store it (which
     **** ****     > EOR
0001 D598 D1A0  30        movb @XX1+31,rtmp
     D59A 0072     
0002 D59C 2806  18        xor  rtmp,ra
                   < elite.a99
33350 D59E D800  30        movb ra,@XX1+31                 ; STA XX1+31        ; clears bit 3 as we know it was set before the EOR), so
     D5A0 0072     
33351                                                                          ; this sets this ship as no longer being drawn on-screen
33352               
33353 D5A2 0460  28        b    @LL155                     ; JMP LL155         ; Jump to LL155 to draw the ship, which removes it from
     D5A4 E25C     
33354                                                                          ; the screen, returning from the subroutine using a
33355                                                                          ; tail call
33356               
33357               * .LL24                  \ This label is commented out in the original source,
33358                                                                          ; and was presumably used to label the RTS which is
33359                                                                          ; actually called by LL10-1 above, not LL24
33360               
33361 D5A6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D5A8 FF1C     
33362               
33363               * ******************************************************************************
33364               *
33365               * Name: LL9 (Part 2 of 12)
33366               * Type: Subroutine
33367               * Category: Drawing ships
33368               * Summary: Draw ship: Check if ship is in field of view, close enough to draw
33369               * Deep dive: Drawing ships
33370               *
33371               * ------------------------------------------------------------------------------
33372               *
33373               * This part checks whether the ship is in our field of view, and whether it is
33374               * close enough to be fully drawn (if not, we jump to SHPPT to draw it as a dot).
33375               *
33376               * ------------------------------------------------------------------------------
33377               *
33378               * Other entry points:
33379               *
33380               * LL10-1              Contains an RTS
33381               *
33382               * ******************************************************************************
33383               
33384               LL10:
33385 D5AA D020  30        movb @XX1+7,ra                  ; LDA XX1+7         ; Set A = z_hi
     D5AC 005A     
33386               
33387 D5AE 0280  22        ci   ra,>c0*256                 ; CMP #192          ; If A >= 192 then the ship is a long way away, so jump
     D5B0 C000     
33388 D5B2 18DD  14        joc  LL14                       ; BCS LL14          ; to LL14 to remove the ship from the screen
33389               
33390 D5B4 D020  30        movb @XX1,ra                    ; LDA XX1           ; If x_lo >= z_lo, set the C flag, otherwise clear it
     D5B6 0053     
33391 D5B8 9020  30        cb   @XX1+6,ra                  ; CMP XX1+6
     D5BA 0059     
33392               
33393 D5BC D020  30        movb @XX1+1,ra                  ; LDA XX1+1         ; Set A = x_hi - z_hi using the carry from the low
     D5BE 0054     
33394                      .sbc @XX1+7,ra                  ; SBC XX1+7         ; bytes, which sets the C flag as if we had done a full
     **** ****     > SBC
0001 D5C0 1801  14        joc  !
0002 D5C2 7004  18        sb   rone,ra
0003               !:
0004 D5C4 7020  30        sb   @XX1+7,ra
     D5C6 005A     
                   < elite.a99
33395                                                                          ; two-byte subtraction (x_hi x_lo) - (z_hi z_lo)
33396               
33397 D5C8 18D2  14        joc  LL14                       ; BCS LL14          ; If the C flag is set then x >= z, so the ship is
33398                                                                          ; further to the side than it is in front of us, so it's
33399                                                                          ; outside our viewing angle of 45 degrees, and we jump
33400                                                                          ; to LL14 to remove it from the screen
33401               
33402 D5CA D020  30        movb @XX1+3,ra                  ; LDA XX1+3         ; If y_lo >= z_lo, set the C flag, otherwise clear it
     D5CC 0056     
33403 D5CE 9020  30        cb   @XX1+6,ra                  ; CMP XX1+6
     D5D0 0059     
33404               
33405 D5D2 D020  30        movb @XX1+4,ra                  ; LDA XX1+4         ; Set A = y_hi - z_hi using the carry from the low
     D5D4 0057     
33406                      .sbc @XX1+7,ra                  ; SBC XX1+7         ; bytes, which sets the C flag as if we had done a full
     **** ****     > SBC
0001 D5D6 1801  14        joc  !
0002 D5D8 7004  18        sb   rone,ra
0003               !:
0004 D5DA 7020  30        sb   @XX1+7,ra
     D5DC 005A     
                   < elite.a99
33407                                                                          ; two-byte subtraction (y_hi y_lo) - (z_hi z_lo)
33408               
33409 D5DE 18C7  14        joc  LL14                       ; BCS LL14          ; If the C flag is set then y >= z, so the ship is
33410                                                                          ; further above us than it is in front of us, so it's
33411                                                                          ; outside our viewing angle of 45 degrees, and we jump
33412                                                                          ; to LL14 to remove it from the screen
33413               
33414 D5E0 0202  20        li   ry,>06*256                 ; LDY #6            ; Fetch byte #6 from the ship's blueprint into X, which
     D5E2 0600     
33415                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; is the number * 4 of the vertex used for the ship's
     **** ****     > LD_IND_Y_IDX
0001 D5E4 D820  50        movb @XX0,@rtmplb
     D5E6 001E     
     D5E8 2079     
0002 D5EA D1A0  30        movb @XX0+1,rtmp
     D5EC 001F     
0003 D5EE A182  18        a    ry,rtmp
0004 D5F0 D016  26        movb *rtmp,RA
                   < elite.a99
33416 D5F2 D040  18        movb ra,rx                      ; TAX               ; laser
33417               
33418 D5F4 0200  20        li   ra,>ff*256                 ; LDA #255          ; Set bytes X and X+1 of the XX3 heap to 255. We're
     D5F6 FF00     
33419 D5F8 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; going to use XX3 to store the screen coordinates of
     D5FA 0100     
33420 D5FC D840  38        movb ra,@XX3+1(rx)              ; STA XX3+1,X       ; all the visible vertices of this ship, so setting the
     D5FE 0101     
33421                                                                          ; laser vertex to 255 means that if we don't update this
33422                                                                          ; vertex with its screen coordinates in parts 6 and 7,
33423                                                                          ; this vertex's entry in the XX3 heap will still be 255,
33424                                                                          ; which we can check in part 9 to see if the laser
33425                                                                          ; vertex is visible (and therefore whether we should
33426                                                                          ; draw laser lines if the ship is firing on us)
33427               
33428 D600 D020  30        movb @XX1+6,ra                  ; LDA XX1+6         ; Set (A T) = (z_hi z_lo)
     D602 0059     
33429 D604 D800  30        movb ra,@T                      ; STA T
     D606 00D1     
33430 D608 D020  30        movb @XX1+7,ra                  ; LDA XX1+7
     D60A 005A     
33431               
33432 D60C 0910  18        srl  ra,1                       ; LSR A             ; Set (A T) = (A T) / 8
33433 D60E 0208  20        li   rarg1,T                    ; ROR T
     D610 00D1     
33434 D612 06A0  32        bl   @ror                       ;
     D614 FF62     
33435 D616 0910  18        srl  ra,1                       ; LSR A
33436 D618 0208  20        li   rarg1,T                    ; ROR T
     D61A 00D1     
33437 D61C 06A0  32        bl   @ror                       ;
     D61E FF62     
33438 D620 0910  18        srl  ra,1                       ; LSR A
33439 D622 0208  20        li   rarg1,T                    ; ROR T
     D624 00D1     
33440 D626 06A0  32        bl   @ror                       ;
     D628 FF62     
33441               
33442 D62A 0910  18        srl  ra,1                       ; LSR A             ; If A >> 4 is non-zero, i.e. z_hi >= 16, jump to LL13
33443 D62C 160A  14        jne  LL13                       ; BNE LL13          ; as the ship is possibly far away enough to be shown as
33444                                                                          ; a dot
33445               
33446 D62E D020  30        movb @T,ra                      ; LDA T             ; Otherwise the C flag contains the previous bit 0 of A,
     D630 00D1     
33447 D632 06A0  32        bl   @rora                      ; ROR A             ; which could have been set, so rotate A right four
     D634 FF4A     
33448 D636 0910  18        srl  ra,1                       ; LSR A             ; times so it's in the form %000xxxxx, i.e. z_hi reduced
33449 D638 0910  18        srl  ra,1                       ; LSR A             ; to a maximum value of 31
33450 D63A 0910  18        srl  ra,1                       ; LSR A
33451               
33452 D63C D800  30        movb ra,@XX4                    ; STA XX4           ; Store A in XX4, which is now the distance of the ship
     D63E 00A7     
33453                                                                          ; we can use for visibility testing
33454               
33455 D640 1515  14        jgt  LL17                       ; BPL LL17          ; Jump down to LL17 (this BPL is effectively a JMP as we
33456                                                                          ; know bit 7 of A is definitely clear)
33457               
33458               LL13:
33459                                                                          ; If we get here then the ship is possibly far enough
33460                                                                          ; away to be shown as a dot
33461 D642 0202  20        li   ry,>0d*256                 ; LDY #13           ; Fetch byte #13 from the ship's blueprint, which gives
     D644 0D00     
33462                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the ship's visibility distance, beyond which we show
     **** ****     > LD_IND_Y_IDX
0001 D646 D820  50        movb @XX0,@rtmplb
     D648 001E     
     D64A 2079     
0002 D64C D1A0  30        movb @XX0+1,rtmp
     D64E 001F     
0003 D650 A182  18        a    ry,rtmp
0004 D652 D016  26        movb *rtmp,RA
                   < elite.a99
33463                                                                          ; the ship as a dot
33464               
33465 D654 9020  30        cb   @XX1+7,ra                  ; CMP XX1+7         ; If z_hi <= the visibility distance, skip to LL17 to
     D656 005A     
33466 D658 1809  14        joc  LL17                       ; BCS LL17          ; draw the ship fully, rather than as a dot, as it is
33467                                                                          ; closer than the visibility distance
33468               
33469 D65A 0200  20        li   ra,>20*256                 ; LDA #%00100000    ; If bit 5 of the ship's byte #31 is set, then the
     D65C 2000     
33470                      .and @XX1+31                    ; AND XX1+31        ; ship is currently exploding, so skip to LL17 to draw
     **** ****     > AND
0001 D65E D1A0  30        movb @XX1+31,rtmp
     D660 0072     
0002 D662 0546  14        inv  rtmp
0003 D664 5006  18        szcb rtmp,ra
                   < elite.a99
33471 D666 1602  14        jne  LL17                       ; BNE LL17          ; the ship's explosion cloud
33472               
33473 D668 0460  28        b    @SHPPT                     ; JMP SHPPT         ; Otherwise jump to SHPPT to draw the ship as a dot,
     D66A D1EE     
33474                                                                          ; returning from the subroutine using a tail call
33475               
33476               * ******************************************************************************
33477               *
33478               * Name: LL9 (Part 3 of 12)
33479               * Type: Subroutine
33480               * Category: Drawing ships
33481               * Summary: Draw ship: Set up orientation vector, ship coordinate variables
33482               * Deep dive: Drawing ships
33483               *
33484               * ------------------------------------------------------------------------------
33485               *
33486               * This part sets up the following variable blocks:
33487               *
33488               * * XX16 contains the orientation vectors, divided to normalise them
33489               *
33490               * * XX18 contains the ship's x, y and z coordinates in space
33491               *
33492               * ******************************************************************************
33493               
33494               LL17:
33495 D66C 0201  20        li   rx,>05*256                 ; LDX #5            ; First we copy the three orientation vectors into XX16,
     D66E 0500     
33496                                                                          ; so set up a counter in X for the 6 bytes in each
33497                                                                          ; vector
33498               
33499               LL15:
33500 D670 D021  34        movb @XX1+21(rx),ra             ; LDA XX1+21,X      ; Copy the X-th byte of sidev to the X-th byte of XX16
     D672 0068     
33501 D674 D840  38        movb ra,@XX16(rx)               ; STA XX16,X
     D676 0009     
33502               
33503 D678 D021  34        movb @XX1+15(rx),ra             ; LDA XX1+15,X      ; Copy the X-th byte of roofv to XX16+6 to the X-th byte
     D67A 0062     
33504 D67C D840  38        movb ra,@XX16+6(rx)             ; STA XX16+6,X      ; of XX16+6
     D67E 000F     
33505               
33506 D680 D021  34        movb @XX1+9(rx),ra              ; LDA XX1+9,X       ; Copy the X-th byte of nosev to XX16+12 to the X-th
     D682 005C     
33507 D684 D840  38        movb ra,@XX16+12(rx)            ; STA XX16+12,X     ; byte of XX16+12
     D686 0015     
33508               
33509 D688 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
33510               
33511 D68A 15F2  14        jgt  LL15                       ; BPL LL15          ; Loop back to copy the next byte of each vector, until
33512                                                                          ; we have the following:
33513                                                                          ;
33514                                                                          ; * XX16(1 0) = sidev_x
33515                                                                          ; * XX16(3 2) = sidev_y
33516                                                                          ; * XX16(5 4) = sidev_z
33517                                                                          ;
33518                                                                          ; * XX16(7 6) = roofv_x
33519                                                                          ; * XX16(9 8) = roofv_y
33520                                                                          ; * XX16(11 10) = roofv_z
33521                                                                          ;
33522                                                                          ; * XX16(13 12) = nosev_x
33523                                                                          ; * XX16(15 14) = nosev_y
33524                                                                          ; * XX16(17 16) = nosev_z
33525               
33526 D68C 0200  20        li   ra,>c5*256                 ; LDA #197          ; Set Q = 197
     D68E C500     
33527 D690 D800  30        movb ra,@Q                      ; STA Q
     D692 0090     
33528               
33529 D694 0202  20        li   ry,>10*256                 ; LDY #16           ; Set Y to be a counter that counts down by 2 each time,
     D696 1000     
33530                                                                          ; starting with 16, then 14, 12 and so on. We use this
33531                                                                          ; to work through each of the coordinates in each of the
33532                                                                          ; orientation vectors
33533               
33534               LL21:
33535 D698 D022  34        movb @XX16(ry),ra               ; LDA XX16,Y        ; Set A = the low byte of the vector coordinate, e.g.
     D69A 0009     
33536                                                                          ; nosev_z_lo when Y = 16
33537               
33538                      .asla                           ; ASL A             ; Shift bit 7 into the C flag
     **** ****     > ASLA
0001 D69C 0240  22        andi ra,>ff00
     D69E FF00     
0002 D6A0 0A10  18        sla  ra,1
                   < elite.a99
33539               
33540 D6A2 D022  34        movb @XX16+1(ry),ra             ; LDA XX16+1,Y      ; Set A = the high byte of the vector coordinate, e.g.
     D6A4 000A     
33541                                                                          ; nosev_z_hi when Y = 16
33542               
33543 D6A6 06A0  32        bl   @rola                      ; ROL A             ; Rotate A left, incorporating the C flag, so A now
     D6A8 FF26     
33544                                                                          ; contains the original high byte, doubled, and without
33545                                                                          ; a sign bit, e.g. A = |nosev_z_hi| * 2
33546               
33547 D6AA 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     D6AC D344     
33548 D6AE 06A0  32        bl   @jsr                       ;
     D6B0 FF10     
33549                                                                          ;
33550                                                                          ; R = 256 * A / Q
33551                                                                          ;
33552                                                                          ; so, for nosev, this would be:
33553                                                                          ;
33554                                                                          ; R = 256 * |nosev_z_hi| * 2 / 197
33555                                                                          ; = 2.6 * |nosev_z_hi|
33556               
33557 D6B2 D060  30        movb @R,rx                      ; LDX R             ; Store R in the low byte's location, so we can keep the
     D6B4 0091     
33558 D6B6 D881  38        movb rx,@XX16(ry)               ; STX XX16,Y        ; old, unscaled high byte intact for the sign
     D6B8 0009     
33559               
33560 D6BA 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter twice
33561 D6BC 7084  18        sb   rone,ry                    ; DEY
33562               
33563 D6BE 15EC  14        jgt  LL21                       ; BPL LL21          ; Loop back for the next vector coordinate until we have
33564                                                                          ; divided them all
33565               
33566                                                                          ; By this point, the vectors have been turned into
33567                                                                          ; scaled magnitudes, so we have the following:
33568                                                                          ;
33569                                                                          ; * XX16   = scaled |sidev_x|
33570                                                                          ; * XX16+2 = scaled |sidev_y|
33571                                                                          ; * XX16+4 = scaled |sidev_z|
33572                                                                          ;
33573                                                                          ; * XX16+6  = scaled |roofv_x|
33574                                                                          ; * XX16+8  = scaled |roofv_y|
33575                                                                          ; * XX16+10 = scaled |roofv_z|
33576                                                                          ;
33577                                                                          ; * XX16+12 = scaled |nosev_x|
33578                                                                          ; * XX16+14 = scaled |nosev_y|
33579                                                                          ; * XX16+16 = scaled |nosev_z|
33580               
33581 D6C0 0201  20        li   rx,>08*256                 ; LDX #8            ; Next we copy the ship's coordinates into XX18, so set
     D6C2 0800     
33582                                                                          ; up a counter in X for 9 bytes
33583               
33584               ll91_:
33585 D6C4 D021  34        movb @XX1(rx),ra                ; LDA XX1,X         ; Copy the X-th byte from XX1 to XX18
     D6C6 0053     
33586 D6C8 D840  38        movb ra,@XX18(rx)               ; STA XX18,X
     D6CA 007E     
33587               
33588 D6CC 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
33589               
33590 D6CE 15FA  14        jgt  ll91_                      ; BPL ll91          ; Loop back for the next byte until we have copied all
33591                                                                          ; three coordinates
33592               
33593                                                                          ; So we now have the following:
33594                                                                          ;
33595                                                                          ; * XX18(2 1 0) = (x_sign x_hi x_lo)
33596                                                                          ;
33597                                                                          ; * XX18(5 4 3) = (y_sign y_hi y_lo)
33598                                                                          ;
33599                                                                          ; * XX18(8 7 6) = (z_sign z_hi z_lo)
33600               
33601 D6D0 0200  20        li   ra,>ff*256                 ; LDA #255          ; Set the 15th byte of XX2 to 255, so that face 15 is
     D6D2 FF00     
33602 D6D4 D800  30        movb ra,@XX2+15                 ; STA XX2+15        ; always visible. No ship definitions actually have this
     D6D6 00E1     
33603                                                                          ; number of faces, but this allows us to force a vertex
33604                                                                          ; to always be visible by associating it with face 15
33605                                                                          ; (see the ship blueprints for the Cobra Mk III at
33606                                                                          ; SHIP_COBRA_MK_3 and the asteroid at SHIP_ASTEROID for
33607                                                                          ; examples of vertices that are associated with face 15)
33608               
33609 D6D8 0202  20        li   ry,>0c*256                 ; LDY #12           ; Set Y = 12 to point to the ship blueprint byte #12,
     D6DA 0C00     
33610               
33611 D6DC D020  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     D6DE 0072     
33612 D6E0 0240  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE29
     D6E2 2000     
33613 D6E4 1315  14        jeq  EE29                       ; BEQ EE29          ; to skip the following
33614               
33615                                                                          ; Otherwise we fall through to set up the visibility
33616                                                                          ; block for an exploding ship
33617               
33618               * ******************************************************************************
33619               *
33620               * Name: LL9 (Part 4 of 12)
33621               * Type: Subroutine
33622               * Category: Drawing ships
33623               * Summary: Draw ship: Set visibility for exploding ship (all faces visible)
33624               * Deep dive: Drawing ships
33625               *
33626               * ------------------------------------------------------------------------------
33627               *
33628               * This part sets up the visibility block in XX2 for a ship that is exploding.
33629               *
33630               * The XX2 block consists of one byte for each face in the ship's blueprint,
33631               * which holds the visibility of that face. Because the ship is exploding, we
33632               * want to set all the faces to be visible. A value of 255 in the visibility
33633               * table means the face is visible, so the following code sets each face to 255
33634               * and then skips over the face visibility calculations that we would apply to a
33635               * non-exploding ship.
33636               *
33637               * ******************************************************************************
33638               
33639                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; Fetch byte #12 of the ship's blueprint, which contains
     **** ****     > LD_IND_Y_IDX
0001 D6E6 D820  50        movb @XX0,@rtmplb
     D6E8 001E     
     D6EA 2079     
0002 D6EC D1A0  30        movb @XX0+1,rtmp
     D6EE 001F     
0003 D6F0 A182  18        a    ry,rtmp
0004 D6F2 D016  26        movb *rtmp,RA
                   < elite.a99
33640                                                                          ; the number of faces * 4
33641               
33642 D6F4 0910  18        srl  ra,1                       ; LSR A             ; Set X = A / 4
33643 D6F6 0910  18        srl  ra,1                       ; LSR A             ; = the number of faces
33644 D6F8 D040  18        movb ra,rx                      ; TAX
33645               
33646 D6FA 0200  20        li   ra,>ff*256                 ; LDA #255          ; Set A = 255
     D6FC FF00     
33647               
33648               EE30:
33649 D6FE D840  38        movb ra,@XX2(rx)                ; STA XX2,X         ; Set the X-th byte of XX2 to 255
     D700 00D2     
33650               
33651 D702 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
33652               
33653 D704 15FC  14        jgt  EE30                       ; BPL EE30          ; Loop back for the next byte until there is one byte
33654                                                                          ; set to 255 for each face
33655               
33656 D706 B044  18        ab   rone,rx                    ; INX               ; Set XX4 = 0 for the distance value we use to test
33657 D708 D801  30        movb rx,@XX4                    ; STX XX4           ; for visibility, so we always shows everything
     D70A 00A7     
33658               
33659               LL41:
33660 D70C 0460  28        b    @LL42                      ; JMP LL42          ; Jump to LL42 to skip the face visibility calculations
     D70E DA94     
33661                                                                          ; as we don't need to do them now we've set up the XX2
33662                                                                          ; block for the explosion
33663               
33664               * ******************************************************************************
33665               *
33666               * Name: LL9 (Part 5 of 12)
33667               * Type: Subroutine
33668               * Category: Drawing ships
33669               * Summary: Draw ship: Calculate the visibility of each of the ship's faces
33670               * Deep dive: Drawing ships
33671               * Back-face culling
33672               *
33673               * ******************************************************************************
33674               
33675               EE29:
33676                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; We set Y to 12 above before jumping down to EE29, so
     **** ****     > LD_IND_Y_IDX
0001 D710 D820  50        movb @XX0,@rtmplb
     D712 001E     
     D714 2079     
0002 D716 D1A0  30        movb @XX0+1,rtmp
     D718 001F     
0003 D71A A182  18        a    ry,rtmp
0004 D71C D016  26        movb *rtmp,RA
                   < elite.a99
33677                                                                          ; this fetches byte #12 of the ship's blueprint, which
33678                                                                          ; contains the number of faces * 4
33679               
33680 D71E 13F6  14        jeq  LL41                       ; BEQ LL41          ; If there are no faces in this ship, jump to LL42 (via
33681                                                                          ; LL41) to skip the face visibility calculations
33682               
33683 D720 D800  30        movb ra,@XX20                   ; STA XX20          ; Set A = the number of faces * 4
     D722 00A8     
33684               
33685 D724 0202  20        li   ry,>12*256                 ; LDY #18           ; Fetch byte #18 of the ship's blueprint, which contains
     D726 1200     
33686                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the factor by which we scale the face normals, into X
     **** ****     > LD_IND_Y_IDX
0001 D728 D820  50        movb @XX0,@rtmplb
     D72A 001E     
     D72C 2079     
0002 D72E D1A0  30        movb @XX0+1,rtmp
     D730 001F     
0003 D732 A182  18        a    ry,rtmp
0004 D734 D016  26        movb *rtmp,RA
                   < elite.a99
33687 D736 D040  18        movb ra,rx                      ; TAX
33688               
33689 D738 D020  30        movb @XX18+7,ra                 ; LDA XX18+7        ; Set A = z_hi
     D73A 0085     
33690               
33691               LL90:
33692 D73C D080  18        movb ra,ry                      ; TAY               ; Set Y = z_hi
33693               
33694 D73E 131A  14        jeq  LL91                       ; BEQ LL91          ; If z_hi = 0 then jump to LL91
33695               
33696                                                                          ; The following is a loop that jumps back to LL90+3,
33697                                                                          ; i.e. here. LL90 is only used for this loop, so it's a
33698                                                                          ; bit of a strange use of the label here
33699               
33700 D740 B044  18        ab   rone,rx                    ; INX               ; Increment the scale factor in X
33701               
33702                      .lsr @XX18+4                    ; LSR XX18+4        ; Divide (y_hi y_lo) by 2
     **** ****     > LSR
0001 D742 D1A0  30        movb @XX18+4,rtmp
     D744 0082     
0002 D746 0916  18        srl  rtmp,1
0003 D748 D806  30        movb rtmp,@XX18+4
     D74A 0082     
                   < elite.a99
33703 D74C 0208  20        li   rarg1,XX18+3               ; ROR XX18+3
     D74E 0081     
33704 D750 06A0  32        bl   @ror                       ;
     D752 FF62     
33705               
33706                      .lsr @XX18+1                    ; LSR XX18+1        ; Divide (x_hi x_lo) by 2
     **** ****     > LSR
0001 D754 D1A0  30        movb @XX18+1,rtmp
     D756 007F     
0002 D758 0916  18        srl  rtmp,1
0003 D75A D806  30        movb rtmp,@XX18+1
     D75C 007F     
                   < elite.a99
33707 D75E 0208  20        li   rarg1,XX18                 ; ROR XX18
     D760 007E     
33708 D762 06A0  32        bl   @ror                       ;
     D764 FF62     
33709               
33710 D766 0910  18        srl  ra,1                       ; LSR A             ; Divide (z_hi z_lo) by 2 (as A contains z_hi)
33711 D768 0208  20        li   rarg1,XX18+6               ; ROR XX18+6
     D76A 0084     
33712 D76C 06A0  32        bl   @ror                       ;
     D76E FF62     
33713               
33714 D770 D080  18        movb ra,ry                      ; TAY               ; Set Y = z_hi
33715               
33716 D772 16E5  14        jne  LL90+3                     ; BNE LL90+3        ; If Y is non-zero, loop back to LL90+3 to divide the
33717                                                                          ; three coordinates until z_hi is 0
33718               
33719               LL91:
33720                                                                          ; By this point z_hi is 0 and X contains the number of
33721                                                                          ; right shifts we had to do, plus the scale factor from
33722                                                                          ; the blueprint
33723 D774 D801  30        movb rx,@XX17                   ; STX XX17          ; Store the updated scale factor in XX17
     D776 0095     
33724               
33725 D778 D020  30        movb @XX18+8,ra                 ; LDA XX18+8        ; Set XX15+5 = z_sign
     D77A 0086     
33726 D77C D800  30        movb ra,@XX15+5                 ; STA XX15+5
     D77E 0036     
33727               
33728 D780 D020  30        movb @XX18,ra                   ; LDA XX18          ; Set XX15(1 0) = (x_sign x_lo)
     D782 007E     
33729 D784 D800  30        movb ra,@XX15                   ; STA XX15
     D786 0031     
33730 D788 D020  30        movb @XX18+2,ra                 ; LDA XX18+2
     D78A 0080     
33731 D78C D800  30        movb ra,@XX15+1                 ; STA XX15+1
     D78E 0032     
33732               
33733 D790 D020  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set XX15(3 2) = (y_sign y_lo)
     D792 0081     
33734 D794 D800  30        movb ra,@XX15+2                 ; STA XX15+2
     D796 0033     
33735 D798 D020  30        movb @XX18+5,ra                 ; LDA XX18+5
     D79A 0083     
33736 D79C D800  30        movb ra,@XX15+3                 ; STA XX15+3
     D79E 0034     
33737               
33738 D7A0 D020  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set XX15+4 = z_lo, so now XX15(5 4) = (z_sign z_lo)
     D7A2 0084     
33739 D7A4 D800  30        movb ra,@XX15+4                 ; STA XX15+4
     D7A6 0035     
33740               
33741 D7A8 0206  20        li   rtmp,LL51                  ; JSR LL51          ; Call LL51 to set XX12 to the dot products of XX15 and
     D7AA D3F2     
33742 D7AC 06A0  32        bl   @jsr                       ;
     D7AE FF10     
33743                                                                          ; XX16, which we'll call dot_sidev, dot_roofv and
33744                                                                          ; dot_nosev:
33745                                                                          ;
33746                                                                          ; XX12(1 0) = [x y z] . sidev
33747                                                                          ; = (dot_sidev_sign dot_sidev_lo)
33748                                                                          ; = dot_sidev
33749                                                                          ;
33750                                                                          ; XX12(3 2) = [x y z] . roofv
33751                                                                          ; = (dot_roofv_sign dot_roofv_lo)
33752                                                                          ; = dot_roofv
33753                                                                          ;
33754                                                                          ; XX12(5 4) = [x y z] . nosev
33755                                                                          ; = (dot_nosev_sign dot_nosev_lo)
33756                                                                          ; = dot_nosev
33757               
33758 D7B0 D020  30        movb @XX12,ra                   ; LDA XX12          ; Set XX18(2 0) = dot_sidev
     D7B2 0037     
33759 D7B4 D800  30        movb ra,@XX18                   ; STA XX18
     D7B6 007E     
33760 D7B8 D020  30        movb @XX12+1,ra                 ; LDA XX12+1
     D7BA 0038     
33761 D7BC D800  30        movb ra,@XX18+2                 ; STA XX18+2
     D7BE 0080     
33762               
33763 D7C0 D020  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set XX18(5 3) = dot_roofv
     D7C2 0039     
33764 D7C4 D800  30        movb ra,@XX18+3                 ; STA XX18+3
     D7C6 0081     
33765 D7C8 D020  30        movb @XX12+3,ra                 ; LDA XX12+3
     D7CA 003A     
33766 D7CC D800  30        movb ra,@XX18+5                 ; STA XX18+5
     D7CE 0083     
33767               
33768 D7D0 D020  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set XX18(8 6) = dot_nosev
     D7D2 003B     
33769 D7D4 D800  30        movb ra,@XX18+6                 ; STA XX18+6
     D7D6 0084     
33770 D7D8 D020  30        movb @XX12+5,ra                 ; LDA XX12+5
     D7DA 003C     
33771 D7DC D800  30        movb ra,@XX18+8                 ; STA XX18+8
     D7DE 0086     
33772               
33773 D7E0 0202  20        li   ry,>04*256                 ; LDY #4            ; Fetch byte #4 of the ship's blueprint, which contains
     D7E2 0400     
33774                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the low byte of the offset to the faces data
     **** ****     > LD_IND_Y_IDX
0001 D7E4 D820  50        movb @XX0,@rtmplb
     D7E6 001E     
     D7E8 2079     
0002 D7EA D1A0  30        movb @XX0+1,rtmp
     D7EC 001F     
0003 D7EE A182  18        a    ry,rtmp
0004 D7F0 D016  26        movb *rtmp,RA
                   < elite.a99
33775               
33776                      .clc                            ; CLC               ; Set V = low byte faces offset + XX0
     **** ****     > CLC
0001 D7F2 0A13  18        sla  rzero,1
                   < elite.a99
33777                      .adc @XX0,ra                    ; ADC XX0
     **** ****     > ADC
0001 D7F4 1701  14        jnc  !
0002 D7F6 B004  18        ab   rone,ra
0003               !:
0004 D7F8 B020  30        ab   @XX0,ra
     D7FA 001E     
                   < elite.a99
33778 D7FC D800  30        movb ra,@V                      ; STA V
     D7FE 0022     
33779               
33780 D800 0202  20        li   ry,>11*256                 ; LDY #17           ; Fetch byte #17 of the ship's blueprint, which contains
     D802 1100     
33781                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the high byte of the offset to the faces data
     **** ****     > LD_IND_Y_IDX
0001 D804 D820  50        movb @XX0,@rtmplb
     D806 001E     
     D808 2079     
0002 D80A D1A0  30        movb @XX0+1,rtmp
     D80C 001F     
0003 D80E A182  18        a    ry,rtmp
0004 D810 D016  26        movb *rtmp,RA
                   < elite.a99
33782               
33783                      .adc @XX0+1,ra                  ; ADC XX0+1         ; Set V+1 = high byte faces offset + XX0+1
     **** ****     > ADC
0001 D812 1701  14        jnc  !
0002 D814 B004  18        ab   rone,ra
0003               !:
0004 D816 B020  30        ab   @XX0+1,ra
     D818 001F     
                   < elite.a99
33784 D81A D800  30        movb ra,@V+1                    ; STA V+1           ;
     D81C 0023     
33785                                                                          ; So V(1 0) now points to the start of the faces data
33786                                                                          ; for this ship
33787               
33788 D81E 0202  20        li   ry,>00*256                 ; LDY #0            ; We're now going to loop through all the faces for this
     D820 0000     
33789                                                                          ; ship, so set a counter in Y, starting from 0, which we
33790                                                                          ; will increment by 4 each loop to step through the
33791                                                                          ; four bytes of data for each face
33792               
33793               LL86:
33794                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this face into A, so:
     **** ****     > LD_IND_Y_IDX
0001 D822 D820  50        movb @V,@rtmplb
     D824 0022     
     D826 2079     
0002 D828 D1A0  30        movb @V+1,rtmp
     D82A 0023     
0003 D82C A182  18        a    ry,rtmp
0004 D82E D016  26        movb *rtmp,RA
                   < elite.a99
33795                                                                          ;
33796                                                                          ; A = %xyz vvvvv, where:
33797                                                                          ;
33798                                                                          ; * Bits 0-4 = visibility distance, beyond which the
33799                                                                          ; face is always shown
33800                                                                          ;
33801                                                                          ; * Bits 7-5 = the sign bits of normal_x, normal_y
33802                                                                          ; and normal_z
33803               
33804 D830 D800  30        movb ra,@XX12+1                 ; STA XX12+1        ; Store byte #0 in XX12+1, so XX12+1 now has the sign of
     D832 0038     
33805                                                                          ; normal_x
33806               
33807 D834 0240  22        andi ra,>1f*256                 ; AND #%00011111    ; Extract bits 0-4 to give the visibility distance
     D836 1F00     
33808               
33809 D838 9020  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 <= the visibility distance, where XX4 contains
     D83A 00A7     
33810 D83C 1810  14        joc  LL87                       ; BCS LL87          ; the ship's z-distance reduced to 0-31 (which we set in
33811                                                                          ; part 2), skip to LL87 as this face is close enough
33812                                                                          ; that we have to test its visibility using the face
33813                                                                          ; normals
33814               
33815                                                                          ; Otherwise this face is within range and is therefore
33816                                                                          ; always shown
33817               
33818 D83E D002  18        movb ry,ra                      ; TYA               ; Set X = Y / 4
33819 D840 0910  18        srl  ra,1                       ; LSR A             ; = the number of this face * 4 /4
33820 D842 0910  18        srl  ra,1                       ; LSR A             ; = the number of this face
33821 D844 D040  18        movb ra,rx                      ; TAX
33822               
33823 D846 0200  20        li   ra,>ff*256                 ; LDA #255          ; Set the X-th byte of XX2 to 255 to denote that this
     D848 FF00     
33824 D84A D840  38        movb ra,@XX2(rx)                ; STA XX2,X         ; face is visible
     D84C 00D2     
33825               
33826 D84E D002  18        movb ry,ra                      ; TYA               ; Set Y = Y + 4 to point to the next face
33827                      .adi (>04*256)                  ; ADC #4
     **** ****     > ADI
0001 D850 1701  14        jnc  !
0002 D852 B004  18        ab   rone,ra
0003               !:
0004 D854 0220  22        ai   ra,(>04*256)
     D856 0400     
                   < elite.a99
33828 D858 D080  18        movb ra,ry                      ; TAY
33829               
33830 D85A 0460  28        b    @LL88                      ; JMP LL88          ; Jump down to LL88 to skip the following, as we don't
     D85C DA8A     
33831                                                                          ; need to test the face normals
33832               
33833               LL87:
33834 D85E D020  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Fetch byte #0 for this face into A
     D860 0038     
33835               
33836                      .asla                           ; ASL A             ; Shift A left and store it, so XX12+3 now has the sign
     **** ****     > ASLA
0001 D862 0240  22        andi ra,>ff00
     D864 FF00     
0002 D866 0A10  18        sla  ra,1
                   < elite.a99
33837 D868 D800  30        movb ra,@XX12+3                 ; STA XX12+3        ; of normal_y
     D86A 003A     
33838               
33839                      .asla                           ; ASL A             ; Shift A left and store it, so XX12+5 now has the sign
     **** ****     > ASLA
0001 D86C 0240  22        andi ra,>ff00
     D86E FF00     
0002 D870 0A10  18        sla  ra,1
                   < elite.a99
33840 D872 D800  30        movb ra,@XX12+5                 ; STA XX12+5        ; of normal_z
     D874 003C     
33841               
33842 D876 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
33843               
33844                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this face and store in XX12, so
     **** ****     > LD_IND_Y_IDX
0001 D878 D820  50        movb @V,@rtmplb
     D87A 0022     
     D87C 2079     
0002 D87E D1A0  30        movb @V+1,rtmp
     D880 0023     
0003 D882 A182  18        a    ry,rtmp
0004 D884 D016  26        movb *rtmp,RA
                   < elite.a99
33845 D886 D800  30        movb ra,@XX12                   ; STA XX12          ; XX12 = normal_x
     D888 0037     
33846               
33847 D88A B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
33848               
33849                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this face and store in XX12+2, so
     **** ****     > LD_IND_Y_IDX
0001 D88C D820  50        movb @V,@rtmplb
     D88E 0022     
     D890 2079     
0002 D892 D1A0  30        movb @V+1,rtmp
     D894 0023     
0003 D896 A182  18        a    ry,rtmp
0004 D898 D016  26        movb *rtmp,RA
                   < elite.a99
33850 D89A D800  30        movb ra,@XX12+2                 ; STA XX12+2        ; XX12+2 = normal_y
     D89C 0039     
33851               
33852 D89E B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
33853               
33854                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this face and store in XX12+4, so
     **** ****     > LD_IND_Y_IDX
0001 D8A0 D820  50        movb @V,@rtmplb
     D8A2 0022     
     D8A4 2079     
0002 D8A6 D1A0  30        movb @V+1,rtmp
     D8A8 0023     
0003 D8AA A182  18        a    ry,rtmp
0004 D8AC D016  26        movb *rtmp,RA
                   < elite.a99
33855 D8AE D800  30        movb ra,@XX12+4                 ; STA XX12+4        ; XX12+4 = normal_z
     D8B0 003B     
33856               
33857                                                                          ; So we now have:
33858                                                                          ;
33859                                                                          ; XX12(1 0) = (normal_x_sign normal_x)
33860                                                                          ;
33861                                                                          ; XX12(3 2) = (normal_y_sign normal_y)
33862                                                                          ;
33863                                                                          ; XX12(5 4) = (normal_z_sign normal_z)
33864               
33865 D8B2 D060  30        movb @XX17,rx                   ; LDX XX17          ; If XX17 < 4 then jump to LL92, otherwise we stored a
     D8B4 0095     
33866 D8B6 0281  22        ci   rx,>04*256                 ; CPX #4            ; larger scale factor above
     D8B8 0400     
33867 D8BA 172B  14        jnc  LL92                       ; BCC LL92
33868               
33869               LL143:
33870 D8BC D020  30        movb @XX18,ra                   ; LDA XX18          ; Set XX15(1 0) = XX18(2 0)
     D8BE 007E     
33871 D8C0 D800  30        movb ra,@XX15                   ; STA XX15          ; = dot_sidev
     D8C2 0031     
33872 D8C4 D020  30        movb @XX18+2,ra                 ; LDA XX18+2
     D8C6 0080     
33873 D8C8 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     D8CA 0032     
33874               
33875 D8CC D020  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set XX15(3 2) = XX18(5 3)
     D8CE 0081     
33876 D8D0 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; = dot_roofv
     D8D2 0033     
33877 D8D4 D020  30        movb @XX18+5,ra                 ; LDA XX18+5
     D8D6 0083     
33878 D8D8 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     D8DA 0034     
33879               
33880 D8DC D020  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set XX15(5 4) = XX18(8 6)
     D8DE 0084     
33881 D8E0 D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; = dot_nosev
     D8E2 0035     
33882 D8E4 D020  30        movb @XX18+8,ra                 ; LDA XX18+8
     D8E6 0086     
33883 D8E8 D800  30        movb ra,@XX15+5                 ; STA XX15+5
     D8EA 0036     
33884               
33885 D8EC 0460  28        b    @LL89                      ; JMP LL89          ; Jump down to LL89
     D8EE D9D6     
33886               
33887               ovflw_:
33888                                                                          ; If we get here then the addition below overflowed, so
33889                                                                          ; we halve the dot products and normal vector
33890                      .lsr @XX18                      ; LSR XX18          ; Divide dot_sidev_lo by 2, so dot_sidev = dot_sidev / 2
     **** ****     > LSR
0001 D8F0 D1A0  30        movb @XX18,rtmp
     D8F2 007E     
0002 D8F4 0916  18        srl  rtmp,1
0003 D8F6 D806  30        movb rtmp,@XX18
     D8F8 007E     
                   < elite.a99
33891               
33892                      .lsr @XX18+6                    ; LSR XX18+6        ; Divide dot_nosev_lo by 2, so dot_nosev = dot_nosev / 2
     **** ****     > LSR
0001 D8FA D1A0  30        movb @XX18+6,rtmp
     D8FC 0084     
0002 D8FE 0916  18        srl  rtmp,1
0003 D900 D806  30        movb rtmp,@XX18+6
     D902 0084     
                   < elite.a99
33893               
33894                      .lsr @XX18+3                    ; LSR XX18+3        ; Divide dot_roofv_lo by 2, so dot_roofv = dot_roofv / 2
     **** ****     > LSR
0001 D904 D1A0  30        movb @XX18+3,rtmp
     D906 0081     
0002 D908 0916  18        srl  rtmp,1
0003 D90A D806  30        movb rtmp,@XX18+3
     D90C 0081     
                   < elite.a99
33895               
33896 D90E 0201  20        li   rx,>01*256                 ; LDX #1            ; Set X = 1 so when we fall through into LL92, we divide
     D910 0100     
33897                                                                          ; the normal vector by 2 as well
33898               
33899               LL92:
33900                                                                          ; We jump here from above with the scale factor in X,
33901                                                                          ; and now we apply it by scaling the normal vector down
33902                                                                          ; by a factor of 2^X (i.e. divide by 2^X)
33903 D912 D020  30        movb @XX12,ra                   ; LDA XX12          ; Set XX15 = normal_x
     D914 0037     
33904 D916 D800  30        movb ra,@XX15                   ; STA XX15
     D918 0031     
33905               
33906 D91A D020  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set XX15+2 = normal_y
     D91C 0039     
33907 D91E D800  30        movb ra,@XX15+2                 ; STA XX15+2
     D920 0033     
33908               
33909 D922 D020  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set A = normal_z
     D924 003B     
33910               
33911               LL93:
33912 D926 7044  18        sb   rone,rx                    ; DEX               ; Decrement the scale factor in X
33913               
33914 D928 110D  14        jlt  LL94                       ; BMI LL94          ; If X was 0 before the decrement, there is no scaling
33915                                                                          ; to do, so jump to LL94 to exit the loop
33916               
33917                      .lsr @XX15                      ; LSR XX15          ; Set XX15 = XX15 / 2
     **** ****     > LSR
0001 D92A D1A0  30        movb @XX15,rtmp
     D92C 0031     
0002 D92E 0916  18        srl  rtmp,1
0003 D930 D806  30        movb rtmp,@XX15
     D932 0031     
                   < elite.a99
33918                                                                          ; = normal_x / 2
33919               
33920                      .lsr @XX15+2                    ; LSR XX15+2        ; Set XX15+2 = XX15+2 / 2
     **** ****     > LSR
0001 D934 D1A0  30        movb @XX15+2,rtmp
     D936 0033     
0002 D938 0916  18        srl  rtmp,1
0003 D93A D806  30        movb rtmp,@XX15+2
     D93C 0033     
                   < elite.a99
33921                                                                          ; = normal_y / 2
33922               
33923 D93E 0910  18        srl  ra,1                       ; LSR A             ; Set A = A / 2
33924                                                                          ; = normal_z / 2
33925               
33926 D940 7044  18        sb   rone,rx                    ; DEX               ; Decrement the scale factor in X
33927               
33928 D942 15F2  14        jgt  LL93+3                     ; BPL LL93+3        ; If we have more scaling to do, loop back up to the
33929                                                                          ; first LSR above until the normal vector is scaled down
33930               
33931               LL94:
33932 D944 D800  30        movb ra,@R                      ; STA R             ; Set R = normal_z
     D946 0091     
33933               
33934 D948 D020  30        movb @XX12+5,ra                 ; LDA XX12+5        ; Set S = normal_z_sign
     D94A 003C     
33935 D94C D800  30        movb ra,@S                      ; STA S
     D94E 0092     
33936               
33937 D950 D020  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set Q = dot_nosev_lo
     D952 0084     
33938 D954 D800  30        movb ra,@Q                      ; STA Q
     D956 0090     
33939               
33940 D958 D020  30        movb @XX18+8,ra                 ; LDA XX18+8        ; Set A = dot_nosev_sign
     D95A 0086     
33941               
33942 D95C 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     D95E D39A     
33943 D960 06A0  32        bl   @jsr                       ;
     D962 FF10     
33944                                                                          ; = normal_z + dot_nosev
33945                                                                          ;
33946                                                                          ; setting the sign of the result in S
33947               
33948 D964 18C5  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
33949                                                                          ; both the normal vector and dot products by 2 and try
33950                                                                          ; again
33951               
33952 D966 D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; Set XX15(5 4) = (S A)
     D968 0035     
33953 D96A D020  30        movb @S,ra                      ; LDA S             ; = normal_z + dot_nosev
     D96C 0092     
33954 D96E D800  30        movb ra,@XX15+5                 ; STA XX15+5
     D970 0036     
33955               
33956 D972 D020  30        movb @XX15,ra                   ; LDA XX15          ; Set R = normal_x
     D974 0031     
33957 D976 D800  30        movb ra,@R                      ; STA R
     D978 0091     
33958               
33959 D97A D020  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set S = normal_x_sign
     D97C 0038     
33960 D97E D800  30        movb ra,@S                      ; STA S
     D980 0092     
33961               
33962 D982 D020  30        movb @XX18,ra                   ; LDA XX18          ; Set Q = dot_sidev_lo
     D984 007E     
33963 D986 D800  30        movb ra,@Q                      ; STA Q
     D988 0090     
33964               
33965 D98A D020  30        movb @XX18+2,ra                 ; LDA XX18+2        ; Set A = dot_sidev_sign
     D98C 0080     
33966               
33967 D98E 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     D990 D39A     
33968 D992 06A0  32        bl   @jsr                       ;
     D994 FF10     
33969                                                                          ; = normal_x + dot_sidev
33970                                                                          ;
33971                                                                          ; setting the sign of the result in S
33972               
33973 D996 18AC  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
33974                                                                          ; both the normal vector and dot products by 2 and try
33975                                                                          ; again
33976               
33977 D998 D800  30        movb ra,@XX15                   ; STA XX15          ; Set XX15(1 0) = (S A)
     D99A 0031     
33978 D99C D020  30        movb @S,ra                      ; LDA S             ; = normal_x + dot_sidev
     D99E 0092     
33979 D9A0 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     D9A2 0032     
33980               
33981 D9A4 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set R = normal_y
     D9A6 0033     
33982 D9A8 D800  30        movb ra,@R                      ; STA R
     D9AA 0091     
33983               
33984 D9AC D020  30        movb @XX12+3,ra                 ; LDA XX12+3        ; Set S = normal_y_sign
     D9AE 003A     
33985 D9B0 D800  30        movb ra,@S                      ; STA S
     D9B2 0092     
33986               
33987 D9B4 D020  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set Q = dot_roofv_lo
     D9B6 0081     
33988 D9B8 D800  30        movb ra,@Q                      ; STA Q
     D9BA 0090     
33989               
33990 D9BC D020  30        movb @XX18+5,ra                 ; LDA XX18+5        ; Set A = dot_roofv_sign
     D9BE 0083     
33991               
33992 D9C0 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     D9C2 D39A     
33993 D9C4 06A0  32        bl   @jsr                       ;
     D9C6 FF10     
33994                                                                          ; = normal_y + dot_roofv
33995               
33996 D9C8 1893  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
33997                                                                          ; both the normal vector and dot products by 2 and try
33998                                                                          ; again
33999               
34000 D9CA D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15(3 2) = (S A)
     D9CC 0033     
34001 D9CE D020  30        movb @S,ra                      ; LDA S             ; = normal_y + dot_roofv
     D9D0 0092     
34002 D9D2 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     D9D4 0034     
34003               
34004               LL89:
34005                                                                          ; When we get here, we have set up the following:
34006                                                                          ;
34007                                                                          ; XX15(1 0) = normal_x + dot_sidev
34008                                                                          ; = normal_x + [x y z] . sidev
34009                                                                          ;
34010                                                                          ; XX15(3 2) = normal_y + dot_roofv
34011                                                                          ; = normal_y + [x y z] . roofv
34012                                                                          ;
34013                                                                          ; XX15(5 4) = normal_z + dot_nosev
34014                                                                          ; = normal_z + [x y z] . nosev
34015                                                                          ;
34016                                                                          ; and:
34017                                                                          ;
34018                                                                          ; XX12(1 0) = (normal_x_sign normal_x)
34019                                                                          ;
34020                                                                          ; XX12(3 2) = (normal_y_sign normal_y)
34021                                                                          ;
34022                                                                          ; XX12(5 4) = (normal_z_sign normal_z)
34023                                                                          ;
34024                                                                          ; We now calculate the dot product XX12 . XX15 to tell
34025                                                                          ; us whether or not this face is visible
34026 D9D6 D020  30        movb @XX12,ra                   ; LDA XX12          ; Set Q = XX12
     D9D8 0037     
34027 D9DA D800  30        movb ra,@Q                      ; STA Q
     D9DC 0090     
34028               
34029 D9DE D020  30        movb @XX15,ra                   ; LDA XX15          ; Set A = XX15
     D9E0 0031     
34030               
34031 D9E2 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     D9E4 4338     
34032 D9E6 06A0  32        bl   @jsr                       ;
     D9E8 FF10     
34033 D9EA D800  30        movb ra,@T                      ; STA T             ; = XX15 * XX12 / 256
     D9EC 00D1     
34034               
34035 D9EE D020  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set S = sign of XX15(1 0) * XX12(1 0), so:
     D9F0 0038     
34036                      .eor @XX15+1                    ; EOR XX15+1        ;
     **** ****     > EOR
0001 D9F2 D1A0  30        movb @XX15+1,rtmp
     D9F4 0032     
0002 D9F6 2806  18        xor  rtmp,ra
                   < elite.a99
34037 D9F8 D800  30        movb ra,@S                      ; STA S             ; (S T) = XX15(1 0) * XX12(1 0) / 256
     D9FA 0092     
34038               
34039 D9FC D020  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set Q = XX12+2
     D9FE 0039     
34040 DA00 D800  30        movb ra,@Q                      ; STA Q
     DA02 0090     
34041               
34042 DA04 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set A = XX15+2
     DA06 0033     
34043               
34044 DA08 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q
     DA0A 4338     
34045 DA0C 06A0  32        bl   @jsr                       ;
     DA0E FF10     
34046 DA10 D800  30        movb ra,@Q                      ; STA Q             ; = XX15+2 * XX12+2 / 256
     DA12 0090     
34047               
34048 DA14 D020  30        movb @T,ra                      ; LDA T             ; Set T = R, so now:
     DA16 00D1     
34049 DA18 D800  30        movb ra,@R                      ; STA R             ;
     DA1A 0091     
34050                                                                          ; (S R) = XX15(1 0) * XX12(1 0) / 256
34051               
34052 DA1C D020  30        movb @XX12+3,ra                 ; LDA XX12+3        ; Set A = sign of XX15+3 * XX12+3, so:
     DA1E 003A     
34053                      .eor @XX15+3                    ; EOR XX15+3        ;
     **** ****     > EOR
0001 DA20 D1A0  30        movb @XX15+3,rtmp
     DA22 0034     
0002 DA24 2806  18        xor  rtmp,ra
                   < elite.a99
34054                                                                          ; (A Q) = XX15(3 2) * XX12(3 2) / 256
34055               
34056 DA26 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S T) = (S R) + (A Q)
     DA28 D39A     
34057 DA2A 06A0  32        bl   @jsr                       ;
     DA2C FF10     
34058 DA2E D800  30        movb ra,@T                      ; STA T             ; =   XX15(1 0) * XX12(1 0) / 256
     DA30 00D1     
34059                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34060               
34061 DA32 D020  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set Q = XX12+4
     DA34 003B     
34062 DA36 D800  30        movb ra,@Q                      ; STA Q
     DA38 0090     
34063               
34064 DA3A D020  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set A = XX15+4
     DA3C 0035     
34065               
34066 DA3E 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q
     DA40 4338     
34067 DA42 06A0  32        bl   @jsr                       ;
     DA44 FF10     
34068 DA46 D800  30        movb ra,@Q                      ; STA Q             ; = XX15+4 * XX12+4 / 256
     DA48 0090     
34069               
34070 DA4A D020  30        movb @T,ra                      ; LDA T             ; Set T = R, so now:
     DA4C 00D1     
34071 DA4E D800  30        movb ra,@R                      ; STA R             ;
     DA50 0091     
34072                                                                          ; (S R) =   XX15(1 0) * XX12(1 0) / 256
34073                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34074               
34075 DA52 D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A = sign of XX15+5 * XX12+5, so:
     DA54 0036     
34076                      .eor @XX12+5                    ; EOR XX12+5        ;
     **** ****     > EOR
0001 DA56 D1A0  30        movb @XX12+5,rtmp
     DA58 003C     
0002 DA5A 2806  18        xor  rtmp,ra
                   < elite.a99
34077                                                                          ; (A Q) = XX15(5 4) * XX12(5 4) / 256
34078               
34079 DA5C 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     DA5E D39A     
34080 DA60 06A0  32        bl   @jsr                       ;
     DA62 FF10     
34081                                                                          ; =   XX15(1 0) * XX12(1 0) / 256
34082                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34083                                                                          ; + XX15(5 4) * XX12(5 4) / 256
34084               
34085                      .pha                            ; PHA               ; Push the result A onto the stack, so the stack now
     **** ****     > PHA
0001 DA64 D680  30        movb ra,*rsp
0002 DA66 060A  14        dec  rsp
                   < elite.a99
34086                                                                          ; contains the dot product XX12 . XX15
34087               
34088 DA68 D002  18        movb ry,ra                      ; TYA               ; Set X = Y / 4
34089 DA6A 0910  18        srl  ra,1                       ; LSR A             ; = the number of this face * 4 /4
34090 DA6C 0910  18        srl  ra,1                       ; LSR A             ; = the number of this face
34091 DA6E D040  18        movb ra,rx                      ; TAX
34092               
34093                      .pla                            ; PLA               ; Pull the dot product off the stack into A
     **** ****     > PLA
0001 DA70 058A  14        inc  rsp
0002 DA72 D01A  26        movb *rsp,ra
                   < elite.a99
34094               
34095                      .bit @S                         ; BIT S             ; If bit 7 of S is set, i.e. the dot product is
     **** ****     > BIT
0001 DA74 D1A0  30        movb @S,rtmp
     DA76 0092     
0002 DA78 0546  14        inv  rtmp
0003 DA7A D1C4  18        movb rone,rtmp2
0004 DA7C 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
34096 DA7E 1102  14        jlt  B112                       ; BMI B112          ; negative, then this face is visible as its normal is
34097                                                                          ; pointing towards us, so skip the following instruction
34098               
34099 DA80 0200  20        li   ra,>00*256                 ; LDA #0            ; Otherwise the face is not visible, so set A = 0 so we
     DA82 0000     
34100                                                                          ; can store this to mean "not visible"
34101               
34102               B112:
34103 DA84 D840  38        movb ra,@XX2(rx)                ; STA XX2,X         ; Store the face's visibility in the X-th byte of XX2
     DA86 00D2     
34104               
34105 DA88 B084  18        ab   rone,ry                    ; INY               ; Above we incremented Y to point to byte #3, so this
34106                                                                          ; increments Y to point to byte #4, i.e. byte #0 of the
34107                                                                          ; next face
34108               
34109               LL88:
34110 DA8A 90A0  30        cb   @XX20,ry                   ; CPY XX20          ; If Y >= XX20, the number of faces * 4, jump down to
     DA8C 00A8     
34111 DA8E 1802  14        joc  LL42                       ; BCS LL42          ; LL42 to move on to the
34112               
34113 DA90 0460  28        b    @LL86                      ; JMP LL86          ; Otherwise loop back to LL86 to work out the visibility
     DA92 D822     
34114                                                                          ; of the next face
34115               
34116               * ******************************************************************************
34117               *
34118               * Name: LL9 (Part 6 of 12)
34119               * Type: Subroutine
34120               * Category: Drawing ships
34121               * Summary: Draw ship: Calculate the visibility of each of the ship's vertices
34122               * Deep dive: Drawing ships
34123               * Calculating vertex coordinates
34124               *
34125               * ------------------------------------------------------------------------------
34126               *
34127               * This section calculates the visibility of each of the ship's vertices, and for
34128               * those that are visible, it starts the process of calculating the screen
34129               * coordinates of each vertex
34130               *
34131               * ******************************************************************************
34132               
34133               LL42:
34134                                                                          ; The first task is to set up the inverse matrix, ready
34135                                                                          ; for us to send to the dot product routine at LL51.
34136                                                                          ; Back up in part 3, we set up the following variables:
34137                                                                          ;
34138                                                                          ; * XX16(1 0) = sidev_x
34139                                                                          ; * XX16(3 2) = sidev_y
34140                                                                          ; * XX16(5 4) = sidev_z
34141                                                                          ;
34142                                                                          ; * XX16(7 6) = roofv_x
34143                                                                          ; * XX16(9 8) = roofv_y
34144                                                                          ; * XX16(11 10) = roofv_z
34145                                                                          ;
34146                                                                          ; * XX16(13 12) = nosev_x
34147                                                                          ; * XX16(15 14) = nosev_y
34148                                                                          ; * XX16(17 16) = nosev_z
34149                                                                          ;
34150                                                                          ; and we then scaled the vectors to give the following:
34151                                                                          ;
34152                                                                          ; * XX16   = scaled |sidev_x|
34153                                                                          ; * XX16+2 = scaled |sidev_y|
34154                                                                          ; * XX16+4 = scaled |sidev_z|
34155                                                                          ;
34156                                                                          ; * XX16+6  = scaled |roofv_x|
34157                                                                          ; * XX16+8  = scaled |roofv_y|
34158                                                                          ; * XX16+10 = scaled |roofv_z|
34159                                                                          ;
34160                                                                          ; * XX16+12 = scaled |nosev_x|
34161                                                                          ; * XX16+14 = scaled |nosev_y|
34162                                                                          ; * XX16+16 = scaled |nosev_z|
34163                                                                          ;
34164                                                                          ; We now need to rearrange these locations so they
34165                                                                          ; effectively transpose the matrix into its inverse
34166 DA94 D0A0  30        movb @XX16+2,ry                 ; LDY XX16+2        ; Set XX16+2 = XX16+6 = scaled |roofv_x|
     DA96 000B     
34167 DA98 D060  30        movb @XX16+3,rx                 ; LDX XX16+3        ; Set XX16+3 = XX16+7 = roofv_x_hi
     DA9A 000C     
34168 DA9C D020  30        movb @XX16+6,ra                 ; LDA XX16+6        ; Set XX16+6 = XX16+2 = scaled |sidev_y|
     DA9E 000F     
34169 DAA0 D800  30        movb ra,@XX16+2                 ; STA XX16+2        ; Set XX16+7 = XX16+3 = sidev_y_hi
     DAA2 000B     
34170 DAA4 D020  30        movb @XX16+7,ra                 ; LDA XX16+7
     DAA6 0010     
34171 DAA8 D800  30        movb ra,@XX16+3                 ; STA XX16+3
     DAAA 000C     
34172 DAAC D802  30        movb ry,@XX16+6                 ; STY XX16+6
     DAAE 000F     
34173 DAB0 D801  30        movb rx,@XX16+7                 ; STX XX16+7
     DAB2 0010     
34174               
34175 DAB4 D0A0  30        movb @XX16+4,ry                 ; LDY XX16+4        ; Set XX16+4 = XX16+12 = scaled |nosev_x|
     DAB6 000D     
34176 DAB8 D060  30        movb @XX16+5,rx                 ; LDX XX16+5        ; Set XX16+5 = XX16+13 = nosev_x_hi
     DABA 000E     
34177 DABC D020  30        movb @XX16+12,ra                ; LDA XX16+12       ; Set XX16+12 = XX16+4 = scaled |sidev_z|
     DABE 0015     
34178 DAC0 D800  30        movb ra,@XX16+4                 ; STA XX16+4        ; Set XX16+13 = XX16+5 = sidev_z_hi
     DAC2 000D     
34179 DAC4 D020  30        movb @XX16+13,ra                ; LDA XX16+13
     DAC6 0016     
34180 DAC8 D800  30        movb ra,@XX16+5                 ; STA XX16+5
     DACA 000E     
34181 DACC D802  30        movb ry,@XX16+12                ; STY XX16+12
     DACE 0015     
34182 DAD0 D801  30        movb rx,@XX16+13                ; STX XX16+13
     DAD2 0016     
34183               
34184 DAD4 D0A0  30        movb @XX16+10,ry                ; LDY XX16+10       ; Set XX16+10 = XX16+14 = scaled |nosev_y|
     DAD6 0013     
34185 DAD8 D060  30        movb @XX16+11,rx                ; LDX XX16+11       ; Set XX16+11 = XX16+15 = nosev_y_hi
     DADA 0014     
34186 DADC D020  30        movb @XX16+14,ra                ; LDA XX16+14       ; Set XX16+14 = XX16+10 = scaled |roofv_z|
     DADE 0017     
34187 DAE0 D800  30        movb ra,@XX16+10                ; STA XX16+10       ; Set XX16+15 = XX16+11 = roofv_z
     DAE2 0013     
34188 DAE4 D020  30        movb @XX16+15,ra                ; LDA XX16+15
     DAE6 0018     
34189 DAE8 D800  30        movb ra,@XX16+11                ; STA XX16+11
     DAEA 0014     
34190 DAEC D802  30        movb ry,@XX16+14                ; STY XX16+14
     DAEE 0017     
34191 DAF0 D801  30        movb rx,@XX16+15                ; STX XX16+15
     DAF2 0018     
34192               
34193                                                                          ; So now we have the following sign-magnitude variables
34194                                                                          ; containing parts of the scaled orientation vectors:
34195                                                                          ;
34196                                                                          ; XX16(1 0)   = scaled sidev_x
34197                                                                          ; XX16(3 2)   = scaled roofv_x
34198                                                                          ; XX16(5 4)   = scaled nosev_x
34199                                                                          ;
34200                                                                          ; XX16(7 6)   = scaled sidev_y
34201                                                                          ; XX16(9 8)   = scaled roofv_y
34202                                                                          ; XX16(11 10) = scaled nosev_y
34203                                                                          ;
34204                                                                          ; XX16(13 12) = scaled sidev_z
34205                                                                          ; XX16(15 14) = scaled roofv_z
34206                                                                          ; XX16(17 16) = scaled nosev_z
34207                                                                          ;
34208                                                                          ; which is what we want, as the various vectors are now
34209                                                                          ; arranged so we can use LL51 to multiply by the
34210                                                                          ; transpose (i.e. the inverse of the matrix)
34211               
34212 DAF4 0202  20        li   ry,>08*256                 ; LDY #8            ; Fetch byte #8 of the ship's blueprint, which is the
     DAF6 0800     
34213                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of vertices * 8, and store it in XX20
     **** ****     > LD_IND_Y_IDX
0001 DAF8 D820  50        movb @XX0,@rtmplb
     DAFA 001E     
     DAFC 2079     
0002 DAFE D1A0  30        movb @XX0+1,rtmp
     DB00 001F     
0003 DB02 A182  18        a    ry,rtmp
0004 DB04 D016  26        movb *rtmp,RA
                   < elite.a99
34214 DB06 D800  30        movb ra,@XX20                   ; STA XX20
     DB08 00A8     
34215               
34216                                                                          ; We now set V(1 0) = XX0(1 0) + 20, so V(1 0) points
34217                                                                          ; to byte #20 of the ship's blueprint, which is always
34218                                                                          ; where the vertex data starts (i.e. just after the 20
34219                                                                          ; byte block that define the ship's characteristics)
34220               
34221 DB0A D020  30        movb @XX0,ra                    ; LDA XX0           ; We start with the low bytes
     DB0C 001E     
34222                      .clc                            ; CLC
     **** ****     > CLC
0001 DB0E 0A13  18        sla  rzero,1
                   < elite.a99
34223                      .adi (>14*256)                  ; ADC #20
     **** ****     > ADI
0001 DB10 1701  14        jnc  !
0002 DB12 B004  18        ab   rone,ra
0003               !:
0004 DB14 0220  22        ai   ra,(>14*256)
     DB16 1400     
                   < elite.a99
34224 DB18 D800  30        movb ra,@V                      ; STA V
     DB1A 0022     
34225               
34226 DB1C D020  30        movb @XX0+1,ra                  ; LDA XX0+1         ; And then do the high bytes
     DB1E 001F     
34227                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 DB20 1701  14        jnc  !
0002 DB22 B004  18        ab   rone,ra
0003               !:
0004 DB24 0220  22        ai   ra,(>00*256)
     DB26 0000     
                   < elite.a99
34228 DB28 D800  30        movb ra,@V+1                    ; STA V+1
     DB2A 0023     
34229               
34230 DB2C 0202  20        li   ry,>00*256                 ; LDY #0            ; We are about to step through all the vertices, using
     DB2E 0000     
34231                                                                          ; Y as a counter. There are six data bytes for each
34232                                                                          ; vertex, so we will increment Y by 6 for each iteration
34233                                                                          ; so it can act as an offset from V(1 0) to the current
34234                                                                          ; vertex's data
34235               
34236 DB30 D802  30        movb ry,@CNT                    ; STY CNT           ; Set CNT = 0, which we will use as a pointer to the
     DB32 00A4     
34237                                                                          ; heap at XX3, starting it at zero so the heap starts
34238                                                                          ; out empty
34239               
34240               LL48:
34241 DB34 D802  30        movb ry,@XX17                   ; STY XX17          ; Set XX17 = Y, so XX17 now contains the offset of the
     DB36 0095     
34242                                                                          ; current vertex's data
34243               
34244                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this vertex into XX15, so:
     **** ****     > LD_IND_Y_IDX
0001 DB38 D820  50        movb @V,@rtmplb
     DB3A 0022     
     DB3C 2079     
0002 DB3E D1A0  30        movb @V+1,rtmp
     DB40 0023     
0003 DB42 A182  18        a    ry,rtmp
0004 DB44 D016  26        movb *rtmp,RA
                   < elite.a99
34245 DB46 D800  30        movb ra,@XX15                   ; STA XX15          ;
     DB48 0031     
34246                                                                          ; XX15 = magnitude of the vertex's x-coordinate
34247               
34248 DB4A B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
34249               
34250                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this vertex into XX15+2, so:
     **** ****     > LD_IND_Y_IDX
0001 DB4C D820  50        movb @V,@rtmplb
     DB4E 0022     
     DB50 2079     
0002 DB52 D1A0  30        movb @V+1,rtmp
     DB54 0023     
0003 DB56 A182  18        a    ry,rtmp
0004 DB58 D016  26        movb *rtmp,RA
                   < elite.a99
34251 DB5A D800  30        movb ra,@XX15+2                 ; STA XX15+2        ;
     DB5C 0033     
34252                                                                          ; XX15+2 = magnitude of the vertex's y-coordinate
34253               
34254 DB5E B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
34255               
34256                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this vertex into XX15+4, so:
     **** ****     > LD_IND_Y_IDX
0001 DB60 D820  50        movb @V,@rtmplb
     DB62 0022     
     DB64 2079     
0002 DB66 D1A0  30        movb @V+1,rtmp
     DB68 0023     
0003 DB6A A182  18        a    ry,rtmp
0004 DB6C D016  26        movb *rtmp,RA
                   < elite.a99
34257 DB6E D800  30        movb ra,@XX15+4                 ; STA XX15+4        ;
     DB70 0035     
34258                                                                          ; XX15+4 = magnitude of the vertex's z-coordinate
34259               
34260 DB72 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
34261               
34262                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this vertex into T, so:
     **** ****     > LD_IND_Y_IDX
0001 DB74 D820  50        movb @V,@rtmplb
     DB76 0022     
     DB78 2079     
0002 DB7A D1A0  30        movb @V+1,rtmp
     DB7C 0023     
0003 DB7E A182  18        a    ry,rtmp
0004 DB80 D016  26        movb *rtmp,RA
                   < elite.a99
34263 DB82 D800  30        movb ra,@T                      ; STA T             ;
     DB84 00D1     
34264                                                                          ; T = %xyz vvvvv, where:
34265                                                                          ;
34266                                                                          ; * Bits 0-4 = visibility distance, beyond which the
34267                                                                          ; vertex is not shown
34268                                                                          ;
34269                                                                          ; * Bits 7-5 = the sign bits of x, y and z
34270               
34271 DB86 0240  22        andi ra,>1f*256                 ; AND #%00011111    ; Extract bits 0-4 to get the visibility distance
     DB88 1F00     
34272               
34273 DB8A 9020  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 > the visibility distance, where XX4 contains
     DB8C 00A7     
34274 DB8E 1734  14        jnc  LL49-3                     ; BCC LL49-3        ; the ship's z-distance reduced to 0-31 (which we set in
34275                                                                          ; part 2), then this vertex is too far away to be
34276                                                                          ; visible, so jump down to LL50 (via the JMP instruction
34277                                                                          ; in LL49-3) to move on to the next vertex
34278               
34279 DB90 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #4
34280               
34281                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #4 for this vertex into P, so:
     **** ****     > LD_IND_Y_IDX
0001 DB92 D820  50        movb @V,@rtmplb
     DB94 0022     
     DB96 2079     
0002 DB98 D1A0  30        movb @V+1,rtmp
     DB9A 0023     
0003 DB9C A182  18        a    ry,rtmp
0004 DB9E D016  26        movb *rtmp,RA
                   < elite.a99
34282 DBA0 D800  30        movb ra,@P                      ; STA P             ;
     DBA2 001B     
34283                                                                          ; P = %ffff ffff, where:
34284                                                                          ;
34285                                                                          ; * Bits 0-3 = the number of face 1
34286                                                                          ;
34287                                                                          ; * Bits 4-7 = the number of face 2
34288               
34289 DBA4 0240  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     DBA6 0F00     
34290 DBA8 D040  18        movb ra,rx                      ; TAX
34291               
34292 DBAA D021  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     DBAC 00D2     
34293 DBAE 1626  14        jne  LL49                       ; BNE LL49          ; face 1 is visible, so jump to LL49
34294               
34295 DBB0 D020  30        movb @P,ra                      ; LDA P             ; Fetch byte #4 for this vertex into A
     DBB2 001B     
34296               
34297 DBB4 0910  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 2
34298 DBB6 0910  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
34299 DBB8 0910  18        srl  ra,1                       ; LSR A
34300 DBBA 0910  18        srl  ra,1                       ; LSR A
34301 DBBC D040  18        movb ra,rx                      ; TAX
34302               
34303 DBBE D021  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     DBC0 00D2     
34304 DBC2 161C  14        jne  LL49                       ; BNE LL49          ; face 2 is visible, so jump to LL49
34305               
34306 DBC4 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #5
34307               
34308                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #5 for this vertex into P, so:
     **** ****     > LD_IND_Y_IDX
0001 DBC6 D820  50        movb @V,@rtmplb
     DBC8 0022     
     DBCA 2079     
0002 DBCC D1A0  30        movb @V+1,rtmp
     DBCE 0023     
0003 DBD0 A182  18        a    ry,rtmp
0004 DBD2 D016  26        movb *rtmp,RA
                   < elite.a99
34309 DBD4 D800  30        movb ra,@P                      ; STA P             ;
     DBD6 001B     
34310                                                                          ; P = %ffff ffff, where:
34311                                                                          ;
34312                                                                          ; * Bits 0-3 = the number of face 3
34313                                                                          ;
34314                                                                          ; * Bits 4-7 = the number of face 4
34315               
34316 DBD8 0240  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     DBDA 0F00     
34317 DBDC D040  18        movb ra,rx                      ; TAX
34318               
34319 DBDE D021  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     DBE0 00D2     
34320 DBE2 160C  14        jne  LL49                       ; BNE LL49          ; face 3 is visible, so jump to LL49
34321               
34322 DBE4 D020  30        movb @P,ra                      ; LDA P             ; Fetch byte #5 for this vertex into A
     DBE6 001B     
34323               
34324 DBE8 0910  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 4
34325 DBEA 0910  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
34326 DBEC 0910  18        srl  ra,1                       ; LSR A
34327 DBEE 0910  18        srl  ra,1                       ; LSR A
34328 DBF0 D040  18        movb ra,rx                      ; TAX
34329               
34330 DBF2 D021  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     DBF4 00D2     
34331 DBF6 1602  14        jne  LL49                       ; BNE LL49          ; face 4 is visible, so jump to LL49
34332               
34333 DBF8 0460  28        b    @LL50                      ; JMP LL50          ; If we get here then none of the four faces associated
     DBFA DF44     
34334                                                                          ; with this vertex are visible, so this vertex is also
34335                                                                          ; not visible, so jump to LL50 to move on to the next
34336                                                                          ; vertex
34337               
34338               LL49:
34339 DBFC D020  30        movb @T,ra                      ; LDA T             ; Fetch byte #5 for this vertex into A and store it, so
     DBFE 00D1     
34340 DC00 D800  30        movb ra,@XX15+1                 ; STA XX15+1        ; XX15+1 now has the sign of the vertex's x-coordinate
     DC02 0032     
34341               
34342                      .asla                           ; ASL A             ; Shift A left and store it, so XX15+3 now has the sign
     **** ****     > ASLA
0001 DC04 0240  22        andi ra,>ff00
     DC06 FF00     
0002 DC08 0A10  18        sla  ra,1
                   < elite.a99
34343 DC0A D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; of the vertex's y-coordinate
     DC0C 0034     
34344               
34345                      .asla                           ; ASL A             ; Shift A left and store it, so XX15+5 now has the sign
     **** ****     > ASLA
0001 DC0E 0240  22        andi ra,>ff00
     DC10 FF00     
0002 DC12 0A10  18        sla  ra,1
                   < elite.a99
34346 DC14 D800  30        movb ra,@XX15+5                 ; STA XX15+5        ; of the vertex's z-coordinate
     DC16 0036     
34347               
34348                                                                          ; By this point we have the following:
34349                                                                          ;
34350                                                                          ; XX15(1 0) = vertex x-coordinate
34351                                                                          ; XX15(3 2) = vertex y-coordinate
34352                                                                          ; XX15(5 4) = vertex z-coordinate
34353                                                                          ;
34354                                                                          ; XX16(1 0)   = scaled sidev_x
34355                                                                          ; XX16(3 2)   = scaled roofv_x
34356                                                                          ; XX16(5 4)   = scaled nosev_x
34357                                                                          ;
34358                                                                          ; XX16(7 6)   = scaled sidev_y
34359                                                                          ; XX16(9 8)   = scaled roofv_y
34360                                                                          ; XX16(11 10) = scaled nosev_y
34361                                                                          ;
34362                                                                          ; XX16(13 12) = scaled sidev_z
34363                                                                          ; XX16(15 14) = scaled roofv_z
34364                                                                          ; XX16(17 16) = scaled nosev_z
34365               
34366 DC18 0206  20        li   rtmp,LL51                  ; JSR LL51          ; Call LL51 to set XX12 to the dot products of XX15 and
     DC1A D3F2     
34367 DC1C 06A0  32        bl   @jsr                       ;
     DC1E FF10     
34368                                                                          ; XX16, as follows:
34369                                                                          ;
34370                                                                          ; XX12(1 0) = [ x y z ] . [ sidev_x roofv_x nosev_x ]
34371                                                                          ;
34372                                                                          ; XX12(3 2) = [ x y z ] . [ sidev_y roofv_y nosev_y ]
34373                                                                          ;
34374                                                                          ; XX12(5 4) = [ x y z ] . [ sidev_z roofv_z nosev_z ]
34375                                                                          ;
34376                                                                          ; XX12 contains the vector from the ship's centre to
34377                                                                          ; the vertex, transformed from the orientation vector
34378                                                                          ; space to the universe orientated around our ship. So
34379                                                                          ; we can refer to this vector below, let's call it
34380                                                                          ; vertv, so:
34381                                                                          ;
34382                                                                          ; vertv_x = [ x y z ] . [ sidev_x roofv_x nosev_x ]
34383                                                                          ;
34384                                                                          ; vertv_y = [ x y z ] . [ sidev_y roofv_y nosev_y ]
34385                                                                          ;
34386                                                                          ; vertv_z = [ x y z ] . [ sidev_z roofv_z nosev_z ]
34387                                                                          ;
34388                                                                          ; To finish the calculation, we now want to calculate:
34389                                                                          ;
34390                                                                          ; vertv + [ x y z ]
34391                                                                          ;
34392                                                                          ; So let's start with the vertv_x + x
34393               
34394 DC20 D020  30        movb @XX1+2,ra                  ; LDA XX1+2         ; Set A = x_sign of the ship's location
     DC22 0055     
34395               
34396 DC24 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 = x_sign
     DC26 0033     
34397               
34398                      .eor @XX12+1                    ; EOR XX12+1        ; If the sign of x_sign * the sign of vertv_x is
     **** ****     > EOR
0001 DC28 D1A0  30        movb @XX12+1,rtmp
     DC2A 0038     
0002 DC2C 2806  18        xor  rtmp,ra
                   < elite.a99
34399 DC2E 1113  14        jlt  LL52                       ; BMI LL52          ; negative (i.e. they have different signs), skip to
34400                                                                          ; LL52
34401               
34402                      .clc                            ; CLC               ; Set XX15(2 1 0) = XX1(2 1 0) + XX12(1 0)
     **** ****     > CLC
0001 DC30 0A13  18        sla  rzero,1
                   < elite.a99
34403 DC32 D020  30        movb @XX12,ra                   ; LDA XX12          ; = (x_sign x_hi x_lo) + vertv_x
     DC34 0037     
34404                      .adc @XX1,ra                    ; ADC XX1           ;
     **** ****     > ADC
0001 DC36 1701  14        jnc  !
0002 DC38 B004  18        ab   rone,ra
0003               !:
0004 DC3A B020  30        ab   @XX1,ra
     DC3C 0053     
                   < elite.a99
34405 DC3E D800  30        movb ra,@XX15                   ; STA XX15          ; Starting with the low bytes
     DC40 0031     
34406               
34407 DC42 D020  30        movb @XX1+1,ra                  ; LDA XX1+1         ; And then doing the high bytes (we can add 0 here as
     DC44 0054     
34408                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_x is 0)
     **** ****     > ADI
0001 DC46 1701  14        jnc  !
0002 DC48 B004  18        ab   rone,ra
0003               !:
0004 DC4A 0220  22        ai   ra,(>00*256)
     DC4C 0000     
                   < elite.a99
34409 DC4E D800  30        movb ra,@XX15+1                 ; STA XX15+1
     DC50 0032     
34410               
34411 DC52 0460  28        b    @LL53                      ; JMP LL53          ; We've added the x-coordinates, so jump to LL53 to do
     DC54 DCA6     
34412                                                                          ; the y-coordinates
34413               
34414               LL52:
34415                                                                          ; If we get here then x_sign and vertv_x have different
34416                                                                          ; signs, so we need to subtract them to get the result
34417 DC56 D020  30        movb @XX1,ra                    ; LDA XX1           ; Set XX15(2 1 0) = XX1(2 1 0) - XX12(1 0)
     DC58 0053     
34418                      .sec                            ; SEC               ; = (x_sign x_hi x_lo) - vertv_x
     **** ****     > SEC
0001 DC5A 0A15  18        sla  rmone,1
                   < elite.a99
34419                      .sbc @XX12,ra                   ; SBC XX12          ;
     **** ****     > SBC
0001 DC5C 1801  14        joc  !
0002 DC5E 7004  18        sb   rone,ra
0003               !:
0004 DC60 7020  30        sb   @XX12,ra
     DC62 0037     
                   < elite.a99
34420 DC64 D800  30        movb ra,@XX15                   ; STA XX15          ; Starting with the low bytes
     DC66 0031     
34421               
34422 DC68 D020  30        movb @XX1+1,ra                  ; LDA XX1+1         ; And then doing the high bytes (we can subtract 0 here
     DC6A 0054     
34423                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_x is 0)
     **** ****     > SBI
0001 DC6C 1801  14        joc  !
0002 DC6E 7004  18        sb   rone,ra
0003               !:
0004 DC70 0220  22        ai   ra,-(>00*256)
     DC72 0000     
                   < elite.a99
34424 DC74 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     DC76 0032     
34425               
34426 DC78 1816  14        joc  LL53                       ; BCS LL53          ; If the subtraction didn't underflow, then the sign of
34427                                                                          ; the result is the same sign as x_sign, and that's what
34428                                                                          ; we want, so we can jump down to LL53 to do the
34429                                                                          ; y-coordinates
34430               
34431                      .eoi (>ff*256)                  ; EOR #%11111111    ; Otherwise we need to negate the result using two's
     **** ****     > EOI
0001 DC7A 0206  20        li   rtmp,(>FF*256)
     DC7C FF00     
0002 DC7E 2806  18        xor  rtmp,ra
                   < elite.a99
34432 DC80 D800  30        movb ra,@XX15+1                 ; STA XX15+1        ; complement, so first we flip the bits of the high byte
     DC82 0032     
34433               
34434 DC84 0200  20        li   ra,>01*256                 ; LDA #1            ; And then subtract the low byte from 1
     DC86 0100     
34435                      .sbc @XX15,ra                   ; SBC XX15
     **** ****     > SBC
0001 DC88 1801  14        joc  !
0002 DC8A 7004  18        sb   rone,ra
0003               !:
0004 DC8C 7020  30        sb   @XX15,ra
     DC8E 0031     
                   < elite.a99
34436 DC90 D800  30        movb ra,@XX15                   ; STA XX15
     DC92 0031     
34437               
34438 DC94 1701  14        jnc  B113                       ; BCC B113          ; If the above subtraction underflowed then we need to
34439 DC96 B004  18        ab   rone,ra                    ; INC XX15+1        ; bump the high byte of the result up by 1
34440               
34441               B113:
34442 DC98 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; And now we flip the sign of the result to get the
     DC9A 0033     
34443                      .eoi (>80*256)                  ; EOR #%10000000    ; correct result
     **** ****     > EOI
0001 DC9C 0206  20        li   rtmp,(>80*256)
     DC9E 8000     
0002 DCA0 2806  18        xor  rtmp,ra
                   < elite.a99
34444 DCA2 D800  30        movb ra,@XX15+2                 ; STA XX15+2
     DCA4 0033     
34445               
34446               LL53:
34447                                                                          ; Now for the y-coordinates, vertv_y + y
34448 DCA6 D020  30        movb @XX1+5,ra                  ; LDA XX1+5         ; Set A = y_sign of the ship's location
     DCA8 0058     
34449               
34450 DCAA D800  30        movb ra,@XX15+5                 ; STA XX15+5        ; Set XX15+5 = y_sign
     DCAC 0036     
34451               
34452                      .eor @XX12+3                    ; EOR XX12+3        ; If the sign of y_sign * the sign of vertv_y is
     **** ****     > EOR
0001 DCAE D1A0  30        movb @XX12+3,rtmp
     DCB0 003A     
0002 DCB2 2806  18        xor  rtmp,ra
                   < elite.a99
34453 DCB4 1113  14        jlt  LL54                       ; BMI LL54          ; negative (i.e. they have different signs), skip to
34454                                                                          ; LL54
34455               
34456                      .clc                            ; CLC               ; Set XX15(5 4 3) = XX1(5 4 3) + XX12(3 2)
     **** ****     > CLC
0001 DCB6 0A13  18        sla  rzero,1
                   < elite.a99
34457 DCB8 D020  30        movb @XX12+2,ra                 ; LDA XX12+2        ; = (y_sign y_hi y_lo) + vertv_y
     DCBA 0039     
34458                      .adc @XX1+3,ra                  ; ADC XX1+3         ;
     **** ****     > ADC
0001 DCBC 1701  14        jnc  !
0002 DCBE B004  18        ab   rone,ra
0003               !:
0004 DCC0 B020  30        ab   @XX1+3,ra
     DCC2 0056     
                   < elite.a99
34459 DCC4 D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; Starting with the low bytes
     DCC6 0034     
34460               
34461 DCC8 D020  30        movb @XX1+4,ra                  ; LDA XX1+4         ; And then doing the high bytes (we can add 0 here as
     DCCA 0057     
34462                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_y is 0)
     **** ****     > ADI
0001 DCCC 1701  14        jnc  !
0002 DCCE B004  18        ab   rone,ra
0003               !:
0004 DCD0 0220  22        ai   ra,(>00*256)
     DCD2 0000     
                   < elite.a99
34463 DCD4 D800  30        movb ra,@XX15+4                 ; STA XX15+4
     DCD6 0035     
34464               
34465 DCD8 0460  28        b    @LL55                      ; JMP LL55          ; We've added the y-coordinates, so jump to LL55 to do
     DCDA DD32     
34466                                                                          ; the z-coordinates
34467               
34468               LL54:
34469                                                                          ; If we get here then y_sign and vertv_y have different
34470                                                                          ; signs, so we need to subtract them to get the result
34471 DCDC D020  30        movb @XX1+3,ra                  ; LDA XX1+3         ; Set XX15(5 4 3) = XX1(5 4 3) - XX12(3 2)
     DCDE 0056     
34472                      .sec                            ; SEC               ; = (y_sign y_hi y_lo) - vertv_y
     **** ****     > SEC
0001 DCE0 0A15  18        sla  rmone,1
                   < elite.a99
34473                      .sbc @XX12+2,ra                 ; SBC XX12+2        ;
     **** ****     > SBC
0001 DCE2 1801  14        joc  !
0002 DCE4 7004  18        sb   rone,ra
0003               !:
0004 DCE6 7020  30        sb   @XX12+2,ra
     DCE8 0039     
                   < elite.a99
34474 DCEA D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; Starting with the low bytes
     DCEC 0034     
34475               
34476 DCEE D020  30        movb @XX1+4,ra                  ; LDA XX1+4         ; And then doing the high bytes (we can subtract 0 here
     DCF0 0057     
34477                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_z is 0)
     **** ****     > SBI
0001 DCF2 1801  14        joc  !
0002 DCF4 7004  18        sb   rone,ra
0003               !:
0004 DCF6 0220  22        ai   ra,-(>00*256)
     DCF8 0000     
                   < elite.a99
34478 DCFA D800  30        movb ra,@XX15+4                 ; STA XX15+4
     DCFC 0035     
34479               
34480 DCFE 1819  14        joc  LL55                       ; BCS LL55          ; If the subtraction didn't underflow, then the sign of
34481                                                                          ; the result is the same sign as y_sign, and that's what
34482                                                                          ; we want, so we can jump down to LL55 to do the
34483                                                                          ; z-coordinates
34484               
34485                      .eoi (>ff*256)                  ; EOR #%11111111    ; Otherwise we need to negate the result using two's
     **** ****     > EOI
0001 DD00 0206  20        li   rtmp,(>FF*256)
     DD02 FF00     
0002 DD04 2806  18        xor  rtmp,ra
                   < elite.a99
34486 DD06 D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; complement, so first we flip the bits of the high byte
     DD08 0035     
34487               
34488 DD0A D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; And then flip the bits of the low byte and add 1
     DD0C 0034     
34489                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 DD0E 0206  20        li   rtmp,(>FF*256)
     DD10 FF00     
0002 DD12 2806  18        xor  rtmp,ra
                   < elite.a99
34490                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 DD14 1701  14        jnc  !
0002 DD16 B004  18        ab   rone,ra
0003               !:
0004 DD18 0220  22        ai   ra,(>01*256)
     DD1A 0100     
                   < elite.a99
34491 DD1C D800  30        movb ra,@XX15+3                 ; STA XX15+3
     DD1E 0034     
34492               
34493 DD20 D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; And now we flip the sign of the result to get the
     DD22 0036     
34494                      .eoi (>80*256)                  ; EOR #%10000000    ; correct result
     **** ****     > EOI
0001 DD24 0206  20        li   rtmp,(>80*256)
     DD26 8000     
0002 DD28 2806  18        xor  rtmp,ra
                   < elite.a99
34495 DD2A D800  30        movb ra,@XX15+5                 ; STA XX15+5
     DD2C 0036     
34496               
34497 DD2E 1701  14        jnc  LL55                       ; BCC LL55          ; If the above subtraction underflowed then we need to
34498 DD30 B004  18        ab   rone,ra                    ; INC XX15+4        ; bump the high byte of the result up by 1
34499               
34500               LL55:
34501                                                                          ; Now for the z-coordinates, vertv_z + z
34502 DD32 D020  30        movb @XX12+5,ra                 ; LDA XX12+5        ; If vertv_z_hi is negative, jump down to LL56
     DD34 003C     
34503 DD36 1151  14        jlt  LL56                       ; BMI LL56
34504               
34505 DD38 D020  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set (U T) = XX1(7 6) + XX12(5 4)
     DD3A 003B     
34506                      .clc                            ; CLC               ; = (z_hi z_lo) + vertv_z
     **** ****     > CLC
0001 DD3C 0A13  18        sla  rzero,1
                   < elite.a99
34507                      .adc @XX1+6,ra                  ; ADC XX1+6         ;
     **** ****     > ADC
0001 DD3E 1701  14        jnc  !
0002 DD40 B004  18        ab   rone,ra
0003               !:
0004 DD42 B020  30        ab   @XX1+6,ra
     DD44 0059     
                   < elite.a99
34508 DD46 D800  30        movb ra,@T                      ; STA T             ; Starting with the low bytes
     DD48 00D1     
34509               
34510 DD4A D020  30        movb @XX1+7,ra                  ; LDA XX1+7         ; And then doing the high bytes (we can add 0 here as
     DD4C 005A     
34511                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_y is 0)
     **** ****     > ADI
0001 DD4E 1701  14        jnc  !
0002 DD50 B004  18        ab   rone,ra
0003               !:
0004 DD52 0220  22        ai   ra,(>00*256)
     DD54 0000     
                   < elite.a99
34512 DD56 D800  30        movb ra,@U                      ; STA U
     DD58 008F     
34513               
34514 DD5A 0460  28        b    @LL57                      ; JMP LL57          ; We've added the z-coordinates, so jump to LL57
     DD5C DE1A     
34515               
34516                                                                          ; The adding process is continued in part 7, after a
34517                                                                          ; couple of subroutines that we don't need quite yet
34518               
34519               * ******************************************************************************
34520               *
34521               * Name: LL61
34522               * Type: Subroutine
34523               * Category: Maths (Arithmetic)
34524               * Summary: Calculate (U R) = 256 * A / Q
34525               *
34526               * ------------------------------------------------------------------------------
34527               *
34528               * Calculate the following, where A >= Q:
34529               *
34530               * (U R) = 256 * A / Q
34531               *
34532               * This is a sister routine to LL28, which does the division when A < Q.
34533               *
34534               * ******************************************************************************
34535               
34536               LL61:
34537 DD5E D060  30        movb @Q,rx                      ; LDX Q             ; If Q = 0, jump down to LL84 to return a division
     DD60 0090     
34538 DD62 131F  14        jeq  LL84                       ; BEQ LL84          ; error
34539               
34540                                                                          ; The LL28 routine returns A / Q, but only if A < Q. In
34541                                                                          ; our case A >= Q, but we still want to use the LL28
34542                                                                          ; routine, so we halve A until it's less than Q, call
34543                                                                          ; the division routine, and then double A by the same
34544                                                                          ; number of times
34545               
34546 DD64 0201  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0 to count the number of times we halve A
     DD66 0000     
34547               
34548               LL63:
34549 DD68 0910  18        srl  ra,1                       ; LSR A             ; Halve A by shifting right
34550               
34551 DD6A B044  18        ab   rone,rx                    ; INX               ; Increment X
34552               
34553 DD6C 9020  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, loop back to LL63 to halve it again
     DD6E 0090     
34554 DD70 18FB  14        joc  LL63                       ; BCS LL63
34555               
34556 DD72 D801  30        movb rx,@S                      ; STX S             ; Otherwise store the number of times we halved A in S
     DD74 0092     
34557               
34558 DD76 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     DD78 D344     
34559 DD7A 06A0  32        bl   @jsr                       ;
     DD7C FF10     
34560                                                                          ;
34561                                                                          ; R = 256 * A / Q
34562                                                                          ;
34563                                                                          ; which we can do now as A < Q
34564               
34565 DD7E D060  30        movb @S,rx                      ; LDX S             ; Otherwise restore the number of times we halved A
     DD80 0092     
34566                                                                          ; above into X
34567               
34568 DD82 D020  30        movb @R,ra                      ; LDA R             ; Set A = our division result
     DD84 0091     
34569               
34570               LL64:
34571                      .asla                           ; ASL A             ; Double (U A) by shifting left
     **** ****     > ASLA
0001 DD86 0240  22        andi ra,>ff00
     DD88 FF00     
0002 DD8A 0A10  18        sla  ra,1
                   < elite.a99
34572 DD8C 0208  20        li   rarg1,U                    ; ROL U
     DD8E 008F     
34573 DD90 06A0  32        bl   @rol                       ;
     DD92 FF36     
34574               
34575 DD94 1106  14        jlt  LL84                       ; BMI LL84          ; If bit 7 of U is set, the doubling has overflowed, so
34576                                                                          ; jump to LL84 to return a division error
34577               
34578 DD96 7044  18        sb   rone,rx                    ; DEX               ; Decrement X
34579               
34580 DD98 16F6  14        jne  LL64                       ; BNE LL64          ; If X is not yet zero then we haven't done as many
34581                                                                          ; doublings as we did halvings earlier, so loop back for
34582                                                                          ; another doubling
34583               
34584 DD9A D800  30        movb ra,@R                      ; STA R             ; Store the low byte of the division result in R
     DD9C 0091     
34585               
34586 DD9E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DDA0 FF1C     
34587               
34588               LL84:
34589 DDA2 0200  20        li   ra,>32*256                 ; LDA #50           ; If we get here then either we tried to divide by 0, or
     DDA4 3200     
34590 DDA6 D800  30        movb ra,@R                      ; STA R             ; the result overflowed, so we set U and R to 50
     DDA8 0091     
34591 DDAA D800  30        movb ra,@U                      ; STA U
     DDAC 008F     
34592               
34593 DDAE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DDB0 FF1C     
34594               
34595               * ******************************************************************************
34596               *
34597               * Name: LL62
34598               * Type: Subroutine
34599               * Category: Maths (Arithmetic)
34600               * Summary: Calculate 128 - (U R)
34601               *
34602               * ------------------------------------------------------------------------------
34603               *
34604               * Calculate the following for a positive sign-magnitude number (U R):
34605               *
34606               * 128 - (U R)
34607               *
34608               * and then store the result, low byte then high byte, on the end of the heap at
34609               * XX3, where X points to the first free byte on the heap. Return by jumping down
34610               * to LL66.
34611               *
34612               * ------------------------------------------------------------------------------
34613               *
34614               * Returns:
34615               *
34616               * X                   X is incremented by 1
34617               *
34618               * ******************************************************************************
34619               
34620               LL62:
34621 DDB2 0200  20        li   ra,>80*256                 ; LDA #128          ; Calculate 128 - (U R), starting with the low bytes
     DDB4 8000     
34622                      .sec                            ; SEC
     **** ****     > SEC
0001 DDB6 0A15  18        sla  rmone,1
                   < elite.a99
34623                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 DDB8 1801  14        joc  !
0002 DDBA 7004  18        sb   rone,ra
0003               !:
0004 DDBC 7020  30        sb   @R,ra
     DDBE 0091     
                   < elite.a99
34624               
34625 DDC0 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DDC2 0100     
34626                                                                          ; the heap at XX3
34627               
34628 DDC4 B044  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34629                                                                          ; byte
34630               
34631 DDC6 0200  20        li   ra,>00*256                 ; LDA #0            ; And then subtract the high bytes
     DDC8 0000     
34632                      .sbc @U,ra                      ; SBC U
     **** ****     > SBC
0001 DDCA 1801  14        joc  !
0002 DDCC 7004  18        sb   rone,ra
0003               !:
0004 DDCE 7020  30        sb   @U,ra
     DDD0 008F     
                   < elite.a99
34633               
34634 DDD2 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DDD4 0100     
34635                                                                          ; the heap at XX3
34636               
34637 DDD6 0460  28        b    @LL66                      ; JMP LL66          ; Jump down to LL66
     DDD8 DEB6     
34638               
34639               * ******************************************************************************
34640               *
34641               * Name: LL9 (Part 7 of 12)
34642               * Type: Subroutine
34643               * Category: Drawing ships
34644               * Summary: Draw ship: Calculate the visibility of each of the ship's vertices
34645               * Deep dive: Drawing ships
34646               * Calculating vertex coordinates
34647               *
34648               * ------------------------------------------------------------------------------
34649               *
34650               * This section continues the coordinate adding from part 6 by finishing off the
34651               * calculation that we started above:
34652               *
34653               * [ sidev_x roofv_x nosev_x ]   [ x ]   [ x ]
34654               * vector to vertex = [ sidev_y roofv_y nosev_y ] . [ y ] + [ y ]
34655               * [ sidev_z roofv_z nosev_z ]   [ z ]   [ z ]
34656               *
34657               * The gets stored as follows, in sign-magnitude values with the magnitudes
34658               * fitting into the low bytes:
34659               *
34660               * XX15(2 0)           [ x y z ] . [ sidev_x roofv_x nosev_x ] + [ x y z ]
34661               *
34662               * XX15(5 3)           [ x y z ] . [ sidev_y roofv_y nosev_y ] + [ x y z ]
34663               *
34664               * (U T)               [ x y z ] . [ sidev_z roofv_z nosev_z ] + [ x y z ]
34665               *
34666               * Finally, because this vector is from our ship to the vertex, and we are at the
34667               * origin, this vector is the same as the coordinates of the vertex. In other
34668               * words, we have just worked out:
34669               *
34670               * XX15(2 0)           x-coordinate of the current vertex
34671               *
34672               * XX15(5 3)           y-coordinate of the current vertex
34673               *
34674               * (U T)               z-coordinate of the current vertex
34675               *
34676               * ******************************************************************************
34677               
34678               LL56:
34679 DDDA D020  30        movb @XX1+6,ra                  ; LDA XX1+6         ; Set (U T) = XX1(7 6) - XX12(5 4)
     DDDC 0059     
34680                      .sec                            ; SEC               ; = (z_hi z_lo) - vertv_z
     **** ****     > SEC
0001 DDDE 0A15  18        sla  rmone,1
                   < elite.a99
34681                      .sbc @XX12+4,ra                 ; SBC XX12+4        ;
     **** ****     > SBC
0001 DDE0 1801  14        joc  !
0002 DDE2 7004  18        sb   rone,ra
0003               !:
0004 DDE4 7020  30        sb   @XX12+4,ra
     DDE6 003B     
                   < elite.a99
34682 DDE8 D800  30        movb ra,@T                      ; STA T             ; Starting with the low bytes
     DDEA 00D1     
34683               
34684 DDEC D020  30        movb @XX1+7,ra                  ; LDA XX1+7         ; And then doing the high bytes (we can subtract 0 here
     DDEE 005A     
34685                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_z is 0)
     **** ****     > SBI
0001 DDF0 1801  14        joc  !
0002 DDF2 7004  18        sb   rone,ra
0003               !:
0004 DDF4 0220  22        ai   ra,-(>00*256)
     DDF6 0000     
                   < elite.a99
34686 DDF8 D800  30        movb ra,@U                      ; STA U
     DDFA 008F     
34687               
34688 DDFC 1706  14        jnc  LL140                      ; BCC LL140         ; If the subtraction just underflowed, skip to LL140 to
34689                                                                          ; set (U T) to the minimum value of 4
34690               
34691 DDFE 160D  14        jne  LL57                       ; BNE LL57          ; If U is non-zero, jump down to LL57
34692               
34693 DE00 D020  30        movb @T,ra                      ; LDA T             ; If T >= 4, jump down to LL57
     DE02 00D1     
34694 DE04 0280  22        ci   ra,>04*256                 ; CMP #4
     DE06 0400     
34695 DE08 1808  14        joc  LL57                       ; BCS LL57
34696               
34697               LL140:
34698 DE0A 0200  20        li   ra,>00*256                 ; LDA #0            ; If we get here then either (U T) < 4 or the
     DE0C 0000     
34699 DE0E D800  30        movb ra,@U                      ; STA U             ; subtraction underflowed, so set (U T) = 4
     DE10 008F     
34700 DE12 0200  20        li   ra,>04*256                 ; LDA #4
     DE14 0400     
34701 DE16 D800  30        movb ra,@T                      ; STA T
     DE18 00D1     
34702               
34703               LL57:
34704                                                                          ; By this point we have our results, so now to scale
34705                                                                          ; the 16-bit results down into 8-bit values
34706 DE1A D020  30        movb @U,ra                      ; LDA U             ; If the high bytes of the result are all zero, we are
     DE1C 008F     
34707 DE1E F020  30        socb @XX15+1,ra                 ; ORA XX15+1        ; done, so jump down to LL60 for the next stage
     DE20 0032     
34708 DE22 F020  30        socb @XX15+4,ra                 ; ORA XX15+4
     DE24 0035     
34709 DE26 131D  14        jeq  LL60                       ; BEQ LL60
34710               
34711                      .lsr @XX15+1                    ; LSR XX15+1        ; Shift XX15(1 0) to the right
     **** ****     > LSR
0001 DE28 D1A0  30        movb @XX15+1,rtmp
     DE2A 0032     
0002 DE2C 0916  18        srl  rtmp,1
0003 DE2E D806  30        movb rtmp,@XX15+1
     DE30 0032     
                   < elite.a99
34712 DE32 0208  20        li   rarg1,XX15                 ; ROR XX15
     DE34 0031     
34713 DE36 06A0  32        bl   @ror                       ;
     DE38 FF62     
34714               
34715                      .lsr @XX15+4                    ; LSR XX15+4        ; Shift XX15(4 3) to the right
     **** ****     > LSR
0001 DE3A D1A0  30        movb @XX15+4,rtmp
     DE3C 0035     
0002 DE3E 0916  18        srl  rtmp,1
0003 DE40 D806  30        movb rtmp,@XX15+4
     DE42 0035     
                   < elite.a99
34716 DE44 0208  20        li   rarg1,XX15+3               ; ROR XX15+3
     DE46 0034     
34717 DE48 06A0  32        bl   @ror                       ;
     DE4A FF62     
34718               
34719                      .lsr @U                         ; LSR U             ; Shift (U T) to the right
     **** ****     > LSR
0001 DE4C D1A0  30        movb @U,rtmp
     DE4E 008F     
0002 DE50 0916  18        srl  rtmp,1
0003 DE52 D806  30        movb rtmp,@U
     DE54 008F     
                   < elite.a99
34720 DE56 0208  20        li   rarg1,T                    ; ROR T
     DE58 00D1     
34721 DE5A 06A0  32        bl   @ror                       ;
     DE5C FF62     
34722               
34723 DE5E 0460  28        b    @LL57                      ; JMP LL57          ; Jump back to LL57 to see if we can shift the result
     DE60 DE1A     
34724                                                                          ; any more
34725               
34726               * ******************************************************************************
34727               *
34728               * Name: LL9 (Part 8 of 12)
34729               * Type: Subroutine
34730               * Category: Drawing ships
34731               * Summary: Draw ship: Calculate the screen coordinates of visible vertices
34732               * Deep dive: Drawing ships
34733               *
34734               * ------------------------------------------------------------------------------
34735               *
34736               * This section projects the coordinate of the vertex into screen coordinates and
34737               * stores them on the XX3 heap. By the end of this part, the XX3 heap contains
34738               * four bytes containing the 16-bit screen coordinates of the current vertex, in
34739               * the order: x_lo, x_hi, y_lo, y_hi.
34740               *
34741               * When we reach here, we are looping through the vertices, and we've just worked
34742               * out the coordinates of the vertex in our normal coordinate system, as follows
34743               *
34744               * XX15(2 0)           (x_sign x_lo) = x-coordinate of the current vertex
34745               *
34746               * XX15(5 3)           (y_sign y_lo) = y-coordinate of the current vertex
34747               *
34748               * (U T)               (z_sign z_lo) = z-coordinate of the current vertex
34749               *
34750               * Note that U is always zero when we get to this point, as the vertex is always
34751               * in front of us (so it has a positive z-coordinate, into the screen).
34752               *
34753               * ------------------------------------------------------------------------------
34754               *
34755               * Other entry points:
34756               *
34757               * LL70+1              Contains an RTS (as the first byte of an LDA
34758               * instruction)
34759               *
34760               * LL66                A re-entry point into the ship-drawing routine, used by
34761               * the LL62 routine to store 128 - (U R) on the XX3 heap
34762               *
34763               * ******************************************************************************
34764               
34765               LL60:
34766 DE62 D020  30        movb @T,ra                      ; LDA T             ; Set Q = z_lo
     DE64 00D1     
34767 DE66 D800  30        movb ra,@Q                      ; STA Q
     DE68 0090     
34768               
34769 DE6A D020  30        movb @XX15,ra                   ; LDA XX15          ; Set A = x_lo
     DE6C 0031     
34770               
34771 DE6E 9020  30        cb   @Q,ra                      ; CMP Q             ; If x_lo < z_lo jump to LL69
     DE70 0090     
34772 DE72 1706  14        jnc  LL69                       ; BCC LL69
34773               
34774 DE74 0206  20        li   rtmp,LL61                  ; JSR LL61          ; Call LL61 to calculate:
     DE76 DD5E     
34775 DE78 06A0  32        bl   @jsr                       ;
     DE7A FF10     
34776                                                                          ;
34777                                                                          ; (U R) = 256 * A / Q
34778                                                                          ; = 256 * x / z
34779                                                                          ;
34780                                                                          ; which we can do as x >= z
34781               
34782 DE7C 0460  28        b    @LL65                      ; JMP LL65          ; Jump to LL65 to skip the division for x_lo < z_lo
     DE7E DE88     
34783               
34784               LL69:
34785 DE80 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     DE82 D344     
34786 DE84 06A0  32        bl   @jsr                       ;
     DE86 FF10     
34787                                                                          ;
34788                                                                          ; R = 256 * A / Q
34789                                                                          ; = 256 * x / z
34790                                                                          ;
34791                                                                          ; Because x < z, the result fits into one byte, and we
34792                                                                          ; also know that U = 0, so (U R) also contains the
34793                                                                          ; result
34794               
34795               LL65:
34796                                                                          ; At this point we have:
34797                                                                          ;
34798                                                                          ; (U R) = x / z
34799                                                                          ;
34800                                                                          ; so (U R) contains the vertex's x-coordinate projected
34801                                                                          ; on screen
34802                                                                          ;
34803                                                                          ; The next task is to convert (U R) to a pixel screen
34804                                                                          ; coordinate and stick it on the XX3 heap.
34805                                                                          ;
34806                                                                          ; We start with the x-coordinate. To convert the
34807                                                                          ; x-coordinate to a screen pixel we add 128, the
34808                                                                          ; x-coordinate of the centre of the screen, because the
34809                                                                          ; projected value is relative to an origin at the centre
34810                                                                          ; of the screen, but the origin of the screen pixels is
34811                                                                          ; at the top-left of the screen
34812 DE88 D060  30        movb @CNT,rx                    ; LDX CNT           ; Fetch the pointer to the end of the XX3 heap from CNT
     DE8A 00A4     
34813                                                                          ; into X
34814               
34815 DE8C D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If x_sign is negative, jump up to LL62, which will
     DE8E 0033     
34816 DE90 1190  14        jlt  LL62                       ; BMI LL62          ; store 128 - (U R) on the XX3 heap and return by
34817                                                                          ; jumping down to LL66 below
34818               
34819 DE92 D020  30        movb @R,ra                      ; LDA R             ; Calculate 128 + (U R), starting with the low bytes
     DE94 0091     
34820                      .clc                            ; CLC
     **** ****     > CLC
0001 DE96 0A13  18        sla  rzero,1
                   < elite.a99
34821                      .adi (>80*256)                  ; ADC #128
     **** ****     > ADI
0001 DE98 1701  14        jnc  !
0002 DE9A B004  18        ab   rone,ra
0003               !:
0004 DE9C 0220  22        ai   ra,(>80*256)
     DE9E 8000     
                   < elite.a99
34822               
34823 DEA0 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DEA2 0100     
34824                                                                          ; the heap at XX3
34825               
34826 DEA4 B044  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34827                                                                          ; byte
34828               
34829 DEA6 D020  30        movb @U,ra                      ; LDA U             ; And then add the high bytes
     DEA8 008F     
34830                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 DEAA 1701  14        jnc  !
0002 DEAC B004  18        ab   rone,ra
0003               !:
0004 DEAE 0220  22        ai   ra,(>00*256)
     DEB0 0000     
                   < elite.a99
34831               
34832 DEB2 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     DEB4 0100     
34833                                                                          ; the heap at XX3
34834               
34835               LL66:
34836                                                                          ; We've just stored the screen x-coordinate of the
34837                                                                          ; vertex on the XX3 heap, so now for the y-coordinate
34838 DEB6 D001  18        movb rx,ra                      ; TXA               ; Store the heap pointer in X on the stack (at this
34839                      .pha                            ; PHA               ; it points to the last entry on the heap, not the first
     **** ****     > PHA
0001 DEB8 D680  30        movb ra,*rsp
0002 DEBA 060A  14        dec  rsp
                   < elite.a99
34840                                                                          ; free byte)
34841               
34842 DEBC 0200  20        li   ra,>00*256                 ; LDA #0            ; Set U = 0
     DEBE 0000     
34843 DEC0 D800  30        movb ra,@U                      ; STA U
     DEC2 008F     
34844               
34845 DEC4 D020  30        movb @T,ra                      ; LDA T             ; Set Q = z_lo
     DEC6 00D1     
34846 DEC8 D800  30        movb ra,@Q                      ; STA Q
     DECA 0090     
34847               
34848 DECC D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set A = y_lo
     DECE 0034     
34849               
34850 DED0 9020  30        cb   @Q,ra                      ; CMP Q             ; If y_lo < z_lo jump to LL67
     DED2 0090     
34851 DED4 171A  14        jnc  LL67                       ; BCC LL67
34852               
34853 DED6 0206  20        li   rtmp,LL61                  ; JSR LL61          ; Call LL61 to calculate:
     DED8 DD5E     
34854 DEDA 06A0  32        bl   @jsr                       ;
     DEDC FF10     
34855                                                                          ;
34856                                                                          ; (U R) = 256 * A / Q
34857                                                                          ; = 256 * y / z
34858                                                                          ;
34859                                                                          ; which we can do as y >= z
34860               
34861 DEDE 0460  28        b    @LL68                      ; JMP LL68          ; Jump to LL68 to skip the division for y_lo < z_lo
     DEE0 DF12     
34862               
34863               LL70:
34864                                                                          ; This gets called from below when y_sign is negative
34865 DEE2 0200  20        li   ra,(Y)*256                 ; LDA #Y            ; Calculate #Y + (U R), starting with the low bytes
     DEE4 6000     
34866                      .clc                            ; CLC
     **** ****     > CLC
0001 DEE6 0A13  18        sla  rzero,1
                   < elite.a99
34867                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 DEE8 1701  14        jnc  !
0002 DEEA B004  18        ab   rone,ra
0003               !:
0004 DEEC B020  30        ab   @R,ra
     DEEE 0091     
                   < elite.a99
34868               
34869 DEF0 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DEF2 0100     
34870                                                                          ; the heap at XX3
34871               
34872 DEF4 B044  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34873                                                                          ; byte
34874               
34875 DEF6 0200  20        li   ra,>00*256                 ; LDA #0            ; And then add the high bytes
     DEF8 0000     
34876                      .adc @U,ra                      ; ADC U
     **** ****     > ADC
0001 DEFA 1701  14        jnc  !
0002 DEFC B004  18        ab   rone,ra
0003               !:
0004 DEFE B020  30        ab   @U,ra
     DF00 008F     
                   < elite.a99
34877               
34878 DF02 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     DF04 0100     
34879                                                                          ; the heap at XX3
34880               
34881 DF06 0460  28        b    @LL50                      ; JMP LL50          ; Jump to LL50 to move on to the next vertex
     DF08 DF44     
34882               
34883               LL67:
34884 DF0A 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     DF0C D344     
34885 DF0E 06A0  32        bl   @jsr                       ;
     DF10 FF10     
34886                                                                          ;
34887                                                                          ; R = 256 * A / Q
34888                                                                          ; = 256 * y / z
34889                                                                          ;
34890                                                                          ; Because y < z, the result fits into one byte, and we
34891                                                                          ; also know that U = 0, so (U R) also contains the
34892                                                                          ; result
34893               
34894               LL68:
34895                                                                          ; At this point we have:
34896                                                                          ;
34897                                                                          ; (U R) = y / z
34898                                                                          ;
34899                                                                          ; so (U R) contains the vertex's y-coordinate projected
34900                                                                          ; on screen
34901                                                                          ;
34902                                                                          ; We now want to convert this to a screen y-coordinate
34903                                                                          ; and stick it on the XX3 heap, much like we did with
34904                                                                          ; the x-coordinate above. Again, we convert the
34905                                                                          ; coordinate by adding or subtracting the y-coordinate
34906                                                                          ; of the centre of the screen, which is in the constant
34907                                                                          ; #Y, but this time we do the opposite, as a positive
34908                                                                          ; projected y-coordinate, i.e. up the space y-axis and
34909                                                                          ; up the screen, converts to a low y-coordinate, which
34910                                                                          ; is the opposite way round to the x-coordinates
34911                      .pla                            ; PLA               ; Restore the heap pointer from the stack into X
     **** ****     > PLA
0001 DF12 058A  14        inc  rsp
0002 DF14 D01A  26        movb *rsp,ra
                   < elite.a99
34912 DF16 D040  18        movb ra,rx                      ; TAX
34913               
34914 DF18 B044  18        ab   rone,rx                    ; INX               ; When we stored the heap pointer, it pointed to the
34915                                                                          ; last entry on the heap, not the first free byte, so we
34916                                                                          ; increment it so it does point to the next free byte
34917               
34918 DF1A D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; If y_sign is negative, jump up to LL70, which will
     DF1C 0036     
34919 DF1E 11E1  14        jlt  LL70                       ; BMI LL70          ; store #Y + (U R) on the XX3 heap and return by jumping
34920                                                                          ; down to LL50 below
34921               
34922 DF20 0200  20        li   ra,(Y)*256                 ; LDA #Y            ; Calculate #Y - (U R), starting with the low bytes
     DF22 6000     
34923                      .sec                            ; SEC
     **** ****     > SEC
0001 DF24 0A15  18        sla  rmone,1
                   < elite.a99
34924                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 DF26 1801  14        joc  !
0002 DF28 7004  18        sb   rone,ra
0003               !:
0004 DF2A 7020  30        sb   @R,ra
     DF2C 0091     
                   < elite.a99
34925               
34926 DF2E D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DF30 0100     
34927                                                                          ; the heap at XX3
34928               
34929 DF32 B044  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34930                                                                          ; byte
34931               
34932 DF34 0200  20        li   ra,>00*256                 ; LDA #0            ; And then subtract the high bytes
     DF36 0000     
34933                      .sbc @U,ra                      ; SBC U
     **** ****     > SBC
0001 DF38 1801  14        joc  !
0002 DF3A 7004  18        sb   rone,ra
0003               !:
0004 DF3C 7020  30        sb   @U,ra
     DF3E 008F     
                   < elite.a99
34934               
34935 DF40 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     DF42 0100     
34936                                                                          ; the heap at XX3
34937               
34938               LL50:
34939                                                                          ; By the time we get here, the XX3 heap contains four
34940                                                                          ; bytes containing the screen coordinates of the current
34941                                                                          ; vertex, in the order: x_lo, x_hi, y_lo, y_hi
34942                      .clc                            ; CLC               ; Set CNT = CNT + 4, so the heap pointer points to the
     **** ****     > CLC
0001 DF44 0A13  18        sla  rzero,1
                   < elite.a99
34943 DF46 D020  30        movb @CNT,ra                    ; LDA CNT           ; next free byte on the heap
     DF48 00A4     
34944                      .adi (>04*256)                  ; ADC #4
     **** ****     > ADI
0001 DF4A 1701  14        jnc  !
0002 DF4C B004  18        ab   rone,ra
0003               !:
0004 DF4E 0220  22        ai   ra,(>04*256)
     DF50 0400     
                   < elite.a99
34945 DF52 D800  30        movb ra,@CNT                    ; STA CNT
     DF54 00A4     
34946               
34947 DF56 D020  30        movb @XX17,ra                   ; LDA XX17          ; Set A to the offset of the current vertex's data,
     DF58 0095     
34948                                                                          ; which we set in part 6
34949               
34950                      .adi (>06*256)                  ; ADC #6            ; Set Y = A + 6, so Y now points to the data for the
     **** ****     > ADI
0001 DF5A 1701  14        jnc  !
0002 DF5C B004  18        ab   rone,ra
0003               !:
0004 DF5E 0220  22        ai   ra,(>06*256)
     DF60 0600     
                   < elite.a99
34951 DF62 D080  18        movb ra,ry                      ; TAY               ; next vertex
34952               
34953 DF64 1805  14        joc  LL72                       ; BCS LL72          ; If the addition just overflowed, meaning we just tried
34954                                                                          ; to access vertex #43, jump to LL72, as the maximum
34955                                                                          ; number of vertices allowed is 42
34956               
34957 DF66 9020  30        cb   @XX20,ra                   ; CMP XX20          ; If Y >= number of vertices * 6 (which we stored in
     DF68 00A8     
34958 DF6A 1802  14        joc  LL72                       ; BCS LL72          ; XX20 in part 6), jump to LL72, as we have processed
34959                                                                          ; all the vertices for this ship
34960               
34961 DF6C 0460  28        b    @LL48                      ; JMP LL48          ; Loop back to LL48 in part 6 to calculate visibility
     DF6E DB34     
34962                                                                          ; and screen coordinates for the next vertex
34963               
34964               * ******************************************************************************
34965               *
34966               * Name: LL9 (Part 9 of 12)
34967               * Type: Subroutine
34968               * Category: Drawing ships
34969               * Summary: Draw ship: Draw laser beams if the ship is firing its laser at us
34970               * Deep dive: Drawing ships
34971               *
34972               * ------------------------------------------------------------------------------
34973               *
34974               * This part sets things up so we can loop through the edges in the next part. It
34975               * also adds a line to the ship line heap, if the ship is firing at us.
34976               *
34977               * When we get here, the heap at XX3 contains all the visible vertex screen
34978               * coordinates.
34979               *
34980               * ******************************************************************************
34981               
34982               LL72:
34983 DF70 D020  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     DF72 0072     
34984 DF74 0240  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE31
     DF76 2000     
34985 DF78 1308  14        jeq  EE31                       ; BEQ EE31
34986               
34987 DF7A D020  30        movb @XX1+31,ra                 ; LDA XX1+31        ; The ship is exploding, so set bit 3 of the ship's byte
     DF7C 0072     
34988 DF7E 0260  22        ori  ra,>08*256                 ; ORA #%00001000    ; #31 to denote that we are drawing something on-screen
     DF80 0800     
34989 DF82 D800  30        movb ra,@XX1+31                 ; STA XX1+31        ; for this ship
     DF84 0072     
34990               
34991 DF86 0460  28        b    @DOEXP                     ; JMP DOEXP         ; Jump to DOEXP to display the explosion cloud,
     DF88 A8A0     
34992                                                                          ; returning from the subroutine using a tail call
34993               
34994               EE31:
34995 DF8A 0200  20        li   ra,>08*256                 ; LDA #%00001000    ; If bit 3 of the ship's byte #31 is clear, then there
     DF8C 0800     
34996                      .bit @XX1+31                    ; BIT XX1+31        ; is nothing already being shown for this ship, so skip
     **** ****     > BIT
0001 DF8E D1A0  30        movb @XX1+31,rtmp
     DF90 0072     
0002 DF92 0546  14        inv  rtmp
0003 DF94 D1C4  18        movb rone,rtmp2
0004 DF96 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
34997 DF98 1306  14        jeq  LL74                       ; BEQ LL74          ; to LL74 as we don't need to erase anything from the
34998                                                                          ; screen
34999               
35000 DF9A 0206  20        li   rtmp,LL155                 ; JSR LL155         ; Otherwise call LL155 to draw the existing ship, which
     DF9C E25C     
35001 DF9E 06A0  32        bl   @jsr                       ;
     DFA0 FF10     
35002                                                                          ; removes it from the screen
35003               
35004 DFA2 0200  20        li   ra,>08*256                 ; LDA #%00001000    ; Set bit 3 of A so the next instruction sets bit 3 of
     DFA4 0800     
35005                                                                          ; the ship's byte #31 to denote that we are drawing
35006                                                                          ; something on-screen for this ship
35007               
35008               LL74:
35009 DFA6 F020  30        socb @XX1+31,ra                 ; ORA XX1+31        ; Apply bit 3 of A to the ship's byte #31, so if there
     DFA8 0072     
35010 DFAA D800  30        movb ra,@XX1+31                 ; STA XX1+31        ; was no ship already on screen, the bit is clear,
     DFAC 0072     
35011                                                                          ; otherwise it is set
35012               
35013 DFAE 0202  20        li   ry,>09*256                 ; LDY #9            ; Fetch byte #9 of the ship's blueprint, which is the
     DFB0 0900     
35014                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of edges, and store it in XX20
     **** ****     > LD_IND_Y_IDX
0001 DFB2 D820  50        movb @XX0,@rtmplb
     DFB4 001E     
     DFB6 2079     
0002 DFB8 D1A0  30        movb @XX0+1,rtmp
     DFBA 001F     
0003 DFBC A182  18        a    ry,rtmp
0004 DFBE D016  26        movb *rtmp,RA
                   < elite.a99
35015 DFC0 D800  30        movb ra,@XX20                   ; STA XX20
     DFC2 00A8     
35016               
35017 DFC4 0202  20        li   ry,>00*256                 ; LDY #0            ; We are about to step through all the edges, using Y
     DFC6 0000     
35018                                                                          ; as a counter
35019               
35020 DFC8 D802  30        movb ry,@U                      ; STY U             ; Set U = 0 (though we increment it to 1 below)
     DFCA 008F     
35021               
35022 DFCC D802  30        movb ry,@XX17                   ; STY XX17          ; Set XX17 = 0, which we are going to use as a counter
     DFCE 0095     
35023                                                                          ; for stepping through the ship's edges
35024               
35025 DFD0 B004  18        ab   rone,ra                    ; INC U             ; We are going to start calculating the lines we need to
35026                                                                          ; draw for this ship, and will store them in the ship
35027                                                                          ; line heap, using U to point to the end of the heap, so
35028                                                                          ; we start by setting U = 1
35029               
35030                      .bit @XX1+31                    ; BIT XX1+31        ; If bit 6 of the ship's byte #31 is clear, then the
     **** ****     > BIT
0001 DFD2 D1A0  30        movb @XX1+31,rtmp
     DFD4 0072     
0002 DFD6 0546  14        inv  rtmp
0003 DFD8 D1C4  18        movb rone,rtmp2
0004 DFDA 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
35031 DFDC 1965  14        jno  LL170                      ; BVC LL170         ; ship is not firing its lasers, so jump to LL170 to
35032                                                                          ; skip the drawing of laser lines
35033               
35034                                                                          ; The ship is firing its laser at us, so we need to draw
35035                                                                          ; the laser lines
35036               
35037 DFDE D020  30        movb @XX1+31,ra                 ; LDA XX1+31        ; Clear bit 6 of the ship's byte #31 so the ship doesn't
     DFE0 0072     
35038 DFE2 0240  22        andi ra,>bf*256                 ; AND #%10111111    ; keep firing endlessly
     DFE4 BF00     
35039 DFE6 D800  30        movb ra,@XX1+31                 ; STA XX1+31
     DFE8 0072     
35040               
35041 DFEA 0202  20        li   ry,>06*256                 ; LDY #6            ; Fetch byte #6 of the ship's blueprint, which is the
     DFEC 0600     
35042                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number * 4 of the vertex where the ship has its lasers
     **** ****     > LD_IND_Y_IDX
0001 DFEE D820  50        movb @XX0,@rtmplb
     DFF0 001E     
     DFF2 2079     
0002 DFF4 D1A0  30        movb @XX0+1,rtmp
     DFF6 001F     
0003 DFF8 A182  18        a    ry,rtmp
0004 DFFA D016  26        movb *rtmp,RA
                   < elite.a99
35043               
35044 DFFC D080  18        movb ra,ry                      ; TAY               ; Put the vertex number into Y, where it can act as an
35045                                                                          ; index into list of vertex screen coordinates we added
35046                                                                          ; to the XX3 heap
35047               
35048 DFFE D062  34        movb @XX3(ry),rx                ; LDX XX3,Y         ; Fetch the x_lo coordinate of the laser vertex from the
     E000 0100     
35049 E002 D801  30        movb rx,@XX15                   ; STX XX15          ; XX3 heap into XX15
     E004 0031     
35050               
35051 E006 B044  18        ab   rone,rx                    ; INX               ; If X = 255 then the laser vertex is not visible, as
35052 E008 134F  14        jeq  LL170                      ; BEQ LL170         ; the value we stored in part 2 wasn't overwritten by
35053                                                                          ; the vertex calculation in part 6 and 7, so jump to
35054                                                                          ; LL170 to skip drawing the laser lines
35055               
35056                                                                          ; We now build a laser beam from the ship's laser vertex
35057                                                                          ; towards our ship, as follows:
35058                                                                          ;
35059                                                                          ; XX15(1 0) = laser vertex x-coordinate
35060                                                                          ;
35061                                                                          ; XX15(3 2) = laser vertex y-coordinate
35062                                                                          ;
35063                                                                          ; XX15(5 4) = x-coordinate of the end of the beam
35064                                                                          ;
35065                                                                          ; XX12(1 0) = y-coordinate of the end of the beam
35066                                                                          ;
35067                                                                          ; The end of the laser beam will be positioned to look
35068                                                                          ; good, rather than being directly aimed at us, as
35069                                                                          ; otherwise we would only see a flashing point of light
35070                                                                          ; as they unleashed their attack
35071               
35072 E00A D062  34        movb @XX3+1(ry),rx              ; LDX XX3+1,Y       ; Fetch the x_hi coordinate of the laser vertex from the
     E00C 0101     
35073 E00E D801  30        movb rx,@XX15+1                 ; STX XX15+1        ; XX3 heap into XX15+1
     E010 0032     
35074               
35075 E012 B044  18        ab   rone,rx                    ; INX               ; If X = 255 then the laser vertex is not visible, as
35076 E014 1349  14        jeq  LL170                      ; BEQ LL170         ; the value we stored in part 2 wasn't overwritten by
35077                                                                          ; a vertex calculation in part 6 and 7, so jump to LL170
35078                                                                          ; to skip drawing the laser beam
35079               
35080 E016 D062  34        movb @XX3+2(ry),rx              ; LDX XX3+2,Y       ; Fetch the y_lo coordinate of the laser vertex from the
     E018 0102     
35081 E01A D801  30        movb rx,@XX15+2                 ; STX XX15+2        ; XX3 heap into XX15+2
     E01C 0033     
35082               
35083 E01E D062  34        movb @XX3+3(ry),rx              ; LDX XX3+3,Y       ; Fetch the y_hi coordinate of the laser vertex from the
     E020 0103     
35084 E022 D801  30        movb rx,@XX15+3                 ; STX XX15+3        ; XX3 heap into XX15+3
     E024 0034     
35085               
35086 E026 0200  20        li   ra,>00*256                 ; LDA #0            ; Set XX15(5 4) = 0, so their laser beam fires to the
     E028 0000     
35087 E02A D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; left edge of the screen
     E02C 0035     
35088 E02E D800  30        movb ra,@XX15+5                 ; STA XX15+5
     E030 0036     
35089               
35090 E032 D800  30        movb ra,@XX12+1                 ; STA XX12+1        ; Set XX12(1 0) = the ship's z_lo coordinate, which will
     E034 0038     
35091 E036 D020  30        movb @XX1+6,ra                  ; LDA XX1+6         ; effectively make the vertical position of the end of
     E038 0059     
35092 E03A D800  30        movb ra,@XX12                   ; STA XX12          ; the laser beam move around as the ship moves in space
     E03C 0037     
35093               
35094 E03E D020  30        movb @XX1+2,ra                  ; LDA XX1+2         ; If the ship's x_sign is positive, skip the next
     E040 0055     
35095 E042 1501  14        jgt  B114                       ; BPL B114          ; instruction
35096               
35097 E044 7004  18        sb   rone,ra                    ; DEC XX15+4        ; The ship's x_sign is negative (i.e. it's on the left
35098                                                                          ; side of the screen), so switch the laser beam so it
35099                                                                          ; goes to the right edge of the screen by decrementing
35100                                                                          ; XX15(5 4) to 255
35101               
35102               B114:
35103 E046 0206  20        li   rtmp,LL145                 ; JSR LL145         ; Call LL145 to see if the laser beam needs to be
     E048 E56C     
35104 E04A 06A0  32        bl   @jsr                       ;
     E04C FF10     
35105                                                                          ; clipped to fit on-screen, returning the clipped line's
35106                                                                          ; end-points in (X1, Y1) and (X2, Y2)
35107               
35108 E04E 182C  14        joc  LL170                      ; BCS LL170         ; If the C flag is set then the line is not visible on
35109                                                                          ; screen, so jump to LL170 so we don't store this line
35110                                                                          ; in the ship line heap
35111               
35112 E050 D0A0  30        movb @U,ry                      ; LDY U             ; Fetch the ship line heap pointer, which points to the
     E052 008F     
35113                                                                          ; next free byte on the heap, into Y
35114               
35115 E054 D020  30        movb @XX15,ra                   ; LDA XX15          ; Add X1 to the end of the heap
     E056 0031     
35116                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E058 D820  50        movb @XX19,@rtmplb
     E05A 0074     
     E05C 2079     
0002 E05E D1A0  30        movb @XX19+1,rtmp
     E060 0075     
0003 E062 A182  18        a    ry,rtmp
0004 E064 D580  30        movb RA,*rtmp
                   < elite.a99
35117               
35118 E066 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35119               
35120 E068 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Add Y1 to the end of the heap
     E06A 0032     
35121                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E06C D820  50        movb @XX19,@rtmplb
     E06E 0074     
     E070 2079     
0002 E072 D1A0  30        movb @XX19+1,rtmp
     E074 0075     
0003 E076 A182  18        a    ry,rtmp
0004 E078 D580  30        movb RA,*rtmp
                   < elite.a99
35122               
35123 E07A B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35124               
35125 E07C D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Add X2 to the end of the heap
     E07E 0033     
35126                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E080 D820  50        movb @XX19,@rtmplb
     E082 0074     
     E084 2079     
0002 E086 D1A0  30        movb @XX19+1,rtmp
     E088 0075     
0003 E08A A182  18        a    ry,rtmp
0004 E08C D580  30        movb RA,*rtmp
                   < elite.a99
35127               
35128 E08E B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35129               
35130 E090 D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Add Y2 to the end of the heap
     E092 0034     
35131                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E094 D820  50        movb @XX19,@rtmplb
     E096 0074     
     E098 2079     
0002 E09A D1A0  30        movb @XX19+1,rtmp
     E09C 0075     
0003 E09E A182  18        a    ry,rtmp
0004 E0A0 D580  30        movb RA,*rtmp
                   < elite.a99
35132               
35133 E0A2 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35134               
35135 E0A4 D802  30        movb ry,@U                      ; STY U             ; Store the updated ship line heap pointer in U
     E0A6 008F     
35136               
35137               * ******************************************************************************
35138               *
35139               * Name: LL9 (Part 10 of 12)
35140               * Type: Subroutine
35141               * Category: Drawing ships
35142               * Summary: Draw ship: Calculate the visibility of each of the ship's edges
35143               * Deep dive: Drawing ships
35144               *
35145               * ------------------------------------------------------------------------------
35146               *
35147               * This part calculates which edges are visible - in other words, which lines we
35148               * should draw - and clips them to fit on the screen.
35149               *
35150               * When we get here, the heap at XX3 contains all the visible vertex screen
35151               * coordinates.
35152               *
35153               * ******************************************************************************
35154               
35155               LL170:
35156 E0A8 0202  20        li   ry,>03*256                 ; LDY #3            ; Fetch byte #3 of the ship's blueprint, which contains
     E0AA 0300     
35157                      .clc                            ; CLC               ; the low byte of the offset to the edges data
     **** ****     > CLC
0001 E0AC 0A13  18        sla  rzero,1
                   < elite.a99
35158                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y
     **** ****     > LD_IND_Y_IDX
0001 E0AE D820  50        movb @XX0,@rtmplb
     E0B0 001E     
     E0B2 2079     
0002 E0B4 D1A0  30        movb @XX0+1,rtmp
     E0B6 001F     
0003 E0B8 A182  18        a    ry,rtmp
0004 E0BA D016  26        movb *rtmp,RA
                   < elite.a99
35159               
35160                      .adc @XX0,ra                    ; ADC XX0           ; Set V = low byte edges offset + XX0
     **** ****     > ADC
0001 E0BC 1701  14        jnc  !
0002 E0BE B004  18        ab   rone,ra
0003               !:
0004 E0C0 B020  30        ab   @XX0,ra
     E0C2 001E     
                   < elite.a99
35161 E0C4 D800  30        movb ra,@V                      ; STA V
     E0C6 0022     
35162               
35163 E0C8 0202  20        li   ry,>10*256                 ; LDY #16           ; Fetch byte #16 of the ship's blueprint, which contains
     E0CA 1000     
35164                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the high byte of the offset to the edges data
     **** ****     > LD_IND_Y_IDX
0001 E0CC D820  50        movb @XX0,@rtmplb
     E0CE 001E     
     E0D0 2079     
0002 E0D2 D1A0  30        movb @XX0+1,rtmp
     E0D4 001F     
0003 E0D6 A182  18        a    ry,rtmp
0004 E0D8 D016  26        movb *rtmp,RA
                   < elite.a99
35165               
35166                      .adc @XX0+1,ra                  ; ADC XX0+1         ; Set V+1 = high byte edges offset + XX0+1
     **** ****     > ADC
0001 E0DA 1701  14        jnc  !
0002 E0DC B004  18        ab   rone,ra
0003               !:
0004 E0DE B020  30        ab   @XX0+1,ra
     E0E0 001F     
                   < elite.a99
35167 E0E2 D800  30        movb ra,@V+1                    ; STA V+1           ;
     E0E4 0023     
35168                                                                          ; So V(1 0) now points to the start of the edges data
35169                                                                          ; for this ship
35170               
35171 E0E6 0202  20        li   ry,>05*256                 ; LDY #5            ; Fetch byte #5 of the ship's blueprint, which contains
     E0E8 0500     
35172                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the maximum heap size for plotting the ship (which is
     **** ****     > LD_IND_Y_IDX
0001 E0EA D820  50        movb @XX0,@rtmplb
     E0EC 001E     
     E0EE 2079     
0002 E0F0 D1A0  30        movb @XX0+1,rtmp
     E0F2 001F     
0003 E0F4 A182  18        a    ry,rtmp
0004 E0F6 D016  26        movb *rtmp,RA
                   < elite.a99
35173 E0F8 D800  30        movb ra,@T1                     ; STA T1            ; 1 + 4 * the maximum number of visible edges) and store
     E0FA 0006     
35174                                                                          ; it in T1
35175               
35176 E0FC D0A0  30        movb @XX17,ry                   ; LDY XX17          ; Set Y to the edge counter in XX17
     E0FE 0095     
35177               
35178               LL75:
35179                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this edge, which contains the
     **** ****     > LD_IND_Y_IDX
0001 E100 D820  50        movb @V,@rtmplb
     E102 0022     
     E104 2079     
0002 E106 D1A0  30        movb @V+1,rtmp
     E108 0023     
0003 E10A A182  18        a    ry,rtmp
0004 E10C D016  26        movb *rtmp,RA
                   < elite.a99
35180                                                                          ; visibility distance for this edge, beyond which the
35181                                                                          ; edge is not shown
35182               
35183 E10E 9020  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 > the visibility distance, where XX4 contains
     E110 00A7     
35184 E112 1802  14        joc  FIX011                     ; BCS FIX011        ; the ship's z-distance reduced to 0-31 (which we set in
35185 E114 0460  28        b    @LL78                      ; JMP LL78          ; part 2), then this edge is too far away to be visible,
     E116 E21E     
35186                                                                          ; so jump down to LL78 to move on to the next edge
35187               FIX011:
35188 E118 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
35189               
35190                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this edge into A, so:
     **** ****     > LD_IND_Y_IDX
0001 E11A D820  50        movb @V,@rtmplb
     E11C 0022     
     E11E 2079     
0002 E120 D1A0  30        movb @V+1,rtmp
     E122 0023     
0003 E124 A182  18        a    ry,rtmp
0004 E126 D016  26        movb *rtmp,RA
                   < elite.a99
35191                                                                          ;
35192                                                                          ; A = %ffff ffff, where:
35193                                                                          ;
35194                                                                          ; * Bits 0-3 = the number of face 1
35195                                                                          ;
35196                                                                          ; * Bits 4-7 = the number of face 2
35197               
35198 E128 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
35199               
35200 E12A D800  30        movb ra,@P                      ; STA P             ; Store byte #1 into P
     E12C 001B     
35201               
35202 E12E 0240  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     E130 0F00     
35203 E132 D040  18        movb ra,rx                      ; TAX
35204               
35205 E134 D021  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     E136 00D2     
35206 E138 160A  14        jne  LL79                       ; BNE LL79          ; face 1 is visible, so jump to LL79
35207               
35208 E13A D020  30        movb @P,ra                      ; LDA P             ; Fetch byte #1 for this edge into A
     E13C 001B     
35209               
35210 E13E 0910  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 2
35211 E140 0910  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
35212 E142 0910  18        srl  ra,1                       ; LSR A
35213 E144 0910  18        srl  ra,1                       ; LSR A
35214 E146 D040  18        movb ra,rx                      ; TAX
35215               
35216 E148 D021  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is zero then we decided in part 5 that
     E14A 00D2     
35217 E14C 1368  14        jeq  LL78                       ; BEQ LL78          ; face 2 is hidden, so jump to LL78
35218               
35219               LL79:
35220                                                                          ; We now build the screen line for this edge, as
35221                                                                          ; follows:
35222                                                                          ;
35223                                                                          ; XX15(1 0) = start x-coordinate
35224                                                                          ;
35225                                                                          ; XX15(3 2) = start y-coordinate
35226                                                                          ;
35227                                                                          ; XX15(5 4) = end x-coordinate
35228                                                                          ;
35229                                                                          ; XX12(1 0) = end y-coordinate
35230                                                                          ;
35231                                                                          ; We can then pass this to the line clipping routine
35232                                                                          ; before storing the resulting line in the ship line
35233                                                                          ; heap
35234                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this edge into X, which contains
     **** ****     > LD_IND_Y_IDX
0001 E14E D820  50        movb @V,@rtmplb
     E150 0022     
     E152 2079     
0002 E154 D1A0  30        movb @V+1,rtmp
     E156 0023     
0003 E158 A182  18        a    ry,rtmp
0004 E15A D016  26        movb *rtmp,RA
                   < elite.a99
35235 E15C D040  18        movb ra,rx                      ; TAX               ; the number of the vertex at the start of the edge
35236               
35237 E15E B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
35238               
35239                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this edge into Q, which contains
     **** ****     > LD_IND_Y_IDX
0001 E160 D820  50        movb @V,@rtmplb
     E162 0022     
     E164 2079     
0002 E166 D1A0  30        movb @V+1,rtmp
     E168 0023     
0003 E16A A182  18        a    ry,rtmp
0004 E16C D016  26        movb *rtmp,RA
                   < elite.a99
35240 E16E D800  30        movb ra,@Q                      ; STA Q             ; the number of the vertex at the end of the edge
     E170 0090     
35241               
35242 E172 D021  34        movb @XX3+1(rx),ra              ; LDA XX3+1,X       ; Fetch the x_hi coordinate of the edge's start vertex
     E174 0101     
35243 E176 D800  30        movb ra,@XX15+1                 ; STA XX15+1        ; from the XX3 heap into XX15+1
     E178 0032     
35244               
35245 E17A D021  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Fetch the x_lo coordinate of the edge's start vertex
     E17C 0100     
35246 E17E D800  30        movb ra,@XX15                   ; STA XX15          ; from the XX3 heap into XX15
     E180 0031     
35247               
35248 E182 D021  34        movb @XX3+2(rx),ra              ; LDA XX3+2,X       ; Fetch the y_lo coordinate of the edge's start vertex
     E184 0102     
35249 E186 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; from the XX3 heap into XX15+2
     E188 0033     
35250               
35251 E18A D021  34        movb @XX3+3(rx),ra              ; LDA XX3+3,X       ; Fetch the y_hi coordinate of the edge's start vertex
     E18C 0103     
35252 E18E D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; from the XX3 heap into XX15+3
     E190 0034     
35253               
35254 E192 D060  30        movb @Q,rx                      ; LDX Q             ; Set X to the number of the vertex at the end of the
     E194 0090     
35255                                                                          ; edge, which we stored in Q
35256               
35257 E196 D021  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Fetch the x_lo coordinate of the edge's end vertex
     E198 0100     
35258 E19A D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; from the XX3 heap into XX15+4
     E19C 0035     
35259               
35260 E19E D021  34        movb @XX3+3(rx),ra              ; LDA XX3+3,X       ; Fetch the y_hi coordinate of the edge's end vertex
     E1A0 0103     
35261 E1A2 D800  30        movb ra,@XX12+1                 ; STA XX12+1        ; from the XX3 heap into XX12+1
     E1A4 0038     
35262               
35263 E1A6 D021  34        movb @XX3+2(rx),ra              ; LDA XX3+2,X       ; Fetch the y_lo coordinate of the edge's end vertex
     E1A8 0102     
35264 E1AA D800  30        movb ra,@XX12                   ; STA XX12          ; from the XX3 heap into XX12
     E1AC 0037     
35265               
35266 E1AE D021  34        movb @XX3+1(rx),ra              ; LDA XX3+1,X       ; Fetch the x_hi coordinate of the edge's end vertex
     E1B0 0101     
35267 E1B2 D800  30        movb ra,@XX15+5                 ; STA XX15+5        ; from the XX3 heap into XX15+5
     E1B4 0036     
35268               
35269 E1B6 0206  20        li   rtmp,LL147                 ; JSR LL147         ; Call LL147 to see if the new line segment needs to be
     E1B8 E578     
35270 E1BA 06A0  32        bl   @jsr                       ;
     E1BC FF10     
35271                                                                          ; clipped to fit on-screen, returning the clipped line's
35272                                                                          ; end-points in (X1, Y1) and (X2, Y2)
35273               
35274 E1BE 182F  14        joc  LL78                       ; BCS LL78          ; If the C flag is set then the line is not visible on
35275                                                                          ; screen, so jump to LL78 so we don't store this line
35276                                                                          ; in the ship line heap
35277               
35278               * ******************************************************************************
35279               *
35280               * Name: LL9 (Part 11 of 12)
35281               * Type: Subroutine
35282               * Category: Drawing ships
35283               * Summary: Draw ship: Add all visible edges to the ship line heap
35284               * Deep dive: Drawing ships
35285               *
35286               * ------------------------------------------------------------------------------
35287               *
35288               * This part adds all the visible edges to the ship line heap, so we can draw
35289               * them in part 12.
35290               *
35291               * Other entry points:
35292               *
35293               * LL81+2              Draw the contents of the ship line heap, used to draw
35294               * the ship as a dot from SHPPT
35295               *
35296               * ******************************************************************************
35297               
35298               LL80:
35299 E1C0 D0A0  30        movb @U,ry                      ; LDY U             ; Fetch the ship line heap pointer, which points to the
     E1C2 008F     
35300                                                                          ; next free byte on the heap, into Y
35301               
35302 E1C4 D020  30        movb @XX15,ra                   ; LDA XX15          ; Add X1 to the end of the heap
     E1C6 0031     
35303                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E1C8 D820  50        movb @XX19,@rtmplb
     E1CA 0074     
     E1CC 2079     
0002 E1CE D1A0  30        movb @XX19+1,rtmp
     E1D0 0075     
0003 E1D2 A182  18        a    ry,rtmp
0004 E1D4 D580  30        movb RA,*rtmp
                   < elite.a99
35304               
35305 E1D6 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35306               
35307 E1D8 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Add Y1 to the end of the heap
     E1DA 0032     
35308                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E1DC D820  50        movb @XX19,@rtmplb
     E1DE 0074     
     E1E0 2079     
0002 E1E2 D1A0  30        movb @XX19+1,rtmp
     E1E4 0075     
0003 E1E6 A182  18        a    ry,rtmp
0004 E1E8 D580  30        movb RA,*rtmp
                   < elite.a99
35309               
35310 E1EA B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35311               
35312 E1EC D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Add X2 to the end of the heap
     E1EE 0033     
35313                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E1F0 D820  50        movb @XX19,@rtmplb
     E1F2 0074     
     E1F4 2079     
0002 E1F6 D1A0  30        movb @XX19+1,rtmp
     E1F8 0075     
0003 E1FA A182  18        a    ry,rtmp
0004 E1FC D580  30        movb RA,*rtmp
                   < elite.a99
35314               
35315 E1FE B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35316               
35317 E200 D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Add Y2 to the end of the heap
     E202 0034     
35318                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E204 D820  50        movb @XX19,@rtmplb
     E206 0074     
     E208 2079     
0002 E20A D1A0  30        movb @XX19+1,rtmp
     E20C 0075     
0003 E20E A182  18        a    ry,rtmp
0004 E210 D580  30        movb RA,*rtmp
                   < elite.a99
35319               
35320 E212 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35321               
35322 E214 D802  30        movb ry,@U                      ; STY U             ; Store the updated ship line heap pointer in U
     E216 008F     
35323               
35324 E218 90A0  30        cb   @T1,ry                     ; CPY T1            ; If Y >= T1 then we have reached the maximum number of
     E21A 0006     
35325 E21C 1814  14        joc  LL81                       ; BCS LL81          ; edge lines that we can store in the ship line heap, so
35326                                                                          ; skip to LL81 so we don't loop back for the next edge
35327               
35328               LL78:
35329 E21E B004  18        ab   rone,ra                    ; INC XX17          ; Increment the edge counter to point to the next edge
35330               
35331 E220 D0A0  30        movb @XX17,ry                   ; LDY XX17          ; If Y >= XX20, which contains the number of edges in
     E222 0095     
35332 E224 90A0  30        cb   @XX20,ry                   ; CPY XX20          ; the blueprint, jump to LL81 as we have processed all
     E226 00A8     
35333 E228 180E  14        joc  LL81                       ; BCS LL81          ; the edges and don't need to loop back for the next one
35334               
35335 E22A 0202  20        li   ry,>00*256                 ; LDY #0            ; Set Y to point to byte #0 again, ready for the next
     E22C 0000     
35336                                                                          ; edge
35337               
35338 E22E D020  30        movb @V,ra                      ; LDA V             ; Increment V by 4 so V(1 0) points to the data for the
     E230 0022     
35339                      .adi (>04*256)                  ; ADC #4            ; next edge
     **** ****     > ADI
0001 E232 1701  14        jnc  !
0002 E234 B004  18        ab   rone,ra
0003               !:
0004 E236 0220  22        ai   ra,(>04*256)
     E238 0400     
                   < elite.a99
35340 E23A D800  30        movb ra,@V                      ; STA V
     E23C 0022     
35341               
35342 E23E 1701  14        jnc  ll81_                      ; BCC ll81          ; If the above addition didn't overflow, jump to ll81 to
35343                                                                          ; skip the following instruction
35344               
35345 E240 B004  18        ab   rone,ra                    ; INC V+1           ; Otherwise increment the high byte of V(1 0), as we
35346                                                                          ; just moved the V(1 0) pointer past a page boundary
35347               
35348               ll81_:
35349 E242 0460  28        b    @LL75                      ; JMP LL75          ; Loop back to LL75 to process the next edge
     E244 E100     
35350               
35351               LL81:
35352                                                                          ; We have finished adding lines to the ship line heap,
35353                                                                          ; so now we need to set the first byte of the heap to
35354                                                                          ; the number of bytes stored there
35355 E246 D020  30        movb @U,ra                      ; LDA U             ; Fetch the ship line heap pointer from U into A, which
     E248 008F     
35356                                                                          ; points to the end of the heap, and therefore contains
35357                                                                          ; the heap size
35358               
35359 E24A 0202  20        li   ry,>00*256                 ; LDY #0            ; Store A as the first byte of the ship line heap, so
     E24C 0000     
35360                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; the heap is now correctly set up
     **** ****     > ST_IND_Y_IDX
0001 E24E D820  50        movb @XX19,@rtmplb
     E250 0074     
     E252 2079     
0002 E254 D1A0  30        movb @XX19+1,rtmp
     E256 0075     
0003 E258 A182  18        a    ry,rtmp
0004 E25A D580  30        movb RA,*rtmp
                   < elite.a99
35361               
35362               * ******************************************************************************
35363               *
35364               * Name: LL9 (Part 12 of 12)
35365               * Type: Subroutine
35366               * Category: Drawing ships
35367               * Summary: Draw ship: Draw all the visible edges from the ship line heap
35368               * Deep dive: Drawing ships
35369               *
35370               * ------------------------------------------------------------------------------
35371               *
35372               * This part draws the lines in the ship line heap, which is used both to draw
35373               * the ship, and to remove it from the screen.
35374               *
35375               * ******************************************************************************
35376               
35377               LL155:
35378 E25C 0202  20        li   ry,>00*256                 ; LDY #0            ; Fetch the first byte from the ship line heap into A,
     E25E 0000     
35379                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; which contains the number of bytes in the heap
     **** ****     > LD_IND_Y_IDX
0001 E260 D820  50        movb @XX19,@rtmplb
     E262 0074     
     E264 2079     
0002 E266 D1A0  30        movb @XX19+1,rtmp
     E268 0075     
0003 E26A A182  18        a    ry,rtmp
0004 E26C D016  26        movb *rtmp,RA
                   < elite.a99
35380               
35381 E26E D800  30        movb ra,@XX20                   ; STA XX20          ; Store the heap size in XX20
     E270 00A8     
35382               
35383 E272 0280  22        ci   ra,>04*256                 ; CMP #4            ; If the heap size is less than 4, there is nothing to
     E274 0400     
35384 E276 1731  14        jnc  LL118-1                    ; BCC LL118-1       ; draw, so return from the subroutine (as LL118-1
35385                                                                          ; contains an RTS)
35386               
35387 E278 B084  18        ab   rone,ry                    ; INY               ; Set Y = 1, which we will use as an index into the ship
35388                                                                          ; line heap, starting at byte #1 (as byte #0 contains
35389                                                                          ; the heap size)
35390               
35391               LL27:
35392                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the X1 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 E27A D820  50        movb @XX19,@rtmplb
     E27C 0074     
     E27E 2079     
0002 E280 D1A0  30        movb @XX19+1,rtmp
     E282 0075     
0003 E284 A182  18        a    ry,rtmp
0004 E286 D016  26        movb *rtmp,RA
                   < elite.a99
35393 E288 D800  30        movb ra,@XX15                   ; STA XX15          ; it in XX15
     E28A 0031     
35394               
35395 E28C B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35396               
35397                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y1 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 E28E D820  50        movb @XX19,@rtmplb
     E290 0074     
     E292 2079     
0002 E294 D1A0  30        movb @XX19+1,rtmp
     E296 0075     
0003 E298 A182  18        a    ry,rtmp
0004 E29A D016  26        movb *rtmp,RA
                   < elite.a99
35398 E29C D800  30        movb ra,@XX15+1                 ; STA XX15+1        ; it in XX15+1
     E29E 0032     
35399               
35400 E2A0 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35401               
35402                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the X2 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 E2A2 D820  50        movb @XX19,@rtmplb
     E2A4 0074     
     E2A6 2079     
0002 E2A8 D1A0  30        movb @XX19+1,rtmp
     E2AA 0075     
0003 E2AC A182  18        a    ry,rtmp
0004 E2AE D016  26        movb *rtmp,RA
                   < elite.a99
35403 E2B0 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; it in XX15+2
     E2B2 0033     
35404               
35405 E2B4 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35406               
35407                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y2 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 E2B6 D820  50        movb @XX19,@rtmplb
     E2B8 0074     
     E2BA 2079     
0002 E2BC D1A0  30        movb @XX19+1,rtmp
     E2BE 0075     
0003 E2C0 A182  18        a    ry,rtmp
0004 E2C2 D016  26        movb *rtmp,RA
                   < elite.a99
35408 E2C4 D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; it in XX15+3
     E2C6 0034     
35409               
35410 E2C8 0206  20        li   rtmp,LL30                  ; JSR LL30          ; Draw a line from (X1, Y1) to (X2, Y2)
     E2CA 224E     
35411 E2CC 06A0  32        bl   @jsr                       ;
     E2CE FF10     
35412               
35413 E2D0 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35414               
35415 E2D2 90A0  30        cb   @XX20,ry                   ; CPY XX20          ; If the heap counter is less than the size of the heap,
     E2D4 00A8     
35416 E2D6 17D1  14        jnc  LL27                       ; BCC LL27          ; loop back to LL27 to draw the next line from the heap
35417               
35418               * .LL82                  \ This label is commented out in the original source
35419               
35420 E2D8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E2DA FF1C     
35421               
35422               * ******************************************************************************
35423               *
35424               * Name: LL118
35425               * Type: Subroutine
35426               * Category: Drawing lines
35427               * Summary: Move a point along a line until it is on-screen
35428               * Deep dive: Line-clipping
35429               *
35430               * ------------------------------------------------------------------------------
35431               *
35432               * Given a point (x1, y1), a gradient and a direction of slope, move the point
35433               * along the line until it is on-screen, so this effectively clips the (x1, y1)
35434               * end of a line to be on the screen.
35435               *
35436               * See the deep dive on "Line-clipping" for more details.
35437               *
35438               * ------------------------------------------------------------------------------
35439               *
35440               * Arguments:
35441               *
35442               * XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
35443               *
35444               * XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
35445               *
35446               * XX12+2              The line's gradient * 256 (so 1.0 = 256)
35447               *
35448               * XX12+3              The direction of slope:
35449               *
35450               * * Positive (bit 7 clear) = top left to bottom right
35451               *
35452               * * Negative (bit 7 set) = top right to bottom left
35453               *
35454               * T                   The gradient of slope:
35455               *
35456               * * 0 if it's a shallow slope
35457               *
35458               * * &FF if it's a steep slope
35459               *
35460               * ------------------------------------------------------------------------------
35461               *
35462               * Returns:
35463               *
35464               * XX15                x1 as an 8-bit coordinate
35465               *
35466               * XX15+2              y1 as an 8-bit coordinate
35467               *
35468               * ------------------------------------------------------------------------------
35469               *
35470               * Other entry points:
35471               *
35472               * LL118-1             Contains an RTS
35473               *
35474               * ******************************************************************************
35475               
35476               LL118:
35477 E2DC D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If x1_hi is positive, jump down to LL119 to skip the
     E2DE 0032     
35478 E2E0 151C  14        jgt  LL119                      ; BPL LL119         ; following
35479               
35480 E2E2 D800  30        movb ra,@S                      ; STA S             ; Otherwise x1_hi is negative, i.e. off the left of the
     E2E4 0092     
35481                                                                          ; screen, so set S = x1_hi
35482               
35483 E2E6 0206  20        li   rtmp,LL120                 ; JSR LL120         ; Call LL120 to calculate:
     E2E8 E3F8     
35484 E2EA 06A0  32        bl   @jsr                       ;
     E2EC FF10     
35485                                                                          ;
35486                                                                          ; (Y X) = (S x1_lo) * XX12+2      if T = 0
35487                                                                          ; = x1 * gradient
35488                                                                          ;
35489                                                                          ; (Y X) = (S x1_lo) / XX12+2      if T <> 0
35490                                                                          ; = x1 / gradient
35491                                                                          ;
35492                                                                          ; with the sign of (Y X) set to the opposite of the
35493                                                                          ; line's direction of slope
35494               
35495 E2EE D001  18        movb rx,ra                      ; TXA               ; Set y1 = y1 + (Y X)
35496                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E2F0 0A13  18        sla  rzero,1
                   < elite.a99
35497                      .adc @XX15+2,ra                 ; ADC XX15+2        ; starting with the low bytes
     **** ****     > ADC
0001 E2F2 1701  14        jnc  !
0002 E2F4 B004  18        ab   rone,ra
0003               !:
0004 E2F6 B020  30        ab   @XX15+2,ra
     E2F8 0033     
                   < elite.a99
35498 E2FA D800  30        movb ra,@XX15+2                 ; STA XX15+2
     E2FC 0033     
35499               
35500 E2FE D002  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35501                      .adc @XX15+3,ra                 ; ADC XX15+3
     **** ****     > ADC
0001 E300 1701  14        jnc  !
0002 E302 B004  18        ab   rone,ra
0003               !:
0004 E304 B020  30        ab   @XX15+3,ra
     E306 0034     
                   < elite.a99
35502 E308 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     E30A 0034     
35503               
35504 E30C 0200  20        li   ra,>00*256                 ; LDA #0            ; Set x1 = 0
     E30E 0000     
35505 E310 D800  30        movb ra,@XX15                   ; STA XX15
     E312 0031     
35506 E314 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     E316 0032     
35507               
35508 E318 D040  18        movb ra,rx                      ; TAX               ; Set X = 0 so the next instruction becomes a JMP
35509               
35510               LL119:
35511 E31A 131D  14        jeq  LL134                      ; BEQ LL134         ; If x1_hi = 0 then jump down to LL134 to skip the
35512                                                                          ; following, as the x-coordinate is already on-screen
35513                                                                          ; (as 0 <= (x_hi x_lo) <= 255)
35514               
35515 E31C D800  30        movb ra,@S                      ; STA S             ; Otherwise x1_hi is positive, i.e. x1 >= 256 and off
     E31E 0092     
35516 E320 7004  18        sb   rone,ra                    ; DEC S             ; the right side of the screen, so set S = x1_hi - 1
35517               
35518 E322 0206  20        li   rtmp,LL120                 ; JSR LL120         ; Call LL120 to calculate:
     E324 E3F8     
35519 E326 06A0  32        bl   @jsr                       ;
     E328 FF10     
35520                                                                          ;
35521                                                                          ; (Y X) = (S x1_lo) * XX12+2      if T = 0
35522                                                                          ; = (x1 - 256) * gradient
35523                                                                          ;
35524                                                                          ; (Y X) = (S x1_lo) / XX12+2      if T <> 0
35525                                                                          ; = (x1 - 256) / gradient
35526                                                                          ;
35527                                                                          ; with the sign of (Y X) set to the opposite of the
35528                                                                          ; line's direction of slope
35529               
35530 E32A D001  18        movb rx,ra                      ; TXA               ; Set y1 = y1 + (Y X)
35531                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E32C 0A13  18        sla  rzero,1
                   < elite.a99
35532                      .adc @XX15+2,ra                 ; ADC XX15+2        ; starting with the low bytes
     **** ****     > ADC
0001 E32E 1701  14        jnc  !
0002 E330 B004  18        ab   rone,ra
0003               !:
0004 E332 B020  30        ab   @XX15+2,ra
     E334 0033     
                   < elite.a99
35533 E336 D800  30        movb ra,@XX15+2                 ; STA XX15+2
     E338 0033     
35534               
35535 E33A D002  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35536                      .adc @XX15+3,ra                 ; ADC XX15+3
     **** ****     > ADC
0001 E33C 1701  14        jnc  !
0002 E33E B004  18        ab   rone,ra
0003               !:
0004 E340 B020  30        ab   @XX15+3,ra
     E342 0034     
                   < elite.a99
35537 E344 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     E346 0034     
35538               
35539 E348 0201  20        li   rx,>ff*256                 ; LDX #255          ; Set x1 = 255
     E34A FF00     
35540 E34C D801  30        movb rx,@XX15                   ; STX XX15
     E34E 0031     
35541 E350 B044  18        ab   rone,rx                    ; INX
35542 E352 D801  30        movb rx,@XX15+1                 ; STX XX15+1
     E354 0032     
35543               
35544               LL134:
35545                                                                          ; We have moved the point so the x-coordinate is on
35546                                                                          ; screen (i.e. in the range 0-255), so now for the
35547                                                                          ; y-coordinate
35548 E356 D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; If y1_hi is positive, jump down to LL119 to skip
     E358 0034     
35549 E35A 151F  14        jgt  LL135                      ; BPL LL135         ; the following
35550               
35551 E35C D800  30        movb ra,@S                      ; STA S             ; Otherwise y1_hi is negative, i.e. off the top of the
     E35E 0092     
35552                                                                          ; screen, so set S = y1_hi
35553               
35554 E360 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set R = y1_lo
     E362 0033     
35555 E364 D800  30        movb ra,@R                      ; STA R
     E366 0091     
35556               
35557 E368 0206  20        li   rtmp,LL123                 ; JSR LL123         ; Call LL123 to calculate:
     E36A E484     
35558 E36C 06A0  32        bl   @jsr                       ;
     E36E FF10     
35559                                                                          ;
35560                                                                          ; (Y X) = (S R) / XX12+2      if T = 0
35561                                                                          ; = y1 / gradient
35562                                                                          ;
35563                                                                          ; (Y X) = (S R) * XX12+2      if T <> 0
35564                                                                          ; = y1 * gradient
35565                                                                          ;
35566                                                                          ; with the sign of (Y X) set to the opposite of the
35567                                                                          ; line's direction of slope
35568               
35569 E370 D001  18        movb rx,ra                      ; TXA               ; Set x1 = x1 + (Y X)
35570                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E372 0A13  18        sla  rzero,1
                   < elite.a99
35571                      .adc @XX15,ra                   ; ADC XX15          ; starting with the low bytes
     **** ****     > ADC
0001 E374 1701  14        jnc  !
0002 E376 B004  18        ab   rone,ra
0003               !:
0004 E378 B020  30        ab   @XX15,ra
     E37A 0031     
                   < elite.a99
35572 E37C D800  30        movb ra,@XX15                   ; STA XX15
     E37E 0031     
35573               
35574 E380 D002  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35575                      .adc @XX15+1,ra                 ; ADC XX15+1
     **** ****     > ADC
0001 E382 1701  14        jnc  !
0002 E384 B004  18        ab   rone,ra
0003               !:
0004 E386 B020  30        ab   @XX15+1,ra
     E388 0032     
                   < elite.a99
35576 E38A D800  30        movb ra,@XX15+1                 ; STA XX15+1
     E38C 0032     
35577               
35578 E38E 0200  20        li   ra,>00*256                 ; LDA #0            ; Set y1 = 0
     E390 0000     
35579 E392 D800  30        movb ra,@XX15+2                 ; STA XX15+2
     E394 0033     
35580 E396 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     E398 0034     
35581               
35582               LL135:
35583               * BNE LL139              \ This instruction is commented out in the original
35584                                                                          ; source
35585 E39A D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set (S R) = (y1_hi y1_lo) - screen height
     E39C 0033     
35586                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 E39E 0A15  18        sla  rmone,1
                   < elite.a99
35587                      .sbi ((Y*2)*256)                ; SBC #Y*2          ; starting with the low bytes
     **** ****     > SBI
0001 E3A0 1801  14        joc  !
0002 E3A2 7004  18        sb   rone,ra
0003               !:
0004 E3A4 0220  22        ai   ra,-((Y*2)*256)
     E3A6 4000     
                   < elite.a99
35588 E3A8 D800  30        movb ra,@R                      ; STA R
     E3AA 0091     
35589               
35590 E3AC D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; And then subtracting the high bytes
     E3AE 0034     
35591                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 E3B0 1801  14        joc  !
0002 E3B2 7004  18        sb   rone,ra
0003               !:
0004 E3B4 0220  22        ai   ra,-(>00*256)
     E3B6 0000     
                   < elite.a99
35592 E3B8 D800  30        movb ra,@S                      ; STA S
     E3BA 0092     
35593               
35594 E3BC 171B  14        jnc  LL136                      ; BCC LL136         ; If the subtraction underflowed, i.e. if y1 < screen
35595                                                                          ; height, then y1 is already on-screen, so jump to LL136
35596                                                                          ; to return from the subroutine, as we are done
35597               
35598               LL139:
35599                                                                          ; If we get here then y1 >= screen height, i.e. off the
35600                                                                          ; bottom of the screen
35601 E3BE 0206  20        li   rtmp,LL123                 ; JSR LL123         ; Call LL123 to calculate:
     E3C0 E484     
35602 E3C2 06A0  32        bl   @jsr                       ;
     E3C4 FF10     
35603                                                                          ;
35604                                                                          ; (Y X) = (S R) / XX12+2      if T = 0
35605                                                                          ; = (y1 - screen height) / gradient
35606                                                                          ;
35607                                                                          ; (Y X) = (S R) * XX12+2      if T <> 0
35608                                                                          ; = (y1 - screen height) * gradient
35609                                                                          ;
35610                                                                          ; with the sign of (Y X) set to the opposite of the
35611                                                                          ; line's direction of slope
35612               
35613 E3C6 D001  18        movb rx,ra                      ; TXA               ; Set x1 = x1 + (Y X)
35614                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E3C8 0A13  18        sla  rzero,1
                   < elite.a99
35615                      .adc @XX15,ra                   ; ADC XX15          ; starting with the low bytes
     **** ****     > ADC
0001 E3CA 1701  14        jnc  !
0002 E3CC B004  18        ab   rone,ra
0003               !:
0004 E3CE B020  30        ab   @XX15,ra
     E3D0 0031     
                   < elite.a99
35616 E3D2 D800  30        movb ra,@XX15                   ; STA XX15
     E3D4 0031     
35617               
35618 E3D6 D002  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35619                      .adc @XX15+1,ra                 ; ADC XX15+1
     **** ****     > ADC
0001 E3D8 1701  14        jnc  !
0002 E3DA B004  18        ab   rone,ra
0003               !:
0004 E3DC B020  30        ab   @XX15+1,ra
     E3DE 0032     
                   < elite.a99
35620 E3E0 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     E3E2 0032     
35621               
35622 E3E4 0200  20        li   ra,(Y*2-1)*256             ; LDA #Y*2-1        ; Set y1 = 2 * #Y - 1. The constant #Y is 96, the
     E3E6 BF00     
35623 E3E8 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; y-coordinate of the mid-point of the space view, so
     E3EA 0033     
35624 E3EC 0200  20        li   ra,>00*256                 ; LDA #0            ; this sets Y2 to 191, the y-coordinate of the bottom
     E3EE 0000     
35625 E3F0 D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; pixel row of the space view
     E3F2 0034     
35626               
35627               LL136:
35628 E3F4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E3F6 FF1C     
35629               
35630               * ******************************************************************************
35631               *
35632               * Name: LL120
35633               * Type: Subroutine
35634               * Category: Maths (Arithmetic)
35635               * Summary: Calculate (Y X) = (S x1_lo) * XX12+2 or (S x1_lo) / XX12+2
35636               *
35637               * ------------------------------------------------------------------------------
35638               *
35639               * Calculate the following:
35640               *
35641               * * If T = 0, this is a shallow slope, so calculate (Y X) = (S x1_lo) * XX12+2
35642               *
35643               * * If T <> 0, this is a steep slope, so calculate (Y X) = (S x1_lo) / XX12+2
35644               *
35645               * giving (Y X) the opposite sign to the slope direction in XX12+3.
35646               *
35647               * ------------------------------------------------------------------------------
35648               *
35649               * Arguments:
35650               *
35651               * T                   The gradient of slope:
35652               *
35653               * * 0 if it's a shallow slope
35654               *
35655               * * &FF if it's a steep slope
35656               *
35657               * ------------------------------------------------------------------------------
35658               *
35659               * Other entry points:
35660               *
35661               * LL122               Calculate (Y X) = (S R) * Q and set the sign to the
35662               * opposite of the top byte on the stack
35663               *
35664               * ******************************************************************************
35665               
35666               LL120:
35667 E3F8 D020  30        movb @XX15,ra                   ; LDA XX15          ; Set R = x1_lo
     E3FA 0031     
35668 E3FC D800  30        movb ra,@R                      ; STA R
     E3FE 0091     
35669               
35670               * .LL120                 \ This label is commented out in the original source
35671               
35672 E400 0206  20        li   rtmp,LL129                 ; JSR LL129         ; Call LL129 to do the following:
     E402 E524     
35673 E404 06A0  32        bl   @jsr                       ;
     E406 FF10     
35674                                                                          ;
35675                                                                          ; Q = XX12+2
35676                                                                          ; = line gradient
35677                                                                          ;
35678                                                                          ; A = S EOR XX12+3
35679                                                                          ; = S EOR slope direction
35680                                                                          ;
35681                                                                          ; (S R) = |S R|
35682                                                                          ;
35683                                                                          ; So A contains the sign of S * slope direction
35684               
35685                      .pha                            ; PHA               ; Store A on the stack so we can use it later
     **** ****     > PHA
0001 E408 D680  30        movb ra,*rsp
0002 E40A 060A  14        dec  rsp
                   < elite.a99
35686               
35687 E40C D060  30        movb @T,rx                      ; LDX T             ; If T is non-zero, then it's a steep slope, so jump
     E40E 00D1     
35688 E410 1642  14        jne  LL121                      ; BNE LL121         ; down to LL121 to calculate this instead:
35689                                                                          ;
35690                                                                          ; (Y X) = (S R) / Q
35691               
35692               LL122:
35693                                                                          ; The following calculates:
35694                                                                          ;
35695                                                                          ; (Y X) = (S R) * Q
35696                                                                          ;
35697                                                                          ; using the same shift-and-add algorithm that's
35698                                                                          ; documented in MULT1
35699 E412 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     E414 0000     
35700               
35701 E416 D040  18        movb ra,rx                      ; TAX               ; Set (Y X) = 0 so we can start building the answer here
35702 E418 D080  18        movb ra,ry                      ; TAY
35703               
35704                      .lsr @S                         ; LSR S             ; Shift (S R) to the right, so we extract bit 0 of (S R)
     **** ****     > LSR
0001 E41A D1A0  30        movb @S,rtmp
     E41C 0092     
0002 E41E 0916  18        srl  rtmp,1
0003 E420 D806  30        movb rtmp,@S
     E422 0092     
                   < elite.a99
35705 E424 0208  20        li   rarg1,R                    ; ROR R             ; into the C flag
     E426 0091     
35706 E428 06A0  32        bl   @ror                       ;
     E42A FF62     
35707               
35708                      .asl @Q                         ; ASL Q             ; Shift Q to the left, catching bit 7 in the C flag
     **** ****     > ASL
0001 E42C D1A0  30        movb @Q,rtmp
     E42E 0090     
0002 E430 0246  22        andi rtmp,>ff00
     E432 FF00     
0003 E434 0A16  18        sla  rtmp,1
0004 E436 D806  30        movb rtmp,@Q
     E438 0090     
                   < elite.a99
35709               
35710 E43A 170D  14        jnc  LL126                      ; BCC LL126         ; If C (i.e. the next bit from Q) is clear, do not do
35711                                                                          ; the addition for this bit of Q, and instead skip to
35712                                                                          ; LL126 to just do the shifts
35713               
35714               LL125:
35715 E43C D001  18        movb rx,ra                      ; TXA               ; Set (Y X) = (Y X) + (S R)
35716                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E43E 0A13  18        sla  rzero,1
                   < elite.a99
35717                      .adc @R,ra                      ; ADC R             ; starting with the low bytes
     **** ****     > ADC
0001 E440 1701  14        jnc  !
0002 E442 B004  18        ab   rone,ra
0003               !:
0004 E444 B020  30        ab   @R,ra
     E446 0091     
                   < elite.a99
35718 E448 D040  18        movb ra,rx                      ; TAX
35719               
35720 E44A D002  18        movb ry,ra                      ; TYA               ; And then doing the high bytes
35721                      .adc @S,ra                      ; ADC S
     **** ****     > ADC
0001 E44C 1701  14        jnc  !
0002 E44E B004  18        ab   rone,ra
0003               !:
0004 E450 B020  30        ab   @S,ra
     E452 0092     
                   < elite.a99
35722 E454 D080  18        movb ra,ry                      ; TAY
35723               
35724               LL126:
35725                      .lsr @S                         ; LSR S             ; Shift (S R) to the right
     **** ****     > LSR
0001 E456 D1A0  30        movb @S,rtmp
     E458 0092     
0002 E45A 0916  18        srl  rtmp,1
0003 E45C D806  30        movb rtmp,@S
     E45E 0092     
                   < elite.a99
35726 E460 0208  20        li   rarg1,R                    ; ROR R
     E462 0091     
35727 E464 06A0  32        bl   @ror                       ;
     E466 FF62     
35728               
35729                      .asl @Q                         ; ASL Q             ; Shift Q to the left, catching bit 7 in the C flag
     **** ****     > ASL
0001 E468 D1A0  30        movb @Q,rtmp
     E46A 0090     
0002 E46C 0246  22        andi rtmp,>ff00
     E46E FF00     
0003 E470 0A16  18        sla  rtmp,1
0004 E472 D806  30        movb rtmp,@Q
     E474 0090     
                   < elite.a99
35730               
35731 E476 18E2  14        joc  LL125                      ; BCS LL125         ; If C (i.e. the next bit from Q) is set, loop back to
35732                                                                          ; LL125 to do the addition for this bit of Q
35733               
35734 E478 16EE  14        jne  LL126                      ; BNE LL126         ; If Q has not yet run out of set bits, loop back to
35735                                                                          ; LL126 to do the "shift" part of shift-and-add until
35736                                                                          ; we have done additions for all the set bits in Q, to
35737                                                                          ; give us our multiplication result
35738               
35739                      .pla                            ; PLA               ; Restore A, which we calculated above, from the stack
     **** ****     > PLA
0001 E47A 058A  14        inc  rsp
0002 E47C D01A  26        movb *rsp,ra
                   < elite.a99
35740               
35741 E47E 153E  14        jgt  LL133                      ; BPL LL133         ; If A is positive jump to LL133 to negate (Y X) and
35742                                                                          ; return from the subroutine using a tail call
35743               
35744 E480 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E482 FF1C     
35745               
35746               * ******************************************************************************
35747               *
35748               * Name: LL123
35749               * Type: Subroutine
35750               * Category: Maths (Arithmetic)
35751               * Summary: Calculate (Y X) = (S R) / XX12+2 or (S R) * XX12+2
35752               *
35753               * ------------------------------------------------------------------------------
35754               *
35755               * Calculate the following:
35756               *
35757               * * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2
35758               *
35759               * * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2
35760               *
35761               * giving (Y X) the opposite sign to the slope direction in XX12+3.
35762               *
35763               * ------------------------------------------------------------------------------
35764               *
35765               * Arguments:
35766               *
35767               * XX12+2              The line's gradient * 256 (so 1.0 = 256)
35768               *
35769               * XX12+3              The direction of slope:
35770               *
35771               * * Bit 7 clear means top left to bottom right
35772               *
35773               * * Bit 7 set means top right to bottom left
35774               *
35775               * T                   The gradient of slope:
35776               *
35777               * * 0 if it's a shallow slope
35778               *
35779               * * &FF if it's a steep slope
35780               *
35781               * ------------------------------------------------------------------------------
35782               *
35783               * Other entry points:
35784               *
35785               * LL121               Calculate (Y X) = (S R) / Q and set the sign to the
35786               * opposite of the top byte on the stack
35787               *
35788               * LL133               Negate (Y X) and return from the subroutine
35789               *
35790               * LL128               Contains an RTS
35791               *
35792               * ******************************************************************************
35793               
35794               LL123:
35795 E484 0206  20        li   rtmp,LL129                 ; JSR LL129         ; Call LL129 to do the following:
     E486 E524     
35796 E488 06A0  32        bl   @jsr                       ;
     E48A FF10     
35797                                                                          ;
35798                                                                          ; Q = XX12+2
35799                                                                          ; = line gradient
35800                                                                          ;
35801                                                                          ; A = S EOR XX12+3
35802                                                                          ; = S EOR slope direction
35803                                                                          ;
35804                                                                          ; (S R) = |S R|
35805                                                                          ;
35806                                                                          ; So A contains the sign of S * slope direction
35807               
35808                      .pha                            ; PHA               ; Store A on the stack so we can use it later
     **** ****     > PHA
0001 E48C D680  30        movb ra,*rsp
0002 E48E 060A  14        dec  rsp
                   < elite.a99
35809               
35810 E490 D060  30        movb @T,rx                      ; LDX T             ; If T is non-zero, then it's a steep slope, so jump up
     E492 00D1     
35811 E494 16BE  14        jne  LL122                      ; BNE LL122         ; to LL122 to calculate this instead:
35812                                                                          ;
35813                                                                          ; (Y X) = (S R) * Q
35814               
35815               LL121:
35816                                                                          ; The following calculates:
35817                                                                          ;
35818                                                                          ; (Y X) = (S R) / Q
35819                                                                          ;
35820                                                                          ; using the same shift-and-subtract algorithm that's
35821                                                                          ; documented in TIS2
35822 E496 0200  20        li   ra,>ff*256                 ; LDA #%11111111    ; Set Y = %11111111
     E498 FF00     
35823 E49A D080  18        movb ra,ry                      ; TAY
35824               
35825                      .asla                           ; ASL A             ; Set X = %11111110
     **** ****     > ASLA
0001 E49C 0240  22        andi ra,>ff00
     E49E FF00     
0002 E4A0 0A10  18        sla  ra,1
                   < elite.a99
35826 E4A2 D040  18        movb ra,rx                      ; TAX
35827               
35828                                                                          ; This sets (Y X) = %1111111111111110, so we can rotate
35829                                                                          ; through 15 loop iterations, getting a 1 each time, and
35830                                                                          ; then getting a 0 on the 16th iteration... and we can
35831                                                                          ; also use it to catch our result bits into bit 0 each
35832                                                                          ; time
35833               
35834               LL130:
35835                      .asl @R                         ; ASL R             ; Shift (S R) to the left
     **** ****     > ASL
0001 E4A4 D1A0  30        movb @R,rtmp
     E4A6 0091     
0002 E4A8 0246  22        andi rtmp,>ff00
     E4AA FF00     
0003 E4AC 0A16  18        sla  rtmp,1
0004 E4AE D806  30        movb rtmp,@R
     E4B0 0091     
                   < elite.a99
35836 E4B2 0208  20        li   rarg1,S                    ; ROL S
     E4B4 0092     
35837 E4B6 06A0  32        bl   @rol                       ;
     E4B8 FF36     
35838               
35839 E4BA D020  30        movb @S,ra                      ; LDA S             ; Set A = S
     E4BC 0092     
35840               
35841 E4BE 1803  14        joc  LL131                      ; BCS LL131         ; If bit 7 of S was set, then jump straight to the
35842                                                                          ; subtraction
35843               
35844 E4C0 9020  30        cb   @Q,ra                      ; CMP Q             ; If A < Q (i.e. S < Q), skip the following subtractions
     E4C2 0090     
35845 E4C4 170F  14        jnc  LL132                      ; BCC LL132
35846               
35847               LL131:
35848                      .sbc @Q,ra                      ; SBC Q             ; A >= Q (i.e. S >= Q) so set:
     **** ****     > SBC
0001 E4C6 1801  14        joc  !
0002 E4C8 7004  18        sb   rone,ra
0003               !:
0004 E4CA 7020  30        sb   @Q,ra
     E4CC 0090     
                   < elite.a99
35849 E4CE D800  30        movb ra,@S                      ; STA S             ;
     E4D0 0092     
35850                                                                          ; S = (A R) - Q
35851                                                                          ; = (S R) - Q
35852                                                                          ;
35853                                                                          ; starting with the low bytes (we know the C flag is
35854                                                                          ; set so the subtraction will be correct)
35855               
35856 E4D2 D020  30        movb @R,ra                      ; LDA R             ; And then doing the high bytes
     E4D4 0091     
35857                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 E4D6 1801  14        joc  !
0002 E4D8 7004  18        sb   rone,ra
0003               !:
0004 E4DA 0220  22        ai   ra,-(>00*256)
     E4DC 0000     
                   < elite.a99
35858 E4DE D800  30        movb ra,@R                      ; STA R
     E4E0 0091     
35859               
35860                      .sec                            ; SEC               ; Set the C flag to rotate into the result in (Y X)
     **** ****     > SEC
0001 E4E2 0A15  18        sla  rmone,1
                   < elite.a99
35861               
35862               LL132:
35863 E4E4 D001  18        movb rx,ra                      ; TXA               ; Rotate the counter in (Y X) to the left, and catch the
35864 E4E6 06A0  32        bl   @rola                      ; ROL A             ; result bit into bit 0 (which will be a 0 if we didn't
     E4E8 FF26     
35865 E4EA D040  18        movb ra,rx                      ; TAX               ; do the subtraction, or 1 if we did)
35866 E4EC D002  18        movb ry,ra                      ; TYA
35867 E4EE 06A0  32        bl   @rola                      ; ROL A
     E4F0 FF26     
35868 E4F2 D080  18        movb ra,ry                      ; TAY
35869               
35870 E4F4 18D7  14        joc  LL130                      ; BCS LL130         ; If we still have set bits in (Y X), loop back to LL130
35871                                                                          ; to do the next iteration of 15, until we have done the
35872                                                                          ; whole division
35873               
35874                      .pla                            ; PLA               ; Restore A, which we calculated above, from the stack
     **** ****     > PLA
0001 E4F6 058A  14        inc  rsp
0002 E4F8 D01A  26        movb *rsp,ra
                   < elite.a99
35875               
35876 E4FA 1112  14        jlt  LL128                      ; BMI LL128         ; If A is negative jump to LL128 to return from the
35877                                                                          ; subroutine with (Y X) as is
35878               
35879               LL133:
35880 E4FC D001  18        movb rx,ra                      ; TXA               ; Otherwise negate (Y X) using two's complement by first
35881                      .eoi (>ff*256)                  ; EOR #%11111111    ; setting the low byte to ~X + 1
     **** ****     > EOI
0001 E4FE 0206  20        li   rtmp,(>FF*256)
     E500 FF00     
0002 E502 2806  18        xor  rtmp,ra
                   < elite.a99
35882               * CLC                    \
35883                      .adi (>01*256)                  ; ADC #1            ; The CLC instruction is commented out in the original
     **** ****     > ADI
0001 E504 1701  14        jnc  !
0002 E506 B004  18        ab   rone,ra
0003               !:
0004 E508 0220  22        ai   ra,(>01*256)
     E50A 0100     
                   < elite.a99
35884 E50C D040  18        movb ra,rx                      ; TAX               ; source. It would have no effect as we know the C flag
35885                                                                          ; is clear from when we passed through the BCS above
35886               
35887 E50E D002  18        movb ry,ra                      ; TYA               ; Then set the high byte to ~Y + C
35888                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 E510 0206  20        li   rtmp,(>FF*256)
     E512 FF00     
0002 E514 2806  18        xor  rtmp,ra
                   < elite.a99
35889                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 E516 1701  14        jnc  !
0002 E518 B004  18        ab   rone,ra
0003               !:
0004 E51A 0220  22        ai   ra,(>00*256)
     E51C 0000     
                   < elite.a99
35890 E51E D080  18        movb ra,ry                      ; TAY
35891               
35892               LL128:
35893 E520 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E522 FF1C     
35894               
35895               * ******************************************************************************
35896               *
35897               * Name: LL129
35898               * Type: Subroutine
35899               * Category: Maths (Arithmetic)
35900               * Summary: Calculate Q = XX12+2, A = S EOR XX12+3 and (S R) = |S R|
35901               *
35902               * ------------------------------------------------------------------------------
35903               *
35904               * Do the following, in this order:
35905               *
35906               * Q = XX12+2
35907               *
35908               * A = S EOR XX12+3
35909               *
35910               * (S R) = |S R|
35911               *
35912               * This sets up the variables required above to calculate (S R) / XX12+2 and give
35913               * the result the opposite sign to XX13+3.
35914               *
35915               * ******************************************************************************
35916               
35917               LL129:
35918 E524 D060  30        movb @XX12+2,rx                 ; LDX XX12+2        ; Set Q = XX12+2
     E526 0039     
35919 E528 D801  30        movb rx,@Q                      ; STX Q
     E52A 0090     
35920               
35921 E52C D020  30        movb @S,ra                      ; LDA S             ; If S is positive, jump to LL127
     E52E 0092     
35922 E530 1518  14        jgt  LL127                      ; BPL LL127
35923               
35924 E532 0200  20        li   ra,>00*256                 ; LDA #0            ; Otherwise set R = -R
     E534 0000     
35925                      .sec                            ; SEC
     **** ****     > SEC
0001 E536 0A15  18        sla  rmone,1
                   < elite.a99
35926                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 E538 1801  14        joc  !
0002 E53A 7004  18        sb   rone,ra
0003               !:
0004 E53C 7020  30        sb   @R,ra
     E53E 0091     
                   < elite.a99
35927 E540 D800  30        movb ra,@R                      ; STA R
     E542 0091     
35928               
35929 E544 D020  30        movb @S,ra                      ; LDA S             ; Push S onto the stack
     E546 0092     
35930                      .pha                            ; PHA
     **** ****     > PHA
0001 E548 D680  30        movb ra,*rsp
0002 E54A 060A  14        dec  rsp
                   < elite.a99
35931               
35932                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set S = ~S + 1 + C
     **** ****     > EOI
0001 E54C 0206  20        li   rtmp,(>FF*256)
     E54E FF00     
0002 E550 2806  18        xor  rtmp,ra
                   < elite.a99
35933                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 E552 1701  14        jnc  !
0002 E554 B004  18        ab   rone,ra
0003               !:
0004 E556 0220  22        ai   ra,(>00*256)
     E558 0000     
                   < elite.a99
35934 E55A D800  30        movb ra,@S                      ; STA S
     E55C 0092     
35935               
35936                      .pla                            ; PLA               ; Pull the original, negative S from the stack into A
     **** ****     > PLA
0001 E55E 058A  14        inc  rsp
0002 E560 D01A  26        movb *rsp,ra
                   < elite.a99
35937               
35938               LL127:
35939                      .eor @XX12+3                    ; EOR XX12+3        ; Set A = original argument S EOR'd with XX12+3
     **** ****     > EOR
0001 E562 D1A0  30        movb @XX12+3,rtmp
     E564 003A     
0002 E566 2806  18        xor  rtmp,ra
                   < elite.a99
35940               
35941 E568 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E56A FF1C     
35942               
35943               * ******************************************************************************
35944               *
35945               * Name: LL145 (Part 1 of 4)
35946               * Type: Subroutine
35947               * Category: Drawing lines
35948               * Summary: Clip line: Work out which end-points are on-screen, if any
35949               * Deep dive: Line-clipping
35950               * Extended screen coordinates
35951               *
35952               * ------------------------------------------------------------------------------
35953               *
35954               * This routine clips the line from (x1, y1) to (x2, y2) so it fits on-screen, or
35955               * returns an error if it can't be clipped to fit. The arguments are 16-bit
35956               * coordinates, and the clipped line is returned using 8-bit screen coordinates.
35957               *
35958               * This part sets XX13 to reflect which of the two points are on-screen and
35959               * off-screen.
35960               *
35961               * ------------------------------------------------------------------------------
35962               *
35963               * Arguments:
35964               *
35965               * XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
35966               *
35967               * XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
35968               *
35969               * XX15(5 4)           x2 as a 16-bit coordinate (x2_hi x2_lo)
35970               *
35971               * XX12(1 0)           y2 as a 16-bit coordinate (y2_hi y2_lo)
35972               *
35973               * ------------------------------------------------------------------------------
35974               *
35975               * Returns:
35976               *
35977               * (X1, Y1)            Screen coordinate of the start of the clipped line
35978               *
35979               * (X2, Y2)            Screen coordinate of the end of the clipped line
35980               *
35981               * C flag              Clear if the clipped line fits on-screen, set if it
35982               * doesn't
35983               *
35984               * XX13                The state of the original coordinates on-screen:
35985               *
35986               * * 0   = (x2, y2) on-screen
35987               *
35988               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
35989               *
35990               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
35991               *
35992               * So XX13 is non-zero if the end of the line was clipped,
35993               * meaning the next line sent to BLINE can't join onto the
35994               * end but has to start a new segment
35995               *
35996               * SWAP                The swap status of the returned coordinates:
35997               *
35998               * * &FF if we swapped the values of (x1, y1) and
35999               * (x2, y2) as part of the clipping process
36000               *
36001               * * 0 if the coordinates are still in the same order
36002               *
36003               * Y                   Y is preserved
36004               *
36005               * ------------------------------------------------------------------------------
36006               *
36007               * Other entry points:
36008               *
36009               * LL147               Don't initialise the values in SWAP or A
36010               *
36011               * ******************************************************************************
36012               
36013               LL145:
36014 E56C 0200  20        li   ra,>00*256                 ; LDA #0            ; Set SWAP = 0
     E56E 0000     
36015 E570 D800  30        movb ra,@SWAP                   ; STA SWAP
     E572 00A1     
36016               
36017 E574 D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A = x2_hi
     E576 0036     
36018               
36019               LL147:
36020 E578 0201  20        li   rx,(Y*2-1)*256             ; LDX #Y*2-1        ; Set X = #Y * 2 - 1. The constant #Y is 96, the
     E57A BF00     
36021                                                                          ; y-coordinate of the mid-point of the space view, so
36022                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
36023                                                                          ; pixel row of the space view
36024               
36025 E57C F020  30        socb @XX12+1,ra                 ; ORA XX12+1        ; If one or both of x2_hi and y2_hi are non-zero, jump
     E57E 0038     
36026 E580 1605  14        jne  LL107                      ; BNE LL107         ; to LL107 to skip the following, leaving X at 191
36027               
36028 E582 9060  30        cb   @XX12,rx                   ; CPX XX12          ; If y2_lo > the y-coordinate of the bottom of screen
     E584 0037     
36029 E586 1702  14        jnc  LL107                      ; BCC LL107         ; then (x2, y2) is off the bottom of the screen, so skip
36030                                                                          ; the following instruction, leaving X at 191
36031               
36032 E588 0201  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0
     E58A 0000     
36033               
36034               LL107:
36035 E58C D801  30        movb rx,@XX13                   ; STX XX13          ; Set XX13 = X, so we have:
     E58E 0098     
36036                                                                          ;
36037                                                                          ; * XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen
36038                                                                          ;
36039                                                                          ; * XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo
36040                                                                          ; is off the bottom of the screen
36041                                                                          ;
36042                                                                          ; In other words, XX13 is 191 if (x2, y2) is off-screen,
36043                                                                          ; otherwise it is 0
36044               
36045 E590 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If one or both of x1_hi and y1_hi are non-zero, jump
     E592 0032     
36046 E594 F020  30        socb @XX15+3,ra                 ; ORA XX15+3        ; to LL83
     E596 0034     
36047 E598 161F  14        jne  LL83                       ; BNE LL83
36048               
36049 E59A 0200  20        li   ra,(Y*2-1)*256             ; LDA #Y*2-1        ; If y1_lo > the y-coordinate of the bottom of screen
     E59C BF00     
36050 E59E 9020  30        cb   @XX15+2,ra                 ; CMP XX15+2        ; then (x1, y1) is off the bottom of the screen, so jump
     E5A0 0033     
36051 E5A2 171A  14        jnc  LL83                       ; BCC LL83          ; to LL83
36052               
36053                                                                          ; If we get here, (x1, y1) is on-screen
36054               
36055 E5A4 D020  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 is non-zero, i.e. (x2, y2) is off-screen, jump
     E5A6 0098     
36056 E5A8 1612  14        jne  LL108                      ; BNE LL108         ; to LL108 to halve it before continuing at LL83
36057               
36058                                                                          ; If we get here, the high bytes are all zero, which
36059                                                                          ; means the x-coordinates are < 256 and therefore fit on
36060                                                                          ; screen, and neither coordinate is off the bottom of
36061                                                                          ; the screen. That means both coordinates are already on
36062                                                                          ; screen, so we don't need to do any clipping, all we
36063                                                                          ; need to do is move the low bytes into (X1, Y1) and
36064                                                                          ; X2, Y2) and return
36065               
36066               LL146:
36067                                                                          ; If we get here then we have clipped our line to the
36068                                                                          ; screen edge (if we had to clip it at all), so we move
36069                                                                          ; the low bytes from (x1, y1) and (x2, y2) into (X1, Y1)
36070                                                                          ; and (X2, Y2), remembering that they share locations
36071                                                                          ; with XX15:
36072                                                                          ;
36073                                                                          ; X1 = XX15
36074                                                                          ; Y1 = XX15+1
36075                                                                          ; X2 = XX15+2
36076                                                                          ; Y2 = XX15+3
36077                                                                          ;
36078                                                                          ; X1 already contains x1_lo, so now we do the rest
36079 E5AA D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set Y1 (aka XX15+1) = y1_lo
     E5AC 0033     
36080 E5AE D800  30        movb ra,@XX15+1                 ; STA XX15+1
     E5B0 0032     
36081               
36082 E5B2 D020  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set X2 (aka XX15+2) = x2_lo
     E5B4 0035     
36083 E5B6 D800  30        movb ra,@XX15+2                 ; STA XX15+2
     E5B8 0033     
36084               
36085 E5BA D020  30        movb @XX12,ra                   ; LDA XX12          ; Set Y2 (aka XX15+3) = y2_lo
     E5BC 0037     
36086 E5BE D800  30        movb ra,@XX15+3                 ; STA XX15+3
     E5C0 0034     
36087               
36088                      .clc                            ; CLC               ; Clear the C flag as the clipped line fits on-screen
     **** ****     > CLC
0001 E5C2 0A13  18        sla  rzero,1
                   < elite.a99
36089               
36090 E5C4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E5C6 FF1C     
36091               
36092               LL109:
36093                      .sec                            ; SEC               ; Set the C flag to indicate the clipped line does not
     **** ****     > SEC
0001 E5C8 0A15  18        sla  rmone,1
                   < elite.a99
36094                                                                          ; fit on-screen
36095               
36096 E5CA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E5CC FF1C     
36097               
36098               LL108:
36099                      .lsr @XX13                      ; LSR XX13          ; If we get here then (x2, y2) is off-screen and XX13 is
     **** ****     > LSR
0001 E5CE D1A0  30        movb @XX13,rtmp
     E5D0 0098     
0002 E5D2 0916  18        srl  rtmp,1
0003 E5D4 D806  30        movb rtmp,@XX13
     E5D6 0098     
                   < elite.a99
36100                                                                          ; 191, so shift XX13 right to halve it to 95
36101               
36102               * ******************************************************************************
36103               *
36104               * Name: LL145 (Part 2 of 4)
36105               * Type: Subroutine
36106               * Category: Drawing lines
36107               * Summary: Clip line: Work out if any part of the line is on-screen
36108               * Deep dive: Line-clipping
36109               * Extended screen coordinates
36110               *
36111               * ------------------------------------------------------------------------------
36112               *
36113               * This part does a number of tests to see if the line is on or off the screen.
36114               *
36115               * If we get here then at least one of (x1, y1) and (x2, y2) is off-screen, with
36116               * XX13 set as follows:
36117               *
36118               * * 0   = (x1, y1) off-screen, (x2, y2) on-screen
36119               *
36120               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
36121               *
36122               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
36123               *
36124               * where "off-screen" is defined as having a non-zero high byte in one of the
36125               * coordinates, or in the case of y-coordinates, having a low byte > 191, the
36126               * y-coordinate of the bottom of the space view.
36127               *
36128               * ******************************************************************************
36129               
36130               LL83:
36131 E5D8 D020  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 < 128 then only one of the points is on-screen
     E5DA 0098     
36132 E5DC 1533  14        jgt  LL115                      ; BPL LL115         ; so jump down to LL115 to skip the checks of whether
36133                                                                          ; both points are in the strips to the right or bottom
36134                                                                          ; of the screen
36135               
36136                                                                          ; If we get here, both points are off-screen
36137               
36138 E5DE D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If both x1_hi and x2_hi have bit 7 set, jump to LL109
     E5E0 0032     
36139                      .and @XX15+5                    ; AND XX15+5        ; to return from the subroutine with the C flag set, as
     **** ****     > AND
0001 E5E2 D1A0  30        movb @XX15+5,rtmp
     E5E4 0036     
0002 E5E6 0546  14        inv  rtmp
0003 E5E8 5006  18        szcb rtmp,ra
                   < elite.a99
36140 E5EA 11EE  14        jlt  LL109                      ; BMI LL109         ; the entire line is above the top of the screen
36141               
36142 E5EC D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; If both y1_hi and y2_hi have bit 7 set, jump to LL109
     E5EE 0034     
36143                      .and @XX12+1                    ; AND XX12+1        ; to return from the subroutine with the C flag set, as
     **** ****     > AND
0001 E5F0 D1A0  30        movb @XX12+1,rtmp
     E5F2 0038     
0002 E5F4 0546  14        inv  rtmp
0003 E5F6 5006  18        szcb rtmp,ra
                   < elite.a99
36144 E5F8 11E7  14        jlt  LL109                      ; BMI LL109         ; the entire line is to the left of the screen
36145               
36146 E5FA D060  30        movb @XX15+1,rx                 ; LDX XX15+1        ; Set A = X = x1_hi - 1
     E5FC 0032     
36147 E5FE 7044  18        sb   rone,rx                    ; DEX
36148 E600 D001  18        movb rx,ra                      ; TXA
36149               
36150 E602 D060  30        movb @XX15+5,rx                 ; LDX XX15+5        ; Set XX12+2 = x2_hi - 1
     E604 0036     
36151 E606 7044  18        sb   rone,rx                    ; DEX
36152 E608 D801  30        movb rx,@XX12+2                 ; STX XX12+2
     E60A 0039     
36153               
36154 E60C F020  30        socb @XX12+2,ra                 ; ORA XX12+2        ; If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set,
     E60E 0039     
36155 E610 15DB  14        jgt  LL109                      ; BPL LL109         ; jump to LL109 to return from the subroutine with the C
36156                                                                          ; flag set, as the line doesn't fit on-screen
36157               
36158 E612 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If y1_lo < y-coordinate of screen bottom, clear the C
     E614 0033     
36159 E616 0280  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; flag, otherwise set it
     E618 C000     
36160               
36161 E61A D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set XX12+2 = y1_hi - (1 - C), so:
     E61C 0034     
36162                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 E61E 1801  14        joc  !
0002 E620 7004  18        sb   rone,ra
0003               !:
0004 E622 0220  22        ai   ra,-(>00*256)
     E624 0000     
                   < elite.a99
36163 E626 D800  30        movb ra,@XX12+2                 ; STA XX12+2        ; * Set XX12+2 = y1_hi - 1 if y1_lo is on-screen
     E628 0039     
36164                                                                          ; * Set XX12+2 = y1_hi     otherwise
36165                                                                          ;
36166                                                                          ; We do this subtraction because we are only interested
36167                                                                          ; in trying to move the points up by a screen if that
36168                                                                          ; might move the point into the space view portion of
36169                                                                          ; the screen, i.e. if y1_lo is on-screen
36170               
36171 E62A D020  30        movb @XX12,ra                   ; LDA XX12          ; If y2_lo < y-coordinate of screen bottom, clear the C
     E62C 0037     
36172 E62E 0280  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; flag, otherwise set it
     E630 C000     
36173               
36174 E632 D020  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set XX12+2 = y2_hi - (1 - C), so:
     E634 0038     
36175                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 E636 1801  14        joc  !
0002 E638 7004  18        sb   rone,ra
0003               !:
0004 E63A 0220  22        ai   ra,-(>00*256)
     E63C 0000     
                   < elite.a99
36176                                                                          ; * Set XX12+1 = y2_hi - 1 if y2_lo is on-screen
36177                                                                          ; * Set XX12+1 = y2_hi     otherwise
36178                                                                          ;
36179                                                                          ; We do this subtraction because we are only interested
36180                                                                          ; in trying to move the points up by a screen if that
36181                                                                          ; might move the point into the space view portion of
36182                                                                          ; the screen, i.e. if y1_lo is on-screen
36183               
36184 E63E F020  30        socb @XX12+2,ra                 ; ORA XX12+2        ; If neither XX12+1 or XX12+2 have bit 7 set, jump to
     E640 0039     
36185 E642 15C2  14        jgt  LL109                      ; BPL LL109         ; LL109 to return from the subroutine with the C flag
36186                                                                          ; set, as the line doesn't fit on-screen
36187               
36188               * ******************************************************************************
36189               *
36190               * Name: LL145 (Part 3 of 4)
36191               * Type: Subroutine
36192               * Category: Drawing lines
36193               * Summary: Clip line: Calculate the line's gradient
36194               * Deep dive: Line-clipping
36195               * Extended screen coordinates
36196               *
36197               * ******************************************************************************
36198               
36199               LL115:
36200 E644 D002  18        movb ry,ra                      ; TYA               ; Store Y on the stack so we can preserve it through the
36201                      .pha                            ; PHA               ; call to this subroutine
     **** ****     > PHA
0001 E646 D680  30        movb ra,*rsp
0002 E648 060A  14        dec  rsp
                   < elite.a99
36202               
36203 E64A D020  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set XX12+2 = x2_lo - x1_lo
     E64C 0035     
36204                      .sec                            ; SEC
     **** ****     > SEC
0001 E64E 0A15  18        sla  rmone,1
                   < elite.a99
36205                      .sbc @XX15,ra                   ; SBC XX15
     **** ****     > SBC
0001 E650 1801  14        joc  !
0002 E652 7004  18        sb   rone,ra
0003               !:
0004 E654 7020  30        sb   @XX15,ra
     E656 0031     
                   < elite.a99
36206 E658 D800  30        movb ra,@XX12+2                 ; STA XX12+2
     E65A 0039     
36207               
36208 E65C D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set XX12+3 = x2_hi - x1_hi
     E65E 0036     
36209                      .sbc @XX15+1,ra                 ; SBC XX15+1
     **** ****     > SBC
0001 E660 1801  14        joc  !
0002 E662 7004  18        sb   rone,ra
0003               !:
0004 E664 7020  30        sb   @XX15+1,ra
     E666 0032     
                   < elite.a99
36210 E668 D800  30        movb ra,@XX12+3                 ; STA XX12+3
     E66A 003A     
36211               
36212 E66C D020  30        movb @XX12,ra                   ; LDA XX12          ; Set XX12+4 = y2_lo - y1_lo
     E66E 0037     
36213                      .sec                            ; SEC
     **** ****     > SEC
0001 E670 0A15  18        sla  rmone,1
                   < elite.a99
36214                      .sbc @XX15+2,ra                 ; SBC XX15+2
     **** ****     > SBC
0001 E672 1801  14        joc  !
0002 E674 7004  18        sb   rone,ra
0003               !:
0004 E676 7020  30        sb   @XX15+2,ra
     E678 0033     
                   < elite.a99
36215 E67A D800  30        movb ra,@XX12+4                 ; STA XX12+4
     E67C 003B     
36216               
36217 E67E D020  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set XX12+5 = y2_hi - y1_hi
     E680 0038     
36218                      .sbc @XX15+3,ra                 ; SBC XX15+3
     **** ****     > SBC
0001 E682 1801  14        joc  !
0002 E684 7004  18        sb   rone,ra
0003               !:
0004 E686 7020  30        sb   @XX15+3,ra
     E688 0034     
                   < elite.a99
36219 E68A D800  30        movb ra,@XX12+5                 ; STA XX12+5
     E68C 003C     
36220               
36221                                                                          ; So we now have:
36222                                                                          ;
36223                                                                          ; delta_x in XX12(3 2)
36224                                                                          ; delta_y in XX12(5 4)
36225                                                                          ;
36226                                                                          ; where the delta is (x1, y1) - (x2, y2))
36227               
36228                      .eor @XX12+3                    ; EOR XX12+3        ; Set S = the sign of delta_x * the sign of delta_y, so
     **** ****     > EOR
0001 E68E D1A0  30        movb @XX12+3,rtmp
     E690 003A     
0002 E692 2806  18        xor  rtmp,ra
                   < elite.a99
36229 E694 D800  30        movb ra,@S                      ; STA S             ; if bit 7 of S is set, the deltas have different signs
     E696 0092     
36230               
36231 E698 D020  30        movb @XX12+5,ra                 ; LDA XX12+5        ; If delta_y_hi is positive, jump down to LL110 to skip
     E69A 003C     
36232 E69C 1511  14        jgt  LL110                      ; BPL LL110         ; the following
36233               
36234 E69E 0200  20        li   ra,>00*256                 ; LDA #0            ; Otherwise flip the sign of delta_y to make it
     E6A0 0000     
36235                      .sec                            ; SEC               ; positive, starting with the low bytes
     **** ****     > SEC
0001 E6A2 0A15  18        sla  rmone,1
                   < elite.a99
36236                      .sbc @XX12+4,ra                 ; SBC XX12+4
     **** ****     > SBC
0001 E6A4 1801  14        joc  !
0002 E6A6 7004  18        sb   rone,ra
0003               !:
0004 E6A8 7020  30        sb   @XX12+4,ra
     E6AA 003B     
                   < elite.a99
36237 E6AC D800  30        movb ra,@XX12+4                 ; STA XX12+4
     E6AE 003B     
36238               
36239 E6B0 0200  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so now:
     E6B2 0000     
36240                      .sbc @XX12+5,ra                 ; SBC XX12+5        ;
     **** ****     > SBC
0001 E6B4 1801  14        joc  !
0002 E6B6 7004  18        sb   rone,ra
0003               !:
0004 E6B8 7020  30        sb   @XX12+5,ra
     E6BA 003C     
                   < elite.a99
36241 E6BC D800  30        movb ra,@XX12+5                 ; STA XX12+5        ; XX12(5 4) = |delta_y|
     E6BE 003C     
36242               
36243               LL110:
36244 E6C0 D020  30        movb @XX12+3,ra                 ; LDA XX12+3        ; If delta_x_hi is positive, jump down to LL111 to skip
     E6C2 003A     
36245 E6C4 150F  14        jgt  LL111                      ; BPL LL111         ; the following
36246               
36247                      .sec                            ; SEC               ; Otherwise flip the sign of delta_x to make it
     **** ****     > SEC
0001 E6C6 0A15  18        sla  rmone,1
                   < elite.a99
36248 E6C8 0200  20        li   ra,>00*256                 ; LDA #0            ; positive, starting with the low bytes
     E6CA 0000     
36249                      .sbc @XX12+2,ra                 ; SBC XX12+2
     **** ****     > SBC
0001 E6CC 1801  14        joc  !
0002 E6CE 7004  18        sb   rone,ra
0003               !:
0004 E6D0 7020  30        sb   @XX12+2,ra
     E6D2 0039     
                   < elite.a99
36250 E6D4 D800  30        movb ra,@XX12+2                 ; STA XX12+2
     E6D6 0039     
36251               
36252 E6D8 0200  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so now:
     E6DA 0000     
36253                      .sbc @XX12+3,ra                 ; SBC XX12+3        ;
     **** ****     > SBC
0001 E6DC 1801  14        joc  !
0002 E6DE 7004  18        sb   rone,ra
0003               !:
0004 E6E0 7020  30        sb   @XX12+3,ra
     E6E2 003A     
                   < elite.a99
36254                                                                          ; (A XX12+2) = |delta_x|
36255               
36256               LL111:
36257                                                                          ; We now keep halving |delta_x| and |delta_y| until
36258                                                                          ; both of them have zero in their high bytes
36259 E6E4 D040  18        movb ra,rx                      ; TAX               ; If |delta_x_hi| is non-zero, skip the following
36260 E6E6 1603  14        jne  LL112                      ; BNE LL112
36261               
36262 E6E8 D060  30        movb @XX12+5,rx                 ; LDX XX12+5        ; If |delta_y_hi| = 0, jump down to LL113 (as both
     E6EA 003C     
36263 E6EC 1310  14        jeq  LL113                      ; BEQ LL113         ; |delta_x_hi| and |delta_y_hi| are 0)
36264               
36265               LL112:
36266 E6EE 0910  18        srl  ra,1                       ; LSR A             ; Halve the value of delta_x in (A XX12+2)
36267 E6F0 0208  20        li   rarg1,XX12+2               ; ROR XX12+2
     E6F2 0039     
36268 E6F4 06A0  32        bl   @ror                       ;
     E6F6 FF62     
36269               
36270                      .lsr @XX12+5                    ; LSR XX12+5        ; Halve the value of delta_y XX12(5 4)
     **** ****     > LSR
0001 E6F8 D1A0  30        movb @XX12+5,rtmp
     E6FA 003C     
0002 E6FC 0916  18        srl  rtmp,1
0003 E6FE D806  30        movb rtmp,@XX12+5
     E700 003C     
                   < elite.a99
36271 E702 0208  20        li   rarg1,XX12+4               ; ROR XX12+4
     E704 003B     
36272 E706 06A0  32        bl   @ror                       ;
     E708 FF62     
36273               
36274 E70A 0460  28        b    @LL111                     ; JMP LL111         ; Loop back to LL111
     E70C E6E4     
36275               
36276               LL113:
36277                                                                          ; By now, the high bytes of both |delta_x| and |delta_y|
36278                                                                          ; are zero
36279 E70E D801  30        movb rx,@T                      ; STX T             ; We know that X = 0 as that's what we tested with a BEQ
     E710 00D1     
36280                                                                          ; above, so this sets T = 0
36281               
36282 E712 D020  30        movb @XX12+2,ra                 ; LDA XX12+2        ; If delta_x_lo < delta_y_lo, so our line is more
     E714 0039     
36283 E716 9020  30        cb   @XX12+4,ra                 ; CMP XX12+4        ; vertical than horizontal, jump to LL114
     E718 003B     
36284 E71A 170A  14        jnc  LL114                      ; BCC LL114
36285               
36286                                                                          ; If we get here then our line is more horizontal than
36287                                                                          ; vertical, so it is a shallow slope
36288               
36289 E71C D800  30        movb ra,@Q                      ; STA Q             ; Set Q = delta_x_lo
     E71E 0090     
36290               
36291 E720 D020  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set A = delta_y_lo
     E722 003B     
36292               
36293 E724 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     E726 D344     
36294 E728 06A0  32        bl   @jsr                       ;
     E72A FF10     
36295                                                                          ;
36296                                                                          ; R = 256 * A / Q
36297                                                                          ; = 256 * delta_y_lo / delta_x_lo
36298               
36299 E72C 0460  28        b    @LL116                     ; JMP LL116         ; Jump to LL116, as we now have the line's gradient in R
     E72E E746     
36300               
36301               LL114:
36302                                                                          ; If we get here then our line is more vertical than
36303                                                                          ; horizontal, so it is a steep slope
36304 E730 D020  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set Q = delta_y_lo
     E732 003B     
36305 E734 D800  30        movb ra,@Q                      ; STA Q
     E736 0090     
36306 E738 D020  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set A = delta_x_lo
     E73A 0039     
36307               
36308 E73C 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     E73E D344     
36309 E740 06A0  32        bl   @jsr                       ;
     E742 FF10     
36310                                                                          ;
36311                                                                          ; R = 256 * A / Q
36312                                                                          ; = 256 * delta_x_lo / delta_y_lo
36313               
36314 E744 7004  18        sb   rone,ra                    ; DEC T             ; T was set to 0 above, so this sets T = &FF when our
36315                                                                          ; line is steep
36316               
36317               * ******************************************************************************
36318               *
36319               * Name: LL145 (Part 4 of 4)
36320               * Type: Subroutine
36321               * Category: Drawing lines
36322               * Summary: Clip line: Call the routine in LL188 to do the actual clipping
36323               * Deep dive: Line-clipping
36324               * Extended screen coordinates
36325               *
36326               * ------------------------------------------------------------------------------
36327               *
36328               * This part sets things up to call the routine in LL188, which does the actual
36329               * clipping.
36330               *
36331               * If we get here, then R has been set to the gradient of the line (x1, y1) to
36332               * (x2, y2), with T indicating the gradient of slope:
36333               *
36334               * * 0   = shallow slope (more horizontal than vertical)
36335               *
36336               * * &FF = steep slope (more vertical than horizontal)
36337               *
36338               * and XX13 has been set as follows:
36339               *
36340               * * 0   = (x1, y1) off-screen, (x2, y2) on-screen
36341               *
36342               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
36343               *
36344               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
36345               *
36346               * ******************************************************************************
36347               
36348               LL116:
36349 E746 D020  30        movb @R,ra                      ; LDA R             ; Store the gradient in XX12+2
     E748 0091     
36350 E74A D800  30        movb ra,@XX12+2                 ; STA XX12+2
     E74C 0039     
36351               
36352 E74E D020  30        movb @S,ra                      ; LDA S             ; Store the type of slope in XX12+3, bit 7 clear means
     E750 0092     
36353 E752 D800  30        movb ra,@XX12+3                 ; STA XX12+3        ; top left to bottom right, bit 7 set means top right to
     E754 003A     
36354                                                                          ; bottom left
36355               
36356 E756 D020  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 = 0, skip the following instruction
     E758 0098     
36357 E75A 1301  14        jeq  LL138                      ; BEQ LL138
36358               
36359 E75C 1511  14        jgt  LLX117                     ; BPL LLX117        ; If XX13 is positive, it must be 95. This means
36360                                                                          ; (x1, y1) is on-screen but (x2, y2) isn't, so we jump
36361                                                                          ; to LLX117 to swap the (x1, y1) and (x2, y2)
36362                                                                          ; coordinates around before doing the actual clipping,
36363                                                                          ; because we need to clip (x2, y2) but the clipping
36364                                                                          ; routine at LL118 only clips (x1, y1)
36365               
36366               LL138:
36367                                                                          ; If we get here, XX13 = 0 or 191, so (x1, y1) is
36368                                                                          ; off-screen and needs clipping
36369 E75E 0206  20        li   rtmp,LL118                 ; JSR LL118         ; Call LL118 to move (x1, y1) along the line onto the
     E760 E2DC     
36370 E762 06A0  32        bl   @jsr                       ;
     E764 FF10     
36371                                                                          ; screen, i.e. clip the line at the (x1, y1) end
36372               
36373 E766 D020  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to
     E768 0098     
36374 E76A 152F  14        jgt  LL124                      ; BPL LL124         ; LL124 to return with a successfully clipped line
36375               
36376               LL117:
36377                                                                          ; If we get here, XX13 = 191 (both coordinates are
36378                                                                          ; off-screen)
36379 E76C D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If either of x1_hi or y1_hi are non-zero, jump to
     E76E 0032     
36380 E770 F020  30        socb @XX15+3,ra                 ; ORA XX15+3        ; LL137 to return from the subroutine with the C flag
     E772 0034     
36381 E774 162F  14        jne  LL137                      ; BNE LL137         ; set, as the line doesn't fit on-screen
36382               
36383 E776 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If y1_lo > y-coordinate of the bottom of the screen
     E778 0033     
36384 E77A 0280  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; jump to LL137 to return from the subroutine with the
     E77C C000     
36385 E77E 182A  14        joc  LL137                      ; BCS LL137         ; C flag set, as the line doesn't fit on-screen
36386               
36387               LLX117:
36388                                                                          ; If we get here, XX13 = 95 or 191, and in both cases
36389                                                                          ; (x2, y2) is off-screen, so we now need to swap the
36390                                                                          ; (x1, y1) and (x2, y2) coordinates around before doing
36391                                                                          ; the actual clipping, because we need to clip (x2, y2)
36392                                                                          ; but the clipping routine at LL118 only clips (x1, y1)
36393 E780 D060  30        movb @XX15,rx                   ; LDX XX15          ; Swap x1_lo = x2_lo
     E782 0031     
36394 E784 D020  30        movb @XX15+4,ra                 ; LDA XX15+4
     E786 0035     
36395 E788 D800  30        movb ra,@XX15                   ; STA XX15
     E78A 0031     
36396 E78C D801  30        movb rx,@XX15+4                 ; STX XX15+4
     E78E 0035     
36397               
36398 E790 D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Swap x2_lo = x1_lo
     E792 0036     
36399 E794 D060  30        movb @XX15+1,rx                 ; LDX XX15+1
     E796 0032     
36400 E798 D801  30        movb rx,@XX15+5                 ; STX XX15+5
     E79A 0036     
36401 E79C D800  30        movb ra,@XX15+1                 ; STA XX15+1
     E79E 0032     
36402               
36403 E7A0 D060  30        movb @XX15+2,rx                 ; LDX XX15+2        ; Swap y1_lo = y2_lo
     E7A2 0033     
36404 E7A4 D020  30        movb @XX12,ra                   ; LDA XX12
     E7A6 0037     
36405 E7A8 D800  30        movb ra,@XX15+2                 ; STA XX15+2
     E7AA 0033     
36406 E7AC D801  30        movb rx,@XX12                   ; STX XX12
     E7AE 0037     
36407               
36408 E7B0 D020  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Swap y2_lo = y1_lo
     E7B2 0038     
36409 E7B4 D060  30        movb @XX15+3,rx                 ; LDX XX15+3
     E7B6 0034     
36410 E7B8 D801  30        movb rx,@XX12+1                 ; STX XX12+1
     E7BA 0038     
36411 E7BC D800  30        movb ra,@XX15+3                 ; STA XX15+3
     E7BE 0034     
36412               
36413 E7C0 0206  20        li   rtmp,LL118                 ; JSR LL118         ; Call LL118 to move (x1, y1) along the line onto the
     E7C2 E2DC     
36414 E7C4 06A0  32        bl   @jsr                       ;
     E7C6 FF10     
36415                                                                          ; screen, i.e. clip the line at the (x1, y1) end
36416               
36417 E7C8 7004  18        sb   rone,ra                    ; DEC SWAP          ; Set SWAP = &FF to indicate that we just clipped the
36418                                                                          ; line at the (x2, y2) end by swapping the coordinates
36419                                                                          ; (the DEC does this as we set SWAP to 0 at the start of
36420                                                                          ; this subroutine)
36421               
36422               LL124:
36423                      .pla                            ; PLA               ; Restore Y from the stack so it gets preserved through
     **** ****     > PLA
0001 E7CA 058A  14        inc  rsp
0002 E7CC D01A  26        movb *rsp,ra
                   < elite.a99
36424 E7CE D080  18        movb ra,ry                      ; TAY               ; the call to this subroutine
36425               
36426 E7D0 0460  28        b    @LL146                     ; JMP LL146         ; Jump up to LL146 to move the low bytes of (x1, y1) and
     E7D2 E5AA     
36427                                                                          ; (x2, y2) into (X1, Y1) and (X2, Y2), and return from
36428                                                                          ; the subroutine with a successfully clipped line
36429               
36430               LL137:
36431                      .pla                            ; PLA               ; Restore Y from the stack so it gets preserved through
     **** ****     > PLA
0001 E7D4 058A  14        inc  rsp
0002 E7D6 D01A  26        movb *rsp,ra
                   < elite.a99
36432 E7D8 D080  18        movb ra,ry                      ; TAY               ; the call to this subroutine
36433               
36434                      .sec                            ; SEC               ; Set the C flag to indicate the clipped line does not
     **** ****     > SEC
0001 E7DA 0A15  18        sla  rmone,1
                   < elite.a99
36435                                                                          ; fit on-screen
36436               
36437 E7DC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E7DE FF1C     
36438               
36439               * ******************************************************************************
36440               *
36441               * Save ELTG.bin
36442               *
36443               * ******************************************************************************
36444               
36445                      ; PRINT "ELITE G"
36446                      ; PRINT "Assembled at ", ~CODE_G%
36447                      ; PRINT "Ends at ", ~P%
36448                      ; PRINT "Code size is ", ~(P% - CODE_G%)
36449                      ; PRINT "Execute at ", ~LOAD%
36450                      ; PRINT "Reload at ", ~LOAD_G%
36451               
36452                      ; PRINT "S.ELTG ", ~CODE_G%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_G%
36453                      ; SAVE "3-assembled-output/ELTG.bin", CODE_G%, P%, LOAD%
36454               
36455               * ******************************************************************************
36456               *
36457               * Name: checksum0
36458               * Type: Variable
36459               * Category: Copy protection
36460               * Summary: Checksum for the entire main game code
36461               *
36462               * ------------------------------------------------------------------------------
36463               *
36464               * This byte contains a checksum for the entire main game code. It is populated
36465               * by elite-checksum.py and is used by the encryption checks in elite-loader.asm
36466               * (see the CHK routine in the loader for more details).
36467               *
36468               * ******************************************************************************
36469               
36470               checksum0_:
36471 E7E0                 bss 1                                               ; This value is checked against the calculated checksum
36472                                                                          ; in part 6 of the loader in elite-loader.asm
36473               
36474               * ******************************************************************************
36475               *
36476               * ELITE SHIP BLUEPRINTS FILE
36477               *
36478               * Produces the binary file SHIPS.bin that gets loaded by elite-bcfs.asm.
36479               *
36480               * ******************************************************************************
36481               
36482               CODE_SHIPS.:
36483                      equ $
36484               
36485               LOAD_SHIPS.:
36486                      equ LOAD. + $ - CODE.
36487               
36488               * ******************************************************************************
36489               *
36490               * Name: XX21
36491               * Type: Variable
36492               * Category: Drawing ships
36493               * Summary: Ship blueprints lookup table
36494               * Deep dive: Ship blueprints
36495               *
36496               * ******************************************************************************
36497               
36498               XX21:
36499 E7E2 E7FC            data SHIP_SIDEWINDER                                ; 1 = Sidewinder
36500 E7E4 E8A6            data SHIP_VIPER                                     ; COPS =  2 = Viper
36501 E7E6 E982            data SHIP_MAMBA                                     ; 3 = Mamba
36502 E7E8 F1BE            data SHIP_PYTHON                                    ; 4 = Python
36503 E7EA EAB2            data SHIP_COBRA_MK_3                                ; 5 = Cobra Mk III (bounty hunter)
36504 E7EC EC3C            data SHIP_THARGOID                                  ; THG  =  6 = Thargoid
36505 E7EE EAB2            data SHIP_COBRA_MK_3                                ; CYL  =  7 = Cobra Mk III (trader)
36506 E7F0 ED5A            data SHIP_CORIOLIS                                  ; SST  =  8 = Coriolis space station
36507 E7F2 EE78            data SHIP_MISSILE                                   ; MSL  =  9 = Missile
36508 E7F4 EF78            data SHIP_ASTEROID                                  ; AST  = 10 = Asteroid
36509 E7F6 F050            data SHIP_CANISTER                                  ; OIL  = 11 = Cargo canister
36510 E7F8 F0FA            data SHIP_THARGON                                   ; TGL  = 12 = Thargon
36511 E7FA F168            data SHIP_ESCAPE_POD                                ; ESC  = 13 = Escape pod
36512               
36513               * ******************************************************************************
36514               *
36515               * Name: VERTEX
36516               * Type: Macro
36517               * Category: Drawing ships
36518               * Summary: Macro definition for adding vertices to ship blueprints
36519               * Deep dive: Ship blueprints
36520               *
36521               * ------------------------------------------------------------------------------
36522               *
36523               * The following macro is used to build the ship blueprints:
36524               *
36525               * VERTEX x, y, z, face1, face2, face3, face4, visibility
36526               *
36527               * See the deep dive on "Ship blueprints" for details of how vertices are stored
36528               * in the ship blueprints, and the deep dive on "Drawing ships" for information
36529               * on how vertices are used to draw 3D wireframe ships.
36530               *
36531               * ------------------------------------------------------------------------------
36532               *
36533               * Arguments:
36534               *
36535               * x                   The vertex's x-coordinate
36536               *
36537               * y                   The vertex's y-coordinate
36538               *
36539               * z                   The vertex's z-coordinate
36540               *
36541               * face1               The number of face 1 associated with this vertex
36542               *
36543               * face2               The number of face 2 associated with this vertex
36544               *
36545               * face3               The number of face 3 associated with this vertex
36546               *
36547               * face4               The number of face 4 associated with this vertex
36548               *
36549               * visibility          The visibility distance, beyond which the vertex is not
36550               * shown
36551               *
36552               * ******************************************************************************
36553               
36554                      ; MACRO VERTEX x, y, z, face1, face2, face3, face4, visibility
36555               
36556                      ; IF x < 0                      ;
36557                      ; s_x = 1 << 7                  ;
36558                      ; ELSE                          ;
36559                      ; s_x = 0                       ;
36560                      ; ENDIF                         ;
36561               
36562                      ; IF y < 0                      ;
36563                      ; s_y = 1 << 6                  ;
36564                      ; ELSE                          ;
36565                      ; s_y = 0                       ;
36566                      ; ENDIF                         ;
36567               
36568                      ; IF z < 0                      ;
36569                      ; s_z = 1 << 5                  ;
36570                      ; ELSE                          ;
36571                      ; s_z = 0                       ;
36572                      ; ENDIF                         ;
36573               
36574                      ; s = s_x + s_y + s_z + visibility ;
36575                      ; f1 = face1 + (face2 << 4)     ;
36576                      ; f2 = face3 + (face4 << 4)     ;
36577                      ; ax = ABS(x)                   ;
36578                      ; ay = ABS(y)                   ;
36579                      ; az = ABS(z)                   ;
36580               
36581                      ; EQUB ax, ay, az, s, f1, f2    ;
36582               
36583                      ; ENDMACRO
36584               
36585               * ******************************************************************************
36586               *
36587               * Name: EDGE
36588               * Type: Macro
36589               * Category: Drawing ships
36590               * Summary: Macro definition for adding edges to ship blueprints
36591               * Deep dive: Ship blueprints
36592               *
36593               * ------------------------------------------------------------------------------
36594               *
36595               * The following macro is used to build the ship blueprints:
36596               *
36597               * EDGE vertex1, vertex2, face1, face2, visibility
36598               *
36599               * See the deep dive on "Ship blueprints" for details of how edges are stored
36600               * in the ship blueprints, and the deep dive on "Drawing ships" for information
36601               * on how edges are used to draw 3D wireframe ships.
36602               *
36603               * ------------------------------------------------------------------------------
36604               *
36605               * Arguments:
36606               *
36607               * vertex1             The number of the vertex at the start of the edge
36608               *
36609               * vertex1             The number of the vertex at the end of the edge
36610               *
36611               * face1               The number of face 1 associated with this edge
36612               *
36613               * face2               The number of face 2 associated with this edge
36614               *
36615               * visibility          The visibility distance, beyond which the edge is not
36616               * shown
36617               *
36618               * ******************************************************************************
36619               
36620                      ; MACRO EDGE vertex1, vertex2, face1, face2, visibility
36621               
36622                      ; f = face1 + (face2 << 4)      ;
36623                      ; EQUB visibility, f, vertex1 << 2, vertex2 << 2 ;
36624               
36625                      ; ENDMACRO
36626               
36627               * ******************************************************************************
36628               *
36629               * Name: FACE
36630               * Type: Macro
36631               * Category: Drawing ships
36632               * Summary: Macro definition for adding faces to ship blueprints
36633               * Deep dive: Ship blueprints
36634               *
36635               * ------------------------------------------------------------------------------
36636               *
36637               * The following macro is used to build the ship blueprints:
36638               *
36639               * FACE normal_x, normal_y, normal_z, visibility
36640               *
36641               * See the deep dive on "Ship blueprints" for details of how faces are stored
36642               * in the ship blueprints, and the deep dive on "Drawing ships" for information
36643               * on how faces are used to draw 3D wireframe ships.
36644               *
36645               * ------------------------------------------------------------------------------
36646               *
36647               * Arguments:
36648               *
36649               * normal_x            The face normal's x-coordinate
36650               *
36651               * normal_y            The face normal's y-coordinate
36652               *
36653               * normal_z            The face normal's z-coordinate
36654               *
36655               * visibility          The visibility distance, beyond which the edge is always
36656               * shown
36657               *
36658               * ******************************************************************************
36659               
36660                      ; MACRO FACE normal_x, normal_y, normal_z, visibility
36661               
36662                      ; IF normal_x < 0               ;
36663                      ; s_x = 1 << 7                  ;
36664                      ; ELSE                          ;
36665                      ; s_x = 0                       ;
36666                      ; ENDIF                         ;
36667               
36668                      ; IF normal_y < 0               ;
36669                      ; s_y = 1 << 6                  ;
36670                      ; ELSE                          ;
36671                      ; s_y = 0                       ;
36672                      ; ENDIF                         ;
36673               
36674                      ; IF normal_z < 0               ;
36675                      ; s_z = 1 << 5                  ;
36676                      ; ELSE                          ;
36677                      ; s_z = 0                       ;
36678                      ; ENDIF                         ;
36679               
36680                      ; s = s_x + s_y + s_z + visibility ;
36681                      ; ax = ABS(normal_x)            ;
36682                      ; ay = ABS(normal_y)            ;
36683                      ; az = ABS(normal_z)            ;
36684               
36685                      ; EQUB s, ax, ay, az            ;
36686               
36687                      ; ENDMACRO
36688               
36689               * ******************************************************************************
36690               *
36691               * Name: SHIP_SIDEWINDER
36692               * Type: Variable
36693               * Category: Drawing ships
36694               * Summary: Ship blueprint for a Sidewinder
36695               * Deep dive: Ship blueprints
36696               *
36697               * ******************************************************************************
36698               
36699               SHIP_SIDEWINDER:
36700 E7FC 00              byte >00                                            ; Max. canisters on demise = 0
36701 E7FE 1081            data 65 * 65                                        ; Targetable area          = 65 * 65
36702               
36703 E800 52              byte (SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)%256  ; Edges data offset (low)
36704 E801   8E            byte (SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)%256  ; Faces data offset (low)
36705               
36706 E802 3D              byte >3d                                            ; Max. edge count          = (61 - 1) / 4 = 15
36707 E803   00            byte >00                                            ; Gun vertex               = 0
36708 E804 1E              byte >1e                                            ; Explosion count          = 6, as (4 * n) + 6 = 30
36709 E805   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
36710 E806 0F              byte >0f                                            ; Number of edges          = 15
36711 E808 3200            data >3200                                          ; Bounty                   = 50
36712 E80A 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
36713 E80B   14            byte >14                                            ; Visibility distance      = 20
36714 E80C 46              byte >46                                            ; Max. energy              = 70
36715 E80D   25            byte >25                                            ; Max. speed               = 37
36716               
36717 E80E 00              byte (SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)/256  ; Edges data offset (high)
36718 E80F   00            byte (SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)/256  ; Faces data offset (high)
36719               
36720 E810 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
36721 E811   10            byte >10                                            ; Laser power              = 2
36722                                                                          ; Missiles                 = 0
36723               
36724               SHIP_SIDEWINDER_VERTICES:
36725                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36726 E812 2000            byte >20, >00, >24, >9f, >10, >54                   ; Vertex 0
     E814 249F     
     E816 1054     
36727 E818 2000            byte >20, >00, >24, >1f, >20, >65                   ; Vertex 1
     E81A 241F     
     E81C 2065     
36728 E81E 4000            byte >40, >00, >1c, >3f, >32, >66                   ; Vertex 2
     E820 1C3F     
     E822 3266     
36729 E824 4000            byte >40, >00, >1c, >bf, >31, >44                   ; Vertex 3
     E826 1CBF     
     E828 3144     
36730 E82A 0010            byte >00, >10, >1c, >3f, >10, >32                   ; Vertex 4
     E82C 1C3F     
     E82E 1032     
36731 E830 0010            byte >00, >10, >1c, >7f, >43, >65                   ; Vertex 5
     E832 1C7F     
     E834 4365     
36732 E836 0C06            byte >0c, >06, >1c, >af, >33, >33                   ; Vertex 6
     E838 1CAF     
     E83A 3333     
36733 E83C 0C06            byte >0c, >06, >1c, >2f, >33, >33                   ; Vertex 7
     E83E 1C2F     
     E840 3333     
36734 E842 0C06            byte >0c, >06, >1c, >6c, >33, >33                   ; Vertex 8
     E844 1C6C     
     E846 3333     
36735 E848 0C06            byte >0c, >06, >1c, >ec, >33, >33                   ; Vertex 9
     E84A 1CEC     
     E84C 3333     
36736               
36737               SHIP_SIDEWINDER_EDGES:
36738                                                                          ; vertex1, vertex2, face1, face2, visibility
36739 E84E 1F50            byte >1f, >50, >00, >04                             ; Edge 0
     E850 0004     
36740 E852 1F62            byte >1f, >62, >04, >08                             ; Edge 1
     E854 0408     
36741 E856 1F20            byte >1f, >20, >04, >10                             ; Edge 2
     E858 0410     
36742 E85A 1F10            byte >1f, >10, >00, >10                             ; Edge 3
     E85C 0010     
36743 E85E 1F41            byte >1f, >41, >00, >0c                             ; Edge 4
     E860 000C     
36744 E862 1F31            byte >1f, >31, >0c, >10                             ; Edge 5
     E864 0C10     
36745 E866 1F32            byte >1f, >32, >08, >10                             ; Edge 6
     E868 0810     
36746 E86A 1F43            byte >1f, >43, >0c, >14                             ; Edge 7
     E86C 0C14     
36747 E86E 1F63            byte >1f, >63, >08, >14                             ; Edge 8
     E870 0814     
36748 E872 1F65            byte >1f, >65, >04, >14                             ; Edge 9
     E874 0414     
36749 E876 1F54            byte >1f, >54, >00, >14                             ; Edge 10
     E878 0014     
36750 E87A 0F33            byte >0f, >33, >18, >1c                             ; Edge 11
     E87C 181C     
36751 E87E 0C33            byte >0c, >33, >1c, >20                             ; Edge 12
     E880 1C20     
36752 E882 0C33            byte >0c, >33, >18, >24                             ; Edge 13
     E884 1824     
36753 E886 0C33            byte >0c, >33, >20, >24                             ; Edge 14
     E888 2024     
36754               
36755               SHIP_SIDEWINDER_FACES:
36756                                                                          ; normal_x, normal_y, normal_z, visibility
36757 E88A 1F00            byte >1f, >00, >20, >08                             ; Face 0
     E88C 2008     
36758 E88E 9F0C            byte >9f, >0c, >2f, >06                             ; Face 1
     E890 2F06     
36759 E892 1F0C            byte >1f, >0c, >2f, >06                             ; Face 2
     E894 2F06     
36760 E896 3F00            byte >3f, >00, >00, >70                             ; Face 3
     E898 0070     
36761 E89A DF0C            byte >df, >0c, >2f, >06                             ; Face 4
     E89C 2F06     
36762 E89E 5F00            byte >5f, >00, >20, >08                             ; Face 5
     E8A0 2008     
36763 E8A2 5F0C            byte >5f, >0c, >2f, >06                             ; Face 6
     E8A4 2F06     
36764               
36765               * ******************************************************************************
36766               *
36767               * Name: SHIP_VIPER
36768               * Type: Variable
36769               * Category: Drawing ships
36770               * Summary: Ship blueprint for a Viper
36771               * Deep dive: Ship blueprints
36772               *
36773               * ******************************************************************************
36774               
36775               SHIP_VIPER:
36776 E8A6 00              byte >00                                            ; Max. canisters on demise = 0
36777 E8A8 15F9            data 75 * 75                                        ; Targetable area          = 75 * 75
36778               
36779 E8AA 70              byte (SHIP_VIPER_EDGES - SHIP_VIPER)%256            ; Edges data offset (low)
36780 E8AB   C0            byte (SHIP_VIPER_FACES - SHIP_VIPER)%256            ; Faces data offset (low)
36781               
36782 E8AC 4D              byte >4d                                            ; Max. edge count          = (77 - 1) / 4 = 19
36783 E8AD   00            byte >00                                            ; Gun vertex               = 0
36784 E8AE 2A              byte >2a                                            ; Explosion count          = 9, as (4 * n) + 6 = 42
36785 E8AF   5A            byte >5a                                            ; Number of vertices       = 90 / 6 = 15
36786 E8B0 14              byte >14                                            ; Number of edges          = 20
36787 E8B2 0000            data >0000                                          ; Bounty                   = 0
36788 E8B4 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
36789 E8B5   17            byte >17                                            ; Visibility distance      = 23
36790 E8B6 78              byte >78                                            ; Max. energy              = 120
36791 E8B7   20            byte >20                                            ; Max. speed               = 32
36792               
36793 E8B8 00              byte (SHIP_VIPER_EDGES - SHIP_VIPER)/256            ; Edges data offset (high)
36794 E8B9   00            byte (SHIP_VIPER_FACES - SHIP_VIPER)/256            ; Faces data offset (high)
36795               
36796 E8BA 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
36797 E8BB   11            byte >11                                            ; Laser power              = 2
36798                                                                          ; Missiles                 = 1
36799               
36800               SHIP_VIPER_VERTICES:
36801                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36802 E8BC 0000            byte >00, >00, >48, >1f, >21, >43                   ; Vertex 0
     E8BE 481F     
     E8C0 2143     
36803 E8C2 0010            byte >00, >10, >18, >1e, >10, >22                   ; Vertex 1
     E8C4 181E     
     E8C6 1022     
36804 E8C8 0010            byte >00, >10, >18, >5e, >43, >55                   ; Vertex 2
     E8CA 185E     
     E8CC 4355     
36805 E8CE 3000            byte >30, >00, >18, >3f, >42, >66                   ; Vertex 3
     E8D0 183F     
     E8D2 4266     
36806 E8D4 3000            byte >30, >00, >18, >bf, >31, >66                   ; Vertex 4
     E8D6 18BF     
     E8D8 3166     
36807 E8DA 1810            byte >18, >10, >18, >7e, >54, >66                   ; Vertex 5
     E8DC 187E     
     E8DE 5466     
36808 E8E0 1810            byte >18, >10, >18, >fe, >35, >66                   ; Vertex 6
     E8E2 18FE     
     E8E4 3566     
36809 E8E6 1810            byte >18, >10, >18, >3f, >20, >66                   ; Vertex 7
     E8E8 183F     
     E8EA 2066     
36810 E8EC 1810            byte >18, >10, >18, >bf, >10, >66                   ; Vertex 8
     E8EE 18BF     
     E8F0 1066     
36811 E8F2 2000            byte >20, >00, >18, >b3, >66, >66                   ; Vertex 9
     E8F4 18B3     
     E8F6 6666     
36812 E8F8 2000            byte >20, >00, >18, >33, >66, >66                   ; Vertex 10
     E8FA 1833     
     E8FC 6666     
36813 E8FE 0808            byte >08, >08, >18, >33, >66, >66                   ; Vertex 11
     E900 1833     
     E902 6666     
36814 E904 0808            byte >08, >08, >18, >b3, >66, >66                   ; Vertex 12
     E906 18B3     
     E908 6666     
36815 E90A 0808            byte >08, >08, >18, >f2, >66, >66                   ; Vertex 13
     E90C 18F2     
     E90E 6666     
36816 E910 0808            byte >08, >08, >18, >72, >66, >66                   ; Vertex 14
     E912 1872     
     E914 6666     
36817               
36818               SHIP_VIPER_EDGES:
36819                                                                          ; vertex1, vertex2, face1, face2, visibility
36820 E916 1F42            byte >1f, >42, >00, >0c                             ; Edge 0
     E918 000C     
36821 E91A 1E21            byte >1e, >21, >00, >04                             ; Edge 1
     E91C 0004     
36822 E91E 1E43            byte >1e, >43, >00, >08                             ; Edge 2
     E920 0008     
36823 E922 1F31            byte >1f, >31, >00, >10                             ; Edge 3
     E924 0010     
36824 E926 1E20            byte >1e, >20, >04, >1c                             ; Edge 4
     E928 041C     
36825 E92A 1E10            byte >1e, >10, >04, >20                             ; Edge 5
     E92C 0420     
36826 E92E 1E54            byte >1e, >54, >08, >14                             ; Edge 6
     E930 0814     
36827 E932 1E53            byte >1e, >53, >08, >18                             ; Edge 7
     E934 0818     
36828 E936 1F60            byte >1f, >60, >1c, >20                             ; Edge 8
     E938 1C20     
36829 E93A 1E65            byte >1e, >65, >14, >18                             ; Edge 9
     E93C 1418     
36830 E93E 1F61            byte >1f, >61, >10, >20                             ; Edge 10
     E940 1020     
36831 E942 1E63            byte >1e, >63, >10, >18                             ; Edge 11
     E944 1018     
36832 E946 1F62            byte >1f, >62, >0c, >1c                             ; Edge 12
     E948 0C1C     
36833 E94A 1E46            byte >1e, >46, >0c, >14                             ; Edge 13
     E94C 0C14     
36834 E94E 1366            byte >13, >66, >24, >30                             ; Edge 14
     E950 2430     
36835 E952 1266            byte >12, >66, >24, >34                             ; Edge 15
     E954 2434     
36836 E956 1366            byte >13, >66, >28, >2c                             ; Edge 16
     E958 282C     
36837 E95A 1266            byte >12, >66, >28, >38                             ; Edge 17
     E95C 2838     
36838 E95E 1066            byte >10, >66, >2c, >38                             ; Edge 18
     E960 2C38     
36839 E962 1066            byte >10, >66, >30, >34                             ; Edge 19
     E964 3034     
36840               
36841               SHIP_VIPER_FACES:
36842                                                                          ; normal_x, normal_y, normal_z, visibility
36843 E966 1F00            byte >1f, >00, >20, >00                             ; Face 0
     E968 2000     
36844 E96A 9F16            byte >9f, >16, >21, >0b                             ; Face 1
     E96C 210B     
36845 E96E 1F16            byte >1f, >16, >21, >0b                             ; Face 2
     E970 210B     
36846 E972 DF16            byte >df, >16, >21, >0b                             ; Face 3
     E974 210B     
36847 E976 5F16            byte >5f, >16, >21, >0b                             ; Face 4
     E978 210B     
36848 E97A 5F00            byte >5f, >00, >20, >00                             ; Face 5
     E97C 2000     
36849 E97E 3F00            byte >3f, >00, >00, >30                             ; Face 6
     E980 0030     
36850               
36851               * ******************************************************************************
36852               *
36853               * Name: SHIP_MAMBA
36854               * Type: Variable
36855               * Category: Drawing ships
36856               * Summary: Ship blueprint for a Mamba
36857               * Deep dive: Ship blueprints
36858               *
36859               * ******************************************************************************
36860               
36861               SHIP_MAMBA:
36862 E982 01              byte >01                                            ; Max. canisters on demise = 1
36863 E984 1324            data 70 * 70                                        ; Targetable area          = 70 * 70
36864               
36865 E986 AC              byte (SHIP_MAMBA_EDGES - SHIP_MAMBA)%256            ; Edges data offset (low)
36866 E987   1C            byte (SHIP_MAMBA_FACES - SHIP_MAMBA)%256            ; Faces data offset (low)
36867               
36868 E988 5D              byte >5d                                            ; Max. edge count          = (93 - 1) / 4 = 23
36869 E989   00            byte >00                                            ; Gun vertex               = 0
36870 E98A 22              byte >22                                            ; Explosion count          = 7, as (4 * n) + 6 = 34
36871 E98B   96            byte >96                                            ; Number of vertices       = 150 / 6 = 25
36872 E98C 1C              byte >1c                                            ; Number of edges          = 28
36873 E98E 9600            data >9600                                          ; Bounty                   = 150
36874 E990 14              byte >14                                            ; Number of faces          = 20 / 4 = 5
36875 E991   19            byte >19                                            ; Visibility distance      = 25
36876 E992 5A              byte >5a                                            ; Max. energy              = 90
36877 E993   1E            byte >1e                                            ; Max. speed               = 30
36878               
36879 E994 00              byte (SHIP_MAMBA_EDGES - SHIP_MAMBA)/256            ; Edges data offset (high)
36880 E995   01            byte (SHIP_MAMBA_FACES - SHIP_MAMBA)/256            ; Faces data offset (high)
36881               
36882 E996 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
36883 E997   12            byte >12                                            ; Laser power              = 2
36884                                                                          ; Missiles                 = 2
36885               
36886               SHIP_MAMBA_VERTICES:
36887                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36888 E998 0000            byte >00, >00, >40, >1f, >10, >32                   ; Vertex 0
     E99A 401F     
     E99C 1032     
36889 E99E 4008            byte >40, >08, >20, >ff, >20, >44                   ; Vertex 1
     E9A0 20FF     
     E9A2 2044     
36890 E9A4 2008            byte >20, >08, >20, >be, >21, >44                   ; Vertex 2
     E9A6 20BE     
     E9A8 2144     
36891 E9AA 2008            byte >20, >08, >20, >3e, >31, >44                   ; Vertex 3
     E9AC 203E     
     E9AE 3144     
36892 E9B0 4008            byte >40, >08, >20, >7f, >30, >44                   ; Vertex 4
     E9B2 207F     
     E9B4 3044     
36893 E9B6 0404            byte >04, >04, >10, >8e, >11, >11                   ; Vertex 5
     E9B8 108E     
     E9BA 1111     
36894 E9BC 0404            byte >04, >04, >10, >0e, >11, >11                   ; Vertex 6
     E9BE 100E     
     E9C0 1111     
36895 E9C2 0803            byte >08, >03, >1c, >0d, >11, >11                   ; Vertex 7
     E9C4 1C0D     
     E9C6 1111     
36896 E9C8 0803            byte >08, >03, >1c, >8d, >11, >11                   ; Vertex 8
     E9CA 1C8D     
     E9CC 1111     
36897 E9CE 1404            byte >14, >04, >10, >d4, >00, >00                   ; Vertex 9
     E9D0 10D4     
     E9D2 0000     
36898 E9D4 1404            byte >14, >04, >10, >54, >00, >00                   ; Vertex 10
     E9D6 1054     
     E9D8 0000     
36899 E9DA 1807            byte >18, >07, >14, >f4, >00, >00                   ; Vertex 11
     E9DC 14F4     
     E9DE 0000     
36900 E9E0 1007            byte >10, >07, >14, >f0, >00, >00                   ; Vertex 12
     E9E2 14F0     
     E9E4 0000     
36901 E9E6 1007            byte >10, >07, >14, >70, >00, >00                   ; Vertex 13
     E9E8 1470     
     E9EA 0000     
36902 E9EC 1807            byte >18, >07, >14, >74, >00, >00                   ; Vertex 14
     E9EE 1474     
     E9F0 0000     
36903 E9F2 0804            byte >08, >04, >20, >ad, >44, >44                   ; Vertex 15
     E9F4 20AD     
     E9F6 4444     
36904 E9F8 0804            byte >08, >04, >20, >2d, >44, >44                   ; Vertex 16
     E9FA 202D     
     E9FC 4444     
36905 E9FE 0804            byte >08, >04, >20, >6e, >44, >44                   ; Vertex 17
     EA00 206E     
     EA02 4444     
36906 EA04 0804            byte >08, >04, >20, >ee, >44, >44                   ; Vertex 18
     EA06 20EE     
     EA08 4444     
36907 EA0A 2004            byte >20, >04, >20, >a7, >44, >44                   ; Vertex 19
     EA0C 20A7     
     EA0E 4444     
36908 EA10 2004            byte >20, >04, >20, >27, >44, >44                   ; Vertex 20
     EA12 2027     
     EA14 4444     
36909 EA16 2404            byte >24, >04, >20, >67, >44, >44                   ; Vertex 21
     EA18 2067     
     EA1A 4444     
36910 EA1C 2404            byte >24, >04, >20, >e7, >44, >44                   ; Vertex 22
     EA1E 20E7     
     EA20 4444     
36911 EA22 2600            byte >26, >00, >20, >a5, >44, >44                   ; Vertex 23
     EA24 20A5     
     EA26 4444     
36912 EA28 2600            byte >26, >00, >20, >25, >44, >44                   ; Vertex 24
     EA2A 2025     
     EA2C 4444     
36913               
36914               SHIP_MAMBA_EDGES:
36915                                                                          ; vertex1, vertex2, face1, face2, visibility
36916 EA2E 1F20            byte >1f, >20, >00, >04                             ; Edge 0
     EA30 0004     
36917 EA32 1F30            byte >1f, >30, >00, >10                             ; Edge 1
     EA34 0010     
36918 EA36 1F40            byte >1f, >40, >04, >10                             ; Edge 2
     EA38 0410     
36919 EA3A 1E42            byte >1e, >42, >04, >08                             ; Edge 3
     EA3C 0408     
36920 EA3E 1E41            byte >1e, >41, >08, >0c                             ; Edge 4
     EA40 080C     
36921 EA42 1E43            byte >1e, >43, >0c, >10                             ; Edge 5
     EA44 0C10     
36922 EA46 0E11            byte >0e, >11, >14, >18                             ; Edge 6
     EA48 1418     
36923 EA4A 0C11            byte >0c, >11, >18, >1c                             ; Edge 7
     EA4C 181C     
36924 EA4E 0D11            byte >0d, >11, >1c, >20                             ; Edge 8
     EA50 1C20     
36925 EA52 0C11            byte >0c, >11, >14, >20                             ; Edge 9
     EA54 1420     
36926 EA56 1400            byte >14, >00, >24, >2c                             ; Edge 10
     EA58 242C     
36927 EA5A 1000            byte >10, >00, >24, >30                             ; Edge 11
     EA5C 2430     
36928 EA5E 1000            byte >10, >00, >28, >34                             ; Edge 12
     EA60 2834     
36929 EA62 1400            byte >14, >00, >28, >38                             ; Edge 13
     EA64 2838     
36930 EA66 0E00            byte >0e, >00, >34, >38                             ; Edge 14
     EA68 3438     
36931 EA6A 0E00            byte >0e, >00, >2c, >30                             ; Edge 15
     EA6C 2C30     
36932 EA6E 0D44            byte >0d, >44, >3c, >40                             ; Edge 16
     EA70 3C40     
36933 EA72 0E44            byte >0e, >44, >44, >48                             ; Edge 17
     EA74 4448     
36934 EA76 0C44            byte >0c, >44, >3c, >48                             ; Edge 18
     EA78 3C48     
36935 EA7A 0C44            byte >0c, >44, >40, >44                             ; Edge 19
     EA7C 4044     
36936 EA7E 0744            byte >07, >44, >50, >54                             ; Edge 20
     EA80 5054     
36937 EA82 0544            byte >05, >44, >50, >60                             ; Edge 21
     EA84 5060     
36938 EA86 0544            byte >05, >44, >54, >60                             ; Edge 22
     EA88 5460     
36939 EA8A 0744            byte >07, >44, >4c, >58                             ; Edge 23
     EA8C 4C58     
36940 EA8E 0544            byte >05, >44, >4c, >5c                             ; Edge 24
     EA90 4C5C     
36941 EA92 0544            byte >05, >44, >58, >5c                             ; Edge 25
     EA94 585C     
36942 EA96 1E21            byte >1e, >21, >00, >08                             ; Edge 26
     EA98 0008     
36943 EA9A 1E31            byte >1e, >31, >00, >0c                             ; Edge 27
     EA9C 000C     
36944               
36945               SHIP_MAMBA_FACES:
36946                                                                          ; normal_x, normal_y, normal_z, visibility
36947 EA9E 5E00            byte >5e, >00, >18, >02                             ; Face 0
     EAA0 1802     
36948 EAA2 1E00            byte >1e, >00, >18, >02                             ; Face 1
     EAA4 1802     
36949 EAA6 9E20            byte >9e, >20, >40, >10                             ; Face 2
     EAA8 4010     
36950 EAAA 1E20            byte >1e, >20, >40, >10                             ; Face 3
     EAAC 4010     
36951 EAAE 3E00            byte >3e, >00, >00, >7f                             ; Face 4
     EAB0 007F     
36952               
36953               * ******************************************************************************
36954               *
36955               * Name: SHIP_COBRA_MK_3
36956               * Type: Variable
36957               * Category: Drawing ships
36958               * Summary: Ship blueprint for a Cobra Mk III
36959               * Deep dive: Ship blueprints
36960               *
36961               * ******************************************************************************
36962               
36963               SHIP_COBRA_MK_3:
36964 EAB2 03              byte >03                                            ; Max. canisters on demise = 3
36965 EAB4 2341            data 95 * 95                                        ; Targetable area          = 95 * 95
36966               
36967 EAB6 BE              byte (SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)%256  ; Edges data offset (low)
36968 EAB7   56            byte (SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)%256  ; Faces data offset (low)
36969               
36970 EAB8 99              byte >99                                            ; Max. edge count          = (153 - 1) / 4 = 38
36971 EAB9   54            byte >54                                            ; Gun vertex               = 84 / 4 = 21
36972 EABA 2A              byte >2a                                            ; Explosion count          = 9, as (4 * n) + 6 = 42
36973 EABB   A8            byte >a8                                            ; Number of vertices       = 168 / 6 = 28
36974 EABC 26              byte >26                                            ; Number of edges          = 38
36975 EABE 0000            data >0000                                          ; Bounty                   = 0
36976 EAC0 34              byte >34                                            ; Number of faces          = 52 / 4 = 13
36977 EAC1   32            byte >32                                            ; Visibility distance      = 50
36978 EAC2 96              byte >96                                            ; Max. energy              = 150
36979 EAC3   1C            byte >1c                                            ; Max. speed               = 28
36980               
36981 EAC4 00              byte (SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)/256  ; Edges data offset (low)
36982 EAC5   01            byte (SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)/256  ; Faces data offset (low)
36983               
36984 EAC6 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
36985 EAC7   13            byte >13                                            ; Laser power              = 2
36986                                                                          ; Missiles                 = 3
36987               
36988               SHIP_COBRA_MK_3_VERTICES:
36989                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36990 EAC8 2000            byte >20, >00, >4c, >1f, >ff, >ff                   ; Vertex 0
     EACA 4C1F     
     EACC FFFF     
36991 EACE 2000            byte >20, >00, >4c, >9f, >ff, >ff                   ; Vertex 1
     EAD0 4C9F     
     EAD2 FFFF     
36992 EAD4 001A            byte >00, >1a, >18, >1f, >ff, >ff                   ; Vertex 2
     EAD6 181F     
     EAD8 FFFF     
36993 EADA 7803            byte >78, >03, >08, >ff, >73, >aa                   ; Vertex 3
     EADC 08FF     
     EADE 73AA     
36994 EAE0 7803            byte >78, >03, >08, >7f, >84, >cc                   ; Vertex 4
     EAE2 087F     
     EAE4 84CC     
36995 EAE6 5810            byte >58, >10, >28, >bf, >ff, >ff                   ; Vertex 5
     EAE8 28BF     
     EAEA FFFF     
36996 EAEC 5810            byte >58, >10, >28, >3f, >ff, >ff                   ; Vertex 6
     EAEE 283F     
     EAF0 FFFF     
36997 EAF2 8008            byte >80, >08, >28, >7f, >98, >cc                   ; Vertex 7
     EAF4 287F     
     EAF6 98CC     
36998 EAF8 8008            byte >80, >08, >28, >ff, >97, >aa                   ; Vertex 8
     EAFA 28FF     
     EAFC 97AA     
36999 EAFE 001A            byte >00, >1a, >28, >3f, >65, >99                   ; Vertex 9
     EB00 283F     
     EB02 6599     
37000 EB04 2018            byte >20, >18, >28, >ff, >a9, >bb                   ; Vertex 10
     EB06 28FF     
     EB08 A9BB     
37001 EB0A 2018            byte >20, >18, >28, >7f, >b9, >cc                   ; Vertex 11
     EB0C 287F     
     EB0E B9CC     
37002 EB10 2408            byte >24, >08, >28, >b4, >99, >99                   ; Vertex 12
     EB12 28B4     
     EB14 9999     
37003 EB16 080C            byte >08, >0c, >28, >b4, >99, >99                   ; Vertex 13
     EB18 28B4     
     EB1A 9999     
37004 EB1C 080C            byte >08, >0c, >28, >34, >99, >99                   ; Vertex 14
     EB1E 2834     
     EB20 9999     
37005 EB22 2408            byte >24, >08, >28, >34, >99, >99                   ; Vertex 15
     EB24 2834     
     EB26 9999     
37006 EB28 240C            byte >24, >0c, >28, >74, >99, >99                   ; Vertex 16
     EB2A 2874     
     EB2C 9999     
37007 EB2E 0810            byte >08, >10, >28, >74, >99, >99                   ; Vertex 17
     EB30 2874     
     EB32 9999     
37008 EB34 0810            byte >08, >10, >28, >f4, >99, >99                   ; Vertex 18
     EB36 28F4     
     EB38 9999     
37009 EB3A 240C            byte >24, >0c, >28, >f4, >99, >99                   ; Vertex 19
     EB3C 28F4     
     EB3E 9999     
37010 EB40 0000            byte >00, >00, >4c, >06, >b0, >bb                   ; Vertex 20
     EB42 4C06     
     EB44 B0BB     
37011 EB46 0000            byte >00, >00, >5a, >1f, >b0, >bb                   ; Vertex 21
     EB48 5A1F     
     EB4A B0BB     
37012 EB4C 5006            byte >50, >06, >28, >e8, >99, >99                   ; Vertex 22
     EB4E 28E8     
     EB50 9999     
37013 EB52 5006            byte >50, >06, >28, >a8, >99, >99                   ; Vertex 23
     EB54 28A8     
     EB56 9999     
37014 EB58 5800            byte >58, >00, >28, >a6, >99, >99                   ; Vertex 24
     EB5A 28A6     
     EB5C 9999     
37015 EB5E 5006            byte >50, >06, >28, >28, >99, >99                   ; Vertex 25
     EB60 2828     
     EB62 9999     
37016 EB64 5800            byte >58, >00, >28, >26, >99, >99                   ; Vertex 26
     EB66 2826     
     EB68 9999     
37017 EB6A 5006            byte >50, >06, >28, >68, >99, >99                   ; Vertex 27
     EB6C 2868     
     EB6E 9999     
37018               
37019               SHIP_COBRA_MK_3_EDGES:
37020                                                                          ; vertex1, vertex2, face1, face2, visibility
37021 EB70 1FB0            byte >1f, >b0, >00, >04                             ; Edge 0
     EB72 0004     
37022 EB74 1FC4            byte >1f, >c4, >00, >10                             ; Edge 1
     EB76 0010     
37023 EB78 1FA3            byte >1f, >a3, >04, >0c                             ; Edge 2
     EB7A 040C     
37024 EB7C 1FA7            byte >1f, >a7, >0c, >20                             ; Edge 3
     EB7E 0C20     
37025 EB80 1FC8            byte >1f, >c8, >10, >1c                             ; Edge 4
     EB82 101C     
37026 EB84 1F98            byte >1f, >98, >18, >1c                             ; Edge 5
     EB86 181C     
37027 EB88 1F96            byte >1f, >96, >18, >24                             ; Edge 6
     EB8A 1824     
37028 EB8C 1F95            byte >1f, >95, >14, >24                             ; Edge 7
     EB8E 1424     
37029 EB90 1F97            byte >1f, >97, >14, >20                             ; Edge 8
     EB92 1420     
37030 EB94 1F51            byte >1f, >51, >08, >14                             ; Edge 9
     EB96 0814     
37031 EB98 1F62            byte >1f, >62, >08, >18                             ; Edge 10
     EB9A 0818     
37032 EB9C 1F73            byte >1f, >73, >0c, >14                             ; Edge 11
     EB9E 0C14     
37033 EBA0 1F84            byte >1f, >84, >10, >18                             ; Edge 12
     EBA2 1018     
37034 EBA4 1F10            byte >1f, >10, >04, >08                             ; Edge 13
     EBA6 0408     
37035 EBA8 1F20            byte >1f, >20, >00, >08                             ; Edge 14
     EBAA 0008     
37036 EBAC 1FA9            byte >1f, >a9, >20, >28                             ; Edge 15
     EBAE 2028     
37037 EBB0 1FB9            byte >1f, >b9, >28, >2c                             ; Edge 16
     EBB2 282C     
37038 EBB4 1FC9            byte >1f, >c9, >1c, >2c                             ; Edge 17
     EBB6 1C2C     
37039 EBB8 1FBA            byte >1f, >ba, >04, >28                             ; Edge 18
     EBBA 0428     
37040 EBBC 1FCB            byte >1f, >cb, >00, >2c                             ; Edge 19
     EBBE 002C     
37041 EBC0 1D31            byte >1d, >31, >04, >14                             ; Edge 20
     EBC2 0414     
37042 EBC4 1D42            byte >1d, >42, >00, >18                             ; Edge 21
     EBC6 0018     
37043 EBC8 06B0            byte >06, >b0, >50, >54                             ; Edge 22
     EBCA 5054     
37044 EBCC 1499            byte >14, >99, >30, >34                             ; Edge 23
     EBCE 3034     
37045 EBD0 1499            byte >14, >99, >48, >4c                             ; Edge 24
     EBD2 484C     
37046 EBD4 1499            byte >14, >99, >38, >3c                             ; Edge 25
     EBD6 383C     
37047 EBD8 1499            byte >14, >99, >40, >44                             ; Edge 26
     EBDA 4044     
37048 EBDC 1399            byte >13, >99, >3c, >40                             ; Edge 27
     EBDE 3C40     
37049 EBE0 1199            byte >11, >99, >38, >44                             ; Edge 28
     EBE2 3844     
37050 EBE4 1399            byte >13, >99, >34, >48                             ; Edge 29
     EBE6 3448     
37051 EBE8 1399            byte >13, >99, >30, >4c                             ; Edge 30
     EBEA 304C     
37052 EBEC 1E65            byte >1e, >65, >08, >24                             ; Edge 31
     EBEE 0824     
37053 EBF0 0699            byte >06, >99, >58, >60                             ; Edge 32
     EBF2 5860     
37054 EBF4 0699            byte >06, >99, >5c, >60                             ; Edge 33
     EBF6 5C60     
37055 EBF8 0899            byte >08, >99, >58, >5c                             ; Edge 34
     EBFA 585C     
37056 EBFC 0699            byte >06, >99, >64, >68                             ; Edge 35
     EBFE 6468     
37057 EC00 0699            byte >06, >99, >68, >6c                             ; Edge 36
     EC02 686C     
37058 EC04 0899            byte >08, >99, >64, >6c                             ; Edge 37
     EC06 646C     
37059               
37060               SHIP_COBRA_MK_3_FACES:
37061                                                                          ; normal_x, normal_y, normal_z, visibility
37062 EC08 1F00            byte >1f, >00, >3e, >1f                             ; Face 0
     EC0A 3E1F     
37063 EC0C 9F12            byte >9f, >12, >37, >10                             ; Face 1
     EC0E 3710     
37064 EC10 1F12            byte >1f, >12, >37, >10                             ; Face 2
     EC12 3710     
37065 EC14 9F10            byte >9f, >10, >34, >0e                             ; Face 3
     EC16 340E     
37066 EC18 1F10            byte >1f, >10, >34, >0e                             ; Face 4
     EC1A 340E     
37067 EC1C 9F0E            byte >9f, >0e, >2f, >00                             ; Face 5
     EC1E 2F00     
37068 EC20 1F0E            byte >1f, >0e, >2f, >00                             ; Face 6
     EC22 2F00     
37069 EC24 9F3D            byte >9f, >3d, >66, >00                             ; Face 7
     EC26 6600     
37070 EC28 1F3D            byte >1f, >3d, >66, >00                             ; Face 8
     EC2A 6600     
37071 EC2C 3F00            byte >3f, >00, >00, >50                             ; Face 9
     EC2E 0050     
37072 EC30 DF07            byte >df, >07, >2a, >09                             ; Face 10
     EC32 2A09     
37073 EC34 5F00            byte >5f, >00, >1e, >06                             ; Face 11
     EC36 1E06     
37074 EC38 5F07            byte >5f, >07, >2a, >09                             ; Face 12
     EC3A 2A09     
37075               
37076               * ******************************************************************************
37077               *
37078               * Name: SHIP_THARGOID
37079               * Type: Variable
37080               * Category: Drawing ships
37081               * Summary: Ship blueprint for a Thargoid mothership
37082               * Deep dive: Ship blueprints
37083               *
37084               * ******************************************************************************
37085               
37086               SHIP_THARGOID:
37087 EC3C 00              byte >00                                            ; Max. canisters on demise = 0
37088 EC3E 2649            data 99 * 99                                        ; Targetable area          = 99 * 99
37089               
37090 EC40 8E              byte (SHIP_THARGOID_EDGES - SHIP_THARGOID)%256      ; Edges data offset (low)
37091 EC41   F6            byte (SHIP_THARGOID_FACES - SHIP_THARGOID)%256      ; Faces data offset (low)
37092               
37093 EC42 65              byte >65                                            ; Max. edge count          = (101 - 1) / 4 = 25
37094 EC43   3C            byte >3c                                            ; Gun vertex               = 60 / 4 = 15
37095 EC44 26              byte >26                                            ; Explosion count          = 8, as (4 * n) + 6 = 38
37096 EC45   78            byte >78                                            ; Number of vertices       = 120 / 6 = 20
37097 EC46 1A              byte >1a                                            ; Number of edges          = 26
37098 EC48 F401            data >f401                                          ; Bounty                   = 500
37099 EC4A 28              byte >28                                            ; Number of faces          = 40 / 4 = 10
37100 EC4B   37            byte >37                                            ; Visibility distance      = 55
37101 EC4C F0              byte >f0                                            ; Max. energy              = 240
37102 EC4D   27            byte >27                                            ; Max. speed               = 39
37103               
37104 EC4E 00              byte (SHIP_THARGOID_EDGES - SHIP_THARGOID)/256      ; Edges data offset (high)
37105 EC4F   00            byte (SHIP_THARGOID_FACES - SHIP_THARGOID)/256      ; Faces data offset (high)
37106               
37107 EC50 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37108 EC51   16            byte >16                                            ; Laser power              = 2
37109                                                                          ; Missiles                 = 6
37110               
37111               SHIP_THARGOID_VERTICES:
37112                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37113 EC52 2030            byte >20, >30, >30, >5f, >40, >88                   ; Vertex 0
     EC54 305F     
     EC56 4088     
37114 EC58 2044            byte >20, >44, >00, >5f, >10, >44                   ; Vertex 1
     EC5A 005F     
     EC5C 1044     
37115 EC5E 2030            byte >20, >30, >30, >7f, >21, >44                   ; Vertex 2
     EC60 307F     
     EC62 2144     
37116 EC64 2000            byte >20, >00, >44, >3f, >32, >44                   ; Vertex 3
     EC66 443F     
     EC68 3244     
37117 EC6A 2030            byte >20, >30, >30, >3f, >43, >55                   ; Vertex 4
     EC6C 303F     
     EC6E 4355     
37118 EC70 2044            byte >20, >44, >00, >1f, >54, >66                   ; Vertex 5
     EC72 001F     
     EC74 5466     
37119 EC76 2030            byte >20, >30, >30, >1f, >64, >77                   ; Vertex 6
     EC78 301F     
     EC7A 6477     
37120 EC7C 2000            byte >20, >00, >44, >1f, >74, >88                   ; Vertex 7
     EC7E 441F     
     EC80 7488     
37121 EC82 1874            byte >18, >74, >74, >df, >80, >99                   ; Vertex 8
     EC84 74DF     
     EC86 8099     
37122 EC88 18A4            byte >18, >a4, >00, >df, >10, >99                   ; Vertex 9
     EC8A 00DF     
     EC8C 1099     
37123 EC8E 1874            byte >18, >74, >74, >ff, >21, >99                   ; Vertex 10
     EC90 74FF     
     EC92 2199     
37124 EC94 1800            byte >18, >00, >a4, >bf, >32, >99                   ; Vertex 11
     EC96 A4BF     
     EC98 3299     
37125 EC9A 1874            byte >18, >74, >74, >bf, >53, >99                   ; Vertex 12
     EC9C 74BF     
     EC9E 5399     
37126 ECA0 18A4            byte >18, >a4, >00, >9f, >65, >99                   ; Vertex 13
     ECA2 009F     
     ECA4 6599     
37127 ECA6 1874            byte >18, >74, >74, >9f, >76, >99                   ; Vertex 14
     ECA8 749F     
     ECAA 7699     
37128 ECAC 1800            byte >18, >00, >a4, >9f, >87, >99                   ; Vertex 15
     ECAE A49F     
     ECB0 8799     
37129 ECB2 1840            byte >18, >40, >50, >9e, >99, >99                   ; Vertex 16
     ECB4 509E     
     ECB6 9999     
37130 ECB8 1840            byte >18, >40, >50, >be, >99, >99                   ; Vertex 17
     ECBA 50BE     
     ECBC 9999     
37131 ECBE 1840            byte >18, >40, >50, >fe, >99, >99                   ; Vertex 18
     ECC0 50FE     
     ECC2 9999     
37132 ECC4 1840            byte >18, >40, >50, >de, >99, >99                   ; Vertex 19
     ECC6 50DE     
     ECC8 9999     
37133               
37134               SHIP_THARGOID_EDGES:
37135                                                                          ; vertex1, vertex2, face1, face2, visibility
37136 ECCA 1F84            byte >1f, >84, >00, >1c                             ; Edge 0
     ECCC 001C     
37137 ECCE 1F40            byte >1f, >40, >00, >04                             ; Edge 1
     ECD0 0004     
37138 ECD2 1F41            byte >1f, >41, >04, >08                             ; Edge 2
     ECD4 0408     
37139 ECD6 1F42            byte >1f, >42, >08, >0c                             ; Edge 3
     ECD8 080C     
37140 ECDA 1F43            byte >1f, >43, >0c, >10                             ; Edge 4
     ECDC 0C10     
37141 ECDE 1F54            byte >1f, >54, >10, >14                             ; Edge 5
     ECE0 1014     
37142 ECE2 1F64            byte >1f, >64, >14, >18                             ; Edge 6
     ECE4 1418     
37143 ECE6 1F74            byte >1f, >74, >18, >1c                             ; Edge 7
     ECE8 181C     
37144 ECEA 1F80            byte >1f, >80, >00, >20                             ; Edge 8
     ECEC 0020     
37145 ECEE 1F10            byte >1f, >10, >04, >24                             ; Edge 9
     ECF0 0424     
37146 ECF2 1F21            byte >1f, >21, >08, >28                             ; Edge 10
     ECF4 0828     
37147 ECF6 1F32            byte >1f, >32, >0c, >2c                             ; Edge 11
     ECF8 0C2C     
37148 ECFA 1F53            byte >1f, >53, >10, >30                             ; Edge 12
     ECFC 1030     
37149 ECFE 1F65            byte >1f, >65, >14, >34                             ; Edge 13
     ED00 1434     
37150 ED02 1F76            byte >1f, >76, >18, >38                             ; Edge 14
     ED04 1838     
37151 ED06 1F87            byte >1f, >87, >1c, >3c                             ; Edge 15
     ED08 1C3C     
37152 ED0A 1F98            byte >1f, >98, >20, >3c                             ; Edge 16
     ED0C 203C     
37153 ED0E 1F90            byte >1f, >90, >20, >24                             ; Edge 17
     ED10 2024     
37154 ED12 1F91            byte >1f, >91, >24, >28                             ; Edge 18
     ED14 2428     
37155 ED16 1F92            byte >1f, >92, >28, >2c                             ; Edge 19
     ED18 282C     
37156 ED1A 1F93            byte >1f, >93, >2c, >30                             ; Edge 20
     ED1C 2C30     
37157 ED1E 1F95            byte >1f, >95, >30, >34                             ; Edge 21
     ED20 3034     
37158 ED22 1F96            byte >1f, >96, >34, >38                             ; Edge 22
     ED24 3438     
37159 ED26 1F97            byte >1f, >97, >38, >3c                             ; Edge 23
     ED28 383C     
37160 ED2A 1E99            byte >1e, >99, >40, >44                             ; Edge 24
     ED2C 4044     
37161 ED2E 1E99            byte >1e, >99, >48, >4c                             ; Edge 25
     ED30 484C     
37162               
37163               SHIP_THARGOID_FACES:
37164                                                                          ; normal_x, normal_y, normal_z, visibility
37165 ED32 5F67            byte >5f, >67, >3c, >19                             ; Face 0
     ED34 3C19     
37166 ED36 7F67            byte >7f, >67, >3c, >19                             ; Face 1
     ED38 3C19     
37167 ED3A 7F67            byte >7f, >67, >19, >3c                             ; Face 2
     ED3C 193C     
37168 ED3E 3F67            byte >3f, >67, >19, >3c                             ; Face 3
     ED40 193C     
37169 ED42 1F40            byte >1f, >40, >00, >00                             ; Face 4
     ED44 0000     
37170 ED46 3F67            byte >3f, >67, >3c, >19                             ; Face 5
     ED48 3C19     
37171 ED4A 1F67            byte >1f, >67, >3c, >19                             ; Face 6
     ED4C 3C19     
37172 ED4E 1F67            byte >1f, >67, >19, >3c                             ; Face 7
     ED50 193C     
37173 ED52 5F67            byte >5f, >67, >19, >3c                             ; Face 8
     ED54 193C     
37174 ED56 9F30            byte >9f, >30, >00, >00                             ; Face 9
     ED58 0000     
37175               
37176               * ******************************************************************************
37177               *
37178               * Name: SHIP_CORIOLIS
37179               * Type: Variable
37180               * Category: Drawing ships
37181               * Summary: Ship blueprint for a Coriolis space station
37182               * Deep dive: Ship blueprints
37183               *
37184               * ******************************************************************************
37185               
37186               SHIP_CORIOLIS:
37187 ED5A 00              byte >00                                            ; Max. canisters on demise = 0
37188 ED5C 6400            data 160 * 160                                      ; Targetable area          = 160 * 160
37189               
37190 ED5E 76              byte (SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)%256      ; Edges data offset (low)
37191 ED5F   E6            byte (SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)%256      ; Faces data offset (low)
37192               
37193 ED60 55              byte >55                                            ; Max. edge count          = (85 - 1) / 4 = 21
37194 ED61   00            byte >00                                            ; Gun vertex               = 0
37195 ED62 36              byte >36                                            ; Explosion count          = 12, as (4 * n) + 6 = 54
37196 ED63   60            byte >60                                            ; Number of vertices       = 96 / 6 = 16
37197 ED64 1C              byte >1c                                            ; Number of edges          = 28
37198 ED66 0000            data >0000                                          ; Bounty                   = 0
37199 ED68 38              byte >38                                            ; Number of faces          = 56 / 4 = 14
37200 ED69   78            byte >78                                            ; Visibility distance      = 120
37201 ED6A F0              byte >f0                                            ; Max. energy              = 240
37202 ED6B   00            byte >00                                            ; Max. speed               = 0
37203               
37204 ED6C 00              byte (SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)/256      ; Edges data offset (high)
37205 ED6D   00            byte (SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)/256      ; Faces data offset (high)
37206               
37207 ED6E 00              byte >00                                            ; Normals are scaled by    = 2^0 = 1
37208 ED6F   06            byte >06                                            ; Laser power              = 0
37209                                                                          ; Missiles                 = 6
37210               
37211               SHIP_CORIOLIS_VERTICES:
37212                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37213 ED70 A000            byte >a0, >00, >a0, >1f, >10, >62                   ; Vertex 0
     ED72 A01F     
     ED74 1062     
37214 ED76 00A0            byte >00, >a0, >a0, >1f, >20, >83                   ; Vertex 1
     ED78 A01F     
     ED7A 2083     
37215 ED7C A000            byte >a0, >00, >a0, >9f, >30, >74                   ; Vertex 2
     ED7E A09F     
     ED80 3074     
37216 ED82 00A0            byte >00, >a0, >a0, >5f, >10, >54                   ; Vertex 3
     ED84 A05F     
     ED86 1054     
37217 ED88 A0A0            byte >a0, >a0, >00, >5f, >51, >a6                   ; Vertex 4
     ED8A 005F     
     ED8C 51A6     
37218 ED8E A0A0            byte >a0, >a0, >00, >1f, >62, >b8                   ; Vertex 5
     ED90 001F     
     ED92 62B8     
37219 ED94 A0A0            byte >a0, >a0, >00, >9f, >73, >c8                   ; Vertex 6
     ED96 009F     
     ED98 73C8     
37220 ED9A A0A0            byte >a0, >a0, >00, >df, >54, >97                   ; Vertex 7
     ED9C 00DF     
     ED9E 5497     
37221 EDA0 A000            byte >a0, >00, >a0, >3f, >a6, >db                   ; Vertex 8
     EDA2 A03F     
     EDA4 A6DB     
37222 EDA6 00A0            byte >00, >a0, >a0, >3f, >b8, >dc                   ; Vertex 9
     EDA8 A03F     
     EDAA B8DC     
37223 EDAC A000            byte >a0, >00, >a0, >bf, >97, >dc                   ; Vertex 10
     EDAE A0BF     
     EDB0 97DC     
37224 EDB2 00A0            byte >00, >a0, >a0, >7f, >95, >da                   ; Vertex 11
     EDB4 A07F     
     EDB6 95DA     
37225 EDB8 0A1E            byte >0a, >1e, >a0, >5e, >00, >00                   ; Vertex 12
     EDBA A05E     
     EDBC 0000     
37226 EDBE 0A1E            byte >0a, >1e, >a0, >1e, >00, >00                   ; Vertex 13
     EDC0 A01E     
     EDC2 0000     
37227 EDC4 0A1E            byte >0a, >1e, >a0, >9e, >00, >00                   ; Vertex 14
     EDC6 A09E     
     EDC8 0000     
37228 EDCA 0A1E            byte >0a, >1e, >a0, >de, >00, >00                   ; Vertex 15
     EDCC A0DE     
     EDCE 0000     
37229               
37230               SHIP_CORIOLIS_EDGES:
37231                                                                          ; vertex1, vertex2, face1, face2, visibility
37232 EDD0 1F10            byte >1f, >10, >00, >0c                             ; Edge 0
     EDD2 000C     
37233 EDD4 1F20            byte >1f, >20, >00, >04                             ; Edge 1
     EDD6 0004     
37234 EDD8 1F30            byte >1f, >30, >04, >08                             ; Edge 2
     EDDA 0408     
37235 EDDC 1F40            byte >1f, >40, >08, >0c                             ; Edge 3
     EDDE 080C     
37236 EDE0 1F51            byte >1f, >51, >0c, >10                             ; Edge 4
     EDE2 0C10     
37237 EDE4 1F61            byte >1f, >61, >00, >10                             ; Edge 5
     EDE6 0010     
37238 EDE8 1F62            byte >1f, >62, >00, >14                             ; Edge 6
     EDEA 0014     
37239 EDEC 1F82            byte >1f, >82, >14, >04                             ; Edge 7
     EDEE 1404     
37240 EDF0 1F83            byte >1f, >83, >04, >18                             ; Edge 8
     EDF2 0418     
37241 EDF4 1F73            byte >1f, >73, >08, >18                             ; Edge 9
     EDF6 0818     
37242 EDF8 1F74            byte >1f, >74, >08, >1c                             ; Edge 10
     EDFA 081C     
37243 EDFC 1F54            byte >1f, >54, >0c, >1c                             ; Edge 11
     EDFE 0C1C     
37244 EE00 1FDA            byte >1f, >da, >20, >2c                             ; Edge 12
     EE02 202C     
37245 EE04 1FDB            byte >1f, >db, >20, >24                             ; Edge 13
     EE06 2024     
37246 EE08 1FDC            byte >1f, >dc, >24, >28                             ; Edge 14
     EE0A 2428     
37247 EE0C 1FD9            byte >1f, >d9, >28, >2c                             ; Edge 15
     EE0E 282C     
37248 EE10 1FA5            byte >1f, >a5, >10, >2c                             ; Edge 16
     EE12 102C     
37249 EE14 1FA6            byte >1f, >a6, >10, >20                             ; Edge 17
     EE16 1020     
37250 EE18 1FB6            byte >1f, >b6, >14, >20                             ; Edge 18
     EE1A 1420     
37251 EE1C 1FB8            byte >1f, >b8, >14, >24                             ; Edge 19
     EE1E 1424     
37252 EE20 1FC8            byte >1f, >c8, >18, >24                             ; Edge 20
     EE22 1824     
37253 EE24 1FC7            byte >1f, >c7, >18, >28                             ; Edge 21
     EE26 1828     
37254 EE28 1F97            byte >1f, >97, >1c, >28                             ; Edge 22
     EE2A 1C28     
37255 EE2C 1F95            byte >1f, >95, >1c, >2c                             ; Edge 23
     EE2E 1C2C     
37256 EE30 1E00            byte >1e, >00, >30, >34                             ; Edge 24
     EE32 3034     
37257 EE34 1E00            byte >1e, >00, >34, >38                             ; Edge 25
     EE36 3438     
37258 EE38 1E00            byte >1e, >00, >38, >3c                             ; Edge 26
     EE3A 383C     
37259 EE3C 1E00            byte >1e, >00, >3c, >30                             ; Edge 27
     EE3E 3C30     
37260               
37261               SHIP_CORIOLIS_FACES:
37262                                                                          ; normal_x, normal_y, normal_z, visibility
37263 EE40 1F00            byte >1f, >00, >00, >a0                             ; Face 0
     EE42 00A0     
37264 EE44 5F6B            byte >5f, >6b, >6b, >6b                             ; Face 1
     EE46 6B6B     
37265 EE48 1F6B            byte >1f, >6b, >6b, >6b                             ; Face 2
     EE4A 6B6B     
37266 EE4C 9F6B            byte >9f, >6b, >6b, >6b                             ; Face 3
     EE4E 6B6B     
37267 EE50 DF6B            byte >df, >6b, >6b, >6b                             ; Face 4
     EE52 6B6B     
37268 EE54 5F00            byte >5f, >00, >a0, >00                             ; Face 5
     EE56 A000     
37269 EE58 1FA0            byte >1f, >a0, >00, >00                             ; Face 6
     EE5A 0000     
37270 EE5C 9FA0            byte >9f, >a0, >00, >00                             ; Face 7
     EE5E 0000     
37271 EE60 1F00            byte >1f, >00, >a0, >00                             ; Face 8
     EE62 A000     
37272 EE64 FF6B            byte >ff, >6b, >6b, >6b                             ; Face 9
     EE66 6B6B     
37273 EE68 7F6B            byte >7f, >6b, >6b, >6b                             ; Face 10
     EE6A 6B6B     
37274 EE6C 3F6B            byte >3f, >6b, >6b, >6b                             ; Face 11
     EE6E 6B6B     
37275 EE70 BF6B            byte >bf, >6b, >6b, >6b                             ; Face 12
     EE72 6B6B     
37276 EE74 3F00            byte >3f, >00, >00, >a0                             ; Face 13
     EE76 00A0     
37277               
37278               * ******************************************************************************
37279               *
37280               * Name: SHIP_MISSILE
37281               * Type: Variable
37282               * Category: Drawing ships
37283               * Summary: Ship blueprint for a missile
37284               * Deep dive: Ship blueprints
37285               *
37286               * ******************************************************************************
37287               
37288               SHIP_MISSILE:
37289 EE78 00              byte >00                                            ; Max. canisters on demise = 0
37290 EE7A 0640            data 40 * 40                                        ; Targetable area          = 40 * 40
37291               
37292 EE7C 7C              byte (SHIP_MISSILE_EDGES - SHIP_MISSILE)%256        ; Edges data offset (low)
37293 EE7D   DC            byte (SHIP_MISSILE_FACES - SHIP_MISSILE)%256        ; Faces data offset (low)
37294               
37295 EE7E 51              byte >51                                            ; Max. edge count          = (81 - 1) / 4 = 20
37296 EE7F   00            byte >00                                            ; Gun vertex               = 0
37297 EE80 0A              byte >0a                                            ; Explosion count          = 1, as (4 * n) + 6 = 10
37298 EE81   66            byte >66                                            ; Number of vertices       = 102 / 6 = 17
37299 EE82 18              byte >18                                            ; Number of edges          = 24
37300 EE84 0000            data >0000                                          ; Bounty                   = 0
37301 EE86 24              byte >24                                            ; Number of faces          = 36 / 4 = 9
37302 EE87   0E            byte >0e                                            ; Visibility distance      = 14
37303 EE88 02              byte >02                                            ; Max. energy              = 2
37304 EE89   2C            byte >2c                                            ; Max. speed               = 44
37305               
37306 EE8A 00              byte (SHIP_MISSILE_EDGES - SHIP_MISSILE)/256        ; Edges data offset (high)
37307 EE8B   00            byte (SHIP_MISSILE_FACES - SHIP_MISSILE)/256        ; Faces data offset (high)
37308               
37309 EE8C 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37310 EE8D   00            byte >00                                            ; Laser power              = 0
37311                                                                          ; Missiles                 = 0
37312               
37313               SHIP_MISSILE_VERTICES:
37314                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37315 EE8E 0000            byte >00, >00, >44, >1f, >10, >32                   ; Vertex 0
     EE90 441F     
     EE92 1032     
37316 EE94 0808            byte >08, >08, >24, >5f, >21, >54                   ; Vertex 1
     EE96 245F     
     EE98 2154     
37317 EE9A 0808            byte >08, >08, >24, >1f, >32, >74                   ; Vertex 2
     EE9C 241F     
     EE9E 3274     
37318 EEA0 0808            byte >08, >08, >24, >9f, >30, >76                   ; Vertex 3
     EEA2 249F     
     EEA4 3076     
37319 EEA6 0808            byte >08, >08, >24, >df, >10, >65                   ; Vertex 4
     EEA8 24DF     
     EEAA 1065     
37320 EEAC 0808            byte >08, >08, >2c, >3f, >74, >88                   ; Vertex 5
     EEAE 2C3F     
     EEB0 7488     
37321 EEB2 0808            byte >08, >08, >2c, >7f, >54, >88                   ; Vertex 6
     EEB4 2C7F     
     EEB6 5488     
37322 EEB8 0808            byte >08, >08, >2c, >ff, >65, >88                   ; Vertex 7
     EEBA 2CFF     
     EEBC 6588     
37323 EEBE 0808            byte >08, >08, >2c, >bf, >76, >88                   ; Vertex 8
     EEC0 2CBF     
     EEC2 7688     
37324 EEC4 0C0C            byte >0c, >0c, >2c, >28, >74, >88                   ; Vertex 9
     EEC6 2C28     
     EEC8 7488     
37325 EECA 0C0C            byte >0c, >0c, >2c, >68, >54, >88                   ; Vertex 10
     EECC 2C68     
     EECE 5488     
37326 EED0 0C0C            byte >0c, >0c, >2c, >e8, >65, >88                   ; Vertex 11
     EED2 2CE8     
     EED4 6588     
37327 EED6 0C0C            byte >0c, >0c, >2c, >a8, >76, >88                   ; Vertex 12
     EED8 2CA8     
     EEDA 7688     
37328 EEDC 0808            byte >08, >08, >0c, >a8, >76, >77                   ; Vertex 13
     EEDE 0CA8     
     EEE0 7677     
37329 EEE2 0808            byte >08, >08, >0c, >e8, >65, >66                   ; Vertex 14
     EEE4 0CE8     
     EEE6 6566     
37330 EEE8 0808            byte >08, >08, >0c, >28, >74, >77                   ; Vertex 15
     EEEA 0C28     
     EEEC 7477     
37331 EEEE 0808            byte >08, >08, >0c, >68, >54, >55                   ; Vertex 16
     EEF0 0C68     
     EEF2 5455     
37332               
37333               SHIP_MISSILE_EDGES:
37334                                                                          ; vertex1, vertex2, face1, face2, visibility
37335 EEF4 1F21            byte >1f, >21, >00, >04                             ; Edge 0
     EEF6 0004     
37336 EEF8 1F32            byte >1f, >32, >00, >08                             ; Edge 1
     EEFA 0008     
37337 EEFC 1F30            byte >1f, >30, >00, >0c                             ; Edge 2
     EEFE 000C     
37338 EF00 1F10            byte >1f, >10, >00, >10                             ; Edge 3
     EF02 0010     
37339 EF04 1F24            byte >1f, >24, >04, >08                             ; Edge 4
     EF06 0408     
37340 EF08 1F51            byte >1f, >51, >04, >10                             ; Edge 5
     EF0A 0410     
37341 EF0C 1F60            byte >1f, >60, >0c, >10                             ; Edge 6
     EF0E 0C10     
37342 EF10 1F73            byte >1f, >73, >08, >0c                             ; Edge 7
     EF12 080C     
37343 EF14 1F74            byte >1f, >74, >08, >14                             ; Edge 8
     EF16 0814     
37344 EF18 1F54            byte >1f, >54, >04, >18                             ; Edge 9
     EF1A 0418     
37345 EF1C 1F65            byte >1f, >65, >10, >1c                             ; Edge 10
     EF1E 101C     
37346 EF20 1F76            byte >1f, >76, >0c, >20                             ; Edge 11
     EF22 0C20     
37347 EF24 1F86            byte >1f, >86, >1c, >20                             ; Edge 12
     EF26 1C20     
37348 EF28 1F87            byte >1f, >87, >14, >20                             ; Edge 13
     EF2A 1420     
37349 EF2C 1F84            byte >1f, >84, >14, >18                             ; Edge 14
     EF2E 1418     
37350 EF30 1F85            byte >1f, >85, >18, >1c                             ; Edge 15
     EF32 181C     
37351 EF34 0885            byte >08, >85, >18, >28                             ; Edge 16
     EF36 1828     
37352 EF38 0887            byte >08, >87, >14, >24                             ; Edge 17
     EF3A 1424     
37353 EF3C 0887            byte >08, >87, >20, >30                             ; Edge 18
     EF3E 2030     
37354 EF40 0885            byte >08, >85, >1c, >2c                             ; Edge 19
     EF42 1C2C     
37355 EF44 0874            byte >08, >74, >24, >3c                             ; Edge 20
     EF46 243C     
37356 EF48 0854            byte >08, >54, >28, >40                             ; Edge 21
     EF4A 2840     
37357 EF4C 0876            byte >08, >76, >30, >34                             ; Edge 22
     EF4E 3034     
37358 EF50 0865            byte >08, >65, >2c, >38                             ; Edge 23
     EF52 2C38     
37359               
37360               SHIP_MISSILE_FACES:
37361                                                                          ; normal_x, normal_y, normal_z, visibility
37362 EF54 9F40            byte >9f, >40, >00, >10                             ; Face 0
     EF56 0010     
37363 EF58 5F00            byte >5f, >00, >40, >10                             ; Face 1
     EF5A 4010     
37364 EF5C 1F40            byte >1f, >40, >00, >10                             ; Face 2
     EF5E 0010     
37365 EF60 1F00            byte >1f, >00, >40, >10                             ; Face 3
     EF62 4010     
37366 EF64 1F20            byte >1f, >20, >00, >00                             ; Face 4
     EF66 0000     
37367 EF68 5F00            byte >5f, >00, >20, >00                             ; Face 5
     EF6A 2000     
37368 EF6C 9F20            byte >9f, >20, >00, >00                             ; Face 6
     EF6E 0000     
37369 EF70 1F00            byte >1f, >00, >20, >00                             ; Face 7
     EF72 2000     
37370 EF74 3F00            byte >3f, >00, >00, >b0                             ; Face 8
     EF76 00B0     
37371               
37372               * ******************************************************************************
37373               *
37374               * Name: SHIP_ASTEROID
37375               * Type: Variable
37376               * Category: Drawing ships
37377               * Summary: Ship blueprint for an asteroid
37378               * Deep dive: Ship blueprints
37379               *
37380               * ******************************************************************************
37381               
37382               SHIP_ASTEROID:
37383 EF78 00              byte >00                                            ; Max. canisters on demise = 0
37384 EF7A 1900            data 80 * 80                                        ; Targetable area          = 80 * 80
37385               
37386 EF7C 4C              byte (SHIP_ASTEROID_EDGES - SHIP_ASTEROID)%256      ; Edges data offset (low)
37387 EF7D   A0            byte (SHIP_ASTEROID_FACES - SHIP_ASTEROID)%256      ; Faces data offset (low)
37388               
37389 EF7E 41              byte >41                                            ; Max. edge count          = (65 - 1) / 4 = 16
37390 EF7F   00            byte >00                                            ; Gun vertex               = 0
37391 EF80 22              byte >22                                            ; Explosion count          = 7, as (4 * n) + 6 = 34
37392 EF81   36            byte >36                                            ; Number of vertices       = 54 / 6 = 9
37393 EF82 15              byte >15                                            ; Number of edges          = 21
37394 EF84 0500            data >0500                                          ; Bounty                   = 5
37395 EF86 38              byte >38                                            ; Number of faces          = 56 / 4 = 14
37396 EF87   32            byte >32                                            ; Visibility distance      = 50
37397 EF88 3C              byte >3c                                            ; Max. energy              = 60
37398 EF89   1E            byte >1e                                            ; Max. speed               = 30
37399               
37400 EF8A 00              byte (SHIP_ASTEROID_EDGES - SHIP_ASTEROID)/256      ; Edges data offset (high)
37401 EF8B   00            byte (SHIP_ASTEROID_FACES - SHIP_ASTEROID)/256      ; Faces data offset (high)
37402               
37403 EF8C 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
37404 EF8D   00            byte >00                                            ; Laser power              = 0
37405                                                                          ; Missiles                 = 0
37406               
37407               SHIP_ASTEROID_VERTICES:
37408                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37409 EF8E 0050            byte >00, >50, >00, >1f, >ff, >ff                   ; Vertex 0
     EF90 001F     
     EF92 FFFF     
37410 EF94 500A            byte >50, >0a, >00, >df, >ff, >ff                   ; Vertex 1
     EF96 00DF     
     EF98 FFFF     
37411 EF9A 0050            byte >00, >50, >00, >5f, >ff, >ff                   ; Vertex 2
     EF9C 005F     
     EF9E FFFF     
37412 EFA0 4628            byte >46, >28, >00, >5f, >ff, >ff                   ; Vertex 3
     EFA2 005F     
     EFA4 FFFF     
37413 EFA6 3C32            byte >3c, >32, >00, >1f, >65, >dc                   ; Vertex 4
     EFA8 001F     
     EFAA 65DC     
37414 EFAC 3200            byte >32, >00, >3c, >1f, >ff, >ff                   ; Vertex 5
     EFAE 3C1F     
     EFB0 FFFF     
37415 EFB2 2800            byte >28, >00, >46, >9f, >10, >32                   ; Vertex 6
     EFB4 469F     
     EFB6 1032     
37416 EFB8 001E            byte >00, >1e, >4b, >3f, >ff, >ff                   ; Vertex 7
     EFBA 4B3F     
     EFBC FFFF     
37417 EFBE 0032            byte >00, >32, >3c, >7f, >98, >ba                   ; Vertex 8
     EFC0 3C7F     
     EFC2 98BA     
37418               
37419               SHIP_ASTEROID_EDGES:
37420                                                                          ; vertex1, vertex2, face1, face2, visibility
37421 EFC4 1F72            byte >1f, >72, >00, >04                             ; Edge 0
     EFC6 0004     
37422 EFC8 1FD6            byte >1f, >d6, >00, >10                             ; Edge 1
     EFCA 0010     
37423 EFCC 1FC5            byte >1f, >c5, >0c, >10                             ; Edge 2
     EFCE 0C10     
37424 EFD0 1FB4            byte >1f, >b4, >08, >0c                             ; Edge 3
     EFD2 080C     
37425 EFD4 1FA3            byte >1f, >a3, >04, >08                             ; Edge 4
     EFD6 0408     
37426 EFD8 1F32            byte >1f, >32, >04, >18                             ; Edge 5
     EFDA 0418     
37427 EFDC 1F31            byte >1f, >31, >08, >18                             ; Edge 6
     EFDE 0818     
37428 EFE0 1F41            byte >1f, >41, >08, >14                             ; Edge 7
     EFE2 0814     
37429 EFE4 1F10            byte >1f, >10, >14, >18                             ; Edge 8
     EFE6 1418     
37430 EFE8 1F60            byte >1f, >60, >00, >14                             ; Edge 9
     EFEA 0014     
37431 EFEC 1F54            byte >1f, >54, >0c, >14                             ; Edge 10
     EFEE 0C14     
37432 EFF0 1F20            byte >1f, >20, >00, >18                             ; Edge 11
     EFF2 0018     
37433 EFF4 1F65            byte >1f, >65, >10, >14                             ; Edge 12
     EFF6 1014     
37434 EFF8 1FA8            byte >1f, >a8, >04, >20                             ; Edge 13
     EFFA 0420     
37435 EFFC 1F87            byte >1f, >87, >04, >1c                             ; Edge 14
     EFFE 041C     
37436 F000 1FD7            byte >1f, >d7, >00, >1c                             ; Edge 15
     F002 001C     
37437 F004 1FDC            byte >1f, >dc, >10, >1c                             ; Edge 16
     F006 101C     
37438 F008 1FC9            byte >1f, >c9, >0c, >1c                             ; Edge 17
     F00A 0C1C     
37439 F00C 1FB9            byte >1f, >b9, >0c, >20                             ; Edge 18
     F00E 0C20     
37440 F010 1FBA            byte >1f, >ba, >08, >20                             ; Edge 19
     F012 0820     
37441 F014 1F98            byte >1f, >98, >1c, >20                             ; Edge 20
     F016 1C20     
37442               
37443               SHIP_ASTEROID_FACES:
37444                                                                          ; normal_x, normal_y, normal_z, visibility
37445 F018 1F09            byte >1f, >09, >42, >51                             ; Face 0
     F01A 4251     
37446 F01C 5F09            byte >5f, >09, >42, >51                             ; Face 1
     F01E 4251     
37447 F020 9F48            byte >9f, >48, >40, >1f                             ; Face 2
     F022 401F     
37448 F024 DF40            byte >df, >40, >49, >2f                             ; Face 3
     F026 492F     
37449 F028 5F2D            byte >5f, >2d, >4f, >41                             ; Face 4
     F02A 4F41     
37450 F02C 1F87            byte >1f, >87, >0f, >23                             ; Face 5
     F02E 0F23     
37451 F030 1F26            byte >1f, >26, >4c, >46                             ; Face 6
     F032 4C46     
37452 F034 BF42            byte >bf, >42, >3b, >27                             ; Face 7
     F036 3B27     
37453 F038 FF43            byte >ff, >43, >0f, >50                             ; Face 8
     F03A 0F50     
37454 F03C 7F42            byte >7f, >42, >0e, >4b                             ; Face 9
     F03E 0E4B     
37455 F040 FF46            byte >ff, >46, >50, >28                             ; Face 10
     F042 5028     
37456 F044 7F3A            byte >7f, >3a, >66, >33                             ; Face 11
     F046 6633     
37457 F048 3F51            byte >3f, >51, >09, >43                             ; Face 12
     F04A 0943     
37458 F04C 3F2F            byte >3f, >2f, >5e, >3f                             ; Face 13
     F04E 5E3F     
37459               
37460               * ******************************************************************************
37461               *
37462               * Name: SHIP_CANISTER
37463               * Type: Variable
37464               * Category: Drawing ships
37465               * Summary: Ship blueprint for a cargo canister
37466               * Deep dive: Ship blueprints
37467               *
37468               * ******************************************************************************
37469               
37470               SHIP_CANISTER:
37471 F050 00              byte >00                                            ; Max. canisters on demise = 0
37472 F052 0190            data 20 * 20                                        ; Targetable area          = 20 * 20
37473               
37474 F054 52              byte (SHIP_CANISTER_EDGES - SHIP_CANISTER)%256      ; Edges data offset (low)
37475 F055   8E            byte (SHIP_CANISTER_FACES - SHIP_CANISTER)%256      ; Faces data offset (low)
37476               
37477 F056 31              byte >31                                            ; Max. edge count          = (49 - 1) / 4 = 12
37478 F057   00            byte >00                                            ; Gun vertex               = 0
37479 F058 12              byte >12                                            ; Explosion count          = 3, as (4 * n) + 6 = 18
37480 F059   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
37481 F05A 0F              byte >0f                                            ; Number of edges          = 15
37482 F05C 0000            data >0000                                          ; Bounty                   = 0
37483 F05E 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
37484 F05F   0C            byte >0c                                            ; Visibility distance      = 12
37485 F060 11              byte >11                                            ; Max. energy              = 17
37486 F061   0F            byte >0f                                            ; Max. speed               = 15
37487               
37488 F062 00              byte (SHIP_CANISTER_EDGES - SHIP_CANISTER)/256      ; Edges data offset (high)
37489 F063   00            byte (SHIP_CANISTER_FACES - SHIP_CANISTER)/256      ; Faces data offset (high)
37490               
37491 F064 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37492 F065   00            byte >00                                            ; Laser power              = 0
37493                                                                          ; Missiles                 = 0
37494               
37495               SHIP_CANISTER_VERTICES:
37496                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37497 F066 1810            byte >18, >10, >00, >1f, >10, >55                   ; Vertex 0
     F068 001F     
     F06A 1055     
37498 F06C 1805            byte >18, >05, >0f, >1f, >10, >22                   ; Vertex 1
     F06E 0F1F     
     F070 1022     
37499 F072 180D            byte >18, >0d, >09, >5f, >20, >33                   ; Vertex 2
     F074 095F     
     F076 2033     
37500 F078 180D            byte >18, >0d, >09, >7f, >30, >44                   ; Vertex 3
     F07A 097F     
     F07C 3044     
37501 F07E 1805            byte >18, >05, >0f, >3f, >40, >55                   ; Vertex 4
     F080 0F3F     
     F082 4055     
37502 F084 1810            byte >18, >10, >00, >9f, >51, >66                   ; Vertex 5
     F086 009F     
     F088 5166     
37503 F08A 1805            byte >18, >05, >0f, >9f, >21, >66                   ; Vertex 6
     F08C 0F9F     
     F08E 2166     
37504 F090 180D            byte >18, >0d, >09, >df, >32, >66                   ; Vertex 7
     F092 09DF     
     F094 3266     
37505 F096 180D            byte >18, >0d, >09, >ff, >43, >66                   ; Vertex 8
     F098 09FF     
     F09A 4366     
37506 F09C 1805            byte >18, >05, >0f, >bf, >54, >66                   ; Vertex 9
     F09E 0FBF     
     F0A0 5466     
37507               
37508               SHIP_CANISTER_EDGES:
37509                                                                          ; vertex1, vertex2, face1, face2, visibility
37510 F0A2 1F10            byte >1f, >10, >00, >04                             ; Edge 0
     F0A4 0004     
37511 F0A6 1F20            byte >1f, >20, >04, >08                             ; Edge 1
     F0A8 0408     
37512 F0AA 1F30            byte >1f, >30, >08, >0c                             ; Edge 2
     F0AC 080C     
37513 F0AE 1F40            byte >1f, >40, >0c, >10                             ; Edge 3
     F0B0 0C10     
37514 F0B2 1F50            byte >1f, >50, >00, >10                             ; Edge 4
     F0B4 0010     
37515 F0B6 1F51            byte >1f, >51, >00, >14                             ; Edge 5
     F0B8 0014     
37516 F0BA 1F21            byte >1f, >21, >04, >18                             ; Edge 6
     F0BC 0418     
37517 F0BE 1F32            byte >1f, >32, >08, >1c                             ; Edge 7
     F0C0 081C     
37518 F0C2 1F43            byte >1f, >43, >0c, >20                             ; Edge 8
     F0C4 0C20     
37519 F0C6 1F54            byte >1f, >54, >10, >24                             ; Edge 9
     F0C8 1024     
37520 F0CA 1F61            byte >1f, >61, >14, >18                             ; Edge 10
     F0CC 1418     
37521 F0CE 1F62            byte >1f, >62, >18, >1c                             ; Edge 11
     F0D0 181C     
37522 F0D2 1F63            byte >1f, >63, >1c, >20                             ; Edge 12
     F0D4 1C20     
37523 F0D6 1F64            byte >1f, >64, >20, >24                             ; Edge 13
     F0D8 2024     
37524 F0DA 1F65            byte >1f, >65, >24, >14                             ; Edge 14
     F0DC 2414     
37525               
37526               SHIP_CANISTER_FACES:
37527                                                                          ; normal_x, normal_y, normal_z, visibility
37528 F0DE 1F60            byte >1f, >60, >00, >00                             ; Face 0
     F0E0 0000     
37529 F0E2 1F00            byte >1f, >00, >29, >1e                             ; Face 1
     F0E4 291E     
37530 F0E6 5F00            byte >5f, >00, >12, >30                             ; Face 2
     F0E8 1230     
37531 F0EA 5F00            byte >5f, >00, >33, >00                             ; Face 3
     F0EC 3300     
37532 F0EE 7F00            byte >7f, >00, >12, >30                             ; Face 4
     F0F0 1230     
37533 F0F2 3F00            byte >3f, >00, >29, >1e                             ; Face 5
     F0F4 291E     
37534 F0F6 9F60            byte >9f, >60, >00, >00                             ; Face 6
     F0F8 0000     
37535               
37536               * ******************************************************************************
37537               *
37538               * Name: SHIP_THARGON
37539               * Type: Variable
37540               * Category: Drawing ships
37541               * Summary: Ship blueprint for a Thargon
37542               * Deep dive: Ship blueprints
37543               *
37544               * ------------------------------------------------------------------------------
37545               *
37546               * The ship blueprint for the Thargon reuses the edges data from the cargo
37547               * canister, so the edges data offset is negative.
37548               *
37549               * ******************************************************************************
37550               
37551               SHIP_THARGON:
37552 F0FA 00              byte >00                                            ; Max. canisters on demise = 0
37553 F0FC 0640            data 40 * 40                                        ; Targetable area          = 40 * 40
37554               
37555 F0FE 58              byte (SHIP_CANISTER_EDGES - SHIP_THARGON)%256       ; Edges from canister
37556 F0FF   52            byte (SHIP_THARGON_FACES - SHIP_THARGON)%256        ; Faces data offset (low)
37557               
37558 F100 41              byte >41                                            ; Max. edge count          = (65 - 1) / 4 = 16
37559 F101   00            byte >00                                            ; Gun vertex               = 0
37560 F102 12              byte >12                                            ; Explosion count          = 3, as (4 * n) + 6 = 18
37561 F103   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
37562 F104 0F              byte >0f                                            ; Number of edges          = 15
37563 F106 3200            data >3200                                          ; Bounty                   = 50
37564 F108 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
37565 F109   14            byte >14                                            ; Visibility distance      = 20
37566 F10A 14              byte >14                                            ; Max. energy              = 20
37567 F10B   1E            byte >1e                                            ; Max. speed               = 30
37568               
37569 F10C 00              byte (SHIP_CANISTER_EDGES - SHIP_THARGON)/256       ; Edges from canister
37570 F10D   00            byte (SHIP_THARGON_FACES - SHIP_THARGON)/256        ; Faces data offset (high)
37571               
37572 F10E 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37573 F10F   10            byte >10                                            ; Laser power              = 2
37574                                                                          ; Missiles                 = 0
37575               
37576               SHIP_THARGON_VERTICES:
37577                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37578 F110 0900            byte >09, >00, >28, >9f, >01, >55                   ; Vertex 0
     F112 289F     
     F114 0155     
37579 F116 0926            byte >09, >26, >0c, >df, >01, >22                   ; Vertex 1
     F118 0CDF     
     F11A 0122     
37580 F11C 0918            byte >09, >18, >20, >ff, >02, >33                   ; Vertex 2
     F11E 20FF     
     F120 0233     
37581 F122 0918            byte >09, >18, >20, >bf, >03, >44                   ; Vertex 3
     F124 20BF     
     F126 0344     
37582 F128 0926            byte >09, >26, >0c, >9f, >04, >55                   ; Vertex 4
     F12A 0C9F     
     F12C 0455     
37583 F12E 0900            byte >09, >00, >08, >3f, >15, >66                   ; Vertex 5
     F130 083F     
     F132 1566     
37584 F134 090A            byte >09, >0a, >0f, >7f, >12, >66                   ; Vertex 6
     F136 0F7F     
     F138 1266     
37585 F13A 0906            byte >09, >06, >1a, >7f, >23, >66                   ; Vertex 7
     F13C 1A7F     
     F13E 2366     
37586 F140 0906            byte >09, >06, >1a, >3f, >34, >66                   ; Vertex 8
     F142 1A3F     
     F144 3466     
37587 F146 090A            byte >09, >0a, >0f, >3f, >45, >66                   ; Vertex 9
     F148 0F3F     
     F14A 4566     
37588               
37589               SHIP_THARGON_FACES:
37590                                                                          ; normal_x, normal_y, normal_z, visibility
37591 F14C 9F24            byte >9f, >24, >00, >00                             ; Face 0
     F14E 0000     
37592 F150 5F14            byte >5f, >14, >05, >07                             ; Face 1
     F152 0507     
37593 F154 7F2E            byte >7f, >2e, >2a, >0e                             ; Face 2
     F156 2A0E     
37594 F158 3F24            byte >3f, >24, >00, >68                             ; Face 3
     F15A 0068     
37595 F15C 3F2E            byte >3f, >2e, >2a, >0e                             ; Face 4
     F15E 2A0E     
37596 F160 1F14            byte >1f, >14, >05, >07                             ; Face 5
     F162 0507     
37597 F164 1F24            byte >1f, >24, >00, >00                             ; Face 6
     F166 0000     
37598               
37599               * ******************************************************************************
37600               *
37601               * Name: SHIP_ESCAPE_POD
37602               * Type: Variable
37603               * Category: Drawing ships
37604               * Summary: Ship blueprint for an escape pod
37605               * Deep dive: Ship blueprints
37606               *
37607               * ******************************************************************************
37608               
37609               SHIP_ESCAPE_POD:
37610 F168 00              byte >00                                            ; Max. canisters on demise = 0
37611 F16A 0100            data 16 * 16                                        ; Targetable area          = 16 * 16
37612               
37613 F16C 2E              byte (SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)%256  ; Edges data offset (low)
37614 F16D   46            byte (SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)%256  ; Faces data offset (low)
37615               
37616 F16E 19              byte >19                                            ; Max. edge count          = (25 - 1) / 4 = 6
37617 F16F   00            byte >00                                            ; Gun vertex               = 0
37618 F170 16              byte >16                                            ; Explosion count          = 4, as (4 * n) + 6 = 22
37619 F171   18            byte >18                                            ; Number of vertices       = 24 / 6 = 4
37620 F172 06              byte >06                                            ; Number of edges          = 6
37621 F174 0000            data >0000                                          ; Bounty                   = 0
37622 F176 10              byte >10                                            ; Number of faces          = 16 / 4 = 4
37623 F177   08            byte >08                                            ; Visibility distance      = 8
37624 F178 11              byte >11                                            ; Max. energy              = 17
37625 F179   08            byte >08                                            ; Max. speed               = 8
37626               
37627 F17A 00              byte (SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)/256  ; Edges data offset (high)
37628 F17B   00            byte (SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)/256  ; Faces data offset (high)
37629               
37630 F17C 03              byte >03                                            ; Normals are scaled by    =  2^3 = 8
37631 F17D   00            byte >00                                            ; Laser power              = 0
37632                                                                          ; Missiles                 = 0
37633               
37634               SHIP_ESCAPE_POD_VERTICES:
37635                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37636 F17E 0700            byte >07, >00, >24, >9f, >12, >33                   ; Vertex 0
     F180 249F     
     F182 1233     
37637 F184 070E            byte >07, >0e, >0c, >ff, >02, >33                   ; Vertex 1
     F186 0CFF     
     F188 0233     
37638 F18A 070E            byte >07, >0e, >0c, >bf, >01, >33                   ; Vertex 2
     F18C 0CBF     
     F18E 0133     
37639 F190 1500            byte >15, >00, >00, >1f, >01, >22                   ; Vertex 3
     F192 001F     
     F194 0122     
37640               
37641               SHIP_ESCAPE_POD_EDGES:
37642                                                                          ; vertex1, vertex2, face1, face2, visibility
37643 F196 1F23            byte >1f, >23, >00, >04                             ; Edge 0
     F198 0004     
37644 F19A 1F03            byte >1f, >03, >04, >08                             ; Edge 1
     F19C 0408     
37645 F19E 1F01            byte >1f, >01, >08, >0c                             ; Edge 2
     F1A0 080C     
37646 F1A2 1F12            byte >1f, >12, >0c, >00                             ; Edge 3
     F1A4 0C00     
37647 F1A6 1F13            byte >1f, >13, >00, >08                             ; Edge 4
     F1A8 0008     
37648 F1AA 1F02            byte >1f, >02, >0c, >04                             ; Edge 5
     F1AC 0C04     
37649               
37650               SHIP_ESCAPE_POD_FACES:
37651                                                                          ; normal_x, normal_y, normal_z, visibility
37652 F1AE 3F1A            byte >3f, >1a, >00, >3d                             ; Face 0
     F1B0 003D     
37653 F1B2 1F13            byte >1f, >13, >33, >0f                             ; Face 1
     F1B4 330F     
37654 F1B6 5F13            byte >5f, >13, >33, >0f                             ; Face 2
     F1B8 330F     
37655 F1BA 9F38            byte >9f, >38, >00, >00                             ; Face 3
     F1BC 0000     
37656               
37657               * ******************************************************************************
37658               *
37659               * Save SHIPS.bin
37660               *
37661               * ******************************************************************************
37662               
37663                      ; PRINT "SHIPS"
37664                      ; PRINT "Assembled at ", ~CODE_SHIPS%
37665                      ; PRINT "Ends at ", ~P%
37666                      ; PRINT "Code size is ", ~(P% - CODE_SHIPS%)
37667                      ; PRINT "Execute at ", ~LOAD%
37668                      ; PRINT "Reload at ", ~LOAD_SHIPS%
37669               
37670                      ; PRINT "S.SHIPS ", ~CODE_SHIPS%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_SHIPS%
37671                      ; SAVE "3-assembled-output/SHIPS.bin", CODE_SHIPS%, P%, LOAD%
37672               
37673               * ******************************************************************************
37674               *
37675               * ELITE PYTHON SHIP BLUEPRINT FILE
37676               *
37677               * Produces the binary file PYTHON.bin that gets loaded by elite-bcfs.asm.
37678               *
37679               * ******************************************************************************
37680               
37681                      ; CLEAR 0, &7F00                ; CLEAR 0, &7F00
37682               
37683               LOAD_PYTHON.:
37684                      equ >1B00
37685               
37686               * ORG CODE_PYTHON%
37687               
37688               * ******************************************************************************
37689               *
37690               * Name: SHIP_PYTHON
37691               * Type: Variable
37692               * Category: Drawing ships
37693               * Summary: Ship blueprint for a Python
37694               * Deep dive: Ship blueprints
37695               *
37696               * ******************************************************************************
37697               
37698               SHIP_PYTHON:
37699 F1BE 03              byte >03                                            ; Max. canisters on demise = 3
37700 F1C0 3840            data 120 * 120                                      ; Targetable area          = 120 * 120
37701               
37702 F1C2 58              byte (SHIP_PYTHON_EDGES - SHIP_PYTHON)%256          ; Edges data offset (low)
37703 F1C3   C0            byte (SHIP_PYTHON_FACES - SHIP_PYTHON)%256          ; Faces data offset (low)
37704               
37705 F1C4 55              byte >55                                            ; Max. edge count          = (85 - 1) / 4 = 21
37706 F1C5   00            byte >00                                            ; Gun vertex               = 0
37707 F1C6 2E              byte >2e                                            ; Explosion count          = 10, as (4 * n) + 6 = 46
37708 F1C7   42            byte >42                                            ; Number of vertices       = 66 / 6 = 11
37709 F1C8 1A              byte >1a                                            ; Number of edges          = 26
37710 F1CA C800            data >c800                                          ; Bounty                   = 200
37711 F1CC 34              byte >34                                            ; Number of faces          = 52 / 4 = 13
37712 F1CD   28            byte >28                                            ; Visibility distance      = 40
37713 F1CE FA              byte >fa                                            ; Max. energy              = 250
37714 F1CF   14            byte >14                                            ; Max. speed               = 20
37715               
37716 F1D0 00              byte (SHIP_PYTHON_EDGES - SHIP_PYTHON)/256          ; Edges data offset (high)
37717 F1D1   00            byte (SHIP_PYTHON_FACES - SHIP_PYTHON)/256          ; Faces data offset (high)
37718               
37719 F1D2 00              byte >00                                            ; Normals are scaled by    = 2^0 = 1
37720 F1D3   1B            byte >1b                                            ; Laser power              = 3
37721                                                                          ; Missiles                 = 3
37722               
37723               SHIP_PYTHON_VERTICES:
37724                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37725 F1D4 0000            byte >00, >00, >e0, >1f, >10, >32                   ; Vertex 0
     F1D6 E01F     
     F1D8 1032     
37726 F1DA 0030            byte >00, >30, >30, >1e, >10, >54                   ; Vertex 1
     F1DC 301E     
     F1DE 1054     
37727 F1E0 6000            byte >60, >00, >10, >3f, >ff, >ff                   ; Vertex 2
     F1E2 103F     
     F1E4 FFFF     
37728 F1E6 6000            byte >60, >00, >10, >bf, >ff, >ff                   ; Vertex 3
     F1E8 10BF     
     F1EA FFFF     
37729 F1EC 0030            byte >00, >30, >20, >3e, >54, >98                   ; Vertex 4
     F1EE 203E     
     F1F0 5498     
37730 F1F2 0018            byte >00, >18, >70, >3f, >89, >cc                   ; Vertex 5
     F1F4 703F     
     F1F6 89CC     
37731 F1F8 3000            byte >30, >00, >70, >bf, >b8, >cc                   ; Vertex 6
     F1FA 70BF     
     F1FC B8CC     
37732 F1FE 3000            byte >30, >00, >70, >3f, >a9, >cc                   ; Vertex 7
     F200 703F     
     F202 A9CC     
37733 F204 0030            byte >00, >30, >30, >5e, >32, >76                   ; Vertex 8
     F206 305E     
     F208 3276     
37734 F20A 0030            byte >00, >30, >20, >7e, >76, >ba                   ; Vertex 9
     F20C 207E     
     F20E 76BA     
37735 F210 0018            byte >00, >18, >70, >7e, >ba, >cc                   ; Vertex 10
     F212 707E     
     F214 BACC     
37736               
37737               SHIP_PYTHON_EDGES:
37738                                                                          ; vertex1, vertex2, face1, face2, visibility
37739 F216 1E32            byte >1e, >32, >00, >20                             ; Edge 0
     F218 0020     
37740 F21A 1F20            byte >1f, >20, >00, >0c                             ; Edge 1
     F21C 000C     
37741 F21E 1F31            byte >1f, >31, >00, >08                             ; Edge 2
     F220 0008     
37742 F222 1E10            byte >1e, >10, >00, >04                             ; Edge 3
     F224 0004     
37743 F226 1D59            byte >1d, >59, >08, >10                             ; Edge 4
     F228 0810     
37744 F22A 1D51            byte >1d, >51, >04, >08                             ; Edge 5
     F22C 0408     
37745 F22E 1D37            byte >1d, >37, >08, >20                             ; Edge 6
     F230 0820     
37746 F232 1D40            byte >1d, >40, >04, >0c                             ; Edge 7
     F234 040C     
37747 F236 1D62            byte >1d, >62, >0c, >20                             ; Edge 8
     F238 0C20     
37748 F23A 1DA7            byte >1d, >a7, >08, >24                             ; Edge 9
     F23C 0824     
37749 F23E 1D84            byte >1d, >84, >0c, >10                             ; Edge 10
     F240 0C10     
37750 F242 1DB6            byte >1d, >b6, >0c, >24                             ; Edge 11
     F244 0C24     
37751 F246 0588            byte >05, >88, >0c, >14                             ; Edge 12
     F248 0C14     
37752 F24A 05BB            byte >05, >bb, >0c, >28                             ; Edge 13
     F24C 0C28     
37753 F24E 0599            byte >05, >99, >08, >14                             ; Edge 14
     F250 0814     
37754 F252 05AA            byte >05, >aa, >08, >28                             ; Edge 15
     F254 0828     
37755 F256 1FA9            byte >1f, >a9, >08, >1c                             ; Edge 16
     F258 081C     
37756 F25A 1FB8            byte >1f, >b8, >0c, >18                             ; Edge 17
     F25C 0C18     
37757 F25E 1FC8            byte >1f, >c8, >14, >18                             ; Edge 18
     F260 1418     
37758 F262 1FC9            byte >1f, >c9, >14, >1c                             ; Edge 19
     F264 141C     
37759 F266 1DAC            byte >1d, >ac, >1c, >28                             ; Edge 20
     F268 1C28     
37760 F26A 1DCB            byte >1d, >cb, >18, >28                             ; Edge 21
     F26C 1828     
37761 F26E 1D98            byte >1d, >98, >10, >14                             ; Edge 22
     F270 1014     
37762 F272 1DBA            byte >1d, >ba, >24, >28                             ; Edge 23
     F274 2428     
37763 F276 1D54            byte >1d, >54, >04, >10                             ; Edge 24
     F278 0410     
37764 F27A 1D76            byte >1d, >76, >20, >24                             ; Edge 25
     F27C 2024     
37765               
37766               SHIP_PYTHON_FACES:
37767                                                                          ; normal_x, normal_y, normal_z, visibility
37768 F27E 9E1B            byte >9e, >1b, >28, >0b                             ; Face 0
     F280 280B     
37769 F282 1E1B            byte >1e, >1b, >28, >0b                             ; Face 1
     F284 280B     
37770 F286 DE1B            byte >de, >1b, >28, >0b                             ; Face 2
     F288 280B     
37771 F28A 5E1B            byte >5e, >1b, >28, >0b                             ; Face 3
     F28C 280B     
37772 F28E 9E13            byte >9e, >13, >26, >00                             ; Face 4
     F290 2600     
37773 F292 1E13            byte >1e, >13, >26, >00                             ; Face 5
     F294 2600     
37774 F296 DE13            byte >de, >13, >26, >00                             ; Face 6
     F298 2600     
37775 F29A 5E13            byte >5e, >13, >26, >00                             ; Face 7
     F29C 2600     
37776 F29E BE19            byte >be, >19, >25, >0b                             ; Face 8
     F2A0 250B     
37777 F2A2 3E19            byte >3e, >19, >25, >0b                             ; Face 9
     F2A4 250B     
37778 F2A6 7E19            byte >7e, >19, >25, >0b                             ; Face 10
     F2A8 250B     
37779 F2AA FE19            byte >fe, >19, >25, >0b                             ; Face 11
     F2AC 250B     
37780 F2AE 3E00            byte >3e, >00, >00, >70                             ; Face 12
     F2B0 0070     
37781               
37782 F2B2                 bss 11                                              ; This space appears to be unused
37783               
37784               * ******************************************************************************
37785               *
37786               * Name: SVN
37787               * Type: Variable
37788               * Category: Save and load
37789               * Summary: The "saving in progress" flag
37790               *
37791               * ******************************************************************************
37792               
37793               SVN:
37794 F2BD                 bss 1                                               ; "Saving in progress" flag
37795                                                                          ;
37796                                                                          ; * Non-zero while we are saving a commander
37797                                                                          ;
37798                                                                          ; * 0 otherwise
37799               
37800               * ******************************************************************************
37801               *
37802               * Name: VEC
37803               * Type: Variable
37804               * Category: Drawing the screen
37805               * Summary: The original value of the IRQ1 vector
37806               *
37807               * ******************************************************************************
37808               
37809               VEC:
37810               * SKIP 2                 \ VEC = &7FFE
37811                                                                          ;
37812                                                                          ; This gets set to the value of the original IRQ1 vector
37813                                                                          ; by the loading process
37814               * ******************************************************************************
37815               *
37816               * Save PYTHON.bin
37817               *
37818               * ******************************************************************************
37819                      ; PRINT "PYTHON"
37820                      ; PRINT "Assembled at ", ~CODE_PYTHON%
37821                      ; PRINT "Ends at ", ~P%
37822                      ; PRINT "Code size is ", ~(P% - CODE_PYTHON%)
37823                      ; PRINT "Execute at ", ~LOAD%
37824                      ; PRINT "Reload at ", ~LOAD_PYTHON%
37825               
37826                      ; PRINT "S.PYTHON ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_PYTHON%
37827                      ; SAVE "3-assembled-output/PYTHON.bin", CODE_PYTHON%, P%, LOAD%
37828               
37829               * ******************************************************************************
37830               *
37831               * Show free space
37832               *
37833               * ******************************************************************************
37834               
37835                      ; PRINT "ELITE game code ", ~(&6000-P%), " bytes free"
37836                      ; PRINT "Ends at ", ~P%
                   < main.a99
0004                      aorg >FF00
0005                      copy "entry.a99"
     **** ****     > entry.a99
0001 FF00 0300  22        limi 0
     FF02 0000     
0002 FF04 02E0  18        lwpi workspace
     FF06 206C     
0003 FF08 020A  24        li   rsp,STACK.
     FF0A 0100     
0004 FF0C 0460  28        b    @TT170
     FF0E C5A4     
0005               
                   < main.a99
0006                      copy "subroutines.a99"
     **** ****     > subroutines.a99
0001               jsr:
0002 FF10 D68B  38        movb r11,*rsp
0003 FF12 060A  22        dec  rsp
0004 FF14 06CB  22        swpb r11
0005 FF16 D68B  38        movb r11,*rsp
0006 FF18 060A  22        dec  rsp
0007 FF1A 0456  24        b    *rtmp
0008               
0009               rts:
0010 FF1C 058A  22        inc  rsp
0011 FF1E D2FA  44        movb *rsp+,r11
0012 FF20 06CB  22        swpb r11
0013 FF22 D2DA  38        movb *rsp,r11
0014 FF24 045B  24        b    *r11
0015               
0016               rola:
0017 FF26 1702  14        jnc  !
0018 FF28 0260  30        ori  ra,>0080
     FF2A 0080     
0019               !:
0020 FF2C 1002  14        jmp  !
0021 FF2E 0240  30        andi ra,>ff7f
     FF30 FF7F     
0022               !:
0023 FF32 0A10  26        sla  ra,1
0024 FF34 045B  24        rt
0025               
0026               rol:
0027 FF36 D198  38        movb *rarg1,rtmp
0028 FF38 1702  14        jnc  !
0029 FF3A 0266  30        ori  rtmp,>0080
     FF3C 0080     
0030               !:
0031 FF3E 1002  14        jmp  !
0032 FF40 0246  30        andi rtmp,>ff7f
     FF42 FF7F     
0033               !:
0034 FF44 0A16  26        sla  rtmp,1
0035 FF46 C606  38        mov  rtmp,*rarg1
0036 FF48 045B  24        rt
0037               
0038               rora:
0039 FF4A 1702  14        jnc  !
0040 FF4C 0260  30        ori  ra,>0001
     FF4E 0001     
0041               !:
0042 FF50 1002  14        jmp  !
0043 FF52 0240  30        andi ra,>fffe
     FF54 FFFE     
0044               !:
0045 FF56 0B10  26        src  ra,1
0046 FF58 0240  30        andi ra,>0080
     FF5A 0080     
0047 FF5C C180  30        mov  ra,rtmp
0048 FF5E 0A96  42        sla  rtmp,9
0049 FF60 045B  24        rt
0050               
0051               ror:
0052 FF62 D198  38        movb *rarg1,rtmp
0053 FF64 1702  14        jnc  !
0054 FF66 0266  30        ori  rtmp,>0001
     FF68 0001     
0055               !:
0056 FF6A 1002  14        jmp  !
0057 FF6C 0246  30        andi rtmp,>fffe
     FF6E FFFE     
0058               !:
0059 FF70 0B16  26        src  rtmp,1
0060 FF72 D606  38        movb rtmp,*rarg1
0061 FF74 0246  30        andi rtmp,>0080
     FF76 0080     
0062 FF78 0A96  42        sla  rtmp,9
0063 FF7A 045B  24        rt
                   < main.a99
