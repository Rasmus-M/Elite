XAS99 CROSS-ASSEMBLER   VERSION 3.6.5
     **** ****     > main.a99
0001                      copy "equates.a99"
     **** ****     > equates.a99
0001               ra:
0002      0000            requ 0
0003               ralb:
0004                      equ  >8301
0005               rx:
0006      0000            requ 1
0007               ry:
0008      0000            requ 2
0009               rzero:
0010      0000            requ 3
0011               rone:
0012      0000            requ 4
0013               rmone:
0014      0000            requ 5
0015               rtmp:
0016      0000            requ 6
0017               rtmplb:
0018                      equ >830d
0019               rtmp2:
0020      0000            requ 7
0021               tmp2lb:
0022                      equ >830f
0023               rarg1:
0024      0000            requ 8
0025               rarg2:
0026      0000            requ 9
0027               rsp:
0028      0000            requ 10
0029               rsplb:
0030                      equ >8315
0031               r11lb:
0032                      equ  >8317
0033               
0034               _MAX_COMMANDER:
0035                      equ  0
0036               _REMOVE_CHECKSUMS:
0037                      equ  1
0038               
0039               ZERO_PAGE.:
0040                      equ >0000
0041               STACK.:
0042                      equ >0100
0043               T.:
0044                      equ >0300
0045               CODE_WORDS.:
0046                      equ >0400
0047               K.:
0048                      equ >0900
0049               WP.:
0050                      equ >0D40
0051               CODE.:
0052                      equ >0F40
0053               CODE_PYTHON.:
0054                      equ >7F00
                   < main.a99
0002                      copy "macros.a99"
     **** ****     > macros.a99
0001               **
0002               * Macros
0003               *
0013               
0021               
0031               
0043               
0056               
0070               
0075               
0080               
0086               
0092               
0099               
0106               
0117               
0124               
0131               
0137               
0146               
0154               
0160               
0166               
0173               
0180               
0185               
0190               
0198               
0204               
0209               
0216               
0222               
0228               
0229               
0230               
0234               
0238               
0246               
0266               
0270               
0274               
0280               
                   < main.a99
0003                      copy "elite.a99"
     **** ****     > elite.a99
0001               * ******************************************************************************
0002               *
0003               * ELITE GAME SOURCE
0004               *
0005               * Elite was written by Ian Bell and David Braben and is copyright Acornsoft 1984
0006               *
0007               * The code on this site is identical to the source discs released on Ian Bell's
0008               * personal website at http://www.elitehomepage.org/ (it's just been reformatted
0009               * to be more readable)
0010               *
0011               * The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
0012               * in the documentation are entirely my fault
0013               *
0014               * The terminology and notations used in this commentary are explained at
0015               * https://elite.bbcelite.com/terminology
0016               *
0017               * The deep dive articles referred to in this commentary can be found at
0018               * https://elite.bbcelite.com/deep_dives
0019               *
0020               * ------------------------------------------------------------------------------
0021               *
0022               * This source file produces the following binary files:
0023               *
0024               * * ELTA.bin
0025               * * ELTB.bin
0026               * * ELTC.bin
0027               * * ELTD.bin
0028               * * ELTE.bin
0029               * * ELTF.bin
0030               * * ELTG.bin
0031               * * PYTHON.bin
0032               * * SHIPS.bin
0033               * * WORDS9.bin
0034               *
0035               * ******************************************************************************
0036               
0037                      ; INCLUDE "1-source-files/main-sources/elite-build-options.asm"
0038               
0039               _SOURCE_DISC:                                              ; (_VARIANT = 1)
0040                      equ 0
0041               _TEXT_SOURCES:                                             ; (_VARIANT = 2)
0042                      equ 0
0043               _STH_CASSETTE:                                             ; (_VARIANT = 3)
0044                      equ 1
0045               
0046                      ; GUARD &6000                                       ; Guard against assembling over screen memory
0047               
0048               * ******************************************************************************
0049               *
0050               * Configuration variables
0051               *
0052               * ******************************************************************************
0053               
0054               * ZERO_PAGE% = &0000
0055               
0056               * STACK% = &0100
0057               
0058               * CODE% = &0F40         \ The address where the code will be run
0059               
0060               LOAD.:                                                     ; The address where the code will be loaded
0061                      equ >1128
0062               
0063               * T% = &0300            \ Current commander data and stardust data blocks
0064               
0065               * CODE_WORDS% = &0400   \ The address where the text data will be run
0066               
0067               LOAD_WORDS.:                                               ; The address where the text data will be loaded
0068                      equ >1100
0069               
0070               * K% = &0900
0071               
0072               * WP% = &0D40
0073               
0074               * CODE_PYTHON% = &7F00
0075               
0076               Q.:                                                        ; Set Q% to TRUE to max out the default commander, FALSE
0077                      equ _MAX_COMMANDER
0078                                                                          ; for the standard default commander
0079               
0080               NOST:                                                      ; The number of stardust particles in normal space (this
0081                      equ 18
0082                                                                          ; goes down to 3 in witchspace)
0083               
0084               NOSH:                                                      ; The maximum number of ships in our local bubble of
0085                      equ 12
0086                                                                          ; universe
0087               
0088               NTY:                                                       ; The number of different ship types
0089                      equ 13
0090               
0091               COPS:                                                      ; Ship type for a Viper
0092                      equ 2
0093               
0094               THG:                                                       ; Ship type for a Thargoid
0095                      equ 6
0096               
0097               CYL:                                                       ; Ship type for a Cobra Mk III (trader)
0098                      equ 7
0099               
0100               SST:                                                       ; Ship type for the space station
0101                      equ 8
0102               
0103               MSL:                                                       ; Ship type for a missile
0104                      equ 9
0105               
0106               AST:                                                       ; Ship type for an asteroid
0107                      equ 10
0108               
0109               OIL:                                                       ; Ship type for a cargo canister
0110                      equ 11
0111               
0112               TGL:                                                       ; Ship type for a Thargon
0113                      equ 12
0114               
0115               ESC:                                                       ; Ship type for an escape pod
0116                      equ 13
0117               
0118               POW:                                                       ; Pulse laser power
0119                      equ 15
0120               
0121               NI.:                                                       ; The number of bytes in each ship's data block (as
0122                      equ 36
0123                                                                          ; stored in INWK and K%)
0124               
0125               VSCAN:                                                     ; Defines the split position in the split-screen mode
0126                      equ 57
0127               
0128               X:                                                         ; The centre x-coordinate of the 256 x 192 space view
0129                      equ 128
0130               
0131               Y:                                                         ; The centre y-coordinate of the 256 x 192 space view
0132                      equ 96
0133               
0134               f0_:                                                       ; Internal key number for red key f0 (Launch, Front)
0135                      equ >20
0136               
0137               f1_:                                                       ; Internal key number for red key f1 (Buy Cargo, Rear)
0138                      equ >71
0139               
0140               f2_:                                                       ; Internal key number for red key f2 (Sell Cargo, Left)
0141                      equ >72
0142               
0143               f3_:                                                       ; Internal key number for red key f3 (Equip Ship, Right)
0144                      equ >73
0145               
0146               f4_:                                                       ; Internal key number for red key f4 (Long-range Chart)
0147                      equ >14
0148               
0149               f5_:                                                       ; Internal key number for red key f5 (Short-range Chart)
0150                      equ >74
0151               
0152               f6_:                                                       ; Internal key number for red key f6 (Data on System)
0153                      equ >75
0154               
0155               f7_:                                                       ; Internal key number for red key f7 (Market Price)
0156                      equ >16
0157               
0158               f8_:                                                       ; Internal key number for red key f8 (Status Mode)
0159                      equ >76
0160               
0161               f9_:                                                       ; Internal key number for red key f9 (Inventory)
0162                      equ >77
0163               
0164               RE:                                                        ; The obfuscation byte used to hide the recursive tokens
0165                      equ >23
0166                                                                          ; table from crackers viewing the binary code
0167               
0168               VIA:                                                       ; Memory-mapped space for accessing internal hardware,
0169                      equ >FE00
0170                                                                          ; such as the video ULA, 6845 CRTC and 6522 VIAs (also
0171                                                                          ; known as SHEILA)
0172               
0173               OSBYTE:                                                    ; The address for the OSBYTE routine, which is used
0174                      equ >FFF4
0175                                                                          ; three times in the main game code
0176               
0177               OSWORD:                                                    ; The address for the OSWORD routine, which is used
0178                      equ >FFF1
0179                                                                          ; twice in the main game code
0180               
0181               OSFILE:                                                    ; The address for the OSFILE routine, which is used
0182                      equ >FFDD
0183                                                                          ; once in the main game code
0184               
0185               * ******************************************************************************
0186               *
0187               * Name: ZP
0188               * Type: Workspace
0189               * Address: &0000 to &00B0
0190               * Category: Workspaces
0191               * Summary: Lots of important variables are stored in the zero page workspace
0192               * as it is quicker and more space-efficient to access memory here
0193               *
0194               * ******************************************************************************
0195               
0196                      aorg ZERO_PAGE.
0197               
0198               ZP:
0199 0000                 bss 0                                               ; The start of the zero page workspace
0200               
0201               RAND:
0202 0000                 bss 4                                               ; Four 8-bit seeds for the random number generation
0203                                                                          ; system implemented in the DORND routine
0204               
0205               TRTB.:
0206 0004                 bss 2                                               ; Contains the address of the keyboard translation
0207                                                                          ; table, which is used to translate internal key
0208                                                                          ; numbers to ASCII
0209               
0210               T1:
0211 0006                 bss 1                                               ; Temporary storage, used in a number of places
0212               
0213               SC:
0214 0007                 bss 1                                               ; Screen address (low byte)
0215                                                                          ;
0216                                                                          ; Elite draws on-screen by poking bytes directly into
0217                                                                          ; screen memory, and SC(1 0) is typically set to the
0218                                                                          ; address of the character block containing the pixel
0219                                                                          ; we want to draw (see the deep dives on "Drawing
0220                                                                          ; monochrome pixels in mode 4" and "Drawing colour
0221                                                                          ; pixels in mode 5" for more details)
0222               
0223               SCH:
0224 0008                 bss 1                                               ; Screen address (high byte)
0225               
0226               XX16:
0227 0009                 bss 18                                              ; Temporary storage for a block of values, used in a
0228                                                                          ; number of places
0229               
0230               P:
0231 001B                 bss 3                                               ; Temporary storage, used in a number of places
0232               
0233               XX0:
0234 001E                 bss 2                                               ; Temporary storage, used to store the address of a ship
0235                                                                          ; blueprint. For example, it is used when we add a new
0236                                                                          ; ship to the local bubble in routine NWSHP, and it
0237                                                                          ; contains the address of the current ship's blueprint
0238                                                                          ; as we loop through all the nearby ships in the main
0239                                                                          ; flight loop
0240               
0241               INF:
0242 0020                 bss 2                                               ; Temporary storage, typically used for storing the
0243                                                                          ; address of a ship's data block, so it can be copied
0244                                                                          ; to and from the internal workspace at INWK
0245               
0246               V:
0247 0022                 bss 2                                               ; Temporary storage, typically used for storing an
0248                                                                          ; address pointer
0249               
0250               XX:
0251 0024                 bss 2                                               ; Temporary storage, typically used for storing a 16-bit
0252                                                                          ; x-coordinate
0253               
0254               YY:
0255 0026                 bss 2                                               ; Temporary storage, typically used for storing a 16-bit
0256                                                                          ; y-coordinate
0257               
0258               SUNX:
0259 0028                 bss 2                                               ; The 16-bit x-coordinate of the vertical centre axis
0260                                                                          ; of the sun (which might be off-screen)
0261               
0262               BETA:
0263 002A                 bss 1                                               ; The current pitch angle beta, which is reduced from
0264                                                                          ; JSTY to a sign-magnitude value between -8 and +8
0265                                                                          ;
0266                                                                          ; This describes how fast we are pitching our ship, and
0267                                                                          ; determines how fast the universe pitches around us
0268                                                                          ;
0269                                                                          ; The sign bit is also stored in BET2, while the
0270                                                                          ; opposite sign is stored in BET2+1
0271               
0272               BET1:
0273 002B                 bss 1                                               ; The magnitude of the pitch angle beta, i.e. |beta|,
0274                                                                          ; which is a positive value between 0 and 8
0275               
0276               XC:
0277 002C                 bss 1                                               ; The x-coordinate of the text cursor (i.e. the text
0278                                                                          ; column), which can be from 0 to 32
0279                                                                          ;
0280                                                                          ; A value of 0 denotes the leftmost column and 32 the
0281                                                                          ; rightmost column, but because the top part of the
0282                                                                          ; screen (the space view) has a white border that
0283                                                                          ; clashes with columns 0 and 32, text is only shown
0284                                                                          ; in columns 1-31
0285               
0286               YC:
0287 002D                 bss 1                                               ; The y-coordinate of the text cursor (i.e. the text
0288                                                                          ; row), which can be from 0 to 23
0289                                                                          ;
0290                                                                          ; The screen actually has 31 character rows if you
0291                                                                          ; include the dashboard, but the text printing routines
0292                                                                          ; only work on the top part (the space view), so the
0293                                                                          ; text cursor only goes up to a maximum of 23, the row
0294                                                                          ; just before the screen splits
0295                                                                          ;
0296                                                                          ; A value of 0 denotes the top row, but because the
0297                                                                          ; top part of the screen has a white border that clashes
0298                                                                          ; with row 0, text is always shown at row 1 or greater
0299               
0300               QQ22:
0301 002E                 bss 2                                               ; The two hyperspace countdown counters
0302                                                                          ;
0303                                                                          ; Before a hyperspace jump, both QQ22 and QQ22+1 are
0304                                                                          ; set to 15
0305                                                                          ;
0306                                                                          ; QQ22 is an internal counter that counts down by 1
0307                                                                          ; each time TT102 is called, which happens every
0308                                                                          ; iteration of the main game loop. When it reaches
0309                                                                          ; zero, the on-screen counter in QQ22+1 gets
0310                                                                          ; decremented, and QQ22 gets set to 5 and the countdown
0311                                                                          ; continues (so the first tick of the hyperspace counter
0312                                                                          ; takes 15 iterations to happen, but subsequent ticks
0313                                                                          ; take 5 iterations each)
0314                                                                          ;
0315                                                                          ; QQ22+1 contains the number that's shown on-screen
0316                                                                          ; during the countdown. It counts down from 15 to 1, and
0317                                                                          ; when it hits 0, the hyperspace engines kick in
0318               
0319               ECMA:
0320 0030                 bss 1                                               ; The E.C.M. countdown timer, which determines whether
0321                                                                          ; an E.C.M. system is currently operating:
0322                                                                          ;
0323                                                                          ; * 0 = E.C.M. is off
0324                                                                          ;
0325                                                                          ; * Non-zero = E.C.M. is on and is counting down
0326                                                                          ;
0327                                                                          ; The counter starts at 32 when an E.C.M. is activated,
0328                                                                          ; either by us or by an opponent, and it decreases by 1
0329                                                                          ; in each iteration of the main flight loop until it
0330                                                                          ; reaches zero, at which point the E.C.M. switches off.
0331                                                                          ; Only one E.C.M. can be active at any one time, so
0332                                                                          ; there is only one counter
0333               
0334               XX15:
0335 0031                 bss 0                                               ; Temporary storage, typically used for storing screen
0336                                                                          ; coordinates in line-drawing routines
0337                                                                          ;
0338                                                                          ; There are six bytes of storage, from XX15 TO XX15+5.
0339                                                                          ; The first four bytes have the following aliases:
0340                                                                          ;
0341                                                                          ; X1 = XX15
0342                                                                          ; Y1 = XX15+1
0343                                                                          ; X2 = XX15+2
0344                                                                          ; Y2 = XX15+3
0345                                                                          ;
0346                                                                          ; These are typically used for describing lines in terms
0347                                                                          ; of screen coordinates, i.e. (X1, Y1) to (X2, Y2)
0348                                                                          ;
0349                                                                          ; The last two bytes of XX15 do not have aliases
0350               
0351               X1:
0352 0031                 bss 1                                               ; Temporary storage, typically used for x-coordinates in
0353                                                                          ; line-drawing routines
0354               
0355               Y1:
0356 0032                 bss 1                                               ; Temporary storage, typically used for y-coordinates in
0357                                                                          ; line-drawing routines
0358               
0359               X2:
0360 0033                 bss 1                                               ; Temporary storage, typically used for x-coordinates in
0361                                                                          ; line-drawing routines
0362               
0363               Y2:
0364 0034                 bss 1                                               ; Temporary storage, typically used for y-coordinates in
0365                                                                          ; line-drawing routines
0366               
0367 0035                 bss 2                                               ; The last two bytes of the XX15 block
0368               
0369               XX12:
0370 0037                 bss 6                                               ; Temporary storage for a block of values, used in a
0371                                                                          ; number of places
0372               
0373               K:
0374 003D                 bss 4                                               ; Temporary storage, used in a number of places
0375               
0376               KL:
0377 0041                 bss 1                                               ; The following bytes implement a key logger that
0378                                                                          ; enables Elite to scan for concurrent key presses of
0379                                                                          ; the primary flight keys, plus a secondary flight key
0380                                                                          ;
0381                                                                          ; See the deep dive on "The key logger" for more details
0382                                                                          ;
0383                                                                          ; If a key is being pressed that is not in the keyboard
0384                                                                          ; table at KYTB, it can be stored here (as seen in
0385                                                                          ; routine DK4, for example)
0386               
0387               KY1:
0388 0042                 bss 1                                               ; "?" is being pressed
0389                                                                          ;
0390                                                                          ; * 0 = no
0391                                                                          ;
0392                                                                          ; * Non-zero = yes
0393               
0394               KY2:
0395 0043                 bss 1                                               ; Space is being pressed
0396                                                                          ;
0397                                                                          ; * 0 = no
0398                                                                          ;
0399                                                                          ; * Non-zero = yes
0400               
0401               KY3:
0402 0044                 bss 1                                               ; "<" is being pressed
0403                                                                          ;
0404                                                                          ; * 0 = no
0405                                                                          ;
0406                                                                          ; * Non-zero = yes
0407               
0408               KY4:
0409 0045                 bss 1                                               ; ">" is being pressed
0410                                                                          ;
0411                                                                          ; * 0 = no
0412                                                                          ;
0413                                                                          ; * Non-zero = yes
0414               
0415               KY5:
0416 0046                 bss 1                                               ; "X" is being pressed
0417                                                                          ;
0418                                                                          ; * 0 = no
0419                                                                          ;
0420                                                                          ; * Non-zero = yes
0421               
0422               KY6:
0423 0047                 bss 1                                               ; "S" is being pressed
0424                                                                          ;
0425                                                                          ; * 0 = no
0426                                                                          ;
0427                                                                          ; * Non-zero = yes
0428               
0429               KY7:
0430 0048                 bss 1                                               ; "A" is being pressed
0431                                                                          ;
0432                                                                          ; * 0 = no
0433                                                                          ;
0434                                                                          ; * Non-zero = yes
0435                                                                          ;
0436                                                                          ; This is also set when the joystick fire button has
0437                                                                          ; been pressed
0438               
0439               KY12:
0440 0049                 bss 1                                               ; TAB is being pressed
0441                                                                          ;
0442                                                                          ; * 0 = no
0443                                                                          ;
0444                                                                          ; * Non-zero = yes
0445               
0446               KY13:
0447 004A                 bss 1                                               ; ESCAPE is being pressed
0448                                                                          ;
0449                                                                          ; * 0 = no
0450                                                                          ;
0451                                                                          ; * Non-zero = yes
0452               
0453               KY14:
0454 004B                 bss 1                                               ; "T" is being pressed
0455                                                                          ;
0456                                                                          ; * 0 = no
0457                                                                          ;
0458                                                                          ; * Non-zero = yes
0459               
0460               KY15:
0461 004C                 bss 1                                               ; "U" is being pressed
0462                                                                          ;
0463                                                                          ; * 0 = no
0464                                                                          ;
0465                                                                          ; * Non-zero = yes
0466               
0467               KY16:
0468 004D                 bss 1                                               ; "M" is being pressed
0469                                                                          ;
0470                                                                          ; * 0 = no
0471                                                                          ;
0472                                                                          ; * Non-zero = yes
0473               
0474               KY17:
0475 004E                 bss 1                                               ; "E" is being pressed
0476                                                                          ;
0477                                                                          ; * 0 = no
0478                                                                          ;
0479                                                                          ; * Non-zero = yes
0480               
0481               KY18:
0482 004F                 bss 1                                               ; "J" is being pressed
0483                                                                          ;
0484                                                                          ; * 0 = no
0485                                                                          ;
0486                                                                          ; * Non-zero = yes
0487               
0488               KY19:
0489 0050                 bss 1                                               ; "C" is being pressed
0490                                                                          ;
0491                                                                          ; * 0 = no
0492                                                                          ;
0493                                                                          ; * Non-zero = yes
0494               
0495               LAS:
0496 0051                 bss 1                                               ; Contains the laser power of the laser fitted to the
0497                                                                          ; current space view (or 0 if there is no laser fitted
0498                                                                          ; to the current view)
0499                                                                          ;
0500                                                                          ; This gets set to bits 0-6 of the laser power byte from
0501                                                                          ; the commander data block, which contains the laser's
0502                                                                          ; power (bit 7 doesn't denote laser power, just whether
0503                                                                          ; or not the laser pulses, so that is not stored here)
0504               
0505               MSTG:
0506 0052                 bss 1                                               ; The current missile lock target
0507                                                                          ;
0508                                                                          ; * &FF = no target
0509                                                                          ;
0510                                                                          ; * 1-12 = the slot number of the ship that our
0511                                                                          ; missile is locked onto
0512               
0513               XX1:
0514 0053                 bss 0                                               ; This is an alias for INWK that is used in the main
0515                                                                          ; ship-drawing routine at LL9
0516               
0517               INWK:
0518 0053                 bss 33                                              ; The zero-page internal workspace for the current ship
0519                                                                          ; data block
0520                                                                          ;
0521                                                                          ; As operations on zero page locations are faster and
0522                                                                          ; have smaller opcodes than operations on the rest of
0523                                                                          ; the addressable memory, Elite tends to store oft-used
0524                                                                          ; data here. A lot of the routines in Elite need to
0525                                                                          ; access and manipulate ship data, so to make this an
0526                                                                          ; efficient exercise, the ship data is first copied from
0527                                                                          ; the ship data blocks at K% into INWK (or, when new
0528                                                                          ; ships are spawned, from the blueprints at XX21). See
0529                                                                          ; the deep dive on "Ship data blocks" for details of
0530                                                                          ; what each of the bytes in the INWK data block
0531                                                                          ; represents
0532               
0533               XX19:
0534 0074                 bss NI. - 33                                        ; XX19(1 0) shares its location with INWK(34 33), which
0535                                                                          ; contains the address of the ship line heap
0536               
0537               LSP:
0538 0077                 bss 1                                               ; The ball line heap pointer, which contains the number
0539                                                                          ; of the first free byte after the end of the LSX2 and
0540                                                                          ; LSY2 heaps (see the deep dive on "The ball line heap"
0541                                                                          ; for details)
0542               
0543               QQ15:
0544 0078                 bss 6                                               ; The three 16-bit seeds for the selected system, i.e.
0545                                                                          ; the one in the crosshairs in the Short-range Chart
0546                                                                          ;
0547                                                                          ; See the deep dives on "Galaxy and system seeds" and
0548                                                                          ; "Twisting the system seeds" for more details
0549               
0550               K5:
0551 007E                 bss 0                                               ; Temporary storage used to store segment coordinates
0552                                                                          ; across successive calls to BLINE, the ball line
0553                                                                          ; routine
0554               
0555               XX18:
0556 007E                 bss 0                                               ; Temporary storage used to store coordinates in the
0557                                                                          ; LL9 ship-drawing routine
0558               
0559               QQ17:
0560 007E                 bss 1                                               ; Contains a number of flags that affect how text tokens
0561                                                                          ; are printed, particularly capitalisation:
0562                                                                          ;
0563                                                                          ; * If all bits are set (255) then text printing is
0564                                                                          ; disabled
0565                                                                          ;
0566                                                                          ; * Bit 7: 0 = ALL CAPS
0567                                                                          ; 1 = Sentence Case, bit 6 determines the
0568                                                                          ; case of the next letter to print
0569                                                                          ;
0570                                                                          ; * Bit 6: 0 = print the next letter in upper case
0571                                                                          ; 1 = print the next letter in lower case
0572                                                                          ;
0573                                                                          ; * Bits 0-5: If any of bits 0-5 are set, print in
0574                                                                          ; lower case
0575                                                                          ;
0576                                                                          ; So:
0577                                                                          ;
0578                                                                          ; * QQ17 = 0 means case is set to ALL CAPS
0579                                                                          ;
0580                                                                          ; * QQ17 = %10000000 means Sentence Case, currently
0581                                                                          ; printing upper case
0582                                                                          ;
0583                                                                          ; * QQ17 = %11000000 means Sentence Case, currently
0584                                                                          ; printing lower case
0585                                                                          ;
0586                                                                          ; * QQ17 = %11111111 means printing is disabled
0587               
0588               QQ19:
0589 007F                 bss 3                                               ; Temporary storage, used in a number of places
0590               
0591               K6:
0592 0082                 bss 5                                               ; Temporary storage, typically used for storing
0593                                                                          ; coordinates during vector calculations
0594               
0595               ALP1:
0596 0087                 bss 1                                               ; Magnitude of the roll angle alpha, i.e. |alpha|,
0597                                                                          ; which is a positive value between 0 and 31
0598               
0599               ALP2:
0600 0088                 bss 2                                               ; Bit 7 of ALP2 = sign of the roll angle in ALPHA
0601                                                                          ;
0602                                                                          ; Bit 7 of ALP2+1 = opposite sign to ALP2 and ALPHA
0603               
0604               BET2:
0605 008A                 bss 2                                               ; Bit 7 of BET2 = sign of the pitch angle in BETA
0606                                                                          ;
0607                                                                          ; Bit 7 of BET2+1 = opposite sign to BET2 and BETA
0608               
0609               DELTA:
0610 008C                 bss 1                                               ; Our current speed, in the range 1-40
0611               
0612               DELT4:
0613 008D                 bss 2                                               ; Our current speed * 64 as a 16-bit value
0614                                                                          ;
0615                                                                          ; This is stored as DELT4(1 0), so the high byte in
0616                                                                          ; DELT4+1 therefore contains our current speed / 4
0617               
0618               U:
0619 008F                 bss 1                                               ; Temporary storage, used in a number of places
0620               
0621               Q:
0622 0090                 bss 1                                               ; Temporary storage, used in a number of places
0623               
0624               R:
0625 0091                 bss 1                                               ; Temporary storage, used in a number of places
0626               
0627               S:
0628 0092                 bss 1                                               ; Temporary storage, used in a number of places
0629               
0630               XSAV:
0631 0093                 bss 1                                               ; Temporary storage for saving the value of the X
0632                                                                          ; register, used in a number of places
0633               
0634               YSAV:
0635 0094                 bss 1                                               ; Temporary storage for saving the value of the Y
0636                                                                          ; register, used in a number of places
0637               
0638               XX17:
0639 0095                 bss 1                                               ; Temporary storage, used in BPRNT to store the number
0640                                                                          ; of characters to print, and as the edge counter in the
0641                                                                          ; main ship-drawing routine
0642               
0643               QQ11:
0644 0096                 bss 1                                               ; The type of the current view:
0645                                                                          ;
0646                                                                          ; 0   = Space view
0647                                                                          ; 1   = Title screen
0648                                                                          ; Get commander name ("@", save/load commander)
0649                                                                          ; In-system jump just arrived ("J")
0650                                                                          ; Data on System screen (red key f6)
0651                                                                          ; Buy Cargo screen (red key f1)
0652                                                                          ; Mis-jump just arrived (witchspace)
0653                                                                          ; 4   = Sell Cargo screen (red key f2)
0654                                                                          ; 6   = Death screen
0655                                                                          ; 8   = Status Mode screen (red key f8)
0656                                                                          ; Inventory screen (red key f9)
0657                                                                          ; 16  = Market Price screen (red key f7)
0658                                                                          ; 32  = Equip Ship screen (red key f3)
0659                                                                          ; 64  = Long-range Chart (red key f4)
0660                                                                          ; 128 = Short-range Chart (red key f5)
0661                                                                          ;
0662                                                                          ; This value is typically set by calling routine TT66
0663               
0664               ZZ:
0665 0097                 bss 1                                               ; Temporary storage, typically used for distance values
0666               
0667               XX13:
0668 0098                 bss 1                                               ; Temporary storage, typically used in the line-drawing
0669                                                                          ; routines
0670               
0671               MCNT:
0672 0099                 bss 1                                               ; The main loop counter
0673                                                                          ;
0674                                                                          ; This counter determines how often certain actions are
0675                                                                          ; performed within the main loop. See the deep dive on
0676                                                                          ; "Scheduling tasks with the main loop counter" for more
0677                                                                          ; details
0678               
0679               DL:
0680 009A                 bss 1                                               ; Vertical sync flag
0681                                                                          ;
0682                                                                          ; DL gets set to 30 every time we reach vertical sync on
0683                                                                          ; the video system, which happens 50 times a second
0684                                                                          ; (50Hz). The WSCAN routine uses this to pause until the
0685                                                                          ; vertical sync, by setting DL to 0 and then monitoring
0686                                                                          ; its value until it changes to 30
0687               
0688               TYPE:
0689 009B                 bss 1                                               ; The current ship type
0690                                                                          ;
0691                                                                          ; This is where we store the current ship type for when
0692                                                                          ; we are iterating through the ships in the local bubble
0693                                                                          ; as part of the main flight loop. See the table at XX21
0694                                                                          ; for information about ship types
0695               
0696               JSTX:
0697 009C                 bss 1                                               ; Our current roll rate
0698                                                                          ;
0699                                                                          ; This value is shown in the dashboard's RL indicator,
0700                                                                          ; and determines the rate at which we are rolling
0701                                                                          ;
0702                                                                          ; The value ranges from 1 to 255 with 128 as the centre
0703                                                                          ; point, so 1 means roll is decreasing at the maximum
0704                                                                          ; rate, 128 means roll is not changing, and 255 means
0705                                                                          ; roll is increasing at the maximum rate
0706                                                                          ;
0707                                                                          ; This value is updated by "<" and ">" key presses, or
0708                                                                          ; if joysticks are enabled, from the joystick. If
0709                                                                          ; keyboard damping is enabled (which it is by default),
0710                                                                          ; the value is slowly moved towards the centre value of
0711                                                                          ; 128 (no roll) if there are no key presses or joystick
0712                                                                          ; movement
0713               
0714               JSTY:
0715 009D                 bss 1                                               ; Our current pitch rate
0716                                                                          ;
0717                                                                          ; This value is shown in the dashboard's DC indicator,
0718                                                                          ; and determines the rate at which we are pitching
0719                                                                          ;
0720                                                                          ; The value ranges from 1 to 255 with 128 as the centre
0721                                                                          ; point, so 1 means pitch is decreasing at the maximum
0722                                                                          ; rate, 128 means pitch is not changing, and 255 means
0723                                                                          ; pitch is increasing at the maximum rate
0724                                                                          ;
0725                                                                          ; This value is updated by "S" and "X" key presses, or
0726                                                                          ; if joysticks are enabled, from the joystick. If
0727                                                                          ; keyboard damping is enabled (which it is by default),
0728                                                                          ; the value is slowly moved towards the centre value of
0729                                                                          ; 128 (no pitch) if there are no key presses or joystick
0730                                                                          ; movement
0731               
0732               ALPHA:
0733 009E                 bss 1                                               ; The current roll angle alpha, which is reduced from
0734                                                                          ; JSTX to a sign-magnitude value between -31 and +31
0735                                                                          ;
0736                                                                          ; This describes how fast we are rolling our ship, and
0737                                                                          ; determines how fast the universe rolls around us
0738                                                                          ;
0739                                                                          ; The sign bit is also stored in ALP2, while the
0740                                                                          ; opposite sign is stored in ALP2+1
0741               
0742               QQ12:
0743 009F                 bss 1                                               ; Our "docked" status
0744                                                                          ;
0745                                                                          ; * 0 = we are not docked
0746                                                                          ;
0747                                                                          ; * &FF = we are docked
0748               
0749               TGT:
0750 00A0                 bss 1                                               ; Temporary storage, typically used as a target value
0751                                                                          ; for counters when drawing explosion clouds and partial
0752                                                                          ; circles
0753               
0754               SWAP:
0755 00A1                 bss 1                                               ; Temporary storage, used to store a flag that records
0756                                                                          ; whether or not we had to swap a line's start and end
0757                                                                          ; coordinates around when clipping the line in routine
0758                                                                          ; LL145 (the flag is used in places like BLINE to swap
0759                                                                          ; them back)
0760               
0761               COL:
0762 00A2                 bss 1                                               ; Temporary storage, used to store colour information
0763                                                                          ; when drawing pixels in the dashboard
0764               
0765               FLAG:
0766 00A3                 bss 1                                               ; A flag that's used to define whether this is the first
0767                                                                          ; call to the ball line routine in BLINE, so it knows
0768                                                                          ; whether to wait for the second call before storing
0769                                                                          ; segment data in the ball line heap
0770               
0771               CNT:
0772 00A4                 bss 1                                               ; Temporary storage, typically used for storing the
0773                                                                          ; number of iterations required when looping
0774               
0775               CNT2:
0776 00A5                 bss 1                                               ; Temporary storage, used in the planet-drawing routine
0777                                                                          ; to store the segment number where the arc of a partial
0778                                                                          ; circle should start
0779               
0780               STP:
0781 00A6                 bss 1                                               ; The step size for drawing circles
0782                                                                          ;
0783                                                                          ; Circles in Elite are split up into 64 points, and the
0784                                                                          ; step size determines how many points to skip with each
0785                                                                          ; straight-line segment, so the smaller the step size,
0786                                                                          ; the smoother the circle. The values used are:
0787                                                                          ;
0788                                                                          ; * 2 for big planets and the circles on the charts
0789                                                                          ; * 4 for medium planets and the launch tunnel
0790                                                                          ; * 8 for small planets and the hyperspace tunnel
0791                                                                          ;
0792                                                                          ; As the step size increases we move from smoother
0793                                                                          ; circles at the top to more polygonal at the bottom.
0794                                                                          ; See the CIRCLE2 routine for more details
0795               
0796               XX4:
0797 00A7                 bss 1                                               ; Temporary storage, used in a number of places
0798               
0799               XX20:
0800 00A8                 bss 1                                               ; Temporary storage, used in a number of places
0801               
0802               XX14:
0803 00A9                 bss 1                                               ; This byte appears to be unused
0804               
0805               RAT:
0806 00AA                 bss 1                                               ; Used to store different signs depending on the current
0807                                                                          ; space view, for use in calculating stardust movement
0808               
0809               RAT2:
0810 00AB                 bss 1                                               ; Temporary storage, used to store the pitch and roll
0811                                                                          ; signs when moving objects and stardust
0812               
0813               K2:
0814 00AC                 bss 4                                               ; Temporary storage, used in a number of places
0815               
0816               * RM: At &00B0 = 176
0817               
0818                      aorg ZERO_PAGE.+>00D1
0819               
0820               T:
0821 00D1                 bss 1                                               ; Temporary storage, used in a number of places
0822               
0823               K3:
0824 00D2                 bss 0                                               ; Temporary storage, used in a number of places
0825               
0826               XX2:
0827 00D2                 bss 14                                              ; Temporary storage, used to store the visibility of the
0828                                                                          ; ship's faces during the ship-drawing routine at LL9
0829               
0830               K4:
0831 00E0                 bss 2                                               ; Temporary storage, used in a number of places
0832               
0833                      ; PRINT "Zero page variables from ", ~ZP, " to ", ~P%
0834               
0835               * ******************************************************************************
0836               *
0837               * Name: XX3
0838               * Type: Workspace
0839               * Address: &0100 to the top of the descending stack
0840               * Category: Workspaces
0841               * Summary: Temporary storage space for complex calculations
0842               *
0843               * ------------------------------------------------------------------------------
0844               *
0845               * Used as heap space for storing temporary data during calculations. Shared with
0846               * the descending 6502 stack, which works down from &01FF.
0847               *
0848               * ******************************************************************************
0849               
0850                      aorg STACK.
0851               
0852               XX3:
0853 0100                 bss 256                                             ; Temporary storage, typically used for storing tables
0854                                                                          ; of values such as screen coordinates or ship data
0855               
0856               * ******************************************************************************
0857               *
0858               * Name: T%
0859               * Type: Workspace
0860               * Address: &0300 to &035F
0861               * Category: Workspaces
0862               * Summary: Current commander data and stardust data blocks
0863               *
0864               * ------------------------------------------------------------------------------
0865               *
0866               * Contains the current commander data (NT% bytes at location TP), and the
0867               * stardust data blocks (NOST bytes at location SX)
0868               *
0869               * ******************************************************************************
0870               
0871                      aorg T.
0872               
0873 0300                 bss 0                                               ; The start of the T% workspace
0874               
0875               TP:
0876 0300                 bss 1                                               ; The current mission status, which is always 0 for the
0877                                                                          ; cassette version of Elite as there are no missions
0878               
0879               QQ0:
0880 0301                 bss 1                                               ; The current system's galactic x-coordinate (0-256)
0881               
0882               QQ1:
0883 0302                 bss 1                                               ; The current system's galactic y-coordinate (0-256)
0884               
0885               QQ21:
0886 0303                 bss 6                                               ; The three 16-bit seeds for the current galaxy
0887                                                                          ;
0888                                                                          ; These seeds define system 0 in the current galaxy, so
0889                                                                          ; they can be used as a starting point to generate all
0890                                                                          ; 256 systems in the galaxy
0891                                                                          ;
0892                                                                          ; Using a galactic hyperdrive rotates each byte to the
0893                                                                          ; left (rolling each byte within itself) to get the
0894                                                                          ; seeds for the next galaxy, so after eight galactic
0895                                                                          ; jumps, the seeds roll around to the first galaxy again
0896                                                                          ;
0897                                                                          ; See the deep dives on "Galaxy and system seeds" and
0898                                                                          ; "Twisting the system seeds" for more details
0899               
0900               CASH:
0901 0309                 bss 4                                               ; Our current cash pot
0902                                                                          ;
0903                                                                          ; The cash stash is stored as a 32-bit unsigned integer,
0904                                                                          ; with the most significant byte in CASH and the least
0905                                                                          ; significant in CASH+3. This is big-endian, which is
0906                                                                          ; the opposite way round to most of the numbers used in
0907                                                                          ; Elite - to use our notation for multi-byte numbers,
0908                                                                          ; the amount of cash is CASH(0 1 2 3)
0909               
0910               QQ14:
0911 030D                 bss 1                                               ; Our current fuel level (0-70)
0912                                                                          ;
0913                                                                          ; The fuel level is stored as the number of light years
0914                                                                          ; multiplied by 10, so QQ14 = 1 represents 0.1 light
0915                                                                          ; years, and the maximum possible value is 70, for 7.0
0916                                                                          ; light years
0917               
0918               COK:
0919 030E                 bss 1                                               ; Flags used to generate the competition code
0920                                                                          ;
0921                                                                          ; See the deep dive on "The competition code" for
0922                                                                          ; details of these flags and how they are used in
0923                                                                          ; generating and decoding the competition code
0924               
0925               GCNT:
0926 030F                 bss 1                                               ; The number of the current galaxy (0-7)
0927                                                                          ;
0928                                                                          ; When this is displayed in-game, 1 is added to the
0929                                                                          ; number, so we start in galaxy 1 in-game, but it's
0930                                                                          ; stored as galaxy 0 internally
0931                                                                          ;
0932                                                                          ; The galaxy number increases by one every time a
0933                                                                          ; galactic hyperdrive is used, and wraps back around to
0934                                                                          ; the start after eight galaxies
0935               
0936               LASER:
0937 0310                 bss 4                                               ; The specifications of the lasers fitted to each of the
0938                                                                          ; four space views:
0939                                                                          ;
0940                                                                          ; * Byte #0 = front view
0941                                                                          ; * Byte #1 = rear view
0942                                                                          ; * Byte #2 = left view
0943                                                                          ; * Byte #3 = right view
0944                                                                          ;
0945                                                                          ; For each of the views:
0946                                                                          ;
0947                                                                          ; * 0 = no laser is fitted to this view
0948                                                                          ;
0949                                                                          ; * Non-zero = a laser is fitted to this view, with
0950                                                                          ; the following specification:
0951                                                                          ;
0952                                                                          ; * Bits 0-6 contain the laser's power
0953                                                                          ;
0954                                                                          ; * Bit 7 determines whether or not the laser pulses
0955                                                                          ; (0 = pulse laser) or is always on (1 = beam
0956                                                                          ; laser)
0957               
0958 0314                 bss 2                                               ; These bytes appear to be unused (they were originally
0959                                                                          ; used for up/down lasers, but they were dropped)
0960               
0961               CRGO:
0962 0316                 bss 1                                               ; Our ship's cargo capacity
0963                                                                          ;
0964                                                                          ; * 22 = standard cargo bay of 20 tonnes
0965                                                                          ;
0966                                                                          ; * 37 = large cargo bay of 35 tonnes
0967                                                                          ;
0968                                                                          ; The value is two greater than the actual capacity to
0969                                                                          ; make the maths in tnpr slightly more efficient
0970               
0971               QQ20:
0972 0317                 bss 17                                              ; The contents of our cargo hold
0973                                                                          ;
0974                                                                          ; The amount of market item X that we have in our hold
0975                                                                          ; can be found in the X-th byte of QQ20. For example:
0976                                                                          ;
0977                                                                          ; * QQ20 contains the amount of food (item 0)
0978                                                                          ;
0979                                                                          ; * QQ20+7 contains the amount of computers (item 7)
0980                                                                          ;
0981                                                                          ; See QQ23 for a list of market item numbers and their
0982                                                                          ; storage units
0983               
0984               ECM:
0985 0328                 bss 1                                               ; E.C.M. system
0986                                                                          ;
0987                                                                          ; * 0 = not fitted
0988                                                                          ;
0989                                                                          ; * &FF = fitted
0990               
0991               BST:
0992 0329                 bss 1                                               ; Fuel scoops (BST stands for "barrel status")
0993                                                                          ;
0994                                                                          ; * 0 = not fitted
0995                                                                          ;
0996                                                                          ; * &FF = fitted
0997               
0998               BOMB:
0999 032A                 bss 1                                               ; Energy bomb
1000                                                                          ;
1001                                                                          ; * 0 = not fitted
1002                                                                          ;
1003                                                                          ; * &7F = fitted
1004               
1005               ENGY:
1006 032B                 bss 1                                               ; Energy unit
1007                                                                          ;
1008                                                                          ; * 0 = not fitted
1009                                                                          ;
1010                                                                          ; * Non-zero = fitted
1011                                                                          ;
1012                                                                          ; The actual value determines the refresh rate of our
1013                                                                          ; energy banks, as they refresh by ENGY+1 each time (so
1014                                                                          ; our ship's energy level goes up by 2 each time if we
1015                                                                          ; have an energy unit fitted, otherwise it goes up by 1)
1016               
1017               DKCMP:
1018 032C                 bss 1                                               ; Docking computer
1019                                                                          ;
1020                                                                          ; * 0 = not fitted
1021                                                                          ;
1022                                                                          ; * &FF = fitted
1023               
1024               GHYP:
1025 032D                 bss 1                                               ; Galactic hyperdrive
1026                                                                          ;
1027                                                                          ; * 0 = not fitted
1028                                                                          ;
1029                                                                          ; * &FF = fitted
1030               
1031               ESCP:
1032 032E                 bss 1                                               ; Escape pod
1033                                                                          ;
1034                                                                          ; * 0 = not fitted
1035                                                                          ;
1036                                                                          ; * &FF = fitted
1037               
1038 032F                 bss 4                                               ; These bytes appear to be unused
1039               
1040               NOMSL:
1041 0333                 bss 1                                               ; The number of missiles we have fitted (0-4)
1042               
1043               FIST:
1044 0334                 bss 1                                               ; Our legal status (FIST stands for "fugitive/innocent
1045                                                                          ; status"):
1046                                                                          ;
1047                                                                          ; * 0 = Clean
1048                                                                          ;
1049                                                                          ; * 1-49 = Offender
1050                                                                          ;
1051                                                                          ; * 50+ = Fugitive
1052                                                                          ;
1053                                                                          ; You get 64 points if you kill a cop, so that's a fast
1054                                                                          ; ticket to fugitive status
1055               
1056               AVL:
1057 0335                 bss 17                                              ; Market availability in the current system
1058                                                                          ;
1059                                                                          ; The available amount of market item X is stored in
1060                                                                          ; the X-th byte of AVL, so for example:
1061                                                                          ;
1062                                                                          ; * AVL contains the amount of food (item 0)
1063                                                                          ;
1064                                                                          ; * AVL+7 contains the amount of computers (item 7)
1065                                                                          ;
1066                                                                          ; See QQ23 for a list of market item numbers and their
1067                                                                          ; storage units, and the deep dive on "Market item
1068                                                                          ; prices and availability" for details of the algorithm
1069                                                                          ; used for calculating each item's availability
1070               
1071               QQ26:
1072 0346                 bss 1                                               ; A random value used to randomise market data
1073                                                                          ;
1074                                                                          ; This value is set to a new random number for each
1075                                                                          ; change of system, so we can add a random factor into
1076                                                                          ; the calculations for market prices (for details of how
1077                                                                          ; this is used, see the deep dive on "Market prices")
1078               
1079               TALLY:
1080 0347                 bss 2                                               ; Our combat rank
1081                                                                          ;
1082                                                                          ; The combat rank is stored as the number of kills, in a
1083                                                                          ; 16-bit number TALLY(1 0) - so the high byte is in
1084                                                                          ; TALLY+1 and the low byte in TALLY
1085                                                                          ;
1086                                                                          ; If the high byte in TALLY+1 is 0 then we have between
1087                                                                          ; 0 and 255 kills, so our rank is Harmless, Mostly
1088                                                                          ; Harmless, Poor, Average or Above Average, according to
1089                                                                          ; the value of the low byte in TALLY:
1090                                                                          ;
1091                                                                          ; Harmless        = %00000000 to %00000011 = 0 to 3
1092                                                                          ; Mostly Harmless = %00000100 to %00000111 = 4 to 7
1093                                                                          ; Poor            = %00001000 to %00001111 = 8 to 15
1094                                                                          ; Average         = %00010000 to %00011111 = 16 to 31
1095                                                                          ; Above Average   = %00100000 to %11111111 = 32 to 255
1096                                                                          ;
1097                                                                          ; If the high byte in TALLY+1 is non-zero then we are
1098                                                                          ; Competent, Dangerous, Deadly or Elite, according to
1099                                                                          ; the high byte in TALLY+1:
1100                                                                          ;
1101                                                                          ; Competent       = 1           = 256 to 511 kills
1102                                                                          ; Dangerous       = 2 to 9      = 512 to 2559 kills
1103                                                                          ; Deadly          = 10 to 24    = 2560 to 6399 kills
1104                                                                          ; Elite           = 25 and up   = 6400 kills and up
1105                                                                          ;
1106                                                                          ; You can see the rating calculation in the STATUS
1107                                                                          ; subroutine
1108               
1109               SVC:
1110 0349                 bss 1                                               ; The save count
1111                                                                          ;
1112                                                                          ; When a new commander is created, the save count gets
1113                                                                          ; set to 128. This value gets halved each time the
1114                                                                          ; commander file is saved, but it is otherwise unused.
1115                                                                          ; It is presumably part of the security system for the
1116                                                                          ; competition, possibly another flag to catch out
1117                                                                          ; entries with manually altered commander files
1118               
1119 034A                 bss 2                                               ; The commander file checksum
1120                                                                          ;
1121                                                                          ; These two bytes are reserved for the commander file
1122                                                                          ; checksum, so when the current commander block is
1123                                                                          ; copied from here to the last saved commander block at
1124                                                                          ; NA%, CHK and CHK2 get overwritten
1125               
1126               NT.:                                                       ; This sets the variable NT% to the size of the current
1127                      equ SVC + 2 - TP
1128                                                                          ; commander data block, which starts at TP and ends at
1129                                                                          ; SVC+2 (inclusive)
1130               
1131               SX:
1132 034C                 bss NOST + 1                                        ; This is where we store the x_hi coordinates for all
1133                                                                          ; the stardust particles
1134               
1135               SXL:
1136 035F                 bss NOST + 1                                        ; This is where we store the x_lo coordinates for all
1137                                                                          ; the stardust particles
1138               
1139                      ; PRINT "T% workspace from  ", ~T%, " to ", ~P%
1140               
1141               * ******************************************************************************
1142               *
1143               * ELITE RECURSIVE TEXT TOKEN FILE
1144               *
1145               * Produces the binary file WORDS9.bin that gets loaded by elite-loader.asm.
1146               *
1147               * The recursive token table is loaded at &1100 and is moved down to &0400 as
1148               * part of elite-loader.asm, so it ends up at &0400 to &07FF.
1149               *
1150               * ******************************************************************************
1151               
1152                      aorg CODE_WORDS.
1153               
1154               * ******************************************************************************
1155               *
1156               * Name: CHAR
1157               * Type: Macro
1158               * Category: Text
1159               * Summary: Macro definition for characters in the recursive token table
1160               * Deep dive: Printing text tokens
1161               *
1162               * ------------------------------------------------------------------------------
1163               *
1164               * The following macro is used when building the recursive token table:
1165               *
1166               * CHAR 'x'            Insert ASCII character "x"
1167               *
1168               * To include an apostrophe, use a backtick character, as in CHAR '`'.
1169               *
1170               * See the deep dive on "Printing text tokens" for details on how characters are
1171               * stored in the recursive token table.
1172               *
1173               * ------------------------------------------------------------------------------
1174               *
1175               * Arguments:
1176               *
1177               * 'x'                 The character to insert into the table
1178               *
1179               * ******************************************************************************
1180               
1181                      ; MACRO CHAR x
1182               
1183                      ; IF x = '`'                    ;
1184                      ; EQUB 39 EOR RE                ;
1185                      ; ELSE                          ;
1186                      ; EQUB x EOR RE                 ;
1187                      ; ENDIF                         ;
1188               
1189                      ; ENDMACRO
1190               
1191               * ******************************************************************************
1192               *
1193               * Name: TWOK
1194               * Type: Macro
1195               * Category: Text
1196               * Summary: Macro definition for two-letter tokens in the token table
1197               * Deep dive: Printing text tokens
1198               *
1199               * ------------------------------------------------------------------------------
1200               *
1201               * The following macro is used when building the recursive token table:
1202               *
1203               * TWOK 'x', 'y'       Insert two-letter token "xy"
1204               *
1205               * See the deep dive on "Printing text tokens" for details on how two-letter
1206               * tokens are stored in the recursive token table.
1207               *
1208               * ------------------------------------------------------------------------------
1209               *
1210               * Arguments:
1211               *
1212               * 'x'                 The first letter of the two-letter token to insert into
1213               * the table
1214               *
1215               * 'y'                 The second letter of the two-letter token to insert into
1216               * the table
1217               *
1218               * ******************************************************************************
1219               
1220                      ; MACRO TWOK t, k
1221               
1222                      ; IF t = 'A' AND k = 'L' : EQUB 128 EOR RE : ENDIF ;
1223                      ; IF t = 'L' AND k = 'E' : EQUB 129 EOR RE : ENDIF ;
1224                      ; IF t = 'X' AND k = 'E' : EQUB 130 EOR RE : ENDIF ;
1225                      ; IF t = 'G' AND k = 'E' : EQUB 131 EOR RE : ENDIF ;
1226                      ; IF t = 'Z' AND k = 'A' : EQUB 132 EOR RE : ENDIF ;
1227                      ; IF t = 'C' AND k = 'E' : EQUB 133 EOR RE : ENDIF ;
1228                      ; IF t = 'B' AND k = 'I' : EQUB 134 EOR RE : ENDIF ;
1229                      ; IF t = 'S' AND k = 'O' : EQUB 135 EOR RE : ENDIF ;
1230                      ; IF t = 'U' AND k = 'S' : EQUB 136 EOR RE : ENDIF ;
1231                      ; IF t = 'E' AND k = 'S' : EQUB 137 EOR RE : ENDIF ;
1232                      ; IF t = 'A' AND k = 'R' : EQUB 138 EOR RE : ENDIF ;
1233                      ; IF t = 'M' AND k = 'A' : EQUB 139 EOR RE : ENDIF ;
1234                      ; IF t = 'I' AND k = 'N' : EQUB 140 EOR RE : ENDIF ;
1235                      ; IF t = 'D' AND k = 'I' : EQUB 141 EOR RE : ENDIF ;
1236                      ; IF t = 'R' AND k = 'E' : EQUB 142 EOR RE : ENDIF ;
1237                      ; IF t = 'A' AND k = '?' : EQUB 143 EOR RE : ENDIF ;
1238                      ; IF t = 'E' AND k = 'R' : EQUB 144 EOR RE : ENDIF ;
1239                      ; IF t = 'A' AND k = 'T' : EQUB 145 EOR RE : ENDIF ;
1240                      ; IF t = 'E' AND k = 'N' : EQUB 146 EOR RE : ENDIF ;
1241                      ; IF t = 'B' AND k = 'E' : EQUB 147 EOR RE : ENDIF ;
1242                      ; IF t = 'R' AND k = 'A' : EQUB 148 EOR RE : ENDIF ;
1243                      ; IF t = 'L' AND k = 'A' : EQUB 149 EOR RE : ENDIF ;
1244                      ; IF t = 'V' AND k = 'E' : EQUB 150 EOR RE : ENDIF ;
1245                      ; IF t = 'T' AND k = 'I' : EQUB 151 EOR RE : ENDIF ;
1246                      ; IF t = 'E' AND k = 'D' : EQUB 152 EOR RE : ENDIF ;
1247                      ; IF t = 'O' AND k = 'R' : EQUB 153 EOR RE : ENDIF ;
1248                      ; IF t = 'Q' AND k = 'U' : EQUB 154 EOR RE : ENDIF ;
1249                      ; IF t = 'A' AND k = 'N' : EQUB 155 EOR RE : ENDIF ;
1250                      ; IF t = 'T' AND k = 'E' : EQUB 156 EOR RE : ENDIF ;
1251                      ; IF t = 'I' AND k = 'S' : EQUB 157 EOR RE : ENDIF ;
1252                      ; IF t = 'R' AND k = 'I' : EQUB 158 EOR RE : ENDIF ;
1253                      ; IF t = 'O' AND k = 'N' : EQUB 159 EOR RE : ENDIF ;
1254               
1255                      ; ENDMACRO
1256               
1257               * ******************************************************************************
1258               *
1259               * Name: CONT
1260               * Type: Macro
1261               * Category: Text
1262               * Summary: Macro definition for control codes in the recursive token table
1263               * Deep dive: Printing text tokens
1264               *
1265               * ------------------------------------------------------------------------------
1266               *
1267               * The following macro is used when building the recursive token table:
1268               *
1269               * CONT n              Insert control code token {n}
1270               *
1271               * See the deep dive on "Printing text tokens" for details on how characters are
1272               * stored in the recursive token table.
1273               *
1274               * ------------------------------------------------------------------------------
1275               *
1276               * Arguments:
1277               *
1278               * n                   The control code to insert into the table
1279               *
1280               * ******************************************************************************
1281               
1282                      ; MACRO CONT n
1283               
1284                      ; EQUB n EOR RE                 ;
1285               
1286                      ; ENDMACRO
1287               
1288               * ******************************************************************************
1289               *
1290               * Name: RTOK
1291               * Type: Macro
1292               * Category: Text
1293               * Summary: Macro definition for recursive tokens in the recursive token table
1294               * Deep dive: Printing text tokens
1295               *
1296               * ------------------------------------------------------------------------------
1297               *
1298               * The following macro is used when building the recursive token table:
1299               *
1300               * RTOK n              Insert recursive token [n]
1301               *
1302               * * Tokens 0-95 get stored as n + 160
1303               *
1304               * * Tokens 128-145 get stored as n - 114
1305               *
1306               * * Tokens 96-127 get stored as n
1307               *
1308               * See the deep dive on "Printing text tokens" for details on how recursive
1309               * tokens are stored in the recursive token table.
1310               *
1311               * ------------------------------------------------------------------------------
1312               *
1313               * Arguments:
1314               *
1315               * n                   The number of the recursive token to insert into the
1316               * table, in the range 0 to 145
1317               *
1318               * ******************************************************************************
1319               
1320                      ; MACRO RTOK n
1321               
1322                      ; IF n >= 0 AND n <= 95         ;
1323                      ; t = n + 160                   ;
1324                      ; ELIF n >= 128                 ;
1325                      ; t = n - 114                   ;
1326                      ; ELSE                          ;
1327                      ; t = n                         ;
1328                      ; ENDIF                         ;
1329               
1330                      ; EQUB t EOR RE                 ;
1331               
1332                      ; ENDMACRO
1333               
1334               * ******************************************************************************
1335               *
1336               * Name: QQ18
1337               * Type: Variable
1338               * Category: Text
1339               * Summary: The recursive token table for tokens 0-148
1340               * Deep dive: Printing text tokens
1341               *
1342               * ******************************************************************************
1343               
1344               QQ18:
1345                      .rtok 111                                           ; Token 0:      "FUEL SCOOPS ON {beep}"
     **** ****     > RTOK
0008 0400 4C              byte 111 ^ RE
                   < elite.a99
1346                      .rtok 131                                           ;
     **** ****     > RTOK
0006 0401   32            byte (131 - 114) ^ RE
                   < elite.a99
1347                      .cont 7                                             ; Encoded as:   "[111][131]{7}"
     **** ****     > CONT
0001 0402 24              byte 7 ^ RE
                   < elite.a99
1348 0403   00            byte >00
1349               
1350                      .char ' '                                           ; Token 1:      " CHART"
     **** ****     > CHAR
0004 0404 03              byte ' ' ^ RE
                   < elite.a99
1351                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0405   60            byte 'C' ^ RE
                   < elite.a99
1352                      .char 'H'                                           ; Encoded as:   " CH<138>T"
     **** ****     > CHAR
0004 0406 6B              byte 'H' ^ RE
                   < elite.a99
1353 0407   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1354                      .char 'T'
     **** ****     > CHAR
0004 0408 77              byte 'T' ^ RE
                   < elite.a99
1355 0409   00            byte >00
1356               
1357                      .char 'G'                                           ; Token 2:      "GOVERNMENT"
     **** ****     > CHAR
0004 040A 64              byte 'G' ^ RE
                   < elite.a99
1358                      .char 'O'                                           ;
     **** ****     > CHAR
0004 040B   6C            byte 'O' ^ RE
                   < elite.a99
1359 040C B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' Encoded as:   "GO<150>RNM<146>T"
1360                      .char 'R'
     **** ****     > CHAR
0004 040D   71            byte 'R' ^ RE
                   < elite.a99
1361                      .char 'N'
     **** ****     > CHAR
0004 040E 6D              byte 'N' ^ RE
                   < elite.a99
1362                      .char 'M'
     **** ****     > CHAR
0004 040F   6E            byte 'M' ^ RE
                   < elite.a99
1363 0410 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
1364                      .char 'T'
     **** ****     > CHAR
0004 0411   77            byte 'T' ^ RE
                   < elite.a99
1365 0412 00              byte >00
1366               
1367                      .char 'D'                                           ; Token 3:      "DATA ON {selected system name}"
     **** ****     > CHAR
0004 0413   67            byte 'D' ^ RE
                   < elite.a99
1368 0414 B2              byte 145 ^ RE                                       ; TWOK 'A', 'T'
1369                      .char 'A'                                           ; Encoded as:   "D<145>A[131]{3}"
     **** ****     > CHAR
0004 0415   62            byte 'A' ^ RE
                   < elite.a99
1370                      .rtok 131
     **** ****     > RTOK
0006 0416 32              byte (131 - 114) ^ RE
                   < elite.a99
1371                      .cont 3
     **** ****     > CONT
0001 0417   20            byte 3 ^ RE
                   < elite.a99
1372 0418 00              byte >00
1373               
1374 0419   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 4:      "INVENTORY{crlf}
1375 041A B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' "
1376                      .char 'N'                                           ;
     **** ****     > CHAR
0004 041B   6D            byte 'N' ^ RE
                   < elite.a99
1377                      .char 'T'                                           ; Encoded as:   "<140><150>NT<153>Y{13}"
     **** ****     > CHAR
0004 041C 77              byte 'T' ^ RE
                   < elite.a99
1378 041D   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1379                      .char 'Y'
     **** ****     > CHAR
0004 041E 7A              byte 'Y' ^ RE
                   < elite.a99
1380                      .cont 13
     **** ****     > CONT
0001 041F   2E            byte 13 ^ RE
                   < elite.a99
1381 0420 00              byte >00
1382               
1383                      .char 'S'                                           ; Token 5:      "SYSTEM"
     **** ****     > CHAR
0004 0421   70            byte 'S' ^ RE
                   < elite.a99
1384                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 0422 7A              byte 'Y' ^ RE
                   < elite.a99
1385                      .char 'S'                                           ; Encoded as:   "SYS<156>M"
     **** ****     > CHAR
0004 0423   70            byte 'S' ^ RE
                   < elite.a99
1386 0424 BF              byte 156 ^ RE                                       ; TWOK 'T', 'E' null
1387                      .char 'M'
     **** ****     > CHAR
0004 0425   6E            byte 'M' ^ RE
                   < elite.a99
1388 0426 00              byte >00
1389               
1390                      .char 'P'                                           ; Token 6:      "PRICE"
     **** ****     > CHAR
0004 0427   73            byte 'P' ^ RE
                   < elite.a99
1391 0428 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I'
1392 0429   A6            byte 133 ^ RE                                       ; TWOK 'C', 'E' Encoded as:   "P<158><133>"
1393 042A 00              byte >00
1394               
1395                      .cont 2                                             ; Token 7:      "{current system name} MARKET PRICES"
     **** ****     > CONT
0001 042B   21            byte 2 ^ RE
                   < elite.a99
1396                      .char ' '                                           ;
     **** ****     > CHAR
0004 042C 03              byte ' ' ^ RE
                   < elite.a99
1397 042D   A8            byte 139 ^ RE                                       ; TWOK 'M', 'A' Encoded as:   "{2} <139>RKET [6]S"
1398                      .char 'R'
     **** ****     > CHAR
0004 042E 71              byte 'R' ^ RE
                   < elite.a99
1399                      .char 'K'
     **** ****     > CHAR
0004 042F   68            byte 'K' ^ RE
                   < elite.a99
1400                      .char 'E'
     **** ****     > CHAR
0004 0430 66              byte 'E' ^ RE
                   < elite.a99
1401                      .char 'T'
     **** ****     > CHAR
0004 0431   77            byte 'T' ^ RE
                   < elite.a99
1402                      .char ' '
     **** ****     > CHAR
0004 0432 03              byte ' ' ^ RE
                   < elite.a99
1403                      .rtok 6
     **** ****     > RTOK
0003 0433   85            byte (6 + 160) ^ RE
                   < elite.a99
1404                      .char 'S'
     **** ****     > CHAR
0004 0434 70              byte 'S' ^ RE
                   < elite.a99
1405 0435   00            byte >00
1406               
1407 0436 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 8:      "INDUSTRIAL"
1408                      .char 'D'                                           ;
     **** ****     > CHAR
0004 0437   67            byte 'D' ^ RE
                   < elite.a99
1409 0438 AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' Encoded as:   "<140>D<136>T<158><128>"
1410                      .char 'T'
     **** ****     > CHAR
0004 0439   77            byte 'T' ^ RE
                   < elite.a99
1411 043A BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' null
1412 043B   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1413 043C 00              byte >00
1414               
1415                      .char 'A'                                           ; Token 9:      "AGRICULTURAL"
     **** ****     > CHAR
0004 043D   62            byte 'A' ^ RE
                   < elite.a99
1416                      .char 'G'                                           ;
     **** ****     > CHAR
0004 043E 64              byte 'G' ^ RE
                   < elite.a99
1417 043F   BD            byte 158 ^ RE                                       ; TWOK 'R', 'I' Encoded as:   "AG<158>CULTU<148>L"
1418                      .char 'C'
     **** ****     > CHAR
0004 0440 60              byte 'C' ^ RE
                   < elite.a99
1419                      .char 'U'
     **** ****     > CHAR
0004 0441   76            byte 'U' ^ RE
                   < elite.a99
1420                      .char 'L'
     **** ****     > CHAR
0004 0442 6F              byte 'L' ^ RE
                   < elite.a99
1421                      .char 'T'
     **** ****     > CHAR
0004 0443   77            byte 'T' ^ RE
                   < elite.a99
1422                      .char 'U'
     **** ****     > CHAR
0004 0444 76              byte 'U' ^ RE
                   < elite.a99
1423 0445   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' null
1424                      .char 'L'
     **** ****     > CHAR
0004 0446 6F              byte 'L' ^ RE
                   < elite.a99
1425 0447   00            byte >00
1426               
1427 0448 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' Token 10:     "RICH "
1428                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0449   60            byte 'C' ^ RE
                   < elite.a99
1429                      .char 'H'                                           ; Encoded as:   "<158>CH "
     **** ****     > CHAR
0004 044A 6B              byte 'H' ^ RE
                   < elite.a99
1430                      .char ' '
     **** ****     > CHAR
0004 044B   03            byte ' ' ^ RE
                   < elite.a99
1431 044C 00              byte >00
1432               
1433                      .char 'A'                                           ; Token 11:     "AVERAGE "
     **** ****     > CHAR
0004 044D   62            byte 'A' ^ RE
                   < elite.a99
1434 044E B5              byte 150 ^ RE                                       ; TWOK 'V', 'E'
1435 044F   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Encoded as:   "A<150><148><131> "
1436 0450 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' null
1437                      .char ' '
     **** ****     > CHAR
0004 0451   03            byte ' ' ^ RE
                   < elite.a99
1438 0452 00              byte >00
1439               
1440                      .char 'P'                                           ; Token 12:     "POOR "
     **** ****     > CHAR
0004 0453   73            byte 'P' ^ RE
                   < elite.a99
1441                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0454 6C              byte 'O' ^ RE
                   < elite.a99
1442 0455   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' Encoded as:   "PO<153> "
1443                      .char ' '
     **** ****     > CHAR
0004 0456 03              byte ' ' ^ RE
                   < elite.a99
1444 0457   00            byte >00
1445               
1446 0458 A8              byte 139 ^ RE                                       ; TWOK 'M', 'A' Token 13:     "MAINLY "
1447 0459   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
1448                      .char 'L'                                           ; Encoded as:   "<139><140>LY "
     **** ****     > CHAR
0004 045A 6F              byte 'L' ^ RE
                   < elite.a99
1449                      .char 'Y'
     **** ****     > CHAR
0004 045B   7A            byte 'Y' ^ RE
                   < elite.a99
1450                      .char ' '
     **** ****     > CHAR
0004 045C 03              byte ' ' ^ RE
                   < elite.a99
1451 045D   00            byte >00
1452               
1453                      .char 'U'                                           ; Token 14:     "UNIT"
     **** ****     > CHAR
0004 045E 76              byte 'U' ^ RE
                   < elite.a99
1454                      .char 'N'                                           ;
     **** ****     > CHAR
0004 045F   6D            byte 'N' ^ RE
                   < elite.a99
1455                      .char 'I'                                           ; Encoded as:   "UNIT"
     **** ****     > CHAR
0004 0460 6A              byte 'I' ^ RE
                   < elite.a99
1456                      .char 'T'
     **** ****     > CHAR
0004 0461   77            byte 'T' ^ RE
                   < elite.a99
1457 0462 00              byte >00
1458               
1459                      .char 'V'                                           ; Token 15:     "VIEW "
     **** ****     > CHAR
0004 0463   75            byte 'V' ^ RE
                   < elite.a99
1460                      .char 'I'                                           ;
     **** ****     > CHAR
0004 0464 6A              byte 'I' ^ RE
                   < elite.a99
1461                      .char 'E'                                           ; Encoded as:   "VIEW "
     **** ****     > CHAR
0004 0465   66            byte 'E' ^ RE
                   < elite.a99
1462                      .char 'W'
     **** ****     > CHAR
0004 0466 74              byte 'W' ^ RE
                   < elite.a99
1463                      .char ' '
     **** ****     > CHAR
0004 0467   03            byte ' ' ^ RE
                   < elite.a99
1464 0468 00              byte >00
1465               
1466 0469   B9            byte 154 ^ RE                                       ; TWOK 'Q', 'U' Token 16:     "QUANTITY"
1467 046A B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
1468 046B   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' Encoded as:   "<154><155><151>TY"
1469                      .char 'T'
     **** ****     > CHAR
0004 046C 77              byte 'T' ^ RE
                   < elite.a99
1470                      .char 'Y'
     **** ****     > CHAR
0004 046D   7A            byte 'Y' ^ RE
                   < elite.a99
1471 046E 00              byte >00
1472               
1473 046F   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Token 17:     "ANARCHY"
1474 0470 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1475                      .char 'C'                                           ; Encoded as:   "<155><138>CHY"
     **** ****     > CHAR
0004 0471   60            byte 'C' ^ RE
                   < elite.a99
1476                      .char 'H'
     **** ****     > CHAR
0004 0472 6B              byte 'H' ^ RE
                   < elite.a99
1477                      .char 'Y'
     **** ****     > CHAR
0004 0473   7A            byte 'Y' ^ RE
                   < elite.a99
1478 0474 00              byte >00
1479               
1480                      .char 'F'                                           ; Token 18:     "FEUDAL"
     **** ****     > CHAR
0004 0475   65            byte 'F' ^ RE
                   < elite.a99
1481                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0476 66              byte 'E' ^ RE
                   < elite.a99
1482                      .char 'U'                                           ; Encoded as:   "FEUD<128>"
     **** ****     > CHAR
0004 0477   76            byte 'U' ^ RE
                   < elite.a99
1483                      .char 'D'
     **** ****     > CHAR
0004 0478 67              byte 'D' ^ RE
                   < elite.a99
1484 0479   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1485 047A 00              byte >00
1486               
1487                      .char 'M'                                           ; Token 19:     "MULTI-GOVERNMENT"
     **** ****     > CHAR
0004 047B   6E            byte 'M' ^ RE
                   < elite.a99
1488                      .char 'U'                                           ;
     **** ****     > CHAR
0004 047C 76              byte 'U' ^ RE
                   < elite.a99
1489                      .char 'L'                                           ; Encoded as:   "MUL<151>-[2]"
     **** ****     > CHAR
0004 047D   6F            byte 'L' ^ RE
                   < elite.a99
1490 047E B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1491                      .char '-'
     **** ****     > CHAR
0004 047F   0E            byte '-' ^ RE
                   < elite.a99
1492                      .rtok 2
     **** ****     > RTOK
0003 0480 81              byte (2 + 160) ^ RE
                   < elite.a99
1493 0481   00            byte >00
1494               
1495 0482 AE              byte 141 ^ RE                                       ; TWOK 'D', 'I' Token 20:     "DICTATORSHIP"
1496                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0483   60            byte 'C' ^ RE
                   < elite.a99
1497                      .char 'T'                                           ; Encoded as:   "<141>CT<145><153>[25]"
     **** ****     > CHAR
0004 0484 77              byte 'T' ^ RE
                   < elite.a99
1498 0485   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1499 0486 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1500                      .rtok 25
     **** ****     > RTOK
0003 0487   9A            byte (25 + 160) ^ RE
                   < elite.a99
1501 0488 00              byte >00
1502               
1503                      .rtok 91                                            ; Token 21:     "COMMUNIST"
     **** ****     > RTOK
0003 0489   D8            byte (91 + 160) ^ RE
                   < elite.a99
1504                      .char 'M'                                           ;
     **** ****     > CHAR
0004 048A 6E              byte 'M' ^ RE
                   < elite.a99
1505                      .char 'U'                                           ; Encoded as:   "[91]MUN<157>T"
     **** ****     > CHAR
0004 048B   76            byte 'U' ^ RE
                   < elite.a99
1506                      .char 'N'
     **** ****     > CHAR
0004 048C 6D              byte 'N' ^ RE
                   < elite.a99
1507 048D   BE            byte 157 ^ RE                                       ; TWOK 'I', 'S' null
1508                      .char 'T'
     **** ****     > CHAR
0004 048E 77              byte 'T' ^ RE
                   < elite.a99
1509 048F   00            byte >00
1510               
1511                      .char 'C'                                           ; Token 22:     "CONFEDERACY"
     **** ****     > CHAR
0004 0490 60              byte 'C' ^ RE
                   < elite.a99
1512 0491   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N'
1513                      .char 'F'                                           ; Encoded as:   "C<159>F<152><144>ACY"
     **** ****     > CHAR
0004 0492 65              byte 'F' ^ RE
                   < elite.a99
1514 0493   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1515 0494 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1516                      .char 'A'
     **** ****     > CHAR
0004 0495   62            byte 'A' ^ RE
                   < elite.a99
1517                      .char 'C'
     **** ****     > CHAR
0004 0496 60              byte 'C' ^ RE
                   < elite.a99
1518                      .char 'Y'
     **** ****     > CHAR
0004 0497   7A            byte 'Y' ^ RE
                   < elite.a99
1519 0498 00              byte >00
1520               
1521                      .char 'D'                                           ; Token 23:     "DEMOCRACY"
     **** ****     > CHAR
0004 0499   67            byte 'D' ^ RE
                   < elite.a99
1522                      .char 'E'                                           ;
     **** ****     > CHAR
0004 049A 66              byte 'E' ^ RE
                   < elite.a99
1523                      .char 'M'                                           ; Encoded as:   "DEMOC<148>CY"
     **** ****     > CHAR
0004 049B   6E            byte 'M' ^ RE
                   < elite.a99
1524                      .char 'O'
     **** ****     > CHAR
0004 049C 6C              byte 'O' ^ RE
                   < elite.a99
1525                      .char 'C'
     **** ****     > CHAR
0004 049D   60            byte 'C' ^ RE
                   < elite.a99
1526 049E B7              byte 148 ^ RE                                       ; TWOK 'R', 'A' null
1527                      .char 'C'
     **** ****     > CHAR
0004 049F   60            byte 'C' ^ RE
                   < elite.a99
1528                      .char 'Y'
     **** ****     > CHAR
0004 04A0 7A              byte 'Y' ^ RE
                   < elite.a99
1529 04A1   00            byte >00
1530               
1531                      .char 'C'                                           ; Token 24:     "CORPORATE STATE"
     **** ****     > CHAR
0004 04A2 60              byte 'C' ^ RE
                   < elite.a99
1532 04A3   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R'
1533                      .char 'P'                                           ; Encoded as:   "C<153>P<153><145>E [43]<145>E"
     **** ****     > CHAR
0004 04A4 73              byte 'P' ^ RE
                   < elite.a99
1534 04A5   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1535 04A6 B2              byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1536                      .char 'E'
     **** ****     > CHAR
0004 04A7   66            byte 'E' ^ RE
                   < elite.a99
1537                      .char ' '
     **** ****     > CHAR
0004 04A8 03              byte ' ' ^ RE
                   < elite.a99
1538                      .rtok 43
     **** ****     > RTOK
0003 04A9   E8            byte (43 + 160) ^ RE
                   < elite.a99
1539 04AA B2              byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1540                      .char 'E'
     **** ****     > CHAR
0004 04AB   66            byte 'E' ^ RE
                   < elite.a99
1541 04AC 00              byte >00
1542               
1543                      .char 'S'                                           ; Token 25:     "SHIP"
     **** ****     > CHAR
0004 04AD   70            byte 'S' ^ RE
                   < elite.a99
1544                      .char 'H'                                           ;
     **** ****     > CHAR
0004 04AE 6B              byte 'H' ^ RE
                   < elite.a99
1545                      .char 'I'                                           ; Encoded as:   "SHIP"
     **** ****     > CHAR
0004 04AF   6A            byte 'I' ^ RE
                   < elite.a99
1546                      .char 'P'
     **** ****     > CHAR
0004 04B0 73              byte 'P' ^ RE
                   < elite.a99
1547 04B1   00            byte >00
1548               
1549                      .char 'P'                                           ; Token 26:     "PRODUCT"
     **** ****     > CHAR
0004 04B2 73              byte 'P' ^ RE
                   < elite.a99
1550                      .char 'R'                                           ;
     **** ****     > CHAR
0004 04B3   71            byte 'R' ^ RE
                   < elite.a99
1551                      .char 'O'                                           ; Encoded as:   "PRODUCT"
     **** ****     > CHAR
0004 04B4 6C              byte 'O' ^ RE
                   < elite.a99
1552                      .char 'D'
     **** ****     > CHAR
0004 04B5   67            byte 'D' ^ RE
                   < elite.a99
1553                      .char 'U'
     **** ****     > CHAR
0004 04B6 76              byte 'U' ^ RE
                   < elite.a99
1554                      .char 'C'
     **** ****     > CHAR
0004 04B7   60            byte 'C' ^ RE
                   < elite.a99
1555                      .char 'T'
     **** ****     > CHAR
0004 04B8 77              byte 'T' ^ RE
                   < elite.a99
1556 04B9   00            byte >00
1557               
1558                      .char ' '                                           ; Token 27:     " LASER"
     **** ****     > CHAR
0004 04BA 03              byte ' ' ^ RE
                   < elite.a99
1559 04BB   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1560                      .char 'S'                                           ; Encoded as:   " <149>S<144>"
     **** ****     > CHAR
0004 04BC 70              byte 'S' ^ RE
                   < elite.a99
1561 04BD   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1562 04BE 00              byte >00
1563               
1564                      .char 'H'                                           ; Token 28:     "HUMAN COLONIAL"
     **** ****     > CHAR
0004 04BF   6B            byte 'H' ^ RE
                   < elite.a99
1565                      .char 'U'                                           ;
     **** ****     > CHAR
0004 04C0 76              byte 'U' ^ RE
                   < elite.a99
1566                      .char 'M'                                           ; Encoded as:   "HUM<155> COL<159>I<128>"
     **** ****     > CHAR
0004 04C1   6E            byte 'M' ^ RE
                   < elite.a99
1567 04C2 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N' null
1568                      .char ' '
     **** ****     > CHAR
0004 04C3   03            byte ' ' ^ RE
                   < elite.a99
1569                      .char 'C'
     **** ****     > CHAR
0004 04C4 60              byte 'C' ^ RE
                   < elite.a99
1570                      .char 'O'
     **** ****     > CHAR
0004 04C5   6C            byte 'O' ^ RE
                   < elite.a99
1571                      .char 'L'
     **** ****     > CHAR
0004 04C6 6F              byte 'L' ^ RE
                   < elite.a99
1572 04C7   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1573                      .char 'I'
     **** ****     > CHAR
0004 04C8 6A              byte 'I' ^ RE
                   < elite.a99
1574 04C9   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1575 04CA 00              byte >00
1576               
1577                      .char 'H'                                           ; Token 29:     "HYPERSPACE "
     **** ****     > CHAR
0004 04CB   6B            byte 'H' ^ RE
                   < elite.a99
1578                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 04CC 7A              byte 'Y' ^ RE
                   < elite.a99
1579                      .char 'P'                                           ; Encoded as:   "HYP<144>SPA<133> "
     **** ****     > CHAR
0004 04CD   73            byte 'P' ^ RE
                   < elite.a99
1580 04CE B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1581                      .char 'S'
     **** ****     > CHAR
0004 04CF   70            byte 'S' ^ RE
                   < elite.a99
1582                      .char 'P'
     **** ****     > CHAR
0004 04D0 73              byte 'P' ^ RE
                   < elite.a99
1583                      .char 'A'
     **** ****     > CHAR
0004 04D1   62            byte 'A' ^ RE
                   < elite.a99
1584 04D2 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1585                      .char ' '
     **** ****     > CHAR
0004 04D3   03            byte ' ' ^ RE
                   < elite.a99
1586 04D4 00              byte >00
1587               
1588                      .char 'S'                                           ; Token 30:     "SHORT RANGE CHART"
     **** ****     > CHAR
0004 04D5   70            byte 'S' ^ RE
                   < elite.a99
1589                      .char 'H'                                           ;
     **** ****     > CHAR
0004 04D6 6B              byte 'H' ^ RE
                   < elite.a99
1590 04D7   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' Encoded as:   "SH<153>T [42][1]"
1591                      .char 'T'
     **** ****     > CHAR
0004 04D8 77              byte 'T' ^ RE
                   < elite.a99
1592                      .char ' '
     **** ****     > CHAR
0004 04D9   03            byte ' ' ^ RE
                   < elite.a99
1593                      .rtok 42
     **** ****     > RTOK
0003 04DA E9              byte (42 + 160) ^ RE
                   < elite.a99
1594                      .rtok 1
     **** ****     > RTOK
0003 04DB   82            byte (1 + 160) ^ RE
                   < elite.a99
1595 04DC 00              byte >00
1596               
1597 04DD   AE            byte 141 ^ RE                                       ; TWOK 'D', 'I' Token 31:     "DISTANCE"
1598                      .rtok 43                                            ;
     **** ****     > RTOK
0003 04DE E8              byte (43 + 160) ^ RE
                   < elite.a99
1599 04DF   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "<141>[43]<155><133>"
1600 04E0 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1601 04E1   00            byte >00
1602               
1603                      .char 'P'                                           ; Token 32:     "POPULATION"
     **** ****     > CHAR
0004 04E2 73              byte 'P' ^ RE
                   < elite.a99
1604                      .char 'O'                                           ;
     **** ****     > CHAR
0004 04E3   6C            byte 'O' ^ RE
                   < elite.a99
1605                      .char 'P'                                           ; Encoded as:   "POPUL<145>I<159>"
     **** ****     > CHAR
0004 04E4 73              byte 'P' ^ RE
                   < elite.a99
1606                      .char 'U'
     **** ****     > CHAR
0004 04E5   76            byte 'U' ^ RE
                   < elite.a99
1607                      .char 'L'
     **** ****     > CHAR
0004 04E6 6F              byte 'L' ^ RE
                   < elite.a99
1608 04E7   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1609                      .char 'I'
     **** ****     > CHAR
0004 04E8 6A              byte 'I' ^ RE
                   < elite.a99
1610 04E9   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1611 04EA 00              byte >00
1612               
1613                      .char 'G'                                           ; Token 33:     "GROSS PRODUCTIVITY"
     **** ****     > CHAR
0004 04EB   64            byte 'G' ^ RE
                   < elite.a99
1614                      .char 'R'                                           ;
     **** ****     > CHAR
0004 04EC 71              byte 'R' ^ RE
                   < elite.a99
1615                      .char 'O'                                           ; Encoded as:   "GROSS [26]IVITY"
     **** ****     > CHAR
0004 04ED   6C            byte 'O' ^ RE
                   < elite.a99
1616                      .char 'S'
     **** ****     > CHAR
0004 04EE 70              byte 'S' ^ RE
                   < elite.a99
1617                      .char 'S'
     **** ****     > CHAR
0004 04EF   70            byte 'S' ^ RE
                   < elite.a99
1618                      .char ' '
     **** ****     > CHAR
0004 04F0 03              byte ' ' ^ RE
                   < elite.a99
1619                      .rtok 26
     **** ****     > RTOK
0003 04F1   99            byte (26 + 160) ^ RE
                   < elite.a99
1620                      .char 'I'
     **** ****     > CHAR
0004 04F2 6A              byte 'I' ^ RE
                   < elite.a99
1621                      .char 'V'
     **** ****     > CHAR
0004 04F3   75            byte 'V' ^ RE
                   < elite.a99
1622                      .char 'I'
     **** ****     > CHAR
0004 04F4 6A              byte 'I' ^ RE
                   < elite.a99
1623                      .char 'T'
     **** ****     > CHAR
0004 04F5   77            byte 'T' ^ RE
                   < elite.a99
1624                      .char 'Y'
     **** ****     > CHAR
0004 04F6 7A              byte 'Y' ^ RE
                   < elite.a99
1625 04F7   00            byte >00
1626               
1627                      .char 'E'                                           ; Token 34:     "ECONOMY"
     **** ****     > CHAR
0004 04F8 66              byte 'E' ^ RE
                   < elite.a99
1628                      .char 'C'                                           ;
     **** ****     > CHAR
0004 04F9   60            byte 'C' ^ RE
                   < elite.a99
1629 04FA BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' Encoded as:   "EC<159>OMY"
1630                      .char 'O'
     **** ****     > CHAR
0004 04FB   6C            byte 'O' ^ RE
                   < elite.a99
1631                      .char 'M'
     **** ****     > CHAR
0004 04FC 6E              byte 'M' ^ RE
                   < elite.a99
1632                      .char 'Y'
     **** ****     > CHAR
0004 04FD   7A            byte 'Y' ^ RE
                   < elite.a99
1633 04FE 00              byte >00
1634               
1635                      .char ' '                                           ; Token 35:     " LIGHT YEARS"
     **** ****     > CHAR
0004 04FF   03            byte ' ' ^ RE
                   < elite.a99
1636                      .char 'L'                                           ;
     **** ****     > CHAR
0004 0500 6F              byte 'L' ^ RE
                   < elite.a99
1637                      .char 'I'                                           ; Encoded as:   " LIGHT YE<138>S"
     **** ****     > CHAR
0004 0501   6A            byte 'I' ^ RE
                   < elite.a99
1638                      .char 'G'
     **** ****     > CHAR
0004 0502 64              byte 'G' ^ RE
                   < elite.a99
1639                      .char 'H'
     **** ****     > CHAR
0004 0503   6B            byte 'H' ^ RE
                   < elite.a99
1640                      .char 'T'
     **** ****     > CHAR
0004 0504 77              byte 'T' ^ RE
                   < elite.a99
1641                      .char ' '
     **** ****     > CHAR
0004 0505   03            byte ' ' ^ RE
                   < elite.a99
1642                      .char 'Y'
     **** ****     > CHAR
0004 0506 7A              byte 'Y' ^ RE
                   < elite.a99
1643                      .char 'E'
     **** ****     > CHAR
0004 0507   66            byte 'E' ^ RE
                   < elite.a99
1644 0508 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1645                      .char 'S'
     **** ****     > CHAR
0004 0509   70            byte 'S' ^ RE
                   < elite.a99
1646 050A 00              byte >00
1647               
1648 050B   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E' Token 36:     "TECH.LEVEL"
1649                      .char 'C'                                           ;
     **** ****     > CHAR
0004 050C 60              byte 'C' ^ RE
                   < elite.a99
1650                      .char 'H'                                           ; Encoded as:   "<156>CH.<129><150>L"
     **** ****     > CHAR
0004 050D   6B            byte 'H' ^ RE
                   < elite.a99
1651                      .char '.'
     **** ****     > CHAR
0004 050E 0D              byte '.' ^ RE
                   < elite.a99
1652 050F   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
1653 0510 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
1654                      .char 'L'
     **** ****     > CHAR
0004 0511   6F            byte 'L' ^ RE
                   < elite.a99
1655 0512 00              byte >00
1656               
1657                      .char 'C'                                           ; Token 37:     "CASH"
     **** ****     > CHAR
0004 0513   60            byte 'C' ^ RE
                   < elite.a99
1658                      .char 'A'                                           ;
     **** ****     > CHAR
0004 0514 62              byte 'A' ^ RE
                   < elite.a99
1659                      .char 'S'                                           ; Encoded as:   "CASH"
     **** ****     > CHAR
0004 0515   70            byte 'S' ^ RE
                   < elite.a99
1660                      .char 'H'
     **** ****     > CHAR
0004 0516 6B              byte 'H' ^ RE
                   < elite.a99
1661 0517   00            byte >00
1662               
1663                      .char ' '                                           ; Token 38:     " BILLION"
     **** ****     > CHAR
0004 0518 03              byte ' ' ^ RE
                   < elite.a99
1664 0519   A5            byte 134 ^ RE                                       ; TWOK 'B', 'I'
1665                      .rtok 118                                           ; Encoded as:   " <134>[118]I<159>"
     **** ****     > RTOK
0008 051A 55              byte 118 ^ RE
                   < elite.a99
1666                      .char 'I'
     **** ****     > CHAR
0004 051B   6A            byte 'I' ^ RE
                   < elite.a99
1667 051C BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1668 051D   00            byte >00
1669               
1670                      .rtok 122                                           ; Token 39:     "GALACTIC CHART{galaxy number}"
     **** ****     > RTOK
0008 051E 59              byte 122 ^ RE
                   < elite.a99
1671                      .rtok 1                                             ;
     **** ****     > RTOK
0003 051F   82            byte (1 + 160) ^ RE
                   < elite.a99
1672                      .cont 1                                             ; Encoded as:   "[122][1]{1}"
     **** ****     > CONT
0001 0520 22              byte 1 ^ RE
                   < elite.a99
1673 0521   00            byte >00
1674               
1675                      .char 'T'                                           ; Token 40:     "TARGET LOST"
     **** ****     > CHAR
0004 0522 77              byte 'T' ^ RE
                   < elite.a99
1676 0523   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R'
1677 0524 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "T<138><131>T LO[43]"
1678                      .char 'T'
     **** ****     > CHAR
0004 0525   77            byte 'T' ^ RE
                   < elite.a99
1679                      .char ' '
     **** ****     > CHAR
0004 0526 03              byte ' ' ^ RE
                   < elite.a99
1680                      .char 'L'
     **** ****     > CHAR
0004 0527   6F            byte 'L' ^ RE
                   < elite.a99
1681                      .char 'O'
     **** ****     > CHAR
0004 0528 6C              byte 'O' ^ RE
                   < elite.a99
1682                      .rtok 43
     **** ****     > RTOK
0003 0529   E8            byte (43 + 160) ^ RE
                   < elite.a99
1683 052A 00              byte >00
1684               
1685                      .rtok 106                                           ; Token 41:     "MISSILE JAMMED"
     **** ****     > RTOK
0008 052B   49            byte 106 ^ RE
                   < elite.a99
1686                      .char ' '                                           ;
     **** ****     > CHAR
0004 052C 03              byte ' ' ^ RE
                   < elite.a99
1687                      .char 'J'                                           ; Encoded as:   "[106] JAMM<152>"
     **** ****     > CHAR
0004 052D   69            byte 'J' ^ RE
                   < elite.a99
1688                      .char 'A'
     **** ****     > CHAR
0004 052E 62              byte 'A' ^ RE
                   < elite.a99
1689                      .char 'M'
     **** ****     > CHAR
0004 052F   6E            byte 'M' ^ RE
                   < elite.a99
1690                      .char 'M'
     **** ****     > CHAR
0004 0530 6E              byte 'M' ^ RE
                   < elite.a99
1691 0531   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1692 0532 00              byte >00
1693               
1694                      .char 'R'                                           ; Token 42:     "RANGE"
     **** ****     > CHAR
0004 0533   71            byte 'R' ^ RE
                   < elite.a99
1695 0534 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
1696 0535   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "R<155><131>"
1697 0536 00              byte >00
1698               
1699                      .char 'S'                                           ; Token 43:     "ST"
     **** ****     > CHAR
0004 0537   70            byte 'S' ^ RE
                   < elite.a99
1700                      .char 'T'                                           ;
     **** ****     > CHAR
0004 0538 77              byte 'T' ^ RE
                   < elite.a99
1701 0539   00            byte >00                                            ; Encoded as:   "ST"
1702               
1703                      .rtok 16                                            ; Token 44:     "QUANTITY OF "
     **** ****     > RTOK
0003 053A 93              byte (16 + 160) ^ RE
                   < elite.a99
1704                      .char ' '                                           ;
     **** ****     > CHAR
0004 053B   03            byte ' ' ^ RE
                   < elite.a99
1705                      .char 'O'                                           ; Encoded as:   "[16] OF "
     **** ****     > CHAR
0004 053C 6C              byte 'O' ^ RE
                   < elite.a99
1706                      .char 'F'
     **** ****     > CHAR
0004 053D   65            byte 'F' ^ RE
                   < elite.a99
1707                      .char ' '
     **** ****     > CHAR
0004 053E 03              byte ' ' ^ RE
                   < elite.a99
1708 053F   00            byte >00
1709               
1710                      .char 'S'                                           ; Token 45:     "SELL"
     **** ****     > CHAR
0004 0540 70              byte 'S' ^ RE
                   < elite.a99
1711                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0541   66            byte 'E' ^ RE
                   < elite.a99
1712                      .rtok 118                                           ; Encoded as:   "SE[118]"
     **** ****     > RTOK
0008 0542 55              byte 118 ^ RE
                   < elite.a99
1713 0543   00            byte >00
1714               
1715                      .char ' '                                           ; Token 46:     " CARGO{sentence case}"
     **** ****     > CHAR
0004 0544 03              byte ' ' ^ RE
                   < elite.a99
1716                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0545   60            byte 'C' ^ RE
                   < elite.a99
1717 0546 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R' Encoded as:   " C<138>GO{6}"
1718                      .char 'G'
     **** ****     > CHAR
0004 0547   64            byte 'G' ^ RE
                   < elite.a99
1719                      .char 'O'
     **** ****     > CHAR
0004 0548 6C              byte 'O' ^ RE
                   < elite.a99
1720                      .cont 6
     **** ****     > CONT
0001 0549   25            byte 6 ^ RE
                   < elite.a99
1721 054A 00              byte >00
1722               
1723                      .char 'E'                                           ; Token 47:     "EQUIP"
     **** ****     > CHAR
0004 054B   66            byte 'E' ^ RE
                   < elite.a99
1724 054C B9              byte 154 ^ RE                                       ; TWOK 'Q', 'U'
1725                      .char 'I'                                           ; Encoded as:   "E<154>IP"
     **** ****     > CHAR
0004 054D   6A            byte 'I' ^ RE
                   < elite.a99
1726                      .char 'P'
     **** ****     > CHAR
0004 054E 73              byte 'P' ^ RE
                   < elite.a99
1727 054F   00            byte >00
1728               
1729                      .char 'F'                                           ; Token 48:     "FOOD"
     **** ****     > CHAR
0004 0550 65              byte 'F' ^ RE
                   < elite.a99
1730                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0551   6C            byte 'O' ^ RE
                   < elite.a99
1731                      .char 'O'                                           ; Encoded as:   "FOOD"
     **** ****     > CHAR
0004 0552 6C              byte 'O' ^ RE
                   < elite.a99
1732                      .char 'D'
     **** ****     > CHAR
0004 0553   67            byte 'D' ^ RE
                   < elite.a99
1733 0554 00              byte >00
1734               
1735 0555   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E' Token 49:     "TEXTILES"
1736                      .char 'X'                                           ;
     **** ****     > CHAR
0004 0556 7B              byte 'X' ^ RE
                   < elite.a99
1737 0557   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' Encoded as:   "<156>X<151>L<137>"
1738                      .char 'L'
     **** ****     > CHAR
0004 0558 6F              byte 'L' ^ RE
                   < elite.a99
1739 0559   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1740 055A 00              byte >00
1741               
1742 055B   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Token 50:     "RADIOACTIVES"
1743 055C AE              byte 141 ^ RE                                       ; TWOK 'D', 'I'
1744                      .char 'O'                                           ; Encoded as:   "<148><141>OAC<151><150>S"
     **** ****     > CHAR
0004 055D   6C            byte 'O' ^ RE
                   < elite.a99
1745                      .char 'A'
     **** ****     > CHAR
0004 055E 62              byte 'A' ^ RE
                   < elite.a99
1746                      .char 'C'
     **** ****     > CHAR
0004 055F   60            byte 'C' ^ RE
                   < elite.a99
1747 0560 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1748 0561   B5            byte 150 ^ RE                                       ; TWOK 'V', 'E' null
1749                      .char 'S'
     **** ****     > CHAR
0004 0562 70              byte 'S' ^ RE
                   < elite.a99
1750 0563   00            byte >00
1751               
1752                      .char 'S'                                           ; Token 51:     "SLAVES"
     **** ****     > CHAR
0004 0564 70              byte 'S' ^ RE
                   < elite.a99
1753 0565   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1754 0566 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' Encoded as:   "S<149><150>S"
1755                      .char 'S'
     **** ****     > CHAR
0004 0567   70            byte 'S' ^ RE
                   < elite.a99
1756 0568 00              byte >00
1757               
1758                      .char 'L'                                           ; Token 52:     "LIQUOR/WINES"
     **** ****     > CHAR
0004 0569   6F            byte 'L' ^ RE
                   < elite.a99
1759                      .char 'I'                                           ;
     **** ****     > CHAR
0004 056A 6A              byte 'I' ^ RE
                   < elite.a99
1760 056B   B9            byte 154 ^ RE                                       ; TWOK 'Q', 'U' Encoded as:   "LI<154><153>/W<140><137>"
1761 056C BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1762                      .char '/'
     **** ****     > CHAR
0004 056D   0C            byte '/' ^ RE
                   < elite.a99
1763                      .char 'W'
     **** ****     > CHAR
0004 056E 74              byte 'W' ^ RE
                   < elite.a99
1764 056F   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1765 0570 AA              byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1766 0571   00            byte >00
1767               
1768                      .char 'L'                                           ; Token 53:     "LUXURIES"
     **** ****     > CHAR
0004 0572 6F              byte 'L' ^ RE
                   < elite.a99
1769                      .char 'U'                                           ;
     **** ****     > CHAR
0004 0573   76            byte 'U' ^ RE
                   < elite.a99
1770                      .char 'X'                                           ; Encoded as:   "LUXU<158><137>"
     **** ****     > CHAR
0004 0574 7B              byte 'X' ^ RE
                   < elite.a99
1771                      .char 'U'
     **** ****     > CHAR
0004 0575   76            byte 'U' ^ RE
                   < elite.a99
1772 0576 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' null
1773 0577   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1774 0578 00              byte >00
1775               
1776                      .char 'N'                                           ; Token 54:     "NARCOTICS"
     **** ****     > CHAR
0004 0579   6D            byte 'N' ^ RE
                   < elite.a99
1777 057A A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1778                      .char 'C'                                           ; Encoded as:   "N<138>CO<151>CS"
     **** ****     > CHAR
0004 057B   60            byte 'C' ^ RE
                   < elite.a99
1779                      .char 'O'
     **** ****     > CHAR
0004 057C 6C              byte 'O' ^ RE
                   < elite.a99
1780 057D   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1781                      .char 'C'
     **** ****     > CHAR
0004 057E 60              byte 'C' ^ RE
                   < elite.a99
1782                      .char 'S'
     **** ****     > CHAR
0004 057F   70            byte 'S' ^ RE
                   < elite.a99
1783 0580 00              byte >00
1784               
1785                      .rtok 91                                            ; Token 55:     "COMPUTERS"
     **** ****     > RTOK
0003 0581   D8            byte (91 + 160) ^ RE
                   < elite.a99
1786                      .char 'P'                                           ;
     **** ****     > CHAR
0004 0582 73              byte 'P' ^ RE
                   < elite.a99
1787                      .char 'U'                                           ; Encoded as:   "[91]PUT<144>S"
     **** ****     > CHAR
0004 0583   76            byte 'U' ^ RE
                   < elite.a99
1788                      .char 'T'
     **** ****     > CHAR
0004 0584 77              byte 'T' ^ RE
                   < elite.a99
1789 0585   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1790                      .char 'S'
     **** ****     > CHAR
0004 0586 70              byte 'S' ^ RE
                   < elite.a99
1791 0587   00            byte >00
1792               
1793 0588 A8              byte 139 ^ RE                                       ; TWOK 'M', 'A' Token 56:     "MACHINERY"
1794                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0589   60            byte 'C' ^ RE
                   < elite.a99
1795                      .char 'H'                                           ; Encoded as:   "<139>CH<140><144>Y"
     **** ****     > CHAR
0004 058A 6B              byte 'H' ^ RE
                   < elite.a99
1796 058B   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1797 058C B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1798                      .char 'Y'
     **** ****     > CHAR
0004 058D   7A            byte 'Y' ^ RE
                   < elite.a99
1799 058E 00              byte >00
1800               
1801                      .rtok 117                                           ; Token 57:     "ALLOYS"
     **** ****     > RTOK
0008 058F   56            byte 117 ^ RE
                   < elite.a99
1802                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0590 6C              byte 'O' ^ RE
                   < elite.a99
1803                      .char 'Y'                                           ; Encoded as:   "[117]OYS"
     **** ****     > CHAR
0004 0591   7A            byte 'Y' ^ RE
                   < elite.a99
1804                      .char 'S'
     **** ****     > CHAR
0004 0592 70              byte 'S' ^ RE
                   < elite.a99
1805 0593   00            byte >00
1806               
1807                      .char 'F'                                           ; Token 58:     "FIREARMS"
     **** ****     > CHAR
0004 0594 65              byte 'F' ^ RE
                   < elite.a99
1808                      .char 'I'                                           ;
     **** ****     > CHAR
0004 0595   6A            byte 'I' ^ RE
                   < elite.a99
1809 0596 AD              byte 142 ^ RE                                       ; TWOK 'R', 'E' Encoded as:   "FI<142><138>MS"
1810 0597   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1811                      .char 'M'
     **** ****     > CHAR
0004 0598 6E              byte 'M' ^ RE
                   < elite.a99
1812                      .char 'S'
     **** ****     > CHAR
0004 0599   70            byte 'S' ^ RE
                   < elite.a99
1813 059A 00              byte >00
1814               
1815                      .char 'F'                                           ; Token 59:     "FURS"
     **** ****     > CHAR
0004 059B   65            byte 'F' ^ RE
                   < elite.a99
1816                      .char 'U'                                           ;
     **** ****     > CHAR
0004 059C 76              byte 'U' ^ RE
                   < elite.a99
1817                      .char 'R'                                           ; Encoded as:   "FURS"
     **** ****     > CHAR
0004 059D   71            byte 'R' ^ RE
                   < elite.a99
1818                      .char 'S'
     **** ****     > CHAR
0004 059E 70              byte 'S' ^ RE
                   < elite.a99
1819 059F   00            byte >00
1820               
1821                      .char 'M'                                           ; Token 60:     "MINERALS"
     **** ****     > CHAR
0004 05A0 6E              byte 'M' ^ RE
                   < elite.a99
1822 05A1   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
1823 05A2 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' Encoded as:   "M<140><144><128>S"
1824 05A3   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1825                      .char 'S'
     **** ****     > CHAR
0004 05A4 70              byte 'S' ^ RE
                   < elite.a99
1826 05A5   00            byte >00
1827               
1828                      .char 'G'                                           ; Token 61:     "GOLD"
     **** ****     > CHAR
0004 05A6 64              byte 'G' ^ RE
                   < elite.a99
1829                      .char 'O'                                           ;
     **** ****     > CHAR
0004 05A7   6C            byte 'O' ^ RE
                   < elite.a99
1830                      .char 'L'                                           ; Encoded as:   "GOLD"
     **** ****     > CHAR
0004 05A8 6F              byte 'L' ^ RE
                   < elite.a99
1831                      .char 'D'
     **** ****     > CHAR
0004 05A9   67            byte 'D' ^ RE
                   < elite.a99
1832 05AA 00              byte >00
1833               
1834                      .char 'P'                                           ; Token 62:     "PLATINUM"
     **** ****     > CHAR
0004 05AB   73            byte 'P' ^ RE
                   < elite.a99
1835                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05AC 6F              byte 'L' ^ RE
                   < elite.a99
1836 05AD   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' Encoded as:   "PL<145><140>UM"
1837 05AE AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1838                      .char 'U'
     **** ****     > CHAR
0004 05AF   76            byte 'U' ^ RE
                   < elite.a99
1839                      .char 'M'
     **** ****     > CHAR
0004 05B0 6E              byte 'M' ^ RE
                   < elite.a99
1840 05B1   00            byte >00
1841               
1842 05B2 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' Token 63:     "GEM-STONES"
1843                      .char 'M'                                           ;
     **** ****     > CHAR
0004 05B3   6E            byte 'M' ^ RE
                   < elite.a99
1844                      .char '-'                                           ; Encoded as:   "<131>M-[43]<159><137>"
     **** ****     > CHAR
0004 05B4 0E              byte '-' ^ RE
                   < elite.a99
1845                      .rtok 43
     **** ****     > RTOK
0003 05B5   E8            byte (43 + 160) ^ RE
                   < elite.a99
1846 05B6 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1847 05B7   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1848 05B8 00              byte >00
1849               
1850 05B9   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' Token 64:     "ALIEN ITEMS"
1851                      .char 'I'                                           ;
     **** ****     > CHAR
0004 05BA 6A              byte 'I' ^ RE
                   < elite.a99
1852 05BB   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' Encoded as:   "<128>I<146> [127]S"
1853                      .char ' '
     **** ****     > CHAR
0004 05BC 03              byte ' ' ^ RE
                   < elite.a99
1854                      .rtok 127
     **** ****     > RTOK
0008 05BD   5C            byte 127 ^ RE
                   < elite.a99
1855                      .char 'S'
     **** ****     > CHAR
0004 05BE 70              byte 'S' ^ RE
                   < elite.a99
1856 05BF   00            byte >00
1857               
1858                      .char '('                                           ; Token 65:     "(Y/N)?"
     **** ****     > CHAR
0004 05C0 0B              byte '(' ^ RE
                   < elite.a99
1859                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 05C1   7A            byte 'Y' ^ RE
                   < elite.a99
1860                      .char '/'                                           ; Encoded as:   "(Y/N)?"
     **** ****     > CHAR
0004 05C2 0C              byte '/' ^ RE
                   < elite.a99
1861                      .char 'N'
     **** ****     > CHAR
0004 05C3   6D            byte 'N' ^ RE
                   < elite.a99
1862                      .char ')'
     **** ****     > CHAR
0004 05C4 0A              byte ')' ^ RE
                   < elite.a99
1863                      .char '?'
     **** ****     > CHAR
0004 05C5   1C            byte '?' ^ RE
                   < elite.a99
1864 05C6 00              byte >00
1865               
1866                      .char ' '                                           ; Token 66:     " CR"
     **** ****     > CHAR
0004 05C7   03            byte ' ' ^ RE
                   < elite.a99
1867                      .char 'C'                                           ;
     **** ****     > CHAR
0004 05C8 60              byte 'C' ^ RE
                   < elite.a99
1868                      .char 'R'                                           ; Encoded as:   " CR"
     **** ****     > CHAR
0004 05C9   71            byte 'R' ^ RE
                   < elite.a99
1869 05CA 00              byte >00
1870               
1871                      .char 'L'                                           ; Token 67:     "LARGE"
     **** ****     > CHAR
0004 05CB   6F            byte 'L' ^ RE
                   < elite.a99
1872 05CC A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1873 05CD   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "L<138><131>"
1874 05CE 00              byte >00
1875               
1876                      .char 'F'                                           ; Token 68:     "FIERCE"
     **** ****     > CHAR
0004 05CF   65            byte 'F' ^ RE
                   < elite.a99
1877                      .char 'I'                                           ;
     **** ****     > CHAR
0004 05D0 6A              byte 'I' ^ RE
                   < elite.a99
1878 05D1   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' Encoded as:   "FI<144><133>"
1879 05D2 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1880 05D3   00            byte >00
1881               
1882                      .char 'S'                                           ; Token 69:     "SMALL"
     **** ****     > CHAR
0004 05D4 70              byte 'S' ^ RE
                   < elite.a99
1883 05D5   A8            byte 139 ^ RE                                       ; TWOK 'M', 'A'
1884                      .rtok 118                                           ; Encoded as:   "S<139>[118]"
     **** ****     > RTOK
0008 05D6 55              byte 118 ^ RE
                   < elite.a99
1885 05D7   00            byte >00
1886               
1887                      .char 'G'                                           ; Token 70:     "GREEN"
     **** ****     > CHAR
0004 05D8 64              byte 'G' ^ RE
                   < elite.a99
1888 05D9   AD            byte 142 ^ RE                                       ; TWOK 'R', 'E'
1889 05DA B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' Encoded as:   "G<142><146>"
1890 05DB   00            byte >00
1891               
1892                      .char 'R'                                           ; Token 71:     "RED"
     **** ****     > CHAR
0004 05DC 71              byte 'R' ^ RE
                   < elite.a99
1893 05DD   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D'
1894 05DE 00              byte >00                                            ; Encoded as:   "R<152>"
1895               
1896                      .char 'Y'                                           ; Token 72:     "YELLOW"
     **** ****     > CHAR
0004 05DF   7A            byte 'Y' ^ RE
                   < elite.a99
1897                      .char 'E'                                           ;
     **** ****     > CHAR
0004 05E0 66              byte 'E' ^ RE
                   < elite.a99
1898                      .rtok 118                                           ; Encoded as:   "YE[118]OW"
     **** ****     > RTOK
0008 05E1   55            byte 118 ^ RE
                   < elite.a99
1899                      .char 'O'
     **** ****     > CHAR
0004 05E2 6C              byte 'O' ^ RE
                   < elite.a99
1900                      .char 'W'
     **** ****     > CHAR
0004 05E3   74            byte 'W' ^ RE
                   < elite.a99
1901 05E4 00              byte >00
1902               
1903                      .char 'B'                                           ; Token 73:     "BLUE"
     **** ****     > CHAR
0004 05E5   61            byte 'B' ^ RE
                   < elite.a99
1904                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05E6 6F              byte 'L' ^ RE
                   < elite.a99
1905                      .char 'U'                                           ; Encoded as:   "BLUE"
     **** ****     > CHAR
0004 05E7   76            byte 'U' ^ RE
                   < elite.a99
1906                      .char 'E'
     **** ****     > CHAR
0004 05E8 66              byte 'E' ^ RE
                   < elite.a99
1907 05E9   00            byte >00
1908               
1909                      .char 'B'                                           ; Token 74:     "BLACK"
     **** ****     > CHAR
0004 05EA 61              byte 'B' ^ RE
                   < elite.a99
1910 05EB   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1911                      .char 'C'                                           ; Encoded as:   "B<149>CK"
     **** ****     > CHAR
0004 05EC 60              byte 'C' ^ RE
                   < elite.a99
1912                      .char 'K'
     **** ****     > CHAR
0004 05ED   68            byte 'K' ^ RE
                   < elite.a99
1913 05EE 00              byte >00
1914               
1915                      .rtok 136                                           ; Token 75:     "HARMLESS"
     **** ****     > RTOK
0006 05EF   35            byte (136 - 114) ^ RE
                   < elite.a99
1916 05F0 00              byte >00                                            ;
1917                                                                          ; Encoded as:   "[136]"
1918               
1919                      .char 'S'                                           ; Token 76:     "SLIMY"
     **** ****     > CHAR
0004 05F1   70            byte 'S' ^ RE
                   < elite.a99
1920                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05F2 6F              byte 'L' ^ RE
                   < elite.a99
1921                      .char 'I'                                           ; Encoded as:   "SLIMY"
     **** ****     > CHAR
0004 05F3   6A            byte 'I' ^ RE
                   < elite.a99
1922                      .char 'M'
     **** ****     > CHAR
0004 05F4 6E              byte 'M' ^ RE
                   < elite.a99
1923                      .char 'Y'
     **** ****     > CHAR
0004 05F5   7A            byte 'Y' ^ RE
                   < elite.a99
1924 05F6 00              byte >00
1925               
1926                      .char 'B'                                           ; Token 77:     "BUG-EYED"
     **** ****     > CHAR
0004 05F7   61            byte 'B' ^ RE
                   < elite.a99
1927                      .char 'U'                                           ;
     **** ****     > CHAR
0004 05F8 76              byte 'U' ^ RE
                   < elite.a99
1928                      .char 'G'                                           ; Encoded as:   "BUG-EY<152>"
     **** ****     > CHAR
0004 05F9   64            byte 'G' ^ RE
                   < elite.a99
1929                      .char '-'
     **** ****     > CHAR
0004 05FA 0E              byte '-' ^ RE
                   < elite.a99
1930                      .char 'E'
     **** ****     > CHAR
0004 05FB   66            byte 'E' ^ RE
                   < elite.a99
1931                      .char 'Y'
     **** ****     > CHAR
0004 05FC 7A              byte 'Y' ^ RE
                   < elite.a99
1932 05FD   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1933 05FE 00              byte >00
1934               
1935                      .char 'H'                                           ; Token 78:     "HORNED"
     **** ****     > CHAR
0004 05FF   6B            byte 'H' ^ RE
                   < elite.a99
1936 0600 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R'
1937                      .char 'N'                                           ; Encoded as:   "H<153>N<152>"
     **** ****     > CHAR
0004 0601   6D            byte 'N' ^ RE
                   < elite.a99
1938 0602 BB              byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1939 0603   00            byte >00
1940               
1941                      .char 'B'                                           ; Token 79:     "BONY"
     **** ****     > CHAR
0004 0604 61              byte 'B' ^ RE
                   < elite.a99
1942 0605   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N'
1943                      .char 'Y'                                           ; Encoded as:   "B<159>Y"
     **** ****     > CHAR
0004 0606 7A              byte 'Y' ^ RE
                   < elite.a99
1944 0607   00            byte >00
1945               
1946                      .char 'F'                                           ; Token 80:     "FAT"
     **** ****     > CHAR
0004 0608 65              byte 'F' ^ RE
                   < elite.a99
1947 0609   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T'
1948 060A 00              byte >00                                            ; Encoded as:   "F<145>"
1949               
1950                      .char 'F'                                           ; Token 81:     "FURRY"
     **** ****     > CHAR
0004 060B   65            byte 'F' ^ RE
                   < elite.a99
1951                      .char 'U'                                           ;
     **** ****     > CHAR
0004 060C 76              byte 'U' ^ RE
                   < elite.a99
1952                      .char 'R'                                           ; Encoded as:   "FURRY"
     **** ****     > CHAR
0004 060D   71            byte 'R' ^ RE
                   < elite.a99
1953                      .char 'R'
     **** ****     > CHAR
0004 060E 71              byte 'R' ^ RE
                   < elite.a99
1954                      .char 'Y'
     **** ****     > CHAR
0004 060F   7A            byte 'Y' ^ RE
                   < elite.a99
1955 0610 00              byte >00
1956               
1957                      .char 'R'                                           ; Token 82:     "RODENT"
     **** ****     > CHAR
0004 0611   71            byte 'R' ^ RE
                   < elite.a99
1958                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0612 6C              byte 'O' ^ RE
                   < elite.a99
1959                      .char 'D'                                           ; Encoded as:   "ROD<146>T"
     **** ****     > CHAR
0004 0613   67            byte 'D' ^ RE
                   < elite.a99
1960 0614 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
1961                      .char 'T'
     **** ****     > CHAR
0004 0615   77            byte 'T' ^ RE
                   < elite.a99
1962 0616 00              byte >00
1963               
1964                      .char 'F'                                           ; Token 83:     "FROG"
     **** ****     > CHAR
0004 0617   65            byte 'F' ^ RE
                   < elite.a99
1965                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0618 71              byte 'R' ^ RE
                   < elite.a99
1966                      .char 'O'                                           ; Encoded as:   "FROG"
     **** ****     > CHAR
0004 0619   6C            byte 'O' ^ RE
                   < elite.a99
1967                      .char 'G'
     **** ****     > CHAR
0004 061A 64              byte 'G' ^ RE
                   < elite.a99
1968 061B   00            byte >00
1969               
1970                      .char 'L'                                           ; Token 84:     "LIZARD"
     **** ****     > CHAR
0004 061C 6F              byte 'L' ^ RE
                   < elite.a99
1971                      .char 'I'                                           ;
     **** ****     > CHAR
0004 061D   6A            byte 'I' ^ RE
                   < elite.a99
1972 061E A7              byte 132 ^ RE                                       ; TWOK 'Z', 'A' Encoded as:   "LI<132>RD"
1973                      .char 'R'
     **** ****     > CHAR
0004 061F   71            byte 'R' ^ RE
                   < elite.a99
1974                      .char 'D'
     **** ****     > CHAR
0004 0620 67              byte 'D' ^ RE
                   < elite.a99
1975 0621   00            byte >00
1976               
1977                      .char 'L'                                           ; Token 85:     "LOBSTER"
     **** ****     > CHAR
0004 0622 6F              byte 'L' ^ RE
                   < elite.a99
1978                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0623   6C            byte 'O' ^ RE
                   < elite.a99
1979                      .char 'B'                                           ; Encoded as:   "LOB[43]<144>"
     **** ****     > CHAR
0004 0624 61              byte 'B' ^ RE
                   < elite.a99
1980                      .rtok 43
     **** ****     > RTOK
0003 0625   E8            byte (43 + 160) ^ RE
                   < elite.a99
1981 0626 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1982 0627   00            byte >00
1983               
1984 0628 A5              byte 134 ^ RE                                       ; TWOK 'B', 'I' Token 86:     "BIRD"
1985                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0629   71            byte 'R' ^ RE
                   < elite.a99
1986                      .char 'D'                                           ; Encoded as:   "<134>RD"
     **** ****     > CHAR
0004 062A 67              byte 'D' ^ RE
                   < elite.a99
1987 062B   00            byte >00
1988               
1989                      .char 'H'                                           ; Token 87:     "HUMANOID"
     **** ****     > CHAR
0004 062C 6B              byte 'H' ^ RE
                   < elite.a99
1990                      .char 'U'                                           ;
     **** ****     > CHAR
0004 062D   76            byte 'U' ^ RE
                   < elite.a99
1991                      .char 'M'                                           ; Encoded as:   "HUM<155>OID"
     **** ****     > CHAR
0004 062E 6E              byte 'M' ^ RE
                   < elite.a99
1992 062F   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' null
1993                      .char 'O'
     **** ****     > CHAR
0004 0630 6C              byte 'O' ^ RE
                   < elite.a99
1994                      .char 'I'
     **** ****     > CHAR
0004 0631   6A            byte 'I' ^ RE
                   < elite.a99
1995                      .char 'D'
     **** ****     > CHAR
0004 0632 67              byte 'D' ^ RE
                   < elite.a99
1996 0633   00            byte >00
1997               
1998                      .char 'F'                                           ; Token 88:     "FELINE"
     **** ****     > CHAR
0004 0634 65              byte 'F' ^ RE
                   < elite.a99
1999                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0635   66            byte 'E' ^ RE
                   < elite.a99
2000                      .char 'L'                                           ; Encoded as:   "FEL<140>E"
     **** ****     > CHAR
0004 0636 6F              byte 'L' ^ RE
                   < elite.a99
2001 0637   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
2002                      .char 'E'
     **** ****     > CHAR
0004 0638 66              byte 'E' ^ RE
                   < elite.a99
2003 0639   00            byte >00
2004               
2005 063A AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 89:     "INSECT"
2006                      .char 'S'                                           ;
     **** ****     > CHAR
0004 063B   70            byte 'S' ^ RE
                   < elite.a99
2007                      .char 'E'                                           ; Encoded as:   "<140>SECT"
     **** ****     > CHAR
0004 063C 66              byte 'E' ^ RE
                   < elite.a99
2008                      .char 'C'
     **** ****     > CHAR
0004 063D   60            byte 'C' ^ RE
                   < elite.a99
2009                      .char 'T'
     **** ****     > CHAR
0004 063E 77              byte 'T' ^ RE
                   < elite.a99
2010 063F   00            byte >00
2011               
2012                      .rtok 11                                            ; Token 90:     "AVERAGE RADIUS"
     **** ****     > RTOK
0003 0640 88              byte (11 + 160) ^ RE
                   < elite.a99
2013 0641   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A'
2014 0642 AE              byte 141 ^ RE                                       ; TWOK 'D', 'I' Encoded as:   "[11]<148><141><136>"
2015 0643   AB            byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2016 0644 00              byte >00
2017               
2018                      .char 'C'                                           ; Token 91:     "COM"
     **** ****     > CHAR
0004 0645   60            byte 'C' ^ RE
                   < elite.a99
2019                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0646 6C              byte 'O' ^ RE
                   < elite.a99
2020                      .char 'M'                                           ; Encoded as:   "COM"
     **** ****     > CHAR
0004 0647   6E            byte 'M' ^ RE
                   < elite.a99
2021 0648 00              byte >00
2022               
2023                      .rtok 91                                            ; Token 92:     "COMMANDER"
     **** ****     > RTOK
0003 0649   D8            byte (91 + 160) ^ RE
                   < elite.a99
2024                      .char 'M'                                           ;
     **** ****     > CHAR
0004 064A 6E              byte 'M' ^ RE
                   < elite.a99
2025 064B   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "[91]M<155>D<144>"
2026                      .char 'D'
     **** ****     > CHAR
0004 064C 67              byte 'D' ^ RE
                   < elite.a99
2027 064D   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
2028 064E 00              byte >00
2029               
2030                      .char ' '                                           ; Token 93:     " DESTROYED"
     **** ****     > CHAR
0004 064F   03            byte ' ' ^ RE
                   < elite.a99
2031                      .char 'D'                                           ;
     **** ****     > CHAR
0004 0650 67              byte 'D' ^ RE
                   < elite.a99
2032 0651   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' Encoded as:   " D<137>TROY<152>"
2033                      .char 'T'
     **** ****     > CHAR
0004 0652 77              byte 'T' ^ RE
                   < elite.a99
2034                      .char 'R'
     **** ****     > CHAR
0004 0653   71            byte 'R' ^ RE
                   < elite.a99
2035                      .char 'O'
     **** ****     > CHAR
0004 0654 6C              byte 'O' ^ RE
                   < elite.a99
2036                      .char 'Y'
     **** ****     > CHAR
0004 0655   7A            byte 'Y' ^ RE
                   < elite.a99
2037 0656 BB              byte 152 ^ RE                                       ; TWOK 'E', 'D' null
2038 0657   00            byte >00
2039               
2040                      .char 'B'                                           ; Token 94:     "BY D.BRABEN & I.BELL"
     **** ****     > CHAR
0004 0658 61              byte 'B' ^ RE
                   < elite.a99
2041                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 0659   7A            byte 'Y' ^ RE
                   < elite.a99
2042                      .char ' '                                           ; Encoded as:   "BY D.B<148><147>N & I.<147>[118]"
     **** ****     > CHAR
0004 065A 03              byte ' ' ^ RE
                   < elite.a99
2043                      .char 'D'
     **** ****     > CHAR
0004 065B   67            byte 'D' ^ RE
                   < elite.a99
2044                      .char '.'
     **** ****     > CHAR
0004 065C 0D              byte '.' ^ RE
                   < elite.a99
2045                      .char 'B'
     **** ****     > CHAR
0004 065D   61            byte 'B' ^ RE
                   < elite.a99
2046 065E B7              byte 148 ^ RE                                       ; TWOK 'R', 'A' null
2047 065F   B0            byte 147 ^ RE                                       ; TWOK 'B', 'E' null
2048                      .char 'N'
     **** ****     > CHAR
0004 0660 6D              byte 'N' ^ RE
                   < elite.a99
2049                      .char ' '
     **** ****     > CHAR
0004 0661   03            byte ' ' ^ RE
                   < elite.a99
2050                      .char '&'
     **** ****     > CHAR
0004 0662 05              byte '&' ^ RE
                   < elite.a99
2051                      .char ' '
     **** ****     > CHAR
0004 0663   03            byte ' ' ^ RE
                   < elite.a99
2052                      .char 'I'
     **** ****     > CHAR
0004 0664 6A              byte 'I' ^ RE
                   < elite.a99
2053                      .char '.'
     **** ****     > CHAR
0004 0665   0D            byte '.' ^ RE
                   < elite.a99
2054 0666 B0              byte 147 ^ RE                                       ; TWOK 'B', 'E' null
2055                      .rtok 118
     **** ****     > RTOK
0008 0667   55            byte 118 ^ RE
                   < elite.a99
2056 0668 00              byte >00
2057               
2058                      .rtok 14                                            ; Token 95:     "UNIT  QUANTITY{crlf}
     **** ****     > RTOK
0003 0669   8D            byte (14 + 160) ^ RE
                   < elite.a99
2059                      .char ' '                                           ; PRODUCT   UNIT PRICE FOR SALE{crlf}
     **** ****     > CHAR
0004 066A 03              byte ' ' ^ RE
                   < elite.a99
2060                      .char ' '                                           ; {lf}"
     **** ****     > CHAR
0004 066B   03            byte ' ' ^ RE
                   < elite.a99
2061                      .rtok 16                                            ;
     **** ****     > RTOK
0003 066C 93              byte (16 + 160) ^ RE
                   < elite.a99
2062                      .cont 13                                            ; Encoded as:   "[14]  [16]{13} [26]   [14] [6] F<153>
     **** ****     > CONT
0001 066D   2E            byte 13 ^ RE
                   < elite.a99
2063                      .char ' '                                           ; SA<129>{13}{10}"
     **** ****     > CHAR
0004 066E 03              byte ' ' ^ RE
                   < elite.a99
2064                      .rtok 26
     **** ****     > RTOK
0003 066F   99            byte (26 + 160) ^ RE
                   < elite.a99
2065                      .char ' '
     **** ****     > CHAR
0004 0670 03              byte ' ' ^ RE
                   < elite.a99
2066                      .char ' '
     **** ****     > CHAR
0004 0671   03            byte ' ' ^ RE
                   < elite.a99
2067                      .char ' '
     **** ****     > CHAR
0004 0672 03              byte ' ' ^ RE
                   < elite.a99
2068                      .rtok 14
     **** ****     > RTOK
0003 0673   8D            byte (14 + 160) ^ RE
                   < elite.a99
2069                      .char ' '
     **** ****     > CHAR
0004 0674 03              byte ' ' ^ RE
                   < elite.a99
2070                      .rtok 6
     **** ****     > RTOK
0003 0675   85            byte (6 + 160) ^ RE
                   < elite.a99
2071                      .char ' '
     **** ****     > CHAR
0004 0676 03              byte ' ' ^ RE
                   < elite.a99
2072                      .char 'F'
     **** ****     > CHAR
0004 0677   65            byte 'F' ^ RE
                   < elite.a99
2073 0678 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2074                      .char ' '
     **** ****     > CHAR
0004 0679   03            byte ' ' ^ RE
                   < elite.a99
2075                      .char 'S'
     **** ****     > CHAR
0004 067A 70              byte 'S' ^ RE
                   < elite.a99
2076                      .char 'A'
     **** ****     > CHAR
0004 067B   62            byte 'A' ^ RE
                   < elite.a99
2077 067C A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2078                      .cont 13
     **** ****     > CONT
0001 067D   2E            byte 13 ^ RE
                   < elite.a99
2079                      .cont 10
     **** ****     > CONT
0001 067E 29              byte 10 ^ RE
                   < elite.a99
2080 067F   00            byte >00
2081               
2082                      .char 'F'                                           ; Token 96:     "FRONT"
     **** ****     > CHAR
0004 0680 65              byte 'F' ^ RE
                   < elite.a99
2083                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0681   71            byte 'R' ^ RE
                   < elite.a99
2084 0682 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' Encoded as:   "FR<159>T"
2085                      .char 'T'
     **** ****     > CHAR
0004 0683   77            byte 'T' ^ RE
                   < elite.a99
2086 0684 00              byte >00
2087               
2088 0685   AD            byte 142 ^ RE                                       ; TWOK 'R', 'E' Token 97:     "REAR"
2089 0686 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
2090 0687   00            byte >00                                            ; Encoded as:   "<142><138>"
2091               
2092 0688 A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' Token 98:     "LEFT"
2093                      .char 'F'                                           ;
     **** ****     > CHAR
0004 0689   65            byte 'F' ^ RE
                   < elite.a99
2094                      .char 'T'                                           ; Encoded as:   "<129>FT"
     **** ****     > CHAR
0004 068A 77              byte 'T' ^ RE
                   < elite.a99
2095 068B   00            byte >00
2096               
2097 068C BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' Token 99:     "RIGHT"
2098                      .char 'G'                                           ;
     **** ****     > CHAR
0004 068D   64            byte 'G' ^ RE
                   < elite.a99
2099                      .char 'H'                                           ; Encoded as:   "<158>GHT"
     **** ****     > CHAR
0004 068E 6B              byte 'H' ^ RE
                   < elite.a99
2100                      .char 'T'
     **** ****     > CHAR
0004 068F   77            byte 'T' ^ RE
                   < elite.a99
2101 0690 00              byte >00
2102               
2103                      .rtok 121                                           ; Token 100:    "ENERGY LOW{beep}"
     **** ****     > RTOK
0008 0691   5A            byte 121 ^ RE
                   < elite.a99
2104                      .char 'L'                                           ;
     **** ****     > CHAR
0004 0692 6F              byte 'L' ^ RE
                   < elite.a99
2105                      .char 'O'                                           ; Encoded as:   "[121]LOW{7}"
     **** ****     > CHAR
0004 0693   6C            byte 'O' ^ RE
                   < elite.a99
2106                      .char 'W'
     **** ****     > CHAR
0004 0694 74              byte 'W' ^ RE
                   < elite.a99
2107                      .cont 7
     **** ****     > CONT
0001 0695   24            byte 7 ^ RE
                   < elite.a99
2108 0696 00              byte >00
2109               
2110                      .rtok 99                                            ; Token 101:    "RIGHT ON COMMANDER!"
     **** ****     > RTOK
0008 0697   40            byte 99 ^ RE
                   < elite.a99
2111                      .rtok 131                                           ;
     **** ****     > RTOK
0006 0698 32              byte (131 - 114) ^ RE
                   < elite.a99
2112                      .rtok 92                                            ; Encoded as:   "[99][131][92]!"
     **** ****     > RTOK
0003 0699   DF            byte (92 + 160) ^ RE
                   < elite.a99
2113                      .char '!'
     **** ****     > CHAR
0004 069A 02              byte '!' ^ RE
                   < elite.a99
2114 069B   00            byte >00
2115               
2116                      .char 'E'                                           ; Token 102:    "EXTRA "
     **** ****     > CHAR
0004 069C 66              byte 'E' ^ RE
                   < elite.a99
2117                      .char 'X'                                           ;
     **** ****     > CHAR
0004 069D   7B            byte 'X' ^ RE
                   < elite.a99
2118                      .char 'T'                                           ; Encoded as:   "EXT<148> "
     **** ****     > CHAR
0004 069E 77              byte 'T' ^ RE
                   < elite.a99
2119 069F   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' null
2120                      .char ' '
     **** ****     > CHAR
0004 06A0 03              byte ' ' ^ RE
                   < elite.a99
2121 06A1   00            byte >00
2122               
2123                      .char 'P'                                           ; Token 103:    "PULSE LASER"
     **** ****     > CHAR
0004 06A2 73              byte 'P' ^ RE
                   < elite.a99
2124                      .char 'U'                                           ;
     **** ****     > CHAR
0004 06A3   76            byte 'U' ^ RE
                   < elite.a99
2125                      .char 'L'                                           ; Encoded as:   "PULSE[27]"
     **** ****     > CHAR
0004 06A4 6F              byte 'L' ^ RE
                   < elite.a99
2126                      .char 'S'
     **** ****     > CHAR
0004 06A5   70            byte 'S' ^ RE
                   < elite.a99
2127                      .char 'E'
     **** ****     > CHAR
0004 06A6 66              byte 'E' ^ RE
                   < elite.a99
2128                      .rtok 27
     **** ****     > RTOK
0003 06A7   98            byte (27 + 160) ^ RE
                   < elite.a99
2129 06A8 00              byte >00
2130               
2131 06A9   B0            byte 147 ^ RE                                       ; TWOK 'B', 'E' Token 104:    "BEAM LASER"
2132                      .char 'A'                                           ;
     **** ****     > CHAR
0004 06AA 62              byte 'A' ^ RE
                   < elite.a99
2133                      .char 'M'                                           ; Encoded as:   "<147>AM[27]"
     **** ****     > CHAR
0004 06AB   6E            byte 'M' ^ RE
                   < elite.a99
2134                      .rtok 27
     **** ****     > RTOK
0003 06AC 98              byte (27 + 160) ^ RE
                   < elite.a99
2135 06AD   00            byte >00
2136               
2137                      .char 'F'                                           ; Token 105:    "FUEL"
     **** ****     > CHAR
0004 06AE 65              byte 'F' ^ RE
                   < elite.a99
2138                      .char 'U'                                           ;
     **** ****     > CHAR
0004 06AF   76            byte 'U' ^ RE
                   < elite.a99
2139                      .char 'E'                                           ; Encoded as:   "FUEL"
     **** ****     > CHAR
0004 06B0 66              byte 'E' ^ RE
                   < elite.a99
2140                      .char 'L'
     **** ****     > CHAR
0004 06B1   6F            byte 'L' ^ RE
                   < elite.a99
2141 06B2 00              byte >00
2142               
2143                      .char 'M'                                           ; Token 106:    "MISSILE"
     **** ****     > CHAR
0004 06B3   6E            byte 'M' ^ RE
                   < elite.a99
2144 06B4 BE              byte 157 ^ RE                                       ; TWOK 'I', 'S'
2145                      .char 'S'                                           ; Encoded as:   "M<157>SI<129>"
     **** ****     > CHAR
0004 06B5   70            byte 'S' ^ RE
                   < elite.a99
2146                      .char 'I'
     **** ****     > CHAR
0004 06B6 6A              byte 'I' ^ RE
                   < elite.a99
2147 06B7   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2148 06B8 00              byte >00
2149               
2150                      .rtok 67                                            ; Token 107:    "LARGE CARGO{sentence case} BAY"
     **** ****     > RTOK
0003 06B9   C0            byte (67 + 160) ^ RE
                   < elite.a99
2151                      .rtok 46                                            ;
     **** ****     > RTOK
0003 06BA ED              byte (46 + 160) ^ RE
                   < elite.a99
2152                      .char ' '                                           ; Encoded as:   "[67][46] BAY"
     **** ****     > CHAR
0004 06BB   03            byte ' ' ^ RE
                   < elite.a99
2153                      .char 'B'
     **** ****     > CHAR
0004 06BC 61              byte 'B' ^ RE
                   < elite.a99
2154                      .char 'A'
     **** ****     > CHAR
0004 06BD   62            byte 'A' ^ RE
                   < elite.a99
2155                      .char 'Y'
     **** ****     > CHAR
0004 06BE 7A              byte 'Y' ^ RE
                   < elite.a99
2156 06BF   00            byte >00
2157               
2158                      .char 'E'                                           ; Token 108:    "E.C.M.SYSTEM"
     **** ****     > CHAR
0004 06C0 66              byte 'E' ^ RE
                   < elite.a99
2159                      .char '.'                                           ;
     **** ****     > CHAR
0004 06C1   0D            byte '.' ^ RE
                   < elite.a99
2160                      .char 'C'                                           ; Encoded as:   "E.C.M.[5]"
     **** ****     > CHAR
0004 06C2 60              byte 'C' ^ RE
                   < elite.a99
2161                      .char '.'
     **** ****     > CHAR
0004 06C3   0D            byte '.' ^ RE
                   < elite.a99
2162                      .char 'M'
     **** ****     > CHAR
0004 06C4 6E              byte 'M' ^ RE
                   < elite.a99
2163                      .char '.'
     **** ****     > CHAR
0004 06C5   0D            byte '.' ^ RE
                   < elite.a99
2164                      .rtok 5
     **** ****     > RTOK
0003 06C6 86              byte (5 + 160) ^ RE
                   < elite.a99
2165 06C7   00            byte >00
2166               
2167                      .rtok 102                                           ; Token 109:    "EXTRA PULSE LASERS"
     **** ****     > RTOK
0008 06C8 45              byte 102 ^ RE
                   < elite.a99
2168                      .rtok 103                                           ;
     **** ****     > RTOK
0008 06C9   44            byte 103 ^ RE
                   < elite.a99
2169                      .char 'S'                                           ; Encoded as:   "[102][103]S"
     **** ****     > CHAR
0004 06CA 70              byte 'S' ^ RE
                   < elite.a99
2170 06CB   00            byte >00
2171               
2172                      .rtok 102                                           ; Token 110:    "EXTRA BEAM LASERS"
     **** ****     > RTOK
0008 06CC 45              byte 102 ^ RE
                   < elite.a99
2173                      .rtok 104                                           ;
     **** ****     > RTOK
0008 06CD   4B            byte 104 ^ RE
                   < elite.a99
2174                      .char 'S'                                           ; Encoded as:   "[102][104]S"
     **** ****     > CHAR
0004 06CE 70              byte 'S' ^ RE
                   < elite.a99
2175 06CF   00            byte >00
2176               
2177                      .rtok 105                                           ; Token 111:    "FUEL SCOOPS"
     **** ****     > RTOK
0008 06D0 4A              byte 105 ^ RE
                   < elite.a99
2178                      .char ' '                                           ;
     **** ****     > CHAR
0004 06D1   03            byte ' ' ^ RE
                   < elite.a99
2179                      .char 'S'                                           ; Encoded as:   "[105] SCOOPS"
     **** ****     > CHAR
0004 06D2 70              byte 'S' ^ RE
                   < elite.a99
2180                      .char 'C'
     **** ****     > CHAR
0004 06D3   60            byte 'C' ^ RE
                   < elite.a99
2181                      .char 'O'
     **** ****     > CHAR
0004 06D4 6C              byte 'O' ^ RE
                   < elite.a99
2182                      .char 'O'
     **** ****     > CHAR
0004 06D5   6C            byte 'O' ^ RE
                   < elite.a99
2183                      .char 'P'
     **** ****     > CHAR
0004 06D6 73              byte 'P' ^ RE
                   < elite.a99
2184                      .char 'S'
     **** ****     > CHAR
0004 06D7   70            byte 'S' ^ RE
                   < elite.a99
2185 06D8 00              byte >00
2186               
2187 06D9   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' Token 112:    "ESCAPE POD"
2188                      .char 'C'                                           ;
     **** ****     > CHAR
0004 06DA 60              byte 'C' ^ RE
                   < elite.a99
2189                      .char 'A'                                           ; Encoded as:   "<137>CAPE POD"
     **** ****     > CHAR
0004 06DB   62            byte 'A' ^ RE
                   < elite.a99
2190                      .char 'P'
     **** ****     > CHAR
0004 06DC 73              byte 'P' ^ RE
                   < elite.a99
2191                      .char 'E'
     **** ****     > CHAR
0004 06DD   66            byte 'E' ^ RE
                   < elite.a99
2192                      .char ' '
     **** ****     > CHAR
0004 06DE 03              byte ' ' ^ RE
                   < elite.a99
2193                      .char 'P'
     **** ****     > CHAR
0004 06DF   73            byte 'P' ^ RE
                   < elite.a99
2194                      .char 'O'
     **** ****     > CHAR
0004 06E0 6C              byte 'O' ^ RE
                   < elite.a99
2195                      .char 'D'
     **** ****     > CHAR
0004 06E1   67            byte 'D' ^ RE
                   < elite.a99
2196 06E2 00              byte >00
2197               
2198                      .rtok 121                                           ; Token 113:    "ENERGY BOMB"
     **** ****     > RTOK
0008 06E3   5A            byte 121 ^ RE
                   < elite.a99
2199                      .char 'B'                                           ;
     **** ****     > CHAR
0004 06E4 61              byte 'B' ^ RE
                   < elite.a99
2200                      .char 'O'                                           ; Encoded as:   "[121]BOMB"
     **** ****     > CHAR
0004 06E5   6C            byte 'O' ^ RE
                   < elite.a99
2201                      .char 'M'
     **** ****     > CHAR
0004 06E6 6E              byte 'M' ^ RE
                   < elite.a99
2202                      .char 'B'
     **** ****     > CHAR
0004 06E7   61            byte 'B' ^ RE
                   < elite.a99
2203 06E8 00              byte >00
2204               
2205                      .rtok 121                                           ; Token 114:    "ENERGY UNIT"
     **** ****     > RTOK
0008 06E9   5A            byte 121 ^ RE
                   < elite.a99
2206                      .rtok 14                                            ;
     **** ****     > RTOK
0003 06EA 8D              byte (14 + 160) ^ RE
                   < elite.a99
2207 06EB   00            byte >00                                            ; Encoded as:   "[121][14]"
2208               
2209                      .rtok 124                                           ; Token 115:    "DOCKING COMPUTERS"
     **** ****     > RTOK
0008 06EC 5F              byte 124 ^ RE
                   < elite.a99
2210 06ED   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
2211                      .char 'G'                                           ; Encoded as:   "[124]<140>G [55]"
     **** ****     > CHAR
0004 06EE 64              byte 'G' ^ RE
                   < elite.a99
2212                      .char ' '
     **** ****     > CHAR
0004 06EF   03            byte ' ' ^ RE
                   < elite.a99
2213                      .rtok 55
     **** ****     > RTOK
0003 06F0 F4              byte (55 + 160) ^ RE
                   < elite.a99
2214 06F1   00            byte >00
2215               
2216                      .rtok 122                                           ; Token 116:    "GALACTIC HYPERSPACE "
     **** ****     > RTOK
0008 06F2 59              byte 122 ^ RE
                   < elite.a99
2217                      .char ' '                                           ;
     **** ****     > CHAR
0004 06F3   03            byte ' ' ^ RE
                   < elite.a99
2218                      .rtok 29                                            ; Encoded as:   "[122] [29]"
     **** ****     > RTOK
0003 06F4 9E              byte (29 + 160) ^ RE
                   < elite.a99
2219 06F5   00            byte >00
2220               
2221                      .char 'A'                                           ; Token 117:    "ALL"
     **** ****     > CHAR
0004 06F6 62              byte 'A' ^ RE
                   < elite.a99
2222                      .rtok 118                                           ;
     **** ****     > RTOK
0008 06F7   55            byte 118 ^ RE
                   < elite.a99
2223 06F8 00              byte >00                                            ; Encoded as:   "A[118]"
2224               
2225                      .char 'L'                                           ; Token 118:    "LL"
     **** ****     > CHAR
0004 06F9   6F            byte 'L' ^ RE
                   < elite.a99
2226                      .char 'L'                                           ;
     **** ****     > CHAR
0004 06FA 6F              byte 'L' ^ RE
                   < elite.a99
2227 06FB   00            byte >00                                            ; Encoded as:   "LL"
2228               
2229                      .rtok 37                                            ; Token 119:    "CASH:{cash} CR{crlf}
     **** ****     > RTOK
0003 06FC E6              byte (37 + 160) ^ RE
                   < elite.a99
2230                      .char ':'                                           ; "
     **** ****     > CHAR
0004 06FD   19            byte ':' ^ RE
                   < elite.a99
2231                      .cont 0                                             ;
     **** ****     > CONT
0001 06FE 23              byte 0 ^ RE
                   < elite.a99
2232 06FF   00            byte >00                                            ; Encoded as:   "[37]:{0}"
2233               
2234 0700 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 120:    "INCOMING MISSILE"
2235                      .rtok 91                                            ;
     **** ****     > RTOK
0003 0701   D8            byte (91 + 160) ^ RE
                   < elite.a99
2236 0702 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Encoded as:   "<140>[91]<140>G [106]"
2237                      .char 'G'
     **** ****     > CHAR
0004 0703   64            byte 'G' ^ RE
                   < elite.a99
2238                      .char ' '
     **** ****     > CHAR
0004 0704 03              byte ' ' ^ RE
                   < elite.a99
2239                      .rtok 106
     **** ****     > RTOK
0008 0705   49            byte 106 ^ RE
                   < elite.a99
2240 0706 00              byte >00
2241               
2242 0707   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' Token 121:    "ENERGY "
2243 0708 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R'
2244                      .char 'G'                                           ; Encoded as:   "<146><144>GY "
     **** ****     > CHAR
0004 0709   64            byte 'G' ^ RE
                   < elite.a99
2245                      .char 'Y'
     **** ****     > CHAR
0004 070A 7A              byte 'Y' ^ RE
                   < elite.a99
2246                      .char ' '
     **** ****     > CHAR
0004 070B   03            byte ' ' ^ RE
                   < elite.a99
2247 070C 00              byte >00
2248               
2249                      .char 'G'                                           ; Token 122:    "GALACTIC"
     **** ****     > CHAR
0004 070D   64            byte 'G' ^ RE
                   < elite.a99
2250                      .char 'A'                                           ;
     **** ****     > CHAR
0004 070E 62              byte 'A' ^ RE
                   < elite.a99
2251 070F   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A' Encoded as:   "GA<149>C<151>C"
2252                      .char 'C'
     **** ****     > CHAR
0004 0710 60              byte 'C' ^ RE
                   < elite.a99
2253 0711   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2254                      .char 'C'
     **** ****     > CHAR
0004 0712 60              byte 'C' ^ RE
                   < elite.a99
2255 0713   00            byte >00
2256               
2257                      .cont 13                                            ; Token 123:    "{crlf}
     **** ****     > CONT
0001 0714 2E              byte 13 ^ RE
                   < elite.a99
2258                      .rtok 92                                            ; COMMANDER'S NAME? "
     **** ****     > RTOK
0003 0715   DF            byte (92 + 160) ^ RE
                   < elite.a99
2259                      .char '`'                                           ;
     **** ****     > CHAR
0002 0716 04              byte 39 ^ RE
                   < elite.a99
2260                      .char 'S'                                           ; Encoded as:   "{13}[92]'S NAME? "
     **** ****     > CHAR
0004 0717   70            byte 'S' ^ RE
                   < elite.a99
2261                      .char ' '
     **** ****     > CHAR
0004 0718 03              byte ' ' ^ RE
                   < elite.a99
2262                      .char 'N'
     **** ****     > CHAR
0004 0719   6D            byte 'N' ^ RE
                   < elite.a99
2263                      .char 'A'
     **** ****     > CHAR
0004 071A 62              byte 'A' ^ RE
                   < elite.a99
2264                      .char 'M'
     **** ****     > CHAR
0004 071B   6E            byte 'M' ^ RE
                   < elite.a99
2265                      .char 'E'
     **** ****     > CHAR
0004 071C 66              byte 'E' ^ RE
                   < elite.a99
2266                      .char '?'
     **** ****     > CHAR
0004 071D   1C            byte '?' ^ RE
                   < elite.a99
2267                      .char ' '
     **** ****     > CHAR
0004 071E 03              byte ' ' ^ RE
                   < elite.a99
2268 071F   00            byte >00
2269               
2270                      .char 'D'                                           ; Token 124:    "DOCK"
     **** ****     > CHAR
0004 0720 67              byte 'D' ^ RE
                   < elite.a99
2271                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0721   6C            byte 'O' ^ RE
                   < elite.a99
2272                      .char 'C'                                           ; Encoded as:   "DOCK"
     **** ****     > CHAR
0004 0722 60              byte 'C' ^ RE
                   < elite.a99
2273                      .char 'K'
     **** ****     > CHAR
0004 0723   68            byte 'K' ^ RE
                   < elite.a99
2274 0724 00              byte >00
2275               
2276                      .cont 5                                             ; Token 125:    "FUEL: {fuel level} LIGHT YEARS{crlf}
     **** ****     > CONT
0001 0725   26            byte 5 ^ RE
                   < elite.a99
2277 0726 A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' CASH:{cash} CR{crlf}
2278                      .char 'G'                                           ; LEGAL STATUS:"
     **** ****     > CHAR
0004 0727   64            byte 'G' ^ RE
                   < elite.a99
2279 0728 A3              byte 128 ^ RE                                       ; TWOK 'A', 'L'
2280                      .char ' '                                           ; Encoded as:   "{5}<129>G<128> [43]<145><136>:"
     **** ****     > CHAR
0004 0729   03            byte ' ' ^ RE
                   < elite.a99
2281                      .rtok 43
     **** ****     > RTOK
0003 072A E8              byte (43 + 160) ^ RE
                   < elite.a99
2282 072B   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
2283 072C AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2284                      .char ':'
     **** ****     > CHAR
0004 072D   19            byte ':' ^ RE
                   < elite.a99
2285 072E 00              byte >00
2286               
2287                      .rtok 92                                            ; Token 126:    "COMMANDER {commander name}{crlf}
     **** ****     > RTOK
0003 072F   DF            byte (92 + 160) ^ RE
                   < elite.a99
2288                      .char ' '                                           ; {crlf}
     **** ****     > CHAR
0004 0730 03              byte ' ' ^ RE
                   < elite.a99
2289                      .cont 4                                             ; {crlf}
     **** ****     > CONT
0001 0731   27            byte 4 ^ RE
                   < elite.a99
2290                      .cont 13                                            ; {sentence case}PRESENT SYSTEM{tab to
     **** ****     > CONT
0001 0732 2E              byte 13 ^ RE
                   < elite.a99
2291                      .cont 13                                            ; column 21}:{current system name}{crlf}
     **** ****     > CONT
0001 0733   2E            byte 13 ^ RE
                   < elite.a99
2292                      .cont 13                                            ; HYPERSPACE SYSTEM{tab to column 21}:
     **** ****     > CONT
0001 0734 2E              byte 13 ^ RE
                   < elite.a99
2293                      .cont 6                                             ; {selected system name}{crlf}
     **** ****     > CONT
0001 0735   25            byte 6 ^ RE
                   < elite.a99
2294                      .rtok 145                                           ; CONDITION{tab to column 21}:"
     **** ****     > RTOK
0006 0736 3C              byte (145 - 114) ^ RE
                   < elite.a99
2295                      .char ' '                                           ;
     **** ****     > CHAR
0004 0737   03            byte ' ' ^ RE
                   < elite.a99
2296                      .rtok 5                                             ; Encoded as:   "[92] {4}{13}{13}{13}{6}[145] [5]{9}{2}
     **** ****     > RTOK
0003 0738 86              byte (5 + 160) ^ RE
                   < elite.a99
2297                      .cont 9                                             ; {13}[29][5]{9}{3}{13}C<159><141><151>
     **** ****     > CONT
0001 0739   2A            byte 9 ^ RE
                   < elite.a99
2298                      .cont 2                                             ; <159>{9}"
     **** ****     > CONT
0001 073A 21              byte 2 ^ RE
                   < elite.a99
2299                      .cont 13
     **** ****     > CONT
0001 073B   2E            byte 13 ^ RE
                   < elite.a99
2300                      .rtok 29
     **** ****     > RTOK
0003 073C 9E              byte (29 + 160) ^ RE
                   < elite.a99
2301                      .rtok 5
     **** ****     > RTOK
0003 073D   86            byte (5 + 160) ^ RE
                   < elite.a99
2302                      .cont 9
     **** ****     > CONT
0001 073E 2A              byte 9 ^ RE
                   < elite.a99
2303                      .cont 3
     **** ****     > CONT
0001 073F   20            byte 3 ^ RE
                   < elite.a99
2304                      .cont 13
     **** ****     > CONT
0001 0740 2E              byte 13 ^ RE
                   < elite.a99
2305                      .char 'C'
     **** ****     > CHAR
0004 0741   60            byte 'C' ^ RE
                   < elite.a99
2306 0742 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
2307 0743   AE            byte 141 ^ RE                                       ; TWOK 'D', 'I' null
2308 0744 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2309 0745   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
2310                      .cont 9
     **** ****     > CONT
0001 0746 2A              byte 9 ^ RE
                   < elite.a99
2311 0747   00            byte >00
2312               
2313                      .char 'I'                                           ; Token 127:    "ITEM"
     **** ****     > CHAR
0004 0748 6A              byte 'I' ^ RE
                   < elite.a99
2314 0749   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E'
2315                      .char 'M'                                           ; Encoded as:   "I<156>M"
     **** ****     > CHAR
0004 074A 6E              byte 'M' ^ RE
                   < elite.a99
2316 074B   00            byte >00
2317               
2318                      .char ' '                                           ; Token 128:    "  LOAD NEW COMMANDER (Y/N)?{crlf}
     **** ****     > CHAR
0004 074C 03              byte ' ' ^ RE
                   < elite.a99
2319                      .char ' '                                           ; {crlf}
     **** ****     > CHAR
0004 074D   03            byte ' ' ^ RE
                   < elite.a99
2320                      .char 'L'                                           ; "
     **** ****     > CHAR
0004 074E 6F              byte 'L' ^ RE
                   < elite.a99
2321                      .char 'O'                                           ;
     **** ****     > CHAR
0004 074F   6C            byte 'O' ^ RE
                   < elite.a99
2322                      .char 'A'                                           ; Encoded as:   "  LOAD NEW [92] [65]{13}{13}"
     **** ****     > CHAR
0004 0750 62              byte 'A' ^ RE
                   < elite.a99
2323                      .char 'D'
     **** ****     > CHAR
0004 0751   67            byte 'D' ^ RE
                   < elite.a99
2324                      .char ' '
     **** ****     > CHAR
0004 0752 03              byte ' ' ^ RE
                   < elite.a99
2325                      .char 'N'
     **** ****     > CHAR
0004 0753   6D            byte 'N' ^ RE
                   < elite.a99
2326                      .char 'E'
     **** ****     > CHAR
0004 0754 66              byte 'E' ^ RE
                   < elite.a99
2327                      .char 'W'
     **** ****     > CHAR
0004 0755   74            byte 'W' ^ RE
                   < elite.a99
2328                      .char ' '
     **** ****     > CHAR
0004 0756 03              byte ' ' ^ RE
                   < elite.a99
2329                      .rtok 92
     **** ****     > RTOK
0003 0757   DF            byte (92 + 160) ^ RE
                   < elite.a99
2330                      .char ' '
     **** ****     > CHAR
0004 0758 03              byte ' ' ^ RE
                   < elite.a99
2331                      .rtok 65
     **** ****     > RTOK
0003 0759   C2            byte (65 + 160) ^ RE
                   < elite.a99
2332                      .cont 13
     **** ****     > CONT
0001 075A 2E              byte 13 ^ RE
                   < elite.a99
2333                      .cont 13
     **** ****     > CONT
0001 075B   2E            byte 13 ^ RE
                   < elite.a99
2334 075C 00              byte >00
2335               
2336                      .cont 6                                             ; Token 129:    "{sentence case}DOCKED"
     **** ****     > CONT
0001 075D   25            byte 6 ^ RE
                   < elite.a99
2337                      .rtok 124                                           ;
     **** ****     > RTOK
0008 075E 5F              byte 124 ^ RE
                   < elite.a99
2338 075F   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' Encoded as:   "{6}[124]<152>"
2339 0760 00              byte >00
2340               
2341 0761   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Token 130:    "RATING:"
2342 0762 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I'
2343                      .char 'N'                                           ; Encoded as:   "<148><151>NG:"
     **** ****     > CHAR
0004 0763   6D            byte 'N' ^ RE
                   < elite.a99
2344                      .char 'G'
     **** ****     > CHAR
0004 0764 64              byte 'G' ^ RE
                   < elite.a99
2345                      .char ':'
     **** ****     > CHAR
0004 0765   19            byte ':' ^ RE
                   < elite.a99
2346 0766 00              byte >00
2347               
2348                      .char ' '                                           ; Token 131:    " ON "
     **** ****     > CHAR
0004 0767   03            byte ' ' ^ RE
                   < elite.a99
2349 0768 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N'
2350                      .char ' '                                           ; Encoded as:   " <159> "
     **** ****     > CHAR
0004 0769   03            byte ' ' ^ RE
                   < elite.a99
2351 076A 00              byte >00
2352               
2353                      .cont 13                                            ; Token 132:    "{crlf}
     **** ****     > CONT
0001 076B   2E            byte 13 ^ RE
                   < elite.a99
2354                      .cont 8                                             ; {all caps}EQUIPMENT: {sentence case}"
     **** ****     > CONT
0001 076C 2B              byte 8 ^ RE
                   < elite.a99
2355                      .rtok 47                                            ;
     **** ****     > RTOK
0003 076D   EC            byte (47 + 160) ^ RE
                   < elite.a99
2356                      .char 'M'                                           ; Encoded as:   "{13}{8}[47]M<146>T:{6}"
     **** ****     > CHAR
0004 076E 6E              byte 'M' ^ RE
                   < elite.a99
2357 076F   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2358                      .char 'T'
     **** ****     > CHAR
0004 0770 77              byte 'T' ^ RE
                   < elite.a99
2359                      .char ':'
     **** ****     > CHAR
0004 0771   19            byte ':' ^ RE
                   < elite.a99
2360                      .cont 6
     **** ****     > CONT
0001 0772 25              byte 6 ^ RE
                   < elite.a99
2361 0773   00            byte >00
2362               
2363                      .char 'C'                                           ; Token 133:    "CLEAN"
     **** ****     > CHAR
0004 0774 60              byte 'C' ^ RE
                   < elite.a99
2364 0775   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E'
2365 0776 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "C<129><155>"
2366 0777   00            byte >00
2367               
2368                      .char 'O'                                           ; Token 134:    "OFFENDER"
     **** ****     > CHAR
0004 0778 6C              byte 'O' ^ RE
                   < elite.a99
2369                      .char 'F'                                           ;
     **** ****     > CHAR
0004 0779   65            byte 'F' ^ RE
                   < elite.a99
2370                      .char 'F'                                           ; Encoded as:   "OFF<146>D<144>"
     **** ****     > CHAR
0004 077A 65              byte 'F' ^ RE
                   < elite.a99
2371 077B   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2372                      .char 'D'
     **** ****     > CHAR
0004 077C 67              byte 'D' ^ RE
                   < elite.a99
2373 077D   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
2374 077E 00              byte >00
2375               
2376                      .char 'F'                                           ; Token 135:    "FUGITIVE"
     **** ****     > CHAR
0004 077F   65            byte 'F' ^ RE
                   < elite.a99
2377                      .char 'U'                                           ;
     **** ****     > CHAR
0004 0780 76              byte 'U' ^ RE
                   < elite.a99
2378                      .char 'G'                                           ; Encoded as:   "FUGI<151><150>"
     **** ****     > CHAR
0004 0781   64            byte 'G' ^ RE
                   < elite.a99
2379                      .char 'I'
     **** ****     > CHAR
0004 0782 6A              byte 'I' ^ RE
                   < elite.a99
2380 0783   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2381 0784 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2382 0785   00            byte >00
2383               
2384                      .char 'H'                                           ; Token 136:    "HARMLESS"
     **** ****     > CHAR
0004 0786 6B              byte 'H' ^ RE
                   < elite.a99
2385 0787   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R'
2386                      .char 'M'                                           ; Encoded as:   "H<138>M<129>SS"
     **** ****     > CHAR
0004 0788 6E              byte 'M' ^ RE
                   < elite.a99
2387 0789   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2388                      .char 'S'
     **** ****     > CHAR
0004 078A 70              byte 'S' ^ RE
                   < elite.a99
2389                      .char 'S'
     **** ****     > CHAR
0004 078B   70            byte 'S' ^ RE
                   < elite.a99
2390 078C 00              byte >00
2391               
2392                      .char 'M'                                           ; Token 137:    "MOSTLY HARMLESS"
     **** ****     > CHAR
0004 078D   6E            byte 'M' ^ RE
                   < elite.a99
2393                      .char 'O'                                           ;
     **** ****     > CHAR
0004 078E 6C              byte 'O' ^ RE
                   < elite.a99
2394                      .rtok 43                                            ; Encoded as:   "MO[43]LY [136]"
     **** ****     > RTOK
0003 078F   E8            byte (43 + 160) ^ RE
                   < elite.a99
2395                      .char 'L'
     **** ****     > CHAR
0004 0790 6F              byte 'L' ^ RE
                   < elite.a99
2396                      .char 'Y'
     **** ****     > CHAR
0004 0791   7A            byte 'Y' ^ RE
                   < elite.a99
2397                      .char ' '
     **** ****     > CHAR
0004 0792 03              byte ' ' ^ RE
                   < elite.a99
2398                      .rtok 136
     **** ****     > RTOK
0006 0793   35            byte (136 - 114) ^ RE
                   < elite.a99
2399 0794 00              byte >00
2400               
2401                      .rtok 12                                            ; Token 138:    "POOR "
     **** ****     > RTOK
0003 0795   8F            byte (12 + 160) ^ RE
                   < elite.a99
2402 0796 00              byte >00                                            ;
2403                                                                          ; Encoded as:   "[12]"
2404               
2405                      .rtok 11                                            ; Token 139:    "AVERAGE "
     **** ****     > RTOK
0003 0797   88            byte (11 + 160) ^ RE
                   < elite.a99
2406 0798 00              byte >00                                            ;
2407                                                                          ; Encoded as:   "[11]"
2408               
2409                      .char 'A'                                           ; Token 140:    "ABOVE AVERAGE "
     **** ****     > CHAR
0004 0799   62            byte 'A' ^ RE
                   < elite.a99
2410                      .char 'B'                                           ;
     **** ****     > CHAR
0004 079A 61              byte 'B' ^ RE
                   < elite.a99
2411                      .char 'O'                                           ; Encoded as:   "ABO<150> [11]"
     **** ****     > CHAR
0004 079B   6C            byte 'O' ^ RE
                   < elite.a99
2412 079C B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2413                      .char ' '
     **** ****     > CHAR
0004 079D   03            byte ' ' ^ RE
                   < elite.a99
2414                      .rtok 11
     **** ****     > RTOK
0003 079E 88              byte (11 + 160) ^ RE
                   < elite.a99
2415 079F   00            byte >00
2416               
2417                      .rtok 91                                            ; Token 141:    "COMPETENT"
     **** ****     > RTOK
0003 07A0 D8              byte (91 + 160) ^ RE
                   < elite.a99
2418                      .char 'P'                                           ;
     **** ****     > CHAR
0004 07A1   73            byte 'P' ^ RE
                   < elite.a99
2419                      .char 'E'                                           ; Encoded as:   "[91]PET<146>T"
     **** ****     > CHAR
0004 07A2 66              byte 'E' ^ RE
                   < elite.a99
2420                      .char 'T'
     **** ****     > CHAR
0004 07A3   77            byte 'T' ^ RE
                   < elite.a99
2421 07A4 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2422                      .char 'T'
     **** ****     > CHAR
0004 07A5   77            byte 'T' ^ RE
                   < elite.a99
2423 07A6 00              byte >00
2424               
2425                      .char 'D'                                           ; Token 142:    "DANGEROUS"
     **** ****     > CHAR
0004 07A7   67            byte 'D' ^ RE
                   < elite.a99
2426 07A8 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
2427 07A9   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "D<155><131>RO<136>"
2428                      .char 'R'
     **** ****     > CHAR
0004 07AA 71              byte 'R' ^ RE
                   < elite.a99
2429                      .char 'O'
     **** ****     > CHAR
0004 07AB   6C            byte 'O' ^ RE
                   < elite.a99
2430 07AC AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2431 07AD   00            byte >00
2432               
2433                      .char 'D'                                           ; Token 143:    "DEADLY"
     **** ****     > CHAR
0004 07AE 67              byte 'D' ^ RE
                   < elite.a99
2434                      .char 'E'                                           ;
     **** ****     > CHAR
0004 07AF   66            byte 'E' ^ RE
                   < elite.a99
2435                      .char 'A'                                           ; Encoded as:   "DEADLY"
     **** ****     > CHAR
0004 07B0 62              byte 'A' ^ RE
                   < elite.a99
2436                      .char 'D'
     **** ****     > CHAR
0004 07B1   67            byte 'D' ^ RE
                   < elite.a99
2437                      .char 'L'
     **** ****     > CHAR
0004 07B2 6F              byte 'L' ^ RE
                   < elite.a99
2438                      .char 'Y'
     **** ****     > CHAR
0004 07B3   7A            byte 'Y' ^ RE
                   < elite.a99
2439 07B4 00              byte >00
2440               
2441                      .char '-'                                           ; Token 144:    "---- E L I T E ----"
     **** ****     > CHAR
0004 07B5   0E            byte '-' ^ RE
                   < elite.a99
2442                      .char '-'                                           ;
     **** ****     > CHAR
0004 07B6 0E              byte '-' ^ RE
                   < elite.a99
2443                      .char '-'                                           ; Encoded as:   "---- E L I T E ----"
     **** ****     > CHAR
0004 07B7   0E            byte '-' ^ RE
                   < elite.a99
2444                      .char '-'
     **** ****     > CHAR
0004 07B8 0E              byte '-' ^ RE
                   < elite.a99
2445                      .char ' '
     **** ****     > CHAR
0004 07B9   03            byte ' ' ^ RE
                   < elite.a99
2446                      .char 'E'
     **** ****     > CHAR
0004 07BA 66              byte 'E' ^ RE
                   < elite.a99
2447                      .char ' '
     **** ****     > CHAR
0004 07BB   03            byte ' ' ^ RE
                   < elite.a99
2448                      .char 'L'
     **** ****     > CHAR
0004 07BC 6F              byte 'L' ^ RE
                   < elite.a99
2449                      .char ' '
     **** ****     > CHAR
0004 07BD   03            byte ' ' ^ RE
                   < elite.a99
2450                      .char 'I'
     **** ****     > CHAR
0004 07BE 6A              byte 'I' ^ RE
                   < elite.a99
2451                      .char ' '
     **** ****     > CHAR
0004 07BF   03            byte ' ' ^ RE
                   < elite.a99
2452                      .char 'T'
     **** ****     > CHAR
0004 07C0 77              byte 'T' ^ RE
                   < elite.a99
2453                      .char ' '
     **** ****     > CHAR
0004 07C1   03            byte ' ' ^ RE
                   < elite.a99
2454                      .char 'E'
     **** ****     > CHAR
0004 07C2 66              byte 'E' ^ RE
                   < elite.a99
2455                      .char ' '
     **** ****     > CHAR
0004 07C3   03            byte ' ' ^ RE
                   < elite.a99
2456                      .char '-'
     **** ****     > CHAR
0004 07C4 0E              byte '-' ^ RE
                   < elite.a99
2457                      .char '-'
     **** ****     > CHAR
0004 07C5   0E            byte '-' ^ RE
                   < elite.a99
2458                      .char '-'
     **** ****     > CHAR
0004 07C6 0E              byte '-' ^ RE
                   < elite.a99
2459                      .char '-'
     **** ****     > CHAR
0004 07C7   0E            byte '-' ^ RE
                   < elite.a99
2460 07C8 00              byte >00
2461               
2462                      .char 'P'                                           ; Token 145:    "PRESENT"
     **** ****     > CHAR
0004 07C9   73            byte 'P' ^ RE
                   < elite.a99
2463 07CA AD              byte 142 ^ RE                                       ; TWOK 'R', 'E'
2464                      .char 'S'                                           ; Encoded as:   "P<142>S<146>T"
     **** ****     > CHAR
0004 07CB   70            byte 'S' ^ RE
                   < elite.a99
2465 07CC B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2466                      .char 'T'
     **** ****     > CHAR
0004 07CD   77            byte 'T' ^ RE
                   < elite.a99
2467 07CE 00              byte >00
2468               
2469                      .cont 8                                             ; Token 146:    "{all caps}GAME OVER"
     **** ****     > CONT
0001 07CF   2B            byte 8 ^ RE
                   < elite.a99
2470                      .char 'G'                                           ;
     **** ****     > CHAR
0004 07D0 64              byte 'G' ^ RE
                   < elite.a99
2471                      .char 'A'                                           ; Encoded as:   "{8}GAME O<150>R"
     **** ****     > CHAR
0004 07D1   62            byte 'A' ^ RE
                   < elite.a99
2472                      .char 'M'
     **** ****     > CHAR
0004 07D2 6E              byte 'M' ^ RE
                   < elite.a99
2473                      .char 'E'
     **** ****     > CHAR
0004 07D3   66            byte 'E' ^ RE
                   < elite.a99
2474                      .char ' '
     **** ****     > CHAR
0004 07D4 03              byte ' ' ^ RE
                   < elite.a99
2475                      .char 'O'
     **** ****     > CHAR
0004 07D5   6C            byte 'O' ^ RE
                   < elite.a99
2476 07D6 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2477                      .char 'R'
     **** ****     > CHAR
0004 07D7   71            byte 'R' ^ RE
                   < elite.a99
2478 07D8 00              byte >00
2479               
2480                      .char 'P'                                           ; Token 147:    "PRESS FIRE OR SPACE,COMMANDER.{crlf}
     **** ****     > CHAR
0004 07D9   73            byte 'P' ^ RE
                   < elite.a99
2481                      .char 'R'                                           ; {crlf}
     **** ****     > CHAR
0004 07DA 71              byte 'R' ^ RE
                   < elite.a99
2482 07DB   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' "
2483                      .char 'S'                                           ;
     **** ****     > CHAR
0004 07DC 70              byte 'S' ^ RE
                   < elite.a99
2484                      .char ' '                                           ; Encoded as:   "PR<137>S FI<142> <153> SPA<133>,[92].
     **** ****     > CHAR
0004 07DD   03            byte ' ' ^ RE
                   < elite.a99
2485                      .char 'F'                                           ; {13}{13}"
     **** ****     > CHAR
0004 07DE 65              byte 'F' ^ RE
                   < elite.a99
2486                      .char 'I'
     **** ****     > CHAR
0004 07DF   6A            byte 'I' ^ RE
                   < elite.a99
2487 07E0 AD              byte 142 ^ RE                                       ; TWOK 'R', 'E' null
2488                      .char ' '
     **** ****     > CHAR
0004 07E1   03            byte ' ' ^ RE
                   < elite.a99
2489 07E2 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2490                      .char ' '
     **** ****     > CHAR
0004 07E3   03            byte ' ' ^ RE
                   < elite.a99
2491                      .char 'S'
     **** ****     > CHAR
0004 07E4 70              byte 'S' ^ RE
                   < elite.a99
2492                      .char 'P'
     **** ****     > CHAR
0004 07E5   73            byte 'P' ^ RE
                   < elite.a99
2493                      .char 'A'
     **** ****     > CHAR
0004 07E6 62              byte 'A' ^ RE
                   < elite.a99
2494 07E7   A6            byte 133 ^ RE                                       ; TWOK 'C', 'E' null
2495                      .char ','
     **** ****     > CHAR
0004 07E8 0F              byte ',' ^ RE
                   < elite.a99
2496                      .rtok 92
     **** ****     > RTOK
0003 07E9   DF            byte (92 + 160) ^ RE
                   < elite.a99
2497                      .char '.'
     **** ****     > CHAR
0004 07EA 0D              byte '.' ^ RE
                   < elite.a99
2498                      .cont 13
     **** ****     > CONT
0001 07EB   2E            byte 13 ^ RE
                   < elite.a99
2499                      .cont 13
     **** ****     > CONT
0001 07EC 2E              byte 13 ^ RE
                   < elite.a99
2500 07ED   00            byte >00
2501               
2502                      .char '('                                           ; Token 148:    "(C) ACORNSOFT 1984"
     **** ****     > CHAR
0004 07EE 0B              byte '(' ^ RE
                   < elite.a99
2503                      .char 'C'                                           ;
     **** ****     > CHAR
0004 07EF   60            byte 'C' ^ RE
                   < elite.a99
2504                      .char ')'                                           ; Encoded as:   "(C) AC<153>N<135>FT 1984"
     **** ****     > CHAR
0004 07F0 0A              byte ')' ^ RE
                   < elite.a99
2505                      .char ' '
     **** ****     > CHAR
0004 07F1   03            byte ' ' ^ RE
                   < elite.a99
2506                      .char 'A'
     **** ****     > CHAR
0004 07F2 62              byte 'A' ^ RE
                   < elite.a99
2507                      .char 'C'
     **** ****     > CHAR
0004 07F3   60            byte 'C' ^ RE
                   < elite.a99
2508 07F4 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2509                      .char 'N'
     **** ****     > CHAR
0004 07F5   6D            byte 'N' ^ RE
                   < elite.a99
2510 07F6 A4              byte 135 ^ RE                                       ; TWOK 'S', 'O' null
2511                      .char 'F'
     **** ****     > CHAR
0004 07F7   65            byte 'F' ^ RE
                   < elite.a99
2512                      .char 'T'
     **** ****     > CHAR
0004 07F8 77              byte 'T' ^ RE
                   < elite.a99
2513                      .char ' '
     **** ****     > CHAR
0004 07F9   03            byte ' ' ^ RE
                   < elite.a99
2514                      .char '1'
     **** ****     > CHAR
0004 07FA 12              byte '1' ^ RE
                   < elite.a99
2515                      .char '9'
     **** ****     > CHAR
0004 07FB   1A            byte '9' ^ RE
                   < elite.a99
2516                      .char '8'
     **** ****     > CHAR
0004 07FC 1B              byte '8' ^ RE
                   < elite.a99
2517                      .char '4'
     **** ****     > CHAR
0004 07FD   17            byte '4' ^ RE
                   < elite.a99
2518 07FE 00              byte >00
2519               
2520               * ******************************************************************************
2521               *
2522               * Save WORDS9.bin
2523               *
2524               * ******************************************************************************
2525               
2526                      ; PRINT "WORDS9"
2527                      ; PRINT "Assembled at ", ~CODE_WORDS%
2528                      ; PRINT "Ends at ", ~P%
2529                      ; PRINT "Code size is ", ~(P% - CODE_WORDS%)
2530                      ; PRINT "Execute at ", ~LOAD_WORDS%
2531                      ; PRINT "Reload at ", ~LOAD_WORDS%
2532               
2533                      ; PRINT "S.WORDS9 ",~CODE_WORDS%," ",~P%," ",~LOAD_WORDS%," ",~LOAD_WORDS%
2534                      ; SAVE "3-assembled-output/WORDS9.bin", CODE_WORDS%, P%, LOAD_WORDS%
2535               
2536               * ******************************************************************************
2537               *
2538               * Name: K%
2539               * Type: Workspace
2540               * Address: &0900 to &0AAF
2541               * Category: Workspaces
2542               * Summary: Ship data blocks and ship line heaps
2543               * Deep dive: Ship data blocks
2544               * The local bubble of universe
2545               *
2546               * ------------------------------------------------------------------------------
2547               *
2548               * Contains ship data for all the ships, planets, suns and space stations in our
2549               * local bubble of universe, along with their corresponding ship line heaps.
2550               *
2551               * The blocks are pointed to by the lookup table at location UNIV. The first 432
2552               * bytes of the K% workspace hold ship data on up to 12 ships, with 36 (NI%)
2553               * bytes per ship, and the ship line heap grows downwards from WP at the end of
2554               * the K% workspace.
2555               *
2556               * See the deep dive on "Ship data blocks" for details on ship data blocks, and
2557               * the deep dive on "The local bubble of universe" for details of how Elite
2558               * stores the local universe in K%, FRIN and UNIV.
2559               *
2560               * ******************************************************************************
2561               
2562                      aorg K.
2563               
2564 0900                 bss NOSH * NI.                                      ; Ship data blocks and ship line heap
2565               
2566               * ******************************************************************************
2567               *
2568               * Name: WP
2569               * Type: Workspace
2570               * Address: &0D40 to &0F33
2571               * Category: Workspaces
2572               * Summary: Ship slots, variables
2573               *
2574               * ******************************************************************************
2575               
2576                      aorg WP.
2577               
2578 0D40                 bss 0                                               ; The start of the WP workspace
2579               
2580               FRIN:
2581 0D40                 bss NOSH + 1                                        ; Slots for the ships in the local bubble of universe
2582                                                                          ;
2583                                                                          ; There are #NOSH + 1 slots, but the ship-spawning
2584                                                                          ; routine at NWSHP only populates #NOSH of them, so
2585                                                                          ; there are 13 slots but only 12 are used for ships
2586                                                                          ; (the last slot is effectively used as a null
2587                                                                          ; terminator when shuffling the slots down in the
2588                                                                          ; KILLSHP routine)
2589                                                                          ;
2590                                                                          ; See the deep dive on "The local bubble of universe"
2591                                                                          ; for details of how Elite stores the local universe in
2592                                                                          ; FRIN, UNIV and K%
2593               
2594               CABTMP:
2595 0D4D                 bss 0                                               ; Cabin temperature
2596                                                                          ;
2597                                                                          ; The ambient cabin temperature in deep space is 30,
2598                                                                          ; which is displayed as one notch on the dashboard bar
2599                                                                          ;
2600                                                                          ; We get higher temperatures closer to the sun
2601                                                                          ;
2602                                                                          ; CABTMP shares a location with MANY, but that's OK as
2603                                                                          ; MANY+0 would contain the number of ships of type 0,
2604                                                                          ; and as there is no ship type 0 (they start at 1), the
2605                                                                          ; byte at MANY+0 is not used for storing a ship type
2606                                                                          ; and can be used for the cabin temperature instead
2607               
2608               MANY:
2609 0D4D                 bss SST                                             ; The number of ships of each type in the local bubble
2610                                                                          ; of universe
2611                                                                          ;
2612                                                                          ; The number of ships of type X in the local bubble is
2613                                                                          ; stored at MANY+X
2614                                                                          ;
2615                                                                          ; See the deep dive on "Ship blueprints" for a list of
2616                                                                          ; ship types
2617               
2618               SSPR:
2619 0D55                 bss NTY + 1 - SST                                   ; "Space station present" flag
2620                                                                          ;
2621                                                                          ; * Non-zero if we are inside the space station's safe
2622                                                                          ; zone
2623                                                                          ;
2624                                                                          ; * 0 if we aren't (in which case we can show the sun)
2625                                                                          ;
2626                                                                          ; This flag is at MANY+SST, which is no coincidence, as
2627                                                                          ; MANY+SST is a count of how many space stations there
2628                                                                          ; are in our local bubble, which is the same as saying
2629                                                                          ; "space station present"
2630               
2631               ECMP:
2632 0D5B                 bss 1                                               ; Our E.C.M. status
2633                                                                          ;
2634                                                                          ; * 0 = E.C.M. is off
2635                                                                          ;
2636                                                                          ; * Non-zero = E.C.M. is on
2637               
2638               MJ:
2639 0D5C                 bss 1                                               ; Are we in witchspace (i.e. have we mis-jumped)?
2640                                                                          ;
2641                                                                          ; * 0 = no, we are in normal space
2642                                                                          ;
2643                                                                          ; * &FF = yes, we are in witchspace
2644               
2645               LAS2:
2646 0D5D                 bss 1                                               ; Laser power for the current laser
2647                                                                          ;
2648                                                                          ; * Bits 0-6 contain the laser power of the current
2649                                                                          ; space view
2650                                                                          ;
2651                                                                          ; * Bit 7 denotes whether or not the laser pulses:
2652                                                                          ;
2653                                                                          ; * 0 = pulsing laser
2654                                                                          ;
2655                                                                          ; * 1 = beam laser (i.e. always on)
2656               
2657               MSAR:
2658 0D5E                 bss 1                                               ; The targeting state of our leftmost missile
2659                                                                          ;
2660                                                                          ; * 0 = missile is not looking for a target, or it
2661                                                                          ; already has a target lock (indicator is not
2662                                                                          ; yellow/white)
2663                                                                          ;
2664                                                                          ; * Non-zero = missile is currently looking for a
2665                                                                          ; target (indicator is yellow/white)
2666               
2667               VIEW:
2668 0D5F                 bss 1                                               ; The number of the current space view
2669                                                                          ;
2670                                                                          ; * 0 = front
2671                                                                          ; * 1 = rear
2672                                                                          ; * 2 = left
2673                                                                          ; * 3 = right
2674               
2675               LASCT:
2676 0D60                 bss 1                                               ; The laser pulse count for the current laser
2677                                                                          ;
2678                                                                          ; This is a counter that defines the gap between the
2679                                                                          ; pulses of a pulse laser. It is set as follows:
2680                                                                          ;
2681                                                                          ; * 0 for a beam laser
2682                                                                          ;
2683                                                                          ; * 10 for a pulse laser
2684                                                                          ;
2685                                                                          ; It gets decremented every vertical sync (in the LINSCN
2686                                                                          ; routine, which is called 50 times a second) and is set
2687                                                                          ; to a non-zero value for pulse lasers only
2688                                                                          ;
2689                                                                          ; The laser only fires when the value of LASCT hits
2690                                                                          ; zero, so for pulse lasers with a value of 10, that
2691                                                                          ; means the laser fires once every 10 vertical syncs (or
2692                                                                          ; 5 times a second)
2693                                                                          ;
2694                                                                          ; In comparison, beam lasers fire continuously as the
2695                                                                          ; value of LASCT is always 0
2696               
2697               GNTMP:
2698 0D61                 bss 1                                               ; Laser temperature (or "gun temperature")
2699                                                                          ;
2700                                                                          ; If the laser temperature exceeds 242 then the laser
2701                                                                          ; overheats and cannot be fired again until it has
2702                                                                          ; cooled down
2703               
2704               HFX:
2705 0D62                 bss 1                                               ; A flag that toggles the hyperspace colour effect
2706                                                                          ;
2707                                                                          ; * 0 = no colour effect
2708                                                                          ;
2709                                                                          ; * Non-zero = hyperspace colour effect enabled
2710                                                                          ;
2711                                                                          ; When HFX is set to 1, the mode 4 screen that makes
2712                                                                          ; up the top part of the display is temporarily switched
2713                                                                          ; to mode 5 (the same screen mode as the dashboard),
2714                                                                          ; which has the effect of blurring and colouring the
2715                                                                          ; hyperspace rings in the top part of the screen. The
2716                                                                          ; code to do this is in the LINSCN routine, which is
2717                                                                          ; called as part of the screen mode routine at IRQ1.
2718                                                                          ; It's in LINSCN that HFX is checked, and if it is
2719                                                                          ; non-zero, the top part of the screen is not switched
2720                                                                          ; to mode 4, thus leaving the top part of the screen in
2721                                                                          ; the more colourful mode 5
2722               
2723               EV:
2724 0D63                 bss 1                                               ; The "extra vessels" spawning counter
2725                                                                          ;
2726                                                                          ; This counter is set to 0 on arrival in a system and
2727                                                                          ; following an in-system jump, and is bumped up when we
2728                                                                          ; spawn bounty hunters or pirates (i.e. "extra vessels")
2729                                                                          ;
2730                                                                          ; It decreases by 1 each time we consider spawning more
2731                                                                          ; "extra vessels" in part 4 of the main game loop, so
2732                                                                          ; increasing the value of EV has the effect of delaying
2733                                                                          ; the spawning of more vessels
2734                                                                          ;
2735                                                                          ; In other words, this counter stops bounty hunters and
2736                                                                          ; pirates from continually appearing, and ensures that
2737                                                                          ; there's a delay between spawnings
2738               
2739               DLY:
2740 0D64                 bss 1                                               ; In-flight message delay
2741                                                                          ;
2742                                                                          ; This counter is used to keep an in-flight message up
2743                                                                          ; for a specified time before it gets removed. The value
2744                                                                          ; in DLY is decremented each time we start another
2745                                                                          ; iteration of the main game loop at TT100
2746               
2747               de_:
2748 0D65                 bss 1                                               ; Equipment destruction flag
2749                                                                          ;
2750                                                                          ; * Bit 1 denotes whether or not the in-flight message
2751                                                                          ; about to be shown by the MESS routine is about
2752                                                                          ; destroyed equipment:
2753                                                                          ;
2754                                                                          ; * 0 = the message is shown normally
2755                                                                          ;
2756                                                                          ; * 1 = the string " DESTROYED" gets added to the
2757                                                                          ; end of the message
2758               
2759               LSX:
2760 0D66                 bss 0                                               ; LSX is an alias that points to the first byte of the
2761                                                                          ; sun line heap at LSO
2762                                                                          ;
2763                                                                          ; * &FF indicates the sun line heap is empty
2764                                                                          ;
2765                                                                          ; * Otherwise the LSO heap contains the line data for
2766                                                                          ; the sun
2767               
2768               LSO:
2769 0D66                 bss 192                                             ; The ship line heap for the space station (see NWSPS)
2770                                                                          ; and the sun line heap (see SUN)
2771                                                                          ;
2772                                                                          ; The spaces can be shared as our local bubble of
2773                                                                          ; universe can support either the sun or a space
2774                                                                          ; station, but not both
2775               
2776               LSX2:
2777 0E26                 bss 78                                              ; The ball line heap for storing x-coordinates (see the
2778                                                                          ; deep dive on "The ball line heap" for details)
2779               
2780               LSY2:
2781 0E74                 bss 78                                              ; The ball line heap for storing y-coordinates (see the
2782                                                                          ; deep dive on "The ball line heap" for details)
2783               
2784               SY:
2785 0EC2                 bss NOST + 1                                        ; This is where we store the y_hi coordinates for all
2786                                                                          ; the stardust particles
2787               
2788               SYL:
2789 0ED5                 bss NOST + 1                                        ; This is where we store the y_lo coordinates for all
2790                                                                          ; the stardust particles
2791               
2792               SZ:
2793 0EE8                 bss NOST + 1                                        ; This is where we store the z_hi coordinates for all
2794                                                                          ; the stardust particles
2795               
2796               SZL:
2797 0EFB                 bss NOST + 1                                        ; This is where we store the z_lo coordinates for all
2798                                                                          ; the stardust particles
2799               
2800               XSAV2:
2801 0F0E                 bss 1                                               ; Temporary storage, used for storing the value of the X
2802                                                                          ; register in the TT26 routine
2803               
2804               YSAV2:
2805 0F0F                 bss 1                                               ; Temporary storage, used for storing the value of the Y
2806                                                                          ; register in the TT26 routine
2807               
2808               MCH:
2809 0F10                 bss 1                                               ; The text token number of the in-flight message that is
2810                                                                          ; currently being shown, and which will be removed by
2811                                                                          ; the me2 routine when the counter in DLY reaches zero
2812               
2813               FSH:
2814 0F11                 bss 1                                               ; Forward shield status
2815                                                                          ;
2816                                                                          ; * 0 = empty
2817                                                                          ;
2818                                                                          ; * &FF = full
2819               
2820               ASH:
2821 0F12                 bss 1                                               ; Aft shield status
2822                                                                          ;
2823                                                                          ; * 0 = empty
2824                                                                          ;
2825                                                                          ; * &FF = full
2826               
2827               ENERGY:
2828 0F13                 bss 1                                               ; Energy bank status
2829                                                                          ;
2830                                                                          ; * 0 = empty
2831                                                                          ;
2832                                                                          ; * &FF = full
2833               
2834               LASX:
2835 0F14                 bss 1                                               ; The x-coordinate of the tip of the laser line
2836               
2837               LASY:
2838 0F15                 bss 1                                               ; The y-coordinate of the tip of the laser line
2839               
2840               COMX:
2841 0F16                 bss 1                                               ; The x-coordinate of the compass dot
2842               
2843               COMY:
2844 0F17                 bss 1                                               ; The y-coordinate of the compass dot
2845               
2846               QQ24:
2847 0F18                 bss 1                                               ; Temporary storage, used to store the current market
2848                                                                          ; item's price in routine TT151
2849               
2850               QQ25:
2851 0F19                 bss 1                                               ; Temporary storage, used to store the current market
2852                                                                          ; item's availability in routine TT151
2853               
2854               QQ28:
2855 0F1A                 bss 1                                               ; The current system's economy (0-7)
2856                                                                          ;
2857                                                                          ; * 0 = Rich Industrial
2858                                                                          ; * 1 = Average Industrial
2859                                                                          ; * 2 = Poor Industrial
2860                                                                          ; * 3 = Mainly Industrial
2861                                                                          ; * 4 = Mainly Agricultural
2862                                                                          ; * 5 = Rich Agricultural
2863                                                                          ; * 6 = Average Agricultural
2864                                                                          ; * 7 = Poor Agricultural
2865                                                                          ;
2866                                                                          ; See the deep dive on "Generating system data" for more
2867                                                                          ; information on economies
2868               
2869               QQ29:
2870 0F1B                 bss 1                                               ; Temporary storage, used in a number of places
2871               
2872               gov_:
2873 0F1C                 bss 1                                               ; The current system's government type (0-7)
2874                                                                          ;
2875                                                                          ; See the deep dive on "Generating system data" for
2876                                                                          ; details of the various government types
2877               
2878               tek_:
2879 0F1D                 bss 1                                               ; The current system's tech level (0-14)
2880                                                                          ;
2881                                                                          ; See the deep dive on "Generating system data" for more
2882                                                                          ; information on tech levels
2883               
2884               SLSP:
2885 0F1E                 bss 2                                               ; The address of the bottom of the ship line heap
2886                                                                          ;
2887                                                                          ; The ship line heap is a descending block of memory
2888                                                                          ; that starts at WP and descends down to SLSP. It can be
2889                                                                          ; extended downwards by the NWSHP routine when adding
2890                                                                          ; new ships (and their associated ship line heaps), in
2891                                                                          ; which case SLSP is lowered to provide more heap space,
2892                                                                          ; assuming there is enough free memory to do so
2893               
2894               XX24:
2895 0F20                 bss 1                                               ; This byte appears to be unused
2896               
2897               ALTIT:
2898 0F21                 bss 1                                               ; Our altitude above the surface of the planet or sun
2899                                                                          ;
2900                                                                          ; * 255 = we are a long way above the surface
2901                                                                          ;
2902                                                                          ; * 1-254 = our altitude as the square root of:
2903                                                                          ;
2904                                                                          ; x_hi^2 + y_hi^2 + z_hi^2 - 6^2
2905                                                                          ;
2906                                                                          ; where our ship is at the origin, the centre of the
2907                                                                          ; planet/sun is at (x_hi, y_hi, z_hi), and the
2908                                                                          ; radius of the planet/sun is 6
2909                                                                          ;
2910                                                                          ; * 0 = we have crashed into the surface
2911               
2912               QQ2:
2913 0F22                 bss 6                                               ; The three 16-bit seeds for the current system, i.e.
2914                                                                          ; the one we are currently in
2915                                                                          ;
2916                                                                          ; See the deep dives on "Galaxy and system seeds" and
2917                                                                          ; "Twisting the system seeds" for more details
2918               
2919               QQ3:
2920 0F28                 bss 1                                               ; The selected system's economy (0-7)
2921                                                                          ;
2922                                                                          ; * 0 = Rich Industrial
2923                                                                          ; * 1 = Average Industrial
2924                                                                          ; * 2 = Poor Industrial
2925                                                                          ; * 3 = Mainly Industrial
2926                                                                          ; * 4 = Mainly Agricultural
2927                                                                          ; * 5 = Rich Agricultural
2928                                                                          ; * 6 = Average Agricultural
2929                                                                          ; * 7 = Poor Agricultural
2930                                                                          ;
2931                                                                          ; See the deep dive on "Generating system data" for more
2932                                                                          ; information on economies
2933               
2934               QQ4:
2935 0F29                 bss 1                                               ; The selected system's government (0-7)
2936                                                                          ;
2937                                                                          ; See the deep dive on "Generating system data" for more
2938                                                                          ; details of the various government types
2939               
2940               QQ5:
2941 0F2A                 bss 1                                               ; The selected system's tech level (0-14)
2942                                                                          ;
2943                                                                          ; See the deep dive on "Generating system data" for more
2944                                                                          ; information on tech levels
2945               
2946               QQ6:
2947 0F2B                 bss 2                                               ; The selected system's population in billions * 10
2948                                                                          ; (1-71), so the maximum population is 7.1 billion
2949                                                                          ;
2950                                                                          ; See the deep dive on "Generating system data" for more
2951                                                                          ; details on population levels
2952               
2953               QQ7:
2954 0F2D                 bss 2                                               ; The selected system's productivity in M CR (96-62480)
2955                                                                          ;
2956                                                                          ; See the deep dive on "Generating system data" for more
2957                                                                          ; details about productivity levels
2958               
2959               QQ8:
2960 0F2F                 bss 2                                               ; The distance from the current system to the selected
2961                                                                          ; system in light years * 10, stored as a 16-bit number
2962                                                                          ;
2963                                                                          ; The distance will be 0 if the selected system is the
2964                                                                          ; current system
2965                                                                          ;
2966                                                                          ; The galaxy chart is 102.4 light years wide and 51.2
2967                                                                          ; light years tall (see the intra-system distance
2968                                                                          ; calculations in routine TT111 for details), which
2969                                                                          ; equates to 1024 x 512 in terms of QQ8
2970               
2971               QQ9:
2972 0F31                 bss 1                                               ; The galactic x-coordinate of the crosshairs in the
2973                                                                          ; galaxy chart (and, most of the time, the selected
2974                                                                          ; system's galactic x-coordinate)
2975               
2976               QQ10:
2977 0F32                 bss 1                                               ; The galactic y-coordinate of the crosshairs in the
2978                                                                          ; galaxy chart (and, most of the time, the selected
2979                                                                          ; system's galactic y-coordinate)
2980               
2981               NOSTM:
2982 0F33                 bss 1                                               ; The number of stardust particles shown on screen,
2983                                                                          ; which is 18 (#NOST) for normal space, and 3 for
2984                                                                          ; witchspace
2985               
2986                      ; PRINT "WP workspace from  ", ~WP," to ", ~P%
2987               
2988               * ******************************************************************************
2989               *
2990               * ELITE A FILE
2991               *
2992               * Produces the binary file ELTA.bin that gets loaded by elite-bcfs.asm.
2993               *
2994               * The main game code (ELITE A through G, plus the ship data) is loaded at &1128
2995               * and is moved down to &0F40 as part of elite-loader.asm.
2996               *
2997               * ******************************************************************************
2998               
2999                      aorg CODE.
3000               
3001               LOAD_A.:
3002                      equ LOAD.
3003               
3004               * ******************************************************************************
3005               *
3006               * Name: S%
3007               * Type: Workspace
3008               * Address: &0F40 to &0F50
3009               * Category: Workspaces
3010               * Summary: Vector addresses, compass colour and configuration settings
3011               *
3012               * ------------------------------------------------------------------------------
3013               *
3014               * Contains addresses that are used by the loader to set up vectors, the current
3015               * compass colour, and the game's configuration settings.
3016               *
3017               * ******************************************************************************
3018               
3019               S.:
3020 0F40 8598            data TT170                                          ; The entry point for the main game; once the main code
3021                                                                          ; has been loaded, decrypted and moved to the right
3022                                                                          ; place by elite-loader.asm, the game is started by a
3023                                                                          ; JMP (S%) instruction, which jumps to the main entry
3024                                                                          ; point at TT170 via this location
3025               
3026 0F42 3172            data TT26                                           ; WRCHV is set to point here by elite-loader.asm
3027               
3028 0F44 35EA            data IRQ1                                           ; IRQ1V is set to point here by elite-loader.asm
3029               
3030 0F46 85A0            data BR1                                            ; BRKV is set to point here by elite-loader.asm
3031               
3032               COMC:
3033 0F48                 bss 1                                               ; The colour of the dot on the compass
3034                                                                          ;
3035                                                                          ; * &F0 = the object in the compass is in front of us,
3036                                                                          ; so the dot is yellow/white
3037                                                                          ;
3038                                                                          ; * &FF = the object in the compass is behind us, so
3039                                                                          ; the dot is green/cyan
3040               
3041               DNOIZ:
3042 0F49                 bss 1                                               ; Sound on/off configuration setting
3043                                                                          ;
3044                                                                          ; * 0 = sound is on (default)
3045                                                                          ;
3046                                                                          ; * Non-zero = sound is off
3047                                                                          ;
3048                                                                          ; Toggled by pressing "S" when paused, see the DK4
3049                                                                          ; routine for details
3050               
3051               DAMP:
3052 0F4A                 bss 1                                               ; Keyboard damping configuration setting
3053                                                                          ;
3054                                                                          ; * 0 = damping is enabled (default)
3055                                                                          ;
3056                                                                          ; * &FF = damping is disabled
3057                                                                          ;
3058                                                                          ; Toggled by pressing CAPS LOCK when paused, see the
3059                                                                          ; DKS3 routine for details
3060               
3061               DJD:
3062 0F4B                 bss 1                                               ; Keyboard auto-recentre configuration setting
3063                                                                          ;
3064                                                                          ; * 0 = auto-recentre is enabled (default)
3065                                                                          ;
3066                                                                          ; * &FF = auto-recentre is disabled
3067                                                                          ;
3068                                                                          ; Toggled by pressing "A" when paused, see the DKS3
3069                                                                          ; routine for details
3070               
3071               PATG:
3072 0F4C                 bss 1                                               ; Configuration setting to show the author names on the
3073                                                                          ; start-up screen and enable manual hyperspace mis-jumps
3074                                                                          ;
3075                                                                          ; * 0 = no author names or manual mis-jumps (default)
3076                                                                          ;
3077                                                                          ; * &FF = show author names and allow manual mis-jumps
3078                                                                          ;
3079                                                                          ; Toggled by pressing "X" when paused, see the DKS3
3080                                                                          ; routine for details
3081                                                                          ;
3082                                                                          ; This needs to be turned on for manual mis-jumps to be
3083                                                                          ; possible. To do a manual mis-jump, first toggle the
3084                                                                          ; author display by pausing the game (COPY) and pressing
3085                                                                          ; "X", and during the next hyperspace, hold down CTRL to
3086                                                                          ; force a mis-jump. See routine ee5 for the "AND PATG"
3087                                                                          ; instruction that implements this logic
3088               
3089               FLH:
3090 0F4D                 bss 1                                               ; Flashing console bars configuration setting
3091                                                                          ;
3092                                                                          ; * 0 = static bars (default)
3093                                                                          ;
3094                                                                          ; * &FF = flashing bars
3095                                                                          ;
3096                                                                          ; Toggled by pressing "F" when paused, see the DKS3
3097                                                                          ; routine for details
3098               
3099               JSTGY:
3100 0F4E                 bss 1                                               ; Reverse joystick Y-channel configuration setting
3101                                                                          ;
3102                                                                          ; * 0 = standard Y-channel (default)
3103                                                                          ;
3104                                                                          ; * &FF = reversed Y-channel
3105                                                                          ;
3106                                                                          ; Toggled by pressing "Y" when paused, see the DKS3
3107                                                                          ; routine for details
3108               
3109               JSTE:
3110 0F4F                 bss 1                                               ; Reverse both joystick channels configuration setting
3111                                                                          ;
3112                                                                          ; * 0 = standard channels (default)
3113                                                                          ;
3114                                                                          ; * &FF = reversed channels
3115                                                                          ;
3116                                                                          ; Toggled by pressing "J" when paused, see the DKS3
3117                                                                          ; routine for details
3118               
3119               JSTK:
3120 0F50                 bss 1                                               ; Keyboard or joystick configuration setting
3121                                                                          ;
3122                                                                          ; * 0 = keyboard (default)
3123                                                                          ;
3124                                                                          ; * &FF = joystick
3125                                                                          ;
3126                                                                          ; Toggled by pressing "K" when paused, see the DKS3
3127                                                                          ; routine for details
3128               
3129               * ******************************************************************************
3130               *
3131               * Name: Main flight loop (Part 1 of 16)
3132               * Type: Subroutine
3133               * Category: Main loop
3134               * Summary: Seed the random number generator
3135               * Deep dive: Program flow of the main game loop
3136               * Generating random numbers
3137               *
3138               * ------------------------------------------------------------------------------
3139               *
3140               * The main flight loop covers most of the flight-specific aspects of Elite. This
3141               * section covers the following:
3142               *
3143               * * Seed the random number generator
3144               *
3145               * ------------------------------------------------------------------------------
3146               *
3147               * Other entry points:
3148               *
3149               * M%                  The entry point for the main flight loop
3150               *
3151               * ******************************************************************************
3152               
3153               M.:
3154 0F52 D020  22        movb @K.,ra                     ; LDA K%            ; We want to seed the random number generator with a
     0F54 0900     
3155                                                                          ; pretty random number, so fetch the contents of K%,
3156                                                                          ; which is the x_lo coordinate of the planet. This value
3157                                                                          ; will be fairly unpredictable, so it's a pretty good
3158                                                                          ; candidate
3159               
3160 0F56 D800  22        movb ra,@RAND                   ; STA RAND          ; Store the seed in the first byte of the four-byte
     0F58 0000     
3161                                                                          ; random number seed that's stored in RAND
3162               
3163               * ******************************************************************************
3164               *
3165               * Name: Main flight loop (Part 2 of 16)
3166               * Type: Subroutine
3167               * Category: Main loop
3168               * Summary: Calculate the alpha and beta angles from the current pitch and
3169               * roll of our ship
3170               * Deep dive: Program flow of the main game loop
3171               * Pitching and rolling
3172               *
3173               * ------------------------------------------------------------------------------
3174               *
3175               * The main flight loop covers most of the flight-specific aspects of Elite. This
3176               * section covers the following:
3177               *
3178               * * Calculate the alpha and beta angles from the current pitch and roll
3179               *
3180               * Here we take the current rate of pitch and roll, as set by the joystick or
3181               * keyboard, and convert them into alpha and beta angles that we can use in the
3182               * matrix functions to rotate space around our ship. The alpha angle covers
3183               * roll, while the beta angle covers pitch (there is no yaw in this version of
3184               * Elite). The angles are in radians, which allows us to use the small angle
3185               * approximation when moving objects in the sky (see the MVEIT routine for more
3186               * on this). Also, the signs of the two angles are stored separately, in both
3187               * the sign and the flipped sign, as this makes calculations easier.
3188               *
3189               * ******************************************************************************
3190               
3191 0F5A D060  22        movb @JSTX,rx                   ; LDX JSTX          ; Set X to the current rate of roll in JSTX
     0F5C 009C     
3192               
3193 0F5E 0206  12        li   rtmp,cntr_                 ; JSR cntr          ; Apply keyboard damping twice (if enabled) so the roll
     0F60 4714     
3194 0F62 06A0  20        bl   @jsr                       ;
     0F64 8002     
3195 0F66 0206  12        li   rtmp,cntr_                 ; JSR cntr          ; rate in X creeps towards the centre by 2
     0F68 4714     
3196 0F6A 06A0  20        bl   @jsr                       ;
     0F6C 8002     
3197               
3198                                                                          ; The roll rate in JSTX increases if we press ">" (and
3199                                                                          ; the RL indicator on the dashboard goes to the right)
3200                                                                          ;
3201                                                                          ; This rolls our ship to the right (clockwise), but we
3202                                                                          ; actually implement this by rolling everything else
3203                                                                          ; to the left (anti-clockwise), so a positive roll rate
3204                                                                          ; in JSTX translates to a negative roll angle alpha
3205               
3206 0F6E D001  14        movb rx,ra                      ; TXA               ; Set A and Y to the roll rate but with the sign bit
3207                      .eoi (>80*256)                  ; EOR #%10000000    ; flipped (i.e. set them to the sign we want for alpha)
     **** ****     > EOI
0001 0F70 0206  12        li   rtmp,(>80*256)
     0F72 8000     
0002 0F74 2806  14        xor  rtmp,ra
                   < elite.a99
3208 0F76 D080  14        movb ra,ry                      ; TAY
3209               
3210 0F78 0240  14        andi ra,>80*256                 ; AND #%10000000    ; Extract the flipped sign of the roll rate and store
     0F7A 8000     
3211 0F7C D800  22        movb ra,@ALP2                   ; STA ALP2          ; in ALP2 (so ALP2 contains the sign of the roll angle
     0F7E 0088     
3212                                                                          ; alpha)
3213               
3214 0F80 D801  22        movb rx,@JSTX                   ; STX JSTX          ; Update JSTX with the damped value that's still in X
     0F82 009C     
3215               
3216                      .eoi (>80*256)                  ; EOR #%10000000    ; Extract the correct sign of the roll rate and store
     **** ****     > EOI
0001 0F84 0206  12        li   rtmp,(>80*256)
     0F86 8000     
0002 0F88 2806  14        xor  rtmp,ra
                   < elite.a99
3217 0F8A D800  22        movb ra,@ALP2+1                 ; STA ALP2+1        ; in ALP2+1 (so ALP2+1 contains the flipped sign of the
     0F8C 0089     
3218                                                                          ; roll angle alpha)
3219               
3220 0F8E D002  14        movb ry,ra                      ; TYA               ; Set A to the roll rate but with the sign bit flipped
3221               
3222 0F90 1508  10        jgt  B01                        ; BPL B01           ; If the value of A is positive, skip the following
3223                                                                          ; three instructions
3224               
3225                      .eoi (>ff*256)                  ; EOR #%11111111    ; A is negative, so change the sign of A using two's
     **** ****     > EOI
0001 0F92 0206  12        li   rtmp,(>FF*256)
     0F94 FF00     
0002 0F96 2806  14        xor  rtmp,ra
                   < elite.a99
3226                      .clc                            ; CLC               ; complement so that A is now positive and contains
     **** ****     > CLC
0001 0F98 0A13  14        sla  rzero,1
                   < elite.a99
3227                      .adi (>01*256)                  ; ADC #1            ; the absolute value of the roll rate, i.e. |JSTX|
     **** ****     > ADI
0001 0F9A 1701  10        jnc  !
0002 0F9C B004  14        ab   rone,ra
0003               !:
0004 0F9E 0220  14        ai   ra,(>01*256)
     0FA0 0100     
                   < elite.a99
3228               
3229               B01:
3230 0FA2 0910  14        srl  ra,1                       ; LSR A             ; Divide the (positive) roll rate in A by 4
3231 0FA4 0910  14        srl  ra,1                       ; LSR A
3232               
3233 0FA6 0280  14        ci   ra,>08*256                 ; CMP #8            ; If A >= 8, skip the following two instructions
     0FA8 0800     
3234 0FAA 1802  10        joc  B02                        ; BCS B02
3235               
3236 0FAC 0910  14        srl  ra,1                       ; LSR A             ; A < 8, so halve A again
3237               
3238                      .clc                            ; CLC               ; This instruction has no effect, as we only get here
     **** ****     > CLC
0001 0FAE 0A13  14        sla  rzero,1
                   < elite.a99
3239                                                                          ; if the C flag is clear (if it is set, we skip this
3240                                                                          ; instruction)
3241               B02:
3242 0FB0 D800  22        movb ra,@ALP1                   ; STA ALP1          ; Store A in ALP1, so we now have:
     0FB2 0087     
3243                                                                          ;
3244                                                                          ; ALP1 = |JSTX| / 8    if |JSTX| < 32
3245                                                                          ;
3246                                                                          ; ALP1 = |JSTX| / 4    if |JSTX| >= 32
3247                                                                          ;
3248                                                                          ; This means that at lower roll rates, the roll angle is
3249                                                                          ; reduced closer to zero than at higher roll rates,
3250                                                                          ; which gives us finer control over the ship's roll at
3251                                                                          ; lower roll rates
3252                                                                          ;
3253                                                                          ; Because JSTX is in the range -127 to +127, ALP1 is
3254                                                                          ; in the range 0 to 31
3255               
3256 0FB4 F020  22        socb @ALP2,ra                   ; ORA ALP2          ; Store A in ALPHA, but with the sign set to ALP2 (so
     0FB6 0088     
3257 0FB8 D800  22        movb ra,@ALPHA                  ; STA ALPHA         ; ALPHA has a different sign to the actual roll rate)
     0FBA 009E     
3258               
3259 0FBC D060  22        movb @JSTY,rx                   ; LDX JSTY          ; Set X to the current rate of pitch in JSTY
     0FBE 009D     
3260               
3261 0FC0 0206  12        li   rtmp,cntr_                 ; JSR cntr          ; Apply keyboard damping so the pitch rate in X creeps
     0FC2 4714     
3262 0FC4 06A0  20        bl   @jsr                       ;
     0FC6 8002     
3263                                                                          ; towards the centre by 1
3264               
3265 0FC8 D001  14        movb rx,ra                      ; TXA               ; Set A and Y to the pitch rate but with the sign bit
3266                      .eoi (>80*256)                  ; EOR #%10000000    ; flipped
     **** ****     > EOI
0001 0FCA 0206  12        li   rtmp,(>80*256)
     0FCC 8000     
0002 0FCE 2806  14        xor  rtmp,ra
                   < elite.a99
3267 0FD0 D080  14        movb ra,ry                      ; TAY
3268               
3269 0FD2 0240  14        andi ra,>80*256                 ; AND #%10000000    ; Extract the flipped sign of the pitch rate into A
     0FD4 8000     
3270               
3271 0FD6 D801  22        movb rx,@JSTY                   ; STX JSTY          ; Update JSTY with the damped value that's still in X
     0FD8 009D     
3272               
3273 0FDA D800  22        movb ra,@BET2+1                 ; STA BET2+1        ; Store the flipped sign of the pitch rate in BET2+1
     0FDC 008B     
3274               
3275                      .eoi (>80*256)                  ; EOR #%10000000    ; Extract the correct sign of the pitch rate and store
     **** ****     > EOI
0001 0FDE 0206  12        li   rtmp,(>80*256)
     0FE0 8000     
0002 0FE2 2806  14        xor  rtmp,ra
                   < elite.a99
3276 0FE4 D800  22        movb ra,@BET2                   ; STA BET2          ; it in BET2
     0FE6 008A     
3277               
3278 0FE8 D002  14        movb ry,ra                      ; TYA               ; Set A to the pitch rate but with the sign bit flipped
3279               
3280 0FEA 1503  10        jgt  B03                        ; BPL B03           ; If the value of A is positive, skip the following
3281                                                                          ; instruction
3282               
3283                      .eoi (>ff*256)                  ; EOR #%11111111    ; A is negative, so flip the bits
     **** ****     > EOI
0001 0FEC 0206  12        li   rtmp,(>FF*256)
     0FEE FF00     
0002 0FF0 2806  14        xor  rtmp,ra
                   < elite.a99
3284               
3285               B03:
3286                      .adi (>04*256)                  ; ADC #4            ; Add 4 to the (positive) pitch rate, so the maximum
     **** ****     > ADI
0001 0FF2 1701  10        jnc  !
0002 0FF4 B004  14        ab   rone,ra
0003               !:
0004 0FF6 0220  14        ai   ra,(>04*256)
     0FF8 0400     
                   < elite.a99
3287                                                                          ; value is now up to 131 (rather than 127)
3288               
3289 0FFA 0910  14        srl  ra,1                       ; LSR A             ; Divide the (positive) pitch rate in A by 16
3290 0FFC 0910  14        srl  ra,1                       ; LSR A
3291 0FFE 0910  14        srl  ra,1                       ; LSR A
3292 1000 0910  14        srl  ra,1                       ; LSR A
3293               
3294 1002 0280  14        ci   ra,>03*256                 ; CMP #3            ; If A >= 3, skip the following instruction
     1004 0300     
3295 1006 1801  10        joc  B04                        ; BCS B04
3296               
3297 1008 0910  14        srl  ra,1                       ; LSR A             ; A < 3, so halve A again
3298               
3299               B04:
3300 100A D800  22        movb ra,@BET1                   ; STA BET1          ; Store A in BET1, so we now have:
     100C 002B     
3301                                                                          ;
3302                                                                          ; BET1 = |JSTY| / 32    if |JSTY| < 48
3303                                                                          ;
3304                                                                          ; BET1 = |JSTY| / 16    if |JSTY| >= 48
3305                                                                          ;
3306                                                                          ; This means that at lower pitch rates, the pitch angle
3307                                                                          ; is reduced closer to zero than at higher pitch rates,
3308                                                                          ; which gives us finer control over the ship's pitch at
3309                                                                          ; lower pitch rates
3310                                                                          ;
3311                                                                          ; Because JSTY is in the range -131 to +131, BET1 is in
3312                                                                          ; the range 0 to 8
3313               
3314 100E F020  22        socb @BET2,ra                   ; ORA BET2          ; Store A in BETA, but with the sign set to BET2 (so
     1010 008A     
3315 1012 D800  22        movb ra,@BETA                   ; STA BETA          ; BETA has the same sign as the actual pitch rate)
     1014 002A     
3316               
3317               * ******************************************************************************
3318               *
3319               * Name: Main flight loop (Part 3 of 16)
3320               * Type: Subroutine
3321               * Category: Main loop
3322               * Summary: Scan for flight keys and process the results
3323               * Deep dive: Program flow of the main game loop
3324               * The key logger
3325               *
3326               * ------------------------------------------------------------------------------
3327               *
3328               * The main flight loop covers most of the flight-specific aspects of Elite. This
3329               * section covers the following:
3330               *
3331               * * Scan for flight keys and process the results
3332               *
3333               * Flight keys are logged in the key logger at location KY1 onwards, with a
3334               * non-zero value in the relevant location indicating a key press. See the deep
3335               * dive on "The key logger" for more details.
3336               *
3337               * The key presses that are processed are as follows:
3338               *
3339               * * Space and "?" to speed up and slow down
3340               * * "U", "T" and "M" to disarm, arm and fire missiles
3341               * * TAB to fire an energy bomb
3342               * * ESCAPE to launch an escape pod
3343               * * "J" to initiate an in-system jump
3344               * * "E" to deploy E.C.M. anti-missile countermeasures
3345               * * "C" to use the docking computer
3346               * * "A" to fire lasers
3347               *
3348               * ******************************************************************************
3349               
3350 1016 D020  22        movb @KY2,ra                    ; LDA KY2           ; If Space is being pressed, keep going, otherwise jump
     1018 0043     
3351 101A 1306  10        jeq  MA17                       ; BEQ MA17          ; down to MA17 to skip the following
3352               
3353 101C D020  22        movb @DELTA,ra                  ; LDA DELTA         ; The "go faster" key is being pressed, so first we
     101E 008C     
3354 1020 0280  14        ci   ra,>28*256                 ; CMP #40           ; fetch the current speed from DELTA into A, and if
     1022 2800     
3355 1024 1801  10        joc  MA17                       ; BCS MA17          ; A >= 40, we are already going at full pelt, so jump
3356                                                                          ; down to MA17 to skip the following
3357               
3358 1026 B004  14        ab   rone,ra                    ; INC DELTA         ; We can go a bit faster, so increment the speed in
3359                                                                          ; location DELTA
3360               
3361               MA17:
3362 1028 D020  22        movb @KY1,ra                    ; LDA KY1           ; If "?" is being pressed, keep going, otherwise jump
     102A 0042     
3363 102C 1303  10        jeq  MA4                        ; BEQ MA4           ; down to MA4 to skip the following
3364               
3365 102E 7004  14        sb   rone,ra                    ; DEC DELTA         ; The "slow down" key is being pressed, so we decrement
3366                                                                          ; the current ship speed in DELTA
3367               
3368 1030 1601  10        jne  MA4                        ; BNE MA4           ; If the speed is still greater than zero, jump to MA4
3369               
3370 1032 B004  14        ab   rone,ra                    ; INC DELTA         ; Otherwise we just braked a little too hard, so bump
3371                                                                          ; the speed back up to the minimum value of 1
3372               
3373               MA4:
3374 1034 D020  22        movb @KY15,ra                   ; LDA KY15          ; If "U" is being pressed and the number of missiles
     1036 004C     
3375                      .and @NOMSL                     ; AND NOMSL         ; in NOMSL is non-zero, keep going, otherwise jump down
     **** ****     > AND
0001 1038 D1A0  22        movb @NOMSL,rtmp
     103A 0333     
0002 103C 0546  10        inv  rtmp
0003 103E 5006  14        szcb rtmp,ra
                   < elite.a99
3376 1040 1310  10        jeq  MA20                       ; BEQ MA20          ; to MA20 to skip the following
3377               
3378 1042 0202  12        li   ry,>ee*256                 ; LDY #&EE          ; The "disarm missiles" key is being pressed, so call
     1044 EE00     
3379 1046 0206  12        li   rtmp,ABORT                 ; JSR ABORT         ; ABORT to disarm the missile and update the missile
     1048 7096     
3380 104A 06A0  20        bl   @jsr                       ;
     104C 8002     
3381                                                                          ; indicators on the dashboard to green/cyan (Y = &EE)
3382               
3383 104E 0200  12        li   ra,>28*256                 ; LDA #40           ; Call the NOISE routine with A = 40 to make a low,
     1050 2800     
3384 1052 0206  12        li   rtmp,NOISE                 ; JSR NOISE         ; long beep to indicate the missile is now disarmed
     1054 8BA4     
3385 1056 06A0  20        bl   @jsr                       ;
     1058 8002     
3386               
3387               MA31:
3388 105A 0200  12        li   ra,>00*256                 ; LDA #0            ; Set MSAR to 0 to indicate that no missiles are
     105C 0000     
3389 105E D800  22        movb ra,@MSAR                   ; STA MSAR          ; currently armed
     1060 0D5E     
3390               
3391               MA20:
3392 1062 D020  22        movb @MSTG,ra                   ; LDA MSTG          ; If MSTG is positive (i.e. it does not have bit 7 set),
     1064 0052     
3393 1066 150E  10        jgt  MA25                       ; BPL MA25          ; then it indicates we already have a missile locked on
3394                                                                          ; a target (in which case MSTG contains the ship number
3395                                                                          ; of the target), so jump to MA25 to skip targeting. Or
3396                                                                          ; to put it another way, if MSTG = &FF, which means
3397                                                                          ; there is no current target lock, keep going
3398               
3399 1068 D020  22        movb @KY14,ra                   ; LDA KY14          ; If "T" is being pressed, keep going, otherwise jump
     106A 004B     
3400 106C 130B  10        jeq  MA25                       ; BEQ MA25          ; down to MA25 to skip the following
3401               
3402 106E D060  22        movb @NOMSL,rx                  ; LDX NOMSL         ; If the number of missiles in NOMSL is zero, jump down
     1070 0333     
3403 1072 1308  10        jeq  MA25                       ; BEQ MA25          ; to MA25 to skip the following
3404               
3405 1074 D800  22        movb ra,@MSAR                   ; STA MSAR          ; The "target missile" key is being pressed and we have
     1076 0D5E     
3406                                                                          ; at least one missile, so set MSAR = &FF to denote that
3407                                                                          ; our missile is currently armed (we know A has the
3408                                                                          ; value &FF, as we just loaded it from MSTG and checked
3409                                                                          ; that it was negative)
3410               
3411 1078 0202  12        li   ry,>e0*256                 ; LDY #&E0          ; Change the leftmost missile indicator to yellow/white
     107A E000     
3412 107C 0206  12        li   rtmp,MSBAR                 ; JSR MSBAR         ; on the missile bar (this call changes the leftmost
     107E 7102     
3413 1080 06A0  20        bl   @jsr                       ;
     1082 8002     
3414                                                                          ; indicator because we set X to the number of missiles
3415                                                                          ; in NOMSL above, and the indicators are numbered from
3416                                                                          ; right to left, so X is the number of the leftmost
3417                                                                          ; indicator)
3418               
3419               MA25:
3420 1084 D020  22        movb @KY16,ra                   ; LDA KY16          ; If "M" is being pressed, keep going, otherwise jump
     1086 004D     
3421 1088 1307  10        jeq  MA24                       ; BEQ MA24          ; down to MA24 to skip the following
3422               
3423 108A D020  22        movb @MSTG,ra                   ; LDA MSTG          ; If MSTG = &FF then there is no target lock, so jump to
     108C 0052     
3424 108E 112D  10        jlt  MA64                       ; BMI MA64          ; MA64 to skip the following (also skipping the checks
3425                                                                          ; for TAB, ESCAPE, "J" and "E")
3426               
3427 1090 0206  12        li   rtmp,FRMIS                 ; JSR FRMIS         ; The "fire missile" key is being pressed and we have
     1092 3C2A     
3428 1094 06A0  20        bl   @jsr                       ;
     1096 8002     
3429                                                                          ; a missile lock, so call the FRMIS routine to fire
3430                                                                          ; the missile
3431               
3432               MA24:
3433 1098 D020  22        movb @KY12,ra                   ; LDA KY12          ; If TAB is being pressed, keep going, otherwise jump
     109A 0049     
3434 109C 1307  10        jeq  MA76                       ; BEQ MA76          ; down to MA76 to skip the following
3435               
3436                      .asl @BOMB                      ; ASL BOMB          ; The "energy bomb" key is being pressed, so double
     **** ****     > ASL
0001 109E D1A0  22        movb @BOMB,rtmp
     10A0 032A     
0002 10A2 0246  14        andi rtmp,>ff00
     10A4 FF00     
0003 10A6 0A16  14        sla  rtmp,1
0004 10A8 D806  22        movb rtmp,@BOMB
     10AA 032A     
                   < elite.a99
3437                                                                          ; the value in BOMB. If we have an energy bomb fitted,
3438                                                                          ; BOMB will contain &7F (%01111111) before this shift
3439                                                                          ; and will contain &FE (%11111110) after the shift; if
3440                                                                          ; we don't have an energy bomb fitted, BOMB will still
3441                                                                          ; contain 0. The bomb explosion is dealt with in the
3442                                                                          ; MAL1 routine below - this just registers the fact that
3443                                                                          ; we've set the bomb ticking
3444               
3445               MA76:
3446 10AC D020  22        movb @KY13,ra                   ; LDA KY13          ; If ESCAPE is being pressed and we have an escape pod
     10AE 004A     
3447                      .and @ESCP                      ; AND ESCP          ; fitted, keep going, otherwise skip the next
     **** ****     > AND
0001 10B0 D1A0  22        movb @ESCP,rtmp
     10B2 032E     
0002 10B4 0546  10        inv  rtmp
0003 10B6 5006  14        szcb rtmp,ra
                   < elite.a99
3448 10B8 1302  10        jeq  B05                        ; BEQ B05           ; instruction
3449               
3450 10BA 0460  20        b    @ESCAPE                    ; JMP ESCAPE        ; The button is being pressed to launch an escape pod
     10BC 3646     
3451                                                                          ; and we have an escape pod fitted, so jump to ESCAPE to
3452                                                                          ; launch it, and exit the main flight loop using a tail
3453                                                                          ; call
3454               
3455               B05:
3456 10BE D020  22        movb @KY18,ra                   ; LDA KY18          ; If "J" is being pressed, keep going, otherwise skip
     10C0 004F     
3457 10C2 1304  10        jeq  B06                        ; BEQ B06           ; the next instruction
3458               
3459 10C4 0206  12        li   rtmp,WARP                  ; JSR WARP          ; Call the WARP routine to do an in-system jump
     10C6 4838     
3460 10C8 06A0  20        bl   @jsr                       ;
     10CA 8002     
3461               
3462               B06:
3463 10CC D020  22        movb @KY17,ra                   ; LDA KY17          ; If "E" is being pressed and we have an E.C.M. fitted,
     10CE 004E     
3464                      .and @ECM                       ; AND ECM           ; keep going, otherwise jump down to MA64 to skip the
     **** ****     > AND
0001 10D0 D1A0  22        movb @ECM,rtmp
     10D2 0328     
0002 10D4 0546  10        inv  rtmp
0003 10D6 5006  14        szcb rtmp,ra
                   < elite.a99
3465 10D8 1308  10        jeq  MA64                       ; BEQ MA64          ; following
3466               
3467 10DA D020  22        movb @ECMA,ra                   ; LDA ECMA          ; If ECMA is non-zero, that means an E.C.M. is already
     10DC 0030     
3468 10DE 1605  10        jne  MA64                       ; BNE MA64          ; operating and is counting down (this can be either
3469                                                                          ; our E.C.M. or an opponent's), so jump down to MA64 to
3470                                                                          ; skip the following (as we can't have two E.C.M.
3471                                                                          ; systems operating at the same time)
3472               
3473 10E0 7004  14        sb   rone,ra                    ; DEC ECMP          ; The E.C.M. button is being pressed and nobody else
3474                                                                          ; is operating their E.C.M., so decrease the value of
3475                                                                          ; ECMP to make it non-zero, to denote that our E.C.M.
3476                                                                          ; is now on
3477               
3478 10E2 0206  12        li   rtmp,ECBLB2                ; JSR ECBLB2        ; Call ECBLB2 to light up the E.C.M. indicator bulb on
     10E4 70B2     
3479 10E6 06A0  20        bl   @jsr                       ;
     10E8 8002     
3480                                                                          ; the dashboard, set the E.C.M. countdown timer to 32,
3481                                                                          ; and start making the E.C.M. sound
3482               
3483               MA64:
3484 10EA D020  22        movb @KY19,ra                   ; LDA KY19          ; If "C" is being pressed, and we have a docking
     10EC 0050     
3485                      .and @DKCMP                     ; AND DKCMP         ; computer fitted, and we are inside the space station's
     **** ****     > AND
0001 10EE D1A0  22        movb @DKCMP,rtmp
     10F0 032C     
0002 10F2 0546  10        inv  rtmp
0003 10F4 5006  14        szcb rtmp,ra
                   < elite.a99
3486                      .and @SSPR                      ; AND SSPR          ; safe zone, keep going, otherwise jump down to MA68 to
     **** ****     > AND
0001 10F6 D1A0  22        movb @SSPR,rtmp
     10F8 0D55     
0002 10FA 0546  10        inv  rtmp
0003 10FC 5006  14        szcb rtmp,ra
                   < elite.a99
3487 10FE 1305  10        jeq  MA68                       ; BEQ MA68          ; skip the following
3488               
3489 1100 D020  22        movb @K.+NI.+32,ra              ; LDA K%+NI%+32     ; Fetch the AI counter (byte #32) of the second ship
     1102 0944     
3490 1104 1102  10        jlt  MA68                       ; BMI MA68          ; from the ship data workspace at K%, which is reserved
3491                                                                          ; for the sun or the space station (in this case it's
3492                                                                          ; the latter as we are in the safe zone). If byte #32 is
3493                                                                          ; negative, meaning the station is hostile, then jump
3494                                                                          ; down to MA68 to skip the following (so we can't use
3495                                                                          ; the docking computer to dock at a station that has
3496                                                                          ; turned against us)
3497               
3498 1106 0460  16        b    @GOIN                      ; JMP GOIN          ; The Docking Computer button has been pressed and
     1108 130A     
3499                                                                          ; we are allowed to dock at the station, so jump to
3500                                                                          ; GOIN to dock (or "go in"), and exit the main flight
3501                                                                          ; loop using a tail call
3502               
3503               MA68:
3504 110A 0200  12        li   ra,>00*256                 ; LDA #0            ; Set LAS = 0, to switch the laser off while we do the
     110C 0000     
3505 110E D800  22        movb ra,@LAS                    ; STA LAS           ; following logic
     1110 0051     
3506               
3507 1112 D800  22        movb ra,@DELT4                  ; STA DELT4         ; Take the 16-bit value (DELTA 0) - i.e. a two-byte
     1114 008D     
3508 1116 D020  22        movb @DELTA,ra                  ; LDA DELTA         ; number with DELTA as the high byte and 0 as the low
     1118 008C     
3509 111A 0910  14        srl  ra,1                       ; LSR A             ; byte - and divide it by 4, storing the 16-bit result
3510 111C 0208  12        li   rarg1,DELT4                ; ROR DELT4         ; in DELT4(1 0). This has the effect of storing the
     111E 008D     
3511 1120 06A0  20        bl   @ror                       ;
     1122 8054     
3512 1124 0910  14        srl  ra,1                       ; LSR A             ; current speed * 64 in the 16-bit location DELT4(1 0)
3513 1126 0208  12        li   rarg1,DELT4                ; ROR DELT4
     1128 008D     
3514 112A 06A0  20        bl   @ror                       ;
     112C 8054     
3515 112E D800  22        movb ra,@DELT4+1                ; STA DELT4+1
     1130 008E     
3516               
3517 1132 D020  22        movb @LASCT,ra                  ; LDA LASCT         ; If LASCT is zero, keep going, otherwise the laser is
     1134 0D60     
3518 1136 1628  10        jne  MA3                        ; BNE MA3           ; a pulse laser that is between pulses, so jump down to
3519                                                                          ; MA3 to skip the following
3520               
3521 1138 D020  22        movb @KY7,ra                    ; LDA KY7           ; If "A" is being pressed, keep going, otherwise jump
     113A 0048     
3522 113C 1325  10        jeq  MA3                        ; BEQ MA3           ; down to MA3 to skip the following
3523               
3524 113E D020  22        movb @GNTMP,ra                  ; LDA GNTMP         ; If the laser temperature >= 242 then the laser has
     1140 0D61     
3525 1142 0280  14        ci   ra,>f2*256                 ; CMP #242          ; overheated, so jump down to MA3 to skip the following
     1144 F200     
3526 1146 1820  10        joc  MA3                        ; BCS MA3
3527               
3528 1148 D060  22        movb @VIEW,rx                   ; LDX VIEW          ; If the current space view has a laser fitted (i.e. the
     114A 0D5F     
3529 114C D021  26        movb @LASER(rx),ra              ; LDA LASER,X       ; laser power for this view is greater than zero), then
     114E 0310     
3530 1150 131B  10        jeq  MA3                        ; BEQ MA3           ; keep going, otherwise jump down to MA3 to skip the
3531                                                                          ; following
3532               
3533                                                                          ; If we get here, then the "fire" button is being
3534                                                                          ; pressed, our laser hasn't overheated and isn't already
3535                                                                          ; being fired, and we actually have a laser fitted to
3536                                                                          ; the current space view, so it's time to hit me with
3537                                                                          ; those laser beams
3538               
3539                      .pha                            ; PHA               ; Store the current view's laser power on the stack
     **** ****     > PHA
0001 1152 D680  26        movb ra,*rsp
0002 1154 060A  10        dec  rsp
                   < elite.a99
3540               
3541 1156 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; Set LAS and LAS2 to bits 0-6 of the laser power
     1158 7F00     
3542 115A D800  22        movb ra,@LAS                    ; STA LAS
     115C 0051     
3543 115E D800  22        movb ra,@LAS2                   ; STA LAS2
     1160 0D5D     
3544               
3545 1162 0200  12        li   ra,>00*256                 ; LDA #0            ; Call the NOISE routine with A = 0 to make the sound
     1164 0000     
3546 1166 0206  12        li   rtmp,NOISE                 ; JSR NOISE         ; of our laser firing
     1168 8BA4     
3547 116A 06A0  20        bl   @jsr                       ;
     116C 8002     
3548               
3549 116E 0206  12        li   rtmp,LASLI                 ; JSR LASLI         ; Call LASLI to draw the laser lines
     1170 48DA     
3550 1172 06A0  20        bl   @jsr                       ;
     1174 8002     
3551               
3552                      .pla                            ; PLA               ; Restore the current view's laser power into A
     **** ****     > PLA
0001 1176 058A  10        inc  rsp
0002 1178 D01A  22        movb *rsp,ra
                   < elite.a99
3553               
3554 117A 1502  10        jgt  ma1_                       ; BPL ma1           ; If the laser power has bit 7 set, then it's an "always
3555                                                                          ; on" laser rather than a pulsing laser, so keep going,
3556                                                                          ; otherwise jump down to ma1 to skip the following
3557                                                                          ; instruction
3558               
3559 117C 0200  12        li   ra,>00*256                 ; LDA #0            ; This is an "always on" laser (i.e. a beam laser,
     117E 0000     
3560                                                                          ; as this version of Elite doesn't have military
3561                                                                          ; lasers), so set A = 0, which will be stored in LASCT
3562                                                                          ; to denote that this is not a pulsing laser
3563               
3564               ma1_:
3565 1180 0240  14        andi ra,>fa*256                 ; AND #%11111010    ; LASCT will be set to 0 for beam lasers, and to the
     1182 FA00     
3566 1184 D800  22        movb ra,@LASCT                  ; STA LASCT         ; laser power AND %11111010 for pulse lasers, which
     1186 0D60     
3567                                                                          ; comes to 10 (as pulse lasers have a power of 15). See
3568                                                                          ; MA23 below for more on laser pulsing and LASCT
3569               
3570               * ******************************************************************************
3571               *
3572               * Name: Main flight loop (Part 4 of 16)
3573               * Type: Subroutine
3574               * Category: Main loop
3575               * Summary: For each nearby ship: Copy the ship's data block from K% to the
3576               * zero-page workspace at INWK
3577               * Deep dive: Program flow of the main game loop
3578               * Ship data blocks
3579               *
3580               * ------------------------------------------------------------------------------
3581               *
3582               * The main flight loop covers most of the flight-specific aspects of Elite. This
3583               * section covers the following:
3584               *
3585               * * Start looping through all the ships in the local bubble, and for each
3586               * one:
3587               *
3588               * * Copy the ship's data block from K% to INWK
3589               *
3590               * * Set XX0 to point to the ship's blueprint (if this is a ship)
3591               *
3592               * ------------------------------------------------------------------------------
3593               *
3594               * Other entry points:
3595               *
3596               * MAL1                Marks the beginning of the ship analysis loop, so we
3597               * can jump back here from part 12 of the main flight loop
3598               * to work our way through each ship in the local bubble.
3599               * We also jump back here when a ship is removed from the
3600               * bubble, so we can continue processing from the next ship
3601               *
3602               * ******************************************************************************
3603               
3604               MA3:
3605 1188 0201  12        li   rx,>00*256                 ; LDX #0            ; We're about to work our way through all the ships in
     118A 0000     
3606                                                                          ; our local bubble of universe, so set a counter in X,
3607                                                                          ; starting from 0, to refer to each ship slot in turn
3608               
3609               MAL1:
3610 118C D801  22        movb rx,@XSAV                   ; STX XSAV          ; Store the current slot number in XSAV
     118E 0093     
3611               
3612 1190 D021  26        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the contents of this slot into A. If it is 0
     1192 0D40     
3613 1194 1602  10        jne  B07                        ; BNE B07           ; then this slot is empty and we have no more ships to
3614 1196 0460  16        b    @MA18                      ; JMP MA18          ; process, so jump to MA18 below, otherwise A contains
     1198 1516     
3615                                                                          ; the type of ship that's in this slot, so skip over the
3616                                                                          ; JMP MA18 instruction and keep going
3617               
3618               B07:
3619 119A D800  22        movb ra,@TYPE                   ; STA TYPE          ; Store the ship type in TYPE
     119C 009B     
3620               
3621 119E 0206  12        li   rtmp,GINF                  ; JSR GINF          ; Call GINF to fetch the address of the ship data block
     11A0 6F00     
3622 11A2 06A0  20        bl   @jsr                       ;
     11A4 8002     
3623                                                                          ; for the ship in slot X and store it in INF. The data
3624                                                                          ; block is in the K% workspace, which is where all the
3625                                                                          ; ship data blocks are stored
3626               
3627                                                                          ; Next we want to copy the ship data block from INF to
3628                                                                          ; the zero-page workspace at INWK, so we can process it
3629                                                                          ; more efficiently
3630               
3631 11A6 0202  12        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; There are NI% bytes in each ship data block (and in
     11A8 2300     
3632                                                                          ; the INWK workspace, so we set a counter in Y so we can
3633                                                                          ; loop through them
3634               
3635               MAL2:
3636                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Load the Y-th byte of INF and store it in the Y-th
     **** ****     > LD_IND_Y_IDX
0001 11AA D820  30        movb @INF,@rtmplb
     11AC 0020     
     11AE 830D     
0002 11B0 D1A0  22        movb @INF+1,rtmp
     11B2 0021     
0003 11B4 A182  14        a    ry,rtmp
0004 11B6 D016  22        movb *rtmp,RA
                   < elite.a99
3637 11B8 D880  30        movb ra,@INWK(ry)               ; STA INWK,Y        ; byte of INWK
     11BA 0053     
3638               
3639 11BC 7084  14        sb   rone,ry                    ; DEY               ; Decrement the loop counter
3640               
3641 11BE 15F5  10        jgt  MAL2                       ; BPL MAL2          ; Loop back for the next byte until we have copied the
3642                                                                          ; last byte from INF to INWK
3643               
3644 11C0 D020  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is negative then this indicates a
     11C2 009B     
3645 11C4 1121  10        jlt  MA21                       ; BMI MA21          ; planet or sun, so jump down to MA21, as the next bit
3646                                                                          ; sets up a pointer to the ship blueprint, and then
3647                                                                          ; checks for energy bomb damage, and neither of these
3648                                                                          ; apply to planets and suns
3649               
3650                      .asla                           ; ASL A             ; Set Y = ship type * 2
     **** ****     > ASLA
0001 11C6 0240  14        andi ra,>ff00
     11C8 FF00     
0002 11CA 0A10  14        sla  ra,1
                   < elite.a99
3651 11CC D080  14        movb ra,ry                      ; TAY
3652               
3653 11CE D022  26        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; The ship blueprints at XX21 start with a lookup
     11D0 A7D4     
3654 11D2 D800  22        movb ra,@XX0                    ; STA XX0           ; table that points to the individual ship blueprints,
     11D4 001E     
3655                                                                          ; so this fetches the low byte of this particular ship
3656                                                                          ; type's blueprint and stores it in XX0
3657               
3658 11D6 D022  26        movb @XX21-1(ry),ra             ; LDA XX21-1,Y      ; Fetch the high byte of this particular ship type's
     11D8 A7D5     
3659 11DA D800  22        movb ra,@XX0+1                  ; STA XX0+1         ; blueprint and store it in XX0+1
     11DC 001F     
3660               
3661               * ******************************************************************************
3662               *
3663               * Name: Main flight loop (Part 5 of 16)
3664               * Type: Subroutine
3665               * Category: Main loop
3666               * Summary: For each nearby ship: If an energy bomb has been set off,
3667               * potentially kill this ship
3668               * Deep dive: Program flow of the main game loop
3669               *
3670               * ------------------------------------------------------------------------------
3671               *
3672               * The main flight loop covers most of the flight-specific aspects of Elite. This
3673               * section covers the following:
3674               *
3675               * * Continue looping through all the ships in the local bubble, and for each
3676               * one:
3677               *
3678               * * If an energy bomb has been set off and this ship can be killed, kill it
3679               * and increase the kill tally
3680               *
3681               * ******************************************************************************
3682               
3683 11DE D020  22        movb @BOMB,ra                   ; LDA BOMB          ; If we set off our energy bomb (see MA24 above), then
     11E0 032A     
3684 11E2 1512  10        jgt  MA21                       ; BPL MA21          ; BOMB is now negative, so this skips to MA21 if our
3685                                                                          ; energy bomb is not going off
3686               
3687 11E4 0282  14        ci   ry,(2*SST)*256             ; CPY #2*SST        ; If the ship in Y is the space station, jump to BA21
     11E6 1000     
3688 11E8 130F  10        jeq  MA21                       ; BEQ MA21          ; as energy bombs are useless against space stations
3689               
3690 11EA D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; If the ship we are checking has bit 5 set in its ship
     11EC 0072     
3691 11EE 0240  14        andi ra,>20*256                 ; AND #%00100000    ; byte #31, then it is already exploding, so jump to
     11F0 2000     
3692 11F2 160A  10        jne  MA21                       ; BNE MA21          ; BA21 as ships can't explode more than once
3693               
3694 11F4 D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; The energy bomb is killing this ship, so set bit 7 of
     11F6 0072     
3695 11F8 0260  14        ori  ra,>80*256                 ; ORA #%10000000    ; the ship byte #31 to indicate that it has now been
     11FA 8000     
3696 11FC D800  22        movb ra,@INWK+31                ; STA INWK+31       ; killed
     11FE 0072     
3697               
3698 1200 0206  12        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     1202 8B54     
3699 1204 06A0  20        bl   @jsr                       ;
     1206 8002     
3700                                                                          ; ship (so increase the kill tally, make an explosion
3701                                                                          ; sound and possibly display "RIGHT ON COMMANDER!")
3702               
3703               * ******************************************************************************
3704               *
3705               * Name: Main flight loop (Part 6 of 16)
3706               * Type: Subroutine
3707               * Category: Main loop
3708               * Summary: For each nearby ship: Move the ship in space and copy the updated
3709               * INWK data block back to K%
3710               * Deep dive: Program flow of the main game loop
3711               * Program flow of the ship-moving routine
3712               * Ship data blocks
3713               *
3714               * ------------------------------------------------------------------------------
3715               *
3716               * The main flight loop covers most of the flight-specific aspects of Elite. This
3717               * section covers the following:
3718               *
3719               * * Continue looping through all the ships in the local bubble, and for each
3720               * one:
3721               *
3722               * * Move the ship in space
3723               *
3724               * * Copy the updated ship's data block from INWK back to K%
3725               *
3726               * ******************************************************************************
3727               
3728               MA21:
3729 1208 0206  12        li   rtmp,MVEIT                 ; JSR MVEIT         ; Call MVEIT to move the ship we are processing in space
     120A 17E2     
3730 120C 06A0  20        bl   @jsr                       ;
     120E 8002     
3731               
3732                                                                          ; Now that we are done processing this ship, we need to
3733                                                                          ; copy the ship data back from INWK to the correct place
3734                                                                          ; in the K% workspace. We already set INF in part 4 to
3735                                                                          ; point to the ship's data block in K%, so we can simply
3736                                                                          ; do the reverse of the copy we did before, this time
3737                                                                          ; copying from INWK to INF
3738               
3739 1210 0202  12        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; Set a counter in Y so we can loop through the NI%
     1212 2300     
3740                                                                          ; bytes in the ship data block
3741               
3742               MAL3:
3743 1214 D022  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Load the Y-th byte of INWK and store it in the Y-th
     1216 0053     
3744                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; byte of INF
     **** ****     > ST_IND_Y_IDX
0001 1218 D820  30        movb @INF,@rtmplb
     121A 0020     
     121C 830D     
0002 121E D1A0  22        movb @INF+1,rtmp
     1220 0021     
0003 1222 A182  14        a    ry,rtmp
0004 1224 D580  26        movb RA,*rtmp
                   < elite.a99
3745               
3746 1226 7084  14        sb   rone,ry                    ; DEY               ; Decrement the loop counter
3747               
3748 1228 15F5  10        jgt  MAL3                       ; BPL MAL3          ; Loop back for the next byte, until we have copied the
3749                                                                          ; last byte from INWK back to INF
3750               
3751               * ******************************************************************************
3752               *
3753               * Name: Main flight loop (Part 7 of 16)
3754               * Type: Subroutine
3755               * Category: Main loop
3756               * Summary: For each nearby ship: Check whether we are docking, scooping or
3757               * colliding with it
3758               * Deep dive: Program flow of the main game loop
3759               *
3760               * ------------------------------------------------------------------------------
3761               *
3762               * The main flight loop covers most of the flight-specific aspects of Elite. This
3763               * section covers the following:
3764               *
3765               * * Continue looping through all the ships in the local bubble, and for each
3766               * one:
3767               *
3768               * * Check how close we are to this ship and work out if we are docking,
3769               * scooping or colliding with it
3770               *
3771               * ******************************************************************************
3772               
3773 122A D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the status of this ship from bits 5 (is ship
     122C 0072     
3774 122E 0240  14        andi ra,>a0*256                 ; AND #%10100000    ; exploding?) and bit 7 (has ship been killed?) from
     1230 A000     
3775                                                                          ; ship byte #31 into A
3776               
3777 1232 0206  12        li   rtmp,MAS4                  ; JSR MAS4          ; Or this value with x_hi, y_hi and z_hi
     1234 8462     
3778 1236 06A0  20        bl   @jsr                       ;
     1238 8002     
3779               
3780 123A 164C  10        jne  MA65                       ; BNE MA65          ; If this value is non-zero, then either the ship is
3781                                                                          ; far away (i.e. has a non-zero high byte in at least
3782                                                                          ; one of the three axes), or it is already exploding,
3783                                                                          ; or has been flagged as being killed - in which case
3784                                                                          ; jump to MA65 to skip the following, as we can't dock
3785                                                                          ; scoop or collide with it
3786               
3787 123C D020  22        movb @INWK,ra                   ; LDA INWK          ; Set A = (x_lo OR y_lo OR z_lo), and if bit 7 of the
     123E 0053     
3788 1240 F020  22        socb @INWK+3,ra                 ; ORA INWK+3        ; result is set, the ship is still a fair distance
     1242 0056     
3789 1244 F020  22        socb @INWK+6,ra                 ; ORA INWK+6        ; away (further than 127 in at least one axis), so jump
     1246 0059     
3790 1248 1145  10        jlt  MA65                       ; BMI MA65          ; to MA65 to skip the following, as it's too far away to
3791                                                                          ; dock, scoop or collide with
3792               
3793 124A D060  22        movb @TYPE,rx                   ; LDX TYPE          ; If the current ship type is negative then it's either
     124C 009B     
3794 124E 1142  10        jlt  MA65                       ; BMI MA65          ; a planet or a sun, so jump down to MA65 to skip the
3795                                                                          ; following, as we can't dock with it or scoop it
3796               
3797 1250 0281  14        ci   rx,(SST)*256               ; CPX #SST          ; If this ship is the space station, jump to ISDK to
     1252 0800     
3798 1254 1341  10        jeq  ISDK                       ; BEQ ISDK          ; check whether we are docking with it
3799               
3800 1256 0240  14        andi ra,>c0*256                 ; AND #%11000000    ; If bit 6 of (x_lo OR y_lo OR z_lo) is set, then the
     1258 C000     
3801 125A 163C  10        jne  MA65                       ; BNE MA65          ; ship is still a reasonable distance away (further than
3802                                                                          ; 63 in at least one axis), so jump to MA65 to skip the
3803                                                                          ; following, as it's too far away to dock, scoop or
3804                                                                          ; collide with
3805               
3806 125C 0281  14        ci   rx,(MSL)*256               ; CPX #MSL          ; If this ship is a missile, jump down to MA65 to skip
     125E 0900     
3807 1260 1339  10        jeq  MA65                       ; BEQ MA65          ; the following, as we can't scoop or dock with a
3808                                                                          ; missile, and it has its own dedicated collision
3809                                                                          ; checks in the TACTICS routine
3810               
3811 1262 0281  14        ci   rx,(OIL)*256               ; CPX #OIL          ; If ship type >= OIL (i.e. it's a cargo canister,
     1264 0B00     
3812 1266 1802  10        joc  B08                        ; BCS B08           ; Thargon or escape pod), skip the JMP instruction and
3813 1268 0460  16        b    @MA58                      ; JMP MA58          ; continue on, otherwise jump to MA58 to process a
     126A 1368     
3814                                                                          ; potential collision
3815               
3816               B08:
3817 126C D020  22        movb @BST,ra                    ; LDA BST           ; If we have fuel scoops fitted then BST will be &FF,
     126E 0329     
3818                                                                          ; otherwise it will be 0
3819               
3820                      .and @INWK+5                    ; AND INWK+5        ; Ship byte #5 contains the y_sign of this ship, so a
     **** ****     > AND
0001 1270 D1A0  22        movb @INWK+5,rtmp
     1272 0058     
0002 1274 0546  10        inv  rtmp
0003 1276 5006  14        szcb rtmp,ra
                   < elite.a99
3821                                                                          ; negative value here means the canister is below us,
3822                                                                          ; which means the result of the AND will be negative if
3823                                                                          ; the canister is below us and we have a fuel scoop
3824                                                                          ; fitted
3825               
3826 1278 1577  10        jgt  MA58                       ; BPL MA58          ; If the result is positive, then we either have no
3827                                                                          ; scoop or the canister is above us, and in both cases
3828                                                                          ; this means we can't scoop the item, so jump to MA58
3829                                                                          ; to process a collision
3830               
3831               * ******************************************************************************
3832               *
3833               * Name: Main flight loop (Part 8 of 16)
3834               * Type: Subroutine
3835               * Category: Main loop
3836               * Summary: For each nearby ship: Process us potentially scooping this item
3837               * Deep dive: Program flow of the main game loop
3838               *
3839               * ------------------------------------------------------------------------------
3840               *
3841               * The main flight loop covers most of the flight-specific aspects of Elite. This
3842               * section covers the following:
3843               *
3844               * * Continue looping through all the ships in the local bubble, and for each
3845               * one:
3846               *
3847               * * Process us potentially scooping this item
3848               *
3849               * ******************************************************************************
3850               
3851 127A 0200  12        li   ra,>03*256                 ; LDA #3            ; Set A to 3 to denote we may be scooping an escape pod
     127C 0300     
3852               
3853 127E 0281  14        ci   rx,(TGL)*256               ; CPX #TGL          ; If ship type < Thargon, i.e. it's a canister, jump
     1280 0C00     
3854 1282 1704  10        jnc  oily_                      ; BCC oily          ; to oily to randomly decide the canister's contents
3855               
3856 1284 1609  10        jne  slvy2_                     ; BNE slvy2         ; If ship type <> Thargon, i.e. it's an escape pod,
3857                                                                          ; jump to slvy2 with A set to 3, so we scoop up the
3858                                                                          ; escape pod as slaves
3859               
3860 1286 0200  12        li   ra,>10*256                 ; LDA #16           ; Otherwise this is a Thargon, so jump to slvy2 with
     1288 1000     
3861 128A 1606  10        jne  slvy2_                     ; BNE slvy2         ; A set to 16, so we scoop up the Thargon as alien items
3862                                                                          ; (this BNE is effectively a JMP as A will never be
3863                                                                          ; zero)
3864               
3865               oily_:
3866 128C 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers and reduce A to a
     128E 8070     
3867 1290 06A0  20        bl   @jsr                       ;
     1292 8002     
3868 1294 0240  14        andi ra,>07*256                 ; AND #7            ; random number in the range 0-7
     1296 0700     
3869               
3870               slvy2_:
3871                                                                          ; By the time we get here, we are scooping, and A
3872                                                                          ; contains the type of item we are scooping (a random
3873                                                                          ; number 0-7 if we are scooping a cargo canister, 3 if
3874                                                                          ; we are scooping an escape pod, or 16 if we are
3875                                                                          ; scooping a Thargon). These numbers correspond to the
3876                                                                          ; relevant market items (see QQ23 for a list), so a
3877                                                                          ; cargo canister can contain anything from food to
3878                                                                          ; computers, while escape pods contain slaves, and
3879                                                                          ; Thargons become alien items when scooped
3880 1298 D800  22        movb ra,@QQ29                   ; STA QQ29          ; Call tnpr with the scooped cargo type stored in QQ29
     129A 0F1B     
3881 129C 0200  12        li   ra,>01*256                 ; LDA #1            ; and A set to 1, to work out whether we have room in
     129E 0100     
3882 12A0 0206  12        li   rtmp,tnpr_                 ; JSR tnpr          ; the hold for the scooped item (A is preserved by this
     12A2 4DF4     
3883 12A4 06A0  20        bl   @jsr                       ;
     12A6 8002     
3884                                                                          ; call, and the C flag contains the result)
3885               
3886 12A8 0202  12        li   ry,>4e*256                 ; LDY #78           ; This instruction has no effect, so presumably it used
     12AA 4E00     
3887                                                                          ; to do something, but didn't get removed
3888               
3889 12AC 1845  10        joc  MA59                       ; BCS MA59          ; If the C flag is set then we have no room in the hold
3890                                                                          ; for the scooped item, so jump down to MA59 make a
3891                                                                          ; sound to indicate failure, before destroying the
3892                                                                          ; canister
3893               
3894 12AE D0A0  22        movb @QQ29,ry                   ; LDY QQ29          ; Scooping was successful, so set Y to the type of
     12B0 0F1B     
3895                                                                          ; item we just scooped, which we stored in QQ29 above
3896               
3897                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; Add A (which we set to 1 above) to the number of items
     **** ****     > ADC
0001 12B2 1701  10        jnc  !
0002 12B4 B004  14        ab   rone,ra
0003               !:
0004 12B6 B022  26        ab   @QQ20(RY),ra
     12B8 0317     
                   < elite.a99
3898 12BA D880  30        movb ra,@QQ20(ry)               ; STA QQ20,Y        ; of type Y in the cargo hold, as we just successfully
     12BC 0317     
3899                                                                          ; scooped one canister of type Y
3900               
3901 12BE D002  14        movb ry,ra                      ; TYA               ; Print recursive token 48 + Y as an in-flight token,
3902                      .adi (>d0*256)                  ; ADC #208          ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
     **** ****     > ADI
0001 12C0 1701  10        jnc  !
0002 12C2 B004  14        ab   rone,ra
0003               !:
0004 12C4 0220  14        ai   ra,(>D0*256)
     12C6 D000     
                   < elite.a99
3903 12C8 0206  12        li   rtmp,MESS                  ; JSR MESS          ; ITEMS"), so this prints the scooped item's name
     12CA 8E52     
3904 12CC 06A0  20        bl   @jsr                       ;
     12CE 8002     
3905               
3906 12D0 0460  16        b    @MA60                      ; JMP MA60          ; We are done scooping, so jump down to MA60 to set the
     12D2 1340     
3907                                                                          ; kill flag on the canister, as it no longer exists in
3908                                                                          ; the local bubble
3909               
3910               MA65:
3911 12D4 0460  16        b    @MA26                      ; JMP MA26          ; If we get here, then the ship we are processing was
     12D6 139A     
3912                                                                          ; too far away to be scooped, docked or collided with,
3913                                                                          ; so jump to MA26 to skip over the collision routines
3914                                                                          ; and move on to missile targeting
3915               
3916               * ******************************************************************************
3917               *
3918               * Name: Main flight loop (Part 9 of 16)
3919               * Type: Subroutine
3920               * Category: Main loop
3921               * Summary: For each nearby ship: If it is a space station, check whether we
3922               * are successfully docking with it
3923               * Deep dive: Program flow of the main game loop
3924               * Docking checks
3925               *
3926               * ------------------------------------------------------------------------------
3927               *
3928               * The main flight loop covers most of the flight-specific aspects of Elite. This
3929               * section covers the following:
3930               *
3931               * * Process docking with a space station
3932               *
3933               * For details on the various docking checks in this routine, see the deep dive
3934               * on "Docking checks".
3935               *
3936               * ------------------------------------------------------------------------------
3937               *
3938               * Other entry points:
3939               *
3940               * GOIN                We jump here from part 3 of the main flight loop if the
3941               * docking computer is activated by pressing "C"
3942               *
3943               * ******************************************************************************
3944               
3945               ISDK:
3946 12D8 D020  22        movb @K.+NI.+32,ra              ; LDA K%+NI%+32     ; 1. Fetch the AI counter (byte #32) of the second ship
     12DA 0944     
3947 12DC 1126  10        jlt  MA62                       ; BMI MA62          ; in the ship data workspace at K%, which is reserved
3948                                                                          ; for the sun or the space station (in this case it's
3949                                                                          ; the latter), and if it's negative, i.e. bit 7 is set,
3950                                                                          ; meaning the station is hostile, jump down to MA62 to
3951                                                                          ; fail docking (so trying to dock at a station that we
3952                                                                          ; have annoyed does not end well)
3953               
3954 12DE D020  22        movb @INWK+14,ra                ; LDA INWK+14       ; 2. If nosev_z_hi < 214, jump down to MA62 to fail
     12E0 0061     
3955 12E2 0280  14        ci   ra,>d6*256                 ; CMP #214          ; docking, as the angle of approach is greater than 26
     12E4 D600     
3956 12E6 1721  10        jnc  MA62                       ; BCC MA62          ; degrees
3957               
3958 12E8 0206  12        li   rtmp,SPS4                  ; JSR SPS4          ; Call SPS4 to get the vector to the space station
     12EA 6D4C     
3959 12EC 06A0  20        bl   @jsr                       ;
     12EE 8002     
3960                                                                          ; into XX15
3961               
3962 12F0 D020  22        movb @XX15+2,ra                 ; LDA XX15+2        ; 3. Check the sign of the z-axis (bit 7 of XX15+2) and
     12F2 0033     
3963 12F4 111A  10        jlt  MA62                       ; BMI MA62          ; if it is negative, we are facing away from the
3964                                                                          ; station, so jump to MA62 to fail docking
3965               
3966 12F6 0280  14        ci   ra,>59*256                 ; CMP #89           ; 4. If z-axis < 89, jump to MA62 to fail docking, as
     12F8 5900     
3967 12FA 1717  10        jnc  MA62                       ; BCC MA62          ; we are not in the 22.0 degree safe cone of approach
3968               
3969 12FC D020  22        movb @INWK+16,ra                ; LDA INWK+16       ; 5. If |roofv_x_hi| < 80, jump to MA62 to fail docking,
     12FE 0063     
3970 1300 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; as the slot is more than 36.6 degrees from horizontal
     1302 7F00     
3971 1304 0280  14        ci   ra,>50*256                 ; CMP #80
     1306 5000     
3972 1308 1710  10        jnc  MA62                       ; BCC MA62
3973               
3974               GOIN:
3975                                                                          ; If we arrive here, either the docking computer has
3976                                                                          ; been activated, or we just docked successfully
3977 130A 0200  12        li   ra,>00*256                 ; LDA #0            ; Set the on-screen hyperspace counter to 0
     130C 0000     
3978 130E D800  22        movb ra,@QQ22+1                 ; STA QQ22+1
     1310 002F     
3979               
3980 1312 0200  12        li   ra,>08*256                 ; LDA #8            ; This instruction has no effect, so presumably it used
     1314 0800     
3981                                                                          ; to do something, and didn't get removed
3982               
3983 1316 0206  12        li   rtmp,LAUN                  ; JSR LAUN          ; Show the space station launch tunnel
     1318 3E62     
3984 131A 06A0  20        bl   @jsr                       ;
     131C 8002     
3985               
3986 131E 0206  12        li   rtmp,RES4                  ; JSR RES4          ; Reset the shields and energy banks, stardust and INWK
     1320 7F16     
3987 1322 06A0  20        bl   @jsr                       ;
     1324 8002     
3988                                                                          ; workspace
3989               
3990 1326 0460  16        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     1328 8650     
3991                                                                          ; screen)
3992               
3993               MA62:
3994                                                                          ; If we arrive here, docking has just failed
3995 132A D020  22        movb @DELTA,ra                  ; LDA DELTA         ; If the ship's speed is < 5, jump to MA67 to register
     132C 008C     
3996 132E 0280  14        ci   ra,>05*256                 ; CMP #5            ; some damage, but not a huge amount
     1330 0500     
3997 1332 1713  10        jnc  MA67                       ; BCC MA67
3998               
3999 1334 0460  16        b    @DEATH                     ; JMP DEATH         ; Otherwise we have just crashed into the station, so
     1336 8472     
4000                                                                          ; process our death
4001               
4002               * ******************************************************************************
4003               *
4004               * Name: Main flight loop (Part 10 of 16)
4005               * Type: Subroutine
4006               * Category: Main loop
4007               * Summary: For each nearby ship: Remove if scooped, or process collisions
4008               * Deep dive: Program flow of the main game loop
4009               *
4010               * ------------------------------------------------------------------------------
4011               *
4012               * The main flight loop covers most of the flight-specific aspects of Elite. This
4013               * section covers the following:
4014               *
4015               * * Continue looping through all the ships in the local bubble, and for each
4016               * one:
4017               *
4018               * * Remove scooped item after both successful and failed scooping attempts
4019               *
4020               * * Process collisions
4021               *
4022               * ******************************************************************************
4023               
4024               MA59:
4025                                                                          ; If we get here then scooping failed
4026 1338 0206  12        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of the cargo canister being destroyed
     133A 8B22     
4027 133C 06A0  20        bl   @jsr                       ;
     133E 8002     
4028                                                                          ; and fall through into MA60 to remove the canister
4029                                                                          ; from our local bubble
4030               
4031               MA60:
4032                                                                          ; If we get here then scooping was successful
4033                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the scooped or destroyed item, to denote
     **** ****     > ASL
0001 1340 D1A0  22        movb @INWK+31,rtmp
     1342 0072     
0002 1344 0246  14        andi rtmp,>ff00
     1346 FF00     
0003 1348 0A16  14        sla  rtmp,1
0004 134A D806  22        movb rtmp,@INWK+31
     134C 0072     
                   < elite.a99
4034                      .sec                            ; SEC               ; that it has been killed and should be removed from
     **** ****     > SEC
0001 134E 0A15  14        sla  rmone,1
                   < elite.a99
4035 1350 0208  12        li   rarg1,INWK+31              ; ROR INWK+31       ; the local bubble
     1352 0072     
4036 1354 06A0  20        bl   @ror                       ;
     1356 8054     
4037               
4038               MA61:
4039 1358 1620  10        jne  MA26                       ; BNE MA26          ; Jump to MA26 to skip over the collision routines and
4040                                                                          ; to move on to missile targeting (this BNE is
4041                                                                          ; effectively a JMP as A will never be zero)
4042               
4043               MA67:
4044                                                                          ; If we get here then we have collided with something,
4045                                                                          ; but not fatally
4046 135A 0200  12        li   ra,>01*256                 ; LDA #1            ; Set the speed in DELTA to 1 (i.e. a sudden stop)
     135C 0100     
4047 135E D800  22        movb ra,@DELTA                  ; STA DELTA
     1360 008C     
4048               
4049 1362 0200  12        li   ra,>05*256                 ; LDA #5            ; Set the amount of damage in A to 5 (a small dent) and
     1364 0500     
4050 1366 1611  10        jne  MA63                       ; BNE MA63          ; jump down to MA63 to process the damage (this BNE is
4051                                                                          ; effectively a JMP as A will never be zero)
4052               
4053               MA58:
4054                                                                          ; If we get here, we have collided with something in a
4055                                                                          ; potentially fatal way
4056                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the ship we just collided with, to
     **** ****     > ASL
0001 1368 D1A0  22        movb @INWK+31,rtmp
     136A 0072     
0002 136C 0246  14        andi rtmp,>ff00
     136E FF00     
0003 1370 0A16  14        sla  rtmp,1
0004 1372 D806  22        movb rtmp,@INWK+31
     1374 0072     
                   < elite.a99
4057                      .sec                            ; SEC               ; denote that it has been killed and should be removed
     **** ****     > SEC
0001 1376 0A15  14        sla  rmone,1
                   < elite.a99
4058 1378 0208  12        li   rarg1,INWK+31              ; ROR INWK+31       ; from the local bubble
     137A 0072     
4059 137C 06A0  20        bl   @ror                       ;
     137E 8054     
4060               
4061 1380 D020  22        movb @INWK+35,ra                ; LDA INWK+35       ; Load A with the energy level of the ship we just hit
     1382 0076     
4062               
4063                      .sec                            ; SEC               ; Set the amount of damage in A to 128 + A / 2, so
     **** ****     > SEC
0001 1384 0A15  14        sla  rmone,1
                   < elite.a99
4064 1386 06A0  20        bl   @rora                      ; ROR A             ; this is quite a big dent, and colliding with higher
     1388 803C     
4065                                                                          ; energy ships will cause more damage
4066               
4067               MA63:
4068 138A 0206  12        li   rtmp,OOPS                  ; JSR OOPS          ; The amount of damage is in A, so call OOPS to reduce
     138C 6E6A     
4069 138E 06A0  20        bl   @jsr                       ;
     1390 8002     
4070                                                                          ; our shields, and if the shields are gone, there's a
4071                                                                          ; chance of cargo loss or even death
4072               
4073 1392 0206  12        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of colliding with the other ship and
     1394 8B22     
4074 1396 06A0  20        bl   @jsr                       ;
     1398 8002     
4075                                                                          ; fall through into MA26 to try targeting a missile
4076               
4077               * ******************************************************************************
4078               *
4079               * Name: Main flight loop (Part 11 of 16)
4080               * Type: Subroutine
4081               * Category: Main loop
4082               * Summary: For each nearby ship: Process missile lock and firing our laser
4083               * Deep dive: Program flow of the main game loop
4084               * Flipping axes between space views
4085               *
4086               * ------------------------------------------------------------------------------
4087               *
4088               * The main flight loop covers most of the flight-specific aspects of Elite. This
4089               * section covers the following:
4090               *
4091               * * Continue looping through all the ships in the local bubble, and for each
4092               * one:
4093               *
4094               * * If this is not the front space view, flip the axes of the ship's
4095               * coordinates in INWK
4096               *
4097               * * Process missile lock
4098               *
4099               * * Process our laser firing
4100               *
4101               * ******************************************************************************
4102               
4103               MA26:
4104 139A D020  22        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to MA15 to skip
     139C 0096     
4105 139E 1662  10        jne  MA15                       ; BNE MA15          ; missile and laser locking
4106               
4107 13A0 0206  12        li   rtmp,PLUT                  ; JSR PLUT          ; Call PLUT to update the geometric axes in INWK to
     13A2 4984     
4108 13A4 06A0  20        bl   @jsr                       ;
     13A6 8002     
4109                                                                          ; match the view (front, rear, left, right)
4110               
4111 13A8 0206  12        li   rtmp,HITCH                 ; JSR HITCH         ; Call HITCH to see if this ship is in the crosshairs,
     13AA 3B3E     
4112 13AC 06A0  20        bl   @jsr                       ;
     13AE 8002     
4113 13B0 1755  10        jnc  MA8                        ; BCC MA8           ; in which case the C flag will be set (so if there is
4114                                                                          ; no missile or laser lock, we jump to MA8 to skip the
4115                                                                          ; following)
4116               
4117 13B2 D020  22        movb @MSAR,ra                   ; LDA MSAR          ; We have missile lock, so check whether the leftmost
     13B4 0D5E     
4118 13B6 130C  10        jeq  MA47                       ; BEQ MA47          ; missile is currently armed, and if not, jump to MA47
4119                                                                          ; to process laser fire, as we can't lock an unarmed
4120                                                                          ; missile
4121               
4122 13B8 0206  12        li   rtmp,BEEP                  ; JSR BEEP          ; We have missile lock and an armed missile, so call
     13BA 8BA0     
4123 13BC 06A0  20        bl   @jsr                       ;
     13BE 8002     
4124                                                                          ; the BEEP subroutine to make a short, high beep
4125               
4126 13C0 D060  22        movb @XSAV,rx                   ; LDX XSAV          ; Call ABORT2 to store the details of this missile
     13C2 0093     
4127 13C4 0202  12        li   ry,>0e*256                 ; LDY #&0E          ; lock, with the targeted ship's slot number in X
     13C6 0E00     
4128 13C8 0206  12        li   rtmp,ABORT2                ; JSR ABORT2        ; (which we stored in XSAV at the start of this ship's
     13CA 709A     
4129 13CC 06A0  20        bl   @jsr                       ;
     13CE 8002     
4130                                                                          ; loop at MAL1), and set the colour of the missile
4131                                                                          ; indicator to the colour in Y (red = &0E)
4132               
4133               MA47:
4134                                                                          ; If we get here then the ship is in our sights, but
4135                                                                          ; we didn't lock a missile, so let's see if we're
4136                                                                          ; firing the laser
4137 13D0 D020  22        movb @LAS,ra                    ; LDA LAS           ; If we are firing the laser then LAS will contain the
     13D2 0051     
4138 13D4 1343  10        jeq  MA8                        ; BEQ MA8           ; laser power (which we set in MA68 above), so if this
4139                                                                          ; is zero, jump down to MA8 to skip the following
4140               
4141 13D6 0201  12        li   rx,>0f*256                 ; LDX #15           ; We are firing our laser and the ship in INWK is in
     13D8 0F00     
4142 13DA 0206  12        li   rtmp,EXNO                  ; JSR EXNO          ; the crosshairs, so call EXNO to make the sound of
     13DC 8B6A     
4143 13DE 06A0  20        bl   @jsr                       ;
     13E0 8002     
4144                                                                          ; us making a laser strike on another ship
4145               
4146 13E2 D020  22        movb @INWK+35,ra                ; LDA INWK+35       ; Fetch the hit ship's energy from byte #35 and subtract
     13E4 0076     
4147                      .sec                            ; SEC               ; our current laser power, and if the result is greater
     **** ****     > SEC
0001 13E6 0A15  14        sla  rmone,1
                   < elite.a99
4148                      .sbc @LAS,ra                    ; SBC LAS           ; than zero, the other ship has survived the hit, so
     **** ****     > SBC
0001 13E8 1801  10        joc  !
0002 13EA 7004  14        sb   rone,ra
0003               !:
0004 13EC 7020  22        sb   @LAS,ra
     13EE 0051     
                   < elite.a99
4149 13F0 182D  10        joc  MA14                       ; BCS MA14          ; jump down to MA14 to make it angry
4150               
4151 13F2 D020  22        movb @TYPE,ra                   ; LDA TYPE          ; Did we just hit the space station? If so, jump to
     13F4 009B     
4152 13F6 0280  14        ci   ra,(SST)*256               ; CMP #SST          ; MA14+2 to make the station hostile, skipping the
     13F8 0800     
4153 13FA 1329  10        jeq  MA14+2                     ; BEQ MA14+2        ; following as we can't destroy a space station
4154               
4155 13FC D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 7 of the enemy ship's byte #31, to indicate
     13FE 0072     
4156 1400 0260  14        ori  ra,>80*256                 ; ORA #%10000000    ; that it has been killed
     1402 8000     
4157 1404 D800  22        movb ra,@INWK+31                ; STA INWK+31
     1406 0072     
4158               
4159 1408 1829  10        joc  MA8                        ; BCS MA8           ; If the enemy ship type is >= SST (i.e. missile,
4160                                                                          ; asteroid, canister, Thargon or escape pod) then
4161                                                                          ; jump down to MA8
4162               
4163 140A 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Fetch a random number, and jump to oh if it is
     140C 8070     
4164 140E 06A0  20        bl   @jsr                       ;
     1410 8002     
4165 1412 1518  10        jgt  oh_                        ; BPL oh            ; positive (50% chance)
4166               
4167 1414 0202  12        li   ry,>00*256                 ; LDY #0            ; Fetch the first byte of the hit ship's blueprint,
     1416 0000     
4168                      .and_ind_y_idx @XX0,ra          ; AND (XX0),Y       ; which determines the maximum number of bits of
     **** ****     > AND_IND_Y_IDX
0001 1418 D820  30        movb @XX0,@rtmplb
     141A 001E     
     141C 830D     
0002 141E D1A0  22        movb @XX0+1,rtmp
     1420 001F     
0003 1422 A182  14        a    ry,rtmp
0004 1424 D196  22        movb *rtmp,rtmp
0005 1426 0546  10        inv  rtmp
0006 1428 5006  14        szcb rtmp,RA
                   < elite.a99
4169                                                                          ; debris shown when the ship is destroyed, and AND
4170                                                                          ; with the random number we just fetched
4171               
4172 142A D800  22        movb ra,@CNT                    ; STA CNT           ; Store the result in CNT, so CNT contains a random
     142C 00A4     
4173                                                                          ; number between 0 and the maximum number of bits of
4174                                                                          ; debris that this ship will release when destroyed
4175               
4176               um_:
4177 142E 130A  10        jeq  oh_                        ; BEQ oh            ; We're going to go round a loop using CNT as a counter
4178                                                                          ; so this checks whether the counter is zero and jumps
4179                                                                          ; to oh when it gets there (which might be straight
4180                                                                          ; away)
4181               
4182 1430 0201  12        li   rx,(OIL)*256               ; LDX #OIL          ; Call SFS1 to spawn a cargo canister from the now
     1432 0B00     
4183 1434 0200  12        li   ra,>00*256                 ; LDA #0            ; deceased parent ship, giving the spawned canister an
     1436 0000     
4184 1438 0206  12        li   rtmp,SFS1                  ; JSR SFS1          ; AI flag of 0 (no AI, no E.C.M., non-hostile)
     143A 3D02     
4185 143C 06A0  20        bl   @jsr                       ;
     143E 8002     
4186               
4187 1440 7004  14        sb   rone,ra                    ; DEC CNT           ; Decrease the loop counter
4188               
4189 1442 15F5  10        jgt  um_                        ; BPL um            ; Jump back up to um (this BPL is effectively a JMP as
4190                                                                          ; CNT will never be negative)
4191               
4192               oh_:
4193 1444 0206  12        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     1446 8B54     
4194 1448 06A0  20        bl   @jsr                       ;
     144A 8002     
4195                                                                          ; ship (so increase the kill tally, make an explosion
4196                                                                          ; sound and so on)
4197               
4198               MA14:
4199 144C D800  22        movb ra,@INWK+35                ; STA INWK+35       ; Store the hit ship's updated energy in ship byte #35
     144E 0076     
4200               
4201 1450 D020  22        movb @TYPE,ra                   ; LDA TYPE          ; Call ANGRY to make this ship hostile, now that we
     1452 009B     
4202 1454 0206  12        li   rtmp,ANGRY                 ; JSR ANGRY         ; have hit it
     1456 3C66     
4203 1458 06A0  20        bl   @jsr                       ;
     145A 8002     
4204               
4205               * ******************************************************************************
4206               *
4207               * Name: Main flight loop (Part 12 of 16)
4208               * Type: Subroutine
4209               * Category: Main loop
4210               * Summary: For each nearby ship: Draw the ship, remove if killed, loop back
4211               * Deep dive: Program flow of the main game loop
4212               * Drawing ships
4213               *
4214               * ------------------------------------------------------------------------------
4215               *
4216               * The main flight loop covers most of the flight-specific aspects of Elite. This
4217               * section covers the following:
4218               *
4219               * * Continue looping through all the ships in the local bubble, and for each
4220               * one:
4221               *
4222               * * Draw the ship
4223               *
4224               * * Process removal of killed ships
4225               *
4226               * * Loop back up to MAL1 to move onto the next ship in the local bubble
4227               *
4228               * ******************************************************************************
4229               
4230               MA8:
4231 145C 0206  12        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to draw the ship we're processing on-screen
     145E 94A8     
4232 1460 06A0  20        bl   @jsr                       ;
     1462 8002     
4233               
4234               MA15:
4235 1464 0202  12        li   ry,>23*256                 ; LDY #35           ; Fetch the ship's energy from byte #35 and copy it to
     1466 2300     
4236 1468 D020  22        movb @INWK+35,ra                ; LDA INWK+35       ; byte #35 in INF (so the ship's data in K% gets
     146A 0076     
4237                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; updated)
     **** ****     > ST_IND_Y_IDX
0001 146C D820  30        movb @INF,@rtmplb
     146E 0020     
     1470 830D     
0002 1472 D1A0  22        movb @INF+1,rtmp
     1474 0021     
0003 1476 A182  14        a    ry,rtmp
0004 1478 D580  26        movb RA,*rtmp
                   < elite.a99
4238               
4239 147A D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; If bit 7 of the ship's byte #31 is clear, then the
     147C 0072     
4240 147E 1533  10        jgt  MAC1                       ; BPL MAC1          ; ship hasn't been killed by energy bomb, collision or
4241                                                                          ; laser fire, so jump to MAC1 to skip the following
4242               
4243 1480 0240  14        andi ra,>20*256                 ; AND #%00100000    ; If bit 5 of the ship's byte #31 is clear then the
     1482 2000     
4244 1484 1330  10        jeq  NBOUN                      ; BEQ NBOUN         ; ship is no longer exploding, so jump to NBOUN to skip
4245                                                                          ; the following
4246               
4247 1486 D020  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship we just destroyed was a cop, keep going,
     1488 009B     
4248 148A 0280  14        ci   ra,(COPS)*256              ; CMP #COPS         ; otherwise jump to q2 to skip the following
     148C 0200     
4249 148E 1606  10        jne  q2_                        ; BNE q2
4250               
4251 1490 D020  22        movb @FIST,ra                   ; LDA FIST          ; We shot the sheriff, so update our FIST flag
     1492 0334     
4252 1494 0260  14        ori  ra,>40*256                 ; ORA #64           ; ("fugitive/innocent status") to at least 64, which
     1496 4000     
4253 1498 D800  22        movb ra,@FIST                   ; STA FIST          ; will instantly make us a fugitive
     149A 0334     
4254               
4255               q2_:
4256 149C D020  22        movb @DLY,ra                    ; LDA DLY           ; If we already have an in-flight message on-screen (in
     149E 0D64     
4257 14A0 F020  22        socb @MJ,ra                     ; ORA MJ            ; which case DLY > 0), or we are in witchspace (in
     14A2 0D5C     
4258 14A4 161E  10        jne  KS1S                       ; BNE KS1S          ; which case MJ > 0), jump to KS1S to skip showing an
4259                                                                          ; on-screen bounty for this kill
4260               
4261 14A6 0202  12        li   ry,>0a*256                 ; LDY #10           ; Fetch byte #10 of the ship's blueprint, which is the
     14A8 0A00     
4262                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; low byte of the bounty awarded when this ship is
     **** ****     > LD_IND_Y_IDX
0001 14AA D820  30        movb @XX0,@rtmplb
     14AC 001E     
     14AE 830D     
0002 14B0 D1A0  22        movb @XX0+1,rtmp
     14B2 001F     
0003 14B4 A182  14        a    ry,rtmp
0004 14B6 D016  22        movb *rtmp,RA
                   < elite.a99
4263 14B8 1314  10        jeq  KS1S                       ; BEQ KS1S          ; killed (in Cr * 10), and if it's zero jump to KS1S as
4264                                                                          ; there is no on-screen bounty to display
4265               
4266 14BA D040  14        movb ra,rx                      ; TAX               ; Put the low byte of the bounty into X
4267               
4268 14BC B084  14        ab   rone,ry                    ; INY               ; Fetch byte #11 of the ship's blueprint, which is the
4269                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; high byte of the bounty awarded (in Cr * 10), and put
     **** ****     > LD_IND_Y_IDX
0001 14BE D820  30        movb @XX0,@rtmplb
     14C0 001E     
     14C2 830D     
0002 14C4 D1A0  22        movb @XX0+1,rtmp
     14C6 001F     
0003 14C8 A182  14        a    ry,rtmp
0004 14CA D016  22        movb *rtmp,RA
                   < elite.a99
4270 14CC D080  14        movb ra,ry                      ; TAY               ; it into Y
4271               
4272 14CE 0206  12        li   rtmp,MCASH                 ; JSR MCASH         ; Call MCASH to add (Y X) to the cash pot
     14D0 61B2     
4273 14D2 06A0  20        bl   @jsr                       ;
     14D4 8002     
4274               
4275 14D6 0200  12        li   ra,>00*256                 ; LDA #0            ; Print control code 0 (current cash, right-aligned to
     14D8 0000     
4276 14DA 0206  12        li   rtmp,MESS                  ; JSR MESS          ; width 9, then " CR", newline) as an in-flight message
     14DC 8E52     
4277 14DE 06A0  20        bl   @jsr                       ;
     14E0 8002     
4278               
4279               KS1S:
4280 14E2 0460  20        b    @KS1                       ; JMP KS1           ; Process the killing of this ship (which removes this
     14E4 7C48     
4281                                                                          ; ship from its slot and shuffles all the other ships
4282                                                                          ; down to close up the gap)
4283               
4284               NBOUN:
4285                      equ  $
4286               MAC1:
4287 14E6 D020  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship we are processing is a planet or sun,
     14E8 009B     
4288 14EA 1105  10        jlt  MA27                       ; BMI MA27          ; jump to MA27 to skip the following two instructions
4289               
4290 14EC 0206  12        li   rtmp,FAROF                 ; JSR FAROF         ; If the ship we are processing is a long way away (its
     14EE 844A     
4291 14F0 06A0  20        bl   @jsr                       ;
     14F2 8002     
4292 14F4 17F6  10        jnc  KS1S                       ; BCC KS1S          ; distance in any one direction is > 224, jump to KS1S
4293                                                                          ; to remove the ship from our local bubble, as it's just
4294                                                                          ; left the building
4295               
4296               MA27:
4297 14F6 0202  12        li   ry,>1f*256                 ; LDY #31           ; Fetch the ship's explosion/killed state from byte #31
     14F8 1F00     
4298 14FA D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; and copy it to byte #31 in INF (so the ship's data in
     14FC 0072     
4299                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; K% gets updated)
     **** ****     > ST_IND_Y_IDX
0001 14FE D820  30        movb @INF,@rtmplb
     1500 0020     
     1502 830D     
0002 1504 D1A0  22        movb @INF+1,rtmp
     1506 0021     
0003 1508 A182  14        a    ry,rtmp
0004 150A D580  26        movb RA,*rtmp
                   < elite.a99
4300               
4301 150C D060  22        movb @XSAV,rx                   ; LDX XSAV          ; We're done processing this ship, so fetch the ship's
     150E 0093     
4302                                                                          ; slot number, which we saved in XSAV back at the start
4303                                                                          ; of the loop
4304               
4305 1510 B044  14        ab   rone,rx                    ; INX               ; Increment the slot number to move on to the next slot
4306               
4307 1512 0460  16        b    @MAL1                      ; JMP MAL1          ; And jump back up to the beginning of the loop to get
     1514 118C     
4308                                                                          ; the next ship in the local bubble for processing
4309               
4310               * ******************************************************************************
4311               *
4312               * Name: Main flight loop (Part 13 of 16)
4313               * Type: Subroutine
4314               * Category: Main loop
4315               * Summary: Show energy bomb effect, charge shields and energy banks
4316               * Deep dive: Program flow of the main game loop
4317               * Scheduling tasks with the main loop counter
4318               *
4319               * ------------------------------------------------------------------------------
4320               *
4321               * The main flight loop covers most of the flight-specific aspects of Elite. This
4322               * section covers the following:
4323               *
4324               * * Show energy bomb effect (if applicable)
4325               *
4326               * * Charge shields and energy banks (every 7 iterations of the main loop)
4327               *
4328               * ******************************************************************************
4329               
4330               MA18:
4331 1516 D020  22        movb @BOMB,ra                   ; LDA BOMB          ; If we set off our energy bomb (see MA24 above), then
     1518 032A     
4332 151A 150F  10        jgt  MA77                       ; BPL MA77          ; BOMB is now negative, so this skips to MA21 if our
4333                                                                          ; energy bomb is not going off
4334               
4335                      .asl @BOMB                      ; ASL BOMB          ; We set off our energy bomb, so rotate BOMB to the
     **** ****     > ASL
0001 151C D1A0  22        movb @BOMB,rtmp
     151E 032A     
0002 1520 0246  14        andi rtmp,>ff00
     1522 FF00     
0003 1524 0A16  14        sla  rtmp,1
0004 1526 D806  22        movb rtmp,@BOMB
     1528 032A     
                   < elite.a99
4336                                                                          ; left by one place. BOMB was rotated left once already
4337                                                                          ; during this iteration of the main loop, back at MA24,
4338                                                                          ; so if this is the first pass it will already be
4339                                                                          ; %11111110, and this will shift it to %11111100 - so
4340                                                                          ; if we set off an energy bomb, it stays activated
4341                                                                          ; (BOMB > 0) for four iterations of the main loop
4342               
4343 152A 0206  12        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     152C 4DE2     
4344 152E 06A0  20        bl   @jsr                       ;
     1530 8002     
4345                                                                          ; screen gets drawn and the following palette change
4346                                                                          ; won't kick in while the screen is still refreshing
4347               
4348 1532 0200  12        li   ra,>30*256                 ; LDA #%00110000    ; Set the palette byte at SHEILA &21 to map logical
     1534 3000     
4349 1536 D800  30        movb ra,@VIA+>21                ; STA VIA+&21       ; colour 0 to physical colour 7 (white), but with only
     1538 FE21     
4350                                                                          ; one mapping (rather than the 7 mappings required to
4351                                                                          ; do the mapping properly). This makes the space screen
4352                                                                          ; flash with black and white stripes. See p.382 of the
4353                                                                          ; Advanced User Guide for details of why this single
4354                                                                          ; palette change creates a special effect
4355               
4356               MA77:
4357 153A D020  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 7,
     153C 0099     
4358 153E 0240  14        andi ra,>07*256                 ; AND #7            ; jumping to MA22 if it is non-zero (so the following
     1540 0700     
4359 1542 1664  10        jne  MA22                       ; BNE MA22          ; code only runs every 8 iterations of the main loop)
4360               
4361 1544 D060  22        movb @ENERGY,rx                 ; LDX ENERGY        ; Fetch our ship's energy levels and skip to b if bit 7
     1546 0F13     
4362 1548 1510  10        jgt  b_                         ; BPL b             ; is not set, i.e. only charge the shields from the
4363                                                                          ; energy banks if they are at more than 50% charge
4364               
4365 154A D060  22        movb @ASH,rx                    ; LDX ASH           ; Call SHD to recharge our aft shield and update the
     154C 0F12     
4366 154E 0206  12        li   rtmp,SHD                   ; JSR SHD           ; shield status in ASH
     1550 6CD2     
4367 1552 06A0  20        bl   @jsr                       ;
     1554 8002     
4368 1556 D801  22        movb rx,@ASH                    ; STX ASH
     1558 0F12     
4369               
4370 155A D060  22        movb @FSH,rx                    ; LDX FSH           ; Call SHD to recharge our forward shield and update
     155C 0F11     
4371 155E 0206  12        li   rtmp,SHD                   ; JSR SHD           ; the shield status in FSH
     1560 6CD2     
4372 1562 06A0  20        bl   @jsr                       ;
     1564 8002     
4373 1566 D801  22        movb rx,@FSH                    ; STX FSH
     1568 0F11     
4374               
4375               b_:
4376                      .sec                            ; SEC               ; Set A = ENERGY + ENGY + 1, so our ship's energy
     **** ****     > SEC
0001 156A 0A15  14        sla  rmone,1
                   < elite.a99
4377 156C D020  22        movb @ENGY,ra                   ; LDA ENGY          ; level goes up by 2 if we have an energy unit fitted,
     156E 032B     
4378                      .adc @ENERGY,ra                 ; ADC ENERGY        ; otherwise it goes up by 1
     **** ****     > ADC
0001 1570 1701  10        jnc  !
0002 1572 B004  14        ab   rone,ra
0003               !:
0004 1574 B020  22        ab   @ENERGY,ra
     1576 0F13     
                   < elite.a99
4379               
4380 1578 1802  10        joc  B09                        ; BCS B09           ; If the value of A did not overflow (the maximum
4381 157A D800  22        movb ra,@ENERGY                 ; STA ENERGY        ; energy level is &FF), then store A in ENERGY
     157C 0F13     
4382               
4383               * ******************************************************************************
4384               *
4385               * Name: Main flight loop (Part 14 of 16)
4386               * Type: Subroutine
4387               * Category: Main loop
4388               * Summary: Spawn a space station if we are close enough to the planet
4389               * Deep dive: Program flow of the main game loop
4390               * Scheduling tasks with the main loop counter
4391               * Ship data blocks
4392               * The space station safe zone
4393               *
4394               * ------------------------------------------------------------------------------
4395               *
4396               * The main flight loop covers most of the flight-specific aspects of Elite. This
4397               * section covers the following:
4398               *
4399               * * Spawn a space station if we are close enough to the planet (every 32
4400               * iterations of the main loop)
4401               *
4402               * ******************************************************************************
4403               
4404               B09:
4405 157E D020  22        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace, jump down to MA23S to skip
     1580 0D5C     
4406 1582 1642  10        jne  MA23S                      ; BNE MA23S         ; the following, as there are no space stations in
4407                                                                          ; witchspace
4408               
4409 1584 D020  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 32,
     1586 0099     
4410 1588 0240  14        andi ra,>1f*256                 ; AND #31           ; jumping to MA93 if it is on-zero (so the following
     158A 1F00     
4411 158C 1646  10        jne  MA93                       ; BNE MA93          ; code only runs every 32 iterations of the main loop)
4412               
4413 158E D020  22        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     1590 0D55     
4414 1592 163A  10        jne  MA23S                      ; BNE MA23S         ; MA23S to skip the following, as we already have a
4415                                                                          ; space station and don't need another
4416               
4417 1594 D080  14        movb ra,ry                      ; TAY               ; Set Y = A = 0 (A is 0 as we didn't branch with the
4418                                                                          ; previous BNE instruction)
4419               
4420 1596 0206  12        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to calculate the largest distance to the
     1598 1786     
4421 159A 06A0  20        bl   @jsr                       ;
     159C 8002     
4422 159E 1634  10        jne  MA23S                      ; BNE MA23S         ; planet in any of the three axes, and if it's
4423                                                                          ; non-zero, jump to MA23S to skip the following, as we
4424                                                                          ; are too far from the planet to bump into a space
4425                                                                          ; station
4426               
4427                                                                          ; We now want to spawn a space station, so first we
4428                                                                          ; need to set up a ship data block for the station in
4429                                                                          ; INWK that we can then pass to NWSPS to add a new
4430                                                                          ; station to our bubble of universe. We do this by
4431                                                                          ; copying the planet data block from K% to INWK so we
4432                                                                          ; can work on it, but we only need the first 29 bytes,
4433                                                                          ; as we don't need to worry about bytes #29 to #35
4434                                                                          ; for planets (as they don't have rotation counters,
4435                                                                          ; AI, explosions, missiles, a ship line heap or energy
4436                                                                          ; levels)
4437               
4438 15A0 0201  12        li   rx,>1c*256                 ; LDX #28           ; So we set a counter in X to copy 29 bytes from K%+0
     15A2 1C00     
4439                                                                          ; to K%+28
4440               
4441               MAL4:
4442 15A4 D021  26        movb @K.(rx),ra                 ; LDA K%,X          ; Load the X-th byte of K% and store in the X-th byte
     15A6 0900     
4443 15A8 D840  30        movb ra,@INWK(rx)               ; STA INWK,X        ; of the INWK workspace
     15AA 0053     
4444               
4445 15AC 7044  14        sb   rone,rx                    ; DEX               ; Decrement the loop counter
4446               
4447 15AE 15FA  10        jgt  MAL4                       ; BPL MAL4          ; Loop back for the next byte until we have copied the
4448                                                                          ; first 28 bytes of K% to INWK
4449               
4450                                                                          ; We now check the distance from our ship (at the
4451                                                                          ; origin) towards the point where we will spawn the
4452                                                                          ; space station if we are close enough
4453                                                                          ;
4454                                                                          ; This point is calculated by starting at the planet's
4455                                                                          ; centre and adding 2 * nosev, which takes us to a point
4456                                                                          ; above the planet's surface, at an altitude that
4457                                                                          ; matches the planet's radius
4458                                                                          ;
4459                                                                          ; This point pitches and rolls around the planet as the
4460                                                                          ; nosev vector rotates with the planet, and if our ship
4461                                                                          ; is within a distance of (192 0) from this point in all
4462                                                                          ; three axes, then we spawn the space station at this
4463                                                                          ; point, with the station's slot facing towards the
4464                                                                          ; planet, along the nosev vector
4465                                                                          ;
4466                                                                          ; This works because in the following, we calculate the
4467                                                                          ; station's coordinates one axis at a time, and store
4468                                                                          ; the results in the INWK block, so by the time we have
4469                                                                          ; calculated and checked all three, the ship data block
4470                                                                          ; is set up with the correct spawning coordinates
4471               
4472 15B0 B044  14        ab   rone,rx                    ; INX               ; Set X = 0 (as we ended the above loop with X as &FF)
4473               
4474 15B2 0202  12        li   ry,>09*256                 ; LDY #9            ; Call MAS1 with X = 0, Y = 9 to do the following:
     15B4 0900     
4475 15B6 0206  12        li   rtmp,MAS1                  ; JSR MAS1          ;
     15B8 1738     
4476 15BA 06A0  20        bl   @jsr                       ;
     15BC 8002     
4477                                                                          ; (x_sign x_hi x_lo) += (nosev_x_hi nosev_x_lo) * 2
4478                                                                          ;
4479                                                                          ; A = |x_sign|
4480               
4481 15BE 1624  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4482                                                                          ; are too far from the planet in the x-direction to
4483                                                                          ; bump into a space station
4484               
4485 15C0 0201  12        li   rx,>03*256                 ; LDX #3            ; Call MAS1 with X = 3, Y = 11 to do the following:
     15C2 0300     
4486 15C4 0202  12        li   ry,>0b*256                 ; LDY #11           ;
     15C6 0B00     
4487 15C8 0206  12        li   rtmp,MAS1                  ; JSR MAS1          ; (y_sign y_hi y_lo) += (nosev_y_hi nosev_y_lo) * 2
     15CA 1738     
4488 15CC 06A0  20        bl   @jsr                       ;
     15CE 8002     
4489                                                                          ;
4490                                                                          ; A = |y_sign|
4491               
4492 15D0 161B  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4493                                                                          ; are too far from the planet in the y-direction to
4494                                                                          ; bump into a space station
4495               
4496 15D2 0201  12        li   rx,>06*256                 ; LDX #6            ; Call MAS1 with X = 6, Y = 13 to do the following:
     15D4 0600     
4497 15D6 0202  12        li   ry,>0d*256                 ; LDY #13           ;
     15D8 0D00     
4498 15DA 0206  12        li   rtmp,MAS1                  ; JSR MAS1          ; (z_sign z_hi z_lo) += (nosev_z_hi nosev_z_lo) * 2
     15DC 1738     
4499 15DE 06A0  20        bl   @jsr                       ;
     15E0 8002     
4500                                                                          ;
4501                                                                          ; A = |z_sign|
4502               
4503 15E2 1612  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4504                                                                          ; are too far from the planet in the z-direction to
4505                                                                          ; bump into a space station
4506               
4507 15E4 0200  12        li   ra,>c0*256                 ; LDA #192          ; Call FAROF2 to compare x_hi, y_hi and z_hi with 192,
     15E6 C000     
4508 15E8 0206  12        li   rtmp,FAROF2                ; JSR FAROF2        ; which will set the C flag if all three are < 192, or
     15EA 844E     
4509 15EC 06A0  20        bl   @jsr                       ;
     15EE 8002     
4510                                                                          ; clear the C flag if any of them are >= 192
4511               
4512 15F0 170B  10        jnc  MA23S                      ; BCC MA23S         ; Jump to MA23S if any one of x_hi, y_hi or z_hi are
4513                                                                          ; >= 192 (i.e. they must all be < 192 for us to be near
4514                                                                          ; enough to the planet to bump into a space station)
4515               
4516 15F2 D020  22        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is not a space view, skip the
     15F4 0096     
4517 15F6 1604  10        jne  B10                        ; BNE B10           ; following instruction (so we only remove the sun from
4518                                                                          ; the screen if we are potentially looking at it)
4519               
4520 15F8 0206  12        li   rtmp,WPLS                  ; JSR WPLS          ; Call WPLS to remove the sun from the screen, as we
     15FA 7970     
4521 15FC 06A0  20        bl   @jsr                       ;
     15FE 8002     
4522                                                                          ; can't have both the sun and the space station at the
4523                                                                          ; same time
4524               
4525               B10:
4526 1600 0206  12        li   rtmp,NWSPS                 ; JSR NWSPS         ; Add a new space station to our local bubble of
     1602 6F1E     
4527 1604 06A0  20        bl   @jsr                       ;
     1606 8002     
4528                                                                          ; universe
4529               
4530               MA23S:
4531 1608 0460  16        b    @MA23                      ; JMP MA23          ; Jump to MA23 to skip the following planet and sun
     160A 16EC     
4532                                                                          ; altitude checks
4533               
4534               * ******************************************************************************
4535               *
4536               * Name: Main flight loop (Part 15 of 16)
4537               * Type: Subroutine
4538               * Category: Main loop
4539               * Summary: Perform altitude checks with the planet and sun and process fuel
4540               * scooping if appropriate
4541               * Deep dive: Program flow of the main game loop
4542               * Scheduling tasks with the main loop counter
4543               *
4544               * ------------------------------------------------------------------------------
4545               *
4546               * The main flight loop covers most of the flight-specific aspects of Elite. This
4547               * section covers the following:
4548               *
4549               * * Perform an altitude check with the planet (every 32 iterations of the main
4550               * loop, on iteration 10 of each 32)
4551               *
4552               * * Perform an altitude check with the sun and process fuel scooping (every
4553               * 32 iterations of the main loop, on iteration 20 of each 32)
4554               *
4555               * ******************************************************************************
4556               
4557               MA22:
4558 160C D020  22        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace, jump down to MA23 to skip
     160E 0D5C     
4559 1610 166D  10        jne  MA23                       ; BNE MA23          ; the following, as there are no planets or suns to
4560                                                                          ; bump into in witchspace
4561               
4562 1612 D020  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 32,
     1614 0099     
4563 1616 0240  14        andi ra,>1f*256                 ; AND #31           ; which tells us the position of this loop in each block
     1618 1F00     
4564                                                                          ; of 32 iterations
4565               
4566               MA93:
4567 161A 0280  14        ci   ra,>0a*256                 ; CMP #10           ; If this is the tenth iteration in this block of 32,
     161C 0A00     
4568 161E 162D  10        jne  MA29                       ; BNE MA29          ; do the following, otherwise jump to MA29 to skip the
4569                                                                          ; planet altitude check and move on to the sun distance
4570                                                                          ; check
4571               
4572 1620 0200  12        li   ra,>32*256                 ; LDA #50           ; If our energy bank status in ENERGY is >= 50, skip
     1622 3200     
4573 1624 9020  22        cb   @ENERGY,ra                 ; CMP ENERGY        ; printing the following message (so the message is
     1626 0F13     
4574 1628 1707  10        jnc  B11                        ; BCC B11           ; only shown if our energy is low)
4575               
4576                      .asla                           ; ASL A             ; Print recursive token 100 ("ENERGY LOW{beep}") as an
     **** ****     > ASLA
0001 162A 0240  14        andi ra,>ff00
     162C FF00     
0002 162E 0A10  14        sla  ra,1
                   < elite.a99
4577 1630 0206  12        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     1632 8E52     
4578 1634 06A0  20        bl   @jsr                       ;
     1636 8002     
4579               
4580               B11:
4581 1638 0202  12        li   ry,>ff*256                 ; LDY #&FF          ; Set our altitude in ALTIT to &FF, the maximum
     163A FF00     
4582 163C D802  22        movb ry,@ALTIT                  ; STY ALTIT
     163E 0F21     
4583               
4584 1640 B084  14        ab   rone,ry                    ; INY               ; Set Y = 0
4585               
4586 1642 0206  12        li   rtmp,m_                    ; JSR m             ; Call m to calculate the maximum distance to the
     1644 1782     
4587 1646 06A0  20        bl   @jsr                       ;
     1648 8002     
4588                                                                          ; planet in any of the three axes, returned in A
4589               
4590 164A 1650  10        jne  MA23                       ; BNE MA23          ; If A > 0 then we are a fair distance away from the
4591                                                                          ; planet in at least one axis, so jump to MA23 to skip
4592                                                                          ; the rest of the altitude check
4593               
4594 164C 0206  12        li   rtmp,MAS3                  ; JSR MAS3          ; Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
     164E 179A     
4595 1650 06A0  20        bl   @jsr                       ;
     1652 8002     
4596                                                                          ; we now know that A now contains the square of the
4597                                                                          ; distance between our ship (at the origin) and the
4598                                                                          ; centre of the planet at (x_hi, y_hi, z_hi)
4599               
4600 1654 184B  10        joc  MA23                       ; BCS MA23          ; If the C flag was set by MAS3, then the result
4601                                                                          ; overflowed (was greater than &FF) and we are still a
4602                                                                          ; fair distance from the planet, so jump to MA23 as we
4603                                                                          ; haven't crashed into the planet
4604               
4605                      .sbi (>24*256)                  ; SBC #36           ; Subtract 36 from x_hi^2 + y_hi^2 + z_hi^2
     **** ****     > SBI
0001 1656 1801  10        joc  !
0002 1658 7004  14        sb   rone,ra
0003               !:
0004 165A 0220  14        ai   ra,-(>24*256)
     165C DC00     
                   < elite.a99
4606                                                                          ;
4607                                                                          ; When we do the 3D Pythagoras calculation, we only use
4608                                                                          ; the high bytes of the coordinates, so that's x_hi,
4609                                                                          ; y_hi and z_hi and
4610                                                                          ;
4611                                                                          ; The planet radius is (0 96 0), as defined in the
4612                                                                          ; PLANET routine, so the high byte is 96
4613                                                                          ;
4614                                                                          ; When we square the coordinates above and add them,
4615                                                                          ; the result gets divided by 256 (otherwise the result
4616                                                                          ; wouldn't fit into one byte), so if we do the same for
4617                                                                          ; the planet's radius, we get:
4618                                                                          ;
4619                                                                          ; 96 * 96 / 256 = 36
4620                                                                          ;
4621                                                                          ; So for the planet, the equivalent figure to test the
4622                                                                          ; sum of the _hi bytes against is 36, so A now contains
4623                                                                          ; the high byte of our altitude above the planet
4624                                                                          ; surface, squared
4625               
4626 165E 170B  10        jnc  MA28                       ; BCC MA28          ; If A < 0 then jump to MA28 as we have crashed into
4627                                                                          ; the planet
4628               
4629 1660 D800  22        movb ra,@R                      ; STA R             ; We are getting close to the planet, so we need to
     1662 0091     
4630 1664 0206  12        li   rtmp,LL5                   ; JSR LL5           ; work out how close. We know from the above that A
     1666 92AA     
4631 1668 06A0  20        bl   @jsr                       ;
     166A 8002     
4632                                                                          ; contains our altitude squared, so we store A in R
4633                                                                          ; and call LL5 to calculate:
4634                                                                          ;
4635                                                                          ; Q = SQRT(R Q) = SQRT(A Q)
4636                                                                          ;
4637                                                                          ; Interestingly, Q doesn't appear to be set to 0 for
4638                                                                          ; this calculation, so presumably this doesn't make a
4639                                                                          ; difference
4640               
4641 166C D020  22        movb @Q,ra                      ; LDA Q             ; Store the result in ALTIT, our altitude
     166E 0090     
4642 1670 D800  22        movb ra,@ALTIT                  ; STA ALTIT
     1672 0F21     
4643               
4644 1674 163B  10        jne  MA23                       ; BNE MA23          ; If our altitude is non-zero then we haven't crashed,
4645                                                                          ; so jump to MA23 to skip to the next section
4646               
4647               MA28:
4648 1676 0460  16        b    @DEATH                     ; JMP DEATH         ; If we get here then we just crashed into the planet
     1678 8472     
4649                                                                          ; or got too close to the sun, so jump to DEATH to start
4650                                                                          ; the funeral preparations and return from the main
4651                                                                          ; flight loop using a tail call
4652               
4653               MA29:
4654 167A 0280  14        ci   ra,>14*256                 ; CMP #20           ; If this is the 20th iteration in this block of 32,
     167C 1400     
4655 167E 1636  10        jne  MA23                       ; BNE MA23          ; do the following, otherwise jump to MA23 to skip the
4656                                                                          ; sun altitude check
4657               
4658 1680 0200  12        li   ra,>1e*256                 ; LDA #30           ; Set CABTMP to 30, the cabin temperature in deep space
     1682 1E00     
4659 1684 D800  22        movb ra,@CABTMP                 ; STA CABTMP        ; (i.e. one notch on the dashboard bar)
     1686 0D4D     
4660               
4661 1688 D020  22        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     168A 0D55     
4662 168C 162F  10        jne  MA23                       ; BNE MA23          ; MA23 to skip the following, as we can't have both the
4663                                                                          ; sun and space station at the same time, so we clearly
4664                                                                          ; can't be flying near the sun
4665               
4666 168E 0202  12        li   ry,(NI.)*256               ; LDY #NI%          ; Set Y to NI%, which is the offset in K% for the sun's
     1690 2400     
4667                                                                          ; data block, as the second block at K% is reserved for
4668                                                                          ; the sun (or space station)
4669               
4670 1692 0206  12        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to calculate the largest distance to the
     1694 1786     
4671 1696 06A0  20        bl   @jsr                       ;
     1698 8002     
4672 169A 1628  10        jne  MA23                       ; BNE MA23          ; sun in any of the three axes, and if it's non-zero,
4673                                                                          ; jump to MA23 to skip the following, as we are too far
4674                                                                          ; from the sun for scooping or temperature changes
4675               
4676 169C 0206  12        li   rtmp,MAS3                  ; JSR MAS3          ; Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
     169E 179A     
4677 16A0 06A0  20        bl   @jsr                       ;
     16A2 8002     
4678                                                                          ; we now know that A now contains the square of the
4679                                                                          ; distance between our ship (at the origin) and the
4680                                                                          ; heart of the sun at (x_hi, y_hi, z_hi)
4681               
4682                      .eoi (>ff*256)                  ; EOR #%11111111    ; Invert A, so A is now small if we are far from the
     **** ****     > EOI
0001 16A4 0206  12        li   rtmp,(>FF*256)
     16A6 FF00     
0002 16A8 2806  14        xor  rtmp,ra
                   < elite.a99
4683                                                                          ; sun and large if we are close to the sun, in the
4684                                                                          ; range 0 = far away to &FF = extremely close, ouch,
4685                                                                          ; hot, hot, hot!
4686               
4687                      .adi (>1e*256)                  ; ADC #30           ; Add the minimum cabin temperature of 30, so we get
     **** ****     > ADI
0001 16AA 1701  10        jnc  !
0002 16AC B004  14        ab   rone,ra
0003               !:
0004 16AE 0220  14        ai   ra,(>1E*256)
     16B0 1E00     
                   < elite.a99
4688                                                                          ; one of the following:
4689                                                                          ;
4690                                                                          ; * If the C flag is clear, A contains the cabin
4691                                                                          ; temperature, ranging from 30 to 255, that's hotter
4692                                                                          ; the closer we are to the sun
4693                                                                          ;
4694                                                                          ; * If the C flag is set, the addition has rolled over
4695                                                                          ; and the cabin temperature is over 255
4696               
4697 16B2 D800  22        movb ra,@CABTMP                 ; STA CABTMP        ; Store the updated cabin temperature
     16B4 0D4D     
4698               
4699 16B6 18DF  10        joc  MA28                       ; BCS MA28          ; If the C flag is set then jump to MA28 to die, as
4700                                                                          ; our temperature is off the scale
4701               
4702 16B8 0280  14        ci   ra,>e0*256                 ; CMP #224          ; If the cabin temperature < 224 then jump to MA23 to
     16BA E000     
4703 16BC 1717  10        jnc  MA23                       ; BCC MA23          ; skip fuel scooping, as we aren't close enough
4704               
4705 16BE D020  22        movb @BST,ra                    ; LDA BST           ; If we don't have fuel scoops fitted, jump to BA23 to
     16C0 0329     
4706 16C2 1314  10        jeq  MA23                       ; BEQ MA23          ; skip fuel scooping, as we can't scoop without fuel
4707                                                                          ; scoops
4708               
4709 16C4 D020  22        movb @DELT4+1,ra                ; LDA DELT4+1       ; We are now successfully fuel scooping, so it's time
     16C6 008E     
4710 16C8 0910  14        srl  ra,1                       ; LSR A             ; to work out how much fuel we're scooping. Fetch the
4711                                                                          ; high byte of DELT4, which contains our current speed
4712                                                                          ; divided by 4, and halve it to get our current speed
4713                                                                          ; divided by 8 (so it's now a value between 1 and 5, as
4714                                                                          ; our speed is normally between 1 and 40). This gives
4715                                                                          ; us the amount of fuel that's being scooped in A, so
4716                                                                          ; the faster we go, the more fuel we scoop, and because
4717                                                                          ; the fuel levels are stored as 10 * the fuel in light
4718                                                                          ; years, that means we just scooped between 0.1 and 0.5
4719                                                                          ; light years of free fuel
4720               
4721                      .adc @QQ14,ra                   ; ADC QQ14          ; Set A = A + the current fuel level * 10 (from QQ14)
     **** ****     > ADC
0001 16CA 1701  10        jnc  !
0002 16CC B004  14        ab   rone,ra
0003               !:
0004 16CE B020  22        ab   @QQ14,ra
     16D0 030D     
                   < elite.a99
4722               
4723 16D2 0280  14        ci   ra,>46*256                 ; CMP #70           ; If A > 70 then set A = 70 (as 70 is the maximum fuel
     16D4 4600     
4724 16D6 1702  10        jnc  B12                        ; BCC B12           ; level, or 7.0 light years)
4725 16D8 0200  12        li   ra,>46*256                 ; LDA #70
     16DA 4600     
4726               
4727               B12:
4728 16DC D800  22        movb ra,@QQ14                   ; STA QQ14          ; Store the updated fuel level in QQ14
     16DE 030D     
4729               
4730 16E0 0200  12        li   ra,>a0*256                 ; LDA #160          ; Print recursive token 0 ("FUEL SCOOPS ON") as an
     16E2 A000     
4731 16E4 0206  12        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     16E6 8E52     
4732 16E8 06A0  20        bl   @jsr                       ;
     16EA 8002     
4733               
4734               * ******************************************************************************
4735               *
4736               * Name: Main flight loop (Part 16 of 16)
4737               * Type: Subroutine
4738               * Category: Main loop
4739               * Summary: Process laser pulsing, E.C.M. energy drain, call stardust routine
4740               * Deep dive: Program flow of the main game loop
4741               *
4742               * ------------------------------------------------------------------------------
4743               *
4744               * The main flight loop covers most of the flight-specific aspects of Elite. This
4745               * section covers the following:
4746               *
4747               * * Process laser pulsing
4748               *
4749               * * Process E.C.M. energy drain
4750               *
4751               * * Jump to the stardust routine if we are in a space view
4752               *
4753               * * Return from the main flight loop
4754               *
4755               * ******************************************************************************
4756               
4757               MA23:
4758 16EC D020  22        movb @LAS2,ra                   ; LDA LAS2          ; If the current view has no laser, jump to MA16 to skip
     16EE 0D5D     
4759 16F0 130D  10        jeq  MA16                       ; BEQ MA16          ; the following
4760               
4761 16F2 D020  22        movb @LASCT,ra                  ; LDA LASCT         ; If LASCT >= 8, jump to MA16 to skip the following, so
     16F4 0D60     
4762 16F6 0280  14        ci   ra,>08*256                 ; CMP #8            ; for a pulse laser with a LASCT between 8 and 10, the
     16F8 0800     
4763 16FA 1808  10        joc  MA16                       ; BCS MA16          ; laser stays on, but for a LASCT of 7 or less it gets
4764                                                                          ; turned off and stays off until LASCT reaches zero and
4765                                                                          ; the next pulse can start (if the fire button is still
4766                                                                          ; being pressed)
4767                                                                          ;
4768                                                                          ; For pulse lasers, LASCT gets set to 10 in ma1 above,
4769                                                                          ; and it decrements every vertical sync (50 times a
4770                                                                          ; second), so this means it pulses five times a second,
4771                                                                          ; with the laser being on for the first 3/10 of each
4772                                                                          ; pulse and off for the rest of the pulse
4773                                                                          ;
4774                                                                          ; If this is a beam laser, LASCT is 0 so we always keep
4775                                                                          ; going here. This means the laser doesn't pulse, but it
4776                                                                          ; does get drawn and removed every cycle, in a slightly
4777                                                                          ; different place each time, so the beams still flicker
4778                                                                          ; around the screen
4779               
4780 16FC 0206  12        li   rtmp,LASLI2                ; JSR LASLI2        ; Redraw the existing laser lines, which has the effect
     16FE 4922     
4781 1700 06A0  20        bl   @jsr                       ;
     1702 8002     
4782                                                                          ; of removing them from the screen
4783               
4784 1704 0200  12        li   ra,>00*256                 ; LDA #0            ; Set LAS2 to 0 so if this is a pulse laser, it will
     1706 0000     
4785 1708 D800  22        movb ra,@LAS2                   ; STA LAS2          ; skip over the above until the next pulse (this has no
     170A 0D5D     
4786                                                                          ; effect if this is a beam laser)
4787               
4788               MA16:
4789 170C D020  22        movb @ECMP,ra                   ; LDA ECMP          ; If our E.C.M is not on, skip to MA69, otherwise keep
     170E 0D5B     
4790 1710 1305  10        jeq  MA69                       ; BEQ MA69          ; going to drain some energy
4791               
4792 1712 0206  12        li   rtmp,DENGY                 ; JSR DENGY         ; Call DENGY to deplete our energy banks by 1
     1714 6CD6     
4793 1716 06A0  20        bl   @jsr                       ;
     1718 8002     
4794               
4795 171A 1305  10        jeq  MA70                       ; BEQ MA70          ; If we have no energy left, jump to MA70 to turn our
4796                                                                          ; E.C.M. off
4797               
4798               MA69:
4799 171C D020  22        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M is going off (ours or an opponent's) then
     171E 0030     
4800 1720 1306  10        jeq  MA66                       ; BEQ MA66          ; keep going, otherwise skip to MA66
4801               
4802 1722 7004  14        sb   rone,ra                    ; DEC ECMA          ; Decrement the E.C.M. countdown timer, and if it has
4803 1724 1604  10        jne  MA66                       ; BNE MA66          ; reached zero, keep going, otherwise skip to MA66
4804               
4805               MA70:
4806 1726 0206  12        li   rtmp,ECMOF                 ; JSR ECMOF         ; If we get here then either we have either run out of
     1728 8B08     
4807 172A 06A0  20        bl   @jsr                       ;
     172C 8002     
4808                                                                          ; energy, or the E.C.M. timer has run down, so switch
4809                                                                          ; off the E.C.M.
4810               
4811               MA66:
4812 172E D020  22        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view (i.e. QQ11 is non-zero)
     1730 0096     
4813 1732 1625  10        jne  MA9                        ; BNE MA9           ; then jump to MA9 to return from the main flight loop
4814                                                                          ; (as MA9 is an RTS)
4815               
4816 1734 0460  20        b    @STARS                     ; JMP STARS         ; This is a space view, so jump to the STARS routine to
     1736 299A     
4817                                                                          ; process the stardust, and return from the main flight
4818                                                                          ; loop using a tail call
4819               
4820               * ******************************************************************************
4821               *
4822               * Name: MAS1
4823               * Type: Subroutine
4824               * Category: Maths (Geometry)
4825               * Summary: Add an orientation vector coordinate to an INWK coordinate
4826               * Deep dive: The space station safe zone
4827               *
4828               * ------------------------------------------------------------------------------
4829               *
4830               * Add a doubled nosev vector coordinate, e.g. (nosev_y_hi nosev_y_lo) * 2, to
4831               * an INWK coordinate, e.g. (x_sign x_hi x_lo), storing the result in the INWK
4832               * coordinate. The axes used in each side of the addition are specified by the
4833               * arguments X and Y.
4834               *
4835               * In the comments below, we document the routine as if we are doing the
4836               * following, i.e. if X = 0 and Y = 11:
4837               *
4838               * (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (nosev_y_hi nosev_y_lo) * 2
4839               *
4840               * as that way the variable names in the comments contain "x" and "y" to match
4841               * the registers that specify the vector axis to use.
4842               *
4843               * ------------------------------------------------------------------------------
4844               *
4845               * Arguments:
4846               *
4847               * X                   The coordinate to add, as follows:
4848               *
4849               * * If X = 0, add (x_sign x_hi x_lo)
4850               * * If X = 3, add (y_sign y_hi y_lo)
4851               * * If X = 6, add (z_sign z_hi z_lo)
4852               *
4853               * Y                   The vector to add, as follows:
4854               *
4855               * * If Y = 9,  add (nosev_x_hi nosev_x_lo)
4856               * * If Y = 11, add (nosev_y_hi nosev_y_lo)
4857               * * If Y = 13, add (nosev_z_hi nosev_z_lo)
4858               *
4859               * ------------------------------------------------------------------------------
4860               *
4861               * Returns:
4862               *
4863               * A                   The highest byte of the result with the sign cleared
4864               * (e.g. |x_sign| when X = 0, etc.)
4865               *
4866               * ------------------------------------------------------------------------------
4867               *
4868               * Other entry points:
4869               *
4870               * MA9                 Contains an RTS
4871               *
4872               * ******************************************************************************
4873               
4874               MAS1:
4875 1738 D022  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Set K(2 1) = (nosev_y_hi nosev_y_lo) * 2
     173A 0053     
4876                      .asla                           ; ASL A
     **** ****     > ASLA
0001 173C 0240  14        andi ra,>ff00
     173E FF00     
0002 1740 0A10  14        sla  ra,1
                   < elite.a99
4877 1742 D800  22        movb ra,@K+1                    ; STA K+1
     1744 003E     
4878 1746 D022  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y
     1748 0054     
4879 174A 06A0  20        bl   @rola                      ; ROL A
     174C 8018     
4880 174E D800  22        movb ra,@K+2                    ; STA K+2
     1750 003F     
4881               
4882 1752 0200  12        li   ra,>00*256                 ; LDA #0            ; Set K+3 bit 7 to the C flag, so the sign bit of the
     1754 0000     
4883 1756 06A0  20        bl   @rora                      ; ROR A             ; above result goes into K+3
     1758 803C     
4884 175A D800  22        movb ra,@K+3                    ; STA K+3
     175C 0040     
4885               
4886 175E 0206  12        li   rtmp,MVT3                  ; JSR MVT3          ; Add (x_sign x_hi x_lo) to K(3 2 1)
     1760 1C88     
4887 1762 06A0  20        bl   @jsr                       ;
     1764 8002     
4888               
4889 1766 D840  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X      ; Store the sign of the result in x_sign
     1768 0055     
4890               
4891 176A D0A0  22        movb @K+1,ry                    ; LDY K+1           ; Store K(2 1) in (x_hi x_lo)
     176C 003E     
4892 176E D842  30        movb ry,@INWK(rx)               ; STY INWK,X
     1770 0053     
4893 1772 D0A0  22        movb @K+2,ry                    ; LDY K+2
     1774 003F     
4894 1776 D842  30        movb ry,@INWK+1(rx)             ; STY INWK+1,X
     1778 0054     
4895               
4896 177A 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; Set A to the sign byte with the sign cleared,
     177C 7F00     
4897                                                                          ; i.e. |x_sign| when X = 0
4898               
4899               MA9:
4900 177E 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     1780 800E     
4901               
4902               * ******************************************************************************
4903               *
4904               * Name: MAS2
4905               * Type: Subroutine
4906               * Category: Maths (Geometry)
4907               * Summary: Calculate a cap on the maximum distance to the planet or sun
4908               *
4909               * ------------------------------------------------------------------------------
4910               *
4911               * Given a value in Y that points to the start of a ship data block as an offset
4912               * from K%, calculate the following:
4913               *
4914               * A = A OR x_sign OR y_sign OR z_sign
4915               *
4916               * and clear the sign bit of the result. The K% workspace contains the ship data
4917               * blocks, so the offset in Y must be 0 or a multiple of NI% (as each block in
4918               * K% contains NI% bytes).
4919               *
4920               * The result effectively contains a maximum cap of the three values (though it
4921               * might not be one of the three input values - it's just guaranteed to be
4922               * larger than all of them).
4923               *
4924               * If Y = 0 and A = 0, then this calculates the maximum cap of the highest byte
4925               * containing the distance to the planet, as K%+2 = x_sign, K%+5 = y_sign and
4926               * K%+8 = z_sign (the first slot in the K% workspace represents the planet).
4927               *
4928               * ------------------------------------------------------------------------------
4929               *
4930               * Arguments:
4931               *
4932               * Y                   The offset from K% for the start of the ship data block
4933               * to use
4934               *
4935               * ------------------------------------------------------------------------------
4936               *
4937               * Returns:
4938               *
4939               * A                   A OR K%+2+Y OR K%+5+Y OR K%+8+Y, with bit 7 cleared
4940               *
4941               * ------------------------------------------------------------------------------
4942               *
4943               * Other entry points:
4944               *
4945               * m                   Do not include A in the calculation
4946               *
4947               * ******************************************************************************
4948               
4949               m_:
4950 1782 0200  12        li   ra,>00*256                 ; LDA #0            ; Set A = 0 and fall through into MAS2 to calculate the
     1784 0000     
4951                                                                          ; OR of the three bytes at K%+2+Y, K%+5+Y and K%+8+Y
4952               
4953               MAS2:
4954 1786 F022  26        socb @K.+2(ry),ra               ; ORA K%+2,Y        ; Set A = A OR x_sign OR y_sign OR z_sign
     1788 0902     
4955 178A F022  26        socb @K.+5(ry),ra               ; ORA K%+5,Y
     178C 0905     
4956 178E F022  26        socb @K.+8(ry),ra               ; ORA K%+8,Y
     1790 0908     
4957               
4958 1792 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; Clear bit 7 in A
     1794 7F00     
4959               
4960 1796 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     1798 800E     
4961               
4962               * ******************************************************************************
4963               *
4964               * Name: MAS3
4965               * Type: Subroutine
4966               * Category: Maths (Arithmetic)
4967               * Summary: Calculate A = x_hi^2 + y_hi^2 + z_hi^2 in the K% block
4968               *
4969               * ------------------------------------------------------------------------------
4970               *
4971               * Given a value in Y that points to the start of a ship data block as an offset
4972               * from K%, calculate the following:
4973               *
4974               * A = x_hi^2 + y_hi^2 + z_hi^2
4975               *
4976               * returning A = &FF if the calculation overflows a one-byte result. The K%
4977               * workspace contains the ship data blocks, so the offset in Y must be 0 or a
4978               * multiple of NI% (as each block in K% contains NI% bytes).
4979               *
4980               * ------------------------------------------------------------------------------
4981               *
4982               * Arguments:
4983               *
4984               * Y                   The offset from K% for the start of the ship data block
4985               * to use
4986               *
4987               * Returns
4988               *
4989               * A                   A = x_hi^2 + y_hi^2 + z_hi^2
4990               *
4991               * A = &FF if the calculation overflows a one-byte result
4992               *
4993               * ******************************************************************************
4994               
4995               MAS3:
4996 179A D022  26        movb @K.+1(ry),ra               ; LDA K%+1,Y        ; Set (A P) = x_hi * x_hi
     179C 0901     
4997 179E 0206  12        li   rtmp,SQUA2                 ; JSR SQUA2
     17A0 42BA     
4998 17A2 06A0  20        bl   @jsr                       ;
     17A4 8002     
4999               
5000 17A6 D800  22        movb ra,@R                      ; STA R             ; Store A (high byte of result) in R
     17A8 0091     
5001               
5002 17AA D022  26        movb @K.+4(ry),ra               ; LDA K%+4,Y        ; Set (A P) = y_hi * y_hi
     17AC 0904     
5003 17AE 0206  12        li   rtmp,SQUA2                 ; JSR SQUA2
     17B0 42BA     
5004 17B2 06A0  20        bl   @jsr                       ;
     17B4 8002     
5005               
5006                      .adc @R,ra                      ; ADC R             ; Add A (high byte of second result) to R
     **** ****     > ADC
0001 17B6 1701  10        jnc  !
0002 17B8 B004  14        ab   rone,ra
0003               !:
0004 17BA B020  22        ab   @R,ra
     17BC 0091     
                   < elite.a99
5007               
5008 17BE 180D  10        joc  MA30                       ; BCS MA30          ; If the addition of the two high bytes caused a carry
5009                                                                          ; (i.e. they overflowed), jump to MA30 to return A = &FF
5010               
5011 17C0 D800  22        movb ra,@R                      ; STA R             ; Store A (sum of the two high bytes) in R
     17C2 0091     
5012               
5013 17C4 D022  26        movb @K.+7(ry),ra               ; LDA K%+7,Y        ; Set (A P) = z_hi * z_hi
     17C6 0907     
5014 17C8 0206  12        li   rtmp,SQUA2                 ; JSR SQUA2
     17CA 42BA     
5015 17CC 06A0  20        bl   @jsr                       ;
     17CE 8002     
5016               
5017                      .adc @R,ra                      ; ADC R             ; Add A (high byte of third result) to R, so R now
     **** ****     > ADC
0001 17D0 1701  10        jnc  !
0002 17D2 B004  14        ab   rone,ra
0003               !:
0004 17D4 B020  22        ab   @R,ra
     17D6 0091     
                   < elite.a99
5018                                                                          ; contains the sum of x_hi^2 + y_hi^2 + z_hi^2
5019               
5020 17D8 1702  10        jnc  B13                        ; BCC B13           ; If there is no carry, skip the following instruction
5021                                                                          ; to return straight from the subroutine
5022               
5023               MA30:
5024 17DA 0200  12        li   ra,>ff*256                 ; LDA #&FF          ; The calculation has overflowed, so set A = &FF
     17DC FF00     
5025               
5026               B13:
5027 17DE 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     17E0 800E     
5028               
5029               * ******************************************************************************
5030               *
5031               * Name: MVEIT (Part 1 of 9)
5032               * Type: Subroutine
5033               * Category: Moving
5034               * Summary: Move current ship: Tidy the orientation vectors
5035               * Deep dive: Program flow of the ship-moving routine
5036               * Scheduling tasks with the main loop counter
5037               *
5038               * ------------------------------------------------------------------------------
5039               *
5040               * This routine has multiple stages. This stage does the following:
5041               *
5042               * * Tidy the orientation vectors for one of the ship slots
5043               *
5044               * ------------------------------------------------------------------------------
5045               *
5046               * Arguments:
5047               *
5048               * INWK                The current ship/planet/sun's data block
5049               *
5050               * XSAV                The slot number of the current ship/planet/sun
5051               *
5052               * TYPE                The type of the current ship/planet/sun
5053               *
5054               * ******************************************************************************
5055               
5056               MVEIT:
5057 17E2 D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; If bits 5 or 7 of ship byte #31 are set, jump to MV30
     17E4 0072     
5058 17E6 0240  14        andi ra,>a0*256                 ; AND #%10100000    ; as the ship is either exploding or has been killed, so
     17E8 A000     
5059 17EA 1623  10        jne  MV30                       ; BNE MV30          ; we don't need to tidy its orientation vectors or apply
5060                                                                          ; tactics
5061               
5062 17EC D020  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter
     17EE 0099     
5063               
5064                      .eor @XSAV                      ; EOR XSAV          ; Fetch the slot number of the ship we are moving, EOR
     **** ****     > EOR
0001 17F0 D1A0  22        movb @XSAV,rtmp
     17F2 0093     
0002 17F4 2806  14        xor  rtmp,ra
                   < elite.a99
5065 17F6 0240  14        andi ra,>0f*256                 ; AND #15           ; with the loop counter and apply mod 15 to the result.
     17F8 0F00     
5066 17FA 1604  10        jne  MV3                        ; BNE MV3           ; The result will be zero when "counter mod 15" matches
5067                                                                          ; the slot number, so this makes sure we call TIDY 12
5068                                                                          ; times every 16 main loop iterations, like this:
5069                                                                          ;
5070                                                                          ; Iteration 0, tidy the ship in slot 0
5071                                                                          ; Iteration 1, tidy the ship in slot 1
5072                                                                          ; Iteration 2, tidy the ship in slot 2
5073                                                                          ; ...
5074                                                                          ; Iteration 11, tidy the ship in slot 11
5075                                                                          ; Iteration 12, do nothing
5076                                                                          ; Iteration 13, do nothing
5077                                                                          ; Iteration 14, do nothing
5078                                                                          ; Iteration 15, do nothing
5079                                                                          ; Iteration 16, tidy the ship in slot 0
5080                                                                          ; ...
5081                                                                          ;
5082                                                                          ; and so on
5083               
5084 17FC 0206  12        li   rtmp,TIDY                  ; JSR TIDY          ; Call TIDY to tidy up the orientation vectors, to
     17FE 8F9C     
5085 1800 06A0  20        bl   @jsr                       ;
     1802 8002     
5086                                                                          ; prevent the ship from getting elongated and out of
5087                                                                          ; shape due to the imprecise nature of trigonometry
5088                                                                          ; in assembly language
5089               
5090               * ******************************************************************************
5091               *
5092               * Name: MVEIT (Part 2 of 9)
5093               * Type: Subroutine
5094               * Category: Moving
5095               * Summary: Move current ship: Call tactics routine, remove ship from scanner
5096               * Deep dive: Scheduling tasks with the main loop counter
5097               *
5098               * ------------------------------------------------------------------------------
5099               *
5100               * This routine has multiple stages. This stage does the following:
5101               *
5102               * * Apply tactics to ships with AI enabled (by calling the TACTICS routine)
5103               *
5104               * * Remove the ship from the scanner, so we can move it
5105               *
5106               * ******************************************************************************
5107               
5108               MV3:
5109 1804 D060  22        movb @TYPE,rx                   ; LDX TYPE          ; If the type of the ship we are moving is positive,
     1806 009B     
5110 1808 1502  10        jgt  B14                        ; BPL B14           ; i.e. it is not a planet (types 128 and 130) or sun
5111                                                                          ; (type 129), then skip the following instruction
5112               
5113 180A 0460  20        b    @MV40                      ; JMP MV40          ; This item is the planet or sun, so jump to MV40 to
     180C 2002     
5114                                                                          ; move it, which ends by jumping back into this routine
5115                                                                          ; at MV45 (after all the rotation, tactics and scanner
5116                                                                          ; code, which we don't need to apply to planets or suns)
5117               
5118               B14:
5119 180E D020  22        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the ship's byte #32 (AI flag) into A
     1810 0073     
5120               
5121 1812 150F  10        jgt  MV30                       ; BPL MV30          ; If bit 7 of the AI flag is clear, then if this is a
5122                                                                          ; ship or missile it is dumb and has no AI, and if this
5123                                                                          ; is the space station it is not hostile, so in both
5124                                                                          ; cases skip the following as it has no tactics
5125               
5126 1814 0281  14        ci   rx,(MSL)*256               ; CPX #MSL          ; If the ship is a missile, skip straight to MV26 to
     1816 0900     
5127 1818 1308  10        jeq  MV26                       ; BEQ MV26          ; call the TACTICS routine, as we do this every
5128                                                                          ; iteration of the main loop for missiles only
5129               
5130 181A D020  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter
     181C 0099     
5131               
5132                      .eor @XSAV                      ; EOR XSAV          ; Fetch the slot number of the ship we are moving, EOR
     **** ****     > EOR
0001 181E D1A0  22        movb @XSAV,rtmp
     1820 0093     
0002 1822 2806  14        xor  rtmp,ra
                   < elite.a99
5133 1824 0240  14        andi ra,>07*256                 ; AND #7            ; with the loop counter and apply mod 8 to the result.
     1826 0700     
5134 1828 1604  10        jne  MV30                       ; BNE MV30          ; The result will be zero when "counter mod 8" matches
5135                                                                          ; the slot number mod 8, so this makes sure we call
5136                                                                          ; TACTICS 12 times every 8 main loop iterations, like
5137                                                                          ; this:
5138                                                                          ;
5139                                                                          ; Iteration 0, apply tactics to slots 0 and 8
5140                                                                          ; Iteration 1, apply tactics to slots 1 and 9
5141                                                                          ; Iteration 2, apply tactics to slots 2 and 10
5142                                                                          ; Iteration 3, apply tactics to slots 3 and 11
5143                                                                          ; Iteration 4, apply tactics to slot 4
5144                                                                          ; Iteration 5, apply tactics to slot 5
5145                                                                          ; Iteration 6, apply tactics to slot 6
5146                                                                          ; Iteration 7, apply tactics to slot 7
5147                                                                          ; Iteration 8, apply tactics to slots 0 and 8
5148                                                                          ; ...
5149                                                                          ;
5150                                                                          ; and so on
5151               
5152               MV26:
5153 182A 0206  12        li   rtmp,TACTICS               ; JSR TACTICS       ; Call TACTICS to apply AI tactics to this ship
     182C 37FC     
5154 182E 06A0  20        bl   @jsr                       ;
     1830 8002     
5155               
5156               MV30:
5157 1832 0206  12        li   rtmp,SCAN                  ; JSR SCAN          ; Draw the ship on the scanner, which has the effect of
     1834 4C86     
5158 1836 06A0  20        bl   @jsr                       ;
     1838 8002     
5159                                                                          ; removing it, as it's already at this point and hasn't
5160                                                                          ; yet moved
5161               
5162               * ******************************************************************************
5163               *
5164               * Name: MVEIT (Part 3 of 9)
5165               * Type: Subroutine
5166               * Category: Moving
5167               * Summary: Move current ship: Move ship forward according to its speed
5168               *
5169               * ------------------------------------------------------------------------------
5170               *
5171               * This routine has multiple stages. This stage does the following:
5172               *
5173               * * Move the ship forward (along the vector pointing in the direction of
5174               * travel) according to its speed:
5175               *
5176               * (x, y, z) += nosev_hi * speed / 64
5177               *
5178               * ******************************************************************************
5179               
5180 183A D020  22        movb @INWK+27,ra                ; LDA INWK+27       ; Set Q = the ship's speed byte #27 * 4
     183C 006E     
5181                      .asla                           ; ASL A
     **** ****     > ASLA
0001 183E 0240  14        andi ra,>ff00
     1840 FF00     
0002 1842 0A10  14        sla  ra,1
                   < elite.a99
5182                      .asla                           ; ASL A
     **** ****     > ASLA
0001 1844 0240  14        andi ra,>ff00
     1846 FF00     
0002 1848 0A10  14        sla  ra,1
                   < elite.a99
5183 184A D800  22        movb ra,@Q                      ; STA Q
     184C 0090     
5184               
5185 184E D020  22        movb @INWK+10,ra                ; LDA INWK+10       ; Set A = |nosev_x_hi|
     1850 005D     
5186 1852 0240  14        andi ra,>7f*256                 ; AND #%01111111
     1854 7F00     
5187               
5188 1856 0206  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     1858 4338     
5189 185A 06A0  20        bl   @jsr                       ;
     185C 8002     
5190 185E D800  22        movb ra,@R                      ; STA R             ; = |nosev_x_hi| * speed / 64
     1860 0091     
5191               
5192 1862 D020  22        movb @INWK+10,ra                ; LDA INWK+10       ; If nosev_x_hi is positive, then:
     1864 005D     
5193 1866 0201  12        li   rx,>00*256                 ; LDX #0            ;
     1868 0000     
5194 186A 0206  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + R
     186C 1BA8     
5195 186E 06A0  20        bl   @jsr                       ;
     1870 8002     
5196                                                                          ;
5197                                                                          ; If nosev_x_hi is negative, then:
5198                                                                          ;
5199                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - R
5200                                                                          ;
5201                                                                          ; So in effect, this does:
5202                                                                          ;
5203                                                                          ; (x_sign x_hi x_lo) += nosev_x_hi * speed / 64
5204               
5205 1872 D020  22        movb @INWK+12,ra                ; LDA INWK+12       ; Set A = |nosev_y_hi|
     1874 005F     
5206 1876 0240  14        andi ra,>7f*256                 ; AND #%01111111
     1878 7F00     
5207               
5208 187A 0206  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     187C 4338     
5209 187E 06A0  20        bl   @jsr                       ;
     1880 8002     
5210 1882 D800  22        movb ra,@R                      ; STA R             ; = |nosev_y_hi| * speed / 64
     1884 0091     
5211               
5212 1886 D020  22        movb @INWK+12,ra                ; LDA INWK+12       ; If nosev_y_hi is positive, then:
     1888 005F     
5213 188A 0201  12        li   rx,>03*256                 ; LDX #3            ;
     188C 0300     
5214 188E 0206  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (y_sign y_hi y_lo) = (y_sign y_hi y_lo) + R
     1890 1BA8     
5215 1892 06A0  20        bl   @jsr                       ;
     1894 8002     
5216                                                                          ;
5217                                                                          ; If nosev_y_hi is negative, then:
5218                                                                          ;
5219                                                                          ; (y_sign y_hi y_lo) = (y_sign y_hi y_lo) - R
5220                                                                          ;
5221                                                                          ; So in effect, this does:
5222                                                                          ;
5223                                                                          ; (y_sign y_hi y_lo) += nosev_y_hi * speed / 64
5224               
5225 1896 D020  22        movb @INWK+14,ra                ; LDA INWK+14       ; Set A = |nosev_z_hi|
     1898 0061     
5226 189A 0240  14        andi ra,>7f*256                 ; AND #%01111111
     189C 7F00     
5227               
5228 189E 0206  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     18A0 4338     
5229 18A2 06A0  20        bl   @jsr                       ;
     18A4 8002     
5230 18A6 D800  22        movb ra,@R                      ; STA R             ; = |nosev_z_hi| * speed / 64
     18A8 0091     
5231               
5232 18AA D020  22        movb @INWK+14,ra                ; LDA INWK+14       ; If nosev_y_hi is positive, then:
     18AC 0061     
5233 18AE 0201  12        li   rx,>06*256                 ; LDX #6            ;
     18B0 0600     
5234 18B2 0206  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + R
     18B4 1BA8     
5235 18B6 06A0  20        bl   @jsr                       ;
     18B8 8002     
5236                                                                          ;
5237                                                                          ; If nosev_z_hi is negative, then:
5238                                                                          ;
5239                                                                          ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) - R
5240                                                                          ;
5241                                                                          ; So in effect, this does:
5242                                                                          ;
5243                                                                          ; (z_sign z_hi z_lo) += nosev_z_hi * speed / 64
5244               
5245               * ******************************************************************************
5246               *
5247               * Name: MVEIT (Part 4 of 9)
5248               * Type: Subroutine
5249               * Category: Moving
5250               * Summary: Move current ship: Apply acceleration to ship's speed as a one-off
5251               *
5252               * ------------------------------------------------------------------------------
5253               *
5254               * This routine has multiple stages. This stage does the following:
5255               *
5256               * * Apply acceleration to the ship's speed (if acceleration is non-zero),
5257               * and then zero the acceleration as it's a one-off change
5258               *
5259               * ******************************************************************************
5260               
5261 18BA D020  22        movb @INWK+27,ra                ; LDA INWK+27       ; Set A = the ship's speed in byte #24 + the ship's
     18BC 006E     
5262                      .clc                            ; CLC               ; acceleration in byte #28
     **** ****     > CLC
0001 18BE 0A13  14        sla  rzero,1
                   < elite.a99
5263                      .adc @INWK+28,ra                ; ADC INWK+28
     **** ****     > ADC
0001 18C0 1701  10        jnc  !
0002 18C2 B004  14        ab   rone,ra
0003               !:
0004 18C4 B020  22        ab   @INWK+28,ra
     18C6 006F     
                   < elite.a99
5264               
5265 18C8 1502  10        jgt  B15                        ; BPL B15           ; If the result is positive, skip the following
5266                                                                          ; instruction
5267               
5268 18CA 0200  12        li   ra,>00*256                 ; LDA #0            ; Set A to 0 to stop the speed from going negative
     18CC 0000     
5269               
5270               B15:
5271 18CE 0202  12        li   ry,>0f*256                 ; LDY #15           ; We now fetch byte #15 from the ship's blueprint, which
     18D0 0F00     
5272                                                                          ; contains the ship's maximum speed, so set Y = 15 to
5273                                                                          ; use as an index
5274               
5275                      .cmp_ind_y_idx @XX0,ra          ; CMP (XX0),Y       ; If A < the ship's maximum speed, skip the following
     **** ****     > CMP_IND_Y_IDX
0001 18D2 D820  30        movb @XX0,@rtmplb
     18D4 001E     
     18D6 830D     
0002 18D8 D1A0  22        movb @XX0+1,rtmp
     18DA 001F     
0003 18DC A182  14        a    ry,rtmp
0004 18DE D196  22        movb *rtmp,rtmp
0005 18E0 9180  14        cb   ra,rtmp
                   < elite.a99
5276 18E2 1707  10        jnc  B16                        ; BCC B16           ; instruction
5277               
5278                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; Set A to the ship's maximum speed
     **** ****     > LD_IND_Y_IDX
0001 18E4 D820  30        movb @XX0,@rtmplb
     18E6 001E     
     18E8 830D     
0002 18EA D1A0  22        movb @XX0+1,rtmp
     18EC 001F     
0003 18EE A182  14        a    ry,rtmp
0004 18F0 D016  22        movb *rtmp,RA
                   < elite.a99
5279               
5280               B16:
5281 18F2 D800  22        movb ra,@INWK+27                ; STA INWK+27       ; We have now calculated the new ship's speed after
     18F4 006E     
5282                                                                          ; accelerating and keeping the speed within the ship's
5283                                                                          ; limits, so store the updated speed in byte #27
5284               
5285 18F6 0200  12        li   ra,>00*256                 ; LDA #0            ; We have added the ship's acceleration, so we now set
     18F8 0000     
5286 18FA D800  22        movb ra,@INWK+28                ; STA INWK+28       ; it back to 0 in byte #28, as it's a one-off change
     18FC 006F     
5287               
5288               * ******************************************************************************
5289               *
5290               * Name: MVEIT (Part 5 of 9)
5291               * Type: Subroutine
5292               * Category: Moving
5293               * Summary: Move current ship: Rotate ship's location by our pitch and roll
5294               * Deep dive: Rotating the universe
5295               *
5296               * ------------------------------------------------------------------------------
5297               *
5298               * This routine has multiple stages. This stage does the following:
5299               *
5300               * * Rotate the ship's location in space by the amount of pitch and roll of
5301               * our ship. See below for a deeper explanation of this routine
5302               *
5303               * ******************************************************************************
5304               
5305 18FE D060  22        movb @ALP1,rx                   ; LDX ALP1          ; Fetch the magnitude of the current roll into X, so
     1900 0087     
5306                                                                          ; if the roll angle is alpha, X contains |alpha|
5307               
5308 1902 D020  22        movb @INWK,ra                   ; LDA INWK          ; Set P = ~x_lo (i.e. with all its bits flipped) so that
     1904 0053     
5309                      .eoi (>ff*256)                  ; EOR #%11111111    ; we can pass x_lo to MLTU2 below)
     **** ****     > EOI
0001 1906 0206  12        li   rtmp,(>FF*256)
     1908 FF00     
0002 190A 2806  14        xor  rtmp,ra
                   < elite.a99
5310 190C D800  22        movb ra,@P                      ; STA P
     190E 001B     
5311               
5312 1910 D020  22        movb @INWK+1,ra                 ; LDA INWK+1        ; Set A = x_hi
     1912 0054     
5313               
5314 1914 0206  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     1916 437E     
5315 1918 06A0  20        bl   @jsr                       ;
     191A 8002     
5316                                                                          ; = (x_hi x_lo) * alpha
5317               
5318 191C D800  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     191E 001D     
5319                                                                          ; have:
5320                                                                          ;
5321                                                                          ; P(2 1 0) = (x_hi x_lo) * alpha
5322               
5323 1920 D020  22        movb @ALP2+1,ra                 ; LDA ALP2+1        ; Fetch the flipped sign of the current roll angle alpha
     1922 0089     
5324                      .eor @INWK+2                    ; EOR INWK+2        ; from ALP2+1 and EOR with byte #2 (x_sign), so if the
     **** ****     > EOR
0001 1924 D1A0  22        movb @INWK+2,rtmp
     1926 0055     
0002 1928 2806  14        xor  rtmp,ra
                   < elite.a99
5325                                                                          ; flipped roll angle and x_sign have the same sign, A
5326                                                                          ; will be positive, else it will be negative. So A will
5327                                                                          ; contain the sign bit of x_sign * flipped alpha sign,
5328                                                                          ; which is the opposite to the sign of the above result,
5329                                                                          ; so we now have:
5330                                                                          ;
5331                                                                          ; (A P+2 P+1) = - (x_sign x_hi x_lo) * alpha / 256
5332               
5333 192A 0201  12        li   rx,>03*256                 ; LDX #3            ; Set (A P+2 P+1) = (y_sign y_hi y_lo) + (A P+2 P+1)
     192C 0300     
5334 192E 0206  12        li   rtmp,MVT6                  ; JSR MVT6          ; = y - x * alpha / 256
     1930 1F7A     
5335 1932 06A0  20        bl   @jsr                       ;
     1934 8002     
5336               
5337 1936 D800  22        movb ra,@K2+3                   ; STA K2+3          ; Set K2(3) = A = the sign of the result
     1938 00AF     
5338               
5339 193A D020  22        movb @P+1,ra                    ; LDA P+1           ; Set K2(1) = P+1, the low byte of the result
     193C 001C     
5340 193E D800  22        movb ra,@K2+1                   ; STA K2+1
     1940 00AD     
5341               
5342                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set P = ~K2+1 (i.e. with all its bits flipped) so
     **** ****     > EOI
0001 1942 0206  12        li   rtmp,(>FF*256)
     1944 FF00     
0002 1946 2806  14        xor  rtmp,ra
                   < elite.a99
5343 1948 D800  22        movb ra,@P                      ; STA P             ; that we can pass K2+1 to MLTU2 below)
     194A 001B     
5344               
5345 194C D020  22        movb @P+2,ra                    ; LDA P+2           ; Set K2(2) = A = P+2
     194E 001D     
5346 1950 D800  22        movb ra,@K2+2                   ; STA K2+2
     1952 00AE     
5347               
5348                                                                          ; So we now have result 1 above:
5349                                                                          ;
5350                                                                          ; K2(3 2 1) = (A P+2 P+1)
5351                                                                          ; = y - x * alpha / 256
5352               
5353 1954 D060  22        movb @BET1,rx                   ; LDX BET1          ; Fetch the magnitude of the current pitch into X, so
     1956 002B     
5354                                                                          ; if the pitch angle is beta, X contains |beta|
5355               
5356 1958 0206  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     195A 437E     
5357 195C 06A0  20        bl   @jsr                       ;
     195E 8002     
5358                                                                          ; = K2(2 1) * beta
5359               
5360 1960 D800  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     1962 001D     
5361                                                                          ; have:
5362                                                                          ;
5363                                                                          ; P(2 1 0) = K2(2 1) * beta
5364               
5365 1964 D020  22        movb @K2+3,ra                   ; LDA K2+3          ; Fetch the sign of the above result in K(3 2 1) from
     1966 00AF     
5366                      .eor @BET2                      ; EOR BET2          ; K2+3 and EOR with BET2, the sign of the current pitch
     **** ****     > EOR
0001 1968 D1A0  22        movb @BET2,rtmp
     196A 008A     
0002 196C 2806  14        xor  rtmp,ra
                   < elite.a99
5367                                                                          ; rate, so if the pitch and K(3 2 1) have the same sign,
5368                                                                          ; A will be positive, else it will be negative. So A
5369                                                                          ; will contain the sign bit of K(3 2 1) * beta, which is
5370                                                                          ; the same as the sign of the above result, so we now
5371                                                                          ; have:
5372                                                                          ;
5373                                                                          ; (A P+2 P+1) = K2(3 2 1) * beta / 256
5374               
5375 196E 0201  12        li   rx,>06*256                 ; LDX #6            ; Set (A P+2 P+1) = (z_sign z_hi z_lo) + (A P+2 P+1)
     1970 0600     
5376 1972 0206  12        li   rtmp,MVT6                  ; JSR MVT6          ; = z + K2 * beta / 256
     1974 1F7A     
5377 1976 06A0  20        bl   @jsr                       ;
     1978 8002     
5378               
5379 197A D800  22        movb ra,@INWK+8                 ; STA INWK+8        ; Set z_sign = A = the sign of the result
     197C 005B     
5380               
5381 197E D020  22        movb @P+1,ra                    ; LDA P+1           ; Set z_lo = P+1, the low byte of the result
     1980 001C     
5382 1982 D800  22        movb ra,@INWK+6                 ; STA INWK+6
     1984 0059     
5383               
5384                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set P = ~z_lo (i.e. with all its bits flipped) so that
     **** ****     > EOI
0001 1986 0206  12        li   rtmp,(>FF*256)
     1988 FF00     
0002 198A 2806  14        xor  rtmp,ra
                   < elite.a99
5385 198C D800  22        movb ra,@P                      ; STA P             ; we can pass z_lo to MLTU2 below)
     198E 001B     
5386               
5387 1990 D020  22        movb @P+2,ra                    ; LDA P+2           ; Set z_hi = P+2
     1992 001D     
5388 1994 D800  22        movb ra,@INWK+7                 ; STA INWK+7
     1996 005A     
5389               
5390                                                                          ; So we now have result 2 above:
5391                                                                          ;
5392                                                                          ; (z_sign z_hi z_lo) = (A P+2 P+1)
5393                                                                          ; = z + K2 * beta / 256
5394               
5395 1998 0206  12        li   rtmp,MLTU2                 ; JSR MLTU2         ; MLTU2 doesn't change Q, and Q was set to beta in
     199A 4380     
5396 199C 06A0  20        bl   @jsr                       ;
     199E 8002     
5397                                                                          ; the previous call to MLTU2, so this call does:
5398                                                                          ;
5399                                                                          ; (A P+1 P) = (A ~P) * Q
5400                                                                          ; = (z_hi z_lo) * beta
5401               
5402 19A0 D800  22        movb ra,@P+2                    ; STA P+2           ; Set P+2 = A = the high byte of the result, so we
     19A2 001D     
5403                                                                          ; now have:
5404                                                                          ;
5405                                                                          ; P(2 1 0) = (z_hi z_lo) * beta
5406               
5407 19A4 D020  22        movb @K2+3,ra                   ; LDA K2+3          ; Set y_sign = K2+3
     19A6 00AF     
5408 19A8 D800  22        movb ra,@INWK+5                 ; STA INWK+5
     19AA 0058     
5409               
5410                      .eor @BET2                      ; EOR BET2          ; EOR y_sign with BET2, the sign of the current pitch
     **** ****     > EOR
0001 19AC D1A0  22        movb @BET2,rtmp
     19AE 008A     
0002 19B0 2806  14        xor  rtmp,ra
                   < elite.a99
5411                      .eor @INWK+8                    ; EOR INWK+8        ; rate, and z_sign. If the result is positive jump to
     **** ****     > EOR
0001 19B2 D1A0  22        movb @INWK+8,rtmp
     19B4 005B     
0002 19B6 2806  14        xor  rtmp,ra
                   < elite.a99
5412 19B8 1512  10        jgt  MV43                       ; BPL MV43          ; MV43, otherwise this means beta * z and y have
5413                                                                          ; different signs, i.e. P(2 1) and K2(3 2 1) have
5414                                                                          ; different signs, so we need to add them in order to
5415                                                                          ; calculate K2(2 1) - P(2 1)
5416               
5417 19BA D020  22        movb @P+1,ra                    ; LDA P+1           ; Set (y_hi y_lo) = K2(2 1) + P(2 1)
     19BC 001C     
5418                      .adc @K2+1,ra                   ; ADC K2+1
     **** ****     > ADC
0001 19BE 1701  10        jnc  !
0002 19C0 B004  14        ab   rone,ra
0003               !:
0004 19C2 B020  22        ab   @K2+1,ra
     19C4 00AD     
                   < elite.a99
5419 19C6 D800  22        movb ra,@INWK+3                 ; STA INWK+3
     19C8 0056     
5420 19CA D020  22        movb @P+2,ra                    ; LDA P+2
     19CC 001D     
5421                      .adc @K2+2,ra                   ; ADC K2+2
     **** ****     > ADC
0001 19CE 1701  10        jnc  !
0002 19D0 B004  14        ab   rone,ra
0003               !:
0004 19D2 B020  22        ab   @K2+2,ra
     19D4 00AE     
                   < elite.a99
5422 19D6 D800  22        movb ra,@INWK+4                 ; STA INWK+4
     19D8 0057     
5423               
5424 19DA 0460  16        b    @MV44                      ; JMP MV44          ; Jump to MV44 to continue the calculation
     19DC 1A2E     
5425               
5426               MV43:
5427 19DE D020  22        movb @K2+1,ra                   ; LDA K2+1          ; Reversing the logic above, we need to subtract P(2 1)
     19E0 00AD     
5428                      .sbc @P+1,ra                    ; SBC P+1           ; and K2(3 2 1) to calculate K2(2 1) - P(2 1), so this
     **** ****     > SBC
0001 19E2 1801  10        joc  !
0002 19E4 7004  14        sb   rone,ra
0003               !:
0004 19E6 7020  22        sb   @P+1,ra
     19E8 001C     
                   < elite.a99
5429 19EA D800  22        movb ra,@INWK+3                 ; STA INWK+3        ; sets (y_hi y_lo) = K2(2 1) - P(2 1)
     19EC 0056     
5430 19EE D020  22        movb @K2+2,ra                   ; LDA K2+2
     19F0 00AE     
5431                      .sbc @P+2,ra                    ; SBC P+2
     **** ****     > SBC
0001 19F2 1801  10        joc  !
0002 19F4 7004  14        sb   rone,ra
0003               !:
0004 19F6 7020  22        sb   @P+2,ra
     19F8 001D     
                   < elite.a99
5432 19FA D800  22        movb ra,@INWK+4                 ; STA INWK+4
     19FC 0057     
5433               
5434 19FE 1817  10        joc  MV44                       ; BCS MV44          ; If the above subtraction did not underflow, then
5435                                                                          ; jump to MV44, otherwise we need to negate the result
5436               
5437 1A00 0200  12        li   ra,>01*256                 ; LDA #1            ; Negate (y_sign y_hi y_lo) using two's complement,
     1A02 0100     
5438                      .sbc @INWK+3,ra                 ; SBC INWK+3        ; first doing the low bytes:
     **** ****     > SBC
0001 1A04 1801  10        joc  !
0002 1A06 7004  14        sb   rone,ra
0003               !:
0004 1A08 7020  22        sb   @INWK+3,ra
     1A0A 0056     
                   < elite.a99
5439 1A0C D800  22        movb ra,@INWK+3                 ; STA INWK+3        ;
     1A0E 0056     
5440                                                                          ; y_lo = 1 - y_lo
5441               
5442 1A10 0200  12        li   ra,>00*256                 ; LDA #0            ; Then the high bytes:
     1A12 0000     
5443                      .sbc @INWK+4,ra                 ; SBC INWK+4        ;
     **** ****     > SBC
0001 1A14 1801  10        joc  !
0002 1A16 7004  14        sb   rone,ra
0003               !:
0004 1A18 7020  22        sb   @INWK+4,ra
     1A1A 0057     
                   < elite.a99
5444 1A1C D800  22        movb ra,@INWK+4                 ; STA INWK+4        ; y_hi = 0 - y_hi
     1A1E 0057     
5445               
5446 1A20 D020  22        movb @INWK+5,ra                 ; LDA INWK+5        ; And finally flip the sign in y_sign
     1A22 0058     
5447                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1A24 0206  12        li   rtmp,(>80*256)
     1A26 8000     
0002 1A28 2806  14        xor  rtmp,ra
                   < elite.a99
5448 1A2A D800  22        movb ra,@INWK+5                 ; STA INWK+5
     1A2C 0058     
5449               
5450               MV44:
5451                                                                          ; So we now have result 3 above:
5452                                                                          ;
5453                                                                          ; (y_sign y_hi y_lo) = K2(2 1) - P(2 1)
5454                                                                          ; = K2 - beta * z
5455 1A2E D060  22        movb @ALP1,rx                   ; LDX ALP1          ; Fetch the magnitude of the current roll into X, so
     1A30 0087     
5456                                                                          ; if the roll angle is alpha, X contains |alpha|
5457               
5458 1A32 D020  22        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P = ~y_lo (i.e. with all its bits flipped) so that
     1A34 0056     
5459                      .eoi (>ff*256)                  ; EOR #&FF          ; we can pass y_lo to MLTU2 below)
     **** ****     > EOI
0001 1A36 0206  12        li   rtmp,(>FF*256)
     1A38 FF00     
0002 1A3A 2806  14        xor  rtmp,ra
                   < elite.a99
5460 1A3C D800  22        movb ra,@P                      ; STA P
     1A3E 001B     
5461               
5462 1A40 D020  22        movb @INWK+4,ra                 ; LDA INWK+4        ; Set A = y_hi
     1A42 0057     
5463               
5464 1A44 0206  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     1A46 437E     
5465 1A48 06A0  20        bl   @jsr                       ;
     1A4A 8002     
5466                                                                          ; = (y_hi y_lo) * alpha
5467               
5468 1A4C D800  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     1A4E 001D     
5469                                                                          ; have:
5470                                                                          ;
5471                                                                          ; P(2 1 0) = (y_hi y_lo) * alpha
5472               
5473 1A50 D020  22        movb @ALP2,ra                   ; LDA ALP2          ; Fetch the correct sign of the current roll angle alpha
     1A52 0088     
5474                      .eor @INWK+5                    ; EOR INWK+5        ; from ALP2 and EOR with byte #5 (y_sign), so if the
     **** ****     > EOR
0001 1A54 D1A0  22        movb @INWK+5,rtmp
     1A56 0058     
0002 1A58 2806  14        xor  rtmp,ra
                   < elite.a99
5475                                                                          ; correct roll angle and y_sign have the same sign, A
5476                                                                          ; will be positive, else it will be negative. So A will
5477                                                                          ; contain the sign bit of x_sign * correct alpha sign,
5478                                                                          ; which is the same as the sign of the above result,
5479                                                                          ; so we now have:
5480                                                                          ;
5481                                                                          ; (A P+2 P+1) = (y_sign y_hi y_lo) * alpha / 256
5482               
5483 1A5A 0201  12        li   rx,>00*256                 ; LDX #0            ; Set (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
     1A5C 0000     
5484 1A5E 0206  12        li   rtmp,MVT6                  ; JSR MVT6          ; = x + y * alpha / 256
     1A60 1F7A     
5485 1A62 06A0  20        bl   @jsr                       ;
     1A64 8002     
5486               
5487 1A66 D800  22        movb ra,@INWK+2                 ; STA INWK+2        ; Set x_sign = A = the sign of the result
     1A68 0055     
5488               
5489 1A6A D020  22        movb @P+2,ra                    ; LDA P+2           ; Set x_hi = P+2, the high byte of the result
     1A6C 001D     
5490 1A6E D800  22        movb ra,@INWK+1                 ; STA INWK+1
     1A70 0054     
5491               
5492 1A72 D020  22        movb @P+1,ra                    ; LDA P+1           ; Set x_lo = P+1, the low byte of the result
     1A74 001C     
5493 1A76 D800  22        movb ra,@INWK                   ; STA INWK
     1A78 0053     
5494               
5495                                                                          ; So we now have result 4 above:
5496                                                                          ;
5497                                                                          ; x = x + alpha * y
5498                                                                          ;
5499                                                                          ; and the rotation of (x, y, z) is done
5500               
5501               * ******************************************************************************
5502               *
5503               * Name: MVEIT (Part 6 of 9)
5504               * Type: Subroutine
5505               * Category: Moving
5506               * Summary: Move current ship: Move the ship in space according to our speed
5507               *
5508               * ------------------------------------------------------------------------------
5509               *
5510               * This routine has multiple stages. This stage does the following:
5511               *
5512               * * Move the ship in space according to our speed (we already moved it
5513               * according to its own speed in part 3).
5514               *
5515               * We do this by subtracting our speed (i.e. the distance we travel in this
5516               * iteration of the loop) from the other ship's z-coordinate. We subtract because
5517               * they appear to be "moving" in the opposite direction to us, and the whole
5518               * MVEIT routine is about moving the other ships rather than us (even though we
5519               * are the one doing the moving).
5520               *
5521               * ------------------------------------------------------------------------------
5522               *
5523               * Other entry points:
5524               *
5525               * MV45                Rejoin the MVEIT routine after the rotation, tactics and
5526               * scanner code
5527               *
5528               * ******************************************************************************
5529               
5530               MV45:
5531 1A7A D020  22        movb @DELTA,ra                  ; LDA DELTA         ; Set R to our speed in DELTA
     1A7C 008C     
5532 1A7E D800  22        movb ra,@R                      ; STA R
     1A80 0091     
5533               
5534 1A82 0200  12        li   ra,>80*256                 ; LDA #%10000000    ; Set A to zeroes but with bit 7 set, so that (A R) is
     1A84 8000     
5535                                                                          ; a 16-bit number containing -R, or -speed
5536               
5537 1A86 0201  12        li   rx,>06*256                 ; LDX #6            ; Set X to the z-axis so the call to MVT1 does this:
     1A88 0600     
5538 1A8A 0206  12        li   rtmp,MVT1                  ; JSR MVT1          ;
     1A8C 1BAA     
5539 1A8E 06A0  20        bl   @jsr                       ;
     1A90 8002     
5540                                                                          ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + (A R)
5541                                                                          ; = (z_sign z_hi z_lo) - speed
5542               
5543 1A92 D020  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is not the sun (129) then skip the
     1A94 009B     
5544 1A96 0240  14        andi ra,>81*256                 ; AND #%10000001    ; next instruction, otherwise return from the subroutine
     1A98 8100     
5545 1A9A 0280  14        ci   ra,>81*256                 ; CMP #129          ; as we don't need to rotate the sun around its origin.
     1A9C 8100     
5546 1A9E 1602  10        jne  B17                        ; BNE B17           ; Having both the AND and the CMP is a little odd, as
5547                                                                          ; the sun is the only ship type with bits 0 and 7 set,
5548                                                                          ; so the AND has no effect and could be removed
5549               
5550 1AA0 0460  16        b    @rts                       ; RTS               ; Return from the subroutine, as the ship we are moving
     1AA2 800E     
5551                                                                          ; is the sun and doesn't need any of the following
5552               
5553               * ******************************************************************************
5554               *
5555               * Name: MVEIT (Part 7 of 9)
5556               * Type: Subroutine
5557               * Category: Moving
5558               * Summary: Move current ship: Rotate ship's orientation vectors by pitch/roll
5559               * Deep dive: Orientation vectors
5560               * Pitching and rolling
5561               *
5562               * ------------------------------------------------------------------------------
5563               *
5564               * This routine has multiple stages. This stage does the following:
5565               *
5566               * * Rotate the ship's orientation vectors according to our pitch and roll
5567               *
5568               * As with the previous step, this is all about moving the other ships rather
5569               * than us (even though we are the one doing the moving). So we rotate the
5570               * current ship's orientation vectors (which defines its orientation in space),
5571               * by the angles we are "moving" the rest of the sky through (alpha and beta, our
5572               * roll and pitch), so the ship appears to us to be stationary while we rotate.
5573               *
5574               * ******************************************************************************
5575               
5576               B17:
5577 1AA4 0202  12        li   ry,>09*256                 ; LDY #9            ; Apply our pitch and roll rotations to the current
     1AA6 0900     
5578 1AA8 0206  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's nosev vector
     1AAA 1D68     
5579 1AAC 06A0  20        bl   @jsr                       ;
     1AAE 8002     
5580               
5581 1AB0 0202  12        li   ry,>0f*256                 ; LDY #15           ; Apply our pitch and roll rotations to the current
     1AB2 0F00     
5582 1AB4 0206  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's roofv vector
     1AB6 1D68     
5583 1AB8 06A0  20        bl   @jsr                       ;
     1ABA 8002     
5584               
5585 1ABC 0202  12        li   ry,>15*256                 ; LDY #21           ; Apply our pitch and roll rotations to the current
     1ABE 1500     
5586 1AC0 0206  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's sidev vector
     1AC2 1D68     
5587 1AC4 06A0  20        bl   @jsr                       ;
     1AC6 8002     
5588               
5589               * ******************************************************************************
5590               *
5591               * Name: MVEIT (Part 8 of 9)
5592               * Type: Subroutine
5593               * Category: Moving
5594               * Summary: Move current ship: Rotate ship about itself by its own pitch/roll
5595               * Deep dive: Orientation vectors
5596               * Pitching and rolling by a fixed angle
5597               *
5598               * ------------------------------------------------------------------------------
5599               *
5600               * This routine has multiple stages. This stage does the following:
5601               *
5602               * * If the ship we are processing is rolling or pitching itself, rotate it and
5603               * apply damping if required
5604               *
5605               * ******************************************************************************
5606               
5607 1AC8 D020  22        movb @INWK+30,ra                ; LDA INWK+30       ; Fetch the ship's pitch counter and extract the sign
     1ACA 0071     
5608 1ACC 0240  14        andi ra,>80*256                 ; AND #%10000000    ; into RAT2
     1ACE 8000     
5609 1AD0 D800  22        movb ra,@RAT2                   ; STA RAT2
     1AD2 00AB     
5610               
5611 1AD4 D020  22        movb @INWK+30,ra                ; LDA INWK+30       ; Fetch the ship's pitch counter and extract the value
     1AD6 0071     
5612 1AD8 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; without the sign bit into A
     1ADA 7F00     
5613               
5614 1ADC 1322  10        jeq  MV8                        ; BEQ MV8           ; If the pitch counter is 0, then jump to MV8 to skip
5615                                                                          ; the following, as the ship is not pitching
5616               
5617 1ADE 0280  14        ci   ra,>7f*256                 ; CMP #%01111111    ; If bits 0-6 are set in the pitch counter (i.e. the
     1AE0 7F00     
5618                                                                          ; ship's pitch is not damping down), then the C flag
5619                                                                          ; will be set by this instruction
5620               
5621                      .sbi (>00*256)                  ; SBC #0            ; Set A = A - 0 - (1 - C), so if we are damping then we
     **** ****     > SBI
0001 1AE2 1801  10        joc  !
0002 1AE4 7004  14        sb   rone,ra
0003               !:
0004 1AE6 0220  14        ai   ra,-(>00*256)
     1AE8 0000     
                   < elite.a99
5622                                                                          ; reduce A by 1, otherwise it is unchanged
5623               
5624 1AEA F020  22        socb @RAT2,ra                   ; ORA RAT2          ; Change bit 7 of A to the sign we saved in RAT2, so
     1AEC 00AB     
5625                                                                          ; the updated pitch counter in A retains its sign
5626               
5627 1AEE D800  22        movb ra,@INWK+30                ; STA INWK+30       ; Store the updated pitch counter in byte #30
     1AF0 0071     
5628               
5629 1AF2 0201  12        li   rx,>0f*256                 ; LDX #15           ; Rotate (roofv_x, nosev_x) by a small angle (pitch)
     1AF4 0F00     
5630 1AF6 0202  12        li   ry,>09*256                 ; LDY #9
     1AF8 0900     
5631 1AFA 0206  12        li   rtmp,MVS5                  ; JSR MVS5
     1AFC 1E34     
5632 1AFE 06A0  20        bl   @jsr                       ;
     1B00 8002     
5633               
5634 1B02 0201  12        li   rx,>11*256                 ; LDX #17           ; Rotate (roofv_y, nosev_y) by a small angle (pitch)
     1B04 1100     
5635 1B06 0202  12        li   ry,>0b*256                 ; LDY #11
     1B08 0B00     
5636 1B0A 0206  12        li   rtmp,MVS5                  ; JSR MVS5
     1B0C 1E34     
5637 1B0E 06A0  20        bl   @jsr                       ;
     1B10 8002     
5638               
5639 1B12 0201  12        li   rx,>13*256                 ; LDX #19           ; Rotate (roofv_z, nosev_z) by a small angle (pitch)
     1B14 1300     
5640 1B16 0202  12        li   ry,>0d*256                 ; LDY #13
     1B18 0D00     
5641 1B1A 0206  12        li   rtmp,MVS5                  ; JSR MVS5
     1B1C 1E34     
5642 1B1E 06A0  20        bl   @jsr                       ;
     1B20 8002     
5643               
5644               MV8:
5645 1B22 D020  22        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the ship's roll counter and extract the sign
     1B24 0070     
5646 1B26 0240  14        andi ra,>80*256                 ; AND #%10000000    ; into RAT2
     1B28 8000     
5647 1B2A D800  22        movb ra,@RAT2                   ; STA RAT2
     1B2C 00AB     
5648               
5649 1B2E D020  22        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the ship's roll counter and extract the value
     1B30 0070     
5650 1B32 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; without the sign bit into A
     1B34 7F00     
5651               
5652 1B36 1322  10        jeq  MV5                        ; BEQ MV5           ; If the roll counter is 0, then jump to MV5 to skip the
5653                                                                          ; following, as the ship is not rolling
5654               
5655 1B38 0280  14        ci   ra,>7f*256                 ; CMP #%01111111    ; If bits 0-6 are set in the roll counter (i.e. the
     1B3A 7F00     
5656                                                                          ; ship's roll is not damping down), then the C flag
5657                                                                          ; will be set by this instruction
5658               
5659                      .sbi (>00*256)                  ; SBC #0            ; Set A = A - 0 - (1 - C), so if we are damping then we
     **** ****     > SBI
0001 1B3C 1801  10        joc  !
0002 1B3E 7004  14        sb   rone,ra
0003               !:
0004 1B40 0220  14        ai   ra,-(>00*256)
     1B42 0000     
                   < elite.a99
5660                                                                          ; reduce A by 1, otherwise it is unchanged
5661               
5662 1B44 F020  22        socb @RAT2,ra                   ; ORA RAT2          ; Change bit 7 of A to the sign we saved in RAT2, so
     1B46 00AB     
5663                                                                          ; the updated roll counter in A retains its sign
5664               
5665 1B48 D800  22        movb ra,@INWK+29                ; STA INWK+29       ; Store the updated pitch counter in byte #29
     1B4A 0070     
5666               
5667 1B4C 0201  12        li   rx,>0f*256                 ; LDX #15           ; Rotate (roofv_x, sidev_x) by a small angle (roll)
     1B4E 0F00     
5668 1B50 0202  12        li   ry,>15*256                 ; LDY #21
     1B52 1500     
5669 1B54 0206  12        li   rtmp,MVS5                  ; JSR MVS5
     1B56 1E34     
5670 1B58 06A0  20        bl   @jsr                       ;
     1B5A 8002     
5671               
5672 1B5C 0201  12        li   rx,>11*256                 ; LDX #17           ; Rotate (roofv_y, sidev_y) by a small angle (roll)
     1B5E 1100     
5673 1B60 0202  12        li   ry,>17*256                 ; LDY #23
     1B62 1700     
5674 1B64 0206  12        li   rtmp,MVS5                  ; JSR MVS5
     1B66 1E34     
5675 1B68 06A0  20        bl   @jsr                       ;
     1B6A 8002     
5676               
5677 1B6C 0201  12        li   rx,>13*256                 ; LDX #19           ; Rotate (roofv_z, sidev_z) by a small angle (roll)
     1B6E 1300     
5678 1B70 0202  12        li   ry,>19*256                 ; LDY #25
     1B72 1900     
5679 1B74 0206  12        li   rtmp,MVS5                  ; JSR MVS5
     1B76 1E34     
5680 1B78 06A0  20        bl   @jsr                       ;
     1B7A 8002     
5681               
5682               * ******************************************************************************
5683               *
5684               * Name: MVEIT (Part 9 of 9)
5685               * Type: Subroutine
5686               * Category: Moving
5687               * Summary: Move current ship: Redraw on scanner, if it hasn't been destroyed
5688               *
5689               * ------------------------------------------------------------------------------
5690               *
5691               * This routine has multiple stages. This stage does the following:
5692               *
5693               * * If the ship is exploding or being removed, hide it on the scanner
5694               *
5695               * * Otherwise redraw the ship on the scanner, now that it's been moved
5696               *
5697               * ******************************************************************************
5698               
5699               MV5:
5700 1B7C D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the ship's exploding/killed state from byte #31
     1B7E 0072     
5701               
5702 1B80 0240  14        andi ra,>a0*256                 ; AND #%10100000    ; If we are exploding or removing this ship then jump to
     1B82 A000     
5703 1B84 1608  10        jne  MVD1                       ; BNE MVD1          ; MVD1 to remove it from the scanner permanently
5704               
5705 1B86 D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 4 to keep the ship visible on the scanner
     1B88 0072     
5706 1B8A 0260  14        ori  ra,>10*256                 ; ORA #%00010000
     1B8C 1000     
5707 1B8E D800  22        movb ra,@INWK+31                ; STA INWK+31
     1B90 0072     
5708               
5709 1B92 0460  20        b    @SCAN                      ; JMP SCAN          ; Display the ship on the scanner, returning from the
     1B94 4C86     
5710                                                                          ; subroutine using a tail call
5711               
5712               MVD1:
5713 1B96 D020  22        movb @INWK+31,ra                ; LDA INWK+31       ; Clear bit 4 to hide the ship on the scanner
     1B98 0072     
5714 1B9A 0240  14        andi ra,>ef*256                 ; AND #%11101111
     1B9C EF00     
5715 1B9E D800  22        movb ra,@INWK+31                ; STA INWK+31
     1BA0 0072     
5716               
5717 1BA2 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     1BA4 800E     
5718               
5719               * ******************************************************************************
5720               *
5721               * Name: MVT1
5722               * Type: Subroutine
5723               * Category: Moving
5724               * Summary: Calculate (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
5725               *
5726               * ------------------------------------------------------------------------------
5727               *
5728               * Add the signed delta (A R) to a ship's coordinate, along the axis given in X.
5729               * Mathematically speaking, this routine translates the ship along a single axis
5730               * by a signed delta. Taking the example of X = 0, the x-axis, it does the
5731               * following:
5732               *
5733               * (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
5734               *
5735               * (In practice, MVT1 is only ever called directly with A = 0 or 128, otherwise
5736               * it is always called via MVT-2, which clears A apart from the sign bit. The
5737               * routine is written to cope with a non-zero delta_hi, so it supports a full
5738               * 16-bit delta, but it appears that delta_hi is only ever used to hold the
5739               * sign of the delta.)
5740               *
5741               * The comments below assume we are adding delta to the x-axis, though the axis
5742               * is determined by the value of X.
5743               *
5744               * ------------------------------------------------------------------------------
5745               *
5746               * Arguments:
5747               *
5748               * (A R)               The signed delta, so A = delta_hi and R = delta_lo
5749               *
5750               * X                   Determines which coordinate axis of INWK to change:
5751               *
5752               * * X = 0 adds the delta to (x_lo, x_hi, x_sign)
5753               *
5754               * * X = 3 adds the delta to (y_lo, y_hi, y_sign)
5755               *
5756               * * X = 6 adds the delta to (z_lo, z_hi, z_sign)
5757               *
5758               * ------------------------------------------------------------------------------
5759               *
5760               * Other entry points:
5761               *
5762               * MVT1-2              Clear bits 0-6 of A before entering MVT1
5763               *
5764               * ******************************************************************************
5765               
5766 1BA6 0240  14        andi ra,>80*256                 ; AND #%10000000    ; Clear bits 0-6 of A
     1BA8 8000     
5767               
5768               MVT1:
5769                      .asla                           ; ASL A             ; Set the C flag to the sign bit of the delta, leaving
     **** ****     > ASLA
0001 1BAA 0240  14        andi ra,>ff00
     1BAC FF00     
0002 1BAE 0A10  14        sla  ra,1
                   < elite.a99
5770                                                                          ; delta_hi << 1 in A
5771               
5772 1BB0 D800  22        movb ra,@S                      ; STA S             ; Set S = delta_hi << 1
     1BB2 0092     
5773                                                                          ;
5774                                                                          ; This also clears bit 0 of S
5775               
5776 1BB4 0200  12        li   ra,>00*256                 ; LDA #0            ; Set T = just the sign bit of delta (in bit 7)
     1BB6 0000     
5777 1BB8 06A0  20        bl   @rora                      ; ROR A
     1BBA 803C     
5778 1BBC D800  22        movb ra,@T                      ; STA T
     1BBE 00D1     
5779               
5780                      .lsr @S                         ; LSR S             ; Set S = delta_hi >> 1
     **** ****     > LSR
0001 1BC0 D1A0  22        movb @S,rtmp
     1BC2 0092     
0002 1BC4 0916  14        srl  rtmp,1
0003 1BC6 D806  22        movb rtmp,@S
     1BC8 0092     
                   < elite.a99
5781                                                                          ; = |delta_hi|
5782                                                                          ;
5783                                                                          ; This also clear the C flag, as we know that bit 0 of
5784                                                                          ; S was clear before the LSR
5785               
5786                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; If T EOR x_sign has bit 7 set, then x_sign and delta
     **** ****     > EOR
0001 1BCA D1A1  26        movb @INWK+2(RX),rtmp
     1BCC 0055     
0002 1BCE 2806  14        xor  rtmp,ra
                   < elite.a99
5787 1BD0 111C  10        jlt  MV10                       ; BMI MV10          ; have different signs, so jump to MV10
5788               
5789                                                                          ; At this point, we know x_sign and delta have the same
5790                                                                          ; sign, that sign is in T, and S contains |delta_hi|,
5791                                                                          ; so now we want to do:
5792                                                                          ;
5793                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (S R)
5794                                                                          ;
5795                                                                          ; and then set the sign of the result to the same sign
5796                                                                          ; as x_sign and delta
5797               
5798 1BD2 D020  22        movb @R,ra                      ; LDA R             ; First we add the low bytes, so:
     1BD4 0091     
5799                      .adc @INWK(rx),ra               ; ADC INWK,X        ;
     **** ****     > ADC
0001 1BD6 1701  10        jnc  !
0002 1BD8 B004  14        ab   rone,ra
0003               !:
0004 1BDA B021  26        ab   @INWK(RX),ra
     1BDC 0053     
                   < elite.a99
5800 1BDE D840  30        movb ra,@INWK(rx)               ; STA INWK,X        ; x_lo = x_lo + R
     1BE0 0053     
5801               
5802 1BE2 D020  22        movb @S,ra                      ; LDA S             ; Then we add the high bytes:
     1BE4 0092     
5803                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X      ;
     **** ****     > ADC
0001 1BE6 1701  10        jnc  !
0002 1BE8 B004  14        ab   rone,ra
0003               !:
0004 1BEA B021  26        ab   @INWK+1(RX),ra
     1BEC 0054     
                   < elite.a99
5804 1BEE D840  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = x_hi + S
     1BF0 0054     
5805               
5806 1BF2 D021  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally we add any carry into x_sign, and if the
     1BF4 0055     
5807                      .adi (>00*256)                  ; ADC #0            ; sign of x_sign and delta in T is negative, make sure
     **** ****     > ADI
0001 1BF6 1701  10        jnc  !
0002 1BF8 B004  14        ab   rone,ra
0003               !:
0004 1BFA 0220  14        ai   ra,(>00*256)
     1BFC 0000     
                   < elite.a99
5808 1BFE F020  22        socb @T,ra                      ; ORA T             ; the result is negative (by OR'ing with T)
     1C00 00D1     
5809 1C02 D840  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X
     1C04 0055     
5810               
5811 1C06 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     1C08 800E     
5812               
5813               MV10:
5814                                                                          ; If we get here, we know x_sign and delta have
5815                                                                          ; different signs, with delta's sign in T, and
5816                                                                          ; |delta_hi| in S, so now we want to do:
5817                                                                          ;
5818                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - (S R)
5819                                                                          ;
5820                                                                          ; and then set the sign of the result according to
5821                                                                          ; the signs of x_sign and delta
5822 1C0A D021  26        movb @INWK(rx),ra               ; LDA INWK,X        ; First we subtract the low bytes, so:
     1C0C 0053     
5823                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1C0E 0A15  14        sla  rmone,1
                   < elite.a99
5824                      .sbc @R,ra                      ; SBC R             ; x_lo = x_lo - R
     **** ****     > SBC
0001 1C10 1801  10        joc  !
0002 1C12 7004  14        sb   rone,ra
0003               !:
0004 1C14 7020  22        sb   @R,ra
     1C16 0091     
                   < elite.a99
5825 1C18 D840  30        movb ra,@INWK(rx)               ; STA INWK,X
     1C1A 0053     
5826               
5827 1C1C D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Then we subtract the high bytes:
     1C1E 0054     
5828                      .sbc @S,ra                      ; SBC S             ;
     **** ****     > SBC
0001 1C20 1801  10        joc  !
0002 1C22 7004  14        sb   rone,ra
0003               !:
0004 1C24 7020  22        sb   @S,ra
     1C26 0092     
                   < elite.a99
5829 1C28 D840  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = x_hi - S
     1C2A 0054     
5830               
5831 1C2C D021  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally we subtract any borrow from bits 0-6 of
     1C2E 0055     
5832 1C30 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; x_sign, and give the result the opposite sign bit to T
     1C32 7F00     
5833                      .sbi (>00*256)                  ; SBC #0            ; (i.e. give it the sign of the original x_sign)
     **** ****     > SBI
0001 1C34 1801  10        joc  !
0002 1C36 7004  14        sb   rone,ra
0003               !:
0004 1C38 0220  14        ai   ra,-(>00*256)
     1C3A 0000     
                   < elite.a99
5834 1C3C 0260  14        ori  ra,>80*256                 ; ORA #%10000000
     1C3E 8000     
5835                      .eor @T                         ; EOR T
     **** ****     > EOR
0001 1C40 D1A0  22        movb @T,rtmp
     1C42 00D1     
0002 1C44 2806  14        xor  rtmp,ra
                   < elite.a99
5836 1C46 D840  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X
     1C48 0055     
5837               
5838 1C4A 181C  10        joc  MV11                       ; BCS MV11          ; If the C flag is set by the above SBC, then our sum
5839                                                                          ; above didn't underflow and is correct - to put it
5840                                                                          ; another way, (x_sign x_hi x_lo) >= (S R) so the result
5841                                                                          ; should indeed have the same sign as x_sign, so jump to
5842                                                                          ; MV11 to return from the subroutine
5843               
5844                                                                          ; Otherwise our subtraction underflowed because
5845                                                                          ; (x_sign x_hi x_lo) < (S R), so we now need to flip the
5846                                                                          ; subtraction around by using two's complement to this:
5847                                                                          ;
5848                                                                          ; (S R) - (x_sign x_hi x_lo)
5849                                                                          ;
5850                                                                          ; and then we need to give the result the same sign as
5851                                                                          ; (S R), the delta, as that's the dominant figure in the
5852                                                                          ; sum
5853               
5854 1C4C 0200  12        li   ra,>01*256                 ; LDA #1            ; First we subtract the low bytes, so:
     1C4E 0100     
5855                      .sbc @INWK(rx),ra               ; SBC INWK,X        ;
     **** ****     > SBC
0001 1C50 1801  10        joc  !
0002 1C52 7004  14        sb   rone,ra
0003               !:
0004 1C54 7021  26        sb   @INWK(RX),ra
     1C56 0053     
                   < elite.a99
5856 1C58 D840  30        movb ra,@INWK(rx)               ; STA INWK,X        ; x_lo = 1 - x_lo
     1C5A 0053     
5857               
5858 1C5C 0200  12        li   ra,>00*256                 ; LDA #0            ; Then we subtract the high bytes:
     1C5E 0000     
5859                      .sbc @INWK+1(rx),ra             ; SBC INWK+1,X      ;
     **** ****     > SBC
0001 1C60 1801  10        joc  !
0002 1C62 7004  14        sb   rone,ra
0003               !:
0004 1C64 7021  26        sb   @INWK+1(RX),ra
     1C66 0054     
                   < elite.a99
5860 1C68 D840  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = 0 - x_hi
     1C6A 0054     
5861               
5862 1C6C 0200  12        li   ra,>00*256                 ; LDA #0            ; And then we subtract the sign bytes:
     1C6E 0000     
5863                      .sbc @INWK+2(rx),ra             ; SBC INWK+2,X      ;
     **** ****     > SBC
0001 1C70 1801  10        joc  !
0002 1C72 7004  14        sb   rone,ra
0003               !:
0004 1C74 7021  26        sb   @INWK+2(RX),ra
     1C76 0055     
                   < elite.a99
5864                                                                          ; x_sign = 0 - x_sign
5865               
5866 1C78 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; Finally, we set the sign bit to the sign in T, the
     1C7A 7F00     
5867 1C7C F020  22        socb @T,ra                      ; ORA T             ; sign of the original delta, as the delta is the
     1C7E 00D1     
5868 1C80 D840  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X      ; dominant figure in the sum
     1C82 0055     
5869               
5870               MV11:
5871 1C84 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     1C86 800E     
5872               
5873               * ******************************************************************************
5874               *
5875               * Name: MVT3
5876               * Type: Subroutine
5877               * Category: Moving
5878               * Summary: Calculate K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
5879               *
5880               * ------------------------------------------------------------------------------
5881               *
5882               * Add an INWK position coordinate - i.e. x, y or z - to K(3 2 1), like this:
5883               *
5884               * K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
5885               *
5886               * The INWK coordinate to add to K(3 2 1) is specified by X.
5887               *
5888               * ------------------------------------------------------------------------------
5889               *
5890               * Arguments:
5891               *
5892               * X                   The coordinate to add to K(3 2 1), as follows:
5893               *
5894               * * If X = 0, add (x_sign x_hi x_lo)
5895               *
5896               * * If X = 3, add (y_sign y_hi y_lo)
5897               *
5898               * * If X = 6, add (z_sign z_hi z_lo)
5899               *
5900               * ------------------------------------------------------------------------------
5901               *
5902               * Returns:
5903               *
5904               * A                   Contains a copy of the high byte of the result, K+3
5905               *
5906               * X                   X is preserved
5907               *
5908               * ******************************************************************************
5909               
5910               MVT3:
5911 1C88 D020  22        movb @K+3,ra                    ; LDA K+3           ; Set S = K+3
     1C8A 0040     
5912 1C8C D800  22        movb ra,@S                      ; STA S
     1C8E 0092     
5913               
5914 1C90 0240  14        andi ra,>80*256                 ; AND #%10000000    ; Set T = sign bit of K(3 2 1)
     1C92 8000     
5915 1C94 D800  22        movb ra,@T                      ; STA T
     1C96 00D1     
5916               
5917                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; If x_sign has a different sign to K(3 2 1), jump to
     **** ****     > EOR
0001 1C98 D1A1  26        movb @INWK+2(RX),rtmp
     1C9A 0055     
0002 1C9C 2806  14        xor  rtmp,ra
                   < elite.a99
5918 1C9E 111F  10        jlt  MV13                       ; BMI MV13          ; MV13 to process the addition as a subtraction
5919               
5920 1CA0 D020  22        movb @K+1,ra                    ; LDA K+1           ; Set K(3 2 1) = K(3 2 1) + (x_sign x_hi x_lo)
     1CA2 003E     
5921                      .clc                            ; CLC               ; starting with the low bytes
     **** ****     > CLC
0001 1CA4 0A13  14        sla  rzero,1
                   < elite.a99
5922                      .adc @INWK(rx),ra               ; ADC INWK,X
     **** ****     > ADC
0001 1CA6 1701  10        jnc  !
0002 1CA8 B004  14        ab   rone,ra
0003               !:
0004 1CAA B021  26        ab   @INWK(RX),ra
     1CAC 0053     
                   < elite.a99
5923 1CAE D800  22        movb ra,@K+1                    ; STA K+1
     1CB0 003E     
5924               
5925 1CB2 D020  22        movb @K+2,ra                    ; LDA K+2           ; Then the middle bytes
     1CB4 003F     
5926                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X
     **** ****     > ADC
0001 1CB6 1701  10        jnc  !
0002 1CB8 B004  14        ab   rone,ra
0003               !:
0004 1CBA B021  26        ab   @INWK+1(RX),ra
     1CBC 0054     
                   < elite.a99
5927 1CBE D800  22        movb ra,@K+2                    ; STA K+2
     1CC0 003F     
5928               
5929 1CC2 D020  22        movb @K+3,ra                    ; LDA K+3           ; And finally the high bytes
     1CC4 0040     
5930                      .adc @INWK+2(rx),ra             ; ADC INWK+2,X
     **** ****     > ADC
0001 1CC6 1701  10        jnc  !
0002 1CC8 B004  14        ab   rone,ra
0003               !:
0004 1CCA B021  26        ab   @INWK+2(RX),ra
     1CCC 0055     
                   < elite.a99
5931               
5932 1CCE 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; Setting the sign bit of K+3 to T, the original sign
     1CD0 7F00     
5933 1CD2 F020  22        socb @T,ra                      ; ORA T             ; of K(3 2 1)
     1CD4 00D1     
5934 1CD6 D800  22        movb ra,@K+3                    ; STA K+3
     1CD8 0040     
5935               
5936 1CDA 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     1CDC 800E     
5937               
5938               MV13:
5939 1CDE D020  22        movb @S,ra                      ; LDA S             ; Set S = |K+3| (i.e. K+3 with the sign bit cleared)
     1CE0 0092     
5940 1CE2 0240  14        andi ra,>7f*256                 ; AND #%01111111
     1CE4 7F00     
5941 1CE6 D800  22        movb ra,@S                      ; STA S
     1CE8 0092     
5942               
5943 1CEA D021  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Set K(3 2 1) = (x_sign x_hi x_lo) - K(3 2 1)
     1CEC 0053     
5944                      .sec                            ; SEC               ; starting with the low bytes
     **** ****     > SEC
0001 1CEE 0A15  14        sla  rmone,1
                   < elite.a99
5945                      .sbc @K+1,ra                    ; SBC K+1
     **** ****     > SBC
0001 1CF0 1801  10        joc  !
0002 1CF2 7004  14        sb   rone,ra
0003               !:
0004 1CF4 7020  22        sb   @K+1,ra
     1CF6 003E     
                   < elite.a99
5946 1CF8 D800  22        movb ra,@K+1                    ; STA K+1
     1CFA 003E     
5947               
5948 1CFC D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Then the middle bytes
     1CFE 0054     
5949                      .sbc @K+2,ra                    ; SBC K+2
     **** ****     > SBC
0001 1D00 1801  10        joc  !
0002 1D02 7004  14        sb   rone,ra
0003               !:
0004 1D04 7020  22        sb   @K+2,ra
     1D06 003F     
                   < elite.a99
5950 1D08 D800  22        movb ra,@K+2                    ; STA K+2
     1D0A 003F     
5951               
5952 1D0C D021  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally the high bytes, doing A = |x_sign| - |K+3|
     1D0E 0055     
5953 1D10 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; and setting the C flag for testing below
     1D12 7F00     
5954                      .sbc @S,ra                      ; SBC S
     **** ****     > SBC
0001 1D14 1801  10        joc  !
0002 1D16 7004  14        sb   rone,ra
0003               !:
0004 1D18 7020  22        sb   @S,ra
     1D1A 0092     
                   < elite.a99
5955               
5956 1D1C 0260  14        ori  ra,>80*256                 ; ORA #%10000000    ; Set the sign bit of K+3 to the opposite sign of T,
     1D1E 8000     
5957                      .eor @T                         ; EOR T             ; i.e. the opposite sign to the original K(3 2 1)
     **** ****     > EOR
0001 1D20 D1A0  22        movb @T,rtmp
     1D22 00D1     
0002 1D24 2806  14        xor  rtmp,ra
                   < elite.a99
5958 1D26 D800  22        movb ra,@K+3                    ; STA K+3
     1D28 0040     
5959               
5960 1D2A 181C  10        joc  MV14                       ; BCS MV14          ; If the C flag is set, i.e. |x_sign| >= |K+3|, then
5961                                                                          ; the sign of K(3 2 1). In this case, we want the
5962                                                                          ; result to have the same sign as the largest argument,
5963                                                                          ; which is (x_sign x_hi x_lo), which we know has the
5964                                                                          ; opposite sign to K(3 2 1), and that's what we just set
5965                                                                          ; the sign of K(3 2 1) to... so we can jump to MV14 to
5966                                                                          ; return from the subroutine
5967               
5968 1D2C 0200  12        li   ra,>01*256                 ; LDA #1            ; We need to swap the sign of the result in K(3 2 1),
     1D2E 0100     
5969                      .sbc @K+1,ra                    ; SBC K+1           ; which we do by calculating 0 - K(3 2 1), which we can
     **** ****     > SBC
0001 1D30 1801  10        joc  !
0002 1D32 7004  14        sb   rone,ra
0003               !:
0004 1D34 7020  22        sb   @K+1,ra
     1D36 003E     
                   < elite.a99
5970 1D38 D800  22        movb ra,@K+1                    ; STA K+1           ; do with 1 - C - K(3 2 1), as we know the C flag is
     1D3A 003E     
5971                                                                          ; clear. We start with the low bytes
5972               
5973 1D3C 0200  12        li   ra,>00*256                 ; LDA #0            ; Then the middle bytes
     1D3E 0000     
5974                      .sbc @K+2,ra                    ; SBC K+2
     **** ****     > SBC
0001 1D40 1801  10        joc  !
0002 1D42 7004  14        sb   rone,ra
0003               !:
0004 1D44 7020  22        sb   @K+2,ra
     1D46 003F     
                   < elite.a99
5975 1D48 D800  22        movb ra,@K+2                    ; STA K+2
     1D4A 003F     
5976               
5977 1D4C 0200  12        li   ra,>00*256                 ; LDA #0            ; And finally the high bytes
     1D4E 0000     
5978                      .sbc @K+3,ra                    ; SBC K+3
     **** ****     > SBC
0001 1D50 1801  10        joc  !
0002 1D52 7004  14        sb   rone,ra
0003               !:
0004 1D54 7020  22        sb   @K+3,ra
     1D56 0040     
                   < elite.a99
5979               
5980 1D58 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; Set the sign bit of K+3 to the same sign as T,
     1D5A 7F00     
5981 1D5C F020  22        socb @T,ra                      ; ORA T             ; i.e. the same sign as the original K(3 2 1), as
     1D5E 00D1     
5982 1D60 D800  22        movb ra,@K+3                    ; STA K+3           ; that's the largest argument
     1D62 0040     
5983               
5984               MV14:
5985 1D64 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     1D66 800E     
5986               
5987               * ******************************************************************************
5988               *
5989               * Name: MVS4
5990               * Type: Subroutine
5991               * Category: Moving
5992               * Summary: Apply pitch and roll to an orientation vector
5993               * Deep dive: Orientation vectors
5994               * Pitching and rolling
5995               *
5996               * ------------------------------------------------------------------------------
5997               *
5998               * Apply pitch and roll angles alpha and beta to the orientation vector in Y.
5999               *
6000               * Specifically, this routine rotates a point (x, y, z) around the origin by
6001               * pitch alpha and roll beta, using the small angle approximation to make the
6002               * maths easier, and incorporating the Minsky circle algorithm to make the
6003               * rotation more stable (though more elliptic).
6004               *
6005               * If that paragraph makes sense to you, then you should probably be writing
6006               * this commentary! For the rest of us, there's a detailed explanation of all
6007               * this in the deep dive on "Pitching and rolling".
6008               *
6009               * ------------------------------------------------------------------------------
6010               *
6011               * Arguments:
6012               *
6013               * Y                   Determines which of the INWK orientation vectors to
6014               * transform:
6015               *
6016               * * Y = 9 rotates nosev: (nosev_x, nosev_y, nosev_z)
6017               *
6018               * * Y = 15 rotates roofv: (roofv_x, roofv_y, roofv_z)
6019               *
6020               * * Y = 21 rotates sidev: (sidev_x, sidev_y, sidev_z)
6021               *
6022               * ******************************************************************************
6023               
6024               MVS4:
6025 1D68 D020  22        movb @ALPHA,ra                  ; LDA ALPHA         ; Set Q = alpha (the roll angle to rotate through)
     1D6A 009E     
6026 1D6C D800  22        movb ra,@Q                      ; STA Q
     1D6E 0090     
6027               
6028 1D70 D062  26        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set (S R) = nosev_y
     1D72 0055     
6029 1D74 D801  22        movb rx,@R                      ; STX R
     1D76 0091     
6030 1D78 D062  26        movb @INWK+3(ry),rx             ; LDX INWK+3,Y
     1D7A 0056     
6031 1D7C D801  22        movb rx,@S                      ; STX S
     1D7E 0092     
6032               
6033 1D80 D062  26        movb @INWK(ry),rx               ; LDX INWK,Y        ; These instructions have no effect as MAD overwrites
     1D82 0053     
6034 1D84 D801  22        movb rx,@P                      ; STX P             ; X and P when called, but they set X = P = nosev_x_lo
     1D86 001B     
6035               
6036 1D88 D022  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Set A = -nosev_x_hi
     1D8A 0054     
6037                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1D8C 0206  12        li   rtmp,(>80*256)
     1D8E 8000     
0002 1D90 2806  14        xor  rtmp,ra
                   < elite.a99
6038               
6039 1D92 0206  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1D94 44B2     
6040 1D96 06A0  20        bl   @jsr                       ;
     1D98 8002     
6041 1D9A D880  30        movb ra,@INWK+3(ry)             ; STA INWK+3,Y      ; = alpha * -nosev_x_hi + nosev_y
     1D9C 0056     
6042 1D9E D881  30        movb rx,@INWK+2(ry)             ; STX INWK+2,Y      ;
     1DA0 0055     
6043                                                                          ; and store (A X) in nosev_y, so this does:
6044                                                                          ;
6045                                                                          ; nosev_y = nosev_y - alpha * nosev_x_hi
6046               
6047 1DA2 D801  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1DA4 001B     
6048                                                                          ; but it sets P = nosev_y_lo
6049               
6050 1DA6 D062  26        movb @INWK(ry),rx               ; LDX INWK,Y        ; Set (S R) = nosev_x
     1DA8 0053     
6051 1DAA D801  22        movb rx,@R                      ; STX R
     1DAC 0091     
6052 1DAE D062  26        movb @INWK+1(ry),rx             ; LDX INWK+1,Y
     1DB0 0054     
6053 1DB2 D801  22        movb rx,@S                      ; STX S
     1DB4 0092     
6054               
6055 1DB6 D022  26        movb @INWK+3(ry),ra             ; LDA INWK+3,Y      ; Set A = nosev_y_hi
     1DB8 0056     
6056               
6057 1DBA 0206  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1DBC 44B2     
6058 1DBE 06A0  20        bl   @jsr                       ;
     1DC0 8002     
6059 1DC2 D880  30        movb ra,@INWK+1(ry)             ; STA INWK+1,Y      ; = alpha * nosev_y_hi + nosev_x
     1DC4 0054     
6060 1DC6 D881  30        movb rx,@INWK(ry)               ; STX INWK,Y        ;
     1DC8 0053     
6061                                                                          ; and store (A X) in nosev_x, so this does:
6062                                                                          ;
6063                                                                          ; nosev_x = nosev_x + alpha * nosev_y_hi
6064               
6065 1DCA D801  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1DCC 001B     
6066                                                                          ; but it sets P = nosev_x_lo
6067               
6068 1DCE D020  22        movb @BETA,ra                   ; LDA BETA          ; Set Q = beta (the pitch angle to rotate through)
     1DD0 002A     
6069 1DD2 D800  22        movb ra,@Q                      ; STA Q
     1DD4 0090     
6070               
6071 1DD6 D062  26        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set (S R) = nosev_y
     1DD8 0055     
6072 1DDA D801  22        movb rx,@R                      ; STX R
     1DDC 0091     
6073 1DDE D062  26        movb @INWK+3(ry),rx             ; LDX INWK+3,Y
     1DE0 0056     
6074 1DE2 D801  22        movb rx,@S                      ; STX S
     1DE4 0092     
6075 1DE6 D062  26        movb @INWK+4(ry),rx             ; LDX INWK+4,Y
     1DE8 0057     
6076               
6077 1DEA D801  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1DEC 001B     
6078                                                                          ; but it sets P = nosev_y
6079               
6080 1DEE D022  26        movb @INWK+5(ry),ra             ; LDA INWK+5,Y      ; Set A = -nosev_z_hi
     1DF0 0058     
6081                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1DF2 0206  12        li   rtmp,(>80*256)
     1DF4 8000     
0002 1DF6 2806  14        xor  rtmp,ra
                   < elite.a99
6082               
6083 1DF8 0206  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1DFA 44B2     
6084 1DFC 06A0  20        bl   @jsr                       ;
     1DFE 8002     
6085 1E00 D880  30        movb ra,@INWK+3(ry)             ; STA INWK+3,Y      ; = beta * -nosev_z_hi + nosev_y
     1E02 0056     
6086 1E04 D881  30        movb rx,@INWK+2(ry)             ; STX INWK+2,Y      ;
     1E06 0055     
6087                                                                          ; and store (A X) in nosev_y, so this does:
6088                                                                          ;
6089                                                                          ; nosev_y = nosev_y - beta * nosev_z_hi
6090               
6091 1E08 D801  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1E0A 001B     
6092                                                                          ; but it sets P = nosev_y_lo
6093               
6094 1E0C D062  26        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; Set (S R) = nosev_z
     1E0E 0057     
6095 1E10 D801  22        movb rx,@R                      ; STX R
     1E12 0091     
6096 1E14 D062  26        movb @INWK+5(ry),rx             ; LDX INWK+5,Y
     1E16 0058     
6097 1E18 D801  22        movb rx,@S                      ; STX S
     1E1A 0092     
6098               
6099 1E1C D022  26        movb @INWK+3(ry),ra             ; LDA INWK+3,Y      ; Set A = nosev_y_hi
     1E1E 0056     
6100               
6101 1E20 0206  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1E22 44B2     
6102 1E24 06A0  20        bl   @jsr                       ;
     1E26 8002     
6103 1E28 D880  30        movb ra,@INWK+5(ry)             ; STA INWK+5,Y      ; = beta * nosev_y_hi + nosev_z
     1E2A 0058     
6104 1E2C D881  30        movb rx,@INWK+4(ry)             ; STX INWK+4,Y      ;
     1E2E 0057     
6105                                                                          ; and store (A X) in nosev_z, so this does:
6106                                                                          ;
6107                                                                          ; nosev_z = nosev_z + beta * nosev_y_hi
6108               
6109 1E30 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     1E32 800E     
6110               
6111               * ******************************************************************************
6112               *
6113               * Name: MVS5
6114               * Type: Subroutine
6115               * Category: Moving
6116               * Summary: Apply a 3.6 degree pitch or roll to an orientation vector
6117               * Deep dive: Orientation vectors
6118               * Pitching and rolling by a fixed angle
6119               *
6120               * ------------------------------------------------------------------------------
6121               *
6122               * Pitch or roll a ship by a small, fixed amount (1/16 radians, or 3.6 degrees),
6123               * in a specified direction, by rotating the orientation vectors. The vectors to
6124               * rotate are given in X and Y, and the direction of the rotation is given in
6125               * RAT2. The calculation is as follows:
6126               *
6127               * * If the direction is positive:
6128               *
6129               * X = X * (1 - 1/512) + Y / 16
6130               * Y = Y * (1 - 1/512) - X / 16
6131               *
6132               * * If the direction is negative:
6133               *
6134               * X = X * (1 - 1/512) - Y / 16
6135               * Y = Y * (1 - 1/512) + X / 16
6136               *
6137               * So if X = 15 (roofv_x), Y = 21 (sidev_x) and RAT2 is positive, it does this:
6138               *
6139               * roofv_x = roofv_x * (1 - 1/512)  + sidev_x / 16
6140               * sidev_x = sidev_x * (1 - 1/512)  - roofv_x / 16
6141               *
6142               * ------------------------------------------------------------------------------
6143               *
6144               * Arguments:
6145               *
6146               * X                   The first vector to rotate:
6147               *
6148               * * If X = 15, rotate roofv_x
6149               *
6150               * * If X = 17, rotate roofv_y
6151               *
6152               * * If X = 19, rotate roofv_z
6153               *
6154               * * If X = 21, rotate sidev_x
6155               *
6156               * * If X = 23, rotate sidev_y
6157               *
6158               * * If X = 25, rotate sidev_z
6159               *
6160               * Y                   The second vector to rotate:
6161               *
6162               * * If Y = 9,  rotate nosev_x
6163               *
6164               * * If Y = 11, rotate nosev_y
6165               *
6166               * * If Y = 13, rotate nosev_z
6167               *
6168               * * If Y = 21, rotate sidev_x
6169               *
6170               * * If Y = 23, rotate sidev_y
6171               *
6172               * * If Y = 25, rotate sidev_z
6173               *
6174               * RAT2                The direction of the pitch or roll to perform, positive
6175               * or negative (i.e. the sign of the roll or pitch counter
6176               * in bit 7)
6177               *
6178               * ******************************************************************************
6179               
6180               MVS5:
6181 1E34 D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch roofv_x_hi, clear the sign bit, divide by 2 and
     1E36 0054     
6182 1E38 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; store in T, so:
     1E3A 7F00     
6183 1E3C 0910  14        srl  ra,1                       ; LSR A             ;
6184 1E3E D800  22        movb ra,@T                      ; STA T             ; T = |roofv_x_hi| / 2
     1E40 00D1     
6185                                                                          ; = |roofv_x| / 512
6186                                                                          ;
6187                                                                          ; The above is true because:
6188                                                                          ;
6189                                                                          ; |roofv_x| = |roofv_x_hi| * 256 + roofv_x_lo
6190                                                                          ;
6191                                                                          ; so:
6192                                                                          ;
6193                                                                          ; |roofv_x| / 512 = |roofv_x_hi| * 256 / 512
6194                                                                          ; + roofv_x_lo / 512
6195                                                                          ; = |roofv_x_hi| / 2
6196               
6197 1E42 D021  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Now we do the following subtraction:
     1E44 0053     
6198                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1E46 0A15  14        sla  rmone,1
                   < elite.a99
6199                      .sbc @T,ra                      ; SBC T             ; (S R) = (roofv_x_hi roofv_x_lo) - |roofv_x| / 512
     **** ****     > SBC
0001 1E48 1801  10        joc  !
0002 1E4A 7004  14        sb   rone,ra
0003               !:
0004 1E4C 7020  22        sb   @T,ra
     1E4E 00D1     
                   < elite.a99
6200 1E50 D800  22        movb ra,@R                      ; STA R             ; = (1 - 1/512) * roofv_x
     1E52 0091     
6201                                                                          ;
6202                                                                          ; by doing the low bytes first
6203               
6204 1E54 D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; And then the high bytes (the high byte of the right
     1E56 0054     
6205                      .sbi (>00*256)                  ; SBC #0            ; side of the subtraction being 0)
     **** ****     > SBI
0001 1E58 1801  10        joc  !
0002 1E5A 7004  14        sb   rone,ra
0003               !:
0004 1E5C 0220  14        ai   ra,-(>00*256)
     1E5E 0000     
                   < elite.a99
6206 1E60 D800  22        movb ra,@S                      ; STA S
     1E62 0092     
6207               
6208 1E64 D022  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Set P = nosev_x_lo
     1E66 0053     
6209 1E68 D800  22        movb ra,@P                      ; STA P
     1E6A 001B     
6210               
6211 1E6C D022  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch the sign of nosev_x_hi (bit 7) and store in T
     1E6E 0054     
6212 1E70 0240  14        andi ra,>80*256                 ; AND #%10000000
     1E72 8000     
6213 1E74 D800  22        movb ra,@T                      ; STA T
     1E76 00D1     
6214               
6215 1E78 D022  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch nosev_x_hi into A and clear the sign bit, so
     1E7A 0054     
6216 1E7C 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; A = |nosev_x_hi|
     1E7E 7F00     
6217               
6218 1E80 0910  14        srl  ra,1                       ; LSR A             ; Set (A P) = (A P) / 16
6219 1E82 0208  12        li   rarg1,P                    ; ROR P             ; = |nosev_x_hi nosev_x_lo| / 16
     1E84 001B     
6220 1E86 06A0  20        bl   @ror                       ;
     1E88 8054     
6221 1E8A 0910  14        srl  ra,1                       ; LSR A             ; = |nosev_x| / 16
6222 1E8C 0208  12        li   rarg1,P                    ; ROR P
     1E8E 001B     
6223 1E90 06A0  20        bl   @ror                       ;
     1E92 8054     
6224 1E94 0910  14        srl  ra,1                       ; LSR A
6225 1E96 0208  12        li   rarg1,P                    ; ROR P
     1E98 001B     
6226 1E9A 06A0  20        bl   @ror                       ;
     1E9C 8054     
6227 1E9E 0910  14        srl  ra,1                       ; LSR A
6228 1EA0 0208  12        li   rarg1,P                    ; ROR P
     1EA2 001B     
6229 1EA4 06A0  20        bl   @ror                       ;
     1EA6 8054     
6230               
6231 1EA8 F020  22        socb @T,ra                      ; ORA T             ; Set the sign of A to the sign in T (i.e. the sign of
     1EAA 00D1     
6232                                                                          ; the original nosev_x), so now:
6233                                                                          ;
6234                                                                          ; (A P) = nosev_x / 16
6235               
6236                      .eor @RAT2                      ; EOR RAT2          ; Give it the sign as if we multiplied by the direction
     **** ****     > EOR
0001 1EAC D1A0  22        movb @RAT2,rtmp
     1EAE 00AB     
0002 1EB0 2806  14        xor  rtmp,ra
                   < elite.a99
6237                                                                          ; by the pitch or roll direction
6238               
6239 1EB2 D801  22        movb rx,@Q                      ; STX Q             ; Store the value of X so it can be restored after the
     1EB4 0090     
6240                                                                          ; call to ADD
6241               
6242 1EB6 0206  12        li   rtmp,ADD                   ; JSR ADD           ; (A X) = (A P) + (S R)
     1EB8 44BA     
6243 1EBA 06A0  20        bl   @jsr                       ;
     1EBC 8002     
6244                                                                          ; = +/-nosev_x / 16 + (1 - 1/512) * roofv_x
6245               
6246 1EBE D800  22        movb ra,@K+1                    ; STA K+1           ; Set K(1 0) = (1 - 1/512) * roofv_x +/- nosev_x / 16
     1EC0 003E     
6247 1EC2 D801  22        movb rx,@K                      ; STX K
     1EC4 003D     
6248               
6249 1EC6 D060  22        movb @Q,rx                      ; LDX Q             ; Restore the value of X from before the call to ADD
     1EC8 0090     
6250               
6251 1ECA D022  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch nosev_x_hi, clear the sign bit, divide by 2 and
     1ECC 0054     
6252 1ECE 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; store in T, so:
     1ED0 7F00     
6253 1ED2 0910  14        srl  ra,1                       ; LSR A             ;
6254 1ED4 D800  22        movb ra,@T                      ; STA T             ; T = |nosev_x_hi| / 2
     1ED6 00D1     
6255                                                                          ; = |nosev_x| / 512
6256               
6257 1ED8 D022  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Now we do the following subtraction:
     1EDA 0053     
6258                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1EDC 0A15  14        sla  rmone,1
                   < elite.a99
6259                      .sbc @T,ra                      ; SBC T             ; (S R) = (nosev_x_hi nosev_x_lo) - |nosev_x| / 512
     **** ****     > SBC
0001 1EDE 1801  10        joc  !
0002 1EE0 7004  14        sb   rone,ra
0003               !:
0004 1EE2 7020  22        sb   @T,ra
     1EE4 00D1     
                   < elite.a99
6260 1EE6 D800  22        movb ra,@R                      ; STA R             ; = (1 - 1/512) * nosev_x
     1EE8 0091     
6261                                                                          ;
6262                                                                          ; by doing the low bytes first
6263               
6264 1EEA D022  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; And then the high bytes (the high byte of the right
     1EEC 0054     
6265                      .sbi (>00*256)                  ; SBC #0            ; side of the subtraction being 0)
     **** ****     > SBI
0001 1EEE 1801  10        joc  !
0002 1EF0 7004  14        sb   rone,ra
0003               !:
0004 1EF2 0220  14        ai   ra,-(>00*256)
     1EF4 0000     
                   < elite.a99
6266 1EF6 D800  22        movb ra,@S                      ; STA S
     1EF8 0092     
6267               
6268 1EFA D021  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Set P = roofv_x_lo
     1EFC 0053     
6269 1EFE D800  22        movb ra,@P                      ; STA P
     1F00 001B     
6270               
6271 1F02 D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch the sign of roofv_x_hi (bit 7) and store in T
     1F04 0054     
6272 1F06 0240  14        andi ra,>80*256                 ; AND #%10000000
     1F08 8000     
6273 1F0A D800  22        movb ra,@T                      ; STA T
     1F0C 00D1     
6274               
6275 1F0E D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch roofv_x_hi into A and clear the sign bit, so
     1F10 0054     
6276 1F12 0240  14        andi ra,>7f*256                 ; AND #%01111111    ; A = |roofv_x_hi|
     1F14 7F00     
6277               
6278 1F16 0910  14        srl  ra,1                       ; LSR A             ; Set (A P) = (A P) / 16
6279 1F18 0208  12        li   rarg1,P                    ; ROR P             ; = |roofv_x_hi roofv_x_lo| / 16
     1F1A 001B     
6280 1F1C 06A0  20        bl   @ror                       ;
     1F1E 8054     
6281 1F20 0910  14        srl  ra,1                       ; LSR A             ; = |roofv_x| / 16
6282 1F22 0208  12        li   rarg1,P                    ; ROR P
     1F24 001B     
6283 1F26 06A0  20        bl   @ror                       ;
     1F28 8054     
6284 1F2A 0910  14        srl  ra,1                       ; LSR A
6285 1F2C 0208  12        li   rarg1,P                    ; ROR P
     1F2E 001B     
6286 1F30 06A0  20        bl   @ror                       ;
     1F32 8054     
6287 1F34 0910  14        srl  ra,1                       ; LSR A
6288 1F36 0208  12        li   rarg1,P                    ; ROR P
     1F38 001B     
6289 1F3A 06A0  20        bl   @ror                       ;
     1F3C 8054     
6290               
6291 1F3E F020  22        socb @T,ra                      ; ORA T             ; Set the sign of A to the opposite sign to T (i.e. the
     1F40 00D1     
6292                      .eoi (>80*256)                  ; EOR #%10000000    ; sign of the original -roofv_x), so now:
     **** ****     > EOI
0001 1F42 0206  12        li   rtmp,(>80*256)
     1F44 8000     
0002 1F46 2806  14        xor  rtmp,ra
                   < elite.a99
6293                                                                          ;
6294                                                                          ; (A P) = -roofv_x / 16
6295               
6296                      .eor @RAT2                      ; EOR RAT2          ; Give it the sign as if we multiplied by the direction
     **** ****     > EOR
0001 1F48 D1A0  22        movb @RAT2,rtmp
     1F4A 00AB     
0002 1F4C 2806  14        xor  rtmp,ra
                   < elite.a99
6297                                                                          ; by the pitch or roll direction
6298               
6299 1F4E D801  22        movb rx,@Q                      ; STX Q             ; Store the value of X so it can be restored after the
     1F50 0090     
6300                                                                          ; call to ADD
6301               
6302 1F52 0206  12        li   rtmp,ADD                   ; JSR ADD           ; (A X) = (A P) + (S R)
     1F54 44BA     
6303 1F56 06A0  20        bl   @jsr                       ;
     1F58 8002     
6304                                                                          ; = -/+roofv_x / 16 + (1 - 1/512) * nosev_x
6305               
6306 1F5A D880  30        movb ra,@INWK+1(ry)             ; STA INWK+1,Y      ; Set nosev_x = (1-1/512) * nosev_x -/+ roofv_x / 16
     1F5C 0054     
6307 1F5E D881  30        movb rx,@INWK(ry)               ; STX INWK,Y
     1F60 0053     
6308               
6309 1F62 D060  22        movb @Q,rx                      ; LDX Q             ; Restore the value of X from before the call to ADD
     1F64 0090     
6310               
6311 1F66 D020  22        movb @K,ra                      ; LDA K             ; Set roofv_x = K(1 0)
     1F68 003D     
6312 1F6A D840  30        movb ra,@INWK(rx)               ; STA INWK,X        ; = (1-1/512) * roofv_x +/- nosev_x / 16
     1F6C 0053     
6313 1F6E D020  22        movb @K+1,ra                    ; LDA K+1
     1F70 003E     
6314 1F72 D840  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X
     1F74 0054     
6315               
6316 1F76 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     1F78 800E     
6317               
6318               * ******************************************************************************
6319               *
6320               * Name: MVT6
6321               * Type: Subroutine
6322               * Category: Moving
6323               * Summary: Calculate (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
6324               *
6325               * ------------------------------------------------------------------------------
6326               *
6327               * Do the following calculation, for the coordinate given by X (so this is what
6328               * it does for the x-coordinate):
6329               *
6330               * (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
6331               *
6332               * A is a sign bit and is not included in the calculation, but bits 0-6 of A are
6333               * preserved. Bit 7 is set to the sign of the result.
6334               *
6335               * ------------------------------------------------------------------------------
6336               *
6337               * Arguments:
6338               *
6339               * A                   The sign of P(2 1) in bit 7
6340               *
6341               * P(2 1)              The 16-bit value we want to add the coordinate to
6342               *
6343               * X                   The coordinate to add, as follows:
6344               *
6345               * * If X = 0, add to (x_sign x_hi x_lo)
6346               *
6347               * * If X = 3, add to (y_sign y_hi y_lo)
6348               *
6349               * * If X = 6, add to (z_sign z_hi z_lo)
6350               *
6351               * ------------------------------------------------------------------------------
6352               *
6353               * Returns:
6354               *
6355               * A                   The sign of the result (in bit 7)
6356               *
6357               * ******************************************************************************
6358               
6359               MVT6:
6360 1F7A D080  14        movb ra,ry                      ; TAY               ; Store argument A into Y, for later use
6361               
6362                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; Set A = A EOR x_sign
     **** ****     > EOR
0001 1F7C D1A1  26        movb @INWK+2(RX),rtmp
     1F7E 0055     
0002 1F80 2806  14        xor  rtmp,ra
                   < elite.a99
6363               
6364 1F82 1114  10        jlt  MV50                       ; BMI MV50          ; If the sign is negative, i.e. A and x_sign have
6365                                                                          ; different signs, jump to MV50
6366               
6367                                                                          ; The signs are the same, so we can add the two
6368                                                                          ; arguments and keep the sign to get the result
6369               
6370 1F84 D020  22        movb @P+1,ra                    ; LDA P+1           ; First we add the low bytes:
     1F86 001C     
6371                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 1F88 0A13  14        sla  rzero,1
                   < elite.a99
6372                      .adc @INWK(rx),ra               ; ADC INWK,X        ; P+1 = P+1 + x_lo
     **** ****     > ADC
0001 1F8A 1701  10        jnc  !
0002 1F8C B004  14        ab   rone,ra
0003               !:
0004 1F8E B021  26        ab   @INWK(RX),ra
     1F90 0053     
                   < elite.a99
6373 1F92 D800  22        movb ra,@P+1                    ; STA P+1
     1F94 001C     
6374               
6375 1F96 D020  22        movb @P+2,ra                    ; LDA P+2           ; And then the high bytes:
     1F98 001D     
6376                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X      ;
     **** ****     > ADC
0001 1F9A 1701  10        jnc  !
0002 1F9C B004  14        ab   rone,ra
0003               !:
0004 1F9E B021  26        ab   @INWK+1(RX),ra
     1FA0 0054     
                   < elite.a99
6377 1FA2 D800  22        movb ra,@P+2                    ; STA P+2           ; P+2 = P+2 + x_hi
     1FA4 001D     
6378               
6379 1FA6 D002  14        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6380                                                                          ; so that we keep the original sign
6381               
6382 1FA8 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     1FAA 800E     
6383               
6384               MV50:
6385 1FAC D021  26        movb @INWK(rx),ra               ; LDA INWK,X        ; First we subtract the low bytes:
     1FAE 0053     
6386                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1FB0 0A15  14        sla  rmone,1
                   < elite.a99
6387                      .sbc @P+1,ra                    ; SBC P+1           ; P+1 = x_lo - P+1
     **** ****     > SBC
0001 1FB2 1801  10        joc  !
0002 1FB4 7004  14        sb   rone,ra
0003               !:
0004 1FB6 7020  22        sb   @P+1,ra
     1FB8 001C     
                   < elite.a99
6388 1FBA D800  22        movb ra,@P+1                    ; STA P+1
     1FBC 001C     
6389               
6390 1FBE D021  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; And then the high bytes:
     1FC0 0054     
6391                      .sbc @P+2,ra                    ; SBC P+2           ;
     **** ****     > SBC
0001 1FC2 1801  10        joc  !
0002 1FC4 7004  14        sb   rone,ra
0003               !:
0004 1FC6 7020  22        sb   @P+2,ra
     1FC8 001D     
                   < elite.a99
6392 1FCA D800  22        movb ra,@P+2                    ; STA P+2           ; P+2 = x_hi - P+2
     1FCC 001D     
6393               
6394 1FCE 1706  10        jnc  MV51                       ; BCC MV51          ; If the last subtraction underflowed, then the C flag
6395                                                                          ; will be clear and x_hi < P+2, so jump to MV51 to
6396                                                                          ; negate the result
6397               
6398 1FD0 D002  14        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6399                      .eoi (>80*256)                  ; EOR #%10000000    ; but flip bit 7, which flips the sign. We do this
     **** ****     > EOI
0001 1FD2 0206  12        li   rtmp,(>80*256)
     1FD4 8000     
0002 1FD6 2806  14        xor  rtmp,ra
                   < elite.a99
6400                                                                          ; because x_hi >= P+2 so we want the result to have the
6401                                                                          ; same sign as x_hi (as it's the dominant side in this
6402                                                                          ; calculation). The sign of x_hi is x_sign, and x_sign
6403                                                                          ; has the opposite sign to A, so we flip the sign in A
6404                                                                          ; to return the correct result
6405               
6406 1FD8 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     1FDA 800E     
6407               
6408               MV51:
6409 1FDC 0200  12        li   ra,>01*256                 ; LDA #1            ; Our subtraction underflowed, so we negate the result
     1FDE 0100     
6410                      .sbc @P+1,ra                    ; SBC P+1           ; using two's complement, first with the low byte:
     **** ****     > SBC
0001 1FE0 1801  10        joc  !
0002 1FE2 7004  14        sb   rone,ra
0003               !:
0004 1FE4 7020  22        sb   @P+1,ra
     1FE6 001C     
                   < elite.a99
6411 1FE8 D800  22        movb ra,@P+1                    ; STA P+1           ;
     1FEA 001C     
6412                                                                          ; P+1 = 1 - P+1
6413               
6414 1FEC 0200  12        li   ra,>00*256                 ; LDA #0            ; And then the high byte:
     1FEE 0000     
6415                      .sbc @P+2,ra                    ; SBC P+2           ;
     **** ****     > SBC
0001 1FF0 1801  10        joc  !
0002 1FF2 7004  14        sb   rone,ra
0003               !:
0004 1FF4 7020  22        sb   @P+2,ra
     1FF6 001D     
                   < elite.a99
6416 1FF8 D800  22        movb ra,@P+2                    ; STA P+2           ; P+2 = 0 - P+2
     1FFA 001D     
6417               
6418 1FFC D002  14        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6419                                                                          ; as this is the correct sign for the result. This is
6420                                                                          ; because x_hi < P+2, so we want to return the same sign
6421                                                                          ; as P+2, the dominant side
6422               
6423 1FFE 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     2000 800E     
6424               
6425               * ******************************************************************************
6426               *
6427               * Name: MV40
6428               * Type: Subroutine
6429               * Category: Moving
6430               * Summary: Rotate the planet or sun's location in space by the amount of
6431               * pitch and roll of our ship
6432               * Deep dive: Rotating the universe
6433               *
6434               * ------------------------------------------------------------------------------
6435               *
6436               * We implement this using the same equations as in part 5 of MVEIT, where we
6437               * rotated the current ship's location by our pitch and roll. Specifically, the
6438               * calculation is as follows:
6439               *
6440               * 1. K2 = y - alpha * x
6441               * 2. z = z + beta * K2
6442               * 3. y = K2 - beta * z
6443               * 4. x = x + alpha * y
6444               *
6445               * See the deep dive on "Rotating the universe" for more details on the above.
6446               *
6447               * ******************************************************************************
6448               
6449               MV40:
6450 2002 D020  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set Q = -ALPHA, so Q contains the angle we want to
     2004 009E     
6451                      .eoi (>80*256)                  ; EOR #%10000000    ; roll the planet through (i.e. in the opposite
     **** ****     > EOI
0001 2006 0206  20        li   rtmp,(>80*256)
     2008 8000     
0002 200A 2806  18        xor  rtmp,ra
                   < elite.a99
6452 200C D800  30        movb ra,@Q                      ; STA Q             ; direction to our ship's roll angle alpha)
     200E 0090     
6453               
6454 2010 D020  30        movb @INWK,ra                   ; LDA INWK          ; Set P(1 0) = (x_hi x_lo)
     2012 0053     
6455 2014 D800  30        movb ra,@P                      ; STA P
     2016 001B     
6456 2018 D020  30        movb @INWK+1,ra                 ; LDA INWK+1
     201A 0054     
6457 201C D800  30        movb ra,@P+1                    ; STA P+1
     201E 001C     
6458               
6459 2020 D020  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Set A = x_sign
     2022 0055     
6460               
6461 2024 0206  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     2026 4148     
6462 2028 06A0  28        bl   @jsr                       ;
     202A 8002     
6463                                                                          ;
6464                                                                          ; which also means:
6465                                                                          ;
6466                                                                          ; K(3 2 1) = (A P+1 P) * Q / 256
6467                                                                          ; = x * -alpha / 256
6468                                                                          ; = - alpha * x / 256
6469               
6470 202C 0201  20        li   rx,>03*256                 ; LDX #3            ; Set K(3 2 1) = (y_sign y_hi y_lo) + K(3 2 1)
     202E 0300     
6471 2030 0206  20        li   rtmp,MVT3                  ; JSR MVT3          ; = y - alpha * x / 256
     2032 1C88     
6472 2034 06A0  28        bl   @jsr                       ;
     2036 8002     
6473               
6474 2038 D020  30        movb @K+1,ra                    ; LDA K+1           ; Set K2(2 1) = P(1 0) = K(2 1)
     203A 003E     
6475 203C D800  30        movb ra,@K2+1                   ; STA K2+1
     203E 00AD     
6476 2040 D800  30        movb ra,@P                      ; STA P
     2042 001B     
6477               
6478 2044 D020  30        movb @K+2,ra                    ; LDA K+2           ; Set K2+2 = K+2
     2046 003F     
6479 2048 D800  30        movb ra,@K2+2                   ; STA K2+2
     204A 00AE     
6480               
6481 204C D800  30        movb ra,@P+1                    ; STA P+1           ; Set P+1 = K+2
     204E 001C     
6482               
6483 2050 D020  30        movb @BETA,ra                   ; LDA BETA          ; Set Q = beta, the pitch angle of our ship
     2052 002A     
6484 2054 D800  30        movb ra,@Q                      ; STA Q
     2056 0090     
6485               
6486 2058 D020  30        movb @K+3,ra                    ; LDA K+3           ; Set K+3 to K2+3, so now we have result 1 above:
     205A 0040     
6487 205C D800  30        movb ra,@K2+3                   ; STA K2+3          ;
     205E 00AF     
6488                                                                          ; K2(3 2 1) = K(3 2 1)
6489                                                                          ; = y - alpha * x / 256
6490               
6491                                                                          ; We also have:
6492                                                                          ;
6493                                                                          ; A = K+3
6494                                                                          ;
6495                                                                          ; P(1 0) = K(2 1)
6496                                                                          ;
6497                                                                          ; so combined, these mean:
6498                                                                          ;
6499                                                                          ; (A P+1 P) = K(3 2 1)
6500                                                                          ; = K2(3 2 1)
6501               
6502 2060 0206  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     2062 4148     
6503 2064 06A0  28        bl   @jsr                       ;
     2066 8002     
6504                                                                          ;
6505                                                                          ; which also means:
6506                                                                          ;
6507                                                                          ; K(3 2 1) = (A P+1 P) * Q / 256
6508                                                                          ; = K2(3 2 1) * beta / 256
6509                                                                          ; = beta * K2 / 256
6510               
6511 2068 0201  20        li   rx,>06*256                 ; LDX #6            ; K(3 2 1) = (z_sign z_hi z_lo) + K(3 2 1)
     206A 0600     
6512 206C 0206  20        li   rtmp,MVT3                  ; JSR MVT3          ; = z + beta * K2 / 256
     206E 1C88     
6513 2070 06A0  28        bl   @jsr                       ;
     2072 8002     
6514               
6515 2074 D020  30        movb @K+1,ra                    ; LDA K+1           ; Set P = K+1
     2076 003E     
6516 2078 D800  30        movb ra,@P                      ; STA P
     207A 001B     
6517               
6518 207C D800  30        movb ra,@INWK+6                 ; STA INWK+6        ; Set z_lo = K+1
     207E 0059     
6519               
6520 2080 D020  30        movb @K+2,ra                    ; LDA K+2           ; Set P+1 = K+2
     2082 003F     
6521 2084 D800  30        movb ra,@P+1                    ; STA P+1
     2086 001C     
6522               
6523 2088 D800  30        movb ra,@INWK+7                 ; STA INWK+7        ; Set z_hi = K+2
     208A 005A     
6524               
6525 208C D020  30        movb @K+3,ra                    ; LDA K+3           ; Set A = z_sign = K+3, so now we have:
     208E 0040     
6526 2090 D800  30        movb ra,@INWK+8                 ; STA INWK+8        ;
     2092 005B     
6527                                                                          ; (z_sign z_hi z_lo) = K(3 2 1)
6528                                                                          ; = z + beta * K2 / 256
6529               
6530                                                                          ; So we now have result 2 above:
6531                                                                          ;
6532                                                                          ; z = z + beta * K2
6533               
6534                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign bit of A to give A = -z_sign
     **** ****     > EOI
0001 2094 0206  20        li   rtmp,(>80*256)
     2096 8000     
0002 2098 2806  18        xor  rtmp,ra
                   < elite.a99
6535               
6536 209A 0206  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     209C 4148     
6537 209E 06A0  28        bl   @jsr                       ;
     20A0 8002     
6538                                                                          ; = (-z_sign z_hi z_lo) * beta
6539                                                                          ; = -z * beta
6540               
6541 20A2 D020  30        movb @K+3,ra                    ; LDA K+3           ; Set T to the sign bit of K(3 2 1 0), i.e. to the sign
     20A4 0040     
6542 20A6 0240  22        andi ra,>80*256                 ; AND #%10000000    ; bit of -z * beta
     20A8 8000     
6543 20AA D800  30        movb ra,@T                      ; STA T
     20AC 00D1     
6544               
6545                      .eor @K2+3                      ; EOR K2+3          ; If K2(3 2 1 0) has a different sign to K(3 2 1 0),
     **** ****     > EOR
0001 20AE D1A0  30        movb @K2+3,rtmp
     20B0 00AF     
0002 20B2 2806  18        xor  rtmp,ra
                   < elite.a99
6546 20B4 111E  14        jlt  MV1                        ; BMI MV1           ; then EOR'ing them will produce a 1 in bit 7, so jump
6547                                                                          ; to MV1 to take this into account
6548               
6549                                                                          ; If we get here, K and K2 have the same sign, so we can
6550                                                                          ; add them together to get the result we're after, and
6551                                                                          ; then set the sign afterwards
6552               
6553 20B6 D020  30        movb @K,ra                      ; LDA K             ; We now do the following sum:
     20B8 003D     
6554               * CLC                    \
6555                      .adc @K2,ra                     ; ADC K2            ; (A y_hi y_lo -) = K(3 2 1 0) + K2(3 2 1 0)
     **** ****     > ADC
0001 20BA 1701  14        jnc  !
0002 20BC B004  18        ab   rone,ra
0003               !:
0004 20BE B020  30        ab   @K2,ra
     20C0 00AC     
                   < elite.a99
6556                                                                          ;
6557                                                                          ; starting with the low bytes (which we don't keep)
6558                                                                          ;
6559                                                                          ; The CLC instruction is commented out in the original
6560                                                                          ; source. It isn't needed because MULT3 clears the C
6561                                                                          ; flag, so this is an example of the authors finding
6562                                                                          ; one more precious byte to save
6563               
6564 20C2 D020  30        movb @K+1,ra                    ; LDA K+1           ; We then do the middle bytes, which go into y_lo
     20C4 003E     
6565                      .adc @K2+1,ra                   ; ADC K2+1
     **** ****     > ADC
0001 20C6 1701  14        jnc  !
0002 20C8 B004  18        ab   rone,ra
0003               !:
0004 20CA B020  30        ab   @K2+1,ra
     20CC 00AD     
                   < elite.a99
6566 20CE D800  30        movb ra,@INWK+3                 ; STA INWK+3
     20D0 0056     
6567               
6568 20D2 D020  30        movb @K+2,ra                    ; LDA K+2           ; And then the high bytes, which go into y_hi
     20D4 003F     
6569                      .adc @K2+2,ra                   ; ADC K2+2
     **** ****     > ADC
0001 20D6 1701  14        jnc  !
0002 20D8 B004  18        ab   rone,ra
0003               !:
0004 20DA B020  30        ab   @K2+2,ra
     20DC 00AE     
                   < elite.a99
6570 20DE D800  30        movb ra,@INWK+4                 ; STA INWK+4
     20E0 0057     
6571               
6572 20E2 D020  30        movb @K+3,ra                    ; LDA K+3           ; And then the sign bytes into A, so overall we have the
     20E4 0040     
6573                      .adc @K2+3,ra                   ; ADC K2+3          ; following, if we drop the low bytes from the result:
     **** ****     > ADC
0001 20E6 1701  14        jnc  !
0002 20E8 B004  18        ab   rone,ra
0003               !:
0004 20EA B020  30        ab   @K2+3,ra
     20EC 00AF     
                   < elite.a99
6574                                                                          ;
6575                                                                          ; (A y_hi y_lo) = (K + K2) / 256
6576               
6577 20EE 0460  28        b    @MV2                       ; JMP MV2           ; Jump to MV2 to skip the calculation for when K and K2
     20F0 2172     
6578                                                                          ; have different signs
6579               
6580               MV1:
6581 20F2 D020  30        movb @K,ra                      ; LDA K             ; If we get here then K2 and K have different signs, so
     20F4 003D     
6582                      .sec                            ; SEC               ; instead of adding, we need to subtract to get the
     **** ****     > SEC
0001 20F6 0A15  18        sla  rmone,1
                   < elite.a99
6583                      .sbc @K2,ra                     ; SBC K2            ; result we want, like this:
     **** ****     > SBC
0001 20F8 1801  14        joc  !
0002 20FA 7004  18        sb   rone,ra
0003               !:
0004 20FC 7020  30        sb   @K2,ra
     20FE 00AC     
                   < elite.a99
6584                                                                          ;
6585                                                                          ; (A y_hi y_lo -) = K(3 2 1 0) - K2(3 2 1 0)
6586                                                                          ;
6587                                                                          ; starting with the low bytes (which we don't keep)
6588               
6589 2100 D020  30        movb @K+1,ra                    ; LDA K+1           ; We then do the middle bytes, which go into y_lo
     2102 003E     
6590                      .sbc @K2+1,ra                   ; SBC K2+1
     **** ****     > SBC
0001 2104 1801  14        joc  !
0002 2106 7004  18        sb   rone,ra
0003               !:
0004 2108 7020  30        sb   @K2+1,ra
     210A 00AD     
                   < elite.a99
6591 210C D800  30        movb ra,@INWK+3                 ; STA INWK+3
     210E 0056     
6592               
6593 2110 D020  30        movb @K+2,ra                    ; LDA K+2           ; And then the high bytes, which go into y_hi
     2112 003F     
6594                      .sbc @K2+2,ra                   ; SBC K2+2
     **** ****     > SBC
0001 2114 1801  14        joc  !
0002 2116 7004  18        sb   rone,ra
0003               !:
0004 2118 7020  30        sb   @K2+2,ra
     211A 00AE     
                   < elite.a99
6595 211C D800  30        movb ra,@INWK+4                 ; STA INWK+4
     211E 0057     
6596               
6597 2120 D020  30        movb @K2+3,ra                   ; LDA K2+3          ; Now for the sign bytes, so first we extract the sign
     2122 00AF     
6598 2124 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; byte from K2 without the sign bit, so P = |K2+3|
     2126 7F00     
6599 2128 D800  30        movb ra,@P                      ; STA P
     212A 001B     
6600               
6601 212C D020  30        movb @K+3,ra                    ; LDA K+3           ; And then we extract the sign byte from K without the
     212E 0040     
6602 2130 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; sign bit, so A = |K+3|
     2132 7F00     
6603               
6604                      .sbc @P,ra                      ; SBC P             ; And finally we subtract the sign bytes, so P = A - P
     **** ****     > SBC
0001 2134 1801  14        joc  !
0002 2136 7004  18        sb   rone,ra
0003               !:
0004 2138 7020  30        sb   @P,ra
     213A 001B     
                   < elite.a99
6605 213C D800  30        movb ra,@P                      ; STA P
     213E 001B     
6606               
6607                                                                          ; By now we have the following, if we drop the low bytes
6608                                                                          ; from the result:
6609                                                                          ;
6610                                                                          ; (A y_hi y_lo) = (K - K2) / 256
6611                                                                          ;
6612                                                                          ; so now we just need to make sure the sign of the
6613                                                                          ; result is correct
6614               
6615 2140 1818  14        joc  MV2                        ; BCS MV2           ; If the C flag is set, then the last subtraction above
6616                                                                          ; didn't underflow and the result is correct, so jump to
6617                                                                          ; MV2 as we are done with this particular stage
6618               
6619 2142 0200  20        li   ra,>01*256                 ; LDA #1            ; Otherwise the subtraction above underflowed, as K2 is
     2144 0100     
6620                      .sbc @INWK+3,ra                 ; SBC INWK+3        ; the dominant part of the subtraction, so we need to
     **** ****     > SBC
0001 2146 1801  14        joc  !
0002 2148 7004  18        sb   rone,ra
0003               !:
0004 214A 7020  30        sb   @INWK+3,ra
     214C 0056     
                   < elite.a99
6621 214E D800  30        movb ra,@INWK+3                 ; STA INWK+3        ; negate the result using two's complement, starting
     2150 0056     
6622                                                                          ; with the low bytes:
6623                                                                          ;
6624                                                                          ; y_lo = 1 - y_lo
6625               
6626 2152 0200  20        li   ra,>00*256                 ; LDA #0            ; And then the high bytes:
     2154 0000     
6627                      .sbc @INWK+4,ra                 ; SBC INWK+4        ;
     **** ****     > SBC
0001 2156 1801  14        joc  !
0002 2158 7004  18        sb   rone,ra
0003               !:
0004 215A 7020  30        sb   @INWK+4,ra
     215C 0057     
                   < elite.a99
6628 215E D800  30        movb ra,@INWK+4                 ; STA INWK+4        ; y_hi = 0 - y_hi
     2160 0057     
6629               
6630 2162 0200  20        li   ra,>00*256                 ; LDA #0            ; And finally the sign bytes:
     2164 0000     
6631                      .sbc @P,ra                      ; SBC P             ;
     **** ****     > SBC
0001 2166 1801  14        joc  !
0002 2168 7004  18        sb   rone,ra
0003               !:
0004 216A 7020  30        sb   @P,ra
     216C 001B     
                   < elite.a99
6632                                                                          ; A = 0 - P
6633               
6634 216E 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now force the sign bit to be negative, so that the
     2170 8000     
6635                                                                          ; final result below gets the opposite sign to K, which
6636                                                                          ; we want as K2 is the dominant part of the sum
6637               
6638               MV2:
6639                      .eor @T                         ; EOR T             ; T contains the sign bit of K, so if K is negative,
     **** ****     > EOR
0001 2172 D1A0  30        movb @T,rtmp
     2174 00D1     
0002 2176 2806  18        xor  rtmp,ra
                   < elite.a99
6640                                                                          ; this flips the sign of A
6641               
6642 2178 D800  30        movb ra,@INWK+5                 ; STA INWK+5        ; Store A in y_sign
     217A 0058     
6643               
6644                                                                          ; So we now have result 3 above:
6645                                                                          ;
6646                                                                          ; y = K2 + K
6647                                                                          ; = K2 - beta * z
6648               
6649 217C D020  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set A = alpha
     217E 009E     
6650 2180 D800  30        movb ra,@Q                      ; STA Q
     2182 0090     
6651               
6652 2184 D020  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P(1 0) = (y_hi y_lo)
     2186 0056     
6653 2188 D800  30        movb ra,@P                      ; STA P
     218A 001B     
6654 218C D020  30        movb @INWK+4,ra                 ; LDA INWK+4
     218E 0057     
6655 2190 D800  30        movb ra,@P+1                    ; STA P+1
     2192 001C     
6656               
6657 2194 D020  30        movb @INWK+5,ra                 ; LDA INWK+5        ; Set A = y_sign
     2196 0058     
6658               
6659 2198 0206  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     219A 4148     
6660 219C 06A0  28        bl   @jsr                       ;
     219E 8002     
6661                                                                          ; = (y_sign y_hi y_lo) * alpha
6662                                                                          ; = y * alpha
6663               
6664 21A0 0201  20        li   rx,>00*256                 ; LDX #0            ; Set K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
     21A2 0000     
6665 21A4 0206  20        li   rtmp,MVT3                  ; JSR MVT3          ; = x + y * alpha / 256
     21A6 1C88     
6666 21A8 06A0  28        bl   @jsr                       ;
     21AA 8002     
6667               
6668 21AC D020  30        movb @K+1,ra                    ; LDA K+1           ; Set (x_sign x_hi x_lo) = K(3 2 1)
     21AE 003E     
6669 21B0 D800  30        movb ra,@INWK                   ; STA INWK          ; = x + y * alpha / 256
     21B2 0053     
6670 21B4 D020  30        movb @K+2,ra                    ; LDA K+2
     21B6 003F     
6671 21B8 D800  30        movb ra,@INWK+1                 ; STA INWK+1
     21BA 0054     
6672 21BC D020  30        movb @K+3,ra                    ; LDA K+3
     21BE 0040     
6673 21C0 D800  30        movb ra,@INWK+2                 ; STA INWK+2
     21C2 0055     
6674               
6675                                                                          ; So we now have result 4 above:
6676                                                                          ;
6677                                                                          ; x = x + y * alpha
6678               
6679 21C4 0460  24        b    @MV45                      ; JMP MV45          ; We have now finished rotating the planet or sun by
     21C6 1A7A     
6680                                                                          ; our pitch and roll, so jump back into the MVEIT
6681                                                                          ; routine at MV45 to apply all the other movements
6682               
6683               * ******************************************************************************
6684               *
6685               * Save ELTA.bin
6686               *
6687               * ******************************************************************************
6688               
6689                      ; PRINT "ELITE A"
6690                      ; PRINT "Assembled at ", ~CODE%
6691                      ; PRINT "Ends at ", ~P%
6692                      ; PRINT "Code size is ", ~(P% - CODE%)
6693                      ; PRINT "Execute at ", ~LOAD%
6694                      ; PRINT "Reload at ", ~LOAD_A%
6695               
6696                      ; PRINT "S.ELTA ", ~CODE%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_A%
6697                      ; SAVE "3-assembled-output/ELTA.bin", CODE%, P%, LOAD%
6698               
6699               * ******************************************************************************
6700               *
6701               * ELITE B FILE
6702               *
6703               * Produces the binary file ELTB.bin that gets loaded by elite-bcfs.asm.
6704               *
6705               * ******************************************************************************
6706               
6707               CODE_B.:
6708                      equ $
6709               
6710               LOAD_B.:
6711                      equ LOAD. + $ - CODE.
6712               
6713               * ******************************************************************************
6714               *
6715               * Name: NA%
6716               * Type: Variable
6717               * Category: Save and load
6718               * Summary: The data block for the last saved commander
6719               * Deep dive: Commander save files
6720               * The competition code
6721               *
6722               * ------------------------------------------------------------------------------
6723               *
6724               * Contains the last saved commander data, with the name at NA% and the data at
6725               * NA%+8 onwards. The size of the data block is given in NT% (which also includes
6726               * the two checksum bytes that follow this block). This block is initially set up
6727               * with the default commander, which can be maxed out for testing purposes by
6728               * setting Q% to TRUE.
6729               *
6730               * The commander's name is stored at NA%, and can be up to 7 characters long
6731               * (the DFS filename limit). It is terminated with a carriage return character,
6732               * ASCII 13.
6733               *
6734               * The offset of each byte within a saved commander file is also shown as #0, #1
6735               * and so on, so the kill tally, for example, is in bytes #71 and #72 of the
6736               * saved file. The related variable name from the current commander block is
6737               * also shown.
6738               *
6739               * ******************************************************************************
6740               
6741               NA.:
6742 21C8 4A41            text 'JAMESON'                                      ; The current commander name, which defaults to JAMESON
     21CA 4D45     
     21CC 534F     
     21CE 4E       
6743 21CF   0D            byte >0d                                            ;
6744                                                                          ; The commander name can be up to 7 characters (the DFS
6745                                                                          ; limit for filenames), and is terminated by a carriage
6746                                                                          ; return
6747               
6748                                                                          ; NA%+8 is the start of the commander data block
6749                                                                          ;
6750                                                                          ; This block contains the last saved commander data
6751                                                                          ; block. As the game is played it uses an identical
6752                                                                          ; block at location TP to store the current commander
6753                                                                          ; state, and that block is copied here when the game is
6754                                                                          ; saved. Conversely, when the game starts up, the block
6755                                                                          ; here is copied to TP, which restores the last saved
6756                                                                          ; commander when we die
6757                                                                          ;
6758                                                                          ; The initial state of this block defines the default
6759                                                                          ; commander. Q% can be set to TRUE to give the default
6760                                                                          ; commander lots of credits and equipment
6761               
6762 21D0 00              byte >00                                            ; TP = Mission status, #0
6763               
6764 21D1   14            byte >14                                            ; QQ0 = Current system X-coordinate (Lave), #1
6765 21D2 AD              byte >ad                                            ; QQ1 = Current system Y-coordinate (Lave), #2
6766               
6767 21D4 4A5A            data >4a5a                                          ; QQ21 = Seed s0 for system 0, galaxy 0 (Tibedied), #3-4
6768 21D6 4802            data >4802                                          ; QQ21 = Seed s1 for system 0, galaxy 0 (Tibedied), #5-6
6769 21D8 53B7            data >53b7                                          ; QQ21 = Seed s2 for system 0, galaxy 0 (Tibedied), #7-8
6770               
6774 21DA 0000            data >0000, >0000                                   ; CASH = Amount of cash (100 Cr), #9-12
     21DC 0000     
6776               
6777 21DE 46              byte >46                                            ; QQ14 = Fuel level, #13
6778               
6779 21DF   00            byte >00                                            ; COK = Competition flags, #14
6780               
6781 21E0 00              byte >00                                            ; GCNT = Galaxy number, 0-7, #15
6782               
6783 21E1   0F            byte POW+(128 & Q.)                                 ; LASER = Front laser, #16
6784               
6785 21E2 00              byte (POW+128) & Q.                                 ; LASER+1 = Rear laser, #17
6786               
6787 21E3   00            byte >00                                            ; LASER+2 = Left laser, #18
6788               
6789 21E4 00              byte >00                                            ; LASER+3 = Right laser, #19
6790               
6791 21E6 0000            data >0000                                          ; These bytes appear to be unused (they were originally
6792                                                                          ; used for up/down lasers, but they were dropped),
6793                                                                          ; #20-21
6794               
6795 21E8 16              byte 22 + (15 & Q.)                                 ; CRGO = Cargo capacity, #22
6796               
6797 21E9   00            byte >00                                            ; QQ20+0  = Amount of food in cargo hold, #23
6798 21EA 00              byte >00                                            ; QQ20+1  = Amount of textiles in cargo hold, #24
6799 21EB   00            byte >00                                            ; QQ20+2  = Amount of radioactives in cargo hold, #25
6800 21EC 00              byte >00                                            ; QQ20+3  = Amount of slaves in cargo hold, #26
6801 21ED   00            byte >00                                            ; QQ20+4  = Amount of liquor/Wines in cargo hold, #27
6802 21EE 00              byte >00                                            ; QQ20+5  = Amount of luxuries in cargo hold, #28
6803 21EF   00            byte >00                                            ; QQ20+6  = Amount of narcotics in cargo hold, #29
6804 21F0 00              byte >00                                            ; QQ20+7  = Amount of computers in cargo hold, #30
6805 21F1   00            byte >00                                            ; QQ20+8  = Amount of machinery in cargo hold, #31
6806 21F2 00              byte >00                                            ; QQ20+9  = Amount of alloys in cargo hold, #32
6807 21F3   00            byte >00                                            ; QQ20+10 = Amount of firearms in cargo hold, #33
6808 21F4 00              byte >00                                            ; QQ20+11 = Amount of furs in cargo hold, #34
6809 21F5   00            byte >00                                            ; QQ20+12 = Amount of minerals in cargo hold, #35
6810 21F6 00              byte >00                                            ; QQ20+13 = Amount of gold in cargo hold, #36
6811 21F7   00            byte >00                                            ; QQ20+14 = Amount of platinum in cargo hold, #37
6812 21F8 00              byte >00                                            ; QQ20+15 = Amount of gem-stones in cargo hold, #38
6813 21F9   00            byte >00                                            ; QQ20+16 = Amount of alien items in cargo hold, #39
6814               
6815 21FA 00              byte Q.                                             ; ECM = E.C.M. system, #40
6816               
6817 21FB   00            byte Q.                                             ; BST = Fuel scoops ("barrel status"), #41
6818               
6819 21FC 00              byte Q. & 127                                       ; BOMB = Energy bomb, #42
6820               
6821 21FD   00            byte Q. & 1                                         ; ENGY = Energy/shield level, #43
6822               
6823 21FE 00              byte Q.                                             ; DKCMP = Docking computer, #44
6824               
6825 21FF   00            byte Q.                                             ; GHYP = Galactic hyperdrive, #45
6826               
6827 2200 00              byte Q.                                             ; ESCP = Escape pod, #46
6828               
6829 2202 0000            data >0000, >0000                                   ; These four bytes appear to be unused, #47-50
     2204 0000     
6830               
6831 2206 03              byte 3 + (Q. & 1)                                   ; NOMSL = Number of missiles, #51
6832               
6833 2207   00            byte >00                                            ; FIST = Legal status ("fugitive/innocent status"), #52
6834               
6835 2208 10              byte >10                                            ; AVL+0  = Market availability of food, #53
6836 2209   0F            byte >0f                                            ; AVL+1  = Market availability of textiles, #54
6837 220A 11              byte >11                                            ; AVL+2  = Market availability of radioactives, #55
6838 220B   00            byte >00                                            ; AVL+3  = Market availability of slaves, #56
6839 220C 03              byte >03                                            ; AVL+4  = Market availability of liquor/Wines, #57
6840 220D   1C            byte >1c                                            ; AVL+5  = Market availability of luxuries, #58
6841 220E 0E              byte >0e                                            ; AVL+6  = Market availability of narcotics, #59
6842 220F   00            byte >00                                            ; AVL+7  = Market availability of computers, #60
6843 2210 00              byte >00                                            ; AVL+8  = Market availability of machinery, #61
6844 2211   0A            byte >0a                                            ; AVL+9  = Market availability of alloys, #62
6845 2212 00              byte >00                                            ; AVL+10 = Market availability of firearms, #63
6846 2213   11            byte >11                                            ; AVL+11 = Market availability of furs, #64
6847 2214 3A              byte >3a                                            ; AVL+12 = Market availability of minerals, #65
6848 2215   07            byte >07                                            ; AVL+13 = Market availability of gold, #66
6849 2216 09              byte >09                                            ; AVL+14 = Market availability of platinum, #67
6850 2217   08            byte >08                                            ; AVL+15 = Market availability of gem-stones, #68
6851 2218 00              byte >00                                            ; AVL+16 = Market availability of alien items, #69
6852               
6853 2219   00            byte >00                                            ; QQ26 = Random byte that changes for each visit to a
6854                                                                          ; system, for randomising market prices, #70
6855               
6856 221A 0000            data >0000                                          ; TALLY = Number of kills, #71-72
6857               
6858 221C 80              byte >80                                            ; SVC = Save count, #73
6859               
6860               * ******************************************************************************
6861               *
6862               * Name: CHK2
6863               * Type: Variable
6864               * Category: Save and load
6865               * Summary: Second checksum byte for the saved commander data file
6866               * Deep dive: Commander save files
6867               * The competition code
6868               *
6869               * ------------------------------------------------------------------------------
6870               *
6871               * Second commander checksum byte. If the default commander is changed, a new
6872               * checksum will be calculated and inserted by the elite-checksum.py script.
6873               *
6874               * The offset of this byte within a saved commander file is also shown (it's at
6875               * byte #74).
6876               *
6877               * ******************************************************************************
6878               
6879               CHK2:
6880 221D   AA            byte >03 ^ >A9                                      ; The checksum value for the default commander, EOR'd
6881                                                                          ; with &A9 to make it harder to tamper with the checksum
6882                                                                          ; byte, #74
6883               
6884               * ******************************************************************************
6885               *
6886               * Name: CHK
6887               * Type: Variable
6888               * Category: Save and load
6889               * Summary: First checksum byte for the saved commander data file
6890               * Deep dive: Commander save files
6891               * The competition code
6892               *
6893               * ------------------------------------------------------------------------------
6894               *
6895               * Commander checksum byte. If the default commander is changed, a new checksum
6896               * will be calculated and inserted by the elite-checksum.py script.
6897               *
6898               * The offset of this byte within a saved commander file is also shown (it's at
6899               * byte #75).
6900               *
6901               * ******************************************************************************
6902               
6903               CHK:
6904 221E 03              byte >03                                            ; The checksum value for the default commander, #75
6905               
6906               * ******************************************************************************
6907               *
6908               * Name: UNIV
6909               * Type: Variable
6910               * Category: Universe
6911               * Summary: Table of pointers to the local universe's ship data blocks
6912               * Deep dive: The local bubble of universe
6913               *
6914               * ------------------------------------------------------------------------------
6915               *
6916               * See the deep dive on "Ship data blocks" for details on ship data blocks, and
6917               * the deep dive on "The local bubble of universe" for details of how Elite
6918               * stores the local universe in K%, FRIN and UNIV.
6919               *
6920               * ******************************************************************************
6921               
6922               UNIV:
6923                      ; FOR I%, 0, NOSH
6924               
6925                      ; EQUW K% + I% * NI%            ;                   ; Address of block no. I%, of size NI%, in workspace K%
6926               
6927                      ; NEXT
6928               
6929 221F   00            byte (K. + 0 * NI.) % 256, (K. + 0 * NI.) / 256
     2220 44       
6930 2221   24            byte (K. + 1 * NI.) % 256, (K. + 1 * NI.) / 256
     2222 44       
6931 2223   48            byte (K. + 2 * NI.) % 256, (K. + 2 * NI.) / 256
     2224 44       
6932 2225   6C            byte (K. + 3 * NI.) % 256, (K. + 3 * NI.) / 256
     2226 44       
6933 2227   90            byte (K. + 4 * NI.) % 256, (K. + 4 * NI.) / 256
     2228 44       
6934 2229   B4            byte (K. + 5 * NI.) % 256, (K. + 5 * NI.) / 256
     222A 44       
6935 222B   D8            byte (K. + 6 * NI.) % 256, (K. + 6 * NI.) / 256
     222C 44       
6936 222D   FC            byte (K. + 7 * NI.) % 256, (K. + 7 * NI.) / 256
     222E 44       
6937 222F   20            byte (K. + 8 * NI.) % 256, (K. + 8 * NI.) / 256
     2230 45       
6938 2231   44            byte (K. + 9 * NI.) % 256, (K. + 9 * NI.) / 256
     2232 45       
6939 2233   68            byte (K. + 10 * NI.) % 256, (K. + 10 * NI.) / 256
     2234 45       
6940 2235   8C            byte (K. + 11 * NI.) % 256, (K. + 11 * NI.) / 256
     2236 45       
6941 2237   B0            byte (K. + 12 * NI.) % 256, (K. + 12 * NI.) / 256
     2238 45       
6942               
6943               * ******************************************************************************
6944               *
6945               * Name: TWOS
6946               * Type: Variable
6947               * Category: Drawing pixels
6948               * Summary: Ready-made single-pixel character row bytes for mode 4
6949               * Deep dive: Drawing monochrome pixels in mode 4
6950               *
6951               * ------------------------------------------------------------------------------
6952               *
6953               * Ready-made bytes for plotting one-pixel points in mode 4 (the top part of the
6954               * split screen). See the PIXEL routine for details.
6955               *
6956               * ******************************************************************************
6957               
6958               TWOS:
6959 2239   80            byte >80
6960 223A 40              byte >40
6961 223B   20            byte >20
6962 223C 10              byte >10
6963 223D   08            byte >08
6964 223E 04              byte >04
6965 223F   02            byte >02
6966 2240 01              byte >01
6967               
6968               * ******************************************************************************
6969               *
6970               * Name: TWOS2
6971               * Type: Variable
6972               * Category: Drawing pixels
6973               * Summary: Ready-made double-pixel character row bytes for mode 4
6974               * Deep dive: Drawing monochrome pixels in mode 4
6975               *
6976               * ------------------------------------------------------------------------------
6977               *
6978               * Ready-made bytes for plotting two-pixel dashes in mode 4 (the top part of the
6979               * split screen). See the PIXEL routine for details.
6980               *
6981               * ******************************************************************************
6982               
6983               TWOS2:
6984 2241   C0            byte >c0
6985 2242 60              byte >60
6986 2243   30            byte >30
6987 2244 18              byte >18
6988 2245   0C            byte >0c
6989 2246 06              byte >06
6990 2247   03            byte >03
6991 2248 03              byte >03
6992               
6993               * ******************************************************************************
6994               *
6995               * Name: CTWOS
6996               * Type: Variable
6997               * Category: Drawing pixels
6998               * Summary: Ready-made single-pixel character row bytes for mode 5
6999               * Deep dive: Drawing colour pixels in mode 5
7000               *
7001               * ------------------------------------------------------------------------------
7002               *
7003               * Ready-made bytes for plotting one-pixel points in mode 5 (the bottom part of
7004               * the split screen). See the dashboard routines SCAN, DIL2 and CPIX2 for
7005               * details.
7006               *
7007               * There is one extra row to support the use of CTWOS+1,X indexing in the CPIX2
7008               * routine. The extra row is a repeat of the first row, and saves us from having
7009               * to work out whether CTWOS+1+X needs to be wrapped around when drawing a
7010               * two-pixel dash that crosses from one character block into another. See CPIX2
7011               * for more details.
7012               *
7013               * ******************************************************************************
7014               
7015               CTWOS:
7016 2249   88            byte >88
7017 224A 44              byte >44
7018 224B   22            byte >22
7019 224C 11              byte >11
7020 224D   88            byte >88
7021               
7022               * ******************************************************************************
7023               *
7024               * Name: LOIN (Part 1 of 7)
7025               * Type: Subroutine
7026               * Category: Drawing lines
7027               * Summary: Draw a line: Calculate the line gradient in the form of deltas
7028               * Deep dive: Bresenham's line algorithm
7029               *
7030               * ------------------------------------------------------------------------------
7031               *
7032               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7033               * This stage calculates the line deltas.
7034               *
7035               * ------------------------------------------------------------------------------
7036               *
7037               * Arguments:
7038               *
7039               * X1                  The screen x-coordinate of the start of the line
7040               *
7041               * Y1                  The screen y-coordinate of the start of the line
7042               *
7043               * X2                  The screen x-coordinate of the end of the line
7044               *
7045               * Y2                  The screen y-coordinate of the end of the line
7046               *
7047               * ------------------------------------------------------------------------------
7048               *
7049               * Returns:
7050               *
7051               * Y                   Y is preserved
7052               *
7053               * ------------------------------------------------------------------------------
7054               *
7055               * Other entry points:
7056               *
7057               * LL30                LL30 is a synonym for LOIN and draws a line from
7058               * (X1, Y1) to (X2, Y2)
7059               *
7060               * ******************************************************************************
7061               
7062               LL30:
7063 224E                 bss 0                                               ; LL30 is a synonym for LOIN
7064                                                                          ;
7065                                                                          ; In the cassette and disc versions of Elite, LL30 and
7066                                                                          ; LOIN are synonyms for the same routine, presumably
7067                                                                          ; because the two developers each had their own line
7068                                                                          ; routines to start with, and then chose one of them for
7069                                                                          ; the final game
7070               
7071               LOIN:
7072 224E D802  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y into YSAV, so we can preserve it across the
     2250 0094     
7073                                                                          ; call to this subroutine
7074               
7075 2252 0200  20        li   ra,>80*256                 ; LDA #128          ; Set S = 128, which is the starting point for the
     2254 8000     
7076 2256 D800  30        movb ra,@S                      ; STA S             ; slope error (representing half a pixel)
     2258 0092     
7077               
7078                      .asla                           ; ASL A             ; Set SWAP = 0, as %10000000 << 1 = 0
     **** ****     > ASLA
0001 225A 0240  22        andi ra,>ff00
     225C FF00     
0002 225E 0A10  18        sla  ra,1
                   < elite.a99
7079 2260 D800  30        movb ra,@SWAP                   ; STA SWAP
     2262 00A1     
7080               
7081 2264 D020  30        movb @X2,ra                     ; LDA X2            ; Set A = X2 - X1
     2266 0033     
7082                      .sbc @X1,ra                     ; SBC X1            ; = delta_x
     **** ****     > SBC
0001 2268 1801  14        joc  !
0002 226A 7004  18        sb   rone,ra
0003               !:
0004 226C 7020  30        sb   @X1,ra
     226E 0031     
                   < elite.a99
7083                                                                          ;
7084                                                                          ; This subtraction works as the ASL A above sets the C
7085                                                                          ; flag
7086               
7087 2270 1808  14        joc  LI1                        ; BCS LI1           ; If X2 > X1 then A is already positive and we can skip
7088                                                                          ; the next three instructions
7089               
7090                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A by flipping all the bits and
     **** ****     > EOI
0001 2272 0206  20        li   rtmp,(>FF*256)
     2274 FF00     
0002 2276 2806  18        xor  rtmp,ra
                   < elite.a99
7091                      .adi (>01*256)                  ; ADC #1            ; adding 1, i.e. using two's complement to make it
     **** ****     > ADI
0001 2278 1701  14        jnc  !
0002 227A B004  18        ab   rone,ra
0003               !:
0004 227C 0220  22        ai   ra,(>01*256)
     227E 0100     
                   < elite.a99
7092                                                                          ; positive
7093               
7094                      .sec                            ; SEC               ; Set the C flag, ready for the subtraction below
     **** ****     > SEC
0001 2280 0A15  18        sla  rmone,1
                   < elite.a99
7095               
7096               LI1:
7097 2282 D800  30        movb ra,@P                      ; STA P             ; Store A in P, so P = |X2 - X1|, or |delta_x|
     2284 001B     
7098               
7099 2286 D020  30        movb @Y2,ra                     ; LDA Y2            ; Set A = Y2 - Y1
     2288 0034     
7100                      .sbc @Y1,ra                     ; SBC Y1            ; = delta_y
     **** ****     > SBC
0001 228A 1801  14        joc  !
0002 228C 7004  18        sb   rone,ra
0003               !:
0004 228E 7020  30        sb   @Y1,ra
     2290 0032     
                   < elite.a99
7101                                                                          ;
7102                                                                          ; This subtraction works as we either set the C flag
7103                                                                          ; above, or we skipped that SEC instruction with a BCS
7104               
7105 2292 1807  14        joc  LI2                        ; BCS LI2           ; If Y2 > Y1 then A is already positive and we can skip
7106                                                                          ; the next two instructions
7107               
7108                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A by flipping all the bits and
     **** ****     > EOI
0001 2294 0206  20        li   rtmp,(>FF*256)
     2296 FF00     
0002 2298 2806  18        xor  rtmp,ra
                   < elite.a99
7109                      .adi (>01*256)                  ; ADC #1            ; adding 1, i.e. using two's complement to make it
     **** ****     > ADI
0001 229A 1701  14        jnc  !
0002 229C B004  18        ab   rone,ra
0003               !:
0004 229E 0220  22        ai   ra,(>01*256)
     22A0 0100     
                   < elite.a99
7110                                                                          ; positive
7111               
7112               LI2:
7113 22A2 D800  30        movb ra,@Q                      ; STA Q             ; Store A in Q, so Q = |Y2 - Y1|, or |delta_y|
     22A4 0090     
7114               
7115 22A6 9020  30        cb   @P,ra                      ; CMP P             ; If Q < P, jump to STPX to step along the x-axis, as
     22A8 001B     
7116 22AA 1702  14        jnc  STPX                       ; BCC STPX          ; the line is closer to being horizontal than vertical
7117               
7118 22AC 0460  28        b    @STPY                      ; JMP STPY          ; Otherwise Q >= P so jump to STPY to step along the
     22AE 242E     
7119                                                                          ; y-axis, as the line is closer to being vertical than
7120                                                                          ; horizontal
7121               
7122               * ******************************************************************************
7123               *
7124               * Name: LOIN (Part 2 of 7)
7125               * Type: Subroutine
7126               * Category: Drawing lines
7127               * Summary: Draw a line: Line has a shallow gradient, step right along x-axis
7128               * Deep dive: Bresenham's line algorithm
7129               *
7130               * ------------------------------------------------------------------------------
7131               *
7132               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7133               * If we get here, then:
7134               *
7135               * * |delta_y| < |delta_x|
7136               *
7137               * * The line is closer to being horizontal than vertical
7138               *
7139               * * We are going to step right along the x-axis
7140               *
7141               * * We potentially swap coordinates to make sure X1 < X2
7142               *
7143               * ******************************************************************************
7144               
7145               STPX:
7146 22B0 D060  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     22B2 0031     
7147               
7148 22B4 9060  30        cb   @X2,rx                     ; CPX X2            ; If X1 < X2, jump down to LI3, as the coordinates are
     22B6 0033     
7149 22B8 1710  14        jnc  LI3                        ; BCC LI3           ; already in the order that we want
7150               
7151 22BA 7004  18        sb   rone,ra                    ; DEC SWAP          ; Otherwise decrement SWAP from 0 to &FF, to denote that
7152                                                                          ; we are swapping the coordinates around
7153               
7154 22BC D020  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2
     22BE 0033     
7155 22C0 D800  30        movb ra,@X1                     ; STA X1
     22C2 0031     
7156 22C4 D801  30        movb rx,@X2                     ; STX X2
     22C6 0033     
7157               
7158 22C8 D040  18        movb ra,rx                      ; TAX               ; Set X = X1
7159               
7160 22CA D020  30        movb @Y2,ra                     ; LDA Y2            ; Swap the values of Y1 and Y2
     22CC 0034     
7161 22CE D0A0  30        movb @Y1,ry                     ; LDY Y1
     22D0 0032     
7162 22D2 D800  30        movb ra,@Y1                     ; STA Y1
     22D4 0032     
7163 22D6 D802  30        movb ry,@Y2                     ; STY Y2
     22D8 0034     
7164               
7165               LI3:
7166                                                                          ; By this point we know the line is horizontal-ish and
7167                                                                          ; X1 < X2, so we're going from left to right as we go
7168                                                                          ; from X1 to X2
7169 22DA D020  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 / 8, so A now contains the character row
     22DC 0032     
7170 22DE 0910  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7171 22E0 0910  18        srl  ra,1                       ; LSR A
7172 22E2 0910  18        srl  ra,1                       ; LSR A
7173               
7174 22E4 0260  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     22E6 6000     
7175                                                                          ; us the screen address of the character row (as each
7176                                                                          ; character row takes up 256 bytes, and the first
7177                                                                          ; character row is at screen address &6000, or page &60)
7178               
7179 22E8 D800  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     22EA 0008     
7180                                                                          ; the high byte of SC is set correctly for drawing the
7181                                                                          ; start of our line
7182               
7183 22EC D020  30        movb @Y1,ra                     ; LDA Y1            ; Set Y = Y1 mod 8, which is the pixel row within the
     22EE 0032     
7184 22F0 0240  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw the start of
     22F2 0700     
7185 22F4 D080  18        movb ra,ry                      ; TAY               ; our line (as each character block has 8 rows)
7186               
7187 22F6 D001  18        movb rx,ra                      ; TXA               ; Set A = bits 3-7 of X1
7188 22F8 0240  22        andi ra,>f8*256                 ; AND #%11111000
     22FA F800     
7189               
7190 22FC D800  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     22FE 0007     
7191                                                                          ; screen address of the far left end (x-coordinate = 0)
7192                                                                          ; of the horizontal pixel row that we want to draw the
7193                                                                          ; start of our line on
7194               
7195 2300 D001  18        movb rx,ra                      ; TXA               ; Set X = X1 mod 8, which is the horizontal pixel number
7196 2302 0240  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     2304 0700     
7197 2306 D040  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
7198                                                                          ; wide)
7199               
7200 2308 D021  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS where pixel X is set,
     230A 2239     
7201 230C D800  30        movb ra,@R                      ; STA R             ; and store it in R
     230E 0091     
7202               
7203                                                                          ; The following calculates:
7204                                                                          ;
7205                                                                          ; Q = Q / P
7206                                                                          ; = |delta_y| / |delta_x|
7207                                                                          ;
7208                                                                          ; using the same shift-and-subtract algorithm that's
7209                                                                          ; documented in TIS2
7210               
7211 2310 D020  30        movb @Q,ra                      ; LDA Q             ; Set A = |delta_y|
     2312 0090     
7212               
7213 2314 0201  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set Q to have bits 1-7 set, so we can rotate through 7
     2316 FE00     
7214 2318 D801  30        movb rx,@Q                      ; STX Q             ; loop iterations, getting a 1 each time, and then
     231A 0090     
7215                                                                          ; getting a 0 on the 8th iteration... and we can also
7216                                                                          ; use Q to catch our result bits into bit 0 each time
7217               
7218               LIL1:
7219                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 231C 0240  22        andi ra,>ff00
     231E FF00     
0002 2320 0A10  18        sla  ra,1
                   < elite.a99
7220               
7221 2322 1803  14        joc  LI4                        ; BCS LI4           ; If bit 7 of A was set, then jump straight to the
7222                                                                          ; subtraction
7223               
7224 2324 9020  30        cb   @P,ra                      ; CMP P             ; If A < P, skip the following subtraction
     2326 001B     
7225 2328 1705  14        jnc  LI5                        ; BCC LI5
7226               
7227               LI4:
7228                      .sbc @P,ra                      ; SBC P             ; A >= P, so set A = A - P
     **** ****     > SBC
0001 232A 1801  14        joc  !
0002 232C 7004  18        sb   rone,ra
0003               !:
0004 232E 7020  30        sb   @P,ra
     2330 001B     
                   < elite.a99
7229               
7230                      .sec                            ; SEC               ; Set the C flag to rotate into the result in Q
     **** ****     > SEC
0001 2332 0A15  18        sla  rmone,1
                   < elite.a99
7231               
7232               LI5:
7233 2334 0208  20        li   rarg1,Q                    ; ROL Q             ; Rotate the counter in Q to the left, and catch the
     2336 0090     
7234 2338 06A0  28        bl   @rol                       ;
     233A 8028     
7235                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
7236                                                                          ; do the subtraction, or 1 if we did)
7237               
7238 233C 18EF  14        joc  LIL1                       ; BCS LIL1          ; If we still have set bits in Q, loop back to TIL2 to
7239                                                                          ; do the next iteration of 7
7240               
7241                                                                          ; We now have:
7242                                                                          ;
7243                                                                          ; Q = A / P
7244                                                                          ; = |delta_y| / |delta_x|
7245                                                                          ;
7246                                                                          ; and the C flag is clear
7247               
7248 233E D060  30        movb @P,rx                      ; LDX P             ; Set X = P + 1
     2340 001B     
7249 2342 B044  18        ab   rone,rx                    ; INX               ; = |delta_x| + 1
7250                                                                          ;
7251                                                                          ; We add 1 so we can skip the first pixel plot if the
7252                                                                          ; line is being drawn with swapped coordinates
7253               
7254 2344 D020  30        movb @Y2,ra                     ; LDA Y2            ; Set A = Y2 - Y1 - 1 (as the C flag is clear following
     2346 0034     
7255                      .sbc @Y1,ra                     ; SBC Y1            ; the above division)
     **** ****     > SBC
0001 2348 1801  14        joc  !
0002 234A 7004  18        sb   rone,ra
0003               !:
0004 234C 7020  30        sb   @Y1,ra
     234E 0032     
                   < elite.a99
7256               
7257 2350 1836  14        joc  DOWN                       ; BCS DOWN          ; If Y2 >= Y1 - 1 then jump to DOWN, as we need to draw
7258                                                                          ; the line to the right and down
7259               
7260               * ******************************************************************************
7261               *
7262               * Name: LOIN (Part 3 of 7)
7263               * Type: Subroutine
7264               * Category: Drawing lines
7265               * Summary: Draw a shallow line going right and up or left and down
7266               * Deep dive: Bresenham's line algorithm
7267               *
7268               * ------------------------------------------------------------------------------
7269               *
7270               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7271               * If we get here, then:
7272               *
7273               * * The line is going right and up (no swap) or left and down (swap)
7274               *
7275               * * X1 < X2 and Y1-1 > Y2
7276               *
7277               * * Draw from (X1, Y1) at bottom left to (X2, Y2) at top right, omitting the
7278               * first pixel
7279               *
7280               * ******************************************************************************
7281               
7282 2352 D020  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP > 0 then we swapped the coordinates above, so
     2354 00A1     
7283 2356 160D  14        jne  LI6                        ; BNE LI6           ; jump down to LI6 to skip plotting the first pixel
7284                                                                          ;
7285                                                                          ; This appears to be a bug that omits the last pixel
7286                                                                          ; of this type of shallow line, rather than the first
7287                                                                          ; pixel, which makes the treatment of this kind of line
7288                                                                          ; different to the other kinds of slope (they all have a
7289                                                                          ; BEQ instruction at this point, rather than a BNE)
7290                                                                          ;
7291                                                                          ; The result is a rather messy line join when a shallow
7292                                                                          ; line that goes right and up or left and down joins a
7293                                                                          ; line with any of the other three types of slope
7294                                                                          ;
7295                                                                          ; This bug was fixed in the advanced versions of Elite,
7296                                                                          ; where the BNE is replaced by a BEQ to bring it in line
7297                                                                          ; with the other three slopes
7298               
7299 2358 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7300                                                                          ; the first pixel
7301               
7302               LIL2:
7303                                                                          ; We now loop along the line from left to right, using X
7304                                                                          ; as a decreasing counter, and at each count we plot a
7305                                                                          ; single pixel using the pixel mask in R
7306 235A D020  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     235C 0091     
7307               
7308                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 235E D1A0  30        movb @SC,rtmp
     2360 0007     
0002 2362 2806  18        xor  rtmp,ra
                   < elite.a99
7309                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 2364 D820  42        movb @SC,@rtmplb
     2366 0007     
     2368 830D     
0002 236A D1A0  30        movb @SC+1,rtmp
     236C 0008     
0003 236E A182  18        a    ry,rtmp
0004 2370 D580  30        movb RA,*rtmp
                   < elite.a99
7310               
7311               LI6:
7312                      .lsr @R                         ; LSR R             ; Shift the single pixel in R to the right to step along
     **** ****     > LSR
0001 2372 D1A0  30        movb @R,rtmp
     2374 0091     
0002 2376 0916  18        srl  rtmp,1
0003 2378 D806  30        movb rtmp,@R
     237A 0091     
                   < elite.a99
7313                                                                          ; the x-axis, so the next pixel we plot will be at the
7314                                                                          ; next x-coordinate along
7315               
7316 237C 170C  14        jnc  LI7                        ; BCC LI7           ; If the pixel didn't fall out of the right end of R
7317                                                                          ; into the C flag, then jump to LI7
7318               
7319 237E 0208  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     2380 0091     
7320 2382 06A0  28        bl   @ror                       ;
     2384 8054     
7321                                                                          ; block, so first rotate R right so the set C flag goes
7322                                                                          ; back into the left end, giving %10000000
7323               
7324 2386 D020  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     2388 0007     
7325                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 238A 1701  14        jnc  !
0002 238C B004  18        ab   rone,ra
0003               !:
0004 238E 0220  22        ai   ra,(>08*256)
     2390 0800     
                   < elite.a99
7326 2392 D800  30        movb ra,@SC                     ; STA SC
     2394 0007     
7327               
7328               LI7:
7329 2396 D020  30        movb @S,ra                      ; LDA S             ; Set S = S + Q to update the slope error
     2398 0092     
7330                      .adc @Q,ra                      ; ADC Q
     **** ****     > ADC
0001 239A 1701  14        jnc  !
0002 239C B004  18        ab   rone,ra
0003               !:
0004 239E B020  30        ab   @Q,ra
     23A0 0090     
                   < elite.a99
7331 23A2 D800  30        movb ra,@S                      ; STA S
     23A4 0092     
7332               
7333 23A6 1705  14        jnc  LIC2                       ; BCC LIC2          ; If the addition didn't overflow, jump to LIC2
7334               
7335 23A8 7084  18        sb   rone,ry                    ; DEY               ; Otherwise we just overflowed, so decrement Y to move
7336                                                                          ; to the pixel line above
7337               
7338 23AA 1503  14        jgt  LIC2                       ; BPL LIC2          ; If Y is positive we are still within the same
7339                                                                          ; character block, so skip to LIC2
7340               
7341 23AC 7004  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7342 23AE 0202  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     23B0 0700     
7343                                                                          ; address and set the pixel line to the last line in
7344                                                                          ; that character block
7345               
7346               LIC2:
7347 23B2 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7348               
7349 23B4 16D2  14        jne  LIL2                       ; BNE LIL2          ; If we haven't yet reached the right end of the line,
7350                                                                          ; loop back to LIL2 to plot the next pixel along
7351               
7352 23B6 D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     23B8 0094     
7353               
7354 23BA 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     23BC 800E     
7355               
7356               * ******************************************************************************
7357               *
7358               * Name: LOIN (Part 4 of 7)
7359               * Type: Subroutine
7360               * Category: Drawing lines
7361               * Summary: Draw a shallow line going right and down or left and up
7362               * Deep dive: Bresenham's line algorithm
7363               *
7364               * ------------------------------------------------------------------------------
7365               *
7366               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7367               * If we get here, then:
7368               *
7369               * * The line is going right and down (no swap) or left and up (swap)
7370               *
7371               * * X1 < X2 and Y1-1 <= Y2
7372               *
7373               * * Draw from (X1, Y1) at top left to (X2, Y2) at bottom right, omitting the
7374               * first pixel
7375               *
7376               * ******************************************************************************
7377               
7378               DOWN:
7379 23BE D020  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     23C0 00A1     
7380 23C2 130D  14        jeq  LI9                        ; BEQ LI9           ; so jump down to LI9 to skip plotting the first pixel
7381               
7382 23C4 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7383                                                                          ; the first pixel
7384               
7385               LIL3:
7386                                                                          ; We now loop along the line from left to right, using X
7387                                                                          ; as a decreasing counter, and at each count we plot a
7388                                                                          ; single pixel using the pixel mask in R
7389 23C6 D020  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     23C8 0091     
7390               
7391                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 23CA D1A0  30        movb @SC,rtmp
     23CC 0007     
0002 23CE 2806  18        xor  rtmp,ra
                   < elite.a99
7392                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 23D0 D820  42        movb @SC,@rtmplb
     23D2 0007     
     23D4 830D     
0002 23D6 D1A0  30        movb @SC+1,rtmp
     23D8 0008     
0003 23DA A182  18        a    ry,rtmp
0004 23DC D580  30        movb RA,*rtmp
                   < elite.a99
7393               
7394               LI9:
7395                      .lsr @R                         ; LSR R             ; Shift the single pixel in R to the right to step along
     **** ****     > LSR
0001 23DE D1A0  30        movb @R,rtmp
     23E0 0091     
0002 23E2 0916  18        srl  rtmp,1
0003 23E4 D806  30        movb rtmp,@R
     23E6 0091     
                   < elite.a99
7396                                                                          ; the x-axis, so the next pixel we plot will be at the
7397                                                                          ; next x-coordinate along
7398               
7399 23E8 170C  14        jnc  LI10                       ; BCC LI10          ; If the pixel didn't fall out of the right end of R
7400                                                                          ; into the C flag, then jump to LI10
7401               
7402 23EA 0208  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     23EC 0091     
7403 23EE 06A0  28        bl   @ror                       ;
     23F0 8054     
7404                                                                          ; block, so first rotate R right so the set C flag goes
7405                                                                          ; back into the left end, giving %10000000
7406               
7407 23F2 D020  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     23F4 0007     
7408                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 23F6 1701  14        jnc  !
0002 23F8 B004  18        ab   rone,ra
0003               !:
0004 23FA 0220  22        ai   ra,(>08*256)
     23FC 0800     
                   < elite.a99
7409 23FE D800  30        movb ra,@SC                     ; STA SC
     2400 0007     
7410               
7411               LI10:
7412 2402 D020  30        movb @S,ra                      ; LDA S             ; Set S = S + Q to update the slope error
     2404 0092     
7413                      .adc @Q,ra                      ; ADC Q
     **** ****     > ADC
0001 2406 1701  14        jnc  !
0002 2408 B004  18        ab   rone,ra
0003               !:
0004 240A B020  30        ab   @Q,ra
     240C 0090     
                   < elite.a99
7414 240E D800  30        movb ra,@S                      ; STA S
     2410 0092     
7415               
7416 2412 1707  14        jnc  LIC3                       ; BCC LIC3          ; If the addition didn't overflow, jump to LIC3
7417               
7418 2414 B084  18        ab   rone,ry                    ; INY               ; Otherwise we just overflowed, so increment Y to move
7419                                                                          ; to the pixel line below
7420               
7421 2416 0282  22        ci   ry,>08*256                 ; CPY #8            ; If Y < 8 we are still within the same character block,
     2418 0800     
7422 241A 1603  14        jne  LIC3                       ; BNE LIC3          ; so skip to LIC3
7423               
7424 241C B004  18        ab   rone,ra                    ; INC SCH           ; Otherwise we need to move down into the character
7425 241E 0202  20        li   ry,>00*256                 ; LDY #0            ; block below, so increment the high byte of the screen
     2420 0000     
7426                                                                          ; address and set the pixel line to the first line in
7427                                                                          ; that character block
7428               
7429               LIC3:
7430 2422 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7431               
7432 2424 16D0  14        jne  LIL3                       ; BNE LIL3          ; If we haven't yet reached the right end of the line,
7433                                                                          ; loop back to LIL3 to plot the next pixel along
7434               
7435 2426 D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2428 0094     
7436               
7437 242A 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     242C 800E     
7438               
7439               * ******************************************************************************
7440               *
7441               * Name: LOIN (Part 5 of 7)
7442               * Type: Subroutine
7443               * Category: Drawing lines
7444               * Summary: Draw a line: Line has a steep gradient, step up along y-axis
7445               * Deep dive: Bresenham's line algorithm
7446               *
7447               * ------------------------------------------------------------------------------
7448               *
7449               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7450               * If we get here, then:
7451               *
7452               * * |delta_y| >= |delta_x|
7453               *
7454               * * The line is closer to being vertical than horizontal
7455               *
7456               * * We are going to step up along the y-axis
7457               *
7458               * * We potentially swap coordinates to make sure Y1 >= Y2
7459               *
7460               * ******************************************************************************
7461               
7462               STPY:
7463 242E D0A0  30        movb @Y1,ry                     ; LDY Y1            ; Set A = Y = Y1
     2430 0032     
7464 2432 D002  18        movb ry,ra                      ; TYA
7465               
7466 2434 D060  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     2436 0031     
7467               
7468 2438 90A0  30        cb   @Y2,ry                     ; CPY Y2            ; If Y1 >= Y2, jump down to LI15, as the coordinates are
     243A 0034     
7469 243C 180F  14        joc  LI15                       ; BCS LI15          ; already in the order that we want
7470               
7471 243E 7004  18        sb   rone,ra                    ; DEC SWAP          ; Otherwise decrement SWAP from 0 to &FF, to denote that
7472                                                                          ; we are swapping the coordinates around
7473               
7474 2440 D020  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2
     2442 0033     
7475 2444 D800  30        movb ra,@X1                     ; STA X1
     2446 0031     
7476 2448 D801  30        movb rx,@X2                     ; STX X2
     244A 0033     
7477               
7478 244C D040  18        movb ra,rx                      ; TAX               ; Set X = X1
7479               
7480 244E D020  30        movb @Y2,ra                     ; LDA Y2            ; Swap the values of Y1 and Y2
     2450 0034     
7481 2452 D800  30        movb ra,@Y1                     ; STA Y1
     2454 0032     
7482 2456 D802  30        movb ry,@Y2                     ; STY Y2
     2458 0034     
7483               
7484 245A D080  18        movb ra,ry                      ; TAY               ; Set Y = A = Y1
7485               
7486               LI15:
7487                                                                          ; By this point we know the line is vertical-ish and
7488                                                                          ; Y1 >= Y2, so we're going from top to bottom as we go
7489                                                                          ; from Y1 to Y2
7490 245C 0910  18        srl  ra,1                       ; LSR A             ; Set A = Y1 / 8, so A now contains the character row
7491 245E 0910  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7492 2460 0910  18        srl  ra,1                       ; LSR A
7493               
7494 2462 0260  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     2464 6000     
7495                                                                          ; us the screen address of the character row (as each
7496                                                                          ; character row takes up 256 bytes, and the first
7497                                                                          ; character row is at screen address &6000, or page &60)
7498               
7499 2466 D800  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     2468 0008     
7500                                                                          ; the high byte of SC is set correctly for drawing the
7501                                                                          ; start of our line
7502               
7503 246A D001  18        movb rx,ra                      ; TXA               ; Set A = bits 3-7 of X1
7504 246C 0240  22        andi ra,>f8*256                 ; AND #%11111000
     246E F800     
7505               
7506 2470 D800  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     2472 0007     
7507                                                                          ; screen address of the far left end (x-coordinate = 0)
7508                                                                          ; of the horizontal pixel row that we want to draw the
7509                                                                          ; start of our line on
7510               
7511 2474 D001  18        movb rx,ra                      ; TXA               ; Set X = X1 mod 8, which is the horizontal pixel number
7512 2476 0240  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     2478 0700     
7513 247A D040  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
7514                                                                          ; wide)
7515               
7516 247C D021  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS where pixel X is set,
     247E 2239     
7517 2480 D800  30        movb ra,@R                      ; STA R             ; and store it in R
     2482 0091     
7518               
7519 2484 D020  30        movb @Y1,ra                     ; LDA Y1            ; Set Y = Y1 mod 8, which is the pixel row within the
     2486 0032     
7520 2488 0240  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw the start of
     248A 0700     
7521 248C D080  18        movb ra,ry                      ; TAY               ; our line (as each character block has 8 rows)
7522               
7523                                                                          ; The following calculates:
7524                                                                          ;
7525                                                                          ; P = P / Q
7526                                                                          ; = |delta_x| / |delta_y|
7527                                                                          ;
7528                                                                          ; using the same shift-and-subtract algorithm
7529                                                                          ; documented in TIS2
7530               
7531 248E D020  30        movb @P,ra                      ; LDA P             ; Set A = |delta_x|
     2490 001B     
7532               
7533 2492 0201  20        li   rx,>01*256                 ; LDX #1            ; Set Q to have bits 1-7 clear, so we can rotate through
     2494 0100     
7534 2496 D801  30        movb rx,@P                      ; STX P             ; 7 loop iterations, getting a 1 each time, and then
     2498 001B     
7535                                                                          ; getting a 1 on the 8th iteration... and we can also
7536                                                                          ; use P to catch our result bits into bit 0 each time
7537               
7538               LIL4:
7539                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 249A 0240  22        andi ra,>ff00
     249C FF00     
0002 249E 0A10  18        sla  ra,1
                   < elite.a99
7540               
7541 24A0 1803  14        joc  LI13                       ; BCS LI13          ; If bit 7 of A was set, then jump straight to the
7542                                                                          ; subtraction
7543               
7544 24A2 9020  30        cb   @Q,ra                      ; CMP Q             ; If A < Q, skip the following subtraction
     24A4 0090     
7545 24A6 1705  14        jnc  LI14                       ; BCC LI14
7546               
7547               LI13:
7548                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 24A8 1801  14        joc  !
0002 24AA 7004  18        sb   rone,ra
0003               !:
0004 24AC 7020  30        sb   @Q,ra
     24AE 0090     
                   < elite.a99
7549               
7550                      .sec                            ; SEC               ; Set the C flag to rotate into the result in Q
     **** ****     > SEC
0001 24B0 0A15  18        sla  rmone,1
                   < elite.a99
7551               
7552               LI14:
7553 24B2 0208  20        li   rarg1,P                    ; ROL P             ; Rotate the counter in P to the left, and catch the
     24B4 001B     
7554 24B6 06A0  28        bl   @rol                       ;
     24B8 8028     
7555                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
7556                                                                          ; do the subtraction, or 1 if we did)
7557               
7558 24BA 17EF  14        jnc  LIL4                       ; BCC LIL4          ; If we still have set bits in P, loop back to TIL2 to
7559                                                                          ; do the next iteration of 7
7560               
7561                                                                          ; We now have:
7562                                                                          ;
7563                                                                          ; P = A / Q
7564                                                                          ; = |delta_x| / |delta_y|
7565                                                                          ;
7566                                                                          ; and the C flag is set
7567               
7568 24BC D060  30        movb @Q,rx                      ; LDX Q             ; Set X = Q + 1
     24BE 0090     
7569 24C0 B044  18        ab   rone,rx                    ; INX               ; = |delta_y| + 1
7570                                                                          ;
7571                                                                          ; We add 1 so we can skip the first pixel plot if the
7572                                                                          ; line is being drawn with swapped coordinates
7573               
7574 24C2 D020  30        movb @X2,ra                     ; LDA X2            ; Set A = X2 - X1 (the C flag is set as we didn't take
     24C4 0033     
7575                      .sbc @X1,ra                     ; SBC X1            ; the above BCC)
     **** ****     > SBC
0001 24C6 1801  14        joc  !
0002 24C8 7004  18        sb   rone,ra
0003               !:
0004 24CA 7020  30        sb   @X1,ra
     24CC 0031     
                   < elite.a99
7576               
7577 24CE 1737  14        jnc  LFT                        ; BCC LFT           ; If X2 < X1 then jump to LFT, as we need to draw the
7578                                                                          ; line to the left and down
7579               
7580               * ******************************************************************************
7581               *
7582               * Name: LOIN (Part 6 of 7)
7583               * Type: Subroutine
7584               * Category: Drawing lines
7585               * Summary: Draw a steep line going up and left or down and right
7586               * Deep dive: Bresenham's line algorithm
7587               *
7588               * ------------------------------------------------------------------------------
7589               *
7590               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7591               * If we get here, then:
7592               *
7593               * * The line is going up and left (no swap) or down and right (swap)
7594               *
7595               * * X1 < X2 and Y1 >= Y2
7596               *
7597               * * Draw from (X1, Y1) at top left to (X2, Y2) at bottom right, omitting the
7598               * first pixel
7599               *
7600               * ******************************************************************************
7601               
7602                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 24D0 0A13  18        sla  rzero,1
                   < elite.a99
7603               
7604 24D2 D020  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     24D4 00A1     
7605 24D6 130D  14        jeq  LI17                       ; BEQ LI17          ; so jump down to LI17 to skip plotting the first pixel
7606               
7607 24D8 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7608                                                                          ; the first pixel
7609               
7610               LIL5:
7611                                                                          ; We now loop along the line from left to right, using X
7612                                                                          ; as a decreasing counter, and at each count we plot a
7613                                                                          ; single pixel using the pixel mask in R
7614 24DA D020  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     24DC 0091     
7615               
7616                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 24DE D1A0  30        movb @SC,rtmp
     24E0 0007     
0002 24E2 2806  18        xor  rtmp,ra
                   < elite.a99
7617                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 24E4 D820  42        movb @SC,@rtmplb
     24E6 0007     
     24E8 830D     
0002 24EA D1A0  30        movb @SC+1,rtmp
     24EC 0008     
0003 24EE A182  18        a    ry,rtmp
0004 24F0 D580  30        movb RA,*rtmp
                   < elite.a99
7618               
7619               LI17:
7620 24F2 7084  18        sb   rone,ry                    ; DEY               ; Decrement Y to step up along the y-axis
7621               
7622 24F4 1503  14        jgt  LI16                       ; BPL LI16          ; If Y is positive we are still within the same
7623                                                                          ; character block, so skip to LI16
7624               
7625 24F6 7004  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7626 24F8 0202  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     24FA 0700     
7627                                                                          ; address and set the pixel line to the last line in
7628                                                                          ; that character block
7629               
7630               LI16:
7631 24FC D020  30        movb @S,ra                      ; LDA S             ; Set S = S + P to update the slope error
     24FE 0092     
7632                      .adc @P,ra                      ; ADC P
     **** ****     > ADC
0001 2500 1701  14        jnc  !
0002 2502 B004  18        ab   rone,ra
0003               !:
0004 2504 B020  30        ab   @P,ra
     2506 001B     
                   < elite.a99
7633 2508 D800  30        movb ra,@S                      ; STA S
     250A 0092     
7634               
7635 250C 1712  14        jnc  LIC5                       ; BCC LIC5          ; If the addition didn't overflow, jump to LIC5
7636               
7637                      .lsr @R                         ; LSR R             ; Otherwise we just overflowed, so shift the single
     **** ****     > LSR
0001 250E D1A0  30        movb @R,rtmp
     2510 0091     
0002 2512 0916  18        srl  rtmp,1
0003 2514 D806  30        movb rtmp,@R
     2516 0091     
                   < elite.a99
7638                                                                          ; pixel in R to the right, so the next pixel we plot
7639                                                                          ; will be at the next x-coordinate along
7640               
7641 2518 170C  14        jnc  LIC5                       ; BCC LIC5          ; If the pixel didn't fall out of the right end of R
7642                                                                          ; into the C flag, then jump to LIC5
7643               
7644 251A 0208  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     251C 0091     
7645 251E 06A0  28        bl   @ror                       ;
     2520 8054     
7646                                                                          ; block, so first rotate R right so the set C flag goes
7647                                                                          ; back into the left end, giving %10000000
7648               
7649 2522 D020  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     2524 0007     
7650                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 2526 1701  14        jnc  !
0002 2528 B004  18        ab   rone,ra
0003               !:
0004 252A 0220  22        ai   ra,(>08*256)
     252C 0800     
                   < elite.a99
7651 252E D800  30        movb ra,@SC                     ; STA SC
     2530 0007     
7652               
7653               LIC5:
7654 2532 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7655               
7656 2534 16D2  14        jne  LIL5                       ; BNE LIL5          ; If we haven't yet reached the right end of the line,
7657                                                                          ; loop back to LIL5 to plot the next pixel along
7658               
7659 2536 D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2538 0094     
7660               
7661 253A 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     253C 800E     
7662               
7663               * ******************************************************************************
7664               *
7665               * Name: LOIN (Part 7 of 7)
7666               * Type: Subroutine
7667               * Category: Drawing lines
7668               * Summary: Draw a steep line going up and right or down and left
7669               * Deep dive: Bresenham's line algorithm
7670               *
7671               * ------------------------------------------------------------------------------
7672               *
7673               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7674               * If we get here, then:
7675               *
7676               * * The line is going up and right (no swap) or down and left (swap)
7677               *
7678               * * X1 >= X2 and Y1 >= Y2
7679               *
7680               * * Draw from (X1, Y1) at bottom left to (X2, Y2) at top right, omitting the
7681               * first pixel
7682               *
7683               * ------------------------------------------------------------------------------
7684               *
7685               * Other entry points:
7686               *
7687               * HL6                 Contains an RTS
7688               *
7689               * ******************************************************************************
7690               
7691               LFT:
7692 253E D020  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     2540 00A1     
7693 2542 130D  14        jeq  LI18                       ; BEQ LI18          ; so jump down to LI18 to skip plotting the first pixel
7694               
7695 2544 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7696                                                                          ; the first pixel
7697               
7698               LIL6:
7699 2546 D020  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     2548 0091     
7700               
7701                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 254A D1A0  30        movb @SC,rtmp
     254C 0007     
0002 254E 2806  18        xor  rtmp,ra
                   < elite.a99
7702                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 2550 D820  42        movb @SC,@rtmplb
     2552 0007     
     2554 830D     
0002 2556 D1A0  30        movb @SC+1,rtmp
     2558 0008     
0003 255A A182  18        a    ry,rtmp
0004 255C D580  30        movb RA,*rtmp
                   < elite.a99
7703               
7704               LI18:
7705 255E 7084  18        sb   rone,ry                    ; DEY               ; Decrement Y to step up along the y-axis
7706               
7707 2560 1503  14        jgt  LI19                       ; BPL LI19          ; If Y is positive we are still within the same
7708                                                                          ; character block, so skip to LI19
7709               
7710 2562 7004  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7711 2564 0202  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     2566 0700     
7712                                                                          ; address and set the pixel line to the last line in
7713                                                                          ; that character block
7714               
7715               LI19:
7716 2568 D020  30        movb @S,ra                      ; LDA S             ; Set S = S + P to update the slope error
     256A 0092     
7717                      .adc @P,ra                      ; ADC P
     **** ****     > ADC
0001 256C 1701  14        jnc  !
0002 256E B004  18        ab   rone,ra
0003               !:
0004 2570 B020  30        ab   @P,ra
     2572 001B     
                   < elite.a99
7718 2574 D800  30        movb ra,@S                      ; STA S
     2576 0092     
7719               
7720 2578 1715  14        jnc  LIC6                       ; BCC LIC6          ; If the addition didn't overflow, jump to LIC6
7721               
7722                      .asl @R                         ; ASL R             ; Otherwise we just overflowed, so shift the single
     **** ****     > ASL
0001 257A D1A0  30        movb @R,rtmp
     257C 0091     
0002 257E 0246  22        andi rtmp,>ff00
     2580 FF00     
0003 2582 0A16  18        sla  rtmp,1
0004 2584 D806  30        movb rtmp,@R
     2586 0091     
                   < elite.a99
7723                                                                          ; pixel in R to the left, so the next pixel we plot
7724                                                                          ; will be at the previous x-coordinate
7725               
7726 2588 170D  14        jnc  LIC6                       ; BCC LIC6          ; If the pixel didn't fall out of the left end of R
7727                                                                          ; into the C flag, then jump to LIC6
7728               
7729 258A 0208  20        li   rarg1,R                    ; ROL R             ; Otherwise we need to move over to the next character
     258C 0091     
7730 258E 06A0  28        bl   @rol                       ;
     2590 8028     
7731                                                                          ; block, so first rotate R left so the set C flag goes
7732                                                                          ; back into the right end, giving %0000001
7733               
7734 2592 D020  30        movb @SC,ra                     ; LDA SC            ; Subtract 7 from SC, so SC(1 0) now points to the
     2594 0007     
7735                      .sbi (>07*256)                  ; SBC #7            ; previous character along to the left
     **** ****     > SBI
0001 2596 1801  14        joc  !
0002 2598 7004  18        sb   rone,ra
0003               !:
0004 259A 0220  22        ai   ra,-(>07*256)
     259C F900     
                   < elite.a99
7736 259E D800  30        movb ra,@SC                     ; STA SC
     25A0 0007     
7737               
7738                      .clc                            ; CLC               ; Clear the C flag so it doesn't affect the additions
     **** ****     > CLC
0001 25A2 0A13  18        sla  rzero,1
                   < elite.a99
7739                                                                          ; below
7740               
7741               LIC6:
7742 25A4 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7743               
7744 25A6 16CF  14        jne  LIL6                       ; BNE LIL6          ; If we haven't yet reached the left end of the line,
7745                                                                          ; loop back to LIL6 to plot the next pixel along
7746               
7747 25A8 D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     25AA 0094     
7748               
7749               HL6:
7750 25AC 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     25AE 800E     
7751               
7752               * ******************************************************************************
7753               *
7754               * Name: NLIN3
7755               * Type: Subroutine
7756               * Category: Drawing lines
7757               * Summary: Print a title and draw a horizontal line at row 19 to box it in
7758               *
7759               * ------------------------------------------------------------------------------
7760               *
7761               * This routine print a text token at the cursor position and draws a horizontal
7762               * line at pixel row 19. It is used for the Status Mode screen, the Short-range
7763               * Chart, the Market Price screen and the Equip Ship screen.
7764               *
7765               * ******************************************************************************
7766               
7767               NLIN3:
7768 25B0 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     25B2 66DC     
7769 25B4 06A0  28        bl   @jsr                       ;
     25B6 8002     
7770               
7771                                                                          ; Fall through into NLIN4 to draw a horizontal line at
7772                                                                          ; pixel row 19
7773               
7774               * ******************************************************************************
7775               *
7776               * Name: NLIN4
7777               * Type: Subroutine
7778               * Category: Drawing lines
7779               * Summary: Draw a horizontal line at pixel row 19 to box in a title
7780               *
7781               * ------------------------------------------------------------------------------
7782               *
7783               * This routine is used on the Inventory screen to draw a horizontal line at
7784               * pixel row 19 to box in the title.
7785               *
7786               * ******************************************************************************
7787               
7788               NLIN4:
7789 25B8 0200  20        li   ra,>13*256                 ; LDA #19           ; Jump to NLIN2 to draw a horizontal line at pixel row
     25BA 1300     
7790 25BC 1603  14        jne  NLIN2                      ; BNE NLIN2         ; 19, returning from the subroutine with using a tail
7791                                                                          ; call (this BNE is effectively a JMP as A will never
7792                                                                          ; be zero)
7793               
7794               * ******************************************************************************
7795               *
7796               * Name: NLIN
7797               * Type: Subroutine
7798               * Category: Drawing lines
7799               * Summary: Draw a horizontal line at pixel row 23 to box in a title
7800               *
7801               * ------------------------------------------------------------------------------
7802               *
7803               * Draw a horizontal line at pixel row 23 and move the text cursor down one
7804               * line.
7805               *
7806               * ******************************************************************************
7807               
7808               NLIN:
7809 25BE 0200  20        li   ra,>17*256                 ; LDA #23           ; Set A = 23 so NLIN2 below draws a horizontal line at
     25C0 1700     
7810                                                                          ; pixel row 23
7811               
7812 25C2 B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
7813               
7814                                                                          ; Fall through into NLIN2 to draw the horizontal line
7815                                                                          ; at row 23
7816               
7817               * ******************************************************************************
7818               *
7819               * Name: NLIN2
7820               * Type: Subroutine
7821               * Category: Drawing lines
7822               * Summary: Draw a screen-wide horizontal line at the pixel row in A
7823               *
7824               * ------------------------------------------------------------------------------
7825               *
7826               * This draws a line from (2, A) to (254, A), which is almost screen-wide and
7827               * fits in nicely between the white borders without clashing with it.
7828               *
7829               * ------------------------------------------------------------------------------
7830               *
7831               * Arguments:
7832               *
7833               * A                   The pixel row on which to draw the horizontal line
7834               *
7835               * ******************************************************************************
7836               
7837               NLIN2:
7838 25C4 D800  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 = A
     25C6 0032     
7839               
7840 25C8 0201  20        li   rx,>02*256                 ; LDX #2            ; Set X1 = 2, so (X1, Y1) = (2, A)
     25CA 0200     
7841 25CC D801  30        movb rx,@X1                     ; STX X1
     25CE 0031     
7842               
7843 25D0 0201  20        li   rx,>fe*256                 ; LDX #254          ; Set X2 = 254, so (X2, Y2) = (254, A)
     25D2 FE00     
7844 25D4 D801  30        movb rx,@X2                     ; STX X2
     25D6 0033     
7845               
7846 25D8 160A  14        jne  HLOIN                      ; BNE HLOIN         ; Call HLOIN to draw a horizontal line from (2, A) to
7847                                                                          ; (254, A) and return from the subroutine (this BNE is
7848                                                                          ; effectively a JMP as A will never be zero)
7849               
7850               * ******************************************************************************
7851               *
7852               * Name: HLOIN2
7853               * Type: Subroutine
7854               * Category: Drawing lines
7855               * Summary: Remove a line from the sun line heap and draw it on-screen
7856               *
7857               * ------------------------------------------------------------------------------
7858               *
7859               * Specifically, this does the following:
7860               *
7861               * * Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
7862               * centre YY(1 0) and length A to the left and right
7863               *
7864               * * Set the Y-th byte of the LSO block to 0 (i.e. remove this line from the
7865               * sun line heap)
7866               *
7867               * * Draw a horizontal line from (X1, Y) to (X2, Y)
7868               *
7869               * ------------------------------------------------------------------------------
7870               *
7871               * Arguments:
7872               *
7873               * YY(1 0)             The x-coordinate of the centre point of the line
7874               *
7875               * A                   The half-width of the line, i.e. the contents of the
7876               * Y-th byte of the sun line heap
7877               *
7878               * Y                   The number of the entry in the sun line heap (which is
7879               * also the y-coordinate of the line)
7880               *
7881               * ------------------------------------------------------------------------------
7882               *
7883               * Returns:
7884               *
7885               * Y                   Y is preserved
7886               *
7887               * ******************************************************************************
7888               
7889               HLOIN2:
7890 25DA 0206  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     25DC 79A6     
7891 25DE 06A0  28        bl   @jsr                       ;
     25E0 8002     
7892                                                                          ; line centred on YY(1 0) and with half-width A
7893               
7894 25E2 D802  30        movb ry,@Y1                     ; STY Y1            ; Set Y1 = Y
     25E4 0032     
7895               
7896 25E6 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the Y-th byte of the LSO block to 0
     25E8 0000     
7897 25EA D880  38        movb ra,@LSO(ry)                ; STA LSO,Y
     25EC 0D66     
7898               
7899                                                                          ; Fall through into HLOIN to draw a horizontal line from
7900                                                                          ; (X1, Y) to (X2, Y)
7901               
7902               * ******************************************************************************
7903               *
7904               * Name: HLOIN
7905               * Type: Subroutine
7906               * Category: Drawing lines
7907               * Summary: Draw a horizontal line from (X1, Y1) to (X2, Y1)
7908               * Deep dive: Drawing monochrome pixels in mode 4
7909               *
7910               * ------------------------------------------------------------------------------
7911               *
7912               * We do not draw a pixel at the right end of the line.
7913               *
7914               * To understand how this routine works, you might find it helpful to read the
7915               * deep dive on "Drawing monochrome pixels in mode 4".
7916               *
7917               * ------------------------------------------------------------------------------
7918               *
7919               * Returns:
7920               *
7921               * Y                   Y is preserved
7922               *
7923               * ******************************************************************************
7924               
7925               HLOIN:
7926 25EE D802  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y into YSAV, so we can preserve it across the
     25F0 0094     
7927                                                                          ; call to this subroutine
7928               
7929 25F2 D060  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     25F4 0031     
7930               
7931 25F6 9060  30        cb   @X2,rx                     ; CPX X2            ; If X1 = X2 then the start and end points are the same,
     25F8 0033     
7932 25FA 13D8  14        jeq  HL6                        ; BEQ HL6           ; so return from the subroutine (as HL6 contains an RTS)
7933               
7934 25FC 1707  14        jnc  HL5                        ; BCC HL5           ; If X1 < X2, jump to HL5 to skip the following code, as
7935                                                                          ; (X1, Y1) is already the left point
7936               
7937 25FE D020  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2, so we know that (X1, Y1)
     2600 0033     
7938 2602 D800  30        movb ra,@X1                     ; STA X1            ; is on the left and (X2, Y1) is on the right
     2604 0031     
7939 2606 D801  30        movb rx,@X2                     ; STX X2
     2608 0033     
7940               
7941 260A D040  18        movb ra,rx                      ; TAX               ; Set X = X1
7942               
7943               HL5:
7944 260C 7004  18        sb   rone,ra                    ; DEC X2            ; Decrement X2 so we do not draw a pixel at the end
7945                                                                          ; point
7946               
7947 260E D020  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 / 8, so A now contains the character row
     2610 0032     
7948 2612 0910  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7949 2614 0910  18        srl  ra,1                       ; LSR A
7950 2616 0910  18        srl  ra,1                       ; LSR A
7951               
7952 2618 0260  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     261A 6000     
7953                                                                          ; us the screen address of the character row (as each
7954                                                                          ; character row takes up 256 bytes, and the first
7955                                                                          ; character row is at screen address &6000, or page &60)
7956               
7957 261C D800  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     261E 0008     
7958                                                                          ; the high byte of SC is set correctly for drawing our
7959                                                                          ; line
7960               
7961 2620 D020  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 mod 8, which is the pixel row within the
     2622 0032     
7962 2624 0240  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw our line (as
     2626 0700     
7963                                                                          ; each character block has 8 rows)
7964               
7965 2628 D800  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     262A 0007     
7966                                                                          ; screen address of the far left end (x-coordinate = 0)
7967                                                                          ; of the horizontal pixel row that we want to draw our
7968                                                                          ; horizontal line on
7969               
7970 262C D001  18        movb rx,ra                      ; TXA               ; Set Y = bits 3-7 of X1
7971 262E 0240  22        andi ra,>f8*256                 ; AND #%11111000
     2630 F800     
7972 2632 D080  18        movb ra,ry                      ; TAY
7973               
7974               HL1:
7975 2634 D001  18        movb rx,ra                      ; TXA               ; Set T = bits 3-7 of X1, which will contain the
7976 2636 0240  22        andi ra,>f8*256                 ; AND #%11111000    ; character number of the start of the line * 8
     2638 F800     
7977 263A D800  30        movb ra,@T                      ; STA T
     263C 00D1     
7978               
7979 263E D020  30        movb @X2,ra                     ; LDA X2            ; Set A = bits 3-7 of X2, which will contain the
     2640 0033     
7980 2642 0240  22        andi ra,>f8*256                 ; AND #%11111000    ; character number of the end of the line * 8
     2644 F800     
7981               
7982                      .sec                            ; SEC               ; Set A = A - T, which will contain the number of
     **** ****     > SEC
0001 2646 0A15  18        sla  rmone,1
                   < elite.a99
7983                      .sbc @T,ra                      ; SBC T             ; character blocks we need to fill - 1 * 8
     **** ****     > SBC
0001 2648 1801  14        joc  !
0002 264A 7004  18        sb   rone,ra
0003               !:
0004 264C 7020  30        sb   @T,ra
     264E 00D1     
                   < elite.a99
7984               
7985 2650 134A  14        jeq  HL2                        ; BEQ HL2           ; If A = 0 then the start and end character blocks are
7986                                                                          ; the same, so the whole line fits within one block, so
7987                                                                          ; jump down to HL2 to draw the line
7988               
7989                                                                          ; Otherwise the line spans multiple characters, so we
7990                                                                          ; start with the left character, then do any characters
7991                                                                          ; in the middle, and finish with the right character
7992               
7993 2652 0910  18        srl  ra,1                       ; LSR A             ; Set R = A / 8, so R now contains the number of
7994 2654 0910  18        srl  ra,1                       ; LSR A             ; character blocks we need to fill - 1
7995 2656 0910  18        srl  ra,1                       ; LSR A
7996 2658 D800  30        movb ra,@R                      ; STA R
     265A 0091     
7997               
7998 265C D020  30        movb @X1,ra                     ; LDA X1            ; Set X = X1 mod 8, which is the horizontal pixel number
     265E 0031     
7999 2660 0240  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     2662 0700     
8000 2664 D040  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
8001                                                                          ; wide)
8002               
8003 2666 D021  34        movb @TWFR(rx),ra               ; LDA TWFR,X        ; Fetch a ready-made byte with X pixels filled in at the
     2668 2731     
8004                                                                          ; right end of the byte (so the filled pixels start at
8005                                                                          ; point X and go all the way to the end of the byte),
8006                                                                          ; which is the shape we want for the left end of the
8007                                                                          ; line
8008               
8009                      .eor @SC                        ; EOR (SC),Y        ; Store this into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 266A D1A0  30        movb @SC,rtmp
     266C 0007     
0002 266E 2806  18        xor  rtmp,ra
                   < elite.a99
8010                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen,
     **** ****     > ST_IND_Y_IDX
0001 2670 D820  42        movb @SC,@rtmplb
     2672 0007     
     2674 830D     
0002 2676 D1A0  30        movb @SC+1,rtmp
     2678 0008     
0003 267A A182  18        a    ry,rtmp
0004 267C D580  30        movb RA,*rtmp
                   < elite.a99
8011                                                                          ; so we have now drawn the line's left cap
8012               
8013 267E D002  18        movb ry,ra                      ; TYA               ; Set Y = Y + 8 so (SC),Y points to the next character
8014                      .adi (>08*256)                  ; ADC #8            ; block along, on the same pixel row as before
     **** ****     > ADI
0001 2680 1701  14        jnc  !
0002 2682 B004  18        ab   rone,ra
0003               !:
0004 2684 0220  22        ai   ra,(>08*256)
     2686 0800     
                   < elite.a99
8015 2688 D080  18        movb ra,ry                      ; TAY
8016               
8017 268A D060  30        movb @R,rx                      ; LDX R             ; Fetch the number of character blocks we need to fill
     268C 0091     
8018                                                                          ; from R
8019               
8020 268E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the number of character blocks in X
8021               
8022 2690 1315  14        jeq  HL3                        ; BEQ HL3           ; If X = 0 then we only have the last block to do (i.e.
8023                                                                          ; the right cap), so jump down to HL3 to draw it
8024               
8025                      .clc                            ; CLC               ; Otherwise clear the C flag so we can do some additions
     **** ****     > CLC
0001 2692 0A13  18        sla  rzero,1
                   < elite.a99
8026                                                                          ; while we draw the character blocks with full-width
8027                                                                          ; lines in them
8028               
8029               HLL1:
8030 2694 0200  20        li   ra,>ff*256                 ; LDA #%11111111    ; Store a full-width 8-pixel horizontal line in SC(1 0)
     2696 FF00     
8031                      .eor @SC                        ; EOR (SC),Y        ; so that it draws the line on-screen, using EOR logic
     **** ****     > EOR
0001 2698 D1A0  30        movb @SC,rtmp
     269A 0007     
0002 269C 2806  18        xor  rtmp,ra
                   < elite.a99
8032                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 269E D820  42        movb @SC,@rtmplb
     26A0 0007     
     26A2 830D     
0002 26A4 D1A0  30        movb @SC+1,rtmp
     26A6 0008     
0003 26A8 A182  18        a    ry,rtmp
0004 26AA D580  30        movb RA,*rtmp
                   < elite.a99
8033               
8034 26AC D002  18        movb ry,ra                      ; TYA               ; Set Y = Y + 8 so (SC),Y points to the next character
8035                      .adi (>08*256)                  ; ADC #8            ; block along, on the same pixel row as before
     **** ****     > ADI
0001 26AE 1701  14        jnc  !
0002 26B0 B004  18        ab   rone,ra
0003               !:
0004 26B2 0220  22        ai   ra,(>08*256)
     26B4 0800     
                   < elite.a99
8036 26B6 D080  18        movb ra,ry                      ; TAY
8037               
8038 26B8 7044  18        sb   rone,rx                    ; DEX               ; Decrement the number of character blocks in X
8039               
8040 26BA 16EC  14        jne  HLL1                       ; BNE HLL1          ; Loop back to draw more full-width lines, if we have
8041                                                                          ; any more to draw
8042               
8043               HL3:
8044 26BC D020  30        movb @X2,ra                     ; LDA X2            ; Now to draw the last character block at the right end
     26BE 0033     
8045 26C0 0240  22        andi ra,>07*256                 ; AND #7            ; of the line, so set X = X2 mod 8, which is the
     26C2 0700     
8046 26C4 D040  18        movb ra,rx                      ; TAX               ; horizontal pixel number where the line ends
8047               
8048 26C6 D021  34        movb @TWFL(rx),ra               ; LDA TWFL,X        ; Fetch a ready-made byte with X pixels filled in at the
     26C8 272A     
8049                                                                          ; left end of the byte (so the filled pixels start at
8050                                                                          ; the left edge and go up to point X), which is the
8051                                                                          ; shape we want for the right end of the line
8052               
8053                      .eor @SC                        ; EOR (SC),Y        ; Store this into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 26CA D1A0  30        movb @SC,rtmp
     26CC 0007     
0002 26CE 2806  18        xor  rtmp,ra
                   < elite.a99
8054                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen,
     **** ****     > ST_IND_Y_IDX
0001 26D0 D820  42        movb @SC,@rtmplb
     26D2 0007     
     26D4 830D     
0002 26D6 D1A0  30        movb @SC+1,rtmp
     26D8 0008     
0003 26DA A182  18        a    ry,rtmp
0004 26DC D580  30        movb RA,*rtmp
                   < elite.a99
8055                                                                          ; so we have now drawn the line's right cap
8056               
8057 26DE D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved across the
     26E0 0094     
8058                                                                          ; call to this subroutine
8059               
8060 26E2 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     26E4 800E     
8061               
8062               HL2:
8063                                                                          ; If we get here then the entire horizontal line fits
8064                                                                          ; into one character block
8065 26E6 D020  30        movb @X1,ra                     ; LDA X1            ; Set X = X1 mod 8, which is the horizontal pixel number
     26E8 0031     
8066 26EA 0240  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     26EC 0700     
8067 26EE D040  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
8068                                                                          ; wide)
8069               
8070 26F0 D021  34        movb @TWFR(rx),ra               ; LDA TWFR,X        ; Fetch a ready-made byte with X pixels filled in at the
     26F2 2731     
8071 26F4 D800  30        movb ra,@T                      ; STA T             ; right end of the byte (so the filled pixels start at
     26F6 00D1     
8072                                                                          ; point X and go all the way to the end of the byte)
8073               
8074 26F8 D020  30        movb @X2,ra                     ; LDA X2            ; Set X = X2 mod 8, which is the horizontal pixel number
     26FA 0033     
8075 26FC 0240  22        andi ra,>07*256                 ; AND #7            ; where the line ends
     26FE 0700     
8076 2700 D040  18        movb ra,rx                      ; TAX
8077               
8078 2702 D021  34        movb @TWFL(rx),ra               ; LDA TWFL,X        ; Fetch a ready-made byte with X pixels filled in at the
     2704 272A     
8079                                                                          ; left end of the byte (so the filled pixels start at
8080                                                                          ; the left edge and go up to point X)
8081               
8082                      .and @T                         ; AND T             ; We now have two bytes, one (T) containing pixels from
     **** ****     > AND
0001 2706 D1A0  30        movb @T,rtmp
     2708 00D1     
0002 270A 0546  14        inv  rtmp
0003 270C 5006  18        szcb rtmp,ra
                   < elite.a99
8083                                                                          ; the starting point X1 onwards, and the other (A)
8084                                                                          ; containing pixels up to the end point at X2, so we can
8085                                                                          ; get the actual line we want to draw by AND'ing them
8086                                                                          ; together. For example, if we want to draw a line from
8087                                                                          ; point 2 to point 5 (within the row of 8 pixels
8088                                                                          ; numbered from 0 to 7), we would have this:
8089                                                                          ;
8090                                                                          ; T       = %00111111
8091                                                                          ; A       = %11111100
8092                                                                          ; T AND A = %00111100
8093                                                                          ;
8094                                                                          ; So we can stick T AND A in screen memory to get the
8095                                                                          ; line we want, which is what we do here by setting
8096                                                                          ; A = A AND T
8097               
8098                      .eor @SC                        ; EOR (SC),Y        ; Store our horizontal line byte into screen memory at
     **** ****     > EOR
0001 270E D1A0  30        movb @SC,rtmp
     2710 0007     
0002 2712 2806  18        xor  rtmp,ra
                   < elite.a99
8099                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; SC(1 0), using EOR logic so it merges with whatever is
     **** ****     > ST_IND_Y_IDX
0001 2714 D820  42        movb @SC,@rtmplb
     2716 0007     
     2718 830D     
0002 271A D1A0  30        movb @SC+1,rtmp
     271C 0008     
0003 271E A182  18        a    ry,rtmp
0004 2720 D580  30        movb RA,*rtmp
                   < elite.a99
8100                                                                          ; already on-screen
8101               
8102 2722 D0A0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2724 0094     
8103               
8104 2726 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     2728 800E     
8105               
8106               * ******************************************************************************
8107               *
8108               * Name: TWFL
8109               * Type: Variable
8110               * Category: Drawing lines
8111               * Summary: Ready-made character rows for the left end of a horizontal line in
8112               * mode 4
8113               *
8114               * ------------------------------------------------------------------------------
8115               *
8116               * Ready-made bytes for plotting horizontal line end caps in mode 4 (the top part
8117               * of the split screen). This table provides a byte with pixels at the left end,
8118               * which is used for the right end of the line.
8119               *
8120               * See the HLOIN routine for details.
8121               *
8122               * ******************************************************************************
8123               
8124               TWFL:
8125 272A 80              byte >80
8126 272B   C0            byte >c0
8127 272C E0              byte >e0
8128 272D   F0            byte >f0
8129 272E F8              byte >f8
8130 272F   FC            byte >fc
8131 2730 FE              byte >fe
8132               
8133               * ******************************************************************************
8134               *
8135               * Name: TWFR
8136               * Type: Variable
8137               * Category: Drawing lines
8138               * Summary: Ready-made character rows for the right end of a horizontal line
8139               * in mode 4
8140               *
8141               * ------------------------------------------------------------------------------
8142               *
8143               * Ready-made bytes for plotting horizontal line end caps in mode 4 (the top part
8144               * of the split screen). This table provides a byte with pixels at the right end,
8145               * which is used for the left end of the line.
8146               *
8147               * See the HLOIN routine for details.
8148               *
8149               * ******************************************************************************
8150               
8151               TWFR:
8152 2731   FF            byte >ff
8153 2732 7F              byte >7f
8154 2733   3F            byte >3f
8155 2734 1F              byte >1f
8156 2735   0F            byte >0f
8157 2736 07              byte >07
8158 2737   03            byte >03
8159 2738 01              byte >01
8160               
8161               * ******************************************************************************
8162               *
8163               * Name: PX3
8164               * Type: Subroutine
8165               * Category: Drawing pixels
8166               * Summary: Plot a single pixel at (X, Y) within a character block
8167               *
8168               * ------------------------------------------------------------------------------
8169               *
8170               * This routine is called from PIXEL to set 1 pixel within a character block for
8171               * a distant point (i.e. where the distance ZZ >= &90). See the PIXEL routine for
8172               * details, as this routine is effectively part of PIXEL.
8173               *
8174               * ------------------------------------------------------------------------------
8175               *
8176               * Arguments:
8177               *
8178               * X                   The x-coordinate of the pixel within the character block
8179               *
8180               * Y                   The y-coordinate of the pixel within the character block
8181               *
8182               * SC(1 0)             The screen address of the character block
8183               *
8184               * T1                  The value of Y to restore on exit, so Y is preserved by
8185               * the call to PIXEL
8186               *
8187               * ******************************************************************************
8188               
8189               PX3:
8190 273A D021  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS and EOR it into SC+Y
     273C 2239     
8191                      .eor @SC                        ; EOR (SC),Y
     **** ****     > EOR
0001 273E D1A0  30        movb @SC,rtmp
     2740 0007     
0002 2742 2806  18        xor  rtmp,ra
                   < elite.a99
8192                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 2744 D820  42        movb @SC,@rtmplb
     2746 0007     
     2748 830D     
0002 274A D1A0  30        movb @SC+1,rtmp
     274C 0008     
0003 274E A182  18        a    ry,rtmp
0004 2750 D580  30        movb RA,*rtmp
                   < elite.a99
8193               
8194 2752 D0A0  30        movb @T1,ry                     ; LDY T1            ; Restore Y from T1, so Y is preserved by the routine
     2754 0006     
8195               
8196 2756 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     2758 800E     
8197               
8198               * ******************************************************************************
8199               *
8200               * Name: PIX1
8201               * Type: Subroutine
8202               * Category: Maths (Arithmetic)
8203               * Summary: Calculate (YY+1 SYL+Y) = (A P) + (S R) and draw stardust particle
8204               *
8205               * ------------------------------------------------------------------------------
8206               *
8207               * Calculate the following:
8208               *
8209               * (YY+1 SYL+Y) = (A P) + (S R)
8210               *
8211               * and draw a stardust particle at (X1,Y1) with distance ZZ.
8212               *
8213               * ------------------------------------------------------------------------------
8214               *
8215               * Arguments:
8216               *
8217               * (A P)               A is the angle ALPHA or BETA, P is always 0
8218               *
8219               * (S R)               YY(1 0) or YY(1 0) + Q * A
8220               *
8221               * Y                   Stardust particle number
8222               *
8223               * X1                  The x-coordinate offset
8224               *
8225               * Y1                  The y-coordinate offset
8226               *
8227               * ZZ                  The distance of the point (further away = smaller point)
8228               *
8229               * ******************************************************************************
8230               
8231               PIX1:
8232 275A 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     275C 44BA     
8233 275E 06A0  28        bl   @jsr                       ;
     2760 8002     
8234               
8235 2762 D800  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY+1 to A, the high byte of the result
     2764 0027     
8236               
8237 2766 D001  18        movb rx,ra                      ; TXA               ; Set SYL+Y to X, the low byte of the result
8238 2768 D880  38        movb ra,@SYL(ry)                ; STA SYL,Y
     276A 0ED5     
8239               
8240                                                                          ; Fall through into PIX1 to draw the stardust particle
8241                                                                          ; at (X1,Y1)
8242               
8243               * ******************************************************************************
8244               *
8245               * Name: PIXEL2
8246               * Type: Subroutine
8247               * Category: Drawing pixels
8248               * Summary: Draw a stardust particle relative to the screen centre
8249               *
8250               * ------------------------------------------------------------------------------
8251               *
8252               * Draw a point (X1, Y1) from the middle of the screen with a size determined by
8253               * a distance value. Used to draw stardust particles.
8254               *
8255               * ------------------------------------------------------------------------------
8256               *
8257               * Arguments:
8258               *
8259               * X1                  The x-coordinate offset
8260               *
8261               * Y1                  The y-coordinate offset (positive means up the screen
8262               * from the centre, negative means down the screen)
8263               *
8264               * ZZ                  The distance of the point (further away = smaller point)
8265               *
8266               * ******************************************************************************
8267               
8268               PIXEL2:
8269 276C D020  30        movb @X1,ra                     ; LDA X1            ; Fetch the x-coordinate offset into A
     276E 0031     
8270               
8271 2770 1508  14        jgt  PX1                        ; BPL PX1           ; If the x-coordinate offset is positive, jump to PX1
8272                                                                          ; to skip the following negation
8273               
8274                      .eoi (>7f*256)                  ; EOR #%01111111    ; The x-coordinate offset is negative, so flip all the
     **** ****     > EOI
0001 2772 0206  20        li   rtmp,(>7F*256)
     2774 7F00     
0002 2776 2806  18        xor  rtmp,ra
                   < elite.a99
8275                      .clc                            ; CLC               ; bits apart from the sign bit and add 1, to convert it
     **** ****     > CLC
0001 2778 0A13  18        sla  rzero,1
                   < elite.a99
8276                      .adi (>01*256)                  ; ADC #1            ; from a sign-magnitude number to a signed number
     **** ****     > ADI
0001 277A 1701  14        jnc  !
0002 277C B004  18        ab   rone,ra
0003               !:
0004 277E 0220  22        ai   ra,(>01*256)
     2780 0100     
                   < elite.a99
8277               
8278               PX1:
8279                      .eoi (>80*256)                  ; EOR #%10000000    ; Set X = X1 + 128
     **** ****     > EOI
0001 2782 0206  20        li   rtmp,(>80*256)
     2784 8000     
0002 2786 2806  18        xor  rtmp,ra
                   < elite.a99
8280 2788 D040  18        movb ra,rx                      ; TAX               ;
8281                                                                          ; So X is now the offset converted to an x-coordinate,
8282                                                                          ; centred on x-coordinate 128
8283               
8284 278A D020  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate offset into A and clear the
     278C 0032     
8285 278E 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; sign bit, so A = |Y1|
     2790 7F00     
8286               
8287 2792 0280  22        ci   ra,>60*256                 ; CMP #96           ; If |Y1| >= 96 then it's off the screen (as 96 is half
     2794 6000     
8288 2796 1851  14        joc  PX4                        ; BCS PX4           ; the screen height), so return from the subroutine (as
8289                                                                          ; PX4 contains an RTS)
8290               
8291 2798 D020  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate offset into A
     279A 0032     
8292               
8293 279C 1507  14        jgt  PX2                        ; BPL PX2           ; If the y-coordinate offset is positive, jump to PX2
8294                                                                          ; to skip the following negation
8295               
8296                      .eoi (>7f*256)                  ; EOR #%01111111    ; The y-coordinate offset is negative, so flip all the
     **** ****     > EOI
0001 279E 0206  20        li   rtmp,(>7F*256)
     27A0 7F00     
0002 27A2 2806  18        xor  rtmp,ra
                   < elite.a99
8297                      .adi (>01*256)                  ; ADC #1            ; bits apart from the sign bit and subtract 1, to negate
     **** ****     > ADI
0001 27A4 1701  14        jnc  !
0002 27A6 B004  18        ab   rone,ra
0003               !:
0004 27A8 0220  22        ai   ra,(>01*256)
     27AA 0100     
                   < elite.a99
8298                                                                          ; it to a positive number, i.e. A is now |Y1|
8299               
8300               PX2:
8301 27AC D800  30        movb ra,@T                      ; STA T             ; Set A = 97 - Y1
     27AE 00D1     
8302 27B0 0200  20        li   ra,>61*256                 ; LDA #97           ;
     27B2 6100     
8303                      .sbc @T,ra                      ; SBC T             ; So if Y is positive we display the point up from the
     **** ****     > SBC
0001 27B4 1801  14        joc  !
0002 27B6 7004  18        sb   rone,ra
0003               !:
0004 27B8 7020  30        sb   @T,ra
     27BA 00D1     
                   < elite.a99
8304                                                                          ; centre at y-coordinate 97, while a negative Y means
8305                                                                          ; down from the centre
8306               
8307                                                                          ; Fall through into PIXEL to draw the stardust at the
8308                                                                          ; screen coordinates in (X, A)
8309               
8310               * ******************************************************************************
8311               *
8312               * Name: PIXEL
8313               * Type: Subroutine
8314               * Category: Drawing pixels
8315               * Summary: Draw a 1-pixel dot, 2-pixel dash or 4-pixel square
8316               * Deep dive: Drawing monochrome pixels in mode 4
8317               *
8318               * ------------------------------------------------------------------------------
8319               *
8320               * Draw a point at screen coordinate (X, A) with the point size determined by the
8321               * distance in ZZ. This applies to the top part of the screen (the monochrome
8322               * mode 4 portion).
8323               *
8324               * ------------------------------------------------------------------------------
8325               *
8326               * Arguments:
8327               *
8328               * X                   The screen x-coordinate of the point to draw
8329               *
8330               * A                   The screen y-coordinate of the point to draw
8331               *
8332               * ZZ                  The distance of the point (further away = smaller point)
8333               *
8334               * ------------------------------------------------------------------------------
8335               *
8336               * Returns:
8337               *
8338               * Y                   Y is preserved
8339               *
8340               * ------------------------------------------------------------------------------
8341               *
8342               * Other entry points:
8343               *
8344               * PX4                 Contains an RTS
8345               *
8346               * ******************************************************************************
8347               
8348               PIXEL:
8349 27BC D802  30        movb ry,@T1                     ; STY T1            ; Store Y in T1
     27BE 0006     
8350               
8351 27C0 D080  18        movb ra,ry                      ; TAY               ; Copy A into Y, for use later
8352               
8353 27C2 0910  18        srl  ra,1                       ; LSR A             ; Set SCH = &60 + A >> 3
8354 27C4 0910  18        srl  ra,1                       ; LSR A
8355 27C6 0910  18        srl  ra,1                       ; LSR A
8356 27C8 0260  22        ori  ra,>60*256                 ; ORA #&60
     27CA 6000     
8357 27CC D800  30        movb ra,@SCH                    ; STA SCH
     27CE 0008     
8358               
8359 27D0 D001  18        movb rx,ra                      ; TXA               ; Set SC = (X >> 3) * 8
8360 27D2 0240  22        andi ra,>f8*256                 ; AND #%11111000
     27D4 F800     
8361 27D6 D800  30        movb ra,@SC                     ; STA SC
     27D8 0007     
8362               
8363 27DA D002  18        movb ry,ra                      ; TYA               ; Set Y = Y AND %111
8364 27DC 0240  22        andi ra,>07*256                 ; AND #%00000111
     27DE 0700     
8365 27E0 D080  18        movb ra,ry                      ; TAY
8366               
8367 27E2 D001  18        movb rx,ra                      ; TXA               ; Set X = X AND %111
8368 27E4 0240  22        andi ra,>07*256                 ; AND #%00000111
     27E6 0700     
8369 27E8 D040  18        movb ra,rx                      ; TAX
8370               
8371 27EA D020  30        movb @ZZ,ra                     ; LDA ZZ            ; If distance in ZZ >= 144, then this point is a very
     27EC 0097     
8372 27EE 0280  22        ci   ra,>90*256                 ; CMP #144          ; long way away, so jump to PX3 to fetch a 1-pixel point
     27F0 9000     
8373 27F2 18A3  14        joc  PX3                        ; BCS PX3           ; from TWOS and EOR it into SC+Y
8374               
8375 27F4 D021  34        movb @TWOS2(rx),ra              ; LDA TWOS2,X       ; Otherwise fetch a 2-pixel dash from TWOS2 and EOR it
     27F6 2241     
8376                      .eor @SC                        ; EOR (SC),Y        ; into SC+Y
     **** ****     > EOR
0001 27F8 D1A0  30        movb @SC,rtmp
     27FA 0007     
0002 27FC 2806  18        xor  rtmp,ra
                   < elite.a99
8377                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 27FE D820  42        movb @SC,@rtmplb
     2800 0007     
     2802 830D     
0002 2804 D1A0  30        movb @SC+1,rtmp
     2806 0008     
0003 2808 A182  18        a    ry,rtmp
0004 280A D580  30        movb RA,*rtmp
                   < elite.a99
8378               
8379 280C D020  30        movb @ZZ,ra                     ; LDA ZZ            ; If distance in ZZ >= 80, then this point is a medium
     280E 0097     
8380 2810 0280  22        ci   ra,>50*256                 ; CMP #80           ; distance away, so jump to PX13 to stop drawing, as a
     2812 5000     
8381 2814 1810  14        joc  PX13                       ; BCS PX13          ; 2-pixel dash is enough
8382               
8383                                                                          ; Otherwise we keep going to draw another 2 pixel point
8384                                                                          ; either above or below the one we just drew, to make a
8385                                                                          ; 4-pixel square
8386               
8387 2816 7084  18        sb   rone,ry                    ; DEY               ; Reduce Y by 1 to point to the pixel row above the one
8388 2818 1502  14        jgt  PX14                       ; BPL PX14          ; we just plotted, and if it is still positive, jump to
8389                                                                          ; PX14 to draw our second 2-pixel dash
8390               
8391 281A 0202  20        li   ry,>01*256                 ; LDY #1            ; Reducing Y by 1 made it negative, which means Y was
     281C 0100     
8392                                                                          ; 0 before we did the DEY above, so set Y to 1 to point
8393                                                                          ; to the pixel row after the one we just plotted
8394               
8395               PX14:
8396 281E D021  34        movb @TWOS2(rx),ra              ; LDA TWOS2,X       ; Fetch a 2-pixel dash from TWOS2 and EOR it into this
     2820 2241     
8397                      .eor @SC                        ; EOR (SC),Y        ; second row to make a 4-pixel square
     **** ****     > EOR
0001 2822 D1A0  30        movb @SC,rtmp
     2824 0007     
0002 2826 2806  18        xor  rtmp,ra
                   < elite.a99
8398                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 2828 D820  42        movb @SC,@rtmplb
     282A 0007     
     282C 830D     
0002 282E D1A0  30        movb @SC+1,rtmp
     2830 0008     
0003 2832 A182  18        a    ry,rtmp
0004 2834 D580  30        movb RA,*rtmp
                   < elite.a99
8399               
8400               PX13:
8401 2836 D0A0  30        movb @T1,ry                     ; LDY T1            ; Restore Y from T1, so Y is preserved by the routine
     2838 0006     
8402               
8403               PX4:
8404 283A 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     283C 800E     
8405               
8406               * ******************************************************************************
8407               *
8408               * Name: BLINE
8409               * Type: Subroutine
8410               * Category: Drawing circles
8411               * Summary: Draw a circle segment and add it to the ball line heap
8412               * Deep dive: The ball line heap
8413               * Drawing circles
8414               *
8415               * ------------------------------------------------------------------------------
8416               *
8417               * Draw a single segment of a circle, adding the point to the ball line heap.
8418               *
8419               * ------------------------------------------------------------------------------
8420               *
8421               * Arguments:
8422               *
8423               * CNT                 The number of this segment
8424               *
8425               * STP                 The step size for the circle
8426               *
8427               * K6(1 0)             The x-coordinate of the new point on the circle, as
8428               * a screen coordinate
8429               *
8430               * (T X)               The y-coordinate of the new point on the circle, as
8431               * an offset from the centre of the circle
8432               *
8433               * FLAG                Set to &FF for the first call, so it sets up the first
8434               * point in the heap but waits until the second call before
8435               * drawing anything (as we need two points, i.e. two calls,
8436               * before we can draw a line)
8437               *
8438               * K4(1 0)             Pixel y-coordinate of the centre of the circle
8439               *
8440               * K5(1 0)             Screen x-coordinate of the previous point added to the
8441               * ball line heap (if this is not the first point)
8442               *
8443               * K5(3 2)             Screen y-coordinate of the previous point added to the
8444               * ball line heap (if this is not the first point)
8445               *
8446               * ------------------------------------------------------------------------------
8447               *
8448               * Returns:
8449               *
8450               * CNT                 CNT is updated to CNT + STP
8451               *
8452               * A                   The new value of CNT
8453               *
8454               * K5(1 0)             Screen x-coordinate of the point that we just added to
8455               * the ball line heap
8456               *
8457               * K5(3 2)             Screen y-coordinate of the point that we just added to
8458               * the ball line heap
8459               *
8460               * FLAG                Set to 0
8461               *
8462               * ******************************************************************************
8463               
8464               BLINE:
8465 283E D001  18        movb rx,ra                      ; TXA               ; Set K6(3 2) = (T X) + K4(1 0)
8466                      .adc @K4,ra                     ; ADC K4            ; = y-coord of centre + y-coord of new point
     **** ****     > ADC
0001 2840 1701  14        jnc  !
0002 2842 B004  18        ab   rone,ra
0003               !:
0004 2844 B020  30        ab   @K4,ra
     2846 00E0     
                   < elite.a99
8467 2848 D800  30        movb ra,@K6+2                   ; STA K6+2          ;
     284A 0084     
8468 284C D020  30        movb @K4+1,ra                   ; LDA K4+1          ; so K6(3 2) now contains the y-coordinate of the new
     284E 00E1     
8469                      .adc @T,ra                      ; ADC T             ; point on the circle but as a screen coordinate, to go
     **** ****     > ADC
0001 2850 1701  14        jnc  !
0002 2852 B004  18        ab   rone,ra
0003               !:
0004 2854 B020  30        ab   @T,ra
     2856 00D1     
                   < elite.a99
8470 2858 D800  30        movb ra,@K6+3                   ; STA K6+3          ; along with the screen x-coordinate in K6(1 0)
     285A 0085     
8471               
8472 285C D020  30        movb @FLAG,ra                   ; LDA FLAG          ; If FLAG = 0, jump down to BL1
     285E 00A3     
8473 2860 130C  14        jeq  BL1                        ; BEQ BL1
8474               
8475 2862 B004  18        ab   rone,ra                    ; INC FLAG          ; Flag is &FF so this is the first call to BLINE, so
8476                                                                          ; increment FLAG to set it to 0, as then the next time
8477                                                                          ; we call BLINE it can draw the first line, from this
8478                                                                          ; point to the next
8479               
8480               BL5:
8481                                                                          ; The following inserts a &FF marker into the LSY2 line
8482                                                                          ; heap to indicate that the next call to BLINE should
8483                                                                          ; store both the (X1, Y1) and (X2, Y2) points. We do
8484                                                                          ; this on the very first call to BLINE (when FLAG is
8485                                                                          ; &FF), and on subsequent calls if the segment does not
8486                                                                          ; fit on-screen, in which case we don't draw or store
8487                                                                          ; that segment, and we start a new segment with the next
8488                                                                          ; call to BLINE that does fit on-screen
8489 2864 D0A0  30        movb @LSP,ry                    ; LDY LSP           ; If byte LSP-1 of LSY2 = &FF, jump to BL7 to tidy up
     2866 0077     
8490 2868 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; and return from the subroutine, as the point that has
     286A FF00     
8491 286C 9022  34        cb   @LSY2-1(ry),ra             ; CMP LSY2-1,Y      ; been passed to BLINE is the start of a segment, so all
     286E 0E73     
8492 2870 135E  14        jeq  BL7                        ; BEQ BL7           ; we need to do is save the coordinate in K5, without
8493                                                                          ; moving the pointer in LSP
8494               
8495 2872 D880  38        movb ra,@LSY2(ry)               ; STA LSY2,Y        ; Otherwise we just tried to plot a segment but it
     2874 0E74     
8496                                                                          ; didn't fit on-screen, so put the &FF marker into the
8497                                                                          ; heap for this point, so the next call to BLINE starts
8498                                                                          ; a new segment
8499               
8500 2876 B004  18        ab   rone,ra                    ; INC LSP           ; Increment LSP to point to the next point in the heap
8501               
8502 2878 165A  14        jne  BL7                        ; BNE BL7           ; Jump to BL7 to tidy up and return from the subroutine
8503                                                                          ; (this BNE is effectively a JMP, as LSP will never be
8504                                                                          ; zero)
8505               
8506               BL1:
8507 287A D020  30        movb @K5,ra                     ; LDA K5            ; Set XX15 = K5 = x_lo of previous point
     287C 007E     
8508 287E D800  30        movb ra,@XX15                   ; STA XX15
     2880 0031     
8509               
8510 2882 D020  30        movb @K5+1,ra                   ; LDA K5+1          ; Set XX15+1 = K5+1 = x_hi of previous point
     2884 007F     
8511 2886 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     2888 0032     
8512               
8513 288A D020  30        movb @K5+2,ra                   ; LDA K5+2          ; Set XX15+2 = K5+2 = y_lo of previous point
     288C 0080     
8514 288E D800  30        movb ra,@XX15+2                 ; STA XX15+2
     2890 0033     
8515               
8516 2892 D020  30        movb @K5+3,ra                   ; LDA K5+3          ; Set XX15+3 = K5+3 = y_hi of previous point
     2894 0081     
8517 2896 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     2898 0034     
8518               
8519 289A D020  30        movb @K6,ra                     ; LDA K6            ; Set XX15+4 = x_lo of new point
     289C 0082     
8520 289E D800  30        movb ra,@XX15+4                 ; STA XX15+4
     28A0 0035     
8521               
8522 28A2 D020  30        movb @K6+1,ra                   ; LDA K6+1          ; Set XX15+5 = x_hi of new point
     28A4 0083     
8523 28A6 D800  30        movb ra,@XX15+5                 ; STA XX15+5
     28A8 0036     
8524               
8525 28AA D020  30        movb @K6+2,ra                   ; LDA K6+2          ; Set XX12 = y_lo of new point
     28AC 0084     
8526 28AE D800  30        movb ra,@XX12                   ; STA XX12
     28B0 0037     
8527               
8528 28B2 D020  30        movb @K6+3,ra                   ; LDA K6+3          ; Set XX12+1 = y_hi of new point
     28B4 0085     
8529 28B6 D800  30        movb ra,@XX12+1                 ; STA XX12+1
     28B8 0038     
8530               
8531 28BA 0206  20        li   rtmp,LL145                 ; JSR LL145         ; Call LL145 to see if the new line segment needs to be
     28BC A560     
8532 28BE 06A0  28        bl   @jsr                       ;
     28C0 8002     
8533                                                                          ; clipped to fit on-screen, returning the clipped line's
8534                                                                          ; end-points in (X1, Y1) and (X2, Y2)
8535               
8536 28C2 18D0  14        joc  BL5                        ; BCS BL5           ; If the C flag is set then the line is not visible on
8537                                                                          ; screen anyway, so jump to BL5, to avoid drawing and
8538                                                                          ; storing this line
8539               
8540 28C4 D020  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0, then we didn't have to swap the line
     28C6 00A1     
8541 28C8 1310  14        jeq  BL9                        ; BEQ BL9           ; coordinates around during the clipping process, so
8542                                                                          ; jump to BL9 to skip the following swap
8543               
8544 28CA D020  30        movb @X1,ra                     ; LDA X1            ; Otherwise the coordinates were swapped by the call to
     28CC 0031     
8545 28CE D0A0  30        movb @X2,ry                     ; LDY X2            ; LL145 above, so we swap (X1, Y1) and (X2, Y2) back
     28D0 0033     
8546 28D2 D800  30        movb ra,@X2                     ; STA X2            ; again
     28D4 0033     
8547 28D6 D802  30        movb ry,@X1                     ; STY X1
     28D8 0031     
8548 28DA D020  30        movb @Y1,ra                     ; LDA Y1
     28DC 0032     
8549 28DE D0A0  30        movb @Y2,ry                     ; LDY Y2
     28E0 0034     
8550 28E2 D800  30        movb ra,@Y2                     ; STA Y2
     28E4 0034     
8551 28E6 D802  30        movb ry,@Y1                     ; STY Y1
     28E8 0032     
8552               
8553               BL9:
8554 28EA D0A0  30        movb @LSP,ry                    ; LDY LSP           ; Set Y = LSP
     28EC 0077     
8555               
8556 28EE D022  34        movb @LSY2-1(ry),ra             ; LDA LSY2-1,Y      ; If byte LSP-1 of LSY2 is not &FF, jump down to BL8
     28F0 0E73     
8557 28F2 0280  22        ci   ra,>ff*256                 ; CMP #&FF          ; to skip the following (X1, Y1) code
     28F4 FF00     
8558 28F6 1609  14        jne  BL8                        ; BNE BL8
8559               
8560                                                                          ; Byte LSP-1 of LSY2 is &FF, which indicates that we
8561                                                                          ; need to store (X1, Y1) in the heap
8562               
8563 28F8 D020  30        movb @X1,ra                     ; LDA X1            ; Store X1 in the LSP-th byte of LSX2
     28FA 0031     
8564 28FC D880  38        movb ra,@LSX2(ry)               ; STA LSX2,Y
     28FE 0E26     
8565               
8566 2900 D020  30        movb @Y1,ra                     ; LDA Y1            ; Store Y1 in the LSP-th byte of LSY2
     2902 0032     
8567 2904 D880  38        movb ra,@LSY2(ry)               ; STA LSY2,Y
     2906 0E74     
8568               
8569 2908 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next byte in LSX2/LSY2
8570               
8571               BL8:
8572 290A D020  30        movb @X2,ra                     ; LDA X2            ; Store X2 in the LSP-th byte of LSX2
     290C 0033     
8573 290E D880  38        movb ra,@LSX2(ry)               ; STA LSX2,Y
     2910 0E26     
8574               
8575 2912 D020  30        movb @Y2,ra                     ; LDA Y2            ; Store Y2 in the LSP-th byte of LSX2
     2914 0034     
8576 2916 D880  38        movb ra,@LSY2(ry)               ; STA LSY2,Y
     2918 0E74     
8577               
8578 291A B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next byte in LSX2/LSY2
8579               
8580 291C D802  30        movb ry,@LSP                    ; STY LSP           ; Update LSP to point to the same as Y
     291E 0077     
8581               
8582 2920 0206  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2)
     2922 224E     
8583 2924 06A0  28        bl   @jsr                       ;
     2926 8002     
8584               
8585 2928 D020  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 is non-zero, jump up to BL5 to add a &FF
     292A 0098     
8586 292C 169B  14        jne  BL5                        ; BNE BL5           ; marker to the end of the line heap. XX13 is non-zero
8587                                                                          ; after the call to the clipping routine LL145 above if
8588                                                                          ; the end of the line was clipped, meaning the next line
8589                                                                          ; sent to BLINE can't join onto the end but has to start
8590                                                                          ; a new segment, and that's what inserting the &FF
8591                                                                          ; marker does
8592               
8593               BL7:
8594 292E D020  30        movb @K6,ra                     ; LDA K6            ; Copy the data for this step point from K6(3 2 1 0)
     2930 0082     
8595 2932 D800  30        movb ra,@K5                     ; STA K5            ; into K5(3 2 1 0), for use in the next call to BLINE:
     2934 007E     
8596 2936 D020  30        movb @K6+1,ra                   ; LDA K6+1          ;
     2938 0083     
8597 293A D800  30        movb ra,@K5+1                   ; STA K5+1          ; * K5(1 0) = screen x-coordinate of this point
     293C 007F     
8598 293E D020  30        movb @K6+2,ra                   ; LDA K6+2          ;
     2940 0084     
8599 2942 D800  30        movb ra,@K5+2                   ; STA K5+2          ; * K5(3 2) = screen y-coordinate of this point
     2944 0080     
8600 2946 D020  30        movb @K6+3,ra                   ; LDA K6+3          ;
     2948 0085     
8601 294A D800  30        movb ra,@K5+3                   ; STA K5+3          ; They now become the "previous point" in the next call
     294C 0081     
8602               
8603 294E D020  30        movb @CNT,ra                    ; LDA CNT           ; Set CNT = CNT + STP
     2950 00A4     
8604                      .clc                            ; CLC
     **** ****     > CLC
0001 2952 0A13  18        sla  rzero,1
                   < elite.a99
8605                      .adc @STP,ra                    ; ADC STP
     **** ****     > ADC
0001 2954 1701  14        jnc  !
0002 2956 B004  18        ab   rone,ra
0003               !:
0004 2958 B020  30        ab   @STP,ra
     295A 00A6     
                   < elite.a99
8606 295C D800  30        movb ra,@CNT                    ; STA CNT
     295E 00A4     
8607               
8608 2960 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     2962 800E     
8609               
8610               * ******************************************************************************
8611               *
8612               * Name: FLIP
8613               * Type: Subroutine
8614               * Category: Stardust
8615               * Summary: Reflect the stardust particles in the screen diagonal and redraw
8616               * the stardust field
8617               *
8618               * ------------------------------------------------------------------------------
8619               *
8620               * Swap the x- and y-coordinates of all the stardust particles and draw the new
8621               * set of particles. Called by LOOK1 when we switch views.
8622               *
8623               * This is a quick way of making the stardust field in the new view feel
8624               * different without having to generate a whole new field. If you look carefully
8625               * at the stardust field when you switch views, you can just about see that the
8626               * new field is a reflection of the previous field in the screen diagonal, i.e.
8627               * in the line from bottom left to top right. This is the line where x = y when
8628               * the origin is in the middle of the screen, and positive x and y are right and
8629               * up, which is the coordinate system we use for stardust).
8630               *
8631               * ******************************************************************************
8632               
8633               FLIP:
8634               * LDA MJ                 \ These instructions are commented out in the original
8635               * BNE FLIP-1             \ source. They would have the effect of not swapping the
8636                                                                          ; stardust if we had mis-jumped into witchspace
8637 2964 D0A0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     2966 0F33     
8638                                                                          ; we can use it as a counter through all the stardust
8639               
8640               FLL1:
8641 2968 D062  34        movb @SY(ry),rx                 ; LDX SY,Y          ; Copy the Y-th particle's y-coordinate from SY+Y into X
     296A 0EC2     
8642               
8643 296C D022  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Copy the Y-th particle's x-coordinate from SX+Y into
     296E 034C     
8644 2970 D800  30        movb ra,@Y1                     ; STA Y1            ; both Y1 and the particle's y-coordinate
     2972 0032     
8645 2974 D880  38        movb ra,@SY(ry)                 ; STA SY,Y
     2976 0EC2     
8646               
8647 2978 D001  18        movb rx,ra                      ; TXA               ; Copy the Y-th particle's original y-coordinate into
8648 297A D800  30        movb ra,@X1                     ; STA X1            ; both X1 and the particle's x-coordinate, so the x- and
     297C 0031     
8649 297E D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; y-coordinates are now swapped and (X1, Y1) contains
     2980 034C     
8650                                                                          ; the particle's new coordinates
8651               
8652 2982 D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Fetch the Y-th particle's distance from SZ+Y into ZZ
     2984 0EE8     
8653 2986 D800  30        movb ra,@ZZ                     ; STA ZZ
     2988 0097     
8654               
8655 298A 0206  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ
     298C 276C     
8656 298E 06A0  28        bl   @jsr                       ;
     2990 8002     
8657               
8658 2992 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point to the next particle of
8659                                                                          ; stardust
8660               
8661 2994 16E9  14        jne  FLL1                       ; BNE FLL1          ; Loop back to FLL1 until we have moved all the stardust
8662                                                                          ; particles
8663               
8664 2996 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     2998 800E     
8665               
8666               * ******************************************************************************
8667               *
8668               * Name: STARS
8669               * Type: Subroutine
8670               * Category: Stardust
8671               * Summary: The main routine for processing the stardust
8672               *
8673               * ------------------------------------------------------------------------------
8674               *
8675               * Called at the very end of the main flight loop.
8676               *
8677               * ******************************************************************************
8678               
8679               STARS:
8680               * LDA #&FF               \ These instructions are commented out in the original
8681               * STA COL                \ source, but they would set the stardust colour to
8682                                                                          ; white. That said, COL is only used when updating the
8683                                                                          ; dashboard, so this would have no effect - perhaps it's
8684                                                                          ; left over from experiments with a colour top part of
8685                                                                          ; the screen? Who knows...
8686 299A D060  30        movb @VIEW,rx                   ; LDX VIEW          ; Load the current view into X:
     299C 0D5F     
8687                                                                          ;
8688                                                                          ; 0 = front
8689                                                                          ; 1 = rear
8690                                                                          ; 2 = left
8691                                                                          ; 3 = right
8692               
8693 299E 1306  14        jeq  STARS1                     ; BEQ STARS1        ; If this 0, jump to STARS1 to process the stardust for
8694                                                                          ; the front view
8695               
8696 29A0 7044  18        sb   rone,rx                    ; DEX               ; If this is view 2 or 3, jump to STARS2 (via ST11) to
8697 29A2 1602  14        jne  ST11                       ; BNE ST11          ; process the stardust for the left or right views
8698               
8699 29A4 0460  28        b    @STARS6                    ; JMP STARS6        ; Otherwise this is the rear view, so jump to STARS6 to
     29A6 2BBA     
8700                                                                          ; process the stardust for the rear view
8701               
8702               ST11:
8703 29A8 0460  28        b    @STARS2                    ; JMP STARS2        ; Jump to STARS2 for the left or right views, as it's
     29AA 3F04     
8704                                                                          ; too far for the branch instruction above
8705               
8706               * ******************************************************************************
8707               *
8708               * Name: STARS1
8709               * Type: Subroutine
8710               * Category: Stardust
8711               * Summary: Process the stardust for the front view
8712               * Deep dive: Stardust in the front view
8713               *
8714               * ------------------------------------------------------------------------------
8715               *
8716               * This moves the stardust towards us according to our speed (so the dust rushes
8717               * past us), and applies our current pitch and roll to each particle of dust, so
8718               * the stardust moves correctly when we steer our ship.
8719               *
8720               * When a stardust particle rushes past us and falls off the side of the screen,
8721               * its memory is recycled as a new particle that's positioned randomly on-screen.
8722               *
8723               * These are the calculations referred to in the commentary:
8724               *
8725               * 1. q = 64 * speed / z_hi
8726               * 2. z = z - speed * 64
8727               * 3. y = y + |y_hi| * q
8728               * 4. x = x + |x_hi| * q
8729               *
8730               * 5. y = y + alpha * x / 256
8731               * 6. x = x - alpha * y / 256
8732               *
8733               * 7. x = x + 2 * (beta * y / 256) ^ 2
8734               * 8. y = y - beta * 256
8735               *
8736               * For more information see the deep dive on "Stardust in the front view".
8737               *
8738               * ******************************************************************************
8739               
8740               STARS1:
8741 29AC D0A0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     29AE 0F33     
8742                                                                          ; we can use it as a counter through all the stardust
8743               
8744                                                                          ; In the following, we're going to refer to the 16-bit
8745                                                                          ; space coordinates of the current particle of stardust
8746                                                                          ; (i.e. the Y-th particle) like this:
8747                                                                          ;
8748                                                                          ; x = (x_hi x_lo)
8749                                                                          ; y = (y_hi y_lo)
8750                                                                          ; z = (z_hi z_lo)
8751                                                                          ;
8752                                                                          ; These values are stored in (SX+Y SXL+Y), (SY+Y SYL+Y)
8753                                                                          ; and (SZ+Y SZL+Y) respectively
8754               
8755               STL1:
8756 29B0 0206  20        li   rtmp,DV42                  ; JSR DV42          ; Call DV42 to set the following:
     29B2 45A4     
8757 29B4 06A0  28        bl   @jsr                       ;
     29B6 8002     
8758                                                                          ;
8759                                                                          ; (P R) = 256 * DELTA / z_hi
8760                                                                          ; = 256 * speed / z_hi
8761                                                                          ;
8762                                                                          ; The maximum value returned is P = 2 and R = 128 (see
8763                                                                          ; DV42 for an explanation)
8764               
8765 29B8 D020  30        movb @R,ra                      ; LDA R             ; Set A = R, so now:
     29BA 0091     
8766                                                                          ;
8767                                                                          ; (P A) = 256 * speed / z_hi
8768               
8769                      .lsr @P                         ; LSR P             ; Rotate (P A) right by 2 places, which sets P = 0 (as P
     **** ****     > LSR
0001 29BC D1A0  30        movb @P,rtmp
     29BE 001B     
0002 29C0 0916  18        srl  rtmp,1
0003 29C2 D806  30        movb rtmp,@P
     29C4 001B     
                   < elite.a99
8770 29C6 06A0  28        bl   @rora                      ; ROR A             ; has a maximum value of 2) and leaves:
     29C8 803C     
8771                      .lsr @P                         ; LSR P             ;
     **** ****     > LSR
0001 29CA D1A0  30        movb @P,rtmp
     29CC 001B     
0002 29CE 0916  18        srl  rtmp,1
0003 29D0 D806  30        movb rtmp,@P
     29D2 001B     
                   < elite.a99
8772 29D4 06A0  28        bl   @rora                      ; ROR A             ; A = 64 * speed / z_hi
     29D6 803C     
8773               
8774 29D8 0260  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1, and store it in Q, so we
     29DA 0100     
8775 29DC D800  30        movb ra,@Q                      ; STA Q             ; now have result 1 above:
     29DE 0090     
8776                                                                          ;
8777                                                                          ; Q = 64 * speed / z_hi
8778               
8779 29E0 D022  34        movb @SZL(ry),ra                ; LDA SZL,Y         ; We now calculate the following:
     29E2 0EFB     
8780                      .sbc @DELT4,ra                  ; SBC DELT4         ;
     **** ****     > SBC
0001 29E4 1801  14        joc  !
0002 29E6 7004  18        sb   rone,ra
0003               !:
0004 29E8 7020  30        sb   @DELT4,ra
     29EA 008D     
                   < elite.a99
8781 29EC D880  38        movb ra,@SZL(ry)                ; STA SZL,Y         ; (z_hi z_lo) = (z_hi z_lo) - DELT4(1 0)
     29EE 0EFB     
8782                                                                          ;
8783                                                                          ; starting with the low bytes
8784               
8785 29F0 D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; And then we do the high bytes
     29F2 0EE8     
8786 29F4 D800  30        movb ra,@ZZ                     ; STA ZZ            ;
     29F6 0097     
8787                      .sbc @DELT4+1,ra                ; SBC DELT4+1       ; We also set ZZ to the original value of z_hi, which we
     **** ****     > SBC
0001 29F8 1801  14        joc  !
0002 29FA 7004  18        sb   rone,ra
0003               !:
0004 29FC 7020  30        sb   @DELT4+1,ra
     29FE 008E     
                   < elite.a99
8788 2A00 D880  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; use below to remove the existing particle
     2A02 0EE8     
8789                                                                          ;
8790                                                                          ; So now we have result 2 above:
8791                                                                          ;
8792                                                                          ; z = z - DELT4(1 0)
8793                                                                          ; = z - speed * 64
8794               
8795 2A04 0206  20        li   rtmp,MLU1                  ; JSR MLU1          ; Call MLU1 to set:
     2A06 42CE     
8796 2A08 06A0  28        bl   @jsr                       ;
     2A0A 8002     
8797                                                                          ;
8798                                                                          ; Y1 = y_hi
8799                                                                          ;
8800                                                                          ; (A P) = |y_hi| * Q
8801                                                                          ;
8802                                                                          ; So Y1 contains the original value of y_hi, which we
8803                                                                          ; use below to remove the existing particle
8804               
8805                                                                          ; We now calculate:
8806                                                                          ;
8807                                                                          ; (S R) = YY(1 0) = (A P) + y
8808               
8809 2A0C D800  30        movb ra,@YY+1                   ; STA YY+1          ; First we do the low bytes with:
     2A0E 0027     
8810 2A10 D020  30        movb @P,ra                      ; LDA P             ;
     2A12 001B     
8811                      .adc @SYL(ry),ra                ; ADC SYL,Y         ; YY+1 = A
     **** ****     > ADC
0001 2A14 1701  14        jnc  !
0002 2A16 B004  18        ab   rone,ra
0003               !:
0004 2A18 B022  34        ab   @SYL(RY),ra
     2A1A 0ED5     
                   < elite.a99
8812 2A1C D800  30        movb ra,@YY                     ; STA YY            ; R = YY = P + y_lo
     2A1E 0026     
8813 2A20 D800  30        movb ra,@R                      ; STA R             ;
     2A22 0091     
8814                                                                          ; so we get this:
8815                                                                          ;
8816                                                                          ; (? R) = YY(1 0) = (A P) + y_lo
8817               
8818 2A24 D020  30        movb @Y1,ra                     ; LDA Y1            ; And then we do the high bytes with:
     2A26 0032     
8819                      .adc @YY+1,ra                   ; ADC YY+1          ;
     **** ****     > ADC
0001 2A28 1701  14        jnc  !
0002 2A2A B004  18        ab   rone,ra
0003               !:
0004 2A2C B020  30        ab   @YY+1,ra
     2A2E 0027     
                   < elite.a99
8820 2A30 D800  30        movb ra,@YY+1                   ; STA YY+1          ; S = YY+1 = y_hi + YY+1
     2A32 0027     
8821 2A34 D800  30        movb ra,@S                      ; STA S             ;
     2A36 0092     
8822                                                                          ; so we get our result:
8823                                                                          ;
8824                                                                          ; (S R) = YY(1 0) = (A P) + (y_hi y_lo)
8825                                                                          ; = |y_hi| * Q + y
8826                                                                          ;
8827                                                                          ; which is result 3 above, and (S R) is set to the new
8828                                                                          ; value of y
8829               
8830 2A38 D022  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Set X1 = A = x_hi
     2A3A 034C     
8831 2A3C D800  30        movb ra,@X1                     ; STA X1            ;
     2A3E 0031     
8832                                                                          ; So X1 contains the original value of x_hi, which we
8833                                                                          ; use below to remove the existing particle
8834               
8835 2A40 0206  20        li   rtmp,MLU2                  ; JSR MLU2          ; Set (A P) = |x_hi| * Q
     2A42 42D6     
8836 2A44 06A0  28        bl   @jsr                       ;
     2A46 8002     
8837               
8838                                                                          ; We now calculate:
8839                                                                          ;
8840                                                                          ; XX(1 0) = (A P) + x
8841               
8842 2A48 D800  30        movb ra,@XX+1                   ; STA XX+1          ; First we do the low bytes:
     2A4A 0025     
8843 2A4C D020  30        movb @P,ra                      ; LDA P             ;
     2A4E 001B     
8844                      .adc @SXL(ry),ra                ; ADC SXL,Y         ; XX(1 0) = (A P) + x_lo
     **** ****     > ADC
0001 2A50 1701  14        jnc  !
0002 2A52 B004  18        ab   rone,ra
0003               !:
0004 2A54 B022  34        ab   @SXL(RY),ra
     2A56 035F     
                   < elite.a99
8845 2A58 D800  30        movb ra,@XX                     ; STA XX
     2A5A 0024     
8846               
8847 2A5C D020  30        movb @X1,ra                     ; LDA X1            ; And then we do the high bytes:
     2A5E 0031     
8848                      .adc @XX+1,ra                   ; ADC XX+1          ;
     **** ****     > ADC
0001 2A60 1701  14        jnc  !
0002 2A62 B004  18        ab   rone,ra
0003               !:
0004 2A64 B020  30        ab   @XX+1,ra
     2A66 0025     
                   < elite.a99
8849 2A68 D800  30        movb ra,@XX+1                   ; STA XX+1          ; XX(1 0) = XX(1 0) + (x_hi 0)
     2A6A 0025     
8850                                                                          ;
8851                                                                          ; so we get our result:
8852                                                                          ;
8853                                                                          ; XX(1 0) = (A P) + x
8854                                                                          ; = |x_hi| * Q + x
8855                                                                          ;
8856                                                                          ; which is result 4 above, and we also have:
8857                                                                          ;
8858                                                                          ; A = XX+1 = (|x_hi| * Q + x) / 256
8859                                                                          ;
8860                                                                          ; i.e. A is the new value of x, divided by 256
8861               
8862                      .eor @ALP2+1                    ; EOR ALP2+1        ; EOR with the flipped sign of the roll angle alpha, so
     **** ****     > EOR
0001 2A6C D1A0  30        movb @ALP2+1,rtmp
     2A6E 0089     
0002 2A70 2806  18        xor  rtmp,ra
                   < elite.a99
8863                                                                          ; A has the opposite sign to the flipped roll angle
8864                                                                          ; alpha, i.e. it gets the same sign as alpha
8865               
8866 2A72 0206  20        li   rtmp,MLS1                  ; JSR MLS1          ; Call MLS1 to calculate:
     2A74 41EE     
8867 2A76 06A0  28        bl   @jsr                       ;
     2A78 8002     
8868                                                                          ;
8869                                                                          ; (A P) = A * ALP1
8870                                                                          ; = (x / 256) * alpha
8871               
8872 2A7A 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2A7C 44BA     
8873 2A7E 06A0  28        bl   @jsr                       ;
     2A80 8002     
8874                                                                          ;
8875                                                                          ; (A X) = (A P) + (S R)
8876                                                                          ; = (x / 256) * alpha + y
8877                                                                          ; = y + alpha * x / 256
8878               
8879 2A82 D800  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY(1 0) = (A X) to give:
     2A84 0027     
8880 2A86 D801  30        movb rx,@YY                     ; STX YY            ;
     2A88 0026     
8881                                                                          ; YY(1 0) = y + alpha * x / 256
8882                                                                          ;
8883                                                                          ; which is result 5 above, and we also have:
8884                                                                          ;
8885                                                                          ; A = YY+1 = y + alpha * x / 256
8886                                                                          ;
8887                                                                          ; i.e. A is the new value of y, divided by 256
8888               
8889                      .eor @ALP2                      ; EOR ALP2          ; EOR A with the correct sign of the roll angle alpha,
     **** ****     > EOR
0001 2A8A D1A0  30        movb @ALP2,rtmp
     2A8C 0088     
0002 2A8E 2806  18        xor  rtmp,ra
                   < elite.a99
8890                                                                          ; so A has the opposite sign to the roll angle alpha
8891               
8892 2A90 0206  20        li   rtmp,MLS2                  ; JSR MLS2          ; Call MLS2 to calculate:
     2A92 41DE     
8893 2A94 06A0  28        bl   @jsr                       ;
     2A96 8002     
8894                                                                          ;
8895                                                                          ; (S R) = XX(1 0)
8896                                                                          ; = x
8897                                                                          ;
8898                                                                          ; (A P) = A * ALP1
8899                                                                          ; = -y / 256 * alpha
8900               
8901 2A98 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2A9A 44BA     
8902 2A9C 06A0  28        bl   @jsr                       ;
     2A9E 8002     
8903                                                                          ;
8904                                                                          ; (A X) = (A P) + (S R)
8905                                                                          ; = -y / 256 * alpha + x
8906               
8907 2AA0 D800  30        movb ra,@XX+1                   ; STA XX+1          ; Set XX(1 0) = (A X), which gives us result 6 above:
     2AA2 0025     
8908 2AA4 D801  30        movb rx,@XX                     ; STX XX            ;
     2AA6 0024     
8909                                                                          ; x = x - alpha * y / 256
8910               
8911 2AA8 D060  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the pitch magnitude into X
     2AAA 002B     
8912               
8913 2AAC D020  30        movb @YY+1,ra                   ; LDA YY+1          ; Set A to y_hi and set it to the flipped sign of beta
     2AAE 0027     
8914                      .eor @BET2+1                    ; EOR BET2+1
     **** ****     > EOR
0001 2AB0 D1A0  30        movb @BET2+1,rtmp
     2AB2 008B     
0002 2AB4 2806  18        xor  rtmp,ra
                   < elite.a99
8915               
8916 2AB6 0206  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     2AB8 41F4     
8917 2ABA 06A0  28        bl   @jsr                       ;
     2ABC 8002     
8918                                                                          ;
8919                                                                          ; (A P) = X * A
8920                                                                          ; = -beta * y_hi
8921               
8922 2ABE D800  30        movb ra,@Q                      ; STA Q             ; Store the high byte of the result in Q, so:
     2AC0 0090     
8923                                                                          ;
8924                                                                          ; Q = -beta * y_hi / 256
8925               
8926 2AC2 0206  20        li   rtmp,MUT2                  ; JSR MUT2          ; Call MUT2 to calculate:
     2AC4 43E4     
8927 2AC6 06A0  28        bl   @jsr                       ;
     2AC8 8002     
8928                                                                          ;
8929                                                                          ; (S R) = XX(1 0) = x
8930                                                                          ;
8931                                                                          ; (A P) = Q * A
8932                                                                          ; = (-beta * y_hi / 256) * (-beta * y_hi / 256)
8933                                                                          ; = (beta * y / 256) ^ 2
8934               
8935                      .asl @P                         ; ASL P             ; Double (A P), store the top byte in A and set the C
     **** ****     > ASL
0001 2ACA D1A0  30        movb @P,rtmp
     2ACC 001B     
0002 2ACE 0246  22        andi rtmp,>ff00
     2AD0 FF00     
0003 2AD2 0A16  18        sla  rtmp,1
0004 2AD4 D806  30        movb rtmp,@P
     2AD6 001B     
                   < elite.a99
8936 2AD8 06A0  28        bl   @rola                      ; ROL A             ; flag to bit 7 of the original A, so this does:
     2ADA 8018     
8937 2ADC D800  30        movb ra,@T                      ; STA T             ;
     2ADE 00D1     
8938                                                                          ; (T P) = (A P) << 1
8939                                                                          ; = 2 * (beta * y / 256) ^ 2
8940               
8941 2AE0 0200  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 in A to the sign bit from the A in the
     2AE2 0000     
8942 2AE4 06A0  28        bl   @rora                      ; ROR A             ; calculation above and apply it to T, so we now have:
     2AE6 803C     
8943 2AE8 F020  30        socb @T,ra                      ; ORA T             ;
     2AEA 00D1     
8944                                                                          ; (A P) = (A P) * 2
8945                                                                          ; = 2 * (beta * y / 256) ^ 2
8946                                                                          ;
8947                                                                          ; with the doubling retaining the sign of (A P)
8948               
8949 2AEC 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2AEE 44BA     
8950 2AF0 06A0  28        bl   @jsr                       ;
     2AF2 8002     
8951                                                                          ;
8952                                                                          ; (A X) = (A P) + (S R)
8953                                                                          ; = 2 * (beta * y / 256) ^ 2 + x
8954               
8955 2AF4 D800  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     2AF6 0025     
8956               
8957 2AF8 D001  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
8958 2AFA D880  38        movb ra,@SXL(ry)                ; STA SXL,Y
     2AFC 035F     
8959               
8960                                                                          ; So (XX+1 x_lo) now contains:
8961                                                                          ;
8962                                                                          ; x = x + 2 * (beta * y / 256) ^ 2
8963                                                                          ;
8964                                                                          ; which is result 7 above
8965               
8966 2AFE D020  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0) = y
     2B00 0026     
8967 2B02 D800  30        movb ra,@R                      ; STA R
     2B04 0091     
8968 2B06 D020  30        movb @YY+1,ra                   ; LDA YY+1
     2B08 0027     
8969               * JSR MAD                \ These instructions are commented out in the original
8970               * STA S                  \ source
8971               * STX R
8972 2B0A D800  30        movb ra,@S                      ; STA S
     2B0C 0092     
8973               
8974 2B0E 0200  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     2B10 0000     
8975 2B12 D800  30        movb ra,@P                      ; STA P
     2B14 001B     
8976               
8977 2B16 D020  30        movb @BETA,ra                   ; LDA BETA          ; Set A = -beta, so:
     2B18 002A     
8978                      .eoi (>80*256)                  ; EOR #%10000000    ;
     **** ****     > EOI
0001 2B1A 0206  20        li   rtmp,(>80*256)
     2B1C 8000     
0002 2B1E 2806  18        xor  rtmp,ra
                   < elite.a99
8979                                                                          ; (A P) = (-beta 0)
8980                                                                          ; = -beta * 256
8981               
8982 2B20 0206  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     2B22 275A     
8983 2B24 06A0  28        bl   @jsr                       ;
     2B26 8002     
8984                                                                          ;
8985                                                                          ; (YY+1 y_lo) = (A P) + (S R)
8986                                                                          ; = -beta * 256 + y
8987                                                                          ;
8988                                                                          ; i.e. y = y - beta * 256, which is result 8 above
8989                                                                          ;
8990                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
8991                                                                          ; ZZ, which will remove the old stardust particle, as we
8992                                                                          ; set X1, Y1 and ZZ to the original values for this
8993                                                                          ; particle during the calculations above
8994               
8995                                                                          ; We now have our newly moved stardust particle at
8996                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
8997                                                                          ; and distance z_hi, so we draw it if it's still on
8998                                                                          ; screen, otherwise we recycle it as a new bit of
8999                                                                          ; stardust and draw that
9000               
9001 2B28 D020  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     2B2A 0025     
9002 2B2C D800  30        movb ra,@X1                     ; STA X1            ; the new x-coordinate is in (x_hi x_lo) and the high
     2B2E 0031     
9003 2B30 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; byte is in X1
     2B32 034C     
9004               
9005 2B34 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; If |x_hi| >= 120 then jump to KILL1 to recycle this
     2B36 7F00     
9006 2B38 0280  22        ci   ra,>78*256                 ; CMP #120          ; particle, as it's gone off the side of the screen,
     2B3A 7800     
9007 2B3C 181C  14        joc  KILL1                      ; BCS KILL1         ; and rejoin at STC1 with the new particle
9008               
9009 2B3E D020  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     2B40 0027     
9010 2B42 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     2B44 0EC2     
9011 2B46 D800  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     2B48 0032     
9012               
9013 2B4A 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 120 then jump to KILL1 to recycle this
     2B4C 7F00     
9014 2B4E 0280  22        ci   ra,>78*256                 ; CMP #120          ; particle, as it's gone off the top or bottom of the
     2B50 7800     
9015 2B52 1811  14        joc  KILL1                      ; BCS KILL1         ; screen, and rejoin at STC1 with the new particle
9016               
9017 2B54 D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; If z_hi < 16 then jump to KILL1 to recycle this
     2B56 0EE8     
9018 2B58 0280  22        ci   ra,>10*256                 ; CMP #16           ; particle, as it's so close that it's effectively gone
     2B5A 1000     
9019 2B5C 170C  14        jnc  KILL1                      ; BCC KILL1         ; past us, and rejoin at STC1 with the new particle
9020               
9021 2B5E D800  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the z-coordinate in z_hi
     2B60 0097     
9022               
9023               STC1:
9024 2B62 0206  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     2B64 276C     
9025 2B66 06A0  28        bl   @jsr                       ;
     2B68 8002     
9026                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
9027                                                                          ; with distance z_hi
9028               
9029 2B6A 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
9030                                                                          ; stardust particle
9031               
9032 2B6C 1302  14        jeq  B18                        ; BEQ B18           ; If we have just done the last particle, skip the next
9033                                                                          ; instruction to return from the subroutine
9034               
9035 2B6E 0460  28        b    @STL1                      ; JMP STL1          ; We have more stardust to process, so jump back up to
     2B70 29B0     
9036                                                                          ; STL1 for the next particle
9037               
9038               B18:
9039 2B72 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     2B74 800E     
9040               
9041               KILL1:
9042                                                                          ; Our particle of stardust just flew past us, so let's
9043                                                                          ; recycle that particle, starting it at a random
9044                                                                          ; position that isn't too close to the centre point
9045 2B76 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2B78 8070     
9046 2B7A 06A0  28        bl   @jsr                       ;
     2B7C 8002     
9047               
9048 2B7E 0260  22        ori  ra,>04*256                 ; ORA #4            ; Make sure A is at least 4 and store it in Y1 and y_hi,
     2B80 0400     
9049 2B82 D800  30        movb ra,@Y1                     ; STA Y1            ; so the new particle starts at least 4 pixels above or
     2B84 0032     
9050 2B86 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; below the centre of the screen
     2B88 0EC2     
9051               
9052 2B8A 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2B8C 8070     
9053 2B8E 06A0  28        bl   @jsr                       ;
     2B90 8002     
9054               
9055 2B92 0260  22        ori  ra,>08*256                 ; ORA #8            ; Make sure A is at least 8 and store it in X1 and x_hi,
     2B94 0800     
9056 2B96 D800  30        movb ra,@X1                     ; STA X1            ; so the new particle starts at least 8 pixels either
     2B98 0031     
9057 2B9A D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; side of the centre of the screen
     2B9C 034C     
9058               
9059 2B9E 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2BA0 8070     
9060 2BA2 06A0  28        bl   @jsr                       ;
     2BA4 8002     
9061               
9062 2BA6 0260  22        ori  ra,>90*256                 ; ORA #144          ; Make sure A is at least 144 and store it in ZZ and
     2BA8 9000     
9063 2BAA D880  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; z_hi so the new particle starts in the far distance
     2BAC 0EE8     
9064 2BAE D800  30        movb ra,@ZZ                     ; STA ZZ
     2BB0 0097     
9065               
9066 2BB2 D020  30        movb @Y1,ra                     ; LDA Y1            ; Set A to the new value of y_hi. This has no effect as
     2BB4 0032     
9067                                                                          ; STC1 starts with a jump to PIXEL2, which starts with a
9068                                                                          ; LDA instruction
9069               
9070 2BB6 0460  28        b    @STC1                      ; JMP STC1          ; Jump up to STC1 to draw this new particle
     2BB8 2B62     
9071               
9072               * ******************************************************************************
9073               *
9074               * Name: STARS6
9075               * Type: Subroutine
9076               * Category: Stardust
9077               * Summary: Process the stardust for the rear view
9078               *
9079               * ------------------------------------------------------------------------------
9080               *
9081               * This routine is very similar to STARS1, which processes stardust for the front
9082               * view. The main difference is that the direction of travel is reversed, so the
9083               * signs in the calculations are different, as well as the order of the first
9084               * batch of calculations.
9085               *
9086               * When a stardust particle falls away into the far distance, it is removed from
9087               * the screen and its memory is recycled as a new particle, positioned randomly
9088               * along one of the four edges of the screen.
9089               *
9090               * These are the calculations referred to in the commentary:
9091               *
9092               * 1. q = 64 * speed / z_hi
9093               * 2. z = z - speed * 64
9094               * 3. y = y + |y_hi| * q
9095               * 4. x = x + |x_hi| * q
9096               *
9097               * 5. y = y + alpha * x / 256
9098               * 6. x = x - alpha * y / 256
9099               *
9100               * 7. x = x + 2 * (beta * y / 256) ^ 2
9101               * 8. y = y - beta * 256
9102               *
9103               * For more information see the deep dive on "Stardust in the front view".
9104               *
9105               * ******************************************************************************
9106               
9107               STARS6:
9108 2BBA D0A0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     2BBC 0F33     
9109                                                                          ; we can use it as a counter through all the stardust
9110               
9111               STL6:
9112 2BBE 0206  20        li   rtmp,DV42                  ; JSR DV42          ; Call DV42 to set the following:
     2BC0 45A4     
9113 2BC2 06A0  28        bl   @jsr                       ;
     2BC4 8002     
9114                                                                          ;
9115                                                                          ; (P R) = 256 * DELTA / z_hi
9116                                                                          ; = 256 * speed / z_hi
9117                                                                          ;
9118                                                                          ; The maximum value returned is P = 2 and R = 128 (see
9119                                                                          ; DV42 for an explanation)
9120               
9121 2BC6 D020  30        movb @R,ra                      ; LDA R             ; Set A = R, so now:
     2BC8 0091     
9122                                                                          ;
9123                                                                          ; (P A) = 256 * speed / z_hi
9124               
9125                      .lsr @P                         ; LSR P             ; Rotate (P A) right by 2 places, which sets P = 0 (as P
     **** ****     > LSR
0001 2BCA D1A0  30        movb @P,rtmp
     2BCC 001B     
0002 2BCE 0916  18        srl  rtmp,1
0003 2BD0 D806  30        movb rtmp,@P
     2BD2 001B     
                   < elite.a99
9126 2BD4 06A0  28        bl   @rora                      ; ROR A             ; has a maximum value of 2) and leaves:
     2BD6 803C     
9127                      .lsr @P                         ; LSR P             ;
     **** ****     > LSR
0001 2BD8 D1A0  30        movb @P,rtmp
     2BDA 001B     
0002 2BDC 0916  18        srl  rtmp,1
0003 2BDE D806  30        movb rtmp,@P
     2BE0 001B     
                   < elite.a99
9128 2BE2 06A0  28        bl   @rora                      ; ROR A             ; A = 64 * speed / z_hi
     2BE4 803C     
9129               
9130 2BE6 0260  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1, and store it in Q, so we
     2BE8 0100     
9131 2BEA D800  30        movb ra,@Q                      ; STA Q             ; now have result 1 above:
     2BEC 0090     
9132                                                                          ;
9133                                                                          ; Q = 64 * speed / z_hi
9134               
9135 2BEE D022  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Set X1 = A = x_hi
     2BF0 034C     
9136 2BF2 D800  30        movb ra,@X1                     ; STA X1            ;
     2BF4 0031     
9137                                                                          ; So X1 contains the original value of x_hi, which we
9138                                                                          ; use below to remove the existing particle
9139               
9140 2BF6 0206  20        li   rtmp,MLU2                  ; JSR MLU2          ; Set (A P) = |x_hi| * Q
     2BF8 42D6     
9141 2BFA 06A0  28        bl   @jsr                       ;
     2BFC 8002     
9142               
9143                                                                          ; We now calculate:
9144                                                                          ;
9145                                                                          ; XX(1 0) = x - (A P)
9146               
9147 2BFE D800  30        movb ra,@XX+1                   ; STA XX+1          ; First we do the low bytes:
     2C00 0025     
9148 2C02 D022  34        movb @SXL(ry),ra                ; LDA SXL,Y         ;
     2C04 035F     
9149                      .sbc @P,ra                      ; SBC P             ; XX(1 0) = x_lo - (A P)
     **** ****     > SBC
0001 2C06 1801  14        joc  !
0002 2C08 7004  18        sb   rone,ra
0003               !:
0004 2C0A 7020  30        sb   @P,ra
     2C0C 001B     
                   < elite.a99
9150 2C0E D800  30        movb ra,@XX                     ; STA XX
     2C10 0024     
9151               
9152 2C12 D020  30        movb @X1,ra                     ; LDA X1            ; And then we do the high bytes:
     2C14 0031     
9153                      .sbc @XX+1,ra                   ; SBC XX+1          ;
     **** ****     > SBC
0001 2C16 1801  14        joc  !
0002 2C18 7004  18        sb   rone,ra
0003               !:
0004 2C1A 7020  30        sb   @XX+1,ra
     2C1C 0025     
                   < elite.a99
9154 2C1E D800  30        movb ra,@XX+1                   ; STA XX+1          ; XX(1 0) = (x_hi 0) - XX(1 0)
     2C20 0025     
9155                                                                          ;
9156                                                                          ; so we get our result:
9157                                                                          ;
9158                                                                          ; XX(1 0) = x - (A P)
9159                                                                          ; = x - |x_hi| * Q
9160                                                                          ;
9161                                                                          ; which is result 2 above, and we also have:
9162               
9163 2C22 0206  20        li   rtmp,MLU1                  ; JSR MLU1          ; Call MLU1 to set:
     2C24 42CE     
9164 2C26 06A0  28        bl   @jsr                       ;
     2C28 8002     
9165                                                                          ;
9166                                                                          ; Y1 = y_hi
9167                                                                          ;
9168                                                                          ; (A P) = |y_hi| * Q
9169                                                                          ;
9170                                                                          ; So Y1 contains the original value of y_hi, which we
9171                                                                          ; use below to remove the existing particle
9172               
9173                                                                          ; We now calculate:
9174                                                                          ;
9175                                                                          ; (S R) = YY(1 0) = y - (A P)
9176               
9177 2C2A D800  30        movb ra,@YY+1                   ; STA YY+1          ; First we do the low bytes with:
     2C2C 0027     
9178 2C2E D022  34        movb @SYL(ry),ra                ; LDA SYL,Y         ;
     2C30 0ED5     
9179                      .sbc @P,ra                      ; SBC P             ; YY+1 = A
     **** ****     > SBC
0001 2C32 1801  14        joc  !
0002 2C34 7004  18        sb   rone,ra
0003               !:
0004 2C36 7020  30        sb   @P,ra
     2C38 001B     
                   < elite.a99
9180 2C3A D800  30        movb ra,@YY                     ; STA YY            ; R = YY = y_lo - P
     2C3C 0026     
9181 2C3E D800  30        movb ra,@R                      ; STA R             ;
     2C40 0091     
9182                                                                          ; so we get this:
9183                                                                          ;
9184                                                                          ; (? R) = YY(1 0) = y_lo - (A P)
9185               
9186 2C42 D020  30        movb @Y1,ra                     ; LDA Y1            ; And then we do the high bytes with:
     2C44 0032     
9187                      .sbc @YY+1,ra                   ; SBC YY+1          ;
     **** ****     > SBC
0001 2C46 1801  14        joc  !
0002 2C48 7004  18        sb   rone,ra
0003               !:
0004 2C4A 7020  30        sb   @YY+1,ra
     2C4C 0027     
                   < elite.a99
9188 2C4E D800  30        movb ra,@YY+1                   ; STA YY+1          ; S = YY+1 = y_hi - YY+1
     2C50 0027     
9189 2C52 D800  30        movb ra,@S                      ; STA S             ;
     2C54 0092     
9190                                                                          ; so we get our result:
9191                                                                          ;
9192                                                                          ; (S R) = YY(1 0) = (y_hi y_lo) - (A P)
9193                                                                          ; = y - |y_hi| * Q
9194                                                                          ;
9195                                                                          ; which is result 3 above, and (S R) is set to the new
9196                                                                          ; value of y
9197               
9198 2C56 D022  34        movb @SZL(ry),ra                ; LDA SZL,Y         ; We now calculate the following:
     2C58 0EFB     
9199                      .adc @DELT4,ra                  ; ADC DELT4         ;
     **** ****     > ADC
0001 2C5A 1701  14        jnc  !
0002 2C5C B004  18        ab   rone,ra
0003               !:
0004 2C5E B020  30        ab   @DELT4,ra
     2C60 008D     
                   < elite.a99
9200 2C62 D880  38        movb ra,@SZL(ry)                ; STA SZL,Y         ; (z_hi z_lo) = (z_hi z_lo) + DELT4(1 0)
     2C64 0EFB     
9201                                                                          ;
9202                                                                          ; starting with the low bytes
9203               
9204 2C66 D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; And then we do the high bytes
     2C68 0EE8     
9205 2C6A D800  30        movb ra,@ZZ                     ; STA ZZ            ;
     2C6C 0097     
9206                      .adc @DELT4+1,ra                ; ADC DELT4+1       ; We also set ZZ to the original value of z_hi, which we
     **** ****     > ADC
0001 2C6E 1701  14        jnc  !
0002 2C70 B004  18        ab   rone,ra
0003               !:
0004 2C72 B020  30        ab   @DELT4+1,ra
     2C74 008E     
                   < elite.a99
9207 2C76 D880  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; use below to remove the existing particle
     2C78 0EE8     
9208                                                                          ;
9209                                                                          ; So now we have result 4 above:
9210                                                                          ;
9211                                                                          ; z = z + DELT4(1 0)
9212                                                                          ; = z + speed * 64
9213               
9214 2C7A D020  30        movb @XX+1,ra                   ; LDA XX+1          ; EOR x with the correct sign of the roll angle alpha,
     2C7C 0025     
9215                      .eor @ALP2                      ; EOR ALP2          ; so A has the opposite sign to the roll angle alpha
     **** ****     > EOR
0001 2C7E D1A0  30        movb @ALP2,rtmp
     2C80 0088     
0002 2C82 2806  18        xor  rtmp,ra
                   < elite.a99
9216               
9217 2C84 0206  20        li   rtmp,MLS1                  ; JSR MLS1          ; Call MLS1 to calculate:
     2C86 41EE     
9218 2C88 06A0  28        bl   @jsr                       ;
     2C8A 8002     
9219                                                                          ;
9220                                                                          ; (A P) = A * ALP1
9221                                                                          ; = (-x / 256) * alpha
9222               
9223 2C8C 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2C8E 44BA     
9224 2C90 06A0  28        bl   @jsr                       ;
     2C92 8002     
9225                                                                          ;
9226                                                                          ; (A X) = (A P) + (S R)
9227                                                                          ; = (-x / 256) * alpha + y
9228                                                                          ; = y - alpha * x / 256
9229               
9230 2C94 D800  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY(1 0) = (A X) to give:
     2C96 0027     
9231 2C98 D801  30        movb rx,@YY                     ; STX YY            ;
     2C9A 0026     
9232                                                                          ; YY(1 0) = y - alpha * x / 256
9233                                                                          ;
9234                                                                          ; which is result 5 above, and we also have:
9235                                                                          ;
9236                                                                          ; A = YY+1 = y - alpha * x / 256
9237                                                                          ;
9238                                                                          ; i.e. A is the new value of y, divided by 256
9239               
9240                      .eor @ALP2+1                    ; EOR ALP2+1        ; EOR with the flipped sign of the roll angle alpha, so
     **** ****     > EOR
0001 2C9C D1A0  30        movb @ALP2+1,rtmp
     2C9E 0089     
0002 2CA0 2806  18        xor  rtmp,ra
                   < elite.a99
9241                                                                          ; A has the opposite sign to the flipped roll angle
9242                                                                          ; alpha, i.e. it gets the same sign as alpha
9243               
9244 2CA2 0206  20        li   rtmp,MLS2                  ; JSR MLS2          ; Call MLS2 to calculate:
     2CA4 41DE     
9245 2CA6 06A0  28        bl   @jsr                       ;
     2CA8 8002     
9246                                                                          ;
9247                                                                          ; (S R) = XX(1 0)
9248                                                                          ; = x
9249                                                                          ;
9250                                                                          ; (A P) = A * ALP1
9251                                                                          ; = y / 256 * alpha
9252               
9253 2CAA 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2CAC 44BA     
9254 2CAE 06A0  28        bl   @jsr                       ;
     2CB0 8002     
9255                                                                          ;
9256                                                                          ; (A X) = (A P) + (S R)
9257                                                                          ; = y / 256 * alpha + x
9258               
9259 2CB2 D800  30        movb ra,@XX+1                   ; STA XX+1          ; Set XX(1 0) = (A X), which gives us result 6 above:
     2CB4 0025     
9260 2CB6 D801  30        movb rx,@XX                     ; STX XX            ;
     2CB8 0024     
9261                                                                          ; x = x + alpha * y / 256
9262               
9263 2CBA D020  30        movb @YY+1,ra                   ; LDA YY+1          ; Set A to y_hi and set it to the flipped sign of beta
     2CBC 0027     
9264                      .eor @BET2+1                    ; EOR BET2+1
     **** ****     > EOR
0001 2CBE D1A0  30        movb @BET2+1,rtmp
     2CC0 008B     
0002 2CC2 2806  18        xor  rtmp,ra
                   < elite.a99
9265               
9266 2CC4 D060  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the pitch magnitude into X
     2CC6 002B     
9267               
9268 2CC8 0206  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     2CCA 41F4     
9269 2CCC 06A0  28        bl   @jsr                       ;
     2CCE 8002     
9270                                                                          ;
9271                                                                          ; (A P) = X * A
9272                                                                          ; = beta * y_hi
9273               
9274 2CD0 D800  30        movb ra,@Q                      ; STA Q             ; Store the high byte of the result in Q, so:
     2CD2 0090     
9275                                                                          ;
9276                                                                          ; Q = beta * y_hi / 256
9277               
9278 2CD4 D020  30        movb @XX+1,ra                   ; LDA XX+1          ; Set S = x_hi
     2CD6 0025     
9279 2CD8 D800  30        movb ra,@S                      ; STA S
     2CDA 0092     
9280               
9281                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A, so A now contains -x
     **** ****     > EOI
0001 2CDC 0206  20        li   rtmp,(>80*256)
     2CDE 8000     
0002 2CE0 2806  18        xor  rtmp,ra
                   < elite.a99
9282               
9283 2CE2 0206  20        li   rtmp,MUT1                  ; JSR MUT1          ; Call MUT1 to calculate:
     2CE4 43EC     
9284 2CE6 06A0  28        bl   @jsr                       ;
     2CE8 8002     
9285                                                                          ;
9286                                                                          ; R = XX = x_lo
9287                                                                          ;
9288                                                                          ; (A P) = Q * A
9289                                                                          ; = (beta * y_hi / 256) * (-beta * y_hi / 256)
9290                                                                          ; = (-beta * y / 256) ^ 2
9291               
9292                      .asl @P                         ; ASL P             ; Double (A P), store the top byte in A and set the C
     **** ****     > ASL
0001 2CEA D1A0  30        movb @P,rtmp
     2CEC 001B     
0002 2CEE 0246  22        andi rtmp,>ff00
     2CF0 FF00     
0003 2CF2 0A16  18        sla  rtmp,1
0004 2CF4 D806  30        movb rtmp,@P
     2CF6 001B     
                   < elite.a99
9293 2CF8 06A0  28        bl   @rola                      ; ROL A             ; flag to bit 7 of the original A, so this does:
     2CFA 8018     
9294 2CFC D800  30        movb ra,@T                      ; STA T             ;
     2CFE 00D1     
9295                                                                          ; (T P) = (A P) << 1
9296                                                                          ; = 2 * (-beta * y / 256) ^ 2
9297               
9298 2D00 0200  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 in A to the sign bit from the A in the
     2D02 0000     
9299 2D04 06A0  28        bl   @rora                      ; ROR A             ; calculation above and apply it to T, so we now have:
     2D06 803C     
9300 2D08 F020  30        socb @T,ra                      ; ORA T             ;
     2D0A 00D1     
9301                                                                          ; (A P) = -2 * (beta * y / 256) ^ 2
9302                                                                          ;
9303                                                                          ; with the doubling retaining the sign of (A P)
9304               
9305 2D0C 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2D0E 44BA     
9306 2D10 06A0  28        bl   @jsr                       ;
     2D12 8002     
9307                                                                          ;
9308                                                                          ; (A X) = (A P) + (S R)
9309                                                                          ; = -2 * (beta * y / 256) ^ 2 + x
9310               
9311 2D14 D800  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     2D16 0025     
9312               
9313 2D18 D001  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
9314 2D1A D880  38        movb ra,@SXL(ry)                ; STA SXL,Y
     2D1C 035F     
9315               
9316                                                                          ; So (XX+1 x_lo) now contains:
9317                                                                          ;
9318                                                                          ; x = x - 2 * (beta * y / 256) ^ 2
9319                                                                          ;
9320                                                                          ; which is result 7 above
9321               
9322 2D1E D020  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0) = y
     2D20 0026     
9323 2D22 D800  30        movb ra,@R                      ; STA R
     2D24 0091     
9324 2D26 D020  30        movb @YY+1,ra                   ; LDA YY+1
     2D28 0027     
9325 2D2A D800  30        movb ra,@S                      ; STA S
     2D2C 0092     
9326               
9327               * EOR #128               \ These instructions are commented out in the original
9328               * JSR MAD                \ source
9329               * STA S
9330               * STX R
9331               
9332 2D2E 0200  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     2D30 0000     
9333 2D32 D800  30        movb ra,@P                      ; STA P
     2D34 001B     
9334               
9335 2D36 D020  30        movb @BETA,ra                   ; LDA BETA          ; Set A = beta, so (A P) = (beta 0) = beta * 256
     2D38 002A     
9336               
9337 2D3A 0206  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     2D3C 275A     
9338 2D3E 06A0  28        bl   @jsr                       ;
     2D40 8002     
9339                                                                          ;
9340                                                                          ; (YY+1 y_lo) = (A P) + (S R)
9341                                                                          ; = beta * 256 + y
9342                                                                          ;
9343                                                                          ; i.e. y = y + beta * 256, which is result 8 above
9344                                                                          ;
9345                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
9346                                                                          ; ZZ, which will remove the old stardust particle, as we
9347                                                                          ; set X1, Y1 and ZZ to the original values for this
9348                                                                          ; particle during the calculations above
9349               
9350                                                                          ; We now have our newly moved stardust particle at
9351                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
9352                                                                          ; and distance z_hi, so we draw it if it's still on
9353                                                                          ; screen, otherwise we recycle it as a new bit of
9354                                                                          ; stardust and draw that
9355               
9356 2D42 D020  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     2D44 0025     
9357 2D46 D800  30        movb ra,@X1                     ; STA X1            ; the new x-coordinate is in (x_hi x_lo) and the high
     2D48 0031     
9358 2D4A D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; byte is in X1
     2D4C 034C     
9359               
9360 2D4E D020  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     2D50 0027     
9361 2D52 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     2D54 0EC2     
9362 2D56 D800  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     2D58 0032     
9363               
9364 2D5A 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 110 then jump to KILL6 to recycle this
     2D5C 7F00     
9365 2D5E 0280  22        ci   ra,>6e*256                 ; CMP #110          ; particle, as it's gone off the top or bottom of the
     2D60 6E00     
9366 2D62 1811  14        joc  KILL6                      ; BCS KILL6         ; screen, and rejoin at STC6 with the new particle
9367               
9368 2D64 D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; If z_hi >= 160 then jump to KILL6 to recycle this
     2D66 0EE8     
9369 2D68 0280  22        ci   ra,>a0*256                 ; CMP #160          ; particle, as it's so far away that it's too far to
     2D6A A000     
9370 2D6C 180C  14        joc  KILL6                      ; BCS KILL6         ; see, and rejoin at STC1 with the new particle
9371               
9372 2D6E D800  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the z-coordinate in z_hi
     2D70 0097     
9373               
9374               STC6:
9375 2D72 0206  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     2D74 276C     
9376 2D76 06A0  28        bl   @jsr                       ;
     2D78 8002     
9377                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
9378                                                                          ; with distance z_hi
9379               
9380 2D7A 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
9381                                                                          ; stardust particle
9382               
9383 2D7C 1302  14        jeq  ST3                        ; BEQ ST3           ; If we have just done the last particle, skip the next
9384                                                                          ; instruction to return from the subroutine
9385               
9386 2D7E 0460  28        b    @STL6                      ; JMP STL6          ; We have more stardust to process, so jump back up to
     2D80 2BBE     
9387                                                                          ; STL6 for the next particle
9388               
9389               ST3:
9390 2D82 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     2D84 800E     
9391               
9392               KILL6:
9393 2D86 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2D88 8070     
9394 2D8A 06A0  28        bl   @jsr                       ;
     2D8C 8002     
9395               
9396 2D8E 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit of A to get |A|
     2D90 7F00     
9397               
9398                      .adi (>0a*256)                  ; ADC #10           ; Make sure A is at least 10 and store it in z_hi and
     **** ****     > ADI
0001 2D92 1701  14        jnc  !
0002 2D94 B004  18        ab   rone,ra
0003               !:
0004 2D96 0220  22        ai   ra,(>0A*256)
     2D98 0A00     
                   < elite.a99
9399 2D9A D880  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; ZZ, so the new particle starts close to us
     2D9C 0EE8     
9400 2D9E D800  30        movb ra,@ZZ                     ; STA ZZ
     2DA0 0097     
9401               
9402 2DA2 0910  18        srl  ra,1                       ; LSR A             ; Divide A by 2 and randomly set the C flag
9403               
9404 2DA4 1813  14        joc  ST4                        ; BCS ST4           ; Jump to ST4 half the time
9405               
9406 2DA6 0910  18        srl  ra,1                       ; LSR A             ; Randomly set the C flag again
9407               
9408 2DA8 0200  20        li   ra,>fc*256                 ; LDA #252          ; Set A to either +126 or -126 (252 >> 1) depending on
     2DAA FC00     
9409 2DAC 06A0  28        bl   @rora                      ; ROR A             ; the C flag, as this is a sign-magnitude number with
     2DAE 803C     
9410                                                                          ; the C flag rotated into its sign bit
9411               
9412 2DB0 D800  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to A, so this particle starts on
     2DB2 0031     
9413 2DB4 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; either the left or right edge of the screen
     2DB6 034C     
9414               
9415 2DB8 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2DBA 8070     
9416 2DBC 06A0  28        bl   @jsr                       ;
     2DBE 8002     
9417               
9418 2DC0 D800  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to random numbers, so the particle
     2DC2 0032     
9419 2DC4 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; starts anywhere along either the left or right edge
     2DC6 0EC2     
9420               
9421 2DC8 0460  28        b    @STC6                      ; JMP STC6          ; Jump up to STC6 to draw this new particle
     2DCA 2D72     
9422               
9423               ST4:
9424 2DCC 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2DCE 8070     
9425 2DD0 06A0  28        bl   @jsr                       ;
     2DD2 8002     
9426               
9427 2DD4 D800  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to random numbers, so the particle
     2DD6 0031     
9428 2DD8 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; starts anywhere along the x-axis
     2DDA 034C     
9429               
9430 2DDC 0910  18        srl  ra,1                       ; LSR A             ; Randomly set the C flag
9431               
9432 2DDE 0200  20        li   ra,>e6*256                 ; LDA #230          ; Set A to either +115 or -115 (230 >> 1) depending on
     2DE0 E600     
9433 2DE2 06A0  28        bl   @rora                      ; ROR A             ; the C flag, as this is a sign-magnitude number with
     2DE4 803C     
9434                                                                          ; the C flag rotated into its sign bit
9435               
9436 2DE6 D800  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to A, so the particle starts anywhere
     2DE8 0032     
9437 2DEA D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; along either the top or bottom edge of the screen
     2DEC 0EC2     
9438               
9439 2DEE 16C1  14        jne  STC6                       ; BNE STC6          ; Jump up to STC6 to draw this new particle (this BNE is
9440                                                                          ; effectively a JMP as A will never be zero)
9441               
9442               * ******************************************************************************
9443               *
9444               * Name: PRXS
9445               * Type: Variable
9446               * Category: Equipment
9447               * Summary: Equipment prices
9448               *
9449               * ------------------------------------------------------------------------------
9450               *
9451               * Equipment prices are stored as 10 * the actual value, so we can support prices
9452               * with fractions of credits (0.1 Cr). This is used for the price of fuel only.
9453               *
9454               * ******************************************************************************
9455               
9456               PRXS:
9457 2DF0 0100            data >0100                                          ; 0  Fuel, calculated in EQSHP  140.0 Cr (full tank)
9458 2DF2 2C01            data >2c01                                          ; 1  Missile                     30.0 Cr
9459 2DF4 A00F            data >a00f                                          ; 2  Large Cargo Bay            400.0 Cr
9460 2DF6 7017            data >7017                                          ; 3  E.C.M. System              600.0 Cr
9461 2DF8 A00F            data >a00f                                          ; 4  Extra Pulse Lasers         400.0 Cr
9462 2DFA 1027            data >1027                                          ; 5  Extra Beam Lasers         1000.0 Cr
9463 2DFC 8214            data >8214                                          ; 6  Fuel Scoops                525.0 Cr
9464 2DFE 1027            data >1027                                          ; 7  Escape Pod                1000.0 Cr
9465 2E00 2823            data >2823                                          ; 8  Energy Bomb                900.0 Cr
9466 2E02 983A            data >983a                                          ; 9  Energy Unit               1500.0 Cr
9467 2E04 1027            data >1027                                          ; 10 Docking Computer          1000.0 Cr
9468 2E06 50C3            data >50c3                                          ; 11 Galactic Hyperspace       5000.0 Cr
9469               
9470               * ******************************************************************************
9471               *
9472               * Name: STATUS
9473               * Type: Subroutine
9474               * Category: Status
9475               * Summary: Show the Status Mode screen (red key f8)
9476               * Deep dive: Combat rank
9477               *
9478               * ******************************************************************************
9479               
9480               st4_:
9481                                                                          ; We call this from st5 below with the high byte of the
9482                                                                          ; kill tally in A, which is non-zero, and want to return
9483                                                                          ; with the following in X, depending on our rating:
9484                                                                          ;
9485                                                                          ; Competent = 6
9486                                                                          ; Dangerous = 7
9487                                                                          ; Deadly    = 8
9488                                                                          ; Elite     = 9
9489                                                                          ;
9490                                                                          ; The high bytes of the top tier ratings are as follows,
9491                                                                          ; so this a relatively simple calculation:
9492                                                                          ;
9493                                                                          ; Competent       = 1 to 2
9494                                                                          ; Dangerous       = 2 to 9
9495                                                                          ; Deadly          = 10 to 24
9496                                                                          ; Elite           = 25 and up
9497 2E08 0201  20        li   rx,>09*256                 ; LDX #9            ; Set X to 9 for an Elite rating
     2E0A 0900     
9498               
9499 2E0C 0280  22        ci   ra,>19*256                 ; CMP #25           ; If A >= 25, jump to st3 to print out our rating, as we
     2E0E 1900     
9500 2E10 185C  14        joc  st3_                       ; BCS st3           ; are Elite
9501               
9502 2E12 7044  18        sb   rone,rx                    ; DEX               ; Decrement X to 8 for a Deadly rating
9503               
9504 2E14 0280  22        ci   ra,>0a*256                 ; CMP #10           ; If A >= 10, jump to st3 to print out our rating, as we
     2E16 0A00     
9505 2E18 1858  14        joc  st3_                       ; BCS st3           ; are Deadly
9506               
9507 2E1A 7044  18        sb   rone,rx                    ; DEX               ; Decrement X to 7 for a Dangerous rating
9508               
9509 2E1C 0280  22        ci   ra,>02*256                 ; CMP #2            ; If A >= 2, jump to st3 to print out our rating, as we
     2E1E 0200     
9510 2E20 1854  14        joc  st3_                       ; BCS st3           ; are Dangerous
9511               
9512 2E22 7044  18        sb   rone,rx                    ; DEX               ; Decrement X to 6 for a Competent rating
9513               
9514 2E24 1652  14        jne  st3_                       ; BNE st3           ; Jump to st3 to print out our rating, as we are
9515                                                                          ; Competent (this BNE is effectively a JMP as A will
9516                                                                          ; never be zero)
9517               
9518               STATUS:
9519 2E26 0200  20        li   ra,>08*256                 ; LDA #8            ; Clear the top part of the screen, draw a white border,
     2E28 0800     
9520 2E2A 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 8 (Status
     2E2C 4B2A     
9521 2E2E 06A0  28        bl   @jsr                       ;
     2E30 8002     
9522                                                                          ; Mode screen)
9523               
9524 2E32 0206  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     2E34 5AB8     
9525 2E36 06A0  28        bl   @jsr                       ;
     2E38 8002     
9526                                                                          ; (QQ9, QQ10)
9527               
9528 2E3A 0200  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     2E3C 0700     
9529 2E3E D800  30        movb ra,@XC                     ; STA XC
     2E40 002C     
9530               
9531 2E42 0200  20        li   ra,>7e*256                 ; LDA #126          ; Print recursive token 126, which prints the top
     2E44 7E00     
9532 2E46 0206  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; four lines of the Status Mode screen:
     2E48 25B0     
9533 2E4A 06A0  28        bl   @jsr                       ;
     2E4C 8002     
9534                                                                          ;
9535                                                                          ; COMMANDER {commander name}
9536                                                                          ;
9537                                                                          ;
9538                                                                          ; Present System      : {current system name}
9539                                                                          ; Hyperspace System   : {selected system name}
9540                                                                          ; Condition           :
9541                                                                          ;
9542                                                                          ; and draw a horizontal line at pixel row 19 to box
9543                                                                          ; in the title
9544               
9545 2E4E 0200  20        li   ra,>0f*256                 ; LDA #15           ; Set A to token 129 ("{sentence case}DOCKED")
     2E50 0F00     
9546               
9547 2E52 D0A0  30        movb @QQ12,ry                   ; LDY QQ12          ; Fetch the docked status from QQ12, and if we are
     2E54 009F     
9548 2E56 160F  14        jne  st6_                       ; BNE st6           ; docked, jump to st6 to print "Docked" for our
9549                                                                          ; ship's condition
9550               
9551 2E58 0200  20        li   ra,>e6*256                 ; LDA #230          ; Otherwise we are in space, so start off by setting A
     2E5A E600     
9552                                                                          ; to token 70 ("GREEN")
9553               
9554 2E5C D0A0  30        movb @MANY+AST,ry               ; LDY MANY+AST      ; Set Y to the number of asteroids in our local bubble
     2E5E 0D57     
9555                                                                          ; of universe
9556               
9557 2E60 D062  34        movb @FRIN+2(ry),rx             ; LDX FRIN+2,Y      ; The ship slots at FRIN are ordered with the first two
     2E62 0D42     
9558                                                                          ; slots reserved for the planet and sun/space station,
9559                                                                          ; and then any ships, so if the slot at FRIN+2+Y is not
9560                                                                          ; empty (i.e. is non-zero), then that means the number
9561                                                                          ; of non-asteroids in the vicinity is at least 1
9562               
9563 2E64 1308  14        jeq  st6_                       ; BEQ st6           ; So if X = 0, there are no ships in the vicinity, so
9564                                                                          ; jump to st6 to print "Green" for our ship's condition
9565               
9566 2E66 D0A0  30        movb @ENERGY,ry                 ; LDY ENERGY        ; Otherwise we have ships in the vicinity, so we load
     2E68 0F13     
9567                                                                          ; our energy levels into Y
9568               
9569 2E6A 0282  22        ci   ry,>80*256                 ; CPY #128          ; Set the C flag if Y >= 128, so C is set if we have
     2E6C 8000     
9570                                                                          ; more than half of our energy banks charged
9571               
9572                      .adi (>01*256)                  ; ADC #1            ; Add 1 + C to A, so if C is not set (i.e. we have low
     **** ****     > ADI
0001 2E6E 1701  14        jnc  !
0002 2E70 B004  18        ab   rone,ra
0003               !:
0004 2E72 0220  22        ai   ra,(>01*256)
     2E74 0100     
                   < elite.a99
9573                                                                          ; energy levels) then A is set to token 231 ("RED"),
9574                                                                          ; and if C is set (i.e. we have healthy energy levels)
9575                                                                          ; then A is set to token 232 ("YELLOW")
9576               
9577               st6_:
9578 2E76 0206  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A (which contains our ship's
     2E78 66C4     
9579 2E7A 06A0  28        bl   @jsr                       ;
     2E7C 8002     
9580                                                                          ; condition) followed by a newline
9581               
9582 2E7E 0200  20        li   ra,>7d*256                 ; LDA #125          ; Print recursive token 125, which prints the next
     2E80 7D00     
9583 2E82 0206  20        li   rtmp,spc_                  ; JSR spc           ; three lines of the Status Mode screen:
     2E84 4EFE     
9584 2E86 06A0  28        bl   @jsr                       ;
     2E88 8002     
9585                                                                          ;
9586                                                                          ; Fuel: {fuel level} Light Years
9587                                                                          ; Cash: {cash} Cr
9588                                                                          ; Legal Status:
9589                                                                          ;
9590                                                                          ; followed by a space
9591               
9592 2E8A 0200  20        li   ra,>13*256                 ; LDA #19           ; Set A to token 133 ("CLEAN")
     2E8C 1300     
9593               
9594 2E8E D0A0  30        movb @FIST,ry                   ; LDY FIST          ; Fetch our legal status, and if it is 0, we are clean,
     2E90 0334     
9595 2E92 1306  14        jeq  st5_                       ; BEQ st5           ; so jump to st5 to print "Clean"
9596               
9597 2E94 0282  22        ci   ry,>32*256                 ; CPY #50           ; Set the C flag if Y >= 50, so C is set if we have
     2E96 3200     
9598                                                                          ; a legal status of 50+ (i.e. we are a fugitive)
9599               
9600                      .adi (>01*256)                  ; ADC #1            ; Add 1 + C to A, so if C is not set (i.e. we have a
     **** ****     > ADI
0001 2E98 1701  14        jnc  !
0002 2E9A B004  18        ab   rone,ra
0003               !:
0004 2E9C 0220  22        ai   ra,(>01*256)
     2E9E 0100     
                   < elite.a99
9601                                                                          ; legal status between 1 and 49) then A is set to token
9602                                                                          ; 134 ("OFFENDER"), and if C is set (i.e. we have a
9603                                                                          ; legal status of 50+) then A is set to token 135
9604                                                                          ; ("FUGITIVE")
9605               
9606               st5_:
9607 2EA0 0206  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A (which contains our legal
     2EA2 66C4     
9608 2EA4 06A0  28        bl   @jsr                       ;
     2EA6 8002     
9609                                                                          ; status) followed by a newline
9610               
9611 2EA8 0200  20        li   ra,>10*256                 ; LDA #16           ; Print recursive token 130 ("RATING:") followed by a
     2EAA 1000     
9612 2EAC 0206  20        li   rtmp,spc_                  ; JSR spc           ; space
     2EAE 4EFE     
9613 2EB0 06A0  28        bl   @jsr                       ;
     2EB2 8002     
9614               
9615 2EB4 D020  30        movb @TALLY+1,ra                ; LDA TALLY+1       ; Fetch the high byte of the kill tally, and if it is
     2EB6 0348     
9616 2EB8 16A7  14        jne  st4_                       ; BNE st4           ; not zero, then we have more than 256 kills, so jump
9617                                                                          ; to st4 to work out whether we are Competent,
9618                                                                          ; Dangerous, Deadly or Elite
9619               
9620                                                                          ; Otherwise we have fewer than 256 kills, so we are one
9621                                                                          ; of Harmless, Mostly Harmless, Poor, Average or Above
9622                                                                          ; Average
9623               
9624 2EBA D040  18        movb ra,rx                      ; TAX               ; Set X to 0 (as A is 0)
9625               
9626 2EBC D020  30        movb @TALLY,ra                  ; LDA TALLY         ; Set A = lower byte of tally / 4
     2EBE 0347     
9627 2EC0 0910  18        srl  ra,1                       ; LSR A
9628 2EC2 0910  18        srl  ra,1                       ; LSR A
9629               
9630               st5L:
9631                                                                          ; We now loop through bits 2 to 7, shifting each of them
9632                                                                          ; off the end of A until there are no set bits left, and
9633                                                                          ; incrementing X for each shift, so at the end of the
9634                                                                          ; process, X contains the position of the leftmost 1 in
9635                                                                          ; A. Looking at the rank values in TALLY:
9636                                                                          ;
9637                                                                          ; Harmless        = %00000000 to %00000011
9638                                                                          ; Mostly Harmless = %00000100 to %00000111
9639                                                                          ; Poor            = %00001000 to %00001111
9640                                                                          ; Average         = %00010000 to %00011111
9641                                                                          ; Above Average   = %00100000 to %11111111
9642                                                                          ;
9643                                                                          ; we can see that the values returned by this process
9644                                                                          ; are:
9645                                                                          ;
9646                                                                          ; Harmless        = 1
9647                                                                          ; Mostly Harmless = 2
9648                                                                          ; Poor            = 3
9649                                                                          ; Average         = 4
9650                                                                          ; Above Average   = 5
9651 2EC4 B044  18        ab   rone,rx                    ; INX               ; Increment X for each shift
9652               
9653 2EC6 0910  18        srl  ra,1                       ; LSR A             ; Shift A to the right
9654               
9655 2EC8 16FD  14        jne  st5L                       ; BNE st5L          ; Keep looping around until A = 0, which means there are
9656                                                                          ; no set bits left in A
9657               
9658               st3_:
9659 2ECA D001  18        movb rx,ra                      ; TXA               ; A now contains our rating as a value of 1 to 9, so
9660                                                                          ; transfer X to A, so we can print it out
9661               
9662                      .clc                            ; CLC               ; Print recursive token 135 + A, which will be in the
     **** ****     > CLC
0001 2ECC 0A13  18        sla  rzero,1
                   < elite.a99
9663                      .adi (>15*256)                  ; ADC #21           ; range 136 ("HARMLESS") to 144 ("---- E L I T E ----")
     **** ****     > ADI
0001 2ECE 1701  14        jnc  !
0002 2ED0 B004  18        ab   rone,ra
0003               !:
0004 2ED2 0220  22        ai   ra,(>15*256)
     2ED4 1500     
                   < elite.a99
9664 2ED6 0206  20        li   rtmp,plf_                  ; JSR plf           ; followed by a newline
     2ED8 66C4     
9665 2EDA 06A0  28        bl   @jsr                       ;
     2EDC 8002     
9666               
9667 2EDE 0200  20        li   ra,>12*256                 ; LDA #18           ; Print recursive token 132, which prints the next bit
     2EE0 1200     
9668 2EE2 0206  20        li   rtmp,plf2_                 ; JSR plf2          ; of the Status Mode screen:
     2EE4 2F94     
9669 2EE6 06A0  28        bl   @jsr                       ;
     2EE8 8002     
9670                                                                          ;
9671                                                                          ; EQUIPMENT:
9672                                                                          ;
9673                                                                          ; followed by a newline and an indent of 6 characters
9674               
9675 2EEA D020  30        movb @CRGO,ra                   ; LDA CRGO          ; If our ship's cargo capacity is < 26 (i.e. we do not
     2EEC 0316     
9676 2EEE 0280  22        ci   ra,>1a*256                 ; CMP #26           ; have a cargo bay extension), skip the following two
     2EF0 1A00     
9677 2EF2 1706  14        jnc  B19                        ; BCC B19           ; instructions
9678               
9679 2EF4 0200  20        li   ra,>6b*256                 ; LDA #107          ; We do have a cargo bay extension, so print recursive
     2EF6 6B00     
9680 2EF8 0206  20        li   rtmp,plf2_                 ; JSR plf2          ; token 107 ("LARGE CARGO{sentence case} BAY"), followed
     2EFA 2F94     
9681 2EFC 06A0  28        bl   @jsr                       ;
     2EFE 8002     
9682                                                                          ; by a newline and an indent of 6 characters
9683               
9684               B19:
9685 2F00 D020  30        movb @BST,ra                    ; LDA BST           ; If we don't have fuel scoops fitted, skip the
     2F02 0329     
9686 2F04 1306  14        jeq  B20                        ; BEQ B20           ; following two instructions
9687               
9688 2F06 0200  20        li   ra,>6f*256                 ; LDA #111          ; We do have fuel scoops fitted, so print recursive
     2F08 6F00     
9689 2F0A 0206  20        li   rtmp,plf2_                 ; JSR plf2          ; token 111 ("FUEL SCOOPS"), followed by a newline and
     2F0C 2F94     
9690 2F0E 06A0  28        bl   @jsr                       ;
     2F10 8002     
9691                                                                          ; an indent of 6 characters
9692               
9693               B20:
9694 2F12 D020  30        movb @ECM,ra                    ; LDA ECM           ; If we don't have an E.C.M. fitted, skip the following
     2F14 0328     
9695 2F16 1306  14        jeq  B21                        ; BEQ B21           ; two instructions
9696               
9697 2F18 0200  20        li   ra,>6c*256                 ; LDA #108          ; We do have an E.C.M. fitted, so print recursive token
     2F1A 6C00     
9698 2F1C 0206  20        li   rtmp,plf2_                 ; JSR plf2          ; 108 ("E.C.M.SYSTEM"), followed by a newline and an
     2F1E 2F94     
9699 2F20 06A0  28        bl   @jsr                       ;
     2F22 8002     
9700                                                                          ; indent of 6 characters
9701               
9702               B21:
9703 2F24 0200  20        li   ra,>71*256                 ; LDA #113          ; We now cover the four pieces of equipment whose flags
     2F26 7100     
9704 2F28 D800  30        movb ra,@XX4                    ; STA XX4           ; are stored in BOMB through BOMB+3, and whose names
     2F2A 00A7     
9705                                                                          ; correspond with text tokens 113 through 116:
9706                                                                          ;
9707                                                                          ; BOMB+0 = BOMB  = token 113 = Energy bomb
9708                                                                          ; BOMB+1 = ENGY  = token 114 = Energy unit
9709                                                                          ; BOMB+2 = DKCMP = token 115 = Docking computer
9710                                                                          ; BOMB+3 = GHYP  = token 116 = Galactic hyperdrive
9711                                                                          ;
9712                                                                          ; We can print these out using a loop, so we set XX4 to
9713                                                                          ; 113 as a counter (and we also set A as well, to pass
9714                                                                          ; through to plf2)
9715               
9716               stqv_:
9717 2F2C D080  18        movb ra,ry                      ; TAY               ; Fetch byte BOMB+0 through BOMB+4 for values of XX4
9718 2F2E D062  34        movb @BOMB-113(ry),rx           ; LDX BOMB-113,Y    ; from 113 through 117
     2F30 02B9     
9719               
9720 2F32 1304  14        jeq  B22                        ; BEQ B22           ; If it is zero then we do not own that piece of
9721                                                                          ; equipment, so skip the next instruction
9722               
9723 2F34 0206  20        li   rtmp,plf2_                 ; JSR plf2          ; Print the recursive token in A from 113 ("ENERGY
     2F36 2F94     
9724 2F38 06A0  28        bl   @jsr                       ;
     2F3A 8002     
9725                                                                          ; BOMB") through 116 ("GALACTIC HYPERSPACE "), followed
9726                                                                          ; by a newline and an indent of 6 characters
9727               
9728               B22:
9729 2F3C B004  18        ab   rone,ra                    ; INC XX4           ; Increment the counter (and A as well)
9730 2F3E D020  30        movb @XX4,ra                    ; LDA XX4
     2F40 00A7     
9731               
9732 2F42 0280  22        ci   ra,>75*256                 ; CMP #117          ; If A < 117, loop back up to stqv to print the next
     2F44 7500     
9733 2F46 17F2  14        jnc  stqv_                      ; BCC stqv          ; piece of equipment
9734               
9735 2F48 0201  20        li   rx,>00*256                 ; LDX #0            ; Now to print our ship's lasers, so set a counter in X
     2F4A 0000     
9736                                                                          ; to count through the four views (0 = front, 1 = rear,
9737                                                                          ; 2 = left, 3 = right)
9738               
9739               st_:
9740 2F4C D801  30        movb rx,@CNT                    ; STX CNT           ; Store the view number in CNT
     2F4E 00A4     
9741               
9742 2F50 D0A1  34        movb @LASER(rx),ry              ; LDY LASER,X       ; Fetch the laser power for view X, and if we do not
     2F52 0310     
9743 2F54 1317  14        jeq  st1_                       ; BEQ st1           ; have a laser fitted to that view, jump to st1 to move
9744                                                                          ; on to the next one
9745               
9746 2F56 D001  18        movb rx,ra                      ; TXA               ; Print recursive token 96 + X, which will print from 96
9747                      .clc                            ; CLC               ; ("FRONT") through to 99 ("RIGHT"), followed by a space
     **** ****     > CLC
0001 2F58 0A13  18        sla  rzero,1
                   < elite.a99
9748                      .adi (>60*256)                  ; ADC #96
     **** ****     > ADI
0001 2F5A 1701  14        jnc  !
0002 2F5C B004  18        ab   rone,ra
0003               !:
0004 2F5E 0220  22        ai   ra,(>60*256)
     2F60 6000     
                   < elite.a99
9749 2F62 0206  20        li   rtmp,spc_                  ; JSR spc
     2F64 4EFE     
9750 2F66 06A0  28        bl   @jsr                       ;
     2F68 8002     
9751               
9752 2F6A 0200  20        li   ra,>67*256                 ; LDA #103          ; Set A to token 103 ("PULSE LASER")
     2F6C 6700     
9753               
9754 2F6E D060  30        movb @CNT,rx                    ; LDX CNT           ; If the laser power for view X has bit 7 clear, then it
     2F70 00A4     
9755 2F72 D0A1  34        movb @LASER(rx),ry              ; LDY LASER,X       ; is a pulse laser, so skip the following instruction
     2F74 0310     
9756 2F76 1502  14        jgt  B23                        ; BPL B23
9757               
9758 2F78 0200  20        li   ra,>68*256                 ; LDA #104          ; Set A to token 104 ("BEAM LASER")
     2F7A 6800     
9759               
9760               B23:
9761 2F7C 0206  20        li   rtmp,plf2_                 ; JSR plf2          ; Print the text token in A (which contains the laser
     2F7E 2F94     
9762 2F80 06A0  28        bl   @jsr                       ;
     2F82 8002     
9763                                                                          ; type) followed by a newline and an indent of 6
9764                                                                          ; characters
9765               
9766               st1_:
9767 2F84 D060  30        movb @CNT,rx                    ; LDX CNT           ; Increment the counter in X and CNT to point to the
     2F86 00A4     
9768 2F88 B044  18        ab   rone,rx                    ; INX               ; next view
9769               
9770 2F8A 0281  22        ci   rx,>04*256                 ; CPX #4            ; If this isn't the last of the four views, jump back up
     2F8C 0400     
9771 2F8E 17DE  14        jnc  st_                        ; BCC st            ; to st to print out the next one
9772               
9773 2F90 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     2F92 800E     
9774               
9775               * ******************************************************************************
9776               *
9777               * Name: plf2
9778               * Type: Subroutine
9779               * Category: Text
9780               * Summary: Print text followed by a newline and indent of 6 characters
9781               *
9782               * ------------------------------------------------------------------------------
9783               *
9784               * Print a text token followed by a newline, and indent the next line to text
9785               * column 6.
9786               *
9787               * ------------------------------------------------------------------------------
9788               *
9789               * Arguments:
9790               *
9791               * A                   The text token to be printed
9792               *
9793               * ******************************************************************************
9794               
9795               plf2_:
9796 2F94 0206  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A followed by a newline
     2F96 66C4     
9797 2F98 06A0  28        bl   @jsr                       ;
     2F9A 8002     
9798               
9799 2F9C 0201  20        li   rx,>06*256                 ; LDX #6            ; Move the text cursor to column 6
     2F9E 0600     
9800 2FA0 D801  30        movb rx,@XC                     ; STX XC
     2FA2 002C     
9801               
9802 2FA4 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     2FA6 800E     
9803               
9804               * ******************************************************************************
9805               *
9806               * Name: TENS
9807               * Type: Variable
9808               * Category: Text
9809               * Summary: A constant used when printing large numbers in BPRNT
9810               * Deep dive: Printing decimal numbers
9811               *
9812               * ------------------------------------------------------------------------------
9813               *
9814               * Contains the four low bytes of the value 100,000,000,000 (100 billion).
9815               *
9816               * The maximum number of digits that we can print with the BPRNT routine is 11,
9817               * so the biggest number we can print is 99,999,999,999. This maximum number
9818               * plus 1 is 100,000,000,000, which in hexadecimal is:
9819               *
9820               * & 17 48 76 E8 00
9821               *
9822               * The TENS variable contains the lowest four bytes in this number, with the
9823               * most significant byte first, i.e. 48 76 E8 00. This value is used in the
9824               * BPRNT routine when working out which decimal digits to print when printing a
9825               * number.
9826               *
9827               * ******************************************************************************
9828               
9829               TENS:
9830 2FA8 0000            data >0000, >0000
     2FAA 0000     
9831               
9832               * ******************************************************************************
9833               *
9834               * Name: pr2
9835               * Type: Subroutine
9836               * Category: Text
9837               * Summary: Print an 8-bit number, left-padded to 3 digits, and optional point
9838               *
9839               * ------------------------------------------------------------------------------
9840               *
9841               * Print the 8-bit number in X to 3 digits, left-padding with spaces for numbers
9842               * with fewer than 3 digits (so numbers < 100 are right-aligned). Optionally
9843               * include a decimal point.
9844               *
9845               * ------------------------------------------------------------------------------
9846               *
9847               * Arguments:
9848               *
9849               * X                   The number to print
9850               *
9851               * C flag              If set, include a decimal point
9852               *
9853               * ------------------------------------------------------------------------------
9854               *
9855               * Other entry points:
9856               *
9857               * pr2+2               Print the 8-bit number in X to the number of digits in A
9858               *
9859               * ******************************************************************************
9860               
9861               pr2_:
9862 2FAC 0200  20        li   ra,>03*256                 ; LDA #3            ; Set A to the number of digits (3)
     2FAE 0300     
9863               
9864 2FB0 0202  20        li   ry,>00*256                 ; LDY #0            ; Zero the Y register, so we can fall through into TT11
     2FB2 0000     
9865                                                                          ; to print the 16-bit number (Y X) to 3 digits, which
9866                                                                          ; effectively prints X to 3 digits as the high byte is
9867                                                                          ; zero
9868               
9869               * ******************************************************************************
9870               *
9871               * Name: TT11
9872               * Type: Subroutine
9873               * Category: Text
9874               * Summary: Print a 16-bit number, left-padded to n digits, and optional point
9875               *
9876               * ------------------------------------------------------------------------------
9877               *
9878               * Print the 16-bit number in (Y X) to a specific number of digits, left-padding
9879               * with spaces for numbers with fewer digits (so lower numbers will be right-
9880               * aligned). Optionally include a decimal point.
9881               *
9882               * ------------------------------------------------------------------------------
9883               *
9884               * Arguments:
9885               *
9886               * X                   The low byte of the number to print
9887               *
9888               * Y                   The high byte of the number to print
9889               *
9890               * A                   The number of digits
9891               *
9892               * C flag              If set, include a decimal point
9893               *
9894               * ******************************************************************************
9895               
9896               TT11:
9897 2FB4 D800  30        movb ra,@U                      ; STA U             ; We are going to use the BPRNT routine (below) to
     2FB6 008F     
9898                                                                          ; print this number, so we store the number of digits
9899                                                                          ; in U, as that's what BPRNT takes as an argument
9900               
9901 2FB8 0200  20        li   ra,>00*256                 ; LDA #0            ; BPRNT takes a 32-bit number in K to K+3, with the
     2FBA 0000     
9902 2FBC D800  30        movb ra,@K                      ; STA K             ; most significant byte first (big-endian), so we set
     2FBE 003D     
9903 2FC0 D800  30        movb ra,@K+1                    ; STA K+1           ; the two most significant bytes to zero (K and K+1)
     2FC2 003E     
9904 2FC4 D802  30        movb ry,@K+2                    ; STY K+2           ; and store (Y X) in the least two significant bytes
     2FC6 003F     
9905 2FC8 D801  30        movb rx,@K+3                    ; STX K+3           ; (K+2 and K+3), so we are going to print the 32-bit
     2FCA 0040     
9906                                                                          ; number (0 0 Y X)
9907               
9908                                                                          ; Finally we fall through into BPRNT to print out the
9909                                                                          ; number in K to K+3, which now contains (Y X), to 3
9910                                                                          ; digits (as U = 3), using the same C flag as when pr2
9911                                                                          ; was called to control the decimal point
9912               
9913               * ******************************************************************************
9914               *
9915               * Name: BPRNT
9916               * Type: Subroutine
9917               * Category: Text
9918               * Summary: Print a 32-bit number, left-padded to a specific number of digits,
9919               * with an optional decimal point
9920               * Deep dive: Printing decimal numbers
9921               *
9922               * ------------------------------------------------------------------------------
9923               *
9924               * Print the 32-bit number stored in K(0 1 2 3) to a specific number of digits,
9925               * left-padding with spaces for numbers with fewer digits (so lower numbers are
9926               * right-aligned). Optionally include a decimal point.
9927               *
9928               * See the deep dive on "Printing decimal numbers" for details of the algorithm
9929               * used in this routine.
9930               *
9931               * ------------------------------------------------------------------------------
9932               *
9933               * Arguments:
9934               *
9935               * K(0 1 2 3)          The number to print, stored with the most significant
9936               * byte in K and the least significant in K+3 (i.e. as a
9937               * big-endian number, which is the opposite way to how the
9938               * 6502 assembler stores addresses, for example)
9939               *
9940               * U                   The maximum number of digits to print, including the
9941               * decimal point (spaces will be used on the left to pad
9942               * out the result to this width, so the number is right-
9943               * aligned to this width). U must be 11 or less
9944               *
9945               * C flag              If set, include a decimal point followed by one
9946               * fractional digit (i.e. show the number to 1 decimal
9947               * place). In this case, the number in K(0 1 2 3) contains
9948               * 10 * the number we end up printing, so to print 123.4,
9949               * we would pass 1234 in K(0 1 2 3) and would set the C
9950               * flag to include the decimal point
9951               *
9952               * ******************************************************************************
9953               
9954               BPRNT:
9955 2FCC 0201  20        li   rx,>0b*256                 ; LDX #11           ; Set T to the maximum number of digits allowed (11
     2FCE 0B00     
9956 2FD0 D801  30        movb rx,@T                      ; STX T             ; characters, which is the number of digits in 10
     2FD2 00D1     
9957                                                                          ; billion). We will use this as a flag when printing
9958                                                                          ; characters in TT37 below
9959               
9960                      .php                            ; PHP               ; Make a copy of the status register (in particular
     **** ****     > PHP
0001 2FD4 02C6  12        stst rtmp
0002 2FD6 D686  30        movb rtmp,*rsp
0003 2FD8 060A  14        dec  rsp
                   < elite.a99
9961                                                                          ; the C flag) so we can retrieve it later
9962               
9963 2FDA 1702  14        jnc  TT30                       ; BCC TT30          ; If the C flag is clear, we do not want to print a
9964                                                                          ; decimal point, so skip the next two instructions
9965               
9966 2FDC 7004  18        sb   rone,ra                    ; DEC T             ; As we are going to show a decimal point, decrement
9967 2FDE 7004  18        sb   rone,ra                    ; DEC U             ; both the number of characters and the number of
9968                                                                          ; digits (as one of them is now a decimal point)
9969               
9970               TT30:
9971 2FE0 0200  20        li   ra,>0b*256                 ; LDA #11           ; Set A to 11, the maximum number of digits allowed
     2FE2 0B00     
9972               
9973                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 2FE4 0A15  18        sla  rmone,1
                   < elite.a99
9974                                                                          ; C flag affecting the result
9975               
9976 2FE6 D800  30        movb ra,@XX17                   ; STA XX17          ; Store the maximum number of digits allowed (11) in
     2FE8 0095     
9977                                                                          ; XX17
9978               
9979                      .sbc @U,ra                      ; SBC U             ; Set U = 11 - U + 1, so U now contains the maximum
     **** ****     > SBC
0001 2FEA 1801  14        joc  !
0002 2FEC 7004  18        sb   rone,ra
0003               !:
0004 2FEE 7020  30        sb   @U,ra
     2FF0 008F     
                   < elite.a99
9980 2FF2 D800  30        movb ra,@U                      ; STA U             ; number of digits minus the number of digits we want
     2FF4 008F     
9981 2FF6 B004  18        ab   rone,ra                    ; INC U             ; to display, plus 1 (so this is the number of digits
9982                                                                          ; we should skip before starting to print the number
9983                                                                          ; itself, and the plus 1 is there to ensure we print at
9984                                                                          ; least one digit)
9985               
9986 2FF8 0202  20        li   ry,>00*256                 ; LDY #0            ; In the main loop below, we use Y to count the number
     2FFA 0000     
9987                                                                          ; of times we subtract 10 billion to get the leftmost
9988                                                                          ; digit, so set this to zero
9989               
9990 2FFC D802  30        movb ry,@S                      ; STY S             ; In the main loop below, we use location S as an
     2FFE 0092     
9991                                                                          ; 8-bit overflow for the 32-bit calculations, so
9992                                                                          ; we need to set this to 0 before joining the loop
9993               
9994 3000 0460  28        b    @TT36                      ; JMP TT36          ; Jump to TT36 to start the process of printing this
     3002 30D4     
9995                                                                          ; number's digits
9996               
9997               TT35:
9998                                                                          ; This subroutine multiplies K(S 0 1 2 3) by 10 and
9999                                                                          ; stores the result back in K(S 0 1 2 3), using the fact
10000                                                                          ; that K * 10 = (K * 2) + (K * 2 * 2 * 2)
10001                      .asl @K+3                       ; ASL K+3           ; Set K(S 0 1 2 3) = K(S 0 1 2 3) * 2 by rotating left
     **** ****     > ASL
0001 3004 D1A0  30        movb @K+3,rtmp
     3006 0040     
0002 3008 0246  22        andi rtmp,>ff00
     300A FF00     
0003 300C 0A16  18        sla  rtmp,1
0004 300E D806  30        movb rtmp,@K+3
     3010 0040     
                   < elite.a99
10002 3012 0208  20        li   rarg1,K+2                  ; ROL K+2
     3014 003F     
10003 3016 06A0  28        bl   @rol                       ;
     3018 8028     
10004 301A 0208  20        li   rarg1,K+1                  ; ROL K+1
     301C 003E     
10005 301E 06A0  28        bl   @rol                       ;
     3020 8028     
10006 3022 0208  20        li   rarg1,K                    ; ROL K
     3024 003D     
10007 3026 06A0  28        bl   @rol                       ;
     3028 8028     
10008 302A 0208  20        li   rarg1,S                    ; ROL S
     302C 0092     
10009 302E 06A0  28        bl   @rol                       ;
     3030 8028     
10010               
10011 3032 0201  20        li   rx,>03*256                 ; LDX #3            ; Now we want to make a copy of the newly doubled K in
     3034 0300     
10012                                                                          ; XX15, so we can use it for the first (K * 2) in the
10013                                                                          ; equation above, so set up a counter in X for copying
10014                                                                          ; four bytes, starting with the last byte in memory
10015                                                                          ; (i.e. the least significant)
10016               
10017               tt35_:
10018 3036 D021  34        movb @K(rx),ra                  ; LDA K,X           ; Copy the X-th byte of K(0 1 2 3) to the X-th byte of
     3038 003D     
10019 303A D840  38        movb ra,@XX15(rx)               ; STA XX15,X        ; XX15(0 1 2 3), so that XX15 will contain a copy of
     303C 0031     
10020                                                                          ; K(0 1 2 3) once we've copied all four bytes
10021               
10022 303E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10023               
10024 3040 15FA  14        jgt  tt35_                      ; BPL tt35          ; Loop back to copy the next byte until we have copied
10025                                                                          ; all four
10026               
10027 3042 D020  30        movb @S,ra                      ; LDA S             ; Store the value of location S, our overflow byte, in
     3044 0092     
10028 3046 D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; XX15+4, so now XX15(4 0 1 2 3) contains a copy of
     3048 0035     
10029                                                                          ; K(S 0 1 2 3), which is the value of (K * 2) that we
10030                                                                          ; want to use in our calculation
10031               
10032                      .asl @K+3                       ; ASL K+3           ; Now to calculate the (K * 2 * 2 * 2) part. We still
     **** ****     > ASL
0001 304A D1A0  30        movb @K+3,rtmp
     304C 0040     
0002 304E 0246  22        andi rtmp,>ff00
     3050 FF00     
0003 3052 0A16  18        sla  rtmp,1
0004 3054 D806  30        movb rtmp,@K+3
     3056 0040     
                   < elite.a99
10033 3058 0208  20        li   rarg1,K+2                  ; ROL K+2           ; have (K * 2) in K(S 0 1 2 3), so we just need to shift
     305A 003F     
10034 305C 06A0  28        bl   @rol                       ;
     305E 8028     
10035 3060 0208  20        li   rarg1,K+1                  ; ROL K+1           ; it twice. This is the first one, so we do this:
     3062 003E     
10036 3064 06A0  28        bl   @rol                       ;
     3066 8028     
10037 3068 0208  20        li   rarg1,K                    ; ROL K             ;
     306A 003D     
10038 306C 06A0  28        bl   @rol                       ;
     306E 8028     
10039 3070 0208  20        li   rarg1,S                    ; ROL S             ; K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 4
     3072 0092     
10040 3074 06A0  28        bl   @rol                       ;
     3076 8028     
10041               
10042                      .asl @K+3                       ; ASL K+3           ; And then we do it again, so that means:
     **** ****     > ASL
0001 3078 D1A0  30        movb @K+3,rtmp
     307A 0040     
0002 307C 0246  22        andi rtmp,>ff00
     307E FF00     
0003 3080 0A16  18        sla  rtmp,1
0004 3082 D806  30        movb rtmp,@K+3
     3084 0040     
                   < elite.a99
10043 3086 0208  20        li   rarg1,K+2                  ; ROL K+2           ;
     3088 003F     
10044 308A 06A0  28        bl   @rol                       ;
     308C 8028     
10045 308E 0208  20        li   rarg1,K+1                  ; ROL K+1           ; K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 8
     3090 003E     
10046 3092 06A0  28        bl   @rol                       ;
     3094 8028     
10047 3096 0208  20        li   rarg1,K                    ; ROL K
     3098 003D     
10048 309A 06A0  28        bl   @rol                       ;
     309C 8028     
10049 309E 0208  20        li   rarg1,S                    ; ROL S
     30A0 0092     
10050 30A2 06A0  28        bl   @rol                       ;
     30A4 8028     
10051               
10052                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 30A6 0A13  18        sla  rzero,1
                   < elite.a99
10053                                                                          ; C flag affecting the result
10054               
10055 30A8 0201  20        li   rx,>03*256                 ; LDX #3            ; By now we've got (K * 2) in XX15(4 0 1 2 3) and
     30AA 0300     
10056                                                                          ; (K * 8) in K(S 0 1 2 3), so the final step is to add
10057                                                                          ; these two 32-bit numbers together to get K * 10.
10058                                                                          ; So we set a counter in X for four bytes, starting
10059                                                                          ; with the last byte in memory (i.e. the least
10060                                                                          ; significant)
10061               
10062               tt36_:
10063 30AC D021  34        movb @K(rx),ra                  ; LDA K,X           ; Fetch the X-th byte of K into A
     30AE 003D     
10064               
10065                      .adc @XX15(rx),ra               ; ADC XX15,X        ; Add the X-th byte of XX15 to A, with carry
     **** ****     > ADC
0001 30B0 1701  14        jnc  !
0002 30B2 B004  18        ab   rone,ra
0003               !:
0004 30B4 B021  34        ab   @XX15(RX),ra
     30B6 0031     
                   < elite.a99
10066               
10067 30B8 D840  38        movb ra,@K(rx)                  ; STA K,X           ; Store the result in the X-th byte of K
     30BA 003D     
10068               
10069 30BC 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10070               
10071 30BE 15F6  14        jgt  tt36_                      ; BPL tt36          ; Loop back to add the next byte, moving from the least
10072                                                                          ; significant byte to the most significant, until we
10073                                                                          ; have added all four
10074               
10075 30C0 D020  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Finally, fetch the overflow byte from XX15(4 0 1 2 3)
     30C2 0035     
10076               
10077                      .adc @S,ra                      ; ADC S             ; And add it to the overflow byte from K(S 0 1 2 3),
     **** ****     > ADC
0001 30C4 1701  14        jnc  !
0002 30C6 B004  18        ab   rone,ra
0003               !:
0004 30C8 B020  30        ab   @S,ra
     30CA 0092     
                   < elite.a99
10078                                                                          ; with carry
10079               
10080 30CC D800  30        movb ra,@S                      ; STA S             ; And store the result in the overflow byte from
     30CE 0092     
10081                                                                          ; K(S 0 1 2 3), so now we have our desired result, i.e.
10082                                                                          ;
10083                                                                          ; K(S 0 1 2 3) = K(S 0 1 2 3) * 10
10084               
10085 30D0 0202  20        li   ry,>00*256                 ; LDY #0            ; In the main loop below, we use Y to count the number
     30D2 0000     
10086                                                                          ; of times we subtract 10 billion to get the leftmost
10087                                                                          ; digit, so set this to zero so we can rejoin the main
10088                                                                          ; loop for another subtraction process
10089               
10090               TT36:
10091                                                                          ; This is the main loop of our digit-printing routine.
10092                                                                          ; In the following loop, we are going to count the
10093                                                                          ; number of times that we can subtract 10 million and
10094                                                                          ; store that count in Y, which we have already set to 0
10095 30D4 0201  20        li   rx,>03*256                 ; LDX #3            ; Our first calculation concerns 32-bit numbers, so
     30D6 0300     
10096                                                                          ; set up a counter for a four-byte loop
10097               
10098                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 30D8 0A15  18        sla  rmone,1
                   < elite.a99
10099                                                                          ; C flag affecting the result
10100               
10101               tt37_:
10102                                                                          ; We now loop through each byte in turn to do this:
10103                                                                          ;
10104                                                                          ; XX15(4 0 1 2 3) = K(S 0 1 2 3) - 100,000,000,000
10105 30DA D021  34        movb @K(rx),ra                  ; LDA K,X           ; Subtract the X-th byte of TENS (i.e. 10 billion) from
     30DC 003D     
10106                      .sbc @TENS(rx),ra               ; SBC TENS,X        ; the X-th byte of K
     **** ****     > SBC
0001 30DE 1801  14        joc  !
0002 30E0 7004  18        sb   rone,ra
0003               !:
0004 30E2 7021  34        sb   @TENS(RX),ra
     30E4 2FA8     
                   < elite.a99
10107               
10108 30E6 D840  38        movb ra,@XX15(rx)               ; STA XX15,X        ; Store the result in the X-th byte of XX15
     30E8 0031     
10109               
10110 30EA 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10111               
10112 30EC 15F6  14        jgt  tt37_                      ; BPL tt37          ; Loop back to subtract the next byte, moving from the
10113                                                                          ; least significant byte to the most significant, until
10114                                                                          ; we have subtracted all four
10115               
10116 30EE D020  30        movb @S,ra                      ; LDA S             ; Subtract the fifth byte of 10 billion (i.e. &17) from
     30F0 0092     
10117                      .sbi (>17*256)                  ; SBC #&17          ; the fifth (overflow) byte of K, which is S
     **** ****     > SBI
0001 30F2 1801  14        joc  !
0002 30F4 7004  18        sb   rone,ra
0003               !:
0004 30F6 0220  22        ai   ra,-(>17*256)
     30F8 E900     
                   < elite.a99
10118               
10119 30FA D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; Store the result in the overflow byte of XX15
     30FC 0035     
10120               
10121 30FE 170F  14        jnc  TT37                       ; BCC TT37          ; If subtracting 10 billion took us below zero, jump to
10122                                                                          ; TT37 to print out this digit, which is now in Y
10123               
10124 3100 0201  20        li   rx,>03*256                 ; LDX #3            ; We now want to copy XX15(4 0 1 2 3) back into
     3102 0300     
10125                                                                          ; K(S 0 1 2 3), so we can loop back up to do the next
10126                                                                          ; subtraction, so set up a counter for a four-byte loop
10127               
10128               tt38_:
10129 3104 D021  34        movb @XX15(rx),ra               ; LDA XX15,X        ; Copy the X-th byte of XX15(0 1 2 3) to the X-th byte
     3106 0031     
10130 3108 D840  38        movb ra,@K(rx)                  ; STA K,X           ; of K(0 1 2 3), so that K(0 1 2 3) will contain a copy
     310A 003D     
10131                                                                          ; of XX15(0 1 2 3) once we've copied all four bytes
10132               
10133 310C 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10134               
10135 310E 15FA  14        jgt  tt38_                      ; BPL tt38          ; Loop back to copy the next byte, until we have copied
10136                                                                          ; all four
10137               
10138 3110 D020  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Store the value of location XX15+4, our overflow
     3112 0035     
10139 3114 D800  30        movb ra,@S                      ; STA S             ; byte in S, so now K(S 0 1 2 3) contains a copy of
     3116 0092     
10140                                                                          ; XX15(4 0 1 2 3)
10141               
10142 3118 B084  18        ab   rone,ry                    ; INY               ; We have now managed to subtract 10 billion from our
10143                                                                          ; number, so increment Y, which is where we are keeping
10144                                                                          ; a count of the number of subtractions so far
10145               
10146 311A 0460  28        b    @TT36                      ; JMP TT36          ; Jump back to TT36 to subtract the next 10 billion
     311C 30D4     
10147               
10148               TT37:
10149 311E D002  18        movb ry,ra                      ; TYA               ; If we get here then Y contains the digit that we want
10150                                                                          ; to print (as Y has now counted the total number of
10151                                                                          ; subtractions of 10 billion), so transfer Y into A
10152               
10153 3120 1608  14        jne  TT32                       ; BNE TT32          ; If the digit is non-zero, jump to TT32 to print it
10154               
10155 3122 D020  30        movb @T,ra                      ; LDA T             ; Otherwise the digit is zero. If we are already
     3124 00D1     
10156                                                                          ; printing the number then we will want to print a 0,
10157                                                                          ; but if we haven't started printing the number yet,
10158                                                                          ; then we probably don't, as we don't want to print
10159                                                                          ; leading zeroes unless this is the only digit before
10160                                                                          ; the decimal point
10161                                                                          ;
10162                                                                          ; To help with this, we are going to use T as a flag
10163                                                                          ; that tells us whether we have already started
10164                                                                          ; printing digits:
10165                                                                          ;
10166                                                                          ; * If T <> 0 we haven't printed anything yet
10167                                                                          ;
10168                                                                          ; * If T = 0 then we have started printing digits
10169                                                                          ;
10170                                                                          ; We initially set T above to the maximum number of
10171                                                                          ; characters allowed, less 1 if we are printing a
10172                                                                          ; decimal point, so the first time we enter the digit
10173                                                                          ; printing routine at TT37, it is definitely non-zero
10174               
10175 3126 1305  14        jeq  TT32                       ; BEQ TT32          ; If T = 0, jump straight to the print routine at TT32,
10176                                                                          ; as we have already started printing the number, so we
10177                                                                          ; definitely want to print this digit too
10178               
10179 3128 7004  18        sb   rone,ra                    ; DEC U             ; We initially set U to the number of digits we want to
10180 312A 1510  14        jgt  TT34                       ; BPL TT34          ; skip before starting to print the number. If we get
10181                                                                          ; here then we haven't printed any digits yet, so
10182                                                                          ; decrement U to see if we have reached the point where
10183                                                                          ; we should start printing the number, and if not, jump
10184                                                                          ; to TT34 to set up things for the next digit
10185               
10186 312C 0200  20        li   ra,(' ')*256               ; LDA #' '          ; We haven't started printing any digits yet, but we
     312E 2000     
10187 3130 1609  14        jne  tt34_                      ; BNE tt34          ; have reached the point where we should start printing
10188                                                                          ; our number, so call TT26 (via tt34) to print a space
10189                                                                          ; so that the number is left-padded with spaces (this
10190                                                                          ; BNE is effectively a JMP as A will never be zero)
10191               
10192               TT32:
10193 3132 0202  20        li   ry,>00*256                 ; LDY #0            ; We are printing an actual digit, so first set T to 0,
     3134 0000     
10194 3136 D802  30        movb ry,@T                      ; STY T             ; to denote that we have now started printing digits as
     3138 00D1     
10195                                                                          ; opposed to spaces
10196               
10197                      .clc                            ; CLC               ; The digit value is in A, so add ASCII "0" to get the
     **** ****     > CLC
0001 313A 0A13  18        sla  rzero,1
                   < elite.a99
10198                      .adi (('0')*256)                ; ADC #'0'          ; ASCII character number to print
     **** ****     > ADI
0001 313C 1701  14        jnc  !
0002 313E B004  18        ab   rone,ra
0003               !:
0004 3140 0220  22        ai   ra,(('0')*256)
     3142 3000     
                   < elite.a99
10199               
10200               tt34_:
10201 3144 0206  20        li   rtmp,TT26                  ; JSR TT26          ; Call TT26 to print the character in A and fall through
     3146 3172     
10202 3148 06A0  28        bl   @jsr                       ;
     314A 8002     
10203                                                                          ; into TT34 to get things ready for the next digit
10204               
10205               TT34:
10206 314C 7004  18        sb   rone,ra                    ; DEC T             ; Decrement T but keep T >= 0 (by incrementing it
10207 314E 1501  14        jgt  B24                        ; BPL B24           ; again if the above decrement made T negative)
10208 3150 B004  18        ab   rone,ra                    ; INC T
10209               
10210               B24:
10211 3152 7004  18        sb   rone,ra                    ; DEC XX17          ; Decrement the total number of characters left to
10212                                                                          ; print, which we stored in XX17
10213               
10214 3154 1166  14        jlt  RR3+1                      ; BMI RR3+1         ; If the result is negative, we have printed all the
10215                                                                          ; characters, so return from the subroutine (as RR3
10216                                                                          ; contains an ORA #&60 instruction, so RR3+1 is &60,
10217                                                                          ; which is the opcode for an RTS)
10218               
10219 3156 1609  14        jne  B25                        ; BNE B25           ; If the result is positive (> 0) then we still have
10220                                                                          ; characters left to print, so loop back to TT35 (via
10221                                                                          ; the JMP TT35 instruction below) to print the next
10222                                                                          ; digit
10223               
10224                      .plp                            ; PLP               ; If we get here then we have printed the exact number
     **** ****     > PLP
0001 3158 058A  14        INC  rsp
0002 315A D19A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
10225                                                                          ; of digits that we wanted to, so restore the C flag
10226                                                                          ; that we stored at the start of the routine
10227               
10228 315C 1706  14        jnc  B25                        ; BCC B25           ; If the C flag is clear, we don't want a decimal point,
10229                                                                          ; so loop back to TT35 (via the JMP TT35 instruction
10230                                                                          ; below) to print the next digit
10231               
10232 315E 0200  20        li   ra,('.')*256               ; LDA #'.'          ; Otherwise the C flag is set, so print the decimal
     3160 2E00     
10233 3162 0206  20        li   rtmp,TT26                  ; JSR TT26          ; point
     3164 3172     
10234 3166 06A0  28        bl   @jsr                       ;
     3168 8002     
10235               
10236               B25:
10237 316A 0460  28        b    @TT35                      ; JMP TT35          ; Loop back to TT35 to print the next digit
     316C 3004     
10238               
10239               * ******************************************************************************
10240               *
10241               * Name: BELL
10242               * Type: Subroutine
10243               * Category: Sound
10244               * Summary: Make a standard system beep
10245               *
10246               * ------------------------------------------------------------------------------
10247               *
10248               * This is the standard system beep, as made by the ASCII 7 "BELL" control code.
10249               *
10250               * ******************************************************************************
10251               
10252               BELL:
10253 316E 0200  20        li   ra,>07*256                 ; LDA #7            ; Control code 7 makes a beep, so load this into A
     3170 0700     
10254               
10255                                                                          ; Fall through into the TT26 print routine to
10256                                                                          ; actually make the sound
10257               
10258               * ******************************************************************************
10259               *
10260               * Name: TT26
10261               * Type: Subroutine
10262               * Category: Text
10263               * Summary: Print a character at the text cursor by poking into screen memory
10264               * Deep dive: Drawing text
10265               *
10266               * ------------------------------------------------------------------------------
10267               *
10268               * Print a character at the text cursor (XC, YC), do a beep, print a newline,
10269               * or delete left (backspace).
10270               *
10271               * WRCHV is set to point here by the loading process.
10272               *
10273               * ------------------------------------------------------------------------------
10274               *
10275               * Arguments:
10276               *
10277               * A                   The character to be printed. Can be one of the
10278               * following:
10279               *
10280               * * 7 (beep)
10281               *
10282               * * 10-13 (line feeds and carriage returns)
10283               *
10284               * * 32-95 (ASCII capital letters, numbers and
10285               * punctuation)
10286               *
10287               * * 127 (delete the character to the left of the text
10288               * cursor and move the cursor to the left)
10289               *
10290               * XC                  Contains the text column to print at (the x-coordinate)
10291               *
10292               * YC                  Contains the line number to print on (the y-coordinate)
10293               *
10294               * ------------------------------------------------------------------------------
10295               *
10296               * Returns:
10297               *
10298               * A                   A is preserved
10299               *
10300               * X                   X is preserved
10301               *
10302               * Y                   Y is preserved
10303               *
10304               * C flag              The C flag is cleared
10305               *
10306               * ------------------------------------------------------------------------------
10307               *
10308               * Other entry points:
10309               *
10310               * RR3+1               Contains an RTS
10311               *
10312               * RREN                Prints the character definition pointed to by P(2 1) at
10313               * the screen address pointed to by (A SC). Used by the
10314               * BULB routine
10315               *
10316               * rT9                 Contains an RTS
10317               *
10318               * ******************************************************************************
10319               
10320               TT26:
10321 3172 D800  30        movb ra,@K3                     ; STA K3            ; Store the A, X and Y registers, so we can restore
     3174 00D2     
10322 3176 D802  30        movb ry,@YSAV2                  ; STY YSAV2         ; them at the end (so they don't get changed by this
     3178 0F0F     
10323 317A D801  30        movb rx,@XSAV2                  ; STX XSAV2         ; routine)
     317C 0F0E     
10324               
10325 317E D0A0  30        movb @QQ17,ry                   ; LDY QQ17          ; Load the QQ17 flag, which contains the text printing
     3180 007E     
10326                                                                          ; flags
10327               
10328 3182 0282  22        ci   ry,>ff*256                 ; CPY #255          ; If QQ17 = 255 then printing is disabled, so jump to
     3184 FF00     
10329 3186 1366  14        jeq  RR4                        ; BEQ RR4           ; RR4, which doesn't print anything, it just restores
10330                                                                          ; the registers and returns from the subroutine
10331               
10332 3188 0280  22        ci   ra,>07*256                 ; CMP #7            ; If this is a beep character (A = 7), jump to R5,
     318A 0700     
10333 318C 136C  14        jeq  R5_                        ; BEQ R5_           ; which will emit the beep, restore the registers and
10334                                                                          ; return from the subroutine
10335               
10336 318E 0280  22        ci   ra,>20*256                 ; CMP #32           ; If this is an ASCII character (A >= 32), jump to RR1
     3190 2000     
10337 3192 1809  14        joc  RR1                        ; BCS RR1           ; below, which will print the character, restore the
10338                                                                          ; registers and return from the subroutine
10339               
10340 3194 0280  22        ci   ra,>0a*256                 ; CMP #10           ; If this is control code 10 (line feed) then jump to
     3196 0A00     
10341 3198 1304  14        jeq  RRX1                       ; BEQ RRX1          ; RRX1, which will move down a line, restore the
10342                                                                          ; registers and return from the subroutine
10343               
10344 319A 0201  20        li   rx,>01*256                 ; LDX #1            ; If we get here, then this is control code 11-13, of
     319C 0100     
10345 319E D801  30        movb rx,@XC                     ; STX XC            ; which only 13 is used. This code prints a newline,
     31A0 002C     
10346                                                                          ; which we can achieve by moving the text cursor
10347                                                                          ; to the start of the line (carriage return) and down
10348                                                                          ; one line (line feed). These two lines do the first
10349                                                                          ; bit by setting XC = 1, and we then fall through into
10350                                                                          ; the line feed routine that's used by control code 10
10351               
10352               RRX1:
10353 31A2 B004  18        ab   rone,ra                    ; INC YC            ; Print a line feed, simply by incrementing the row
10354                                                                          ; number (y-coordinate) of the text cursor, which is
10355                                                                          ; stored in YC
10356               
10357 31A4 1657  14        jne  RR4                        ; BNE RR4           ; Jump to RR4 to restore the registers and return from
10358                                                                          ; the subroutine (this BNE is effectively a JMP as Y
10359                                                                          ; will never be zero)
10360               
10361               RR1:
10362                                                                          ; If we get here, then the character to print is an
10363                                                                          ; ASCII character in the range 32-95. The quickest way
10364                                                                          ; to display text on-screen is to poke the character
10365                                                                          ; pixel by pixel, directly into screen memory, so
10366                                                                          ; that's what the rest of this routine does
10367                                                                          ;
10368                                                                          ; The first step, then, is to get hold of the bitmap
10369                                                                          ; definition for the character we want to draw on the
10370                                                                          ; screen (i.e. we need the pixel shape of this
10371                                                                          ; character). The MOS ROM contains bitmap definitions
10372                                                                          ; of the system's ASCII characters, starting from &C000
10373                                                                          ; for space (ASCII 32) and ending with the  symbol
10374                                                                          ; (ASCII 126)
10375                                                                          ;
10376                                                                          ; There are definitions for 32 characters in each of the
10377                                                                          ; three pages of MOS memory, as each definition takes up
10378                                                                          ; 8 bytes (8 rows of 8 pixels) and 32 * 8 = 256 bytes =
10379                                                                          ; 1 page. So:
10380                                                                          ;
10381                                                                          ; ASCII 32-63  are defined in &C000-&C0FF (page 0)
10382                                                                          ; ASCII 64-95  are defined in &C100-&C1FF (page 1)
10383                                                                          ; ASCII 96-126 are defined in &C200-&C2F0 (page 2)
10384                                                                          ;
10385                                                                          ; The following code reads the relevant character
10386                                                                          ; bitmap from the above locations in ROM and pokes
10387                                                                          ; those values into the correct position in screen
10388                                                                          ; memory, thus printing the character on-screen
10389                                                                          ;
10390                                                                          ; It's a long way from 10 PRINT "Hello world!":GOTO 10
10391               * LDX #LO(K3)            \ These instructions are commented out in the original
10392               * INX                    \ source, but they call OSWORD 10, which reads the
10393               * STX P+1                \ character bitmap for the character number in K3 and
10394               * DEX                    \ stores it in the block at K3+1, while also setting
10395               * LDY #HI(K3)            \ P+1 to point to the character definition. This is
10396               * STY P+2                \ exactly what the following uncommented code does,
10397               * LDA #10                \ just without calling OSWORD. Presumably the code
10398               * JSR OSWORD             \ below is faster than using the system call, as this
10399                                                                          ; version takes up 15 bytes, while the version below
10400                                                                          ; (which ends with STA P+1 and SYX P+2) is 17 bytes.
10401                                                                          ; Every efficiency saving helps, especially as this
10402                                                                          ; routine is run each time the game prints a character
10403                                                                          ;
10404                                                                          ; If you want to switch this code back on, uncomment
10405                                                                          ; the above block, and comment out the code below from
10406                                                                          ; TAY to STX P+2. You will also need to uncomment the
10407                                                                          ; LDA YC instruction a few lines down (in RR2), just to
10408                                                                          ; make sure the rest of the code doesn't shift in
10409                                                                          ; memory. To be honest I can't see a massive difference
10410                                                                          ; in speed, but there you go
10411 31A6 D080  18        movb ra,ry                      ; TAY               ; Copy the character number from A to Y, as we are
10412                                                                          ; about to pull A apart to work out where this
10413                                                                          ; character definition lives in memory
10414               
10415                                                                          ; Now we want to set X to point to the relevant page
10416                                                                          ; number for this character - i.e. &C0, &C1 or &C2.
10417               
10418                                                                          ; The following logic is easier to follow if we look
10419                                                                          ; at the three character number ranges in binary:
10420                                                                          ;
10421                                                                          ; Bit #  76543210
10422                                                                          ;
10423                                                                          ; 32  = %00100000     Page 0 of bitmap definitions
10424                                                                          ; 63  = %00111111
10425                                                                          ;
10426                                                                          ; 64  = %01000000     Page 1 of bitmap definitions
10427                                                                          ; 95  = %01011111
10428                                                                          ;
10429                                                                          ; 96  = %01100000     Page 2 of bitmap definitions
10430                                                                          ; 125 = %01111101
10431                                                                          ;
10432                                                                          ; We'll refer to this below
10433               
10434 31A8 0201  20        li   rx,>bf*256                 ; LDX #&BF          ; Set X to point to the first font page in ROM minus 1,
     31AA BF00     
10435                                                                          ; which is &C0 - 1, or &BF
10436               
10437                      .asla                           ; ASL A             ; If bit 6 of the character is clear (A is 32-63)
     **** ****     > ASLA
0001 31AC 0240  22        andi ra,>ff00
     31AE FF00     
0002 31B0 0A10  18        sla  ra,1
                   < elite.a99
10438                      .asla                           ; ASL A             ; then skip the following instruction
     **** ****     > ASLA
0001 31B2 0240  22        andi ra,>ff00
     31B4 FF00     
0002 31B6 0A10  18        sla  ra,1
                   < elite.a99
10439 31B8 1702  14        jnc  B26                        ; BCC B26
10440               
10441 31BA 0201  20        li   rx,>c1*256                 ; LDX #&C1          ; A is 64-126, so set X to point to page &C1
     31BC C100     
10442               
10443               B26:
10444                      .asla                           ; ASL A             ; If bit 5 of the character is clear (A is 64-95)
     **** ****     > ASLA
0001 31BE 0240  22        andi ra,>ff00
     31C0 FF00     
0002 31C2 0A10  18        sla  ra,1
                   < elite.a99
10445 31C4 1701  14        jnc  B27                        ; BCC B27           ; then skip the following instruction
10446               
10447 31C6 B044  18        ab   rone,rx                    ; INX               ; Increment X
10448                                                                          ;
10449                                                                          ; By this point, we started with X = &BF, and then
10450                                                                          ; we did the following:
10451                                                                          ;
10452                                                                          ; If A = 32-63:   skip    then INX  so X = &C0
10453                                                                          ; If A = 64-95:   X = &C1 then skip so X = &C1
10454                                                                          ; If A = 96-126:  X = &C1 then INX  so X = &C2
10455                                                                          ;
10456                                                                          ; In other words, X points to the relevant page. But
10457                                                                          ; what about the value of A? That gets shifted to the
10458                                                                          ; left three times during the above code, which
10459                                                                          ; multiplies the number by 8 but also drops bits 7, 6
10460                                                                          ; and 5 in the process. Look at the above binary
10461                                                                          ; figures and you can see that if we cleared bits 5-7,
10462                                                                          ; then that would change 32-53 to 0-31... but it would
10463                                                                          ; do exactly the same to 64-95 and 96-125. And because
10464                                                                          ; we also multiply this figure by 8, A now points to
10465                                                                          ; the start of the character's definition within its
10466                                                                          ; page (because there are 8 bytes per character
10467                                                                          ; definition)
10468                                                                          ;
10469                                                                          ; Or, to put it another way, X contains the high byte
10470                                                                          ; (the page) of the address of the definition that we
10471                                                                          ; want, while A contains the low byte (the offset into
10472                                                                          ; the page) of the address
10473               
10474               B27:
10475 31C8 D800  30        movb ra,@P+1                    ; STA P+1           ; Store the address of this character's definition in
     31CA 001C     
10476 31CC D801  30        movb rx,@P+2                    ; STX P+2           ; P(2 1)
     31CE 001D     
10477               
10478 31D0 D020  30        movb @XC,ra                     ; LDA XC            ; Fetch XC, the x-coordinate (column) of the text cursor
     31D2 002C     
10479                                                                          ; into A
10480               
10481                      .asla                           ; ASL A             ; Multiply A by 8, and store in SC. As each character is
     **** ****     > ASLA
0001 31D4 0240  22        andi ra,>ff00
     31D6 FF00     
0002 31D8 0A10  18        sla  ra,1
                   < elite.a99
10482                      .asla                           ; ASL A             ; 8 pixels wide, and the special screen mode Elite uses
     **** ****     > ASLA
0001 31DA 0240  22        andi ra,>ff00
     31DC FF00     
0002 31DE 0A10  18        sla  ra,1
                   < elite.a99
10483                      .asla                           ; ASL A             ; for the top part of the screen is 256 pixels across
     **** ****     > ASLA
0001 31E0 0240  22        andi ra,>ff00
     31E2 FF00     
0002 31E4 0A10  18        sla  ra,1
                   < elite.a99
10484 31E6 D800  30        movb ra,@SC                     ; STA SC            ; with one bit per pixel, this value is not only the
     31E8 0007     
10485                                                                          ; screen address offset of the text cursor from the left
10486                                                                          ; side of the screen, it's also the least significant
10487                                                                          ; byte of the screen address where we want to print this
10488                                                                          ; character, as each row of on-screen pixels corresponds
10489                                                                          ; to one page. To put this more explicitly, the screen
10490                                                                          ; starts at &6000, so the text rows are stored in screen
10491                                                                          ; memory like this:
10492                                                                          ;
10493                                                                          ; Row 1: &6000 - &60FF    YC = 1, XC = 0 to 31
10494                                                                          ; Row 2: &6100 - &61FF    YC = 2, XC = 0 to 31
10495                                                                          ; Row 3: &6200 - &62FF    YC = 3, XC = 0 to 31
10496                                                                          ;
10497                                                                          ; and so on
10498               
10499 31EA D020  30        movb @YC,ra                     ; LDA YC            ; Fetch YC, the y-coordinate (row) of the text cursor
     31EC 002D     
10500               
10501 31EE 0282  22        ci   ry,>7f*256                 ; CPY #127          ; If the character number (which is in Y) <> 127, then
     31F0 7F00     
10502 31F2 160D  14        jne  RR2                        ; BNE RR2           ; skip to RR2 to print that character, otherwise this is
10503                                                                          ; the delete character, so continue on
10504               
10505 31F4 7004  18        sb   rone,ra                    ; DEC XC            ; We want to delete the character to the left of the
10506                                                                          ; text cursor and move the cursor back one, so let's
10507                                                                          ; do that by decrementing YC. Note that this doesn't
10508                                                                          ; have anything to do with the actual deletion below,
10509                                                                          ; we're just updating the cursor so it's in the right
10510                                                                          ; position following the deletion
10511               
10512                      .adi (>5e*256)                  ; ADC #&5E          ; A contains YC (from above) and the C flag is set (from
     **** ****     > ADI
0001 31F6 1701  14        jnc  !
0002 31F8 B004  18        ab   rone,ra
0003               !:
0004 31FA 0220  22        ai   ra,(>5E*256)
     31FC 5E00     
                   < elite.a99
10513 31FE D040  18        movb ra,rx                      ; TAX               ; the CPY #127 above), so these instructions do this:
10514                                                                          ;
10515                                                                          ; X = YC + &5E + 1
10516                                                                          ; = YC + &5F
10517               
10518                                                                          ; Because YC starts at 0 for the first text row, this
10519                                                                          ; means that X will be &5F for row 0, &60 for row 1 and
10520                                                                          ; so on. In other words, X is now set to the page number
10521                                                                          ; for the row before the one containing the text cursor,
10522                                                                          ; and given that we set SC above to point to the offset
10523                                                                          ; in memory of the text cursor within the row's page,
10524                                                                          ; this means that (X SC) now points to the character
10525                                                                          ; above the text cursor
10526               
10527 3200 0202  20        li   ry,>f8*256                 ; LDY #&F8          ; Set Y = &F8, so the following call to ZES2 will count
     3202 F800     
10528                                                                          ; Y upwards from &F8 to &FF
10529               
10530 3204 0206  20        li   rtmp,ZES2                  ; JSR ZES2          ; Call ZES2, which zero-fills from address (X SC) + Y to
     3206 881A     
10531 3208 06A0  28        bl   @jsr                       ;
     320A 8002     
10532                                                                          ; (X SC) + &FF. (X SC) points to the character above the
10533                                                                          ; text cursor, and adding &FF to this would point to the
10534                                                                          ; cursor, so adding &F8 points to the character before
10535                                                                          ; the cursor, which is the one we want to delete. So
10536                                                                          ; this call zero-fills the character to the left of the
10537                                                                          ; cursor, which erases it from the screen
10538               
10539 320C 1323  14        jeq  RR4                        ; BEQ RR4           ; We are done deleting, so restore the registers and
10540                                                                          ; return from the subroutine (this BNE is effectively
10541                                                                          ; a JMP as ZES2 always returns with the Z flag set)
10542               
10543               RR2:
10544                                                                          ; Now to actually print the character
10545 320E B004  18        ab   rone,ra                    ; INC XC            ; Once we print the character, we want to move the text
10546                                                                          ; cursor to the right, so we do this by incrementing
10547                                                                          ; XC. Note that this doesn't have anything to do
10548                                                                          ; with the actual printing below, we're just updating
10549                                                                          ; the cursor so it's in the right position following
10550                                                                          ; the print
10551               
10552               * LDA YC                 \ This instruction is commented out in the original
10553                                                                          ; source. It isn't required because we only just did a
10554                                                                          ; LDA YC before jumping to RR2, so this is presumably
10555                                                                          ; an example of the authors squeezing the code to save
10556                                                                          ; 2 bytes and 3 cycles
10557                                                                          ;
10558                                                                          ; If you want to re-enable the commented block near the
10559                                                                          ; start of this routine, you should uncomment this
10560                                                                          ; instruction as well
10561               
10562 3210 0280  22        ci   ra,>18*256                 ; CMP #24           ; If the text cursor is on the screen (i.e. YC < 24, so
     3212 1800     
10563 3214 1706  14        jnc  RR3                        ; BCC RR3           ; we are on rows 0-23), then jump to RR3 to print the
10564                                                                          ; character
10565               
10566 3216 0206  20        li   rtmp,TTX66                 ; JSR TTX66         ; Otherwise we are off the bottom of the screen, so
     3218 4B2E     
10567 321A 06A0  28        bl   @jsr                       ;
     321C 8002     
10568                                                                          ; clear the screen and draw a white border
10569               
10570 321E 0460  28        b    @RR4                       ; JMP RR4           ; And restore the registers and return from the
     3220 3254     
10571                                                                          ; subroutine
10572               
10573               RR3:
10574                                                                          ; A contains the value of YC - the screen row where we
10575                                                                          ; want to print this character - so now we need to
10576                                                                          ; convert this into a screen address, so we can poke
10577                                                                          ; the character data to the right place in screen
10578                                                                          ; memory
10579 3222 0260  22        ori  ra,>60*256                 ; ORA #&60          ; We already stored the least significant byte
     3224 6000     
10580                                                                          ; of this screen address in SC above (see the STA SC
10581                                                                          ; instruction above), so all we need is the most
10582                                                                          ; significant byte. As mentioned above, in Elite's
10583                                                                          ; square mode 4 screen, each row of text on-screen
10584                                                                          ; takes up exactly one page, so the first row is page
10585                                                                          ; &60xx, the second row is page &61xx, so we can get
10586                                                                          ; the page for character (XC, YC) by OR'ing with &60.
10587                                                                          ; To see this in action, consider that our two values
10588                                                                          ; are, in binary:
10589                                                                          ;
10590                                                                          ; YC is between:  %00000000
10591                                                                          ; and:  %00010111
10592                                                                          ; &60 is:  %01100000
10593                                                                          ;
10594                                                                          ; so YC OR &60 effectively adds &60 to YC, giving us
10595                                                                          ; the page number that we want
10596               
10597               RREN:
10598 3226 D800  30        movb ra,@SC+1                   ; STA SC+1          ; Store the page number of the destination screen
     3228 0008     
10599                                                                          ; location in SC+1, so SC now points to the full screen
10600                                                                          ; location where this character should go
10601               
10602 322A 0202  20        li   ry,>07*256                 ; LDY #7            ; We want to print the 8 bytes of character data to the
     322C 0700     
10603                                                                          ; screen (one byte per row), so set up a counter in Y
10604                                                                          ; to count these bytes
10605               
10606               RRL1:
10607                      .ld_ind_y_idx @P+1,ra           ; LDA (P+1),Y       ; The character definition is at P(2 1) - we set this up
     **** ****     > LD_IND_Y_IDX
0001 322E D820  42        movb @P+1,@rtmplb
     3230 001C     
     3232 830D     
0002 3234 D1A0  30        movb @P+1+1,rtmp
     3236 001D     
0003 3238 A182  18        a    ry,rtmp
0004 323A D016  26        movb *rtmp,RA
                   < elite.a99
10608                                                                          ; above - so load the Y-th byte from P(2 1), which will
10609                                                                          ; contain the bitmap for the Y-th row of the character
10610               
10611                      .eor @SC                        ; EOR (SC),Y        ; If we EOR this value with the existing screen
     **** ****     > EOR
0001 323C D1A0  30        movb @SC,rtmp
     323E 0007     
0002 3240 2806  18        xor  rtmp,ra
                   < elite.a99
10612                                                                          ; contents, then it's reversible (so reprinting the
10613                                                                          ; same character in the same place will revert the
10614                                                                          ; screen to what it looked like before we printed
10615                                                                          ; anything); this means that printing a white pixel
10616                                                                          ; onto a white background results in a black pixel, but
10617                                                                          ; that's a small price to pay for easily erasable text
10618               
10619                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Store the Y-th byte at the screen address for this
     **** ****     > ST_IND_Y_IDX
0001 3242 D820  42        movb @SC,@rtmplb
     3244 0007     
     3246 830D     
0002 3248 D1A0  30        movb @SC+1,rtmp
     324A 0008     
0003 324C A182  18        a    ry,rtmp
0004 324E D580  30        movb RA,*rtmp
                   < elite.a99
10620                                                                          ; character location
10621               
10622 3250 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
10623               
10624 3252 15ED  14        jgt  RRL1                       ; BPL RRL1          ; Loop back for the next byte to print to the screen
10625               
10626               RR4:
10627 3254 D0A0  30        movb @YSAV2,ry                  ; LDY YSAV2         ; We're done printing, so restore the values of the
     3256 0F0F     
10628 3258 D060  30        movb @XSAV2,rx                  ; LDX XSAV2         ; A, X and Y registers that we saved above and clear
     325A 0F0E     
10629 325C D020  30        movb @K3,ra                     ; LDA K3            ; the C flag, so everything is back to how it was
     325E 00D2     
10630                      .clc                            ; CLC
     **** ****     > CLC
0001 3260 0A13  18        sla  rzero,1
                   < elite.a99
10631               
10632               rT9:
10633 3262 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3264 800E     
10634               
10635               R5_:
10636 3266 0206  20        li   rtmp,BEEP                  ; JSR BEEP          ; Call the BEEP subroutine to make a short, high beep
     3268 8BA0     
10637 326A 06A0  28        bl   @jsr                       ;
     326C 8002     
10638               
10639 326E 0460  28        b    @RR4                       ; JMP RR4           ; Jump to RR4 to restore the registers and return from
     3270 3254     
10640                                                                          ; the subroutine using a tail call
10641               
10642               * ******************************************************************************
10643               *
10644               * Name: DIALS (Part 1 of 4)
10645               * Type: Subroutine
10646               * Category: Dashboard
10647               * Summary: Update the dashboard: speed indicator
10648               * Deep dive: The dashboard indicators
10649               *
10650               * ------------------------------------------------------------------------------
10651               *
10652               * This routine updates the dashboard. First we draw all the indicators in the
10653               * right part of the dashboard, from top (speed) to bottom (energy banks), and
10654               * then we move on to the left part, again drawing from top (forward shield) to
10655               * bottom (altitude).
10656               *
10657               * This first section starts us off with the speedometer in the top right.
10658               *
10659               * ******************************************************************************
10660               
10661               DIALS:
10662 3272 0200  20        li   ra,>d0*256                 ; LDA #&D0          ; Set SC(1 0) = &78D0, which is the screen address for
     3274 D000     
10663 3276 D800  30        movb ra,@SC                     ; STA SC            ; the character block containing the left end of the
     3278 0007     
10664 327A 0200  20        li   ra,>78*256                 ; LDA #&78          ; top indicator in the right part of the dashboard, the
     327C 7800     
10665 327E D800  30        movb ra,@SC+1                   ; STA SC+1          ; one showing our speed
     3280 0008     
10666               
10667 3282 0206  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     3284 3402     
10668 3286 06A0  28        bl   @jsr                       ;
     3288 8002     
10669                                                                          ; and X to the colour for safe values
10670               
10671 328A D801  30        movb rx,@K+1                    ; STX K+1           ; Set K+1 (the colour we should show for low values) to
     328C 003E     
10672                                                                          ; X (the colour to use for safe values)
10673               
10674 328E D800  30        movb ra,@K                      ; STA K             ; Set K (the colour we should show for high values) to
     3290 003D     
10675                                                                          ; A (the colour to use for dangerous values)
10676               
10677                                                                          ; The above sets the following indicators to show red
10678                                                                          ; for high values and yellow/white for low values
10679               
10680 3292 0200  20        li   ra,>0e*256                 ; LDA #14           ; Set T1 to 14, the threshold at which we change the
     3294 0E00     
10681 3296 D800  30        movb ra,@T1                     ; STA T1            ; indicator's colour
     3298 0006     
10682               
10683 329A D020  30        movb @DELTA,ra                  ; LDA DELTA         ; Fetch our ship's speed into A, in the range 0-40
     329C 008C     
10684               
10685               * LSR A                  \ Draw the speed indicator using a range of 0-31, and
10686 329E 0206  20        li   rtmp,DIL-1                 ; JSR DIL-1         ; increment SC to point to the next indicator (the roll
     32A0 342B     
10687 32A2 06A0  28        bl   @jsr                       ;
     32A4 8002     
10688                                                                          ; indicator). The LSR is commented out as it isn't
10689                                                                          ; required with a call to DIL-1, so perhaps this was
10690                                                                          ; originally a call to DIL that got optimised
10691               
10692               * ******************************************************************************
10693               *
10694               * Name: DIALS (Part 2 of 4)
10695               * Type: Subroutine
10696               * Category: Dashboard
10697               * Summary: Update the dashboard: pitch and roll indicators
10698               * Deep dive: The dashboard indicators
10699               *
10700               * ******************************************************************************
10701               
10702 32A6 0200  20        li   ra,>00*256                 ; LDA #0            ; Set R = P = 0 for the low bytes in the call to the ADD
     32A8 0000     
10703 32AA D800  30        movb ra,@R                      ; STA R             ; routine below
     32AC 0091     
10704 32AE D800  30        movb ra,@P                      ; STA P
     32B0 001B     
10705               
10706 32B2 0200  20        li   ra,>08*256                 ; LDA #8            ; Set S = 8, which is the value of the centre of the
     32B4 0800     
10707 32B6 D800  30        movb ra,@S                      ; STA S             ; roll indicator
     32B8 0092     
10708               
10709 32BA D020  30        movb @ALP1,ra                   ; LDA ALP1          ; Fetch the roll angle alpha as a value between 0 and
     32BC 0087     
10710 32BE 0910  18        srl  ra,1                       ; LSR A             ; 31, and divide by 4 to get a value of 0 to 7
10711 32C0 0910  18        srl  ra,1                       ; LSR A
10712               
10713 32C2 F020  30        socb @ALP2,ra                   ; ORA ALP2          ; Apply the roll sign to the value, and flip the sign,
     32C4 0088     
10714                      .eoi (>80*256)                  ; EOR #%10000000    ; so it's now in the range -7 to +7, with a positive
     **** ****     > EOI
0001 32C6 0206  20        li   rtmp,(>80*256)
     32C8 8000     
0002 32CA 2806  18        xor  rtmp,ra
                   < elite.a99
10715                                                                          ; roll angle alpha giving a negative value in A
10716               
10717 32CC 0206  20        li   rtmp,ADD                   ; JSR ADD           ; We now add A to S to give us a value in the range 1 to
     32CE 44BA     
10718 32D0 06A0  28        bl   @jsr                       ;
     32D2 8002     
10719                                                                          ; 15, which we can pass to DIL2 to draw the vertical
10720                                                                          ; bar on the indicator at this position. We use the ADD
10721                                                                          ; routine like this:
10722                                                                          ;
10723                                                                          ; (A X) = (A 0) + (S 0)
10724                                                                          ;
10725                                                                          ; and just take the high byte of the result. We use ADD
10726                                                                          ; rather than a normal ADC because ADD separates out the
10727                                                                          ; sign bit and does the arithmetic using absolute values
10728                                                                          ; and separate sign bits, which we want here rather than
10729                                                                          ; the two's complement that ADC uses
10730               
10731 32D4 0206  20        li   rtmp,DIL2                  ; JSR DIL2          ; Draw a vertical bar on the roll indicator at offset A
     32D6 34F6     
10732 32D8 06A0  28        bl   @jsr                       ;
     32DA 8002     
10733                                                                          ; and increment SC to point to the next indicator (the
10734                                                                          ; pitch indicator)
10735               
10736 32DC D020  30        movb @BETA,ra                   ; LDA BETA          ; Fetch the pitch angle beta as a value between -8 and
     32DE 002A     
10737                                                                          ; +8
10738               
10739 32E0 D060  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the magnitude of the pitch angle beta, and if it
     32E2 002B     
10740 32E4 1304  14        jeq  B28                        ; BEQ B28           ; is 0 (i.e. we are not pitching), skip the next
10741                                                                          ; instruction
10742               
10743                      .sbi (>01*256)                  ; SBC #1            ; The pitch angle beta is non-zero, so set A = A - 1
     **** ****     > SBI
0001 32E6 1801  14        joc  !
0002 32E8 7004  18        sb   rone,ra
0003               !:
0004 32EA 0220  22        ai   ra,-(>01*256)
     32EC FF00     
                   < elite.a99
10744                                                                          ; (the C flag is set by the call to DIL2 above, so we
10745                                                                          ; don't need to do a SEC). This gives us a value of A
10746                                                                          ; from -7 to +7 because these are magnitude-based
10747                                                                          ; numbers with sign bits, rather than two's complement
10748                                                                          ; numbers
10749               
10750               B28:
10751 32EE 0206  20        li   rtmp,ADD                   ; JSR ADD           ; We now add A to S to give us a value in the range 1 to
     32F0 44BA     
10752 32F2 06A0  28        bl   @jsr                       ;
     32F4 8002     
10753                                                                          ; 15, which we can pass to DIL2 to draw the vertical
10754                                                                          ; bar on the indicator at this position (see the JSR ADD
10755                                                                          ; above for more on this)
10756               
10757 32F6 0206  20        li   rtmp,DIL2                  ; JSR DIL2          ; Draw a vertical bar on the pitch indicator at offset A
     32F8 34F6     
10758 32FA 06A0  28        bl   @jsr                       ;
     32FC 8002     
10759                                                                          ; and increment SC to point to the next indicator (the
10760                                                                          ; four energy banks)
10761               
10762               * ******************************************************************************
10763               *
10764               * Name: DIALS (Part 3 of 4)
10765               * Type: Subroutine
10766               * Category: Dashboard
10767               * Summary: Update the dashboard: four energy banks
10768               * Deep dive: The dashboard indicators
10769               *
10770               * ------------------------------------------------------------------------------
10771               *
10772               * This and the next section only run once every four iterations of the main
10773               * loop, so while the speed, pitch and roll indicators update every iteration,
10774               * the other indicators update less often.
10775               *
10776               * ******************************************************************************
10777               
10778 32FE D020  30        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 4,
     3300 0099     
10779 3302 0240  22        andi ra,>03*256                 ; AND #3            ; jumping to rT9 if it is non-zero. rT9 contains an RTS,
     3304 0300     
10780 3306 16AD  14        jne  rT9                        ; BNE rT9           ; so the following code only runs every 4 iterations of
10781                                                                          ; the main loop, otherwise we return from the subroutine
10782               
10783 3308 0202  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0, for use in various places below
     330A 0000     
10784               
10785 330C 0206  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     330E 3402     
10786 3310 06A0  28        bl   @jsr                       ;
     3312 8002     
10787                                                                          ; and X to the colour for safe values
10788               
10789 3314 D801  30        movb rx,@K                      ; STX K             ; Set K (the colour we should show for high values) to X
     3316 003D     
10790                                                                          ; (the colour to use for safe values)
10791               
10792 3318 D800  30        movb ra,@K+1                    ; STA K+1           ; Set K+1 (the colour we should show for low values) to
     331A 003E     
10793                                                                          ; A (the colour to use for dangerous values)
10794               
10795                                                                          ; The above sets the following indicators to show red
10796                                                                          ; for low values and yellow/white for high values, which
10797                                                                          ; we use not only for the energy banks, but also for the
10798                                                                          ; shield levels and current fuel
10799               
10800 331C 0201  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X so we can zero the four bytes at
     331E 0300     
10801                                                                          ; XX12, so we can then calculate each of the four energy
10802                                                                          ; banks' values before drawing them later
10803               
10804 3320 D801  30        movb rx,@T1                     ; STX T1            ; Set T1 to 3, the threshold at which we change the
     3322 0006     
10805                                                                          ; indicator's colour
10806               
10807               DLL23:
10808 3324 D842  38        movb ry,@XX12(rx)               ; STY XX12,X        ; Set the X-th byte of XX12 to 0
     3326 0037     
10809               
10810 3328 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
10811               
10812 332A 15FC  14        jgt  DLL23                      ; BPL DLL23         ; Loop back for the next byte until the four bytes at
10813                                                                          ; XX12 are all zeroed
10814               
10815 332C 0201  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X to loop through the 4 energy
     332E 0300     
10816                                                                          ; bank indicators, so we can calculate each of the four
10817                                                                          ; energy banks' values and store them in XX12
10818               
10819 3330 D020  30        movb @ENERGY,ra                 ; LDA ENERGY        ; Set A = Q = ENERGY / 4, so they are both now in the
     3332 0F13     
10820 3334 0910  18        srl  ra,1                       ; LSR A             ; range 0-63 (so that's a maximum of 16 in each of the
10821 3336 0910  18        srl  ra,1                       ; LSR A             ; banks, and a maximum of 15 in the top bank)
10822               
10823 3338 D800  30        movb ra,@Q                      ; STA Q             ; Set Q to A, so we can use Q to hold the remaining
     333A 0090     
10824                                                                          ; energy as we work our way through each bank, from the
10825                                                                          ; full ones at the bottom to the empty ones at the top
10826               
10827               DLL24:
10828                      .sec                            ; SEC               ; Set A = A - 16 to reduce the energy count by a full
     **** ****     > SEC
0001 333C 0A15  18        sla  rmone,1
                   < elite.a99
10829                      .sbi (>10*256)                  ; SBC #16           ; bank
     **** ****     > SBI
0001 333E 1801  14        joc  !
0002 3340 7004  18        sb   rone,ra
0003               !:
0004 3342 0220  22        ai   ra,-(>10*256)
     3344 F000     
                   < elite.a99
10830               
10831 3346 170B  14        jnc  DLL26                      ; BCC DLL26         ; If the C flag is clear then A < 16, so this bank is
10832                                                                          ; not full to the brim, and is therefore the last one
10833                                                                          ; with any energy in it, so jump to DLL26
10834               
10835 3348 D800  30        movb ra,@Q                      ; STA Q             ; This bank is full, so update Q with the energy of the
     334A 0090     
10836                                                                          ; remaining banks
10837               
10838 334C 0200  20        li   ra,>10*256                 ; LDA #16           ; Store this bank's level in XX12 as 16, as it is full,
     334E 1000     
10839 3350 D840  38        movb ra,@XX12(rx)               ; STA XX12,X        ; with XX12+3 for the bottom bank and XX12+0 for the top
     3352 0037     
10840               
10841 3354 D020  30        movb @Q,ra                      ; LDA Q             ; Set A to the remaining energy level again
     3356 0090     
10842               
10843 3358 7044  18        sb   rone,rx                    ; DEX               ; Decrement X to point to the next bank, i.e. the one
10844                                                                          ; above the bank we just processed
10845               
10846 335A 15F0  14        jgt  DLL24                      ; BPL DLL24         ; Loop back to DLL24 until we have either processed all
10847                                                                          ; four banks, or jumped out early to DLL26 if the top
10848                                                                          ; banks have no charge
10849               
10850 335C 1104  14        jlt  DLL9                       ; BMI DLL9          ; Jump to DLL9 as we have processed all four banks (this
10851                                                                          ; BMI is effectively a JMP as A will never be positive)
10852               
10853               DLL26:
10854 335E D020  30        movb @Q,ra                      ; LDA Q             ; If we get here then the bank we just checked is not
     3360 0090     
10855 3362 D840  38        movb ra,@XX12(rx)               ; STA XX12,X        ; fully charged, so store its value in XX12 (using Q,
     3364 0037     
10856                                                                          ; which contains the energy of the remaining banks -
10857                                                                          ; i.e. this one)
10858               
10859                                                                          ; Now that we have the four energy bank values in XX12,
10860                                                                          ; we can draw them, starting with the top bank in XX12
10861                                                                          ; and looping down to the bottom bank in XX12+3, using Y
10862                                                                          ; as a loop counter, which was set to 0 above
10863               
10864               DLL9:
10865 3366 D022  34        movb @XX12(ry),ra               ; LDA XX12,Y        ; Fetch the value of the Y-th indicator, starting from
     3368 0037     
10866                                                                          ; the top
10867               
10868 336A D802  30        movb ry,@P                      ; STY P             ; Store the indicator number in P for retrieval later
     336C 001B     
10869               
10870 336E 0206  20        li   rtmp,DIL                   ; JSR DIL           ; Draw the energy bank using a range of 0-15, and
     3370 342C     
10871 3372 06A0  28        bl   @jsr                       ;
     3374 8002     
10872                                                                          ; increment SC to point to the next indicator (the
10873                                                                          ; next energy bank down)
10874               
10875 3376 D0A0  30        movb @P,ry                      ; LDY P             ; Restore the indicator number into Y
     3378 001B     
10876               
10877 337A B084  18        ab   rone,ry                    ; INY               ; Increment the indicator number
10878               
10879 337C 0282  22        ci   ry,>04*256                 ; CPY #4            ; Check to see if we have drawn the last energy bank
     337E 0400     
10880               
10881 3380 16F2  14        jne  DLL9                       ; BNE DLL9          ; Loop back to DLL9 if we have more banks to draw,
10882                                                                          ; otherwise we are done
10883               
10884               * ******************************************************************************
10885               *
10886               * Name: DIALS (Part 4 of 4)
10887               * Type: Subroutine
10888               * Category: Dashboard
10889               * Summary: Update the dashboard: shields, fuel, laser & cabin temp, altitude
10890               * Deep dive: The dashboard indicators
10891               *
10892               * ******************************************************************************
10893               
10894 3382 0200  20        li   ra,>78*256                 ; LDA #&78          ; Set SC(1 0) = &7810, which is the screen address for
     3384 7800     
10895 3386 D800  30        movb ra,@SC+1                   ; STA SC+1          ; the character block containing the left end of the
     3388 0008     
10896 338A 0200  20        li   ra,>10*256                 ; LDA #&10          ; top indicator in the left part of the dashboard, the
     338C 1000     
10897 338E D800  30        movb ra,@SC                     ; STA SC            ; one showing the forward shield
     3390 0007     
10898               
10899 3392 D020  30        movb @FSH,ra                    ; LDA FSH           ; Draw the forward shield indicator using a range of
     3394 0F11     
10900 3396 0206  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     3398 3424     
10901 339A 06A0  28        bl   @jsr                       ;
     339C 8002     
10902                                                                          ; (the aft shield)
10903               
10904 339E D020  30        movb @ASH,ra                    ; LDA ASH           ; Draw the aft shield indicator using a range of 0-255,
     33A0 0F12     
10905 33A2 0206  20        li   rtmp,DILX                  ; JSR DILX          ; and increment SC to point to the next indicator (the
     33A4 3424     
10906 33A6 06A0  28        bl   @jsr                       ;
     33A8 8002     
10907                                                                          ; fuel level)
10908               
10909 33AA D020  30        movb @QQ14,ra                   ; LDA QQ14          ; Draw the fuel level indicator using a range of 0-63,
     33AC 030D     
10910 33AE 0206  20        li   rtmp,DILX+2                ; JSR DILX+2        ; and increment SC to point to the next indicator (the
     33B0 3426     
10911 33B2 06A0  28        bl   @jsr                       ;
     33B4 8002     
10912                                                                          ; cabin temperature)
10913               
10914 33B6 0206  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     33B8 3402     
10915 33BA 06A0  28        bl   @jsr                       ;
     33BC 8002     
10916                                                                          ; and X to the colour for safe values
10917               
10918 33BE D801  30        movb rx,@K+1                    ; STX K+1           ; Set K+1 (the colour we should show for low values) to
     33C0 003E     
10919                                                                          ; X (the colour to use for safe values)
10920               
10921 33C2 D800  30        movb ra,@K                      ; STA K             ; Set K (the colour we should show for high values) to
     33C4 003D     
10922                                                                          ; A (the colour to use for dangerous values)
10923               
10924                                                                          ; The above sets the following indicators to show red
10925                                                                          ; for high values and yellow/white for low values, which
10926                                                                          ; we use for the cabin and laser temperature bars
10927               
10928 33C6 0201  20        li   rx,>0b*256                 ; LDX #11           ; Set T1 to 11, the threshold at which we change the
     33C8 0B00     
10929 33CA D801  30        movb rx,@T1                     ; STX T1            ; cabin and laser temperature indicators' colours
     33CC 0006     
10930               
10931 33CE D020  30        movb @CABTMP,ra                 ; LDA CABTMP        ; Draw the cabin temperature indicator using a range of
     33D0 0D4D     
10932 33D2 0206  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     33D4 3424     
10933 33D6 06A0  28        bl   @jsr                       ;
     33D8 8002     
10934                                                                          ; (the laser temperature)
10935               
10936 33DA D020  30        movb @GNTMP,ra                  ; LDA GNTMP         ; Draw the laser temperature indicator using a range of
     33DC 0D61     
10937 33DE 0206  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     33E0 3424     
10938 33E2 06A0  28        bl   @jsr                       ;
     33E4 8002     
10939                                                                          ; (the altitude)
10940               
10941 33E6 0200  20        li   ra,>f0*256                 ; LDA #240          ; Set T1 to 240, the threshold at which we change the
     33E8 F000     
10942 33EA D800  30        movb ra,@T1                     ; STA T1            ; altitude indicator's colour. As the altitude has a
     33EC 0006     
10943                                                                          ; range of 0-255, pixel 16 will not be filled in, and
10944                                                                          ; 240 would change the colour when moving between pixels
10945                                                                          ; 15 and 16, so this effectively switches off the colour
10946                                                                          ; change for the altitude indicator
10947               
10948 33EE D800  30        movb ra,@K+1                    ; STA K+1           ; Set K+1 (the colour we should show for low values) to
     33F0 003E     
10949                                                                          ; 240, or &F0 (dashboard colour 2, yellow/white), so the
10950                                                                          ; altitude indicator always shows in this colour
10951               
10952 33F2 D020  30        movb @ALTIT,ra                  ; LDA ALTIT         ; Draw the altitude indicator using a range of 0-255
     33F4 0F21     
10953 33F6 0206  20        li   rtmp,DILX                  ; JSR DILX
     33F8 3424     
10954 33FA 06A0  28        bl   @jsr                       ;
     33FC 8002     
10955               
10956 33FE 0460  28        b    @COMPAS                    ; JMP COMPAS        ; We have now drawn all the indicators, so jump to
     3400 6CEA     
10957                                                                          ; COMPAS to draw the compass, returning from the
10958                                                                          ; subroutine using a tail call
10959               
10960               * ******************************************************************************
10961               *
10962               * Name: PZW
10963               * Type: Subroutine
10964               * Category: Dashboard
10965               * Summary: Fetch the current dashboard colours, to support flashing
10966               *
10967               * ------------------------------------------------------------------------------
10968               *
10969               * Set A and X to the colours we should use for indicators showing dangerous and
10970               * safe values respectively. This enables us to implement flashing indicators,
10971               * which is one of the game's configurable options.
10972               *
10973               * If flashing is enabled, the colour returned in A (dangerous values) will be
10974               * red for 8 iterations of the main loop, and yellow/white for the next 8, before
10975               * going back to red. If we always use PZW to decide which colours we should use
10976               * when updating indicators, flashing colours will be automatically taken care of
10977               * for us.
10978               *
10979               * The values returned are &F0 for yellow/white and &0F for red. These are mode 5
10980               * bytes that contain 4 pixels, with the colour of each pixel given in two bits,
10981               * the high bit from the first nibble (bits 4-7) and the low bit from the second
10982               * nibble (bits 0-3). So in &F0 each pixel is %10, or colour 2 (yellow or white,
10983               * depending on the dashboard palette), while in &0F each pixel is %01, or colour
10984               * 1 (red).
10985               *
10986               * ------------------------------------------------------------------------------
10987               *
10988               * Returns:
10989               *
10990               * A                   The colour to use for indicators with dangerous values
10991               *
10992               * X                   The colour to use for indicators with safe values
10993               *
10994               * ******************************************************************************
10995               
10996               PZW:
10997 3402 0201  20        li   rx,>f0*256                 ; LDX #&F0          ; Set X to dashboard colour 2 (yellow/white)
     3404 F000     
10998               
10999 3406 D020  30        movb @MCNT,ra                   ; LDA MCNT          ; A will be non-zero for 8 out of every 16 main loop
     3408 0099     
11000 340A 0240  22        andi ra,>08*256                 ; AND #%00001000    ; counts, when bit 4 is set, so this is what we use to
     340C 0800     
11001                                                                          ; flash the "danger" colour
11002               
11003                      .and @FLH                       ; AND FLH           ; A will be zeroed if flashing colours are disabled
     **** ****     > AND
0001 340E D1A0  30        movb @FLH,rtmp
     3410 0F4D     
0002 3412 0546  14        inv  rtmp
0003 3414 5006  18        szcb rtmp,ra
                   < elite.a99
11004               
11005 3416 1302  14        jeq  B29                        ; BEQ B29           ; If A is zero, skip to the LDA instruction below
11006               
11007 3418 D001  18        movb rx,ra                      ; TXA               ; Otherwise flashing colours are enabled and it's the
11008                                                                          ; main loop iteration where we flash them, so set A to
11009                                                                          ; colour 2 (yellow/white) and use the BIT trick below to
11010                                                                          ; return from the subroutine
11011               
11012 341A 2C              byte >2c                                            ; Skip the next instruction by turning it into
11013                                                                          ; &2C &A9 &0F, or BIT &0FA9, which does nothing apart
11014                                                                          ; from affect the flags
11015               
11016               B29:
11017 341C 0200  20        li   ra,>0f*256                 ; LDA #&0F          ; Set A to dashboard colour 1 (red)
     341E 0F00     
11018               
11019 3420 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3422 800E     
11020               
11021               * ******************************************************************************
11022               *
11023               * Name: DILX
11024               * Type: Subroutine
11025               * Category: Dashboard
11026               * Summary: Update a bar-based indicator on the dashboard
11027               * Deep dive: The dashboard indicators
11028               *
11029               * ------------------------------------------------------------------------------
11030               *
11031               * The range of values shown on the indicator depends on which entry point is
11032               * called. For the default entry point of DILX, the range is 0-255 (as the value
11033               * passed in A is one byte). The other entry points are shown below.
11034               *
11035               * ------------------------------------------------------------------------------
11036               *
11037               * Arguments:
11038               *
11039               * A                   The value to be shown on the indicator (so the larger
11040               * the value, the longer the bar)
11041               *
11042               * T1                  The threshold at which we change the indicator's colour
11043               * from the low value colour to the high value colour. The
11044               * threshold is in pixels, so it should have a value from
11045               * 0-16, as each bar indicator is 16 pixels wide
11046               *
11047               * K                   The colour to use when A is a high value, as a 4-pixel
11048               * mode 5 character row byte
11049               *
11050               * K+1                 The colour to use when A is a low value, as a 4-pixel
11051               * mode 5 character row byte
11052               *
11053               * SC(1 0)             The screen address of the first character block in the
11054               * indicator
11055               *
11056               * ------------------------------------------------------------------------------
11057               *
11058               * Other entry points:
11059               *
11060               * DILX+2              The range of the indicator is 0-64 (for the fuel
11061               * indicator)
11062               *
11063               * DIL-1               The range of the indicator is 0-32 (for the speed
11064               * indicator)
11065               *
11066               * DIL                 The range of the indicator is 0-16 (for the energy
11067               * banks)
11068               *
11069               * ******************************************************************************
11070               
11071               DILX:
11072 3424 0910  18        srl  ra,1                       ; LSR A             ; If we call DILX, we set A = A / 16, so A is 0-15
11073 3426 0910  18        srl  ra,1                       ; LSR A
11074               
11075 3428 0910  18        srl  ra,1                       ; LSR A             ; If we call DILX+2, we set A = A / 4, so A is 0-15
11076               
11077 342A 0910  18        srl  ra,1                       ; LSR A             ; If we call DIL-1, we set A = A / 2, so A is 0-15
11078               
11079               DIL:
11080                                                                          ; If we call DIL, we leave A alone, so A is 0-15
11081 342C D800  30        movb ra,@Q                      ; STA Q             ; Store the indicator value in Q, now reduced to 0-15,
     342E 0090     
11082                                                                          ; which is the length of the indicator to draw in pixels
11083               
11084 3430 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Set R = &FF, to use as a mask for drawing each row of
     3432 FF00     
11085 3434 D801  30        movb rx,@R                      ; STX R             ; each character block of the bar, starting with a full
     3436 0091     
11086                                                                          ; character's width of 4 pixels
11087               
11088 3438 9020  30        cb   @T1,ra                     ; CMP T1            ; If A >= T1 then we have passed the threshold where we
     343A 0006     
11089 343C 1803  14        joc  DL30                       ; BCS DL30          ; change bar colour, so jump to DL30 to set A to the
11090                                                                          ; "high value" colour
11091               
11092 343E D020  30        movb @K+1,ra                    ; LDA K+1           ; Set A to K+1, the "low value" colour to use
     3440 003E     
11093               
11094 3442 1602  14        jne  DL31                       ; BNE DL31          ; Jump down to DL31 (this BNE is effectively a JMP as A
11095                                                                          ; will never be zero)
11096               
11097               DL30:
11098 3444 D020  30        movb @K,ra                      ; LDA K             ; Set A to K, the "high value" colour to use
     3446 003D     
11099               
11100               DL31:
11101 3448 D800  30        movb ra,@COL                    ; STA COL           ; Store the colour of the indicator in COL
     344A 00A2     
11102               
11103 344C 0202  20        li   ry,>02*256                 ; LDY #2            ; We want to start drawing the indicator on the third
     344E 0200     
11104                                                                          ; line in this character row, so set Y to point to that
11105                                                                          ; row's offset
11106               
11107 3450 0201  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X for the width of the indicator,
     3452 0300     
11108                                                                          ; which is 4 characters (each of which is 4 pixels wide,
11109                                                                          ; to give a total width of 16 pixels)
11110               
11111               DL1:
11112 3454 D020  30        movb @Q,ra                      ; LDA Q             ; Fetch the indicator value (0-15) from Q into A
     3456 0090     
11113               
11114 3458 0280  22        ci   ra,>04*256                 ; CMP #4            ; If Q < 4, then we need to draw the end cap of the
     345A 0400     
11115 345C 172D  14        jnc  DL2                        ; BCC DL2           ; indicator, which is less than a full character's
11116                                                                          ; width, so jump down to DL2 to do this
11117               
11118                      .sbi (>04*256)                  ; SBC #4            ; Otherwise we can draw a 4-pixel wide block, so
     **** ****     > SBI
0001 345E 1801  14        joc  !
0002 3460 7004  18        sb   rone,ra
0003               !:
0004 3462 0220  22        ai   ra,-(>04*256)
     3464 FC00     
                   < elite.a99
11119 3466 D800  30        movb ra,@Q                      ; STA Q             ; subtract 4 from Q so it contains the amount of the
     3468 0090     
11120                                                                          ; indicator that's left to draw after this character
11121               
11122 346A D020  30        movb @R,ra                      ; LDA R             ; Fetch the shape of the indicator row that we need to
     346C 0091     
11123                                                                          ; display from R, so we can use it as a mask when
11124                                                                          ; painting the indicator. It will be &FF at this point
11125                                                                          ; (i.e. a full 4-pixel row)
11126               
11127               DL5:
11128                      .and @COL                       ; AND COL           ; Fetch the 4-pixel mode 5 colour byte from COL, and
     **** ****     > AND
0001 346E D1A0  30        movb @COL,rtmp
     3470 00A2     
0002 3472 0546  14        inv  rtmp
0003 3474 5006  18        szcb rtmp,ra
                   < elite.a99
11129                                                                          ; only keep pixels that have their equivalent bits set
11130                                                                          ; in the mask byte in A
11131               
11132                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the shape of the mask on pixel row Y of the
     **** ****     > ST_IND_Y_IDX
0001 3476 D820  42        movb @SC,@rtmplb
     3478 0007     
     347A 830D     
0002 347C D1A0  30        movb @SC+1,rtmp
     347E 0008     
0003 3480 A182  18        a    ry,rtmp
0004 3482 D580  30        movb RA,*rtmp
                   < elite.a99
11133                                                                          ; character block we are processing
11134               
11135 3484 B084  18        ab   rone,ry                    ; INY               ; Draw the next pixel row, incrementing Y
11136                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 3486 D820  42        movb @SC,@rtmplb
     3488 0007     
     348A 830D     
0002 348C D1A0  30        movb @SC+1,rtmp
     348E 0008     
0003 3490 A182  18        a    ry,rtmp
0004 3492 D580  30        movb RA,*rtmp
                   < elite.a99
11137               
11138 3494 B084  18        ab   rone,ry                    ; INY               ; And draw the third pixel row, incrementing Y
11139                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 3496 D820  42        movb @SC,@rtmplb
     3498 0007     
     349A 830D     
0002 349C D1A0  30        movb @SC+1,rtmp
     349E 0008     
0003 34A0 A182  18        a    ry,rtmp
0004 34A2 D580  30        movb RA,*rtmp
                   < elite.a99
11140               
11141 34A4 D002  18        movb ry,ra                      ; TYA               ; Add 6 to Y, so Y is now 8 more than when we started
11142                      .clc                            ; CLC               ; this loop iteration, so Y now points to the address
     **** ****     > CLC
0001 34A6 0A13  18        sla  rzero,1
                   < elite.a99
11143                      .adi (>06*256)                  ; ADC #6            ; of the first line of the indicator bar in the next
     **** ****     > ADI
0001 34A8 1701  14        jnc  !
0002 34AA B004  18        ab   rone,ra
0003               !:
0004 34AC 0220  22        ai   ra,(>06*256)
     34AE 0600     
                   < elite.a99
11144 34B0 D080  18        movb ra,ry                      ; TAY               ; character block (as each character is 8 bytes of
11145                                                                          ; screen memory)
11146               
11147 34B2 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter for the next character
11148                                                                          ; block along in the indicator
11149               
11150 34B4 111D  14        jlt  DL6                        ; BMI DL6           ; If we just drew the last character block then we are
11151                                                                          ; done drawing, so jump down to DL6 to finish off
11152               
11153 34B6 15CE  14        jgt  DL1                        ; BPL DL1           ; Loop back to DL1 to draw the next character block of
11154                                                                          ; the indicator (this BPL is effectively a JMP as A will
11155                                                                          ; never be negative following the previous BMI)
11156               
11157               DL2:
11158                      .eoi (>03*256)                  ; EOR #3            ; If we get here then we are drawing the indicator's
     **** ****     > EOI
0001 34B8 0206  20        li   rtmp,(>03*256)
     34BA 0300     
0002 34BC 2806  18        xor  rtmp,ra
                   < elite.a99
11159 34BE D800  30        movb ra,@Q                      ; STA Q             ; end cap, so Q is < 4, and this EOR flips the bits, so
     34C0 0090     
11160                                                                          ; instead of containing the number of indicator columns
11161                                                                          ; we need to fill in on the left side of the cap's
11162                                                                          ; character block, Q now contains the number of blank
11163                                                                          ; columns there should be on the right side of the cap's
11164                                                                          ; character block
11165               
11166 34C2 D020  30        movb @R,ra                      ; LDA R             ; Fetch the current mask from R, which will be &FF at
     34C4 0091     
11167                                                                          ; this point, so we need to turn Q of the columns on the
11168                                                                          ; right side of the mask to black to get the correct end
11169                                                                          ; cap shape for the indicator
11170               
11171               DL3:
11172                      .asla                           ; ASL A             ; Shift the mask left so bit 0 is cleared, and then
     **** ****     > ASLA
0001 34C6 0240  22        andi ra,>ff00
     34C8 FF00     
0002 34CA 0A10  18        sla  ra,1
                   < elite.a99
11173 34CC 0240  22        andi ra,>ef*256                 ; AND #%11101111    ; clear bit 4, which has the effect of shifting zeroes
     34CE EF00     
11174                                                                          ; from the left into each nibble (i.e. xxxx xxxx becomes
11175                                                                          ; xxx0 xxx0, which blanks out the last column in the
11176                                                                          ; 4-pixel mode 5 character block)
11177               
11178 34D0 7004  18        sb   rone,ra                    ; DEC Q             ; Decrement the counter for the number of columns to
11179                                                                          ; blank out
11180               
11181 34D2 15F9  14        jgt  DL3                        ; BPL DL3           ; If we still have columns to blank out in the mask,
11182                                                                          ; loop back to DL3 until the mask is correct for the
11183                                                                          ; end cap
11184               
11185                      .pha                            ; PHA               ; Store the mask byte on the stack while we use the
     **** ****     > PHA
0001 34D4 D680  30        movb ra,*rsp
0002 34D6 060A  14        dec  rsp
                   < elite.a99
11186                                                                          ; accumulator for a bit
11187               
11188 34D8 0200  20        li   ra,>00*256                 ; LDA #0            ; Change the mask so no bits are set, so the characters
     34DA 0000     
11189 34DC D800  30        movb ra,@R                      ; STA R             ; after the one we're about to draw will be all blank
     34DE 0091     
11190               
11191 34E0 0200  20        li   ra,>63*256                 ; LDA #99           ; Set Q to a high number (99, why not) so we will keep
     34E2 6300     
11192 34E4 D800  30        movb ra,@Q                      ; STA Q             ; drawing blank characters until we reach the end of
     34E6 0090     
11193                                                                          ; the indicator row
11194               
11195                      .pla                            ; PLA               ; Restore the mask byte from the stack so we can use it
     **** ****     > PLA
0001 34E8 058A  14        inc  rsp
0002 34EA D01A  26        movb *rsp,ra
                   < elite.a99
11196                                                                          ; to draw the end cap of the indicator
11197               
11198 34EC 0460  28        b    @DL5                       ; JMP DL5           ; Jump back up to DL5 to draw the mask byte on-screen
     34EE 346E     
11199               
11200               DL6:
11201 34F0 B004  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of SC to point to the next
11202                                                                          ; character row on-screen (as each row takes up exactly
11203                                                                          ; one page of 256 bytes) - so this sets up SC to point
11204                                                                          ; to the next indicator, i.e. the one below the one we
11205                                                                          ; just drew
11206               
11207               DL9:
11208 34F2 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     34F4 800E     
11209               
11210               * ******************************************************************************
11211               *
11212               * Name: DIL2
11213               * Type: Subroutine
11214               * Category: Dashboard
11215               * Summary: Update the roll or pitch indicator on the dashboard
11216               * Deep dive: The dashboard indicators
11217               *
11218               * ------------------------------------------------------------------------------
11219               *
11220               * The indicator can show a vertical bar in 16 positions, with a value of 8
11221               * showing the bar in the middle of the indicator.
11222               *
11223               * In practice this routine is only ever called with A in the range 1 to 15, so
11224               * the vertical bar never appears in the leftmost position (though it does appear
11225               * in the rightmost).
11226               *
11227               * ------------------------------------------------------------------------------
11228               *
11229               * Arguments:
11230               *
11231               * A                   The offset of the vertical bar to show in the indicator,
11232               * from 0 at the far left, to 8 in the middle, and 15 at
11233               * the far right
11234               *
11235               * ------------------------------------------------------------------------------
11236               *
11237               * Returns:
11238               *
11239               * C flag              The C flag is set
11240               *
11241               * ******************************************************************************
11242               
11243               DIL2:
11244 34F6 0202  20        li   ry,>01*256                 ; LDY #1            ; We want to start drawing the vertical indicator bar on
     34F8 0100     
11245                                                                          ; the second line in the indicator's character block, so
11246                                                                          ; set Y to point to that row's offset
11247               
11248 34FA D800  30        movb ra,@Q                      ; STA Q             ; Store the offset of the vertical bar to draw in Q
     34FC 0090     
11249               
11250                                                                          ; We are now going to work our way along the indicator
11251                                                                          ; on the dashboard, from left to right, working our way
11252                                                                          ; along one character block at a time. Y will be used as
11253                                                                          ; a pixel row counter to work our way through the
11254                                                                          ; character blocks, so each time we draw a character
11255                                                                          ; block, we will increment Y by 8 to move on to the next
11256                                                                          ; block (as each character block contains 8 rows)
11257               
11258               DLL10:
11259                      .sec                            ; SEC               ; Set A = Q - 4, so that A contains the offset of the
     **** ****     > SEC
0001 34FE 0A15  18        sla  rmone,1
                   < elite.a99
11260 3500 D020  30        movb @Q,ra                      ; LDA Q             ; vertical bar from the start of this character block
     3502 0090     
11261                      .sbi (>04*256)                  ; SBC #4
     **** ****     > SBI
0001 3504 1801  14        joc  !
0002 3506 7004  18        sb   rone,ra
0003               !:
0004 3508 0220  22        ai   ra,-(>04*256)
     350A FC00     
                   < elite.a99
11262               
11263 350C 180B  14        joc  DLL11                      ; BCS DLL11         ; If Q >= 4 then the character block we are drawing does
11264                                                                          ; not contain the vertical indicator bar, so jump to
11265                                                                          ; DLL11 to draw a blank character block
11266               
11267 350E 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to a high number (and &FF is as high as they go)
     3510 FF00     
11268               
11269 3512 D060  30        movb @Q,rx                      ; LDX Q             ; Set X to the offset of the vertical bar, which we know
     3514 0090     
11270                                                                          ; is within this character block
11271               
11272 3516 D800  30        movb ra,@Q                      ; STA Q             ; Set Q to a high number (&FF, why not) so we will keep
     3518 0090     
11273                                                                          ; drawing blank characters after this one until we reach
11274                                                                          ; the end of the indicator row
11275               
11276 351A D021  34        movb @CTWOS(rx),ra              ; LDA CTWOS,X       ; CTWOS is a table of ready-made 1-pixel mode 5 bytes,
     351C 2249     
11277                                                                          ; just like the TWOS and TWOS2 tables for mode 4 (see
11278                                                                          ; the PIXEL routine for details of how they work). This
11279                                                                          ; fetches a mode 5 1-pixel byte with the pixel position
11280                                                                          ; at X, so the pixel is at the offset that we want for
11281                                                                          ; our vertical bar
11282               
11283 351E 0240  22        andi ra,>f0*256                 ; AND #&F0          ; The 4-pixel mode 5 colour byte &F0 represents four
     3520 F000     
11284                                                                          ; pixels of colour %10 (3), which is yellow in the
11285                                                                          ; normal dashboard palette and white if we have an
11286                                                                          ; escape pod fitted. We AND this with A so that we only
11287                                                                          ; keep the pixel that matches the position of the
11288                                                                          ; vertical bar (i.e. A is acting as a mask on the
11289                                                                          ; 4-pixel colour byte)
11290               
11291 3522 1604  14        jne  DLL12                      ; BNE DLL12         ; Jump to DLL12 to skip the code for drawing a blank,
11292                                                                          ; and move on to drawing the indicator (this BNE is
11293                                                                          ; effectively a JMP as A is always non-zero)
11294               
11295               DLL11:
11296                                                                          ; If we get here then we want to draw a blank for this
11297                                                                          ; character block
11298 3524 D800  30        movb ra,@Q                      ; STA Q             ; Update Q with the new offset of the vertical bar, so
     3526 0090     
11299                                                                          ; it becomes the offset after the character block we
11300                                                                          ; are about to draw
11301               
11302 3528 0200  20        li   ra,>00*256                 ; LDA #0            ; Change the mask so no bits are set, so all of the
     352A 0000     
11303                                                                          ; character blocks we display from now on will be blank
11304               DLL12:
11305                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the shape of the mask on pixel row Y of the
     **** ****     > ST_IND_Y_IDX
0001 352C D820  42        movb @SC,@rtmplb
     352E 0007     
     3530 830D     
0002 3532 D1A0  30        movb @SC+1,rtmp
     3534 0008     
0003 3536 A182  18        a    ry,rtmp
0004 3538 D580  30        movb RA,*rtmp
                   < elite.a99
11306                                                                          ; character block we are processing
11307               
11308 353A B084  18        ab   rone,ry                    ; INY               ; Draw the next pixel row, incrementing Y
11309                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 353C D820  42        movb @SC,@rtmplb
     353E 0007     
     3540 830D     
0002 3542 D1A0  30        movb @SC+1,rtmp
     3544 0008     
0003 3546 A182  18        a    ry,rtmp
0004 3548 D580  30        movb RA,*rtmp
                   < elite.a99
11310               
11311 354A B084  18        ab   rone,ry                    ; INY               ; And draw the third pixel row, incrementing Y
11312                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 354C D820  42        movb @SC,@rtmplb
     354E 0007     
     3550 830D     
0002 3552 D1A0  30        movb @SC+1,rtmp
     3554 0008     
0003 3556 A182  18        a    ry,rtmp
0004 3558 D580  30        movb RA,*rtmp
                   < elite.a99
11313               
11314 355A B084  18        ab   rone,ry                    ; INY               ; And draw the fourth pixel row, incrementing Y
11315                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 355C D820  42        movb @SC,@rtmplb
     355E 0007     
     3560 830D     
0002 3562 D1A0  30        movb @SC+1,rtmp
     3564 0008     
0003 3566 A182  18        a    ry,rtmp
0004 3568 D580  30        movb RA,*rtmp
                   < elite.a99
11316               
11317 356A D002  18        movb ry,ra                      ; TYA               ; Add 5 to Y, so Y is now 8 more than when we started
11318                      .clc                            ; CLC               ; this loop iteration, so Y now points to the address
     **** ****     > CLC
0001 356C 0A13  18        sla  rzero,1
                   < elite.a99
11319                      .adi (>05*256)                  ; ADC #5            ; of the first line of the indicator bar in the next
     **** ****     > ADI
0001 356E 1701  14        jnc  !
0002 3570 B004  18        ab   rone,ra
0003               !:
0004 3572 0220  22        ai   ra,(>05*256)
     3574 0500     
                   < elite.a99
11320 3576 D080  18        movb ra,ry                      ; TAY               ; character block (as each character is 8 bytes of
11321                                                                          ; screen memory)
11322               
11323 3578 0282  22        ci   ry,>1e*256                 ; CPY #30           ; If Y < 30 then we still have some more character
     357A 1E00     
11324 357C 17C0  14        jnc  DLL10                      ; BCC DLL10         ; blocks to draw, so loop back to DLL10 to display the
11325                                                                          ; next one along
11326               
11327 357E B004  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of SC to point to the next
11328                                                                          ; character row on-screen (as each row takes up exactly
11329                                                                          ; one page of 256 bytes) - so this sets up SC to point
11330                                                                          ; to the next indicator, i.e. the one below the one we
11331                                                                          ; just drew
11332               
11333 3580 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3582 800E     
11334               
11335               * ******************************************************************************
11336               *
11337               * Name: TVT1
11338               * Type: Variable
11339               * Category: Drawing the screen
11340               * Summary: Palette data for space and the two dashboard colour schemes
11341               *
11342               * ------------------------------------------------------------------------------
11343               *
11344               * Palette bytes for use with the split-screen mode (see IRQ1 below for more
11345               * details).
11346               *
11347               * Palette data is given as a set of bytes, with each byte mapping a logical
11348               * colour to a physical one. In each byte, the logical colour is given in bits
11349               * 4-7 and the physical colour in bits 0-3. See p.379 of the Advanced User Guide
11350               * for details of how palette mapping works, as in modes 4 and 5 we have to do
11351               * multiple palette commands to change the colours correctly, and the physical
11352               * colour value is EOR'd with 7, just to make things even more confusing.
11353               *
11354               * Similarly, the palette at TVT1+16 is for the monochrome space view, where
11355               * logical colour 1 is mapped to physical colour 0 EOR 7 = 7 (white), and
11356               * logical colour 0 is mapped to physical colour 7 EOR 7 = 0 (black). Each of
11357               * these mappings requires six calls to SHEILA &21 - see p.379 of the Advanced
11358               * User Guide for an explanation.
11359               *
11360               * The mode 5 palette table has two blocks which overlap. The block used depends
11361               * on whether or not we have an escape pod fitted. The block at TVT1 is used for
11362               * the standard dashboard colours, while TVT1+8 is used for the dashboard when an
11363               * escape pod is fitted. The colours are as follows:
11364               *
11365               * Normal (TVT1)     Escape pod (TVT1+8)
11366               *
11367               * Colour 0      Black             Black
11368               * Colour 1      Red               Red
11369               * Colour 2      Yellow            White
11370               * Colour 3      Green             Cyan
11371               *
11372               * ******************************************************************************
11373               
11374               TVT1:
11375 3584 D4C4            byte >d4,>c4                                        ; This block of palette data is used to create two
11376 3586 9484            byte >94,>84                                        ; palettes used in three different places, all of them
11377 3588 F5E5            byte >f5,>e5                                        ; redefining four colours in mode 5:
11378 358A B5A5            byte >b5,>a5                                        ;
11379                                                                          ; 12 bytes from TVT1 (i.e. the first 6 rows): applied
11380 358C 7666            byte >76,>66                                        ; when the T1 timer runs down at the switch from the
11381 358E 3626            byte >36,>26                                        ; space view to the dashboard, so this is the standard
11382                                                                          ; dashboard palette
11383 3590 E1F1            byte >e1,>f1                                        ;
11384 3592 B1A1            byte >b1,>a1                                        ; 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
11385                                                                          ; when the T1 timer runs down at the switch from the
11386                                                                          ; space view to the dashboard, and we have an escape
11387                                                                          ; pod fitted, so this is the escape pod dashboard
11388                                                                          ; palette
11389                                                                          ;
11390                                                                          ; 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
11391                                                                          ; at vertical sync in LINSCN when HFX is non-zero, to
11392                                                                          ; create the hyperspace effect in LINSCN (where the
11393                                                                          ; whole screen is switched to mode 5 at vertical sync)
11394               
11395 3594 F0E0            byte >f0,>e0                                        ; 12 bytes of palette data at TVT1+16, used to set the
11396 3596 B0A0            byte >b0,>a0                                        ; mode 4 palette in LINSCN when we hit vertical sync,
11397 3598 D0C0            byte >d0,>c0                                        ; so the palette is set to monochrome when we start to
11398 359A 9080            byte >90,>80                                        ; draw the first row of the screen
11399 359C 7767            byte >77,>67
11400 359E 3727            byte >37,>27
11401               
11402               * ******************************************************************************
11403               *
11404               * Name: IRQ1
11405               * Type: Subroutine
11406               * Category: Drawing the screen
11407               * Summary: The main screen-mode interrupt handler (IRQ1V points here)
11408               * Deep dive: The split-screen mode in BBC Micro Elite
11409               *
11410               * ------------------------------------------------------------------------------
11411               *
11412               * The main interrupt handler, which implements Elite's split-screen mode (see
11413               * the deep dive on "The split-screen mode in BBC Micro Elite" for details).
11414               *
11415               * IRQ1V is set to point to IRQ1 by the loading process.
11416               *
11417               * ******************************************************************************
11418               
11419               LINSCN:
11420                                                                          ; This is called from the interrupt handler below, at
11421                                                                          ; the start of each vertical sync (i.e. when the screen
11422                                                                          ; refresh starts)
11423 35A0 0200  20        li   ra,>1e*256                 ; LDA #30           ; Set the line scan counter to a non-zero value, so
     35A2 1E00     
11424 35A4 D800  30        movb ra,@DL                     ; STA DL            ; routines like WSCAN can set DL to 0 and then wait for
     35A6 009A     
11425                                                                          ; it to change to non-zero to catch the vertical sync
11426               
11427 35A8 D800  38        movb ra,@VIA+>44                ; STA VIA+&44       ; Set 6522 System VIA T1C-L timer 1 low-order counter
     35AA FE44     
11428                                                                          ; (SHEILA &44) to 30
11429               
11430 35AC 0200  20        li   ra,(VSCAN)*256             ; LDA #VSCAN        ; Set 6522 System VIA T1C-L timer 1 high-order counter
     35AE 3900     
11431 35B0 D800  38        movb ra,@VIA+>45                ; STA VIA+&45       ; (SHEILA &45) to VSCAN (57) to start the T1 counter
     35B2 FE45     
11432                                                                          ; counting down from 14622 at a rate of 1 MHz
11433               
11434 35B4 D020  30        movb @HFX,ra                    ; LDA HFX           ; If HFX is non-zero, jump to VNT1 to set the mode 5
     35B6 0D62     
11435 35B8 163D  14        jne  VNT1                       ; BNE VNT1          ; palette instead of switching to mode 4, which will
11436                                                                          ; have the effect of blurring and colouring the top
11437                                                                          ; screen. This is how the white hyperspace rings turn
11438                                                                          ; to colour when we do a hyperspace jump, and is
11439                                                                          ; triggered by setting HFX to 1 in routine LL164
11440               
11441 35BA 0200  20        li   ra,>08*256                 ; LDA #%00001000    ; Set the Video ULA control register (SHEILA &20) to
     35BC 0800     
11442 35BE D800  38        movb ra,@VIA+>20                ; STA VIA+&20       ; %00001000, which is the same as switching to mode 4
     35C0 FE20     
11443                                                                          ; (i.e. the top part of the screen) but with no cursor
11444               
11445               VNT3:
11446 35C2 D022  34        movb @TVT1+16(ry),ra            ; LDA TVT1+16,Y     ; Copy the Y-th palette byte from TVT1+16 to SHEILA &21
     35C4 3594     
11447 35C6 D800  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     35C8 FE21     
11448                                                                          ; of the screen (i.e. the dashboard)
11449               
11450 35CA 7084  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11451               
11452 35CC 15FA  14        jgt  VNT3                       ; BPL VNT3          ; Loop back to VNT3 until we have copied all the
11453                                                                          ; palette bytes
11454               
11455 35CE D020  30        movb @LASCT,ra                  ; LDA LASCT         ; Decrement the value of LASCT, but if we go too far
     35D0 0D60     
11456 35D2 1301  14        jeq  B30                        ; BEQ B30           ; and it becomes negative, bump it back up again (this
11457 35D4 7004  18        sb   rone,ra                    ; DEC LASCT         ; controls the pulsing of pulse lasers)
11458               
11459               B30:
11460 35D6 D020  34        movb @SVN,ra                    ; LDA SVN           ; If SVN is non-zero, we are in the process of saving
     35D8 7FFF     
11461 35DA 1623  14        jne  jvec_                      ; BNE jvec          ; the commander file, so jump to jvec to pass control
11462                                                                          ; to the next interrupt handler, so we don't break file
11463                                                                          ; saving by blocking the interrupt chain
11464               
11465                      .pla                            ; PLA               ; Otherwise restore Y from the stack
     **** ****     > PLA
0001 35DC 058A  14        inc  rsp
0002 35DE D01A  26        movb *rsp,ra
                   < elite.a99
11466 35E0 D080  18        movb ra,ry                      ; TAY
11467               
11468 35E2 D020  34        movb @VIA+>41,ra                ; LDA VIA+&41       ; Read 6522 System VIA input register IRA (SHEILA &41)
     35E4 FE41     
11469               
11470 35E6 D020  30        movb @>FC,ra                    ; LDA &FC           ; Set A to the interrupt accumulator save register,
     35E8 00FC     
11471                                                                          ; which restores A to the value it had on entering the
11472                                                                          ; interrupt
11473               
11474                      ; RTI                           ; RTI               ; Return from interrupts, so this interrupt is not
11475                                                                          ; passed on to the next interrupt handler, but instead
11476                                                                          ; the interrupt terminates here
11477               
11478               IRQ1:
11479 35EA D002  18        movb ry,ra                      ; TYA               ; Store Y on the stack
11480                      .pha                            ; PHA
     **** ****     > PHA
0001 35EC D680  30        movb ra,*rsp
0002 35EE 060A  14        dec  rsp
                   < elite.a99
11481               
11482 35F0 0202  20        li   ry,>0b*256                 ; LDY #11           ; Set Y as a counter for 12 bytes, to use when setting
     35F2 0B00     
11483                                                                          ; the dashboard palette below
11484               
11485 35F4 0200  20        li   ra,>02*256                 ; LDA #%00000010    ; Read the 6522 System VIA status byte bit 1 (SHEILA
     35F6 0200     
11486                      .bit @VIA+>4D                   ; BIT VIA+&4D       ; &4D), which is set if vertical sync has occurred on
     **** ****     > BIT
0001 35F8 D1A0  34        movb @VIA+>4D,rtmp
     35FA FE4D     
0002 35FC 0546  14        inv  rtmp
0003 35FE D1C4  18        movb rone,rtmp2
0004 3600 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
11487                                                                          ; the video system
11488               
11489 3602 16CE  14        jne  LINSCN                     ; BNE LINSCN        ; If we are on the vertical sync pulse, jump to LINSCN
11490                                                                          ; to set up the timers to enable us to switch the
11491                                                                          ; screen mode between the space view and dashboard
11492               
11493 3604 190E  14        jno  jvec_                      ; BVC jvec          ; Read the 6522 System VIA status byte bit 6, which is
11494                                                                          ; set if timer 1 has timed out. We set the timer in
11495                                                                          ; LINSCN above, so this means we only run the next bit
11496                                                                          ; if the screen redraw has reached the boundary between
11497                                                                          ; the space view and the dashboard. Otherwise bit 6 is
11498                                                                          ; clear and we aren't at the boundary, so we jump to
11499                                                                          ; jvec to pass control to the next interrupt handler
11500               
11501                      .asla                           ; ASL A             ; Double the value in A to 4
     **** ****     > ASLA
0001 3606 0240  22        andi ra,>ff00
     3608 FF00     
0002 360A 0A10  18        sla  ra,1
                   < elite.a99
11502               
11503 360C D800  38        movb ra,@VIA+>20                ; STA VIA+&20       ; Set the Video ULA control register (SHEILA &20) to
     360E FE20     
11504                                                                          ; %00000100, which is the same as switching to mode 5,
11505                                                                          ; (i.e. the bottom part of the screen) but with no
11506                                                                          ; cursor
11507               
11508 3610 D020  30        movb @ESCP,ra                   ; LDA ESCP          ; If an escape pod is fitted, jump to VNT1 to set the
     3612 032E     
11509 3614 160F  14        jne  VNT1                       ; BNE VNT1          ; mode 5 palette differently (so the dashboard is a
11510                                                                          ; different colour if we have an escape pod)
11511               
11512               B31:
11513 3616 D022  34        movb @TVT1(ry),ra               ; LDA TVT1,Y        ; Copy the Y-th palette byte from TVT1 to SHEILA &21
     3618 3584     
11514 361A D800  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     361C FE21     
11515                                                                          ; of the screen (i.e. the dashboard)
11516               
11517 361E 7084  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11518               
11519 3620 15FA  14        jgt  B31                        ; BPL B31           ; Loop back to the LDA TVT1,Y instruction until we have
11520                                                                          ; copied all the palette bytes
11521               
11522               jvec_:
11523                      .pla                            ; PLA               ; Restore Y from the stack
     **** ****     > PLA
0001 3622 058A  14        inc  rsp
0002 3624 D01A  26        movb *rsp,ra
                   < elite.a99
11524 3626 D080  18        movb ra,ry                      ; TAY
11525               
11526                      .jmpi @VEC                      ; JMP (VEC)         ; Jump to the address in VEC, which was set to the
     **** ****     > JMPI
0001 3628 D821  46        movb @VEC(rx),@rtmplb
     362A 8000     
     362C 830D     
0002 362E D1A1  34        movb @VEC+1(rx),rtmp
     3630 8001     
0003 3632 0456  20        b    *rtmp
                   < elite.a99
11527                                                                          ; original IRQ1V vector by the loading process, so this
11528                                                                          ; instruction passes control to the next interrupt
11529                                                                          ; handler
11530               
11531               VNT1:
11532 3634 0202  20        li   ry,>07*256                 ; LDY #7            ; Set Y as a counter for 8 bytes
     3636 0700     
11533               
11534 3638 D022  34        movb @TVT1+8(ry),ra             ; LDA TVT1+8,Y      ; Copy the Y-th palette byte from TVT1+8 to SHEILA &21
     363A 358C     
11535 363C D800  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     363E FE21     
11536                                                                          ; of the screen (i.e. the dashboard)
11537               
11538 3640 7084  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11539               
11540 3642 15F9  14        jgt  VNT1+2                     ; BPL VNT1+2        ; Loop back to the LDA TVT1+8,Y instruction until we
11541                                                                          ; have copied all the palette bytes
11542               
11543 3644 11EE  14        jlt  jvec_                      ; BMI jvec          ; Jump up to jvec to pass control to the next interrupt
11544                                                                          ; handler (this BMI is effectively a JMP as we didn't
11545                                                                          ; loop back with the BPL above, so BMI is always true)
11546               
11547               * ******************************************************************************
11548               *
11549               * Name: ESCAPE
11550               * Type: Subroutine
11551               * Category: Flight
11552               * Summary: Launch our escape pod
11553               *
11554               * ------------------------------------------------------------------------------
11555               *
11556               * This routine displays our doomed Cobra Mk III disappearing off into the ether
11557               * before arranging our replacement ship. Called when we press ESCAPE during
11558               * flight and have an escape pod fitted.
11559               *
11560               * ******************************************************************************
11561               
11562               ESCAPE:
11563 3646 D020  30        movb @MJ,ra                     ; LDA MJ            ; Store the value of MJ on the stack (the "are we in
     3648 0D5C     
11564                      .pha                            ; PHA               ; witchspace?" flag)
     **** ****     > PHA
0001 364A D680  30        movb ra,*rsp
0002 364C 060A  14        dec  rsp
                   < elite.a99
11565               
11566 364E 0206  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     3650 7F26     
11567 3652 06A0  28        bl   @jsr                       ;
     3654 8002     
11568               
11569 3656 0201  20        li   rx,(CYL)*256               ; LDX #CYL          ; Set the current ship type to a Cobra Mk III, so we
     3658 0700     
11570 365A D801  30        movb rx,@TYPE                   ; STX TYPE          ; can show our ship disappear into the distance when we
     365C 009B     
11571                                                                          ; eject in our pod
11572               
11573 365E 0206  20        li   rtmp,FRS1                  ; JSR FRS1          ; Call FRS1 to launch the Cobra Mk III straight ahead,
     3660 3BD8     
11574 3662 06A0  28        bl   @jsr                       ;
     3664 8002     
11575                                                                          ; like a missile launch, but with our ship instead
11576               
11577 3666 0200  20        li   ra,>08*256                 ; LDA #8            ; Set the Cobra's byte #27 (speed) to 8
     3668 0800     
11578 366A D800  30        movb ra,@INWK+27                ; STA INWK+27
     366C 006E     
11579               
11580 366E 0200  20        li   ra,>c2*256                 ; LDA #194          ; Set the Cobra's byte #30 (pitch counter) to 194, so it
     3670 C200     
11581 3672 D800  30        movb ra,@INWK+30                ; STA INWK+30       ; pitches up as we pull away
     3674 0071     
11582               
11583 3676 0910  18        srl  ra,1                       ; LSR A             ; Set the Cobra's byte #32 (AI flag) to %01100001, so it
11584 3678 D800  30        movb ra,@INWK+32                ; STA INWK+32       ; has no AI, and we can use this value as a counter to
     367A 0073     
11585                                                                          ; do the following loop 97 times
11586               
11587               ESL1:
11588 367C 0206  20        li   rtmp,MVEIT                 ; JSR MVEIT         ; Call MVEIT to move the Cobra in space
     367E 17E2     
11589 3680 06A0  28        bl   @jsr                       ;
     3682 8002     
11590               
11591 3684 0206  20        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to draw the Cobra on-screen
     3686 94A8     
11592 3688 06A0  28        bl   @jsr                       ;
     368A 8002     
11593               
11594 368C 7004  18        sb   rone,ra                    ; DEC INWK+32       ; Decrement the counter in byte #32
11595               
11596 368E 16F6  14        jne  ESL1                       ; BNE ESL1          ; Loop back to keep moving the Cobra until the AI flag
11597                                                                          ; is 0, which gives it time to drift away from our pod
11598               
11599 3690 0206  20        li   rtmp,SCAN                  ; JSR SCAN          ; Call SCAN to remove the Cobra from the scanner (by
     3692 4C86     
11600 3694 06A0  28        bl   @jsr                       ;
     3696 8002     
11601                                                                          ; redrawing it)
11602               
11603 3698 0206  20        li   rtmp,RESET                 ; JSR RESET         ; Call RESET to reset our ship and various controls
     369A 7EFE     
11604 369C 06A0  28        bl   @jsr                       ;
     369E 8002     
11605               
11606                      .pla                            ; PLA               ; Restore the witchspace flag from before the escape pod
     **** ****     > PLA
0001 36A0 058A  14        inc  rsp
0002 36A2 D01A  26        movb *rsp,ra
                   < elite.a99
11607 36A4 1302  14        jeq  B32                        ; BEQ B32           ; launch, and if we were in normal space, skip the
11608                                                                          ; following instruction
11609               
11610 36A6 0460  24        b    @DEATH                     ; JMP DEATH         ; Launching an escape pod in witchspace is fatal, so
     36A8 8472     
11611                                                                          ; jump to DEATH to begin the funeral and return from the
11612                                                                          ; subroutine using a tail call
11613               
11614               B32:
11615 36AA 0201  20        li   rx,>10*256                 ; LDX #16           ; We lose all our cargo when using our escape pod, so
     36AC 1000     
11616                                                                          ; up a counter in X so we can zero the 17 cargo slots
11617                                                                          ; in QQ20
11618               
11619               ESL2:
11620 36AE D840  38        movb ra,@QQ20(rx)               ; STA QQ20,X        ; Set the X-th byte of QQ20 to zero (as we know A = 0
     36B0 0317     
11621                                                                          ; from the BEQ above), so we no longer have any of item
11622                                                                          ; type X in the cargo hold
11623               
11624 36B2 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
11625               
11626 36B4 15FC  14        jgt  ESL2                       ; BPL ESL2          ; Loop back to ESL2 until we have emptied the entire
11627                                                                          ; cargo hold
11628               
11629 36B6 D800  30        movb ra,@FIST                   ; STA FIST          ; Launching an escape pod also clears our criminal
     36B8 0334     
11630                                                                          ; record, so set our legal status in FIST to 0 ("clean")
11631               
11632 36BA D800  30        movb ra,@ESCP                   ; STA ESCP          ; The escape pod is a one-use item, so set ESCP to 0 so
     36BC 032E     
11633                                                                          ; we no longer have one fitted
11634               
11635 36BE 0200  20        li   ra,>46*256                 ; LDA #70           ; Our replacement ship is delivered with a full tank of
     36C0 4600     
11636 36C2 D800  30        movb ra,@QQ14                   ; STA QQ14          ; fuel, so set the current fuel level in QQ14 to 70, or
     36C4 030D     
11637                                                                          ; 7.0 light years
11638               
11639 36C6 0460  24        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     36C8 8650     
11640                                                                          ; screen) and return from the subroutine with a tail
11641                                                                          ; call
11642               
11643               * ******************************************************************************
11644               *
11645               * Save ELTB.bin
11646               *
11647               * ******************************************************************************
11648               
11649                      ; PRINT "ELITE B"
11650                      ; PRINT "Assembled at ", ~CODE_B%
11651                      ; PRINT "Ends at ", ~P%
11652                      ; PRINT "Code size is ", ~(P% - CODE_B%)
11653                      ; PRINT "Execute at ", ~LOAD%
11654                      ; PRINT "Reload at ", ~LOAD_B%
11655               
11656                      ; PRINT "S.ELTB ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_B%
11657                      ; SAVE "3-assembled-output/ELTB.bin", CODE_B%, P%, LOAD%
11658               
11659               * ******************************************************************************
11660               *
11661               * ELITE C FILE
11662               *
11663               * Produces the binary file ELTC.bin that gets loaded by elite-bcfs.asm.
11664               *
11665               * ******************************************************************************
11666               
11667               CODE_C.:
11668                      equ $
11669               
11670               LOAD_C.:
11671                      equ LOAD. + $ - CODE.
11672               
11673               * ******************************************************************************
11674               *
11675               * Name: TACTICS (Part 1 of 7)
11676               * Type: Subroutine
11677               * Category: Tactics
11678               * Summary: Apply tactics: Process missiles, both enemy missiles and our own
11679               * Deep dive: Program flow of the tactics routine
11680               *
11681               * ------------------------------------------------------------------------------
11682               *
11683               * This section implements missile tactics and is entered at TA18 from the main
11684               * entry point below, if the current ship is a missile. Specifically:
11685               *
11686               * * If E.C.M. is active, destroy the missile
11687               *
11688               * * If the missile is hostile towards us, then check how close it is. If it
11689               * hasn't reached us, jump to part 3 so it can streak towards us, otherwise
11690               * we've been hit, so process a large amount of damage to our ship
11691               *
11692               * * Otherwise see how close the missile is to its target. If it has not yet
11693               * reached its target, give the target a chance to activate its E.C.M. if it
11694               * has one, otherwise jump to TA19 with K3 set to the vector from the target
11695               * to the missile
11696               *
11697               * * If it has reached its target and the target is the space station, destroy
11698               * the missile, potentially damaging us if we are nearby
11699               *
11700               * * If it has reached its target and the target is a ship, destroy the missile
11701               * and the ship, potentially damaging us if we are nearby
11702               *
11703               * ******************************************************************************
11704               
11705               TA34:
11706                                                                          ; If we get here, the missile is hostile
11707 36CA 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A to x_hi OR y_hi OR z_hi
     36CC 0000     
11708 36CE 0206  20        li   rtmp,MAS4                  ; JSR MAS4
     36D0 8462     
11709 36D2 06A0  28        bl   @jsr                       ;
     36D4 8002     
11710               
11711 36D6 1300  14        jeq  B33                        ; BEQ B33           ; If A = 0 then the missile is very close to our ship,
11712                                                                          ; so skip the following instruction
11713               
11714               B33:
11715 36D8 0460  28        b    @TA21                      ; JMP TA21          ; Jump down to part 3 to set up the vectors and skip
     36DA 38AE     
11716                                                                          ; straight to aggressive manoeuvring
11717               
11718 36DC 0206  20        li   rtmp,TA87+3                ; JSR TA87+3        ; The missile has hit our ship, so call TA87+3 to set
     36DE 37B3     
11719 36E0 06A0  28        bl   @jsr                       ;
     36E2 8002     
11720                                                                          ; bit 7 of the missile's byte #31, which marks the
11721                                                                          ; missile as being killed
11722               
11723 36E4 0206  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of the missile exploding
     36E6 8B22     
11724 36E8 06A0  28        bl   @jsr                       ;
     36EA 8002     
11725               
11726 36EC 0200  20        li   ra,>fa*256                 ; LDA #250          ; Call OOPS to damage the ship by 250, which is a pretty
     36EE FA00     
11727 36F0 0460  28        b    @OOPS                      ; JMP OOPS          ; big hit, and return from the subroutine using a tail
     36F2 6E6A     
11728                                                                          ; call
11729               
11730               TA18:
11731                                                                          ; This is the entry point for missile tactics and is
11732                                                                          ; called from the main TACTICS routine below
11733 36F4 D020  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     36F6 0030     
11734 36F8 164E  14        jne  TA35                       ; BNE TA35          ; opponent's), jump to TA35 to destroy this missile
11735               
11736 36FA D020  30        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the AI flag from byte #32 and if bit 6 is set
     36FC 0073     
11737                      .asla                           ; ASL A             ; (i.e. missile is hostile), jump up to TA34 to check
     **** ****     > ASLA
0001 36FE 0240  22        andi ra,>ff00
     3700 FF00     
0002 3702 0A10  18        sla  ra,1
                   < elite.a99
11738 3704 11E2  14        jlt  TA34                       ; BMI TA34          ; whether the missile has hit us
11739               
11740 3706 0910  18        srl  ra,1                       ; LSR A             ; Otherwise shift A right again. We know bits 6 and 7
11741                                                                          ; are now clear, so this leaves bits 0-5. Bits 1-5
11742                                                                          ; contain the target's slot number, and bit 0 is cleared
11743                                                                          ; in FRMIS when a missile is launched, so A contains
11744                                                                          ; the slot number shifted left by 1 (i.e. doubled) so we
11745                                                                          ; can use it as an index for the two-byte address table
11746                                                                          ; at UNIV
11747               
11748 3708 D040  18        movb ra,rx                      ; TAX               ; Copy the address of the target ship's data block from
11749 370A D021  34        movb @UNIV(rx),ra               ; LDA UNIV,X        ; UNIV(X+1 X) to V(1 0)
     370C 221F     
11750 370E D800  30        movb ra,@V                      ; STA V
     3710 0022     
11751 3712 D021  34        movb @UNIV+1(rx),ra             ; LDA UNIV+1,X
     3714 2220     
11752 3716 D800  30        movb ra,@V+1                    ; STA V+1
     3718 0023     
11753               
11754 371A 0202  20        li   ry,>02*256                 ; LDY #2            ; K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of
     371C 0200     
11755 371E 0206  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     3720 3AD2     
11756 3722 06A0  28        bl   @jsr                       ;
     3724 8002     
11757               
11758 3726 0202  20        li   ry,>05*256                 ; LDY #5            ; K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of
     3728 0500     
11759 372A 0206  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     372C 3AD2     
11760 372E 06A0  28        bl   @jsr                       ;
     3730 8002     
11761               
11762 3732 0202  20        li   ry,>08*256                 ; LDY #8            ; K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of
     3734 0800     
11763 3736 0206  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     3738 3AD2     
11764 373A 06A0  28        bl   @jsr                       ;
     373C 8002     
11765               
11766                                                                          ; So K3 now contains the vector from the target ship to
11767                                                                          ; the missile
11768               
11769 373E D020  30        movb @K3+2,ra                   ; LDA K3+2          ; Set A = OR of all the sign and high bytes of the
     3740 00D4     
11770 3742 F020  30        socb @K3+5,ra                   ; ORA K3+5          ; above, clearing bit 7 (i.e. ignore the signs)
     3744 00D7     
11771 3746 F020  30        socb @K3+8,ra                   ; ORA K3+8
     3748 00DA     
11772 374A 0240  22        andi ra,>7f*256                 ; AND #%01111111
     374C 7F00     
11773 374E F020  30        socb @K3+1,ra                   ; ORA K3+1
     3750 00D3     
11774 3752 F020  30        socb @K3+4,ra                   ; ORA K3+4
     3754 00D6     
11775 3756 F020  30        socb @K3+7,ra                   ; ORA K3+7
     3758 00D9     
11776               
11777 375A 163C  14        jne  TA64                       ; BNE TA64          ; If the result is non-zero, then the missile is some
11778                                                                          ; distance from the target, so jump down to TA64 see if
11779                                                                          ; the target activates its E.C.M.
11780               
11781 375C D020  30        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the AI flag from byte #32 and if only bits 7 and
     375E 0073     
11782 3760 0280  22        ci   ra,>82*256                 ; CMP #%10000010    ; 1 are set (AI is enabled and the target is slot 1, the
     3762 8200     
11783 3764 1318  14        jeq  TA35                       ; BEQ TA35          ; space station), jump to TA35 to destroy this missile,
11784                                                                          ; as the space station ain't kidding around
11785               
11786 3766 0202  20        li   ry,>1f*256                 ; LDY #31           ; Fetch byte #31 (the exploding flag) of the target ship
     3768 1F00     
11787                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; into A
     **** ****     > LD_IND_Y_IDX
0001 376A D820  42        movb @V,@rtmplb
     376C 0022     
     376E 830D     
0002 3770 D1A0  30        movb @V+1,rtmp
     3772 0023     
0003 3774 A182  18        a    ry,rtmp
0004 3776 D016  26        movb *rtmp,RA
                   < elite.a99
11788               
11789                      .bit @M32+1                     ; BIT M32+1         ; M32 contains an LDY #32 instruction, so M32+1 contains
     **** ****     > BIT
0001 3778 D1A0  34        movb @M32+1,rtmp
     377A 37E3     
0002 377C 0546  14        inv  rtmp
0003 377E D1C4  18        movb rone,rtmp2
0004 3780 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
11790                                                                          ; 32, so this instruction tests A with %00100000, which
11791                                                                          ; checks bit 5 of A (the "already exploding?" bit)
11792               
11793 3782 1609  14        jne  TA35                       ; BNE TA35          ; If the target ship is already exploding, jump to TA35
11794                                                                          ; to destroy this missile
11795               
11796 3784 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Otherwise set bit 7 of the target's byte #31 to mark
     3786 8000     
11797                      .st_ind_y_idx @V,ra             ; STA (V),Y         ; the ship as having been killed, so it explodes
     **** ****     > ST_IND_Y_IDX
0001 3788 D820  42        movb @V,@rtmplb
     378A 0022     
     378C 830D     
0002 378E D1A0  30        movb @V+1,rtmp
     3790 0023     
0003 3792 A182  18        a    ry,rtmp
0004 3794 D580  30        movb RA,*rtmp
                   < elite.a99
11798               
11799               TA35:
11800 3796 D020  30        movb @INWK,ra                   ; LDA INWK          ; Set A = x_lo OR y_lo OR z_lo of the missile
     3798 0053     
11801 379A F020  30        socb @INWK+3,ra                 ; ORA INWK+3
     379C 0056     
11802 379E F020  30        socb @INWK+6,ra                 ; ORA INWK+6
     37A0 0059     
11803               
11804 37A2 1606  14        jne  TA87                       ; BNE TA87          ; If A is non-zero then the missile is not near our
11805                                                                          ; ship, so jump to TA87 to skip damaging our ship
11806               
11807 37A4 0200  20        li   ra,>50*256                 ; LDA #80           ; Otherwise the missile just got destroyed near us, so
     37A6 5000     
11808 37A8 0206  20        li   rtmp,OOPS                  ; JSR OOPS          ; call OOPS to damage the ship by 80, which is nowhere
     37AA 6E6A     
11809 37AC 06A0  28        bl   @jsr                       ;
     37AE 8002     
11810                                                                          ; near as bad as the 250 damage from a missile slamming
11811                                                                          ; straight into us, but it's still pretty nasty
11812               
11813               TA87:
11814 37B0 0206  20        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     37B2 8B54     
11815 37B4 06A0  28        bl   @jsr                       ;
     37B6 8002     
11816                                                                          ; missile (so increase the kill tally, make an explosion
11817                                                                          ; sound and so on)
11818               
11819                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the missile's byte #31 flag to mark it as
     **** ****     > ASL
0001 37B8 D1A0  30        movb @INWK+31,rtmp
     37BA 0072     
0002 37BC 0246  22        andi rtmp,>ff00
     37BE FF00     
0003 37C0 0A16  18        sla  rtmp,1
0004 37C2 D806  30        movb rtmp,@INWK+31
     37C4 0072     
                   < elite.a99
11820                      .sec                            ; SEC               ; having been killed, so it explodes
     **** ****     > SEC
0001 37C6 0A15  18        sla  rmone,1
                   < elite.a99
11821 37C8 0208  20        li   rarg1,INWK+31              ; ROR INWK+31
     37CA 0072     
11822 37CC 06A0  28        bl   @ror                       ;
     37CE 8054     
11823               
11824               TA1:
11825 37D0 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     37D2 800E     
11826               
11827               TA64:
11828                                                                          ; If we get here then the missile has not reached the
11829                                                                          ; target
11830 37D4 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     37D6 8070     
11831 37D8 06A0  28        bl   @jsr                       ;
     37DA 8002     
11832               
11833 37DC 0280  22        ci   ra,>10*256                 ; CMP #16           ; If A >= 16 (94% chance), jump down to TA19 with the
     37DE 1000     
11834 37E0 186E  14        joc  TA19                       ; BCS TA19          ; vector from the target to the missile in K3
11835               
11836               M32:
11837 37E2 0202  20        li   ry,>20*256                 ; LDY #32           ; Fetch byte #32 for the target and shift bit 0 (E.C.M.)
     37E4 2000     
11838                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; into the C flag
     **** ****     > LD_IND_Y_IDX
0001 37E6 D820  42        movb @V,@rtmplb
     37E8 0022     
     37EA 830D     
0002 37EC D1A0  30        movb @V+1,rtmp
     37EE 0023     
0003 37F0 A182  18        a    ry,rtmp
0004 37F2 D016  26        movb *rtmp,RA
                   < elite.a99
11839 37F4 0910  18        srl  ra,1                       ; LSR A
11840               
11841 37F6 1763  14        jnc  TA19                       ; BCC TA19          ; If the C flag is clear then the target does not have
11842                                                                          ; E.C.M. fitted, so jump down to TA19 with the vector
11843                                                                          ; from the target to the missile in K3
11844               
11845 37F8 0460  28        b    @ECBLB2                    ; JMP ECBLB2        ; The target has E.C.M., so jump to ECBLB2 to set it
     37FA 70B2     
11846                                                                          ; off, returning from the subroutine using a tail call
11847               
11848               * ******************************************************************************
11849               *
11850               * Name: TACTICS (Part 2 of 7)
11851               * Type: Subroutine
11852               * Category: Tactics
11853               * Summary: Apply tactics: Escape pod, station, lone Thargon, safe-zone pirate
11854               * Deep dive: Program flow of the tactics routine
11855               *
11856               * ------------------------------------------------------------------------------
11857               *
11858               * This section contains the main entry point at TACTICS, which is called from
11859               * part 2 of MVEIT for ships that have the AI flag set (i.e. bit 7 of byte #32).
11860               * This part does the following:
11861               *
11862               * * If this is a missile, jump up to the missile code in part 1
11863               *
11864               * * If this is an escape pod, point it at the planet and jump to the
11865               * manoeuvring code in part 7
11866               *
11867               * * If this is the space station and it is hostile, consider spawning a cop
11868               * (45% chance, up to a maximum of four) and we're done
11869               *
11870               * * If this is a lone Thargon without a mothership, set it adrift aimlessly
11871               * and we're done
11872               *
11873               * * If this is a pirate and we are within the space station safe zone, stop
11874               * the pirate from attacking by removing all its aggression
11875               *
11876               * * Recharge the ship's energy banks by 1
11877               *
11878               * ------------------------------------------------------------------------------
11879               *
11880               * Arguments:
11881               *
11882               * X                   The ship type
11883               *
11884               * ******************************************************************************
11885               
11886               TACTICS:
11887 37FC 0281  22        ci   rx,(MSL)*256               ; CPX #MSL          ; If this is a missile, jump up to TA18 to implement
     37FE 0900     
11888 3800 1602  14        jne  FIX001                     ; BNE FIX001        ; missile tactics
11889 3802 0460  28        b    @TA18                      ; JMP TA18
     3804 36F4     
11890               FIX001:
11891 3806 0281  22        ci   rx,(ESC)*256               ; CPX #ESC          ; If this is not an escape pod, skip the following two
     3808 0D00     
11892 380A 1606  14        jne  B34                        ; BNE B34           ; instructions
11893               
11894 380C 0206  20        li   rtmp,SPS1                  ; JSR SPS1          ; This is an escape pod, so call SPS1 to calculate the
     380E 896E     
11895 3810 06A0  28        bl   @jsr                       ;
     3812 8002     
11896                                                                          ; vector to the planet and store it in XX15
11897               
11898 3814 0460  28        b    @TA15                      ; JMP TA15          ; Jump down to TA15
     3816 3A48     
11899               
11900               B34:
11901 3818 0281  22        ci   rx,(SST)*256               ; CPX #SST          ; If this is not the space station, jump down to TA13
     381A 0800     
11902 381C 1612  14        jne  TA13                       ; BNE TA13
11903               
11904                                                                          ; We only call the tactics routine for the space station
11905                                                                          ; when it is hostile, so if we get here then this is the
11906                                                                          ; station, and we already know it's hostile, so we need
11907                                                                          ; to spawn some cops
11908               
11909 381E 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3820 8070     
11910 3822 06A0  28        bl   @jsr                       ;
     3824 8002     
11911               
11912 3826 0280  22        ci   ra,>8c*256                 ; CMP #140          ; If A < 140 (55% chance) then return from the
     3828 8C00     
11913 382A 1723  14        jnc  TA14-1                     ; BCC TA14-1        ; subroutine (as TA14-1 contains an RTS)
11914               
11915 382C D020  30        movb @MANY+COPS,ra              ; LDA MANY+COPS     ; We only call the tactics routine for the space station
     382E 0D4F     
11916 3830 0280  22        ci   ra,>04*256                 ; CMP #4            ; when it is hostile, so first check the number of cops
     3832 0400     
11917 3834 181E  14        joc  TA14-1                     ; BCS TA14-1        ; in the vicinity, and if we already have 4 or more, we
11918                                                                          ; don't need to spawn any more, so return from the
11919                                                                          ; subroutine (as TA14-1 contains an RTS)
11920               
11921 3836 0201  20        li   rx,(COPS)*256              ; LDX #COPS         ; Set X to the ship type for a cop
     3838 0200     
11922               
11923 383A 0200  20        li   ra,>f1*256                 ; LDA #%11110001    ; Set the AI flag to give the ship E.C.M., enable AI and
     383C F100     
11924                                                                          ; make it very aggressive (60 out of 63)
11925               
11926 383E 0460  28        b    @SFS1                      ; JMP SFS1          ; Jump to SFS1 to spawn the ship, returning from the
     3840 3D02     
11927                                                                          ; subroutine using a tail call
11928               
11929               TA13:
11930 3842 0281  22        ci   rx,(TGL)*256               ; CPX #TGL          ; If this is not a Thargon, jump down to TA14
     3844 0C00     
11931 3846 1616  14        jne  TA14                       ; BNE TA14
11932               
11933 3848 D020  30        movb @MANY+THG,ra               ; LDA MANY+THG      ; If there is at least one Thargoid in the vicinity,
     384A 0D53     
11934 384C 1613  14        jne  TA14                       ; BNE TA14          ; jump down to TA14
11935               
11936                      .lsr @INWK+32                   ; LSR INWK+32       ; This is a Thargon but there is no Thargoid mothership,
     **** ****     > LSR
0001 384E D1A0  30        movb @INWK+32,rtmp
     3850 0073     
0002 3852 0916  18        srl  rtmp,1
0003 3854 D806  30        movb rtmp,@INWK+32
     3856 0073     
                   < elite.a99
11937                      .asl @INWK+32                   ; ASL INWK+32       ; so clear bit 0 of the AI flag to disable its E.C.M.
     **** ****     > ASL
0001 3858 D1A0  30        movb @INWK+32,rtmp
     385A 0073     
0002 385C 0246  22        andi rtmp,>ff00
     385E FF00     
0003 3860 0A16  18        sla  rtmp,1
0004 3862 D806  30        movb rtmp,@INWK+32
     3864 0073     
                   < elite.a99
11938               
11939                      .lsr @INWK+27                   ; LSR INWK+27       ; And halve the Thargon's speed
     **** ****     > LSR
0001 3866 D1A0  30        movb @INWK+27,rtmp
     3868 006E     
0002 386A 0916  18        srl  rtmp,1
0003 386C D806  30        movb rtmp,@INWK+27
     386E 006E     
                   < elite.a99
11940               
11941 3870 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3872 800E     
11942               
11943               TA14:
11944 3874 0281  22        ci   rx,(CYL)*256               ; CPX #CYL          ; If A >= #CYL, i.e. this is a Cobra Mk III trader (as
     3876 0700     
11945 3878 180C  14        joc  TA62                       ; BCS TA62          ; asteroids and cargo canisters never have AI), jump
11946                                                                          ; down to TA62
11947               
11948 387A 0281  22        ci   rx,(COPS)*256              ; CPX #COPS         ; If this is a cop, jump down to TA62
     387C 0200     
11949 387E 1309  14        jeq  TA62                       ; BEQ TA62
11950               
11951 3880 D020  30        movb @SSPR,ra                   ; LDA SSPR          ; If we aren't within range of the space station, jump
     3882 0D55     
11952 3884 1306  14        jeq  TA62                       ; BEQ TA62          ; down to TA62
11953               
11954 3886 D020  30        movb @INWK+32,ra                ; LDA INWK+32       ; This is a pirate or bounty hunter, but we are inside
     3888 0073     
11955 388A 0240  22        andi ra,>81*256                 ; AND #%10000001    ; the space station's safe zone, so clear bits 1-6 of
     388C 8100     
11956 388E D800  30        movb ra,@INWK+32                ; STA INWK+32       ; the AI flag to stop it being hostile, because even
     3890 0073     
11957                                                                          ; pirates aren't crazy enough to breach the station's
11958                                                                          ; no-fire zone
11959               
11960               TA62:
11961 3892 0202  20        li   ry,>0e*256                 ; LDY #14           ; If the ship's energy is greater or equal to the
     3894 0E00     
11962 3896 D020  30        movb @INWK+35,ra                ; LDA INWK+35       ; maximum value from the ship's blueprint pointed to by
     3898 0076     
11963                      .cmp_ind_y_idx @XX0,ra          ; CMP (XX0),Y       ; XX0, then skip the next instruction
     **** ****     > CMP_IND_Y_IDX
0001 389A D820  42        movb @XX0,@rtmplb
     389C 001E     
     389E 830D     
0002 38A0 D1A0  30        movb @XX0+1,rtmp
     38A2 001F     
0003 38A4 A182  18        a    ry,rtmp
0004 38A6 D196  26        movb *rtmp,rtmp
0005 38A8 9180  18        cb   ra,rtmp
                   < elite.a99
11964 38AA 1801  14        joc  TA21                       ; BCS TA21
11965               
11966 38AC B004  18        ab   rone,ra                    ; INC INWK+35       ; The ship's energy is not at maximum, so recharge the
11967                                                                          ; energy banks by 1
11968               
11969               * ******************************************************************************
11970               *
11971               * Name: TACTICS (Part 3 of 7)
11972               * Type: Subroutine
11973               * Category: Tactics
11974               * Summary: Apply tactics: Calculate dot product to determine ship's aim
11975               * Deep dive: Program flow of the tactics routine
11976               *
11977               * ------------------------------------------------------------------------------
11978               *
11979               * This section sets up some vectors and calculates dot products. Specifically:
11980               *
11981               * * Calculate the dot product of the ship's nose vector (i.e. the direction it
11982               * is pointing) with the vector between us and the ship. This value will help
11983               * us work out later on whether the enemy ship is pointing towards us, and
11984               * therefore whether it can hit us with its lasers.
11985               *
11986               * ******************************************************************************
11987               
11988               TA21:
11989 38AE 0201  20        li   rx,>08*256                 ; LDX #8            ; We now want to copy the ship's x, y and z coordinates
     38B0 0800     
11990                                                                          ; from INWK to K3, so set up a counter for 9 bytes
11991               
11992               TAL1:
11993 38B2 D021  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Copy the X-th byte from INWK to the X-th byte of K3
     38B4 0053     
11994 38B6 D840  38        movb ra,@K3(rx)                 ; STA K3,X
     38B8 00D2     
11995               
11996 38BA 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
11997               
11998 38BC 15FA  14        jgt  TAL1                       ; BPL TAL1          ; Loop back until we have copied all 9 bytes
11999               
12000               TA19:
12001                                                                          ; If this is a missile that's heading for its target
12002                                                                          ; (not us, one of the other ships), then the missile
12003                                                                          ; routine at TA18 above jumps here after setting K3 to
12004                                                                          ; the vector from the target to the missile
12005 38BE 0206  20        li   rtmp,TAS2                  ; JSR TAS2          ; Normalise the vector in K3 and store the normalised
     38C0 8992     
12006 38C2 06A0  28        bl   @jsr                       ;
     38C4 8002     
12007                                                                          ; version in XX15, so XX15 contains the normalised
12008                                                                          ; vector from our ship to the ship we are applying AI
12009                                                                          ; tactics to (or the normalised vector from the target
12010                                                                          ; to the missile - in both cases it's the vector from
12011                                                                          ; the potential victim to the attacker)
12012               
12013 38C6 0202  20        li   ry,>0a*256                 ; LDY #10           ; Set (A X) = nosev . XX15
     38C8 0A00     
12014 38CA 0206  20        li   rtmp,TAS3                  ; JSR TAS3
     38CC 4476     
12015 38CE 06A0  28        bl   @jsr                       ;
     38D0 8002     
12016               
12017 38D2 D800  30        movb ra,@CNT                    ; STA CNT           ; Store the high byte of the dot product in CNT. The
     38D4 00A4     
12018                                                                          ; bigger the value, the more aligned the two ships are,
12019                                                                          ; with a maximum magnitude of 36 (96 * 96 >> 8). If CNT
12020                                                                          ; is positive, the ships are facing in a similar
12021                                                                          ; direction, if it's negative they are facing in
12022                                                                          ; opposite directions
12023               
12024               * ******************************************************************************
12025               *
12026               * Name: TACTICS (Part 4 of 7)
12027               * Type: Subroutine
12028               * Category: Tactics
12029               * Summary: Apply tactics: Check energy levels, maybe launch escape pod if low
12030               * Deep dive: Program flow of the tactics routine
12031               *
12032               * ------------------------------------------------------------------------------
12033               *
12034               * This section works out what kind of condition the ship is in. Specifically:
12035               *
12036               * * Rarely (2.5% chance) roll the ship by a noticeable amount
12037               *
12038               * * If the ship has at least half its energy banks full, jump to part 6 to
12039               * consider firing the lasers
12040               *
12041               * * If the ship is not into the last 1/8th of its energy, jump to part 5 to
12042               * consider firing a missile
12043               *
12044               * * If the ship is into the last 1/8th of its energy, then rarely (10% chance)
12045               * the ship launches an escape pod and is left drifting in space
12046               *
12047               * ******************************************************************************
12048               
12049 38D6 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; If this is not a missile, skip the following
     38D8 009B     
12050 38DA 0280  22        ci   ra,(MSL)*256               ; CMP #MSL          ; instruction
     38DC 0900     
12051 38DE 1602  14        jne  B35                        ; BNE B35
12052               
12053 38E0 0460  28        b    @TA20                      ; JMP TA20          ; This is a missile, so jump down to TA20 to get
     38E2 3A10     
12054                                                                          ; straight into some aggressive manoeuvring
12055               
12056               B35:
12057 38E4 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     38E6 8070     
12058 38E8 06A0  28        bl   @jsr                       ;
     38EA 8002     
12059               
12060 38EC 0280  22        ci   ra,>fa*256                 ; CMP #250          ; If A < 250 (97.5% chance), jump down to TA7 to skip
     38EE FA00     
12061 38F0 1708  14        jnc  TA7                        ; BCC TA7           ; the following
12062               
12063 38F2 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     38F4 8070     
12064 38F6 06A0  28        bl   @jsr                       ;
     38F8 8002     
12065               
12066 38FA 0260  22        ori  ra,>68*256                 ; ORA #104          ; Bump A up to at least 104 and store in the roll
     38FC 6800     
12067 38FE D800  30        movb ra,@INWK+29                ; STA INWK+29       ; counter, to gives the ship a noticeable roll
     3900 0070     
12068               
12069               TA7:
12070 3902 0202  20        li   ry,>0e*256                 ; LDY #14           ; Set A = the ship's maximum energy / 2
     3904 0E00     
12071                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y
     **** ****     > LD_IND_Y_IDX
0001 3906 D820  42        movb @XX0,@rtmplb
     3908 001E     
     390A 830D     
0002 390C D1A0  30        movb @XX0+1,rtmp
     390E 001F     
0003 3910 A182  18        a    ry,rtmp
0004 3912 D016  26        movb *rtmp,RA
                   < elite.a99
12072 3914 0910  18        srl  ra,1                       ; LSR A
12073               
12074 3916 9020  30        cb   @INWK+35,ra                ; CMP INWK+35       ; If the ship's current energy in byte #35 > A, i.e. the
     3918 0076     
12075 391A 1738  14        jnc  TA3                        ; BCC TA3           ; ship has at least half of its energy banks charged,
12076                                                                          ; jump down to TA3
12077               
12078 391C 0910  18        srl  ra,1                       ; LSR A             ; If the ship's current energy in byte #35 > A / 4, i.e.
12079 391E 0910  18        srl  ra,1                       ; LSR A             ; the ship is not into the last 1/8th of its energy,
12080 3920 9020  30        cb   @INWK+35,ra                ; CMP INWK+35       ; jump down to ta3 to consider firing a missile
     3922 0076     
12081 3924 1712  14        jnc  ta3_                       ; BCC ta3
12082               
12083 3926 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3928 8070     
12084 392A 06A0  28        bl   @jsr                       ;
     392C 8002     
12085               
12086 392E 0280  22        ci   ra,>e6*256                 ; CMP #230          ; If A < 230 (90% chance), jump down to ta3 to consider
     3930 E600     
12087 3932 170B  14        jnc  ta3_                       ; BCC ta3           ; firing a missile
12088               
12089 3934 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; If this is a Thargoid, jump down to ta3 to consider
     3936 009B     
12090 3938 0280  22        ci   ra,(THG)*256               ; CMP #THG          ; launching a Thargon
     393A 0600     
12091 393C 1306  14        jeq  ta3_                       ; BEQ ta3
12092               
12093                                                                          ; By this point, the ship has run out of both energy and
12094                                                                          ; luck, so it's time to bail
12095               
12096 393E 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the AI flag to 0 to disable AI, hostility and
     3940 0000     
12097 3942 D800  30        movb ra,@INWK+32                ; STA INWK+32       ; E.C.M., so the ship's a sitting duck
     3944 0073     
12098               
12099 3946 0460  28        b    @SESCP                     ; JMP SESCP         ; Jump to SESCP to spawn an escape pod from the ship,
     3948 3CFA     
12100                                                                          ; returning from the subroutine using a tail call
12101               
12102               * ******************************************************************************
12103               *
12104               * Name: TACTICS (Part 5 of 7)
12105               * Type: Subroutine
12106               * Category: Tactics
12107               * Summary: Apply tactics: Consider whether to launch a missile at us
12108               * Deep dive: Program flow of the tactics routine
12109               *
12110               * ------------------------------------------------------------------------------
12111               *
12112               * This section considers whether to launch a missile. Specifically:
12113               *
12114               * * If the ship doesn't have any missiles, skip to the next part
12115               *
12116               * * If an E.C.M. is firing, skip to the next part
12117               *
12118               * * Randomly decide whether to fire a missile (or, in the case of Thargoids,
12119               * release a Thargon), and if we do, we're done
12120               *
12121               * ******************************************************************************
12122               
12123               ta3_:
12124                                                                          ; If we get here then the ship has less than half energy
12125                                                                          ; so there may not be enough juice for lasers, but let's
12126                                                                          ; see if we can fire a missile
12127 394A D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set A = bits 0-2 of byte #31, the number of missiles
     394C 0072     
12128 394E 0240  22        andi ra,>07*256                 ; AND #%00000111    ; the ship has left
     3950 0700     
12129               
12130 3952 131C  14        jeq  TA3                        ; BEQ TA3           ; If it doesn't have any missiles, jump to TA3
12131               
12132 3954 D800  30        movb ra,@T                      ; STA T             ; Store the number of missiles in T
     3956 00D1     
12133               
12134 3958 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     395A 8070     
12135 395C 06A0  28        bl   @jsr                       ;
     395E 8002     
12136               
12137 3960 0240  22        andi ra,>1f*256                 ; AND #31           ; Restrict A to a random number in the range 0-31
     3962 1F00     
12138               
12139 3964 9020  30        cb   @T,ra                      ; CMP T             ; If A >= T, which is quite likely, though less likely
     3966 00D1     
12140 3968 1811  14        joc  TA3                        ; BCS TA3           ; with higher numbers of missiles, jump to TA3 to skip
12141                                                                          ; firing a missile
12142               
12143 396A D020  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     396C 0030     
12144 396E 160E  14        jne  TA3                        ; BNE TA3           ; opponent's), jump to TA3 to skip firing a missile
12145               
12146 3970 7004  18        sb   rone,ra                    ; DEC INWK+31       ; We're done with the checks, so it's time to fire off a
12147                                                                          ; missile, so reduce the missile count in byte #31 by 1
12148               
12149 3972 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship type into A
     3974 009B     
12150               
12151 3976 0280  22        ci   ra,(THG)*256               ; CMP #THG          ; If this is not a Thargoid, jump down to TA16 to launch
     3978 0600     
12152 397A 1606  14        jne  TA16                       ; BNE TA16          ; a missile
12153               
12154 397C 0201  20        li   rx,(TGL)*256               ; LDX #TGL          ; This is a Thargoid, so instead of launching a missile,
     397E 0C00     
12155 3980 D020  30        movb @INWK+32,ra                ; LDA INWK+32       ; the mothership launches a Thargon, so call SFS1 to
     3982 0073     
12156 3984 0460  28        b    @SFS1                      ; JMP SFS1          ; spawn a Thargon from the parent ship, and return from
     3986 3D02     
12157                                                                          ; the subroutine using a tail call
12158               
12159               TA16:
12160 3988 0460  24        b    @SFRMIS                    ; JMP SFRMIS        ; Jump to SFRMIS to spawn a missile as a child of the
     398A 8B34     
12161                                                                          ; current ship, make a noise and print a message warning
12162                                                                          ; of incoming missiles, and return from the subroutine
12163                                                                          ; using a tail call
12164               
12165               * ******************************************************************************
12166               *
12167               * Name: TACTICS (Part 6 of 7)
12168               * Type: Subroutine
12169               * Category: Tactics
12170               * Summary: Apply tactics: Consider firing a laser at us, if aim is true
12171               * Deep dive: Program flow of the tactics routine
12172               *
12173               * ------------------------------------------------------------------------------
12174               *
12175               * This section looks at potentially firing the ship's laser at us. Specifically:
12176               *
12177               * * If the ship is not pointing at us, skip to the next part
12178               *
12179               * * If the ship is pointing at us but not accurately, fire its laser at us and
12180               * skip to the next part
12181               *
12182               * * If we are in the ship's crosshairs, register some damage to our ship, slow
12183               * down the attacking ship, make the noise of us being hit by laser fire, and
12184               * we're done
12185               *
12186               * ******************************************************************************
12187               
12188               TA3:
12189                                                                          ; If we get here then the ship either has plenty of
12190                                                                          ; energy, or levels are low but it couldn't manage to
12191                                                                          ; launch a missile, so maybe we can fire the laser?
12192 398C 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A to x_hi OR y_hi OR z_hi
     398E 0000     
12193 3990 0206  20        li   rtmp,MAS4                  ; JSR MAS4
     3992 8462     
12194 3994 06A0  28        bl   @jsr                       ;
     3996 8002     
12195               
12196 3998 0240  22        andi ra,>e0*256                 ; AND #%11100000    ; If any of the hi bytes have any of bits 5-7 set, then
     399A E000     
12197 399C 1624  14        jne  TA4                        ; BNE TA4           ; jump to TA4 to skip the laser checks, as the ship is
12198                                                                          ; too far away from us to hit us with a laser
12199               
12200 399E D060  30        movb @CNT,rx                    ; LDX CNT           ; Set X = the dot product set above in CNT. If this is
     39A0 00A4     
12201                                                                          ; positive, this ship and our ship are facing in similar
12202                                                                          ; directions, but if it's negative then we are facing
12203                                                                          ; each other, so for us to be in the enemy ship's line
12204                                                                          ; of fire, X needs to be negative. The value in X can
12205                                                                          ; have a maximum magnitude of 36, which would mean we
12206                                                                          ; were facing each other square on, so in the following
12207                                                                          ; code we check X like this:
12208                                                                          ;
12209                                                                          ; X = 0 to -31, we are not in the enemy ship's line
12210                                                                          ; of fire, so they can't shoot at us
12211                                                                          ;
12212                                                                          ; X = -32 to -34, we are in the enemy ship's line
12213                                                                          ; of fire, so they can shoot at us, but they can't
12214                                                                          ; hit us as we're not dead in their crosshairs
12215                                                                          ;
12216                                                                          ; X = -35 to -36, we are bang in the middle of the
12217                                                                          ; enemy ship's crosshairs, so they can not only
12218                                                                          ; shoot us, they can hit us
12219               
12220 39A2 0281  22        ci   rx,>a0*256                 ; CPX #160          ; If X < 160, i.e. X > -32, then we are not in the enemy
     39A4 A000     
12221 39A6 171F  14        jnc  TA4                        ; BCC TA4           ; ship's line of fire, so jump to TA4 to skip the laser
12222                                                                          ; checks
12223               
12224 39A8 D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 6 in byte #31 to denote that the ship is
     39AA 0072     
12225 39AC 0260  22        ori  ra,>40*256                 ; ORA #%01000000    ; firing its laser at us
     39AE 4000     
12226 39B0 D800  30        movb ra,@INWK+31                ; STA INWK+31
     39B2 0072     
12227               
12228 39B4 0281  22        ci   rx,>a3*256                 ; CPX #163          ; If X < 163, i.e. X > -35, then we are not in the enemy
     39B6 A300     
12229 39B8 1716  14        jnc  TA4                        ; BCC TA4           ; ship's crosshairs, so jump to TA4 to skip the laser
12230                                                                          ; checks
12231               
12232               HIT:
12233 39BA 0202  20        li   ry,>13*256                 ; LDY #19           ; We are being hit by enemy laser fire, so fetch the
     39BC 1300     
12234                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; enemy ship's byte #19 from their ship's blueprint
     **** ****     > LD_IND_Y_IDX
0001 39BE D820  42        movb @XX0,@rtmplb
     39C0 001E     
     39C2 830D     
0002 39C4 D1A0  30        movb @XX0+1,rtmp
     39C6 001F     
0003 39C8 A182  18        a    ry,rtmp
0004 39CA D016  26        movb *rtmp,RA
                   < elite.a99
12235                                                                          ; into A
12236               
12237 39CC 0910  18        srl  ra,1                       ; LSR A             ; Halve the enemy ship's byte #19 (which contains both
12238                                                                          ; the laser power and number of missiles) to get the
12239                                                                          ; amount of damage we should take
12240               
12241 39CE 0206  20        li   rtmp,OOPS                  ; JSR OOPS          ; Call OOPS to take some damage, which could do anything
     39D0 6E6A     
12242 39D2 06A0  28        bl   @jsr                       ;
     39D4 8002     
12243                                                                          ; from reducing the shields and energy, all the way to
12244                                                                          ; losing cargo or dying (if the latter, we don't come
12245                                                                          ; back from this subroutine)
12246               
12247 39D6 7004  18        sb   rone,ra                    ; DEC INWK+28       ; Halve the attacking ship's acceleration in byte #28
12248               
12249 39D8 D020  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     39DA 0030     
12250 39DC 1678  14        jne  TA10                       ; BNE TA10          ; opponent's), return from the subroutine without making
12251                                                                          ; the laser-strike sound (as TA10 contains an RTS)
12252               
12253 39DE 0200  20        li   ra,>08*256                 ; LDA #8            ; Call the NOISE routine with A = 8 to make the sound
     39E0 0800     
12254 39E2 0460  24        b    @NOISE                     ; JMP NOISE         ; of us being hit by lasers, returning from the
     39E4 8BA4     
12255                                                                          ; subroutine using a tail call
12256               
12257               * ******************************************************************************
12258               *
12259               * Name: TACTICS (Part 7 of 7)
12260               * Type: Subroutine
12261               * Category: Tactics
12262               * Summary: Apply tactics: Set pitch, roll, and acceleration
12263               * Deep dive: Program flow of the tactics routine
12264               *
12265               * ------------------------------------------------------------------------------
12266               *
12267               * This section looks at manoeuvring the ship. Specifically:
12268               *
12269               * * Work out which direction the ship should be moving, depending on whether
12270               * it's an escape pod, where it is, which direction it is pointing, and how
12271               * aggressive it is
12272               *
12273               * * Set the pitch and roll counters to head in that direction
12274               *
12275               * * Speed up or slow down, depending on where the ship is in relation to us
12276               *
12277               * ******************************************************************************
12278               
12279               TA4:
12280 39E6 D020  30        movb @INWK+7,ra                 ; LDA INWK+7        ; If z_hi >= 3 then the ship is quite far away, so jump
     39E8 005A     
12281 39EA 0280  22        ci   ra,>03*256                 ; CMP #3            ; down to TA5
     39EC 0300     
12282 39EE 1807  14        joc  TA5                        ; BCS TA5
12283               
12284 39F0 D020  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Otherwise set A = x_hi OR y_hi and extract bits 1-7
     39F2 0054     
12285 39F4 F020  30        socb @INWK+4,ra                 ; ORA INWK+4
     39F6 0057     
12286 39F8 0240  22        andi ra,>fe*256                 ; AND #%11111110
     39FA FE00     
12287               
12288 39FC 1325  14        jeq  TA15                       ; BEQ TA15          ; If A = 0 then the ship is pretty close to us, so jump
12289                                                                          ; to TA15 so it heads away from us
12290               
12291               TA5:
12292                                                                          ; If we get here then the ship is quite far away
12293 39FE 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3A00 8070     
12294 3A02 06A0  28        bl   @jsr                       ;
     3A04 8002     
12295               
12296 3A06 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 of A, so A is at least 128
     3A08 8000     
12297               
12298 3A0A 9020  30        cb   @INWK+32,ra                ; CMP INWK+32       ; If A >= byte #32 (the ship's AI flag) then jump down
     3A0C 0073     
12299 3A0E 181C  14        joc  TA15                       ; BCS TA15          ; to TA15 so it heads away from us
12300               
12301                                                                          ; We get here if A < byte #32, and the chances of this
12302                                                                          ; being true are greater with high values of byte #32,
12303                                                                          ; as long as they are at least 128
12304                                                                          ;
12305                                                                          ; In other words, higher byte #32 values increase the
12306                                                                          ; chances of a ship changing direction to head towards
12307                                                                          ; us - or, to put it another way, ships with higher
12308                                                                          ; byte #32 values of 128 or more are spoiling for a
12309                                                                          ; fight
12310                                                                          ;
12311                                                                          ; Thargoids have byte #32 set to 255, which explains
12312                                                                          ; an awful lot
12313               
12314               TA20:
12315                                                                          ; If this is a missile we will have jumped straight
12316                                                                          ; here, but we also get here if the ship is either far
12317                                                                          ; away and aggressive, or not too close
12318 3A10 D020  30        movb @XX15,ra                   ; LDA XX15          ; Reverse the signs of XX15 and the dot product in CNT,
     3A12 0031     
12319                      .eoi (>80*256)                  ; EOR #%10000000    ; starting with the x-coordinate
     **** ****     > EOI
0001 3A14 0206  20        li   rtmp,(>80*256)
     3A16 8000     
0002 3A18 2806  18        xor  rtmp,ra
                   < elite.a99
12320 3A1A D800  30        movb ra,@XX15                   ; STA XX15
     3A1C 0031     
12321               
12322 3A1E D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Then reverse the sign of the y-coordinate
     3A20 0032     
12323                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 3A22 0206  20        li   rtmp,(>80*256)
     3A24 8000     
0002 3A26 2806  18        xor  rtmp,ra
                   < elite.a99
12324 3A28 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     3A2A 0032     
12325               
12326 3A2C D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; And then the z-coordinate, so now the XX15 vector goes
     3A2E 0033     
12327                      .eoi (>80*256)                  ; EOR #%10000000    ; from the enemy ship to our ship (it was previously the
     **** ****     > EOI
0001 3A30 0206  20        li   rtmp,(>80*256)
     3A32 8000     
0002 3A34 2806  18        xor  rtmp,ra
                   < elite.a99
12328 3A36 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; other way round)
     3A38 0033     
12329               
12330 3A3A D020  30        movb @CNT,ra                    ; LDA CNT           ; And finally change the sign of the dot product in CNT,
     3A3C 00A4     
12331                      .eoi (>80*256)                  ; EOR #%10000000    ; so now it's positive if the ships are facing each
     **** ****     > EOI
0001 3A3E 0206  20        li   rtmp,(>80*256)
     3A40 8000     
0002 3A42 2806  18        xor  rtmp,ra
                   < elite.a99
12332 3A44 D800  30        movb ra,@CNT                    ; STA CNT           ; other, and negative if they are facing the same way
     3A46 00A4     
12333               
12334               TA15:
12335                                                                          ; If we get here, then one of the following is true:
12336                                                                          ;
12337                                                                          ; * This is an escape pod and XX15 is pointing towards
12338                                                                          ; the planet
12339                                                                          ;
12340                                                                          ; * The ship is pretty close to us, or it's just not
12341                                                                          ; very aggressive (though there is a random factor
12342                                                                          ; at play here too). XX15 is still pointing from our
12343                                                                          ; ship towards the enemy ship
12344                                                                          ;
12345                                                                          ; * The ship is aggressive (though again, there's an
12346                                                                          ; element of randomness here). XX15 is pointing from
12347                                                                          ; the enemy ship towards our ship
12348                                                                          ;
12349                                                                          ; * This is a missile heading for a target. XX15 is
12350                                                                          ; pointing from the missile towards the target
12351                                                                          ;
12352                                                                          ; We now want to move the ship in the direction of XX15,
12353                                                                          ; which will make aggressive ships head towards us, and
12354                                                                          ; ships that are too close turn away. Escape pods,
12355                                                                          ; meanwhile, head off towards the planet in search of a
12356                                                                          ; space station, and missiles home in on their targets
12357 3A48 0202  20        li   ry,>10*256                 ; LDY #16           ; Set (A X) = roofv . XX15
     3A4A 1000     
12358 3A4C 0206  20        li   rtmp,TAS3                  ; JSR TAS3          ;
     3A4E 4476     
12359 3A50 06A0  28        bl   @jsr                       ;
     3A52 8002     
12360                                                                          ; This will be positive if XX15 is pointing in the same
12361                                                                          ; direction as an arrow out of the top of the ship, in
12362                                                                          ; other words if the ship should pull up to head in the
12363                                                                          ; direction of XX15
12364               
12365                      .eoi (>80*256)                  ; EOR #%10000000    ; Set the ship's pitch counter to 3, with the opposite
     **** ****     > EOI
0001 3A54 0206  20        li   rtmp,(>80*256)
     3A56 8000     
0002 3A58 2806  18        xor  rtmp,ra
                   < elite.a99
12366 3A5A 0240  22        andi ra,>80*256                 ; AND #%10000000    ; sign to the dot product result, which gently pitches
     3A5C 8000     
12367 3A5E 0260  22        ori  ra,>03*256                 ; ORA #%00000011    ; the ship towards the direction of the XX15 vector
     3A60 0300     
12368 3A62 D800  30        movb ra,@INWK+30                ; STA INWK+30
     3A64 0071     
12369               
12370 3A66 D020  30        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the roll counter from byte #29 into A and clear
     3A68 0070     
12371 3A6A 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; the sign bit (to give an endless clockwise roll)
     3A6C 7F00     
12372               
12373 3A6E 0280  22        ci   ra,>10*256                 ; CMP #16           ; If A >= 16 then jump to TA6, as the ship is already
     3A70 1000     
12374 3A72 1810  14        joc  TA6                        ; BCS TA6           ; in the process of rolling
12375               
12376 3A74 0202  20        li   ry,>16*256                 ; LDY #22           ; Set (A X) = sidev . XX15
     3A76 1600     
12377 3A78 0206  20        li   rtmp,TAS3                  ; JSR TAS3          ;
     3A7A 4476     
12378 3A7C 06A0  28        bl   @jsr                       ;
     3A7E 8002     
12379                                                                          ; This will be positive if XX15 is pointing in the same
12380                                                                          ; direction as an arrow out of the right side of the
12381                                                                          ; ship, in other words if the ship should roll right to
12382                                                                          ; head in the direction of XX15
12383               
12384                      .eor @INWK+30                   ; EOR INWK+30       ; Set the ship's roll counter to 5, with the sign set to
     **** ****     > EOR
0001 3A80 D1A0  30        movb @INWK+30,rtmp
     3A82 0071     
0002 3A84 2806  18        xor  rtmp,ra
                   < elite.a99
12385 3A86 0240  22        andi ra,>80*256                 ; AND #%10000000    ; positive (clockwise roll) if the pitch counter and dot
     3A88 8000     
12386                      .eoi (>85*256)                  ; EOR #%10000101    ; product have different signs, negative (anti-clockwise
     **** ****     > EOI
0001 3A8A 0206  20        li   rtmp,(>85*256)
     3A8C 8500     
0002 3A8E 2806  18        xor  rtmp,ra
                   < elite.a99
12387 3A90 D800  30        movb ra,@INWK+29                ; STA INWK+29       ; roll) if they have the same sign
     3A92 0070     
12388               
12389               TA6:
12390 3A94 D020  30        movb @CNT,ra                    ; LDA CNT           ; Fetch the dot product, and if it's negative jump to
     3A96 00A4     
12391 3A98 1109  14        jlt  TA9                        ; BMI TA9           ; TA9, as the ships are facing away from each other and
12392                                                                          ; the ship might want to slow down to take another shot
12393               
12394 3A9A 0280  22        ci   ra,>16*256                 ; CMP #22           ; The dot product is positive, so the ships are facing
     3A9C 1600     
12395 3A9E 1706  14        jnc  TA9                        ; BCC TA9           ; each other. If A < 22 then the ships are not heading
12396                                                                          ; directly towards each other, so jump to TA9 to slow
12397                                                                          ; down
12398               
12399 3AA0 0200  20        li   ra,>03*256                 ; LDA #3            ; Otherwise set the acceleration in byte #28 to 3
     3AA2 0300     
12400 3AA4 D800  30        movb ra,@INWK+28                ; STA INWK+28
     3AA6 006F     
12401               
12402 3AA8 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3AAA 800E     
12403               
12404               TA9:
12405 3AAC 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit of the dot product in A
     3AAE 7F00     
12406               
12407 3AB0 0280  22        ci   ra,>12*256                 ; CMP #18           ; If A < 18 then the ship is way off the XX15 vector, so
     3AB2 1200     
12408 3AB4 170C  14        jnc  TA10                       ; BCC TA10          ; return from the subroutine (TA10 contains an RTS)
12409                                                                          ; without slowing down, as it still has quite a bit of
12410                                                                          ; turning to do to get on course
12411               
12412 3AB6 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Otherwise set A = -1
     3AB8 FF00     
12413               
12414 3ABA D060  30        movb @TYPE,rx                   ; LDX TYPE          ; If this is not a missile then skip the ASL instruction
     3ABC 009B     
12415 3ABE 0281  22        ci   rx,(MSL)*256               ; CPX #MSL
     3AC0 0900     
12416 3AC2 1603  14        jne  B36                        ; BNE B36
12417               
12418                      .asla                           ; ASL A             ; This is a missile, so set A = -2, as missiles are more
     **** ****     > ASLA
0001 3AC4 0240  22        andi ra,>ff00
     3AC6 FF00     
0002 3AC8 0A10  18        sla  ra,1
                   < elite.a99
12419                                                                          ; nimble and can brake more quickly
12420               
12421               B36:
12422 3ACA D800  30        movb ra,@INWK+28                ; STA INWK+28       ; Set the ship's acceleration to A
     3ACC 006F     
12423               
12424               TA10:
12425 3ACE 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3AD0 800E     
12426               
12427               * ******************************************************************************
12428               *
12429               * Name: TAS1
12430               * Type: Subroutine
12431               * Category: Maths (Arithmetic)
12432               * Summary: Calculate K3 = (x_sign x_hi x_lo) - V(1 0)
12433               *
12434               * ------------------------------------------------------------------------------
12435               *
12436               * Calculate one of the following, depending on the value in Y:
12437               *
12438               * K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in V(1 0)
12439               *
12440               * K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate in V(1 0)
12441               *
12442               * K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate in V(1 0)
12443               *
12444               * where the first coordinate is from the ship data block in INWK, and the second
12445               * coordinate is from the ship data block pointed to by V(1 0).
12446               *
12447               * ------------------------------------------------------------------------------
12448               *
12449               * Arguments:
12450               *
12451               * V(1 0)              The address of the ship data block to subtract
12452               *
12453               * Y                   The coordinate in the V(1 0) block to subtract:
12454               *
12455               * * If Y = 2, subtract the x-coordinate and store the
12456               * result in K3(2 1 0)
12457               *
12458               * * If Y = 5, subtract the y-coordinate and store the
12459               * result in K3(5 4 3)
12460               *
12461               * * If Y = 8, subtract the z-coordinate and store the
12462               * result in K3(8 7 6)
12463               *
12464               * ******************************************************************************
12465               
12466               TAS1:
12467                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Copy the sign byte of the V(1 0) coordinate into K+3,
     **** ****     > LD_IND_Y_IDX
0001 3AD2 D820  42        movb @V,@rtmplb
     3AD4 0022     
     3AD6 830D     
0002 3AD8 D1A0  30        movb @V+1,rtmp
     3ADA 0023     
0003 3ADC A182  18        a    ry,rtmp
0004 3ADE D016  26        movb *rtmp,RA
                   < elite.a99
12468                      .eoi (>80*256)                  ; EOR #%10000000    ; flipping it in the process
     **** ****     > EOI
0001 3AE0 0206  20        li   rtmp,(>80*256)
     3AE2 8000     
0002 3AE4 2806  18        xor  rtmp,ra
                   < elite.a99
12469 3AE6 D800  30        movb ra,@K+3                    ; STA K+3
     3AE8 0040     
12470               
12471 3AEA 7084  18        sb   rone,ry                    ; DEY               ; Copy the high byte of the V(1 0) coordinate into K+2
12472                      .ld_ind_y_idx @V,ra             ; LDA (V),Y
     **** ****     > LD_IND_Y_IDX
0001 3AEC D820  42        movb @V,@rtmplb
     3AEE 0022     
     3AF0 830D     
0002 3AF2 D1A0  30        movb @V+1,rtmp
     3AF4 0023     
0003 3AF6 A182  18        a    ry,rtmp
0004 3AF8 D016  26        movb *rtmp,RA
                   < elite.a99
12473 3AFA D800  30        movb ra,@K+2                    ; STA K+2
     3AFC 003F     
12474               
12475 3AFE 7084  18        sb   rone,ry                    ; DEY               ; Copy the high byte of the V(1 0) coordinate into K+1,
12476                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; so now:
     **** ****     > LD_IND_Y_IDX
0001 3B00 D820  42        movb @V,@rtmplb
     3B02 0022     
     3B04 830D     
0002 3B06 D1A0  30        movb @V+1,rtmp
     3B08 0023     
0003 3B0A A182  18        a    ry,rtmp
0004 3B0C D016  26        movb *rtmp,RA
                   < elite.a99
12477 3B0E D800  30        movb ra,@K+1                    ; STA K+1           ;
     3B10 003E     
12478                                                                          ; K(3 2 1) = - coordinate in V(1 0)
12479               
12480 3B12 D802  30        movb ry,@U                      ; STY U             ; Copy the index (now 0, 3 or 6) into U and X
     3B14 008F     
12481 3B16 D060  30        movb @U,rx                      ; LDX U
     3B18 008F     
12482               
12483 3B1A 0206  20        li   rtmp,MVT3                  ; JSR MVT3          ; Call MVT3 to add the same coordinates, but this time
     3B1C 1C88     
12484 3B1E 06A0  28        bl   @jsr                       ;
     3B20 8002     
12485                                                                          ; from INWK, so this would look like this for the
12486                                                                          ; x-axis:
12487                                                                          ;
12488                                                                          ; K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
12489                                                                          ; = (x_sign x_hi x_lo) - coordinate in V(1 0)
12490               
12491 3B22 D0A0  30        movb @U,ry                      ; LDY U             ; Restore the index into Y, though this instruction has
     3B24 008F     
12492                                                                          ; no effect, as Y is not used again, either here or
12493                                                                          ; following calls to this routine
12494               
12495 3B26 D840  38        movb ra,@K3+2(rx)               ; STA K3+2,X        ; Store K(3 2 1) in K3+X(2 1 0), starting with the sign
     3B28 00D4     
12496                                                                          ; byte
12497               
12498 3B2A D020  30        movb @K+2,ra                    ; LDA K+2           ; And then doing the high byte
     3B2C 003F     
12499 3B2E D840  38        movb ra,@K3+1(rx)               ; STA K3+1,X
     3B30 00D3     
12500               
12501 3B32 D020  30        movb @K+1,ra                    ; LDA K+1           ; And finally the low byte
     3B34 003E     
12502 3B36 D840  38        movb ra,@K3(rx)                 ; STA K3,X
     3B38 00D2     
12503               
12504 3B3A 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3B3C 800E     
12505               
12506               * ******************************************************************************
12507               *
12508               * Name: HITCH
12509               * Type: Subroutine
12510               * Category: Tactics
12511               * Summary: Work out if the ship in INWK is in our crosshairs
12512               * Deep dive: In the crosshairs
12513               *
12514               * ------------------------------------------------------------------------------
12515               *
12516               * This is called by the main flight loop to see if we have laser or missile lock
12517               * on an enemy ship.
12518               *
12519               * ------------------------------------------------------------------------------
12520               *
12521               * Returns:
12522               *
12523               * C flag              Set if the ship is in our crosshairs, clear if it isn't
12524               *
12525               * ------------------------------------------------------------------------------
12526               *
12527               * Other entry points:
12528               *
12529               * HI1                 Contains an RTS
12530               *
12531               * ******************************************************************************
12532               
12533               HITCH:
12534                      .clc                            ; CLC               ; Clear the C flag so we can return with it cleared if
     **** ****     > CLC
0001 3B3E 0A13  18        sla  rzero,1
                   < elite.a99
12535                                                                          ; our checks fail
12536               
12537 3B40 D020  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set A = z_sign
     3B42 005B     
12538               
12539 3B44 1647  14        jne  HI1                        ; BNE HI1           ; If A is non-zero then the ship is behind us and can't
12540                                                                          ; be in our crosshairs, so return from the subroutine
12541                                                                          ; with the C flag clear (as HI1 contains an RTS)
12542               
12543 3B46 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type has bit 7 set then it is the planet
     3B48 009B     
12544 3B4A 1144  14        jlt  HI1                        ; BMI HI1           ; or sun, which we can't target or hit with lasers, so
12545                                                                          ; return from the subroutine with the C flag clear (as
12546                                                                          ; HI1 contains an RTS)
12547               
12548 3B4C D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch bit 5 of byte #31 (the exploding flag) and OR
     3B4E 0072     
12549 3B50 0240  22        andi ra,>20*256                 ; AND #%00100000    ; with x_hi and y_hi
     3B52 2000     
12550 3B54 F020  30        socb @INWK+1,ra                 ; ORA INWK+1
     3B56 0054     
12551 3B58 F020  30        socb @INWK+4,ra                 ; ORA INWK+4
     3B5A 0057     
12552               
12553 3B5C 163B  14        jne  HI1                        ; BNE HI1           ; If this value is non-zero then either the ship is
12554                                                                          ; exploding (so we can't target it), or the ship is too
12555                                                                          ; far away from our line of fire to be targeted, so
12556                                                                          ; return from the subroutine with the C flag clear (as
12557                                                                          ; HI1 contains an RTS)
12558               
12559 3B5E D020  30        movb @INWK,ra                   ; LDA INWK          ; Set A = x_lo
     3B60 0053     
12560               
12561 3B62 0206  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A = x_lo^2
     3B64 42BA     
12562 3B66 06A0  28        bl   @jsr                       ;
     3B68 8002     
12563               
12564 3B6A D800  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P) = x_lo^2
     3B6C 0092     
12565 3B6E D020  30        movb @P,ra                      ; LDA P
     3B70 001B     
12566 3B72 D800  30        movb ra,@R                      ; STA R
     3B74 0091     
12567               
12568 3B76 D020  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set A = y_lo
     3B78 0056     
12569               
12570 3B7A 0206  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A = y_lo^2
     3B7C 42BA     
12571 3B7E 06A0  28        bl   @jsr                       ;
     3B80 8002     
12572               
12573 3B82 D040  18        movb ra,rx                      ; TAX               ; Store the high byte in X
12574               
12575 3B84 D020  30        movb @P,ra                      ; LDA P             ; Add the two low bytes, so:
     3B86 001B     
12576                      .adc @R,ra                      ; ADC R             ;
     **** ****     > ADC
0001 3B88 1701  14        jnc  !
0002 3B8A B004  18        ab   rone,ra
0003               !:
0004 3B8C B020  30        ab   @R,ra
     3B8E 0091     
                   < elite.a99
12577 3B90 D800  30        movb ra,@R                      ; STA R             ; R = P + R
     3B92 0091     
12578               
12579 3B94 D001  18        movb rx,ra                      ; TXA               ; Restore the high byte into A and add S to give the
12580                      .adc @S,ra                      ; ADC S             ; following:
     **** ****     > ADC
0001 3B96 1701  14        jnc  !
0002 3B98 B004  18        ab   rone,ra
0003               !:
0004 3B9A B020  30        ab   @S,ra
     3B9C 0092     
                   < elite.a99
12581                                                                          ;
12582                                                                          ; (A R) = (S R) + (A P) = x_lo^2 + y_lo^2
12583               
12584 3B9E 1702  14        jnc  FIX002                     ; BCC FIX002        ; If the addition just overflowed then there is no way
12585                                                                          ; our crosshairs are within the ship's targetable area,
12586                                                                          ; so return from the subroutine with the C flag clear
12587                                                                          ; (as FR1-2 contains a CLC then an RTS)
12588 3BA0 0460  28        b    @FR1-2                     ; JMP FR1-2
     3BA2 3CF0     
12589               FIX002:
12590 3BA4 D800  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P) = x_lo^2 + y_lo^2
     3BA6 0092     
12591               
12592 3BA8 0202  20        li   ry,>02*256                 ; LDY #2            ; Fetch the ship's blueprint and set A to the high byte
     3BAA 0200     
12593                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; of the targetable area of the ship
     **** ****     > LD_IND_Y_IDX
0001 3BAC D820  42        movb @XX0,@rtmplb
     3BAE 001E     
     3BB0 830D     
0002 3BB2 D1A0  30        movb @XX0+1,rtmp
     3BB4 001F     
0003 3BB6 A182  18        a    ry,rtmp
0004 3BB8 D016  26        movb *rtmp,RA
                   < elite.a99
12594               
12595 3BBA 9020  30        cb   @S,ra                      ; CMP S             ; We now compare the high bytes of the targetable area
     3BBC 0092     
12596                                                                          ; and the calculation in (S R):
12597                                                                          ;
12598                                                                          ; * If A >= S then then the C flag will be set
12599                                                                          ;
12600                                                                          ; * If A < S then the C flag will be C clear
12601               
12602 3BBE 160A  14        jne  HI1                        ; BNE HI1           ; If A <> S we have just set the C flag correctly, so
12603                                                                          ; return from the subroutine (as HI1 contains an RTS)
12604               
12605 3BC0 7084  18        sb   rone,ry                    ; DEY               ; The high bytes were identical, so now we fetch the
12606                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; low byte of the targetable area into A
     **** ****     > LD_IND_Y_IDX
0001 3BC2 D820  42        movb @XX0,@rtmplb
     3BC4 001E     
     3BC6 830D     
0002 3BC8 D1A0  30        movb @XX0+1,rtmp
     3BCA 001F     
0003 3BCC A182  18        a    ry,rtmp
0004 3BCE D016  26        movb *rtmp,RA
                   < elite.a99
12607               
12608 3BD0 9020  30        cb   @R,ra                      ; CMP R             ; We now compare the low bytes of the targetable area
     3BD2 0091     
12609                                                                          ; and the calculation in (S R):
12610                                                                          ;
12611                                                                          ; * If A >= R then the C flag will be set
12612                                                                          ;
12613                                                                          ; * If A < R then the C flag will be C clear
12614               
12615               HI1:
12616 3BD4 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3BD6 800E     
12617               
12618               * ******************************************************************************
12619               *
12620               * Name: FRS1
12621               * Type: Subroutine
12622               * Category: Tactics
12623               * Summary: Launch a ship straight ahead of us, below the laser sights
12624               *
12625               * ------------------------------------------------------------------------------
12626               *
12627               * This is used in two places:
12628               *
12629               * * When we launch a missile, in which case the missile is the ship that is
12630               * launched ahead of us
12631               *
12632               * * When we launch our escape pod, in which case it's our abandoned Cobra Mk
12633               * III that is launched ahead of us
12634               *
12635               * * The fq1 entry point is used to launch a bunch of cargo canisters ahead of
12636               * us as part of the death screen
12637               *
12638               * ------------------------------------------------------------------------------
12639               *
12640               * Arguments:
12641               *
12642               * X                   The type of ship to launch ahead of us
12643               *
12644               * ------------------------------------------------------------------------------
12645               *
12646               * Returns:
12647               *
12648               * C flag              Set if the ship was successfully launched, clear if it
12649               * wasn't (as there wasn't enough free memory)
12650               *
12651               * ------------------------------------------------------------------------------
12652               *
12653               * Other entry points:
12654               *
12655               * fq1                 Used to add a cargo canister to the universe
12656               *
12657               * ******************************************************************************
12658               
12659               FRS1:
12660 3BD8 0206  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     3BDA 7FB4     
12661 3BDC 06A0  28        bl   @jsr                       ;
     3BDE 8002     
12662               
12663 3BE0 0200  20        li   ra,>1c*256                 ; LDA #28           ; Set y_lo = 28
     3BE2 1C00     
12664 3BE4 D800  30        movb ra,@INWK+3                 ; STA INWK+3
     3BE6 0056     
12665               
12666 3BE8 0910  18        srl  ra,1                       ; LSR A             ; Set z_lo = 14, so the launched ship starts out
12667 3BEA D800  30        movb ra,@INWK+6                 ; STA INWK+6        ; ahead of us
     3BEC 0059     
12668               
12669 3BEE 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set y_sign to be negative, so the launched ship is
     3BF0 8000     
12670 3BF2 D800  30        movb ra,@INWK+5                 ; STA INWK+5        ; launched just below our line of sight
     3BF4 0058     
12671               
12672 3BF6 D020  30        movb @MSTG,ra                   ; LDA MSTG          ; Set A to the missile lock target, shifted left so the
     3BF8 0052     
12673                      .asla                           ; ASL A             ; slot number is in bits 1-5
     **** ****     > ASLA
0001 3BFA 0240  22        andi ra,>ff00
     3BFC FF00     
0002 3BFE 0A10  18        sla  ra,1
                   < elite.a99
12674               
12675 3C00 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 and store the result in byte #32, the AI
     3C02 8000     
12676 3C04 D800  30        movb ra,@INWK+32                ; STA INWK+32       ; flag launched ship for the launched ship. For missiles
     3C06 0073     
12677                                                                          ; this enables AI (bit 7), makes it friendly towards us
12678                                                                          ; (bit 6), sets the target to the value of MSTG (bits
12679                                                                          ; 1-5), and sets its lock status as launched (bit 0).
12680                                                                          ; It doesn't matter what it does for our abandoned
12681                                                                          ; Cobra, as the AI flag gets overwritten once we return
12682                                                                          ; from the subroutine back to the ESCAPE routine that
12683                                                                          ; called FRS1 in the first place
12684               
12685               fq1_:
12686 3C08 0200  20        li   ra,>60*256                 ; LDA #&60          ; Set byte #14 (nosev_z_hi) to 1 (&60), so the launched
     3C0A 6000     
12687 3C0C D800  30        movb ra,@INWK+14                ; STA INWK+14       ; ship is pointing away from us
     3C0E 0061     
12688               
12689 3C10 0260  22        ori  ra,>80*256                 ; ORA #128          ; Set byte #22 (sidev_x_hi) to -1 (&D0), so the launched
     3C12 8000     
12690 3C14 D800  30        movb ra,@INWK+22                ; STA INWK+22       ; ship has the same orientation as spawned ships, just
     3C16 0069     
12691                                                                          ; pointing away from us (if we set sidev to +1 instead,
12692                                                                          ; this ship would be a mirror image of all the other
12693                                                                          ; ships, which are spawned with -1 in nosev and +1 in
12694                                                                          ; sidev)
12695               
12696 3C18 D020  30        movb @DELTA,ra                  ; LDA DELTA         ; Set byte #27 (speed) to 2 * DELTA, so the launched
     3C1A 008C     
12697 3C1C 06A0  28        bl   @rola                      ; ROL A             ; ship flies off at twice our speed
     3C1E 8018     
12698 3C20 D800  30        movb ra,@INWK+27                ; STA INWK+27
     3C22 006E     
12699               
12700 3C24 D001  18        movb rx,ra                      ; TXA               ; Add a new ship of type X to our local bubble of
12701 3C26 0460  28        b    @NWSHP                     ; JMP NWSHP         ; universe and return from the subroutine using a tail
     3C28 6F6E     
12702                                                                          ; call
12703               
12704               * ******************************************************************************
12705               *
12706               * Name: FRMIS
12707               * Type: Subroutine
12708               * Category: Tactics
12709               * Summary: Fire a missile from our ship
12710               *
12711               * ------------------------------------------------------------------------------
12712               *
12713               * We fired a missile, so send it streaking away from us to unleash mayhem and
12714               * destruction on our sworn enemies.
12715               *
12716               * ******************************************************************************
12717               
12718               FRMIS:
12719 3C2A 0201  20        li   rx,(MSL)*256               ; LDX #MSL          ; Call FRS1 to launch a missile straight ahead of us
     3C2C 0900     
12720 3C2E 0206  20        li   rtmp,FRS1                  ; JSR FRS1
     3C30 3BD8     
12721 3C32 06A0  28        bl   @jsr                       ;
     3C34 8002     
12722               
12723 3C36 175D  14        jnc  FR1                        ; BCC FR1           ; If FRS1 returns with the C flag clear, then there
12724                                                                          ; isn't room in the universe for our missile, so jump
12725                                                                          ; down to FR1 to display a "missile jammed" message
12726               
12727 3C38 D060  30        movb @MSTG,rx                   ; LDX MSTG          ; Fetch the slot number of the missile's target
     3C3A 0052     
12728               
12729 3C3C 0206  20        li   rtmp,GINF                  ; JSR GINF          ; Get the address of the data block for the target ship
     3C3E 6F00     
12730 3C40 06A0  28        bl   @jsr                       ;
     3C42 8002     
12731                                                                          ; and store it in INF
12732               
12733 3C44 D021  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the ship type of the missile's target into A
     3C46 0D40     
12734               
12735 3C48 0206  20        li   rtmp,ANGRY                 ; JSR ANGRY         ; Call ANGRY to make the target ship hostile
     3C4A 3C66     
12736 3C4C 06A0  28        bl   @jsr                       ;
     3C4E 8002     
12737               
12738 3C50 0202  20        li   ry,>00*256                 ; LDY #0            ; We have just launched a missile, so we need to remove
     3C52 0000     
12739 3C54 0206  20        li   rtmp,ABORT                 ; JSR ABORT         ; missile lock and hide the leftmost indicator on the
     3C56 7096     
12740 3C58 06A0  28        bl   @jsr                       ;
     3C5A 8002     
12741                                                                          ; dashboard by setting it to black (Y = 0)
12742               
12743 3C5C 7004  18        sb   rone,ra                    ; DEC NOMSL         ; Reduce the number of missiles we have by 1
12744               
12745 3C5E 0200  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     3C60 3000     
12746 3C62 0460  24        b    @NOISE                     ; JMP NOISE         ; of a missile launch, returning from the subroutine
     3C64 8BA4     
12747                                                                          ; using a tail call
12748               
12749               * ******************************************************************************
12750               *
12751               * Name: ANGRY
12752               * Type: Subroutine
12753               * Category: Tactics
12754               * Summary: Make a ship hostile
12755               *
12756               * ------------------------------------------------------------------------------
12757               *
12758               * All this routine does is set the ship's hostile flag, start it turning and
12759               * give it a kick of acceleration - later calls to TACTICS will make the ship
12760               * start to attack us.
12761               *
12762               * ------------------------------------------------------------------------------
12763               *
12764               * Arguments:
12765               *
12766               * A                   The type of ship we're going to irritate
12767               *
12768               * INF                 The address of the data block for the ship we're going
12769               * to infuriate
12770               *
12771               * ******************************************************************************
12772               
12773               ANGRY:
12774 3C66 0280  22        ci   ra,(SST)*256               ; CMP #SST          ; If this is the space station, jump to AN2 to make the
     3C68 0800     
12775 3C6A 1334  14        jeq  AN2                        ; BEQ AN2           ; space station hostile
12776               
12777 3C6C 18B3  14        joc  HI1                        ; BCS HI1           ; If A >= #SST then this is a missile, asteroid, cargo
12778                                                                          ; canister, Thargon or escape pod, and they can't get
12779                                                                          ; hostile, so return from the subroutine (as HI1
12780                                                                          ; contains an RTS)
12781               
12782 3C6E 0280  22        ci   ra,(CYL)*256               ; CMP #CYL          ; If this is not a Cobra Mk III trader, skip the
     3C70 0700     
12783 3C72 1604  14        jne  B37                        ; BNE B37           ; following instruction
12784               
12785 3C74 0206  20        li   rtmp,AN2                   ; JSR AN2           ; Call AN2 to make the space station hostile
     3C76 3CD4     
12786 3C78 06A0  28        bl   @jsr                       ;
     3C7A 8002     
12787               
12788               B37:
12789 3C7C 0202  20        li   ry,>20*256                 ; LDY #32           ; Fetch the ship's byte #32 (AI flag)
     3C7E 2000     
12790                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y
     **** ****     > LD_IND_Y_IDX
0001 3C80 D820  42        movb @INF,@rtmplb
     3C82 0020     
     3C84 830D     
0002 3C86 D1A0  30        movb @INF+1,rtmp
     3C88 0021     
0003 3C8A A182  18        a    ry,rtmp
0004 3C8C D016  26        movb *rtmp,RA
                   < elite.a99
12791               
12792 3C8E 13A2  14        jeq  HI1                        ; BEQ HI1           ; If the AI flag is zero then this ship has no AI and
12793                                                                          ; it can't get hostile, so return from the subroutine
12794                                                                          ; (as HI1 contains an RTS)
12795               
12796 3C90 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Otherwise set bit 7 (AI enabled) to ensure AI is
     3C92 8000     
12797                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; definitely enabled
     **** ****     > ST_IND_Y_IDX
0001 3C94 D820  42        movb @INF,@rtmplb
     3C96 0020     
     3C98 830D     
0002 3C9A D1A0  30        movb @INF+1,rtmp
     3C9C 0021     
0003 3C9E A182  18        a    ry,rtmp
0004 3CA0 D580  30        movb RA,*rtmp
                   < elite.a99
12798               
12799 3CA2 0202  20        li   ry,>1c*256                 ; LDY #28           ; Set the ship's byte #28 (acceleration) to 2, so it
     3CA4 1C00     
12800 3CA6 0200  20        li   ra,>02*256                 ; LDA #2            ; speeds up
     3CA8 0200     
12801                      .st_ind_y_idx @INF,ra           ; STA (INF),Y
     **** ****     > ST_IND_Y_IDX
0001 3CAA D820  42        movb @INF,@rtmplb
     3CAC 0020     
     3CAE 830D     
0002 3CB0 D1A0  30        movb @INF+1,rtmp
     3CB2 0021     
0003 3CB4 A182  18        a    ry,rtmp
0004 3CB6 D580  30        movb RA,*rtmp
                   < elite.a99
12802               
12803                      .asla                           ; ASL A             ; Set the ship's byte #30 (pitch counter) to 4, so it
     **** ****     > ASLA
0001 3CB8 0240  22        andi ra,>ff00
     3CBA FF00     
0002 3CBC 0A10  18        sla  ra,1
                   < elite.a99
12804 3CBE 0202  20        li   ry,>1e*256                 ; LDY #30           ; starts diving
     3CC0 1E00     
12805                      .st_ind_y_idx @INF,ra           ; STA (INF),Y
     **** ****     > ST_IND_Y_IDX
0001 3CC2 D820  42        movb @INF,@rtmplb
     3CC4 0020     
     3CC6 830D     
0002 3CC8 D1A0  30        movb @INF+1,rtmp
     3CCA 0021     
0003 3CCC A182  18        a    ry,rtmp
0004 3CCE D580  30        movb RA,*rtmp
                   < elite.a99
12806               
12807 3CD0 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3CD2 800E     
12808               
12809               AN2:
12810                      .asl @K.+NI.+32                 ; ASL K%+NI%+32     ; Fetch the AI counter (byte #32) of the second ship
     **** ****     > ASL
0001 3CD4 D1A0  30        movb @K.+NI.+32,rtmp
     3CD6 0944     
0002 3CD8 0246  22        andi rtmp,>ff00
     3CDA FF00     
0003 3CDC 0A16  18        sla  rtmp,1
0004 3CDE D806  30        movb rtmp,@K.+NI.+32
     3CE0 0944     
                   < elite.a99
12811                      .sec                            ; SEC               ; in the ship data workspace at K%, which is reserved
     **** ****     > SEC
0001 3CE2 0A15  18        sla  rmone,1
                   < elite.a99
12812 3CE4 0208  20        li   rarg1,K.+NI.+32            ; ROR K%+NI%+32     ; for the sun or the space station (in this case it's
     3CE6 0944     
12813 3CE8 06A0  28        bl   @ror                       ;
     3CEA 8054     
12814                                                                          ; the latter), and set bit 7 to make it hostile
12815               
12816                      .clc                            ; CLC               ; Clear the C flag, which isn't used by calls to this
     **** ****     > CLC
0001 3CEC 0A13  18        sla  rzero,1
                   < elite.a99
12817                                                                          ; routine, but it does set up the entry point FR1-2
12818                                                                          ; so that it clears the C flag and does an RTS
12819               
12820 3CEE 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3CF0 800E     
12821               
12822               * ******************************************************************************
12823               *
12824               * Name: FR1
12825               * Type: Subroutine
12826               * Category: Tactics
12827               * Summary: Display the "missile jammed" message
12828               *
12829               * ------------------------------------------------------------------------------
12830               *
12831               * This is shown if there isn't room in the local bubble of universe for a new
12832               * missile.
12833               *
12834               * ------------------------------------------------------------------------------
12835               *
12836               * Other entry points:
12837               *
12838               * FR1-2               Clear the C flag and return from the subroutine
12839               *
12840               * ******************************************************************************
12841               
12842               FR1:
12843 3CF2 0200  20        li   ra,>c9*256                 ; LDA #201          ; Print recursive token 41 ("MISSILE JAMMED") as an
     3CF4 C900     
12844 3CF6 0460  24        b    @MESS                      ; JMP MESS          ; in-flight message and return from the subroutine using
     3CF8 8E52     
12845                                                                          ; a tail call
12846               
12847               * ******************************************************************************
12848               *
12849               * Name: SESCP
12850               * Type: Subroutine
12851               * Category: Flight
12852               * Summary: Spawn an escape pod from the current (parent) ship
12853               *
12854               * ------------------------------------------------------------------------------
12855               *
12856               * This is called when an enemy ship has run out of both energy and luck, so it's
12857               * time to bail.
12858               *
12859               * ******************************************************************************
12860               
12861               SESCP:
12862 3CFA 0201  20        li   rx,(ESC)*256               ; LDX #ESC          ; Set X to the ship type for an escape pod
     3CFC 0D00     
12863               
12864 3CFE 0200  20        li   ra,>fe*256                 ; LDA #%11111110    ; Set A to an AI flag that has AI enabled, is hostile,
     3D00 FE00     
12865                                                                          ; but has no E.C.M.
12866               
12867                                                                          ; Fall through into SFS1 to spawn the escape pod
12868               
12869               * ******************************************************************************
12870               *
12871               * Name: SFS1
12872               * Type: Subroutine
12873               * Category: Universe
12874               * Summary: Spawn a child ship from the current (parent) ship
12875               *
12876               * ------------------------------------------------------------------------------
12877               *
12878               * If the parent is a space station then the child ship is spawned coming out of
12879               * the slot, and if the child is a cargo canister, it is sent tumbling through
12880               * space. Otherwise the child ship is spawned with the same ship data as the
12881               * parent, just with damping disabled and the ship type and AI flag that are
12882               * passed in A and X.
12883               *
12884               * ------------------------------------------------------------------------------
12885               *
12886               * Arguments:
12887               *
12888               * A                   AI flag for the new ship (see the documentation on ship
12889               * data byte #32 for details)
12890               *
12891               * X                   The ship type of the child to spawn
12892               *
12893               * INF                 Address of the parent's ship data block
12894               *
12895               * TYPE                The type of the parent ship
12896               *
12897               * ------------------------------------------------------------------------------
12898               *
12899               * Returns:
12900               *
12901               * C flag              Set if ship successfully added, clear if it failed
12902               *
12903               * INF                 INF is preserved
12904               *
12905               * XX0                 XX0 is preserved
12906               *
12907               * INWK                The whole INWK workspace is preserved
12908               *
12909               * ------------------------------------------------------------------------------
12910               *
12911               * Other entry points:
12912               *
12913               * SFS1-2              Add a missile to the local bubble that has AI enabled,
12914               * is hostile, but has no E.C.M.
12915               *
12916               * ******************************************************************************
12917               
12918               SFS1:
12919 3D02 D800  30        movb ra,@T1                     ; STA T1            ; Store the child ship's AI flag in T1
     3D04 0006     
12920               
12921                                                                          ; Before spawning our child ship, we need to save the
12922                                                                          ; INF and XX00 variables and the whole INWK workspace,
12923                                                                          ; so we can restore them later when returning from the
12924                                                                          ; subroutine
12925               
12926 3D06 D020  30        movb @XX0,ra                    ; LDA XX0           ; Store XX0(1 0) on the stack, so we can restore it
     3D08 001E     
12927                      .pha                            ; PHA               ; later when returning from the subroutine
     **** ****     > PHA
0001 3D0A D680  30        movb ra,*rsp
0002 3D0C 060A  14        dec  rsp
                   < elite.a99
12928 3D0E D020  30        movb @XX0+1,ra                  ; LDA XX0+1
     3D10 001F     
12929                      .pha                            ; PHA
     **** ****     > PHA
0001 3D12 D680  30        movb ra,*rsp
0002 3D14 060A  14        dec  rsp
                   < elite.a99
12930               
12931 3D16 D020  30        movb @INF,ra                    ; LDA INF           ; Store INF(1 0) on the stack, so we can restore it
     3D18 0020     
12932                      .pha                            ; PHA               ; later when returning from the subroutine
     **** ****     > PHA
0001 3D1A D680  30        movb ra,*rsp
0002 3D1C 060A  14        dec  rsp
                   < elite.a99
12933 3D1E D020  30        movb @INF+1,ra                  ; LDA INF+1
     3D20 0021     
12934                      .pha                            ; PHA
     **** ****     > PHA
0001 3D22 D680  30        movb ra,*rsp
0002 3D24 060A  14        dec  rsp
                   < elite.a99
12935               
12936 3D26 0202  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; Now we want to store the current INWK data block in
     3D28 2300     
12937                                                                          ; temporary memory so we can restore it when we are
12938                                                                          ; done, and we also want to copy the parent's ship data
12939                                                                          ; into INWK, which we can do at the same time, so set up
12940                                                                          ; a counter in Y for NI% bytes
12941               
12942               FRL2:
12943 3D2A D022  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Copy the Y-th byte of INWK to the Y-th byte of
     3D2C 0053     
12944 3D2E D880  38        movb ra,@XX3(ry)                ; STA XX3,Y         ; temporary memory in XX3, so we can restore it later
     3D30 0100     
12945                                                                          ; when returning from the subroutine
12946               
12947                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Copy the Y-th byte of the parent ship's data block to
     **** ****     > LD_IND_Y_IDX
0001 3D32 D820  42        movb @INF,@rtmplb
     3D34 0020     
     3D36 830D     
0002 3D38 D1A0  30        movb @INF+1,rtmp
     3D3A 0021     
0003 3D3C A182  18        a    ry,rtmp
0004 3D3E D016  26        movb *rtmp,RA
                   < elite.a99
12948 3D40 D880  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; the Y-th byte of INWK
     3D42 0053     
12949               
12950 3D44 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
12951               
12952 3D46 15F1  14        jgt  FRL2                       ; BPL FRL2          ; Loop back to copy the next byte until we have done
12953                                                                          ; them all
12954               
12955                                                                          ; INWK now contains the ship data for the parent ship,
12956                                                                          ; so now we need to tweak the data before creating the
12957                                                                          ; new child ship (in this way, the child inherits things
12958                                                                          ; like location from the parent)
12959               
12960 3D48 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship type of the parent into A
     3D4A 009B     
12961               
12962 3D4C 0280  22        ci   ra,(SST)*256               ; CMP #SST          ; If the parent is not a space station, jump to rx to
     3D4E 0800     
12963 3D50 1622  14        jne  rx_                        ; BNE rx            ; skip the following
12964               
12965                                                                          ; The parent is a space station, so the child needs to
12966                                                                          ; launch out of the space station's slot. The space
12967                                                                          ; station's nosev vector points out of the station's
12968                                                                          ; slot, so we want to move the ship along this vector.
12969                                                                          ; We do this by taking the unit vector in nosev and
12970                                                                          ; doubling it, so we spawn our ship 2 units along the
12971                                                                          ; vector from the space station's centre
12972               
12973 3D52 D001  18        movb rx,ra                      ; TXA               ; Store the child's ship type in X on the stack
12974                      .pha                            ; PHA
     **** ****     > PHA
0001 3D54 D680  30        movb ra,*rsp
0002 3D56 060A  14        dec  rsp
                   < elite.a99
12975               
12976 3D58 0200  20        li   ra,>20*256                 ; LDA #32           ; Set the child's byte #27 (speed) to 32
     3D5A 2000     
12977 3D5C D800  30        movb ra,@INWK+27                ; STA INWK+27
     3D5E 006E     
12978               
12979 3D60 0201  20        li   rx,>00*256                 ; LDX #0            ; Add 2 * nosev_x_hi to (x_lo, x_hi, x_sign) to get the
     3D62 0000     
12980 3D64 D020  30        movb @INWK+10,ra                ; LDA INWK+10       ; child's x-coordinate
     3D66 005D     
12981 3D68 0206  20        li   rtmp,SFS2                  ; JSR SFS2
     3D6A 3E26     
12982 3D6C 06A0  28        bl   @jsr                       ;
     3D6E 8002     
12983               
12984 3D70 0201  20        li   rx,>03*256                 ; LDX #3            ; Add 2 * nosev_y_hi to (y_lo, y_hi, y_sign) to get the
     3D72 0300     
12985 3D74 D020  30        movb @INWK+12,ra                ; LDA INWK+12       ; child's y-coordinate
     3D76 005F     
12986 3D78 0206  20        li   rtmp,SFS2                  ; JSR SFS2
     3D7A 3E26     
12987 3D7C 06A0  28        bl   @jsr                       ;
     3D7E 8002     
12988               
12989 3D80 0201  20        li   rx,>06*256                 ; LDX #6            ; Add 2 * nosev_z_hi to (z_lo, z_hi, z_sign) to get the
     3D82 0600     
12990 3D84 D020  30        movb @INWK+14,ra                ; LDA INWK+14       ; child's z-coordinate
     3D86 0061     
12991 3D88 0206  20        li   rtmp,SFS2                  ; JSR SFS2
     3D8A 3E26     
12992 3D8C 06A0  28        bl   @jsr                       ;
     3D8E 8002     
12993               
12994                      .pla                            ; PLA               ; Restore the child's ship type from the stack into X
     **** ****     > PLA
0001 3D90 058A  14        inc  rsp
0002 3D92 D01A  26        movb *rsp,ra
                   < elite.a99
12995 3D94 D040  18        movb ra,rx                      ; TAX
12996               
12997               rx_:
12998 3D96 D020  30        movb @T1,ra                     ; LDA T1            ; Restore the child ship's AI flag from T1 and store it
     3D98 0006     
12999 3D9A D800  30        movb ra,@INWK+32                ; STA INWK+32       ; in the child's byte #32 (AI)
     3D9C 0073     
13000               
13001                      .lsr @INWK+29                   ; LSR INWK+29       ; Clear bit 0 of the child's byte #29 (roll counter) so
     **** ****     > LSR
0001 3D9E D1A0  30        movb @INWK+29,rtmp
     3DA0 0070     
0002 3DA2 0916  18        srl  rtmp,1
0003 3DA4 D806  30        movb rtmp,@INWK+29
     3DA6 0070     
                   < elite.a99
13002                      .asl @INWK+29                   ; ASL INWK+29       ; that its roll dampens (so if we are spawning from a
     **** ****     > ASL
0001 3DA8 D1A0  30        movb @INWK+29,rtmp
     3DAA 0070     
0002 3DAC 0246  22        andi rtmp,>ff00
     3DAE FF00     
0003 3DB0 0A16  18        sla  rtmp,1
0004 3DB2 D806  30        movb rtmp,@INWK+29
     3DB4 0070     
                   < elite.a99
13003                                                                          ; space station, for example, the spawned ship won't
13004                                                                          ; keep rolling forever)
13005               
13006 3DB6 D001  18        movb rx,ra                      ; TXA               ; Copy the child's ship type from X into A
13007               
13008 3DB8 0280  22        ci   ra,(OIL)*256               ; CMP #OIL          ; If the child we are spawning is not a cargo canister,
     3DBA 0B00     
13009 3DBC 1616  14        jne  NOIL                       ; BNE NOIL          ; jump to NOIL to skip us setting up the pitch and roll
13010                                                                          ; for the canister
13011               
13012 3DBE 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3DC0 8070     
13013 3DC2 06A0  28        bl   @jsr                       ;
     3DC4 8002     
13014               
13015                      .asla                           ; ASL A             ; Set the child's byte #30 (pitch counter) to a random
     **** ****     > ASLA
0001 3DC6 0240  22        andi ra,>ff00
     3DC8 FF00     
0002 3DCA 0A10  18        sla  ra,1
                   < elite.a99
13016 3DCC D800  30        movb ra,@INWK+30                ; STA INWK+30       ; value, and at the same time set the C flag randomly
     3DCE 0071     
13017               
13018 3DD0 D001  18        movb rx,ra                      ; TXA               ; Set the child's byte #27 (speed) to a random value
13019 3DD2 0240  22        andi ra,>0f*256                 ; AND #%00001111    ; between 0 and 15
     3DD4 0F00     
13020 3DD6 D800  30        movb ra,@INWK+27                ; STA INWK+27
     3DD8 006E     
13021               
13022 3DDA 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Set the child's byte #29 (roll counter) to a full
     3DDC FF00     
13023 3DDE 06A0  28        bl   @rora                      ; ROR A             ; roll with no damping (as bits 0 to 6 are set), so the
     3DE0 803C     
13024 3DE2 D800  30        movb ra,@INWK+29                ; STA INWK+29       ; canister tumbles through space, with the direction in
     3DE4 0070     
13025                                                                          ; bit 7 set randomly, depending on the C flag from above
13026               
13027 3DE6 0200  20        li   ra,(OIL)*256               ; LDA #OIL          ; Set A to the ship type of a cargo canister
     3DE8 0B00     
13028               
13029               NOIL:
13030 3DEA 0206  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Add a new ship of type A to the local bubble
     3DEC 6F6E     
13031 3DEE 06A0  28        bl   @jsr                       ;
     3DF0 8002     
13032               
13033                                                                          ; We have now created our child ship, so we need to
13034                                                                          ; restore all the variables we saved at the start of
13035                                                                          ; the routine, so they are preserved when we return
13036                                                                          ; from the subroutine
13037               
13038                      .pla                            ; PLA               ; Restore INF(1 0) from the stack
     **** ****     > PLA
0001 3DF2 058A  14        inc  rsp
0002 3DF4 D01A  26        movb *rsp,ra
                   < elite.a99
13039 3DF6 D800  30        movb ra,@INF+1                  ; STA INF+1
     3DF8 0021     
13040                      .pla                            ; PLA
     **** ****     > PLA
0001 3DFA 058A  14        inc  rsp
0002 3DFC D01A  26        movb *rsp,ra
                   < elite.a99
13041 3DFE D800  30        movb ra,@INF                    ; STA INF
     3E00 0020     
13042               
13043 3E02 0201  20        li   rx,(NI.-1)*256             ; LDX #NI%-1        ; Now to restore the INWK workspace that we saved into
     3E04 2300     
13044                                                                          ; XX3 above, so set a counter in X for NI% bytes
13045               
13046               FRL3:
13047 3E06 D021  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Copy the Y-th byte of XX3 to the Y-th byte of INWK
     3E08 0100     
13048 3E0A D840  38        movb ra,@INWK(rx)               ; STA INWK,X
     3E0C 0053     
13049               
13050 3E0E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
13051               
13052 3E10 15FA  14        jgt  FRL3                       ; BPL FRL3          ; Loop back to copy the next byte until we have done
13053                                                                          ; them all
13054               
13055                      .pla                            ; PLA               ; Restore XX0(1 0) from the stack
     **** ****     > PLA
0001 3E12 058A  14        inc  rsp
0002 3E14 D01A  26        movb *rsp,ra
                   < elite.a99
13056 3E16 D800  30        movb ra,@XX0+1                  ; STA XX0+1
     3E18 001F     
13057                      .pla                            ; PLA
     **** ****     > PLA
0001 3E1A 058A  14        inc  rsp
0002 3E1C D01A  26        movb *rsp,ra
                   < elite.a99
13058 3E1E D800  30        movb ra,@XX0                    ; STA XX0
     3E20 001E     
13059               
13060 3E22 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3E24 800E     
13061               
13062               * ******************************************************************************
13063               *
13064               * Name: SFS2
13065               * Type: Subroutine
13066               * Category: Moving
13067               * Summary: Move a ship in space along one of the coordinate axes
13068               *
13069               * ------------------------------------------------------------------------------
13070               *
13071               * Move a ship's coordinates by a certain amount in the direction of one of the
13072               * axes, where X determines the axis. Mathematically speaking, this routine
13073               * translates the ship along a single axis by a signed delta.
13074               *
13075               * ------------------------------------------------------------------------------
13076               *
13077               * Arguments:
13078               *
13079               * A                   The amount of movement, i.e. the signed delta
13080               *
13081               * X                   Determines which coordinate axis of INWK to move:
13082               *
13083               * * X = 0 moves the ship along the x-axis
13084               *
13085               * * X = 3 moves the ship along the y-axis
13086               *
13087               * * X = 6 moves the ship along the z-axis
13088               *
13089               * ******************************************************************************
13090               
13091               SFS2:
13092                      .asla                           ; ASL A             ; Set R = |A * 2|, with the C flag set to bit 7 of A
     **** ****     > ASLA
0001 3E26 0240  22        andi ra,>ff00
     3E28 FF00     
0002 3E2A 0A10  18        sla  ra,1
                   < elite.a99
13093 3E2C D800  30        movb ra,@R                      ; STA R
     3E2E 0091     
13094               
13095 3E30 0200  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 of A to the C flag, i.e. the sign bit from
     3E32 0000     
13096 3E34 06A0  28        bl   @rora                      ; ROR A             ; the original argument in A
     3E36 803C     
13097               
13098 3E38 0460  24        b    @MVT1                      ; JMP MVT1          ; Add the delta R with sign A to (x_lo, x_hi, x_sign)
     3E3A 1BAA     
13099                                                                          ; (or y or z, depending on the value in X) and return
13100                                                                          ; from the subroutine using a tail call
13101               
13102               * ******************************************************************************
13103               *
13104               * Name: LL164
13105               * Type: Subroutine
13106               * Category: Drawing circles
13107               * Summary: Make the hyperspace sound and draw the hyperspace tunnel
13108               *
13109               * ------------------------------------------------------------------------------
13110               *
13111               * See the IRQ1 routine for details on the multi-coloured effect that's used.
13112               *
13113               * ******************************************************************************
13114               
13115               LL164:
13116 3E3C 0200  20        li   ra,>38*256                 ; LDA #56           ; Call the NOISE routine with A = 56 to make the sound
     3E3E 3800     
13117 3E40 0206  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the hyperspace drive being engaged
     3E42 8BA4     
13118 3E44 06A0  28        bl   @jsr                       ;
     3E46 8002     
13119               
13120 3E48 0200  20        li   ra,>01*256                 ; LDA #1            ; Set HFX to 1, which switches the screen mode to a full
     3E4A 0100     
13121 3E4C D800  30        movb ra,@HFX                    ; STA HFX           ; mode 5 screen, therefore making the hyperspace rings
     3E4E 0D62     
13122                                                                          ; multi-coloured and all zig-zaggy (see the IRQ1 routine
13123                                                                          ; for details)
13124               
13125 3E50 0200  20        li   ra,>04*256                 ; LDA #4            ; Set the step size for the hyperspace rings to 4, so
     3E52 0400     
13126                                                                          ; there are more sections in the rings and they are
13127                                                                          ; quite round (compared to the step size of 8 used in
13128                                                                          ; the much more polygonal launch rings)
13129               
13130 3E54 0206  20        li   rtmp,HFS2                  ; JSR HFS2          ; Call HFS2 to draw the hyperspace tunnel rings
     3E56 3E72     
13131 3E58 06A0  28        bl   @jsr                       ;
     3E5A 8002     
13132               
13133 3E5C 7004  18        sb   rone,ra                    ; DEC HFX           ; Set HFX back to 0, so we switch back to the normal
13134                                                                          ; split-screen mode
13135               
13136 3E5E 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3E60 800E     
13137               
13138               * ******************************************************************************
13139               *
13140               * Name: LAUN
13141               * Type: Subroutine
13142               * Category: Drawing circles
13143               * Summary: Make the launch sound and draw the launch tunnel
13144               *
13145               * ------------------------------------------------------------------------------
13146               *
13147               * This is shown when launching from or docking with the space station.
13148               *
13149               * ******************************************************************************
13150               
13151               LAUN:
13152 3E62 0200  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     3E64 3000     
13153 3E66 0206  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the ship launching from the station
     3E68 8BA4     
13154 3E6A 06A0  28        bl   @jsr                       ;
     3E6C 8002     
13155               
13156 3E6E 0200  20        li   ra,>08*256                 ; LDA #8            ; Set the step size for the launch tunnel rings to 8, so
     3E70 0800     
13157                                                                          ; there are fewer sections in the rings and they are
13158                                                                          ; quite polygonal (compared to the step size of 4 used
13159                                                                          ; in the much rounder hyperspace rings)
13160               
13161                                                                          ; Fall through into HFS2 to draw the launch tunnel rings
13162               
13163               * ******************************************************************************
13164               *
13165               * Name: HFS2
13166               * Type: Subroutine
13167               * Category: Drawing circles
13168               * Summary: Draw the launch or hyperspace tunnel
13169               *
13170               * ------------------------------------------------------------------------------
13171               *
13172               * The animation gets drawn like this. First, we draw a circle of radius 8 at the
13173               * centre, and then double the radius, draw another circle, double the radius
13174               * again and draw a circle, and we keep doing this until the radius is bigger
13175               * than 160 (which goes beyond the edge of the screen, which is 256 pixels wide,
13176               * equivalent to a radius of 128). We then repeat this whole process for an
13177               * initial circle of radius 9, then radius 10, all the way up to radius 15.
13178               *
13179               * This has the effect of making the tunnel appear to be racing towards us as we
13180               * hurtle out into hyperspace or through the space station's docking tunnel.
13181               *
13182               * The hyperspace effect is done in a full mode 5 screen, which makes the rings
13183               * all coloured and zig-zaggy, while the launch screen is in the normal
13184               * monochrome mode 4 screen.
13185               *
13186               * ------------------------------------------------------------------------------
13187               *
13188               * Arguments:
13189               *
13190               * A                   The step size of the straight lines making up the rings
13191               * (4 for launch, 8 for hyperspace)
13192               *
13193               * ******************************************************************************
13194               
13195               HFS2:
13196 3E72 D800  30        movb ra,@STP                    ; STA STP           ; Store the step size in A
     3E74 00A6     
13197               
13198 3E76 0206  20        li   rtmp,TTX66                 ; JSR TTX66         ; Clear the screen and draw a white border
     3E78 4B2E     
13199 3E7A 06A0  28        bl   @jsr                       ;
     3E7C 8002     
13200               
13201 3E7E 0206  20        li   rtmp,HFS1                  ; JSR HFS1          ; Call HFS1 below and then fall through into the same
     3E80 3E86     
13202 3E82 06A0  28        bl   @jsr                       ;
     3E84 8002     
13203                                                                          ; routine, so this effectively runs HFS1 twice, and as
13204                                                                          ; HFS1 draws 8 concentric rings, this means we draw 16
13205                                                                          ; of them in all
13206               
13207               HFS1:
13208 3E86 0200  20        li   ra,>80*256                 ; LDA #128          ; Set K3 = 128 (the x-coordinate of the centre of the
     3E88 8000     
13209 3E8A D800  30        movb ra,@K3                     ; STA K3            ; screen)
     3E8C 00D2     
13210               
13211 3E8E 0201  20        li   rx,(Y)*256                 ; LDX #Y            ; Set K4 = #Y (the y-coordinate of the centre of the
     3E90 6000     
13212 3E92 D801  30        movb rx,@K4                     ; STX K4            ; screen)
     3E94 00E0     
13213               
13214                      .asla                           ; ASL A             ; Set A = 0
     **** ****     > ASLA
0001 3E96 0240  22        andi ra,>ff00
     3E98 FF00     
0002 3E9A 0A10  18        sla  ra,1
                   < elite.a99
13215               
13216 3E9C D800  30        movb ra,@XX4                    ; STA XX4           ; Set XX4 = 0, which we will use as a counter for
     3E9E 00A7     
13217                                                                          ; drawing eight concentric rings
13218               
13219 3EA0 D800  30        movb ra,@K3+1                   ; STA K3+1          ; Set the high bytes of K3(1 0) and K4(1 0) to 0
     3EA2 00D3     
13220 3EA4 D800  30        movb ra,@K4+1                   ; STA K4+1
     3EA6 00E1     
13221               
13222               HFL5:
13223 3EA8 0206  20        li   rtmp,HFL1                  ; JSR HFL1          ; Call HFL1 below to draw a set of rings, with each one
     3EAA 3EC0     
13224 3EAC 06A0  28        bl   @jsr                       ;
     3EAE 8002     
13225                                                                          ; twice the radius of the previous one, until they won't
13226                                                                          ; fit on-screen
13227               
13228 3EB0 B004  18        ab   rone,ra                    ; INC XX4           ; Increment the counter and fetch it into X
13229 3EB2 D060  30        movb @XX4,rx                    ; LDX XX4
     3EB4 00A7     
13230               
13231 3EB6 0281  22        ci   rx,>08*256                 ; CPX #8            ; If we haven't drawn 8 sets of rings yet, loop back to
     3EB8 0800     
13232 3EBA 16F6  14        jne  HFL5                       ; BNE HFL5          ; HFL5 to draw the next ring
13233               
13234 3EBC 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3EBE 800E     
13235               
13236               HFL1:
13237 3EC0 D020  30        movb @XX4,ra                    ; LDA XX4           ; Set K to the ring number in XX4 (0-7) + 8, so K has
     3EC2 00A7     
13238 3EC4 0240  22        andi ra,>07*256                 ; AND #7            ; a value of 8 to 15, which we will use as the starting
     3EC6 0700     
13239                      .clc                            ; CLC               ; radius for our next set of rings
     **** ****     > CLC
0001 3EC8 0A13  18        sla  rzero,1
                   < elite.a99
13240                      .adi (>08*256)                  ; ADC #8
     **** ****     > ADI
0001 3ECA 1701  14        jnc  !
0002 3ECC B004  18        ab   rone,ra
0003               !:
0004 3ECE 0220  22        ai   ra,(>08*256)
     3ED0 0800     
                   < elite.a99
13241 3ED2 D800  30        movb ra,@K                      ; STA K
     3ED4 003D     
13242               
13243               HFL2:
13244 3ED6 0200  20        li   ra,>01*256                 ; LDA #1            ; Set LSP = 1 to reset the ball line heap
     3ED8 0100     
13245 3EDA D800  30        movb ra,@LSP                    ; STA LSP
     3EDC 0077     
13246               
13247 3EDE 0206  20        li   rtmp,CIRCLE2               ; JSR CIRCLE2       ; Call CIRCLE2 to draw a circle with the centre at
     3EE0 7820     
13248 3EE2 06A0  28        bl   @jsr                       ;
     3EE4 8002     
13249                                                                          ; (K3(1 0), K4(1 0)) and radius K
13250               
13251                      .asl @K                         ; ASL K             ; Double the radius in K
     **** ****     > ASL
0001 3EE6 D1A0  30        movb @K,rtmp
     3EE8 003D     
0002 3EEA 0246  22        andi rtmp,>ff00
     3EEC FF00     
0003 3EEE 0A16  18        sla  rtmp,1
0004 3EF0 D806  30        movb rtmp,@K
     3EF2 003D     
                   < elite.a99
13252               
13253 3EF4 1805  14        joc  HF8                        ; BCS HF8           ; If the radius had a 1 in bit 7 before the above shift,
13254                                                                          ; then doubling K will means the circle will no longer
13255                                                                          ; fit on the screen (which is width 256), so jump to
13256                                                                          ; HF8 to stop drawing circles
13257               
13258 3EF6 D020  30        movb @K,ra                      ; LDA K             ; If the radius in K <= 160, loop back to HFL2 to draw
     3EF8 003D     
13259 3EFA 0280  22        ci   ra,>a0*256                 ; CMP #160          ; another one
     3EFC A000     
13260 3EFE 17EB  14        jnc  HFL2                       ; BCC HFL2
13261               
13262               HF8:
13263 3F00 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     3F02 800E     
13264               
13265               * ******************************************************************************
13266               *
13267               * Name: STARS2
13268               * Type: Subroutine
13269               * Category: Stardust
13270               * Summary: Process the stardust for the left or right view
13271               * Deep dive: Stardust in the side views
13272               *
13273               * ------------------------------------------------------------------------------
13274               *
13275               * This moves the stardust sideways according to our speed and which side we are
13276               * looking out of, and applies our current pitch and roll to each particle of
13277               * dust, so the stardust moves correctly when we steer our ship.
13278               *
13279               * These are the calculations referred to in the commentary:
13280               *
13281               * 1. delta_x = 8 * 256 * speed / z_hi
13282               * 2. x = x + delta_x
13283               *
13284               * 3. x = x + beta * y
13285               * 4. y = y - beta * x
13286               *
13287               * 5. x = x - alpha * x * y
13288               * 6. y = y + alpha * y * y + alpha
13289               *
13290               * For more information see the deep dive on "Stardust in the side views".
13291               *
13292               * ------------------------------------------------------------------------------
13293               *
13294               * Arguments:
13295               *
13296               * X                   The view to process:
13297               *
13298               * * X = 1 for left view
13299               *
13300               * * X = 2 for right view
13301               *
13302               * ******************************************************************************
13303               
13304               STARS2:
13305 3F04 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can use it to capture a sign bit
     3F06 0000     
13306               
13307 3F08 0281  22        ci   rx,>02*256                 ; CPX #2            ; If X >= 2 then the C flag is set
     3F0A 0200     
13308               
13309 3F0C 06A0  28        bl   @rora                      ; ROR A             ; Roll the C flag into the sign bit of A and store in
     3F0E 803C     
13310 3F10 D800  30        movb ra,@RAT                    ; STA RAT           ; RAT, so:
     3F12 00AA     
13311                                                                          ;
13312                                                                          ; * Left view, C is clear so RAT = 0 (positive)
13313                                                                          ;
13314                                                                          ; * Right view, C is set so RAT = 128 (negative)
13315                                                                          ;
13316                                                                          ; RAT represents the end of the x-axis where we want new
13317                                                                          ; stardust particles to come from: positive for the left
13318                                                                          ; view where new particles come in from the right,
13319                                                                          ; negative for the right view where new particles come
13320                                                                          ; in from the left
13321               
13322                      .eoi (>80*256)                  ; EOR #%10000000    ; Set RAT2 to the opposite sign, so:
     **** ****     > EOI
0001 3F14 0206  20        li   rtmp,(>80*256)
     3F16 8000     
0002 3F18 2806  18        xor  rtmp,ra
                   < elite.a99
13323 3F1A D800  30        movb ra,@RAT2                   ; STA RAT2          ;
     3F1C 00AB     
13324                                                                          ; * Left view, RAT2 = 128 (negative)
13325                                                                          ;
13326                                                                          ; * Right view, RAT2 = 0 (positive)
13327                                                                          ;
13328                                                                          ; RAT2 represents the direction in which stardust
13329                                                                          ; particles should move along the x-axis: negative for
13330                                                                          ; the left view where particles go from right to left,
13331                                                                          ; positive for the right view where particles go from
13332                                                                          ; left to right
13333               
13334 3F1E 0206  20        li   rtmp,ST2                   ; JSR ST2           ; Call ST2 to flip the signs of the following if this is
     3F20 4078     
13335 3F22 06A0  28        bl   @jsr                       ;
     3F24 8002     
13336                                                                          ; the right view: ALPHA, ALP2, ALP2+1, BET2 and BET2+1
13337               
13338 3F26 D0A0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     3F28 0F33     
13339                                                                          ; we can use it as a counter through all the stardust
13340               
13341               STL2:
13342 3F2A D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Set A = ZZ = z_hi
     3F2C 0EE8     
13343               
13344 3F2E D800  30        movb ra,@ZZ                     ; STA ZZ            ; We also set ZZ to the original value of z_hi, which we
     3F30 0097     
13345                                                                          ; use below to remove the existing particle
13346               
13347 3F32 0910  18        srl  ra,1                       ; LSR A             ; Set A = z_hi / 8
13348 3F34 0910  18        srl  ra,1                       ; LSR A
13349 3F36 0910  18        srl  ra,1                       ; LSR A
13350               
13351 3F38 0206  20        li   rtmp,DV41                  ; JSR DV41          ; Call DV41 to set the following:
     3F3A 45A8     
13352 3F3C 06A0  28        bl   @jsr                       ;
     3F3E 8002     
13353                                                                          ;
13354                                                                          ; (P R) = 256 * DELTA / A
13355                                                                          ; = 256 * speed / (z_hi / 8)
13356                                                                          ; = 8 * 256 * speed / z_hi
13357                                                                          ;
13358                                                                          ; This represents the distance we should move this
13359                                                                          ; particle along the x-axis, let's call it delta_x
13360               
13361 3F40 D020  30        movb @P,ra                      ; LDA P             ; Set S = P but with the sign from RAT2, so we now have
     3F42 001B     
13362                      .eor @RAT2                      ; EOR RAT2          ; the distance delta_x with the correct sign in (S R):
     **** ****     > EOR
0001 3F44 D1A0  30        movb @RAT2,rtmp
     3F46 00AB     
0002 3F48 2806  18        xor  rtmp,ra
                   < elite.a99
13363 3F4A D800  30        movb ra,@S                      ; STA S             ;
     3F4C 0092     
13364                                                                          ; (S R) = delta_x
13365                                                                          ; = 8 * 256 * speed / z_hi
13366                                                                          ;
13367                                                                          ; So (S R) is the delta, signed to match the direction
13368                                                                          ; the stardust should move in, which is result 1 above
13369               
13370 3F4E D022  34        movb @SXL(ry),ra                ; LDA SXL,Y         ; Set (A P) = (x_hi x_lo)
     3F50 035F     
13371 3F52 D800  30        movb ra,@P                      ; STA P             ; = x
     3F54 001B     
13372 3F56 D022  34        movb @SX(ry),ra                 ; LDA SX,Y
     3F58 034C     
13373               
13374 3F5A D800  30        movb ra,@X1                     ; STA X1            ; Set X1 = A, so X1 contains the original value of x_hi,
     3F5C 0031     
13375                                                                          ; which we use below to remove the existing particle
13376               
13377 3F5E 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     3F60 44BA     
13378 3F62 06A0  28        bl   @jsr                       ;
     3F64 8002     
13379                                                                          ;
13380                                                                          ; (A X) = (A P) + (S R)
13381                                                                          ; = x + delta_x
13382               
13383 3F66 D800  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     3F68 0092     
13384 3F6A D801  30        movb rx,@R                      ; STX R             ; = x + delta_x
     3F6C 0091     
13385               
13386 3F6E D022  34        movb @SY(ry),ra                 ; LDA SY,Y          ; Set A = y_hi
     3F70 0EC2     
13387               
13388 3F72 D800  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 = A, so Y1 contains the original value of y_hi,
     3F74 0032     
13389                                                                          ; which we use below to remove the existing particle
13390               
13391                      .eor @BET2                      ; EOR BET2          ; Give A the correct sign of A * beta, i.e. y_hi * beta
     **** ****     > EOR
0001 3F76 D1A0  30        movb @BET2,rtmp
     3F78 008A     
0002 3F7A 2806  18        xor  rtmp,ra
                   < elite.a99
13392               
13393 3F7C D060  30        movb @BET1,rx                   ; LDX BET1          ; Fetch |beta| from BET1, the pitch angle
     3F7E 002B     
13394               
13395 3F80 0206  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     3F82 41F4     
13396 3F84 06A0  28        bl   @jsr                       ;
     3F86 8002     
13397                                                                          ;
13398                                                                          ; (A P) = X * A
13399                                                                          ; = beta * y_hi
13400               
13401 3F88 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     3F8A 44BA     
13402 3F8C 06A0  28        bl   @jsr                       ;
     3F8E 8002     
13403                                                                          ;
13404                                                                          ; (A X) = (A P) + (S R)
13405                                                                          ; = beta * y + x + delta_x
13406               
13407 3F90 D801  30        movb rx,@XX                     ; STX XX            ; Set XX(1 0) = (A X), which gives us results 2 and 3
     3F92 0024     
13408 3F94 D800  30        movb ra,@XX+1                   ; STA XX+1          ; above, done at the same time:
     3F96 0025     
13409                                                                          ;
13410                                                                          ; x = x + delta_x + beta * y
13411               
13412 3F98 D062  34        movb @SYL(ry),rx                ; LDX SYL,Y         ; Set (S R) = (y_hi y_lo)
     3F9A 0ED5     
13413 3F9C D801  30        movb rx,@R                      ; STX R             ; = y
     3F9E 0091     
13414 3FA0 D060  30        movb @Y1,rx                     ; LDX Y1
     3FA2 0032     
13415 3FA4 D801  30        movb rx,@S                      ; STX S
     3FA6 0092     
13416               
13417 3FA8 D060  30        movb @BET1,rx                   ; LDX BET1          ; Fetch |beta| from BET1, the pitch angle
     3FAA 002B     
13418               
13419                      .eor @BET2+1                    ; EOR BET2+1        ; Give A the opposite sign to x * beta
     **** ****     > EOR
0001 3FAC D1A0  30        movb @BET2+1,rtmp
     3FAE 008B     
0002 3FB0 2806  18        xor  rtmp,ra
                   < elite.a99
13420               
13421 3FB2 0206  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     3FB4 41F4     
13422 3FB6 06A0  28        bl   @jsr                       ;
     3FB8 8002     
13423                                                                          ;
13424                                                                          ; (A P) = X * A
13425                                                                          ; = -beta * x
13426               
13427 3FBA 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     3FBC 44BA     
13428 3FBE 06A0  28        bl   @jsr                       ;
     3FC0 8002     
13429                                                                          ;
13430                                                                          ; (A X) = (A P) + (S R)
13431                                                                          ; = -beta * x + y
13432               
13433 3FC2 D801  30        movb rx,@YY                     ; STX YY            ; Set YY(1 0) = (A X), which gives us result 4 above:
     3FC4 0026     
13434 3FC6 D800  30        movb ra,@YY+1                   ; STA YY+1          ;
     3FC8 0027     
13435                                                                          ; y = y - beta * x
13436               
13437 3FCA D060  30        movb @ALP1,rx                   ; LDX ALP1          ; Set X = |alpha| from ALP2, the roll angle
     3FCC 0087     
13438               
13439                      .eor @ALP2                      ; EOR ALP2          ; Give A the correct sign of A * alpha, i.e. y_hi *
     **** ****     > EOR
0001 3FCE D1A0  30        movb @ALP2,rtmp
     3FD0 0088     
0002 3FD2 2806  18        xor  rtmp,ra
                   < elite.a99
13440                                                                          ; alpha
13441               
13442 3FD4 0206  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     3FD6 41F4     
13443 3FD8 06A0  28        bl   @jsr                       ;
     3FDA 8002     
13444                                                                          ;
13445                                                                          ; (A P) = X * A
13446                                                                          ; = alpha * y
13447               
13448 3FDC D800  30        movb ra,@Q                      ; STA Q             ; Set Q = high byte of alpha * y
     3FDE 0090     
13449               
13450 3FE0 D020  30        movb @XX,ra                     ; LDA XX            ; Set (S R) = XX(1 0)
     3FE2 0024     
13451 3FE4 D800  30        movb ra,@R                      ; STA R             ; = x
     3FE6 0091     
13452 3FE8 D020  30        movb @XX+1,ra                   ; LDA XX+1          ;
     3FEA 0025     
13453 3FEC D800  30        movb ra,@S                      ; STA S             ; and set A = y_hi at the same time
     3FEE 0092     
13454               
13455                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A = -x_hi
     **** ****     > EOI
0001 3FF0 0206  20        li   rtmp,(>80*256)
     3FF2 8000     
0002 3FF4 2806  18        xor  rtmp,ra
                   < elite.a99
13456               
13457 3FF6 0206  20        li   rtmp,MAD                   ; JSR MAD           ; Call MAD to calculate:
     3FF8 44B2     
13458 3FFA 06A0  28        bl   @jsr                       ;
     3FFC 8002     
13459                                                                          ;
13460                                                                          ; (A X) = Q * A + (S R)
13461                                                                          ; = alpha * y * -x + x
13462               
13463 3FFE D800  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     4000 0025     
13464               
13465 4002 D001  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
13466 4004 D880  38        movb ra,@SXL(ry)                ; STA SXL,Y
     4006 035F     
13467               
13468                                                                          ; So (XX+1 x_lo) now contains result 5 above:
13469                                                                          ;
13470                                                                          ; x = x - alpha * x * y
13471               
13472 4008 D020  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0)
     400A 0026     
13473 400C D800  30        movb ra,@R                      ; STA R             ; = y
     400E 0091     
13474 4010 D020  30        movb @YY+1,ra                   ; LDA YY+1          ;
     4012 0027     
13475 4014 D800  30        movb ra,@S                      ; STA S             ; and set A = y_hi at the same time
     4016 0092     
13476               
13477 4018 0206  20        li   rtmp,MAD                   ; JSR MAD           ; Call MAD to calculate:
     401A 44B2     
13478 401C 06A0  28        bl   @jsr                       ;
     401E 8002     
13479                                                                          ;
13480                                                                          ; (A X) = Q * A + (S R)
13481                                                                          ; = alpha * y * y_hi + y
13482               
13483 4020 D800  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     4022 0092     
13484 4024 D801  30        movb rx,@R                      ; STX R             ; = y + alpha * y * y
     4026 0091     
13485               
13486 4028 0200  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     402A 0000     
13487 402C D800  30        movb ra,@P                      ; STA P
     402E 001B     
13488               
13489 4030 D020  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set A = alpha, so:
     4032 009E     
13490                                                                          ;
13491                                                                          ; (A P) = (alpha 0)
13492                                                                          ; = alpha / 256
13493               
13494 4034 0206  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     4036 275A     
13495 4038 06A0  28        bl   @jsr                       ;
     403A 8002     
13496                                                                          ;
13497                                                                          ; (YY+1 y_lo) = (A P) + (S R)
13498                                                                          ; = alpha * 256 + y + alpha * y * y
13499                                                                          ;
13500                                                                          ; i.e. y = y + alpha / 256 + alpha * y^2, which is
13501                                                                          ; result 6 above
13502                                                                          ;
13503                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
13504                                                                          ; ZZ, which will remove the old stardust particle, as we
13505                                                                          ; set X1, Y1 and ZZ to the original values for this
13506                                                                          ; particle during the calculations above
13507               
13508                                                                          ; We now have our newly moved stardust particle at
13509                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
13510                                                                          ; and distance z_hi, so we draw it if it's still on
13511                                                                          ; screen, otherwise we recycle it as a new bit of
13512                                                                          ; stardust and draw that
13513               
13514 403C D020  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     403E 0025     
13515 4040 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; the new x-coordinate is in (x_hi x_lo) and the high
     4042 034C     
13516 4044 D800  30        movb ra,@X1                     ; STA X1            ; byte is in X1
     4046 0031     
13517               
13518 4048 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; If |x_hi| >= 116 then jump to KILL2 to recycle this
     404A 7F00     
13519 404C 0280  22        ci   ra,>74*256                 ; CMP #116          ; particle, as it's gone off the side of the screen,
     404E 7400     
13520 4050 1834  14        joc  KILL2                      ; BCS KILL2         ; and rejoin at STC2 with the new particle
13521               
13522 4052 D020  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     4054 0027     
13523 4056 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     4058 0EC2     
13524 405A D800  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     405C 0032     
13525               
13526 405E 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 116 then jump to ST5 to recycle this
     4060 7F00     
13527 4062 0280  22        ci   ra,>74*256                 ; CMP #116          ; particle, as it's gone off the top or bottom of the
     4064 7400     
13528 4066 183A  14        joc  ST5                        ; BCS ST5           ; screen, and rejoin at STC2 with the new particle
13529               
13530               STC2:
13531 4068 0206  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     406A 276C     
13532 406C 06A0  28        bl   @jsr                       ;
     406E 8002     
13533                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
13534                                                                          ; with distance z_hi
13535               
13536 4070 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
13537                                                                          ; stardust particle
13538               
13539 4072 1302  14        jeq  ST2                        ; BEQ ST2           ; If we have just done the last particle, skip the next
13540                                                                          ; instruction to return from the subroutine
13541               
13542 4074 0460  28        b    @STL2                      ; JMP STL2          ; We have more stardust to process, so jump back up to
     4076 3F2A     
13543                                                                          ; STL2 for the next particle
13544               
13545                                                                          ; Fall through into ST2 to restore the signs of the
13546                                                                          ; following if this is the right view: ALPHA, ALP2,
13547                                                                          ; ALP2+1, BET2 and BET2+1
13548               
13549               ST2:
13550 4078 D020  30        movb @ALPHA,ra                  ; LDA ALPHA         ; If this is the right view, flip the sign of ALPHA
     407A 009E     
13551                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 407C D1A0  30        movb @RAT,rtmp
     407E 00AA     
0002 4080 2806  18        xor  rtmp,ra
                   < elite.a99
13552 4082 D800  30        movb ra,@ALPHA                  ; STA ALPHA
     4084 009E     
13553               
13554 4086 D020  30        movb @ALP2,ra                   ; LDA ALP2          ; If this is the right view, flip the sign of ALP2
     4088 0088     
13555                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 408A D1A0  30        movb @RAT,rtmp
     408C 00AA     
0002 408E 2806  18        xor  rtmp,ra
                   < elite.a99
13556 4090 D800  30        movb ra,@ALP2                   ; STA ALP2
     4092 0088     
13557               
13558                      .eoi (>80*256)                  ; EOR #%10000000    ; If this is the right view, flip the sign of ALP2+1
     **** ****     > EOI
0001 4094 0206  20        li   rtmp,(>80*256)
     4096 8000     
0002 4098 2806  18        xor  rtmp,ra
                   < elite.a99
13559 409A D800  30        movb ra,@ALP2+1                 ; STA ALP2+1
     409C 0089     
13560               
13561 409E D020  30        movb @BET2,ra                   ; LDA BET2          ; If this is the right view, flip the sign of BET2
     40A0 008A     
13562                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 40A2 D1A0  30        movb @RAT,rtmp
     40A4 00AA     
0002 40A6 2806  18        xor  rtmp,ra
                   < elite.a99
13563 40A8 D800  30        movb ra,@BET2                   ; STA BET2
     40AA 008A     
13564               
13565                      .eoi (>80*256)                  ; EOR #%10000000    ; If this is the right view, flip the sign of BET2+1
     **** ****     > EOI
0001 40AC 0206  20        li   rtmp,(>80*256)
     40AE 8000     
0002 40B0 2806  18        xor  rtmp,ra
                   < elite.a99
13566 40B2 D800  30        movb ra,@BET2+1                 ; STA BET2+1
     40B4 008B     
13567               
13568 40B6 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     40B8 800E     
13569               
13570               KILL2:
13571 40BA 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     40BC 8070     
13572 40BE 06A0  28        bl   @jsr                       ;
     40C0 8002     
13573               
13574 40C2 D800  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to random numbers, so the particle
     40C4 0032     
13575 40C6 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; starts anywhere along the y-axis
     40C8 0EC2     
13576               
13577 40CA 0200  20        li   ra,>73*256                 ; LDA #115          ; Make sure A is at least 115 and has the sign in RAT
     40CC 7300     
13578 40CE F020  30        socb @RAT,ra                    ; ORA RAT
     40D0 00AA     
13579               
13580 40D2 D800  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to A, so this particle starts on the
     40D4 0031     
13581 40D6 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; correct edge of the screen for new particles
     40D8 034C     
13582               
13583 40DA 1610  14        jne  STF1                       ; BNE STF1          ; Jump down to STF1 to set the z-coordinate (this BNE is
13584                                                                          ; effectively a JMP as A will never be zero)
13585               
13586               ST5:
13587 40DC 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     40DE 8070     
13588 40E0 06A0  28        bl   @jsr                       ;
     40E2 8002     
13589               
13590 40E4 D800  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to random numbers, so the particle
     40E6 0031     
13591 40E8 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; starts anywhere along the x-axis
     40EA 034C     
13592               
13593 40EC 0200  20        li   ra,>6e*256                 ; LDA #110          ; Make sure A is at least 110 and has the sign in AL2+1,
     40EE 6E00     
13594 40F0 F020  30        socb @ALP2+1,ra                 ; ORA ALP2+1        ; the flipped sign of the roll angle alpha
     40F2 0089     
13595               
13596 40F4 D800  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to A, so the particle starts at the
     40F6 0032     
13597 40F8 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; top or bottom edge, depending on the current roll
     40FA 0EC2     
13598                                                                          ; angle alpha
13599               
13600               STF1:
13601 40FC 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     40FE 8070     
13602 4100 06A0  28        bl   @jsr                       ;
     4102 8002     
13603               
13604 4104 0260  22        ori  ra,>08*256                 ; ORA #8            ; Make sure A is at least 8 and store it in z_hi and
     4106 0800     
13605 4108 D800  30        movb ra,@ZZ                     ; STA ZZ            ; ZZ, so the new particle starts at any distance from
     410A 0097     
13606 410C D880  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; us, but not too close
     410E 0EE8     
13607               
13608 4110 16AB  14        jne  STC2                       ; BNE STC2          ; Jump up to STC2 to draw this new particle (this BNE is
13609                                                                          ; effectively a JMP as A will never be zero)
13610               
13611               * ******************************************************************************
13612               *
13613               * Name: SNE
13614               * Type: Variable
13615               * Category: Maths (Geometry)
13616               * Summary: Sine/cosine table
13617               * Deep dive: The sine, cosine and arctan tables
13618               * Drawing circles
13619               * Drawing ellipses
13620               *
13621               * ------------------------------------------------------------------------------
13622               *
13623               * This lookup table contains sine values for the first half of a circle, from 0
13624               * to 180 degrees (0 to PI radians). In terms of circle or ellipse line segments,
13625               * there are 64 segments in a circle, so this contains sine values for segments
13626               * 0 to 31.
13627               *
13628               * In terms of segments, to calculate the sine of the angle at segment x, we look
13629               * up the value in SNE + x, and to calculate the cosine of the angle we look up
13630               * the value in SNE + ((x + 16) mod 32).
13631               *
13632               * In terms of radians, to calculate the following:
13633               *
13634               * sin(theta) * 256
13635               *
13636               * where theta is in radians, we look up the value in:
13637               *
13638               * SNE + (theta * 10)
13639               *
13640               * To calculate the following:
13641               *
13642               * cos(theta) * 256
13643               *
13644               * where theta is in radians, look up the value in:
13645               *
13646               * SNE + ((theta * 10) + 16) mod 32
13647               *
13648               * Theta must be between 0 and 3.1 radians, so theta * 10 is between 0 and 31.
13649               *
13650               * ******************************************************************************
13651               
13652               SNE:
13653                      ; FOR I%, 0, 31
13654               
13655                      ; N = ABS(SIN((I% / 64) * 2 * PI)) ;
13656               
13657                      ; IF N >= 1                     ;
13658                      ; B% = 255                      ;
13659                      ; ELSE                          ;
13660                      ; B% = INT(256 * N + 0.5)       ;
13661                      ; ENDIF                         ;
13662               
13663                      ; EQUB B%                       ;
13664               
13665                      ; NEXT
13666               
13667 4112 00              byte >00
13668 4113   19            byte >19
13669 4114 32              byte >32
13670 4115   4A            byte >4a
13671 4116 62              byte >62
13672 4117   79            byte >79
13673 4118 8E              byte >8e
13674 4119   A2            byte >a2
13675 411A B5              byte >b5
13676 411B   C6            byte >c6
13677 411C D5              byte >d5
13678 411D   E2            byte >e2
13679 411E ED              byte >ed
13680 411F   F5            byte >f5
13681 4120 FB              byte >fb
13682 4121   FF            byte >ff
13683 4122 FF              byte >ff
13684 4123   FF            byte >ff
13685 4124 FB              byte >fb
13686 4125   F5            byte >f5
13687 4126 ED              byte >ed
13688 4127   E2            byte >e2
13689 4128 D5              byte >d5
13690 4129   C6            byte >c6
13691 412A B5              byte >b5
13692 412B   A2            byte >a2
13693 412C 8E              byte >8e
13694 412D   79            byte >79
13695 412E 62              byte >62
13696 412F   4A            byte >4a
13697 4130 32              byte >32
13698 4131   19            byte >19
13699               
13700               * ******************************************************************************
13701               *
13702               * Name: MU5
13703               * Type: Subroutine
13704               * Category: Maths (Arithmetic)
13705               * Summary: Set K(3 2 1 0) = (A A A A) and clear the C flag
13706               *
13707               * ------------------------------------------------------------------------------
13708               *
13709               * In practice this is only called via a BEQ following an AND instruction, in
13710               * which case A = 0, so this routine effectively does this:
13711               *
13712               * K(3 2 1 0) = 0
13713               *
13714               * ******************************************************************************
13715               
13716               MU5:
13717 4132 D800  30        movb ra,@K                      ; STA K             ; Set K(3 2 1 0) to (A A A A)
     4134 003D     
13718 4136 D800  30        movb ra,@K+1                    ; STA K+1
     4138 003E     
13719 413A D800  30        movb ra,@K+2                    ; STA K+2
     413C 003F     
13720 413E D800  30        movb ra,@K+3                    ; STA K+3
     4140 0040     
13721               
13722                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 4142 0A13  18        sla  rzero,1
                   < elite.a99
13723               
13724 4144 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4146 800E     
13725               
13726               * ******************************************************************************
13727               *
13728               * Name: MULT3
13729               * Type: Subroutine
13730               * Category: Maths (Arithmetic)
13731               * Summary: Calculate K(3 2 1 0) = (A P+1 P) * Q
13732               * Deep dive: Shift-and-add multiplication
13733               *
13734               * ------------------------------------------------------------------------------
13735               *
13736               * Calculate the following multiplication between a signed 24-bit number and a
13737               * signed 8-bit number, returning the result as a signed 32-bit number:
13738               *
13739               * K(3 2 1 0) = (A P+1 P) * Q
13740               *
13741               * The algorithm is the same shift-and-add algorithm as in routine MULT1, but
13742               * extended to cope with more bits.
13743               *
13744               * ------------------------------------------------------------------------------
13745               *
13746               * Returns:
13747               *
13748               * C flag              The C flag is cleared
13749               *
13750               * ******************************************************************************
13751               
13752               MULT3:
13753 4148 D800  30        movb ra,@R                      ; STA R             ; Store the high byte of (A P+1 P) in R
     414A 0091     
13754               
13755 414C 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Set K+2 to |A|, the high byte of K(2 1 0)
     414E 7F00     
13756 4150 D800  30        movb ra,@K+2                    ; STA K+2
     4152 003F     
13757               
13758 4154 D020  30        movb @Q,ra                      ; LDA Q             ; Set A to bits 0-6 of Q, so A = |Q|
     4156 0090     
13759 4158 0240  22        andi ra,>7f*256                 ; AND #%01111111
     415A 7F00     
13760               
13761 415C 13EA  14        jeq  MU5                        ; BEQ MU5           ; If |Q| = 0, jump to MU5 to set K(3 2 1 0) to 0,
13762                                                                          ; returning from the subroutine using a tail call
13763               
13764                      .sec                            ; SEC               ; Set T = |Q| - 1
     **** ****     > SEC
0001 415E 0A15  18        sla  rmone,1
                   < elite.a99
13765                      .sbi (>01*256)                  ; SBC #1
     **** ****     > SBI
0001 4160 1801  14        joc  !
0002 4162 7004  18        sb   rone,ra
0003               !:
0004 4164 0220  22        ai   ra,-(>01*256)
     4166 FF00     
                   < elite.a99
13766 4168 D800  30        movb ra,@T                      ; STA T
     416A 00D1     
13767               
13768                                                                          ; We now use the same shift-and-add algorithm as MULT1
13769                                                                          ; to calculate the following:
13770                                                                          ;
13771                                                                          ; K(2 1 0) = K(2 1 0) * |Q|
13772                                                                          ;
13773                                                                          ; so we start with the first shift right, in which we
13774                                                                          ; take (K+2 P+1 P) and shift it right, storing the
13775                                                                          ; result in K(2 1 0), ready for the multiplication loop
13776                                                                          ; (so the multiplication loop actually calculates
13777                                                                          ; (|A| P+1 P) * |Q|, as the following sets K(2 1 0) to
13778                                                                          ; (|A| P+1 P) shifted right)
13779               
13780 416C D020  30        movb @P+1,ra                    ; LDA P+1           ; Set A = P+1
     416E 001C     
13781               
13782                      .lsr @K+2                       ; LSR K+2           ; Shift the high byte in K+2 to the right
     **** ****     > LSR
0001 4170 D1A0  30        movb @K+2,rtmp
     4172 003F     
0002 4174 0916  18        srl  rtmp,1
0003 4176 D806  30        movb rtmp,@K+2
     4178 003F     
                   < elite.a99
13783               
13784 417A 06A0  28        bl   @rora                      ; ROR A             ; Shift the middle byte in A to the right and store in
     417C 803C     
13785 417E D800  30        movb ra,@K+1                    ; STA K+1           ; K+1 (so K+1 contains P+1 shifted right)
     4180 003E     
13786               
13787 4182 D020  30        movb @P,ra                      ; LDA P             ; Shift the middle byte in P to the right and store in
     4184 001B     
13788 4186 06A0  28        bl   @rora                      ; ROR A             ; K, so K(2 1 0) now contains (|A| P+1 P) shifted right
     4188 803C     
13789 418A D800  30        movb ra,@K                      ; STA K
     418C 003D     
13790               
13791                                                                          ; We now use the same shift-and-add algorithm as MULT1
13792                                                                          ; to calculate the following:
13793                                                                          ;
13794                                                                          ; K(2 1 0) = K(2 1 0) * |Q|
13795               
13796 418E 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4190 0000     
13797               
13798 4192 0201  20        li   rx,>18*256                 ; LDX #24           ; Set up a counter in X to count the 24 bits in K(2 1 0)
     4194 1800     
13799               
13800               MUL2:
13801 4196 1704  14        jnc  B38                        ; BCC B38           ; If C (i.e. the next bit from K) is set, do the
13802                      .adc @T,ra                      ; ADC T             ; addition for this bit of K:
     **** ****     > ADC
0001 4198 1701  14        jnc  !
0002 419A B004  18        ab   rone,ra
0003               !:
0004 419C B020  30        ab   @T,ra
     419E 00D1     
                   < elite.a99
13803                                                                          ;
13804                                                                          ; A = A + T + C
13805                                                                          ; = A + |Q| - 1 + 1
13806                                                                          ; = A + |Q|
13807               
13808               B38:
13809 41A0 06A0  28        bl   @rora                      ; ROR A             ; Shift A right by one place to catch the next digit
     41A2 803C     
13810 41A4 0208  20        li   rarg1,K+2                  ; ROR K+2           ; next digit of our result in the left end of K(2 1 0),
     41A6 003F     
13811 41A8 06A0  28        bl   @ror                       ;
     41AA 8054     
13812 41AC 0208  20        li   rarg1,K+1                  ; ROR K+1           ; while also shifting K(2 1 0) right to fetch the next
     41AE 003E     
13813 41B0 06A0  28        bl   @ror                       ;
     41B2 8054     
13814 41B4 0208  20        li   rarg1,K                    ; ROR K             ; bit for the calculation into the C flag
     41B6 003D     
13815 41B8 06A0  28        bl   @ror                       ;
     41BA 8054     
13816                                                                          ;
13817                                                                          ; On the last iteration of this loop, the bit falling
13818                                                                          ; off the end of K will be bit 0 of the original A, as
13819                                                                          ; we did one shift before the loop and we are doing 24
13820                                                                          ; iterations. We set A to 0 before looping, so this
13821                                                                          ; means the loop exits with the C flag clear
13822               
13823 41BC 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
13824               
13825 41BE 16EB  14        jne  MUL2                       ; BNE MUL2          ; Loop back for the next bit until K(2 1 0) has been
13826                                                                          ; rotated all the way
13827               
13828                                                                          ; The result (|A| P+1 P) * |Q| is now in (A K+2 K+1 K),
13829                                                                          ; but it is positive and doesn't have the correct sign
13830                                                                          ; of the final result yet
13831               
13832 41C0 D800  30        movb ra,@T                      ; STA T             ; Save the high byte of the result into T
     41C2 00D1     
13833               
13834 41C4 D020  30        movb @R,ra                      ; LDA R             ; Fetch the sign byte from the original (A P+1 P)
     41C6 0091     
13835                                                                          ; argument that we stored in R
13836               
13837                      .eor @Q                         ; EOR Q             ; EOR with Q so the sign bit is the same as that of
     **** ****     > EOR
0001 41C8 D1A0  30        movb @Q,rtmp
     41CA 0090     
0002 41CC 2806  18        xor  rtmp,ra
                   < elite.a99
13838                                                                          ; (A P+1 P) * Q
13839               
13840 41CE 0240  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign bit
     41D0 8000     
13841               
13842 41D2 F020  30        socb @T,ra                      ; ORA T             ; Apply this to the high byte of the result in T, so
     41D4 00D1     
13843                                                                          ; that A now has the correct sign for the result, and
13844                                                                          ; (A K+2 K+1 K) therefore contains the correctly signed
13845                                                                          ; result
13846               
13847 41D6 D800  30        movb ra,@K+3                    ; STA K+3           ; Store A in K+3, so K(3 2 1 0) now contains the result
     41D8 0040     
13848               
13849 41DA 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     41DC 800E     
13850               
13851               * ******************************************************************************
13852               *
13853               * Name: MLS2
13854               * Type: Subroutine
13855               * Category: Maths (Arithmetic)
13856               * Summary: Calculate (S R) = XX(1 0) and (A P) = A * ALP1
13857               *
13858               * ------------------------------------------------------------------------------
13859               *
13860               * Calculate the following:
13861               *
13862               * (S R) = XX(1 0)
13863               *
13864               * (A P) = A * ALP1
13865               *
13866               * where ALP1 is the magnitude of the current roll angle alpha, in the range
13867               * 0-31.
13868               *
13869               * ******************************************************************************
13870               
13871               MLS2:
13872 41DE D060  30        movb @XX,rx                     ; LDX XX            ; Set (S R) = XX(1 0), starting with the low bytes
     41E0 0024     
13873 41E2 D801  30        movb rx,@R                      ; STX R
     41E4 0091     
13874               
13875 41E6 D060  30        movb @XX+1,rx                   ; LDX XX+1          ; And then doing the high bytes
     41E8 0025     
13876 41EA D801  30        movb rx,@S                      ; STX S
     41EC 0092     
13877               
13878                                                                          ; Fall through into MLS1 to calculate (A P) = A * ALP1
13879               
13880               * ******************************************************************************
13881               *
13882               * Name: MLS1
13883               * Type: Subroutine
13884               * Category: Maths (Arithmetic)
13885               * Summary: Calculate (A P) = ALP1 * A
13886               *
13887               * ------------------------------------------------------------------------------
13888               *
13889               * Calculate the following:
13890               *
13891               * (A P) = ALP1 * A
13892               *
13893               * where ALP1 is the magnitude of the current roll angle alpha, in the range
13894               * 0-31.
13895               *
13896               * This routine uses an unrolled version of MU11. MU11 calculates P * X, so we
13897               * use the same algorithm but with P set to ALP1 and X set to A. The unrolled
13898               * version here can skip the bit tests for bits 5-7 of P as we know P < 32, so
13899               * only 5 shifts with bit tests are needed (for bits 0-4), while the other 3
13900               * shifts can be done without a test (for bits 5-7).
13901               *
13902               * ------------------------------------------------------------------------------
13903               *
13904               * Other entry points:
13905               *
13906               * MULTS-2             Calculate (A P) = X * A
13907               *
13908               * ******************************************************************************
13909               
13910               MLS1:
13911 41EE D060  30        movb @ALP1,rx                   ; LDX ALP1          ; Set P to the roll angle alpha magnitude in ALP1
     41F0 0087     
13912 41F2 D801  30        movb rx,@P                      ; STX P             ; (0-31), so now we calculate P * A
     41F4 001B     
13913               
13914               MULTS:
13915 41F6 D040  18        movb ra,rx                      ; TAX               ; Set X = A, so now we can calculate P * X instead of
13916                                                                          ; P * A to get our result, and we can use the algorithm
13917                                                                          ; from MU11 to do that, just unrolled (as MU11 returns
13918                                                                          ; P * X)
13919               
13920 41F8 0240  22        andi ra,>80*256                 ; AND #%10000000    ; Set T to the sign bit of A
     41FA 8000     
13921 41FC D800  30        movb ra,@T                      ; STA T
     41FE 00D1     
13922               
13923 4200 D001  18        movb rx,ra                      ; TXA               ; Set A = |A|
13924 4202 0240  22        andi ra,>7f*256                 ; AND #127
     4204 7F00     
13925               
13926 4206 1602  14        jne  FIX003                     ; BNE FIX003        ; If A = 0, jump to MU6 to set P(1 0) = 0 and return
13927                                                                          ; from the subroutine using a tail call
13928 4208 0460  28        b    @MU6                       ; JMP MU6
     420A 431A     
13929               FIX003:
13930 420C D040  18        movb ra,rx                      ; TAX               ; Set T1 = X - 1
13931 420E 7044  18        sb   rone,rx                    ; DEX               ;
13932 4210 D801  30        movb rx,@T1                     ; STX T1            ; We subtract 1 as the C flag will be set when we want
     4212 0006     
13933                                                                          ; to do an addition in the loop below
13934               
13935 4214 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4216 0000     
13936               
13937                      .lsr @P                         ; LSR P             ; Set P = P >> 1
     **** ****     > LSR
0001 4218 D1A0  30        movb @P,rtmp
     421A 001B     
0002 421C 0916  18        srl  rtmp,1
0003 421E D806  30        movb rtmp,@P
     4220 001B     
                   < elite.a99
13938                                                                          ; and C flag = bit 0 of P
13939               
13940                                                                          ; We are now going to work our way through the bits of
13941                                                                          ; P, and do a shift-add for any bits that are set,
13942                                                                          ; keeping the running total in A, but instead of using a
13943                                                                          ; loop like MU11, we just unroll it, starting with bit 0
13944               
13945 4222 1704  14        jnc  B39                        ; BCC B39           ; If C (i.e. the next bit from P) is set, do the
13946                      .adc @T1,ra                     ; ADC T1            ; addition for this bit of P:
     **** ****     > ADC
0001 4224 1701  14        jnc  !
0002 4226 B004  18        ab   rone,ra
0003               !:
0004 4228 B020  30        ab   @T1,ra
     422A 0006     
                   < elite.a99
13947                                                                          ;
13948                                                                          ; A = A + T1 + C
13949                                                                          ; = A + X - 1 + 1
13950                                                                          ; = A + X
13951               
13952               B39:
13953 422C 06A0  28        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result,
     422E 803C     
13954                                                                          ; which the next ROR sticks into the left end of P while
13955                                                                          ; also extracting the next bit of P
13956               
13957 4230 0208  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     4232 001B     
13958 4234 06A0  28        bl   @ror                       ;
     4236 8054     
13959                                                                          ; the start of P, and shift P right to fetch the next
13960                                                                          ; bit for the calculation into the C flag
13961               
13962 4238 1704  14        jnc  B40                        ; BCC B40           ; Repeat the shift-and-add loop for bit 1
13963                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 423A 1701  14        jnc  !
0002 423C B004  18        ab   rone,ra
0003               !:
0004 423E B020  30        ab   @T1,ra
     4240 0006     
                   < elite.a99
13964               B40:
13965 4242 06A0  28        bl   @rora                      ; ROR A
     4244 803C     
13966 4246 0208  20        li   rarg1,P                    ; ROR P
     4248 001B     
13967 424A 06A0  28        bl   @ror                       ;
     424C 8054     
13968               
13969 424E 1704  14        jnc  B41                        ; BCC B41           ; Repeat the shift-and-add loop for bit 2
13970                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 4250 1701  14        jnc  !
0002 4252 B004  18        ab   rone,ra
0003               !:
0004 4254 B020  30        ab   @T1,ra
     4256 0006     
                   < elite.a99
13971               B41:
13972 4258 06A0  28        bl   @rora                      ; ROR A
     425A 803C     
13973 425C 0208  20        li   rarg1,P                    ; ROR P
     425E 001B     
13974 4260 06A0  28        bl   @ror                       ;
     4262 8054     
13975               
13976 4264 1704  14        jnc  B42                        ; BCC B42           ; Repeat the shift-and-add loop for bit 3
13977                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 4266 1701  14        jnc  !
0002 4268 B004  18        ab   rone,ra
0003               !:
0004 426A B020  30        ab   @T1,ra
     426C 0006     
                   < elite.a99
13978               B42:
13979 426E 06A0  28        bl   @rora                      ; ROR A
     4270 803C     
13980 4272 0208  20        li   rarg1,P                    ; ROR P
     4274 001B     
13981 4276 06A0  28        bl   @ror                       ;
     4278 8054     
13982               
13983 427A 1704  14        jnc  B43                        ; BCC B43           ; Repeat the shift-and-add loop for bit 4
13984                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 427C 1701  14        jnc  !
0002 427E B004  18        ab   rone,ra
0003               !:
0004 4280 B020  30        ab   @T1,ra
     4282 0006     
                   < elite.a99
13985               B43:
13986 4284 06A0  28        bl   @rora                      ; ROR A
     4286 803C     
13987 4288 0208  20        li   rarg1,P                    ; ROR P
     428A 001B     
13988 428C 06A0  28        bl   @ror                       ;
     428E 8054     
13989               
13990 4290 0910  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 5
13991 4292 0208  20        li   rarg1,P                    ; ROR P
     4294 001B     
13992 4296 06A0  28        bl   @ror                       ;
     4298 8054     
13993               
13994 429A 0910  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 6
13995 429C 0208  20        li   rarg1,P                    ; ROR P
     429E 001B     
13996 42A0 06A0  28        bl   @ror                       ;
     42A2 8054     
13997               
13998 42A4 0910  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 7
13999 42A6 0208  20        li   rarg1,P                    ; ROR P
     42A8 001B     
14000 42AA 06A0  28        bl   @ror                       ;
     42AC 8054     
14001               
14002 42AE F020  30        socb @T,ra                      ; ORA T             ; Give A the sign bit of the original argument A that
     42B0 00D1     
14003                                                                          ; we put into T above
14004               
14005 42B2 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     42B4 800E     
14006               
14007               * ******************************************************************************
14008               *
14009               * Name: SQUA
14010               * Type: Subroutine
14011               * Category: Maths (Arithmetic)
14012               * Summary: Clear bit 7 of A and calculate (A P) = A * A
14013               *
14014               * ------------------------------------------------------------------------------
14015               *
14016               * Do the following multiplication of unsigned 8-bit numbers, after first
14017               * clearing bit 7 of A:
14018               *
14019               * (A P) = A * A
14020               *
14021               * ******************************************************************************
14022               
14023               SQUA:
14024 42B6 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear bit 7 of A and fall through into SQUA2 to set
     42B8 7F00     
14025                                                                          ; (A P) = A * A
14026               
14027               * ******************************************************************************
14028               *
14029               * Name: SQUA2
14030               * Type: Subroutine
14031               * Category: Maths (Arithmetic)
14032               * Summary: Calculate (A P) = A * A
14033               *
14034               * ------------------------------------------------------------------------------
14035               *
14036               * Do the following multiplication of unsigned 8-bit numbers:
14037               *
14038               * (A P) = A * A
14039               *
14040               * ******************************************************************************
14041               
14042               SQUA2:
14043 42BA D800  30        movb ra,@P                      ; STA P             ; Copy A into P and X
     42BC 001B     
14044 42BE D040  18        movb ra,rx                      ; TAX
14045               
14046 42C0 1611  14        jne  MU11                       ; BNE MU11          ; If X = 0 fall through into MU1 to return a 0,
14047                                                                          ; otherwise jump to MU11 to return P * X
14048               
14049               * ******************************************************************************
14050               *
14051               * Name: MU1
14052               * Type: Subroutine
14053               * Category: Maths (Arithmetic)
14054               * Summary: Copy X into P and A, and clear the C flag
14055               *
14056               * ------------------------------------------------------------------------------
14057               *
14058               * Used to return a 0 result quickly from MULTU below.
14059               *
14060               * ******************************************************************************
14061               
14062               MU1:
14063                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 42C2 0A13  18        sla  rzero,1
                   < elite.a99
14064               
14065 42C4 D801  30        movb rx,@P                      ; STX P             ; Copy X into P and A
     42C6 001B     
14066 42C8 D001  18        movb rx,ra                      ; TXA
14067               
14068 42CA 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     42CC 800E     
14069               
14070               * ******************************************************************************
14071               *
14072               * Name: MLU1
14073               * Type: Subroutine
14074               * Category: Maths (Arithmetic)
14075               * Summary: Calculate Y1 = y_hi and (A P) = |y_hi| * Q for Y-th stardust
14076               *
14077               * ------------------------------------------------------------------------------
14078               *
14079               * Do the following assignment, and multiply the Y-th stardust particle's
14080               * y-coordinate with an unsigned number Q:
14081               *
14082               * Y1 = y_hi
14083               *
14084               * (A P) = |y_hi| * Q
14085               *
14086               * ******************************************************************************
14087               
14088               MLU1:
14089 42CE D022  34        movb @SY(ry),ra                 ; LDA SY,Y          ; Set Y1 the Y-th byte of SY
     42D0 0EC2     
14090 42D2 D800  30        movb ra,@Y1                     ; STA Y1
     42D4 0032     
14091               
14092                                                                          ; Fall through into MLU2 to calculate:
14093                                                                          ;
14094                                                                          ; (A P) = |A| * Q
14095               
14096               * ******************************************************************************
14097               *
14098               * Name: MLU2
14099               * Type: Subroutine
14100               * Category: Maths (Arithmetic)
14101               * Summary: Calculate (A P) = |A| * Q
14102               *
14103               * ------------------------------------------------------------------------------
14104               *
14105               * Do the following multiplication of a sign-magnitude 8-bit number P with an
14106               * unsigned number Q:
14107               *
14108               * (A P) = |A| * Q
14109               *
14110               * ******************************************************************************
14111               
14112               MLU2:
14113 42D6 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit in P, so P = |A|
     42D8 7F00     
14114 42DA D800  30        movb ra,@P                      ; STA P
     42DC 001B     
14115               
14116                                                                          ; Fall through into MULTU to calculate:
14117                                                                          ;
14118                                                                          ; (A P) = P * Q
14119                                                                          ; = |A| * Q
14120               
14121               * ******************************************************************************
14122               *
14123               * Name: MULTU
14124               * Type: Subroutine
14125               * Category: Maths (Arithmetic)
14126               * Summary: Calculate (A P) = P * Q
14127               *
14128               * ------------------------------------------------------------------------------
14129               *
14130               * Do the following multiplication of unsigned 8-bit numbers:
14131               *
14132               * (A P) = P * Q
14133               *
14134               * ******************************************************************************
14135               
14136               MULTU:
14137 42DE D060  30        movb @Q,rx                      ; LDX Q             ; Set X = Q
     42E0 0090     
14138               
14139 42E2 13EF  14        jeq  MU1                        ; BEQ MU1           ; If X = Q = 0, jump to MU1 to copy X into P and A,
14140                                                                          ; clear the C flag and return from the subroutine using
14141                                                                          ; a tail call
14142               
14143                                                                          ; Otherwise fall through into MU11 to set (A P) = P * X
14144               
14145               * ******************************************************************************
14146               *
14147               * Name: MU11
14148               * Type: Subroutine
14149               * Category: Maths (Arithmetic)
14150               * Summary: Calculate (A P) = P * X
14151               * Deep dive: Shift-and-add multiplication
14152               *
14153               * ------------------------------------------------------------------------------
14154               *
14155               * Do the following multiplication of two unsigned 8-bit numbers:
14156               *
14157               * (A P) = P * X
14158               *
14159               * This uses the same shift-and-add approach as MULT1, but it's simpler as we
14160               * are dealing with unsigned numbers in P and X. See the deep dive on
14161               * "Shift-and-add multiplication" for a discussion of how this algorithm works.
14162               *
14163               * ******************************************************************************
14164               
14165               MU11:
14166 42E4 7044  18        sb   rone,rx                    ; DEX               ; Set T = X - 1
14167 42E6 D801  30        movb rx,@T                      ; STX T             ;
     42E8 00D1     
14168                                                                          ; We subtract 1 as the C flag will be set when we want
14169                                                                          ; to do an addition in the loop below
14170               
14171 42EA 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     42EC 0000     
14172               
14173 42EE 0201  20        li   rx,>08*256                 ; LDX #8            ; Set up a counter in X to count the 8 bits in P
     42F0 0800     
14174               
14175                      .lsr @P                         ; LSR P             ; Set P = P >> 1
     **** ****     > LSR
0001 42F2 D1A0  30        movb @P,rtmp
     42F4 001B     
0002 42F6 0916  18        srl  rtmp,1
0003 42F8 D806  30        movb rtmp,@P
     42FA 001B     
                   < elite.a99
14176                                                                          ; and C flag = bit 0 of P
14177               
14178                                                                          ; We are now going to work our way through the bits of
14179                                                                          ; P, and do a shift-add for any bits that are set,
14180                                                                          ; keeping the running total in A. We just did the first
14181                                                                          ; shift right, so we now need to do the first add and
14182                                                                          ; loop through the other bits in P
14183               
14184               MUL6:
14185 42FC 1704  14        jnc  B44                        ; BCC B44           ; If C (i.e. the next bit from P) is set, do the
14186                      .adc @T,ra                      ; ADC T             ; addition for this bit of P:
     **** ****     > ADC
0001 42FE 1701  14        jnc  !
0002 4300 B004  18        ab   rone,ra
0003               !:
0004 4302 B020  30        ab   @T,ra
     4304 00D1     
                   < elite.a99
14187                                                                          ;
14188                                                                          ; A = A + T + C
14189                                                                          ; = A + X - 1 + 1
14190                                                                          ; = A + X
14191               
14192               B44:
14193 4306 06A0  28        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result,
     4308 803C     
14194                                                                          ; which the next ROR sticks into the left end of P while
14195                                                                          ; also extracting the next bit of P
14196               
14197 430A 0208  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     430C 001B     
14198 430E 06A0  28        bl   @ror                       ;
     4310 8054     
14199                                                                          ; the start of P, and shift P right to fetch the next
14200                                                                          ; bit for the calculation into the C flag
14201               
14202 4312 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14203               
14204 4314 16F3  14        jne  MUL6                       ; BNE MUL6          ; Loop back for the next bit until P has been rotated
14205                                                                          ; all the way
14206               
14207 4316 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4318 800E     
14208               
14209               * ******************************************************************************
14210               *
14211               * Name: MU6
14212               * Type: Subroutine
14213               * Category: Maths (Arithmetic)
14214               * Summary: Set P(1 0) = (A A)
14215               *
14216               * ------------------------------------------------------------------------------
14217               *
14218               * In practice this is only called via a BEQ following an AND instruction, in
14219               * which case A = 0, so this routine effectively does this:
14220               *
14221               * P(1 0) = 0
14222               *
14223               * ******************************************************************************
14224               
14225               MU6:
14226 431A D800  30        movb ra,@P+1                    ; STA P+1           ; Set P(1 0) = (A A)
     431C 001C     
14227 431E D800  30        movb ra,@P                      ; STA P
     4320 001B     
14228               
14229 4322 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4324 800E     
14230               
14231               * ******************************************************************************
14232               *
14233               * Name: FMLTU2
14234               * Type: Subroutine
14235               * Category: Maths (Arithmetic)
14236               * Summary: Calculate A = K * sin(A)
14237               * Deep dive: The sine, cosine and arctan tables
14238               *
14239               * ------------------------------------------------------------------------------
14240               *
14241               * Calculate the following:
14242               *
14243               * A = K * sin(A)
14244               *
14245               * Because this routine uses the sine lookup table SNE, we can also call this
14246               * routine to calculate cosine multiplication. To calculate the following:
14247               *
14248               * A = K * cos(B)
14249               *
14250               * call this routine with B + 16 in the accumulator, as sin(B + 16) = cos(B).
14251               *
14252               * ******************************************************************************
14253               
14254               FMLTU2:
14255 4326 0240  22        andi ra,>1f*256                 ; AND #%00011111    ; Restrict A to bits 0-5 (so it's in the range 0-31)
     4328 1F00     
14256               
14257 432A D040  18        movb ra,rx                      ; TAX               ; Set Q = sin(A) * 256
14258 432C D021  34        movb @SNE(rx),ra                ; LDA SNE,X
     432E 4112     
14259 4330 D800  30        movb ra,@Q                      ; STA Q
     4332 0090     
14260               
14261 4334 D020  30        movb @K,ra                      ; LDA K             ; Set A to the radius in K
     4336 003D     
14262               
14263                                                                          ; Fall through into FMLTU to do the following:
14264                                                                          ;
14265                                                                          ; (A ?) = A * Q
14266                                                                          ; = K * sin(A) * 256
14267                                                                          ;
14268                                                                          ; which is equivalent to:
14269                                                                          ;
14270                                                                          ; A = K * sin(A)
14271               
14272               * ******************************************************************************
14273               *
14274               * Name: FMLTU
14275               * Type: Subroutine
14276               * Category: Maths (Arithmetic)
14277               * Summary: Calculate A = A * Q / 256
14278               *
14279               * ------------------------------------------------------------------------------
14280               *
14281               * Do the following multiplication of two unsigned 8-bit numbers, returning only
14282               * the high byte of the result:
14283               *
14284               * (A ?) = A * Q
14285               *
14286               * or, to put it another way:
14287               *
14288               * A = A * Q / 256
14289               *
14290               * ------------------------------------------------------------------------------
14291               *
14292               * Returns:
14293               *
14294               * C flag              The C flag is set
14295               *
14296               * ******************************************************************************
14297               
14298               FMLTU:
14299                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip the bits in A, set the C flag and rotate right,
     **** ****     > EOI
0001 4338 0206  20        li   rtmp,(>FF*256)
     433A FF00     
0002 433C 2806  18        xor  rtmp,ra
                   < elite.a99
14300                      .sec                            ; SEC               ; so the C flag now contains bit 0 of A inverted, and P
     **** ****     > SEC
0001 433E 0A15  18        sla  rmone,1
                   < elite.a99
14301 4340 06A0  28        bl   @rora                      ; ROR A             ; contains A inverted and shifted right by one, with bit
     4342 803C     
14302 4344 D800  30        movb ra,@P                      ; STA P             ; 7 set to a 1. We can now use P as our source of bits
     4346 001B     
14303                                                                          ; to shift right, just as in MU11, just with the logic
14304                                                                          ; reversed
14305               
14306 4348 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     434A 0000     
14307               
14308               MUL3:
14309 434C 180E  14        joc  MU7                        ; BCS MU7           ; If C (i.e. the next bit from P) is set, do not do the
14310                                                                          ; addition for this bit of P, and instead skip to MU7
14311                                                                          ; to just do the shifts
14312               
14313                      .adc @Q,ra                      ; ADC Q             ; Do the addition for this bit of P:
     **** ****     > ADC
0001 434E 1701  14        jnc  !
0002 4350 B004  18        ab   rone,ra
0003               !:
0004 4352 B020  30        ab   @Q,ra
     4354 0090     
                   < elite.a99
14314                                                                          ;
14315                                                                          ; A = A + Q + C
14316                                                                          ; = A + Q
14317               
14318 4356 06A0  28        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result.
     4358 803C     
14319                                                                          ; If we were interested in the low byte of the result we
14320                                                                          ; would want to save the bit that falls off the end, but
14321                                                                          ; we aren't, so we can ignore it
14322               
14323                      .lsr @P                         ; LSR P             ; Shift P right to fetch the next bit for the
     **** ****     > LSR
0001 435A D1A0  30        movb @P,rtmp
     435C 001B     
0002 435E 0916  18        srl  rtmp,1
0003 4360 D806  30        movb rtmp,@P
     4362 001B     
                   < elite.a99
14324                                                                          ; calculation into the C flag
14325               
14326 4364 16F3  14        jne  MUL3                       ; BNE MUL3          ; Loop back to MUL3 if P still contains some set bits
14327                                                                          ; (so we loop through the bits of P until we get to the
14328                                                                          ; 1 we inserted before the loop, and then we stop)
14329               
14330                                                                          ; If we get here then the C flag is set as we just
14331                                                                          ; rotated a 1 out of the right end of P
14332               
14333 4366 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4368 800E     
14334               
14335               MU7:
14336 436A 0910  18        srl  ra,1                       ; LSR A             ; Shift A right to catch the next digit of our result,
14337                                                                          ; pushing a 0 into bit 7 as we aren't adding anything
14338                                                                          ; here (we can't use a ROR here as the C flag is set, so
14339                                                                          ; a ROR would push a 1 into bit 7)
14340               
14341                      .lsr @P                         ; LSR P             ; Fetch the next bit from P into the C flag
     **** ****     > LSR
0001 436C D1A0  30        movb @P,rtmp
     436E 001B     
0002 4370 0916  18        srl  rtmp,1
0003 4372 D806  30        movb rtmp,@P
     4374 001B     
                   < elite.a99
14342               
14343 4376 16EA  14        jne  MUL3                       ; BNE MUL3          ; Loop back to MUL3 if P still contains some set bits
14344                                                                          ; (so we loop through the bits of P until we get to the
14345                                                                          ; 1 we inserted before the loop, and then we stop)
14346               
14347                                                                          ; If we get here then the C flag is set as we just
14348                                                                          ; rotated a 1 out of the right end of P
14349               
14350 4378 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     437A 800E     
14351               
14352               * ******************************************************************************
14353               *
14354               * Name: Unused duplicate of MULTU
14355               * Type: Subroutine
14356               * Category: Maths (Arithmetic)
14357               * Summary: An unused duplicate of the MULTU routine
14358               *
14359               * ------------------------------------------------------------------------------
14360               *
14361               * This is a duplicate of the MULTU routine, but with no entry label, so it can't
14362               * be called by name. It is unused, and could have been culled to save a few
14363               * bytes (24 to be precise), but it's still here, unnamed, unloved and unvisited,
14364               * through no fault of its own.
14365               *
14366               * ******************************************************************************
14367               
14368               * {
14369               * LDX Q
14370               * BEQ MU1
14371               * DEX
14372               * STX T
14373               * LDA #0
14374               * LDX #8
14375               * LSR P
14376               *
14377               * .MUL6
14378               *
14379               * BCC B45
14380               * ADC T
14381               * .B45
14382               * ROR A
14383               * ROR P
14384               * DEX
14385               * BNE MUL6
14386               * RTS
14387               * }
14388               
14389               * ******************************************************************************
14390               *
14391               * Name: MLTU2
14392               * Type: Subroutine
14393               * Category: Maths (Arithmetic)
14394               * Summary: Calculate (A P+1 P) = (A ~P) * Q
14395               * Deep dive: Shift-and-add multiplication
14396               *
14397               * ------------------------------------------------------------------------------
14398               *
14399               * Do the following multiplication of an unsigned 16-bit number and an unsigned
14400               * 8-bit number:
14401               *
14402               * (A P+1 P) = (A ~P) * Q
14403               *
14404               * where ~P means P EOR %11111111 (i.e. P with all its bits flipped). In other
14405               * words, if you wanted to calculate &1234 * &56, you would:
14406               *
14407               * * Set A to &12
14408               * * Set P to &34 EOR %11111111 = &CB
14409               * * Set Q to &56
14410               *
14411               * before calling MLTU2.
14412               *
14413               * This routine is like a mash-up of MU11 and FMLTU. It uses part of FMLTU's
14414               * inverted argument trick to work out whether or not to do an addition, and like
14415               * MU11 it sets up a counter in X to extract bits from (P+1 P). But this time we
14416               * extract 16 bits from (P+1 P), so the result is a 24-bit number. The core of
14417               * the algorithm is still the shift-and-add approach explained in MULT1, just
14418               * with more bits.
14419               *
14420               * ------------------------------------------------------------------------------
14421               *
14422               * Returns:
14423               *
14424               * Q                   Q is preserved
14425               *
14426               * ------------------------------------------------------------------------------
14427               *
14428               * Other entry points:
14429               *
14430               * MLTU2-2             Set Q to X, so this calculates (A P+1 P) = (A ~P) * X
14431               *
14432               * ******************************************************************************
14433               
14434 437C D801  30        movb rx,@Q                      ; STX Q             ; Store X in Q
     437E 0090     
14435               
14436               MLTU2:
14437                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip the bits in A and rotate right, storing the
     **** ****     > EOI
0001 4380 0206  20        li   rtmp,(>FF*256)
     4382 FF00     
0002 4384 2806  18        xor  rtmp,ra
                   < elite.a99
14438 4386 0910  18        srl  ra,1                       ; LSR A             ; result in P+1, so we now calculate (P+1 P) * Q
14439 4388 D800  30        movb ra,@P+1                    ; STA P+1
     438A 001C     
14440               
14441 438C 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     438E 0000     
14442               
14443 4390 0201  20        li   rx,>10*256                 ; LDX #16           ; Set up a counter in X to count the 16 bits in (P+1 P)
     4392 1000     
14444               
14445 4394 0208  20        li   rarg1,P                    ; ROR P             ; Set P = P >> 1 with bit 7 = bit 0 of A
     4396 001B     
14446 4398 06A0  28        bl   @ror                       ;
     439A 8054     
14447                                                                          ; and C flag = bit 0 of P
14448               
14449               MUL7:
14450 439C 1812  14        joc  MU21                       ; BCS MU21          ; If C (i.e. the next bit from P) is set, do not do the
14451                                                                          ; addition for this bit of P, and instead skip to MU21
14452                                                                          ; to just do the shifts
14453               
14454                      .adc @Q,ra                      ; ADC Q             ; Do the addition for this bit of P:
     **** ****     > ADC
0001 439E 1701  14        jnc  !
0002 43A0 B004  18        ab   rone,ra
0003               !:
0004 43A2 B020  30        ab   @Q,ra
     43A4 0090     
                   < elite.a99
14455                                                                          ;
14456                                                                          ; A = A + Q + C
14457                                                                          ; = A + Q
14458               
14459 43A6 06A0  28        bl   @rora                      ; ROR A             ; Rotate (A P+1 P) to the right, so we capture the next
     43A8 803C     
14460 43AA 0208  20        li   rarg1,P+1                  ; ROR P+1           ; digit of the result in P+1, and extract the next digit
     43AC 001C     
14461 43AE 06A0  28        bl   @ror                       ;
     43B0 8054     
14462 43B2 0208  20        li   rarg1,P                    ; ROR P             ; of (P+1 P) in the C flag
     43B4 001B     
14463 43B6 06A0  28        bl   @ror                       ;
     43B8 8054     
14464               
14465 43BA 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14466               
14467 43BC 16EF  14        jne  MUL7                       ; BNE MUL7          ; Loop back for the next bit until P has been rotated
14468                                                                          ; all the way
14469               
14470 43BE 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     43C0 800E     
14471               
14472               MU21:
14473 43C2 0910  18        srl  ra,1                       ; LSR A             ; Shift (A P+1 P) to the right, so we capture the next
14474 43C4 0208  20        li   rarg1,P+1                  ; ROR P+1           ; digit of the result in P+1, and extract the next digit
     43C6 001C     
14475 43C8 06A0  28        bl   @ror                       ;
     43CA 8054     
14476 43CC 0208  20        li   rarg1,P                    ; ROR P             ; of (P+1 P) in the C flag
     43CE 001B     
14477 43D0 06A0  28        bl   @ror                       ;
     43D2 8054     
14478               
14479 43D4 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14480               
14481 43D6 16E2  14        jne  MUL7                       ; BNE MUL7          ; Loop back for the next bit until P has been rotated
14482                                                                          ; all the way
14483               
14484 43D8 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     43DA 800E     
14485               
14486               * ******************************************************************************
14487               *
14488               * Name: MUT3
14489               * Type: Subroutine
14490               * Category: Maths (Arithmetic)
14491               * Summary: An unused routine that does the same as MUT2
14492               *
14493               * ------------------------------------------------------------------------------
14494               *
14495               * This routine is never actually called, but it is identical to MUT2, as the
14496               * extra instructions have no effect.
14497               *
14498               * ******************************************************************************
14499               
14500               MUT3:
14501 43DC D060  30        movb @ALP1,rx                   ; LDX ALP1          ; Set P = ALP1, though this gets overwritten by the
     43DE 0087     
14502 43E0 D801  30        movb rx,@P                      ; STX P             ; following, so this has no effect
     43E2 001B     
14503               
14504                                                                          ; Fall through into MUT2 to do the following:
14505                                                                          ;
14506                                                                          ; (S R) = XX(1 0)
14507                                                                          ; (A P) = Q * A
14508               
14509               * ******************************************************************************
14510               *
14511               * Name: MUT2
14512               * Type: Subroutine
14513               * Category: Maths (Arithmetic)
14514               * Summary: Calculate (S R) = XX(1 0) and (A P) = Q * A
14515               *
14516               * ------------------------------------------------------------------------------
14517               *
14518               * Do the following assignment, and multiplication of two signed 8-bit numbers:
14519               *
14520               * (S R) = XX(1 0)
14521               * (A P) = Q * A
14522               *
14523               * ******************************************************************************
14524               
14525               MUT2:
14526 43E4 D060  30        movb @XX+1,rx                   ; LDX XX+1          ; Set S = XX+1
     43E6 0025     
14527 43E8 D801  30        movb rx,@S                      ; STX S
     43EA 0092     
14528               
14529                                                                          ; Fall through into MUT1 to do the following:
14530                                                                          ;
14531                                                                          ; R = XX
14532                                                                          ; (A P) = Q * A
14533               
14534               * ******************************************************************************
14535               *
14536               * Name: MUT1
14537               * Type: Subroutine
14538               * Category: Maths (Arithmetic)
14539               * Summary: Calculate R = XX and (A P) = Q * A
14540               *
14541               * ------------------------------------------------------------------------------
14542               *
14543               * Do the following assignment, and multiplication of two signed 8-bit numbers:
14544               *
14545               * R = XX
14546               * (A P) = Q * A
14547               *
14548               * ******************************************************************************
14549               
14550               MUT1:
14551 43EC D060  30        movb @XX,rx                     ; LDX XX            ; Set R = XX
     43EE 0024     
14552 43F0 D801  30        movb rx,@R                      ; STX R
     43F2 0091     
14553               
14554                                                                          ; Fall through into MULT1 to do the following:
14555                                                                          ;
14556                                                                          ; (A P) = Q * A
14557               
14558               * ******************************************************************************
14559               *
14560               * Name: MULT1
14561               * Type: Subroutine
14562               * Category: Maths (Arithmetic)
14563               * Summary: Calculate (A P) = Q * A
14564               * Deep dive: Shift-and-add multiplication
14565               *
14566               * ------------------------------------------------------------------------------
14567               *
14568               * Do the following multiplication of two 8-bit sign-magnitude numbers:
14569               *
14570               * (A P) = Q * A
14571               *
14572               * ******************************************************************************
14573               
14574               MULT1:
14575 43F4 D040  18        movb ra,rx                      ; TAX               ; Store A in X
14576               
14577 43F6 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Set P = |A| >> 1
     43F8 7F00     
14578 43FA 0910  18        srl  ra,1                       ; LSR A             ; and C flag = bit 0 of A
14579 43FC D800  30        movb ra,@P                      ; STA P
     43FE 001B     
14580               
14581 4400 D001  18        movb rx,ra                      ; TXA               ; Restore argument A
14582               
14583                      .eor @Q                         ; EOR Q             ; Set bit 7 of A and T if Q and A have different signs,
     **** ****     > EOR
0001 4402 D1A0  30        movb @Q,rtmp
     4404 0090     
0002 4406 2806  18        xor  rtmp,ra
                   < elite.a99
14584 4408 0240  22        andi ra,>80*256                 ; AND #%10000000    ; clear bit 7 if they have the same signs, 0 all other
     440A 8000     
14585 440C D800  30        movb ra,@T                      ; STA T             ; bits, i.e. T contains the sign bit of Q * A
     440E 00D1     
14586               
14587 4410 D020  30        movb @Q,ra                      ; LDA Q             ; Set A = |Q|
     4412 0090     
14588 4414 0240  22        andi ra,>7f*256                 ; AND #%01111111
     4416 7F00     
14589               
14590 4418 131E  14        jeq  mu10_                      ; BEQ mu10          ; If |Q| = 0 jump to mu10 (with A set to 0)
14591               
14592 441A D040  18        movb ra,rx                      ; TAX               ; Set T1 = |Q| - 1
14593 441C 7044  18        sb   rone,rx                    ; DEX               ;
14594 441E D801  30        movb rx,@T1                     ; STX T1            ; We subtract 1 as the C flag will be set when we want
     4420 0006     
14595                                                                          ; to do an addition in the loop below
14596               
14597                                                                          ; We are now going to work our way through the bits of
14598                                                                          ; P, and do a shift-add for any bits that are set,
14599                                                                          ; keeping the running total in A. We already set up
14600                                                                          ; the first shift at the start of this routine, as
14601                                                                          ; P = |A| >> 1 and C = bit 0 of A, so we now need to set
14602                                                                          ; up a loop to sift through the other 7 bits in P
14603               
14604 4422 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4424 0000     
14605               
14606 4426 0201  20        li   rx,>07*256                 ; LDX #7            ; Set up a counter in X to count the 7 bits remaining
     4428 0700     
14607                                                                          ; in P
14608               
14609               MUL4:
14610 442A 1704  14        jnc  B46                        ; BCC B46           ; If C (i.e. the next bit from P) is set, do the
14611                      .adc @T1,ra                     ; ADC T1            ; addition for this bit of P:
     **** ****     > ADC
0001 442C 1701  14        jnc  !
0002 442E B004  18        ab   rone,ra
0003               !:
0004 4430 B020  30        ab   @T1,ra
     4432 0006     
                   < elite.a99
14612                                                                          ;
14613                                                                          ; A = A + T1 + C
14614                                                                          ; = A + |Q| - 1 + 1
14615                                                                          ; = A + |Q|
14616               
14617               B46:
14618 4434 06A0  28        bl   @rora                      ; ROR A             ; As mentioned above, this ROR shifts A right and
     4436 803C     
14619                                                                          ; catches bit 0 in C - giving another digit for our
14620                                                                          ; result - and the next ROR sticks that bit into the
14621                                                                          ; left end of P while also extracting the next bit of P
14622                                                                          ; for the next addition
14623               
14624 4438 0208  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     443A 001B     
14625 443C 06A0  28        bl   @ror                       ;
     443E 8054     
14626                                                                          ; the start of P, and shift P right to fetch the next
14627                                                                          ; bit for the calculation
14628               
14629 4440 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14630               
14631 4442 16F3  14        jne  MUL4                       ; BNE MUL4          ; Loop back for the next bit until P has been rotated
14632                                                                          ; all the way
14633               
14634 4444 0910  18        srl  ra,1                       ; LSR A             ; Rotate (A P) once more to get the final result, as
14635 4446 0208  20        li   rarg1,P                    ; ROR P             ; we only pushed 7 bits through the above process
     4448 001B     
14636 444A 06A0  28        bl   @ror                       ;
     444C 8054     
14637               
14638 444E F020  30        socb @T,ra                      ; ORA T             ; Set the sign bit of the result that we stored in T
     4450 00D1     
14639               
14640 4452 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4454 800E     
14641               
14642               mu10_:
14643 4456 D800  30        movb ra,@P                      ; STA P             ; If we get here, the result is 0 and A = 0, so set
     4458 001B     
14644                                                                          ; P = 0 so (A P) = 0
14645               
14646 445A 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     445C 800E     
14647               
14648               * ******************************************************************************
14649               *
14650               * Name: MULT12
14651               * Type: Subroutine
14652               * Category: Maths (Arithmetic)
14653               * Summary: Calculate (S R) = Q * A
14654               *
14655               * ------------------------------------------------------------------------------
14656               *
14657               * Calculate:
14658               *
14659               * (S R) = Q * A
14660               *
14661               * ******************************************************************************
14662               
14663               MULT12:
14664 445E 0206  20        li   rtmp,MULT1                 ; JSR MULT1         ; Set (A P) = Q * A
     4460 43F4     
14665 4462 06A0  28        bl   @jsr                       ;
     4464 8002     
14666               
14667 4466 D800  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P)
     4468 0092     
14668 446A D020  30        movb @P,ra                      ; LDA P             ; = Q * A
     446C 001B     
14669 446E D800  30        movb ra,@R                      ; STA R
     4470 0091     
14670               
14671 4472 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4474 800E     
14672               
14673               * ******************************************************************************
14674               *
14675               * Name: TAS3
14676               * Type: Subroutine
14677               * Category: Maths (Geometry)
14678               * Summary: Calculate the dot product of XX15 and an orientation vector
14679               *
14680               * ------------------------------------------------------------------------------
14681               *
14682               * Calculate the dot product of the vector in XX15 and one of the orientation
14683               * vectors, as determined by the value of Y. If vect is the orientation vector,
14684               * we calculate this:
14685               *
14686               * (A X) = vect . XX15
14687               * = vect_x * XX15 + vect_y * XX15+1 + vect_z * XX15+2
14688               *
14689               * ------------------------------------------------------------------------------
14690               *
14691               * Arguments:
14692               *
14693               * Y                   The orientation vector:
14694               *
14695               * * If Y = 10, calculate nosev . XX15
14696               *
14697               * * If Y = 16, calculate roofv . XX15
14698               *
14699               * * If Y = 22, calculate sidev . XX15
14700               *
14701               * ------------------------------------------------------------------------------
14702               *
14703               * Returns:
14704               *
14705               * (A X)               The result of the dot product
14706               *
14707               * ******************************************************************************
14708               
14709               TAS3:
14710 4476 D062  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; Set Q = the Y-th byte of INWK, i.e. vect_x
     4478 0053     
14711 447A D801  30        movb rx,@Q                      ; STX Q
     447C 0090     
14712               
14713 447E D020  30        movb @XX15,ra                   ; LDA XX15          ; Set A = XX15
     4480 0031     
14714               
14715 4482 0206  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A
     4484 445E     
14716 4486 06A0  28        bl   @jsr                       ;
     4488 8002     
14717                                                                          ; = vect_x * XX15
14718               
14719 448A D062  34        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set Q = the Y+2-th byte of INWK, i.e. vect_y
     448C 0055     
14720 448E D801  30        movb rx,@Q                      ; STX Q
     4490 0090     
14721               
14722 4492 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A = XX15+1
     4494 0032     
14723               
14724 4496 0206  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     4498 44B2     
14725 449A 06A0  28        bl   @jsr                       ;
     449C 8002     
14726                                                                          ; = vect_y * XX15+1 + vect_x * XX15
14727               
14728 449E D800  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     44A0 0092     
14729 44A2 D801  30        movb rx,@R                      ; STX R
     44A4 0091     
14730               
14731 44A6 D062  34        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; Set Q = the Y+2-th byte of INWK, i.e. vect_z
     44A8 0057     
14732 44AA D801  30        movb rx,@Q                      ; STX Q
     44AC 0090     
14733               
14734 44AE D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set A = XX15+2
     44B0 0033     
14735               
14736                                                                          ; Fall through into MAD to set:
14737                                                                          ;
14738                                                                          ; (A X) = Q * A + (S R)
14739                                                                          ; = vect_z * XX15+2 + vect_y * XX15+1 +
14740                                                                          ; vect_x * XX15
14741               
14742               * ******************************************************************************
14743               *
14744               * Name: MAD
14745               * Type: Subroutine
14746               * Category: Maths (Arithmetic)
14747               * Summary: Calculate (A X) = Q * A + (S R)
14748               *
14749               * ------------------------------------------------------------------------------
14750               *
14751               * Calculate
14752               *
14753               * (A X) = Q * A + (S R)
14754               *
14755               * ******************************************************************************
14756               
14757               MAD:
14758 44B2 0206  20        li   rtmp,MULT1                 ; JSR MULT1         ; Call MULT1 to set (A P) = Q * A
     44B4 43F4     
14759 44B6 06A0  28        bl   @jsr                       ;
     44B8 8002     
14760               
14761                                                                          ; Fall through into ADD to do:
14762                                                                          ;
14763                                                                          ; (A X) = (A P) + (S R)
14764                                                                          ; = Q * A + (S R)
14765               
14766               * ******************************************************************************
14767               *
14768               * Name: ADD
14769               * Type: Subroutine
14770               * Category: Maths (Arithmetic)
14771               * Summary: Calculate (A X) = (A P) + (S R)
14772               * Deep dive: Adding sign-magnitude numbers
14773               *
14774               * ------------------------------------------------------------------------------
14775               *
14776               * Add two 16-bit sign-magnitude numbers together, calculating:
14777               *
14778               * (A X) = (A P) + (S R)
14779               *
14780               * ******************************************************************************
14781               
14782               ADD:
14783 44BA D800  30        movb ra,@T1                     ; STA T1            ; Store argument A in T1
     44BC 0006     
14784               
14785 44BE 0240  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign (bit 7) of A and store it in T
     44C0 8000     
14786 44C2 D800  30        movb ra,@T                      ; STA T
     44C4 00D1     
14787               
14788                      .eor @S                         ; EOR S             ; EOR bit 7 of A with S. If they have different bit 7s
     **** ****     > EOR
0001 44C6 D1A0  30        movb @S,rtmp
     44C8 0092     
0002 44CA 2806  18        xor  rtmp,ra
                   < elite.a99
14789 44CC 1112  14        jlt  MU8                        ; BMI MU8           ; (i.e. they have different signs) then bit 7 in the
14790                                                                          ; EOR result will be 1, which means the EOR result is
14791                                                                          ; negative. So the AND, EOR and BMI together mean "jump
14792                                                                          ; to MU8 if A and S have different signs"
14793               
14794                                                                          ; If we reach here, then A and S have the same sign, so
14795                                                                          ; we can add them and set the sign to get the result
14796               
14797 44CE D020  30        movb @R,ra                      ; LDA R             ; Add the least significant bytes together into X:
     44D0 0091     
14798                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 44D2 0A13  18        sla  rzero,1
                   < elite.a99
14799                      .adc @P,ra                      ; ADC P             ; X = P + R
     **** ****     > ADC
0001 44D4 1701  14        jnc  !
0002 44D6 B004  18        ab   rone,ra
0003               !:
0004 44D8 B020  30        ab   @P,ra
     44DA 001B     
                   < elite.a99
14800 44DC D040  18        movb ra,rx                      ; TAX
14801               
14802 44DE D020  30        movb @S,ra                      ; LDA S             ; Add the most significant bytes together into A. We
     44E0 0092     
14803                      .adc @T1,ra                     ; ADC T1            ; stored the original argument A in T1 earlier, so we
     **** ****     > ADC
0001 44E2 1701  14        jnc  !
0002 44E4 B004  18        ab   rone,ra
0003               !:
0004 44E6 B020  30        ab   @T1,ra
     44E8 0006     
                   < elite.a99
14804                                                                          ; can do this with:
14805                                                                          ;
14806                                                                          ; A = A  + S + C
14807                                                                          ; = T1 + S + C
14808               
14809 44EA F020  30        socb @T,ra                      ; ORA T             ; If argument A was negative (and therefore S was also
     44EC 00D1     
14810                                                                          ; negative) then make sure result A is negative by
14811                                                                          ; OR'ing the result with the sign bit from argument A
14812                                                                          ; (which we stored in T)
14813               
14814 44EE 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     44F0 800E     
14815               
14816               MU8:
14817                                                                          ; If we reach here, then A and S have different signs,
14818                                                                          ; so we can subtract their absolute values and set the
14819                                                                          ; sign to get the result
14820 44F2 D020  30        movb @S,ra                      ; LDA S             ; Clear the sign (bit 7) in S and store the result in
     44F4 0092     
14821 44F6 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; U, so U now contains |S|
     44F8 7F00     
14822 44FA D800  30        movb ra,@U                      ; STA U
     44FC 008F     
14823               
14824 44FE D020  30        movb @P,ra                      ; LDA P             ; Subtract the least significant bytes into X:
     4500 001B     
14825                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 4502 0A15  18        sla  rmone,1
                   < elite.a99
14826                      .sbc @R,ra                      ; SBC R             ; X = P - R
     **** ****     > SBC
0001 4504 1801  14        joc  !
0002 4506 7004  18        sb   rone,ra
0003               !:
0004 4508 7020  30        sb   @R,ra
     450A 0091     
                   < elite.a99
14827 450C D040  18        movb ra,rx                      ; TAX
14828               
14829 450E D020  30        movb @T1,ra                     ; LDA T1            ; Restore the A of the argument (A P) from T1 and
     4510 0006     
14830 4512 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; clear the sign (bit 7), so A now contains |A|
     4514 7F00     
14831               
14832                      .sbc @U,ra                      ; SBC U             ; Set A = |A| - |S|
     **** ****     > SBC
0001 4516 1801  14        joc  !
0002 4518 7004  18        sb   rone,ra
0003               !:
0004 451A 7020  30        sb   @U,ra
     451C 008F     
                   < elite.a99
14833               
14834                                                                          ; At this point we have |A P| - |S R| in (A X), so we
14835                                                                          ; need to check whether the subtraction above was the
14836                                                                          ; right way round (i.e. that we subtracted the smaller
14837                                                                          ; absolute value from the larger absolute value)
14838               
14839 451E 1813  14        joc  MU9                        ; BCS MU9           ; If |A| >= |S|, our subtraction was the right way
14840                                                                          ; round, so jump to MU9 to set the sign
14841               
14842                                                                          ; If we get here, then |A| < |S|, so our subtraction
14843                                                                          ; above was the wrong way round (we actually subtracted
14844                                                                          ; the larger absolute value from the smaller absolute
14845                                                                          ; value). So let's subtract the result we have in (A X)
14846                                                                          ; from zero, so that the subtraction is the right way
14847                                                                          ; round
14848               
14849 4520 D800  30        movb ra,@U                      ; STA U             ; Store A in U
     4522 008F     
14850               
14851 4524 D001  18        movb rx,ra                      ; TXA               ; Set X = 0 - X using two's complement (to negate a
14852                      .eoi (>ff*256)                  ; EOR #&FF          ; number in two's complement, you can invert the bits
     **** ****     > EOI
0001 4526 0206  20        li   rtmp,(>FF*256)
     4528 FF00     
0002 452A 2806  18        xor  rtmp,ra
                   < elite.a99
14853                      .adi (>01*256)                  ; ADC #1            ; and add one - and we know the C flag is clear as we
     **** ****     > ADI
0001 452C 1701  14        jnc  !
0002 452E B004  18        ab   rone,ra
0003               !:
0004 4530 0220  22        ai   ra,(>01*256)
     4532 0100     
                   < elite.a99
14854 4534 D040  18        movb ra,rx                      ; TAX               ; didn't take the BCS branch above, so the ADC will do
14855                                                                          ; the correct addition)
14856               
14857 4536 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 - A, which we can do this time using a
     4538 0000     
14858                      .sbc @U,ra                      ; SBC U             ; subtraction with the C flag clear
     **** ****     > SBC
0001 453A 1801  14        joc  !
0002 453C 7004  18        sb   rone,ra
0003               !:
0004 453E 7020  30        sb   @U,ra
     4540 008F     
                   < elite.a99
14859               
14860 4542 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now set the sign bit of A, so that the EOR on the
     4544 8000     
14861                                                                          ; next line will give the result the opposite sign to
14862                                                                          ; argument A (as T contains the sign bit of argument
14863                                                                          ; A). This is the same as giving the result the same
14864                                                                          ; sign as argument S (as A and S have different signs),
14865                                                                          ; which is what we want, as S has the larger absolute
14866                                                                          ; value
14867               
14868               MU9:
14869                      .eor @T                         ; EOR T             ; If we get here from the BCS above, then |A| >= |S|,
     **** ****     > EOR
0001 4546 D1A0  30        movb @T,rtmp
     4548 00D1     
0002 454A 2806  18        xor  rtmp,ra
                   < elite.a99
14870                                                                          ; so we want to give the result the same sign as
14871                                                                          ; argument A, so if argument A was negative, we flip
14872                                                                          ; the sign of the result with an EOR (to make it
14873                                                                          ; negative)
14874               
14875 454C 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     454E 800E     
14876               
14877               * ******************************************************************************
14878               *
14879               * Name: TIS1
14880               * Type: Subroutine
14881               * Category: Maths (Arithmetic)
14882               * Summary: Calculate (A ?) = (-X * A + (S R)) / 96
14883               * Deep dive: Shift-and-subtract division
14884               *
14885               * ------------------------------------------------------------------------------
14886               *
14887               * Calculate the following expression between sign-magnitude numbers, ignoring
14888               * the low byte of the result:
14889               *
14890               * (A ?) = (-X * A + (S R)) / 96
14891               *
14892               * This uses the same shift-and-subtract algorithm as TIS2, just with the
14893               * quotient A hard-coded to 96.
14894               *
14895               * ------------------------------------------------------------------------------
14896               *
14897               * Returns:
14898               *
14899               * Q                   Gets set to the value of argument X
14900               *
14901               * ******************************************************************************
14902               
14903               TIS1:
14904 4550 D801  30        movb rx,@Q                      ; STX Q             ; Set Q = X
     4552 0090     
14905               
14906                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign bit in A
     **** ****     > EOI
0001 4554 0206  20        li   rtmp,(>80*256)
     4556 8000     
0002 4558 2806  18        xor  rtmp,ra
                   < elite.a99
14907               
14908 455A 0206  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     455C 44B2     
14909 455E 06A0  28        bl   @jsr                       ;
     4560 8002     
14910                                                                          ; = X * -A + (S R)
14911               
14912               DVID96:
14913 4562 D040  18        movb ra,rx                      ; TAX               ; Set T to the sign bit of the result
14914 4564 0240  22        andi ra,>80*256                 ; AND #%10000000
     4566 8000     
14915 4568 D800  30        movb ra,@T                      ; STA T
     456A 00D1     
14916               
14917 456C D001  18        movb rx,ra                      ; TXA               ; Set A to the high byte of the result with the sign bit
14918 456E 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; cleared, so (A ?) = |X * A + (S R)|
     4570 7F00     
14919               
14920                                                                          ; The following is identical to TIS2, except Q is
14921                                                                          ; hard-coded to 96, so this does A = A / 96
14922               
14923 4572 0201  20        li   rx,>fe*256                 ; LDX #254          ; Set T1 to have bits 1-7 set, so we can rotate through
     4574 FE00     
14924 4576 D801  30        movb rx,@T1                     ; STX T1            ; 7 loop iterations, getting a 1 each time, and then
     4578 0006     
14925                                                                          ; getting a 0 on the 8th iteration... and we can also
14926                                                                          ; use T1 to catch our result bits into bit 0 each time
14927               
14928               DVL3:
14929                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 457A 0240  22        andi ra,>ff00
     457C FF00     
0002 457E 0A10  18        sla  ra,1
                   < elite.a99
14930               
14931 4580 0280  22        ci   ra,>60*256                 ; CMP #96           ; If A < 96 skip the following subtraction
     4582 6000     
14932 4584 1704  14        jnc  DV4                        ; BCC DV4
14933               
14934                      .sbi (>60*256)                  ; SBC #96           ; Set A = A - 96
     **** ****     > SBI
0001 4586 1801  14        joc  !
0002 4588 7004  18        sb   rone,ra
0003               !:
0004 458A 0220  22        ai   ra,-(>60*256)
     458C A000     
                   < elite.a99
14935                                                                          ;
14936                                                                          ; Going into this subtraction we know the C flag is
14937                                                                          ; set as we passed through the BCC above, and we also
14938                                                                          ; know that A >= 96, so the C flag will still be set
14939                                                                          ; once we are done
14940               
14941               DV4:
14942 458E 0208  20        li   rarg1,T1                   ; ROL T1            ; Rotate the counter in T1 to the left, and catch the
     4590 0006     
14943 4592 06A0  28        bl   @rol                       ;
     4594 8028     
14944                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
14945                                                                          ; do the subtraction, or 1 if we did)
14946               
14947 4596 18F1  14        joc  DVL3                       ; BCS DVL3          ; If we still have set bits in T1, loop back to DVL3 to
14948                                                                          ; do the next iteration of 7
14949               
14950 4598 D020  30        movb @T1,ra                     ; LDA T1            ; Fetch the result from T1 into A
     459A 0006     
14951               
14952 459C F020  30        socb @T,ra                      ; ORA T             ; Give A the sign of the result that we stored above
     459E 00D1     
14953               
14954 45A0 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     45A2 800E     
14955               
14956               * ******************************************************************************
14957               *
14958               * Name: DV42
14959               * Type: Subroutine
14960               * Category: Maths (Arithmetic)
14961               * Summary: Calculate (P R) = 256 * DELTA / z_hi
14962               *
14963               * ------------------------------------------------------------------------------
14964               *
14965               * Calculate the following division and remainder:
14966               *
14967               * P = DELTA / (the Y-th stardust particle's z_hi coordinate)
14968               *
14969               * R = remainder as a fraction of A, where 1.0 = 255
14970               *
14971               * Another way of saying the above is this:
14972               *
14973               * (P R) = 256 * DELTA / z_hi
14974               *
14975               * DELTA is a value between 1 and 40, and the minimum z_hi is 16 (dust particles
14976               * are removed at lower values than this), so this means P is between 0 and 2
14977               * (as 40 / 16 = 2.5, so the maximum result is P = 2 and R = 128.
14978               *
14979               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
14980               * keep the remainder.
14981               *
14982               * ------------------------------------------------------------------------------
14983               *
14984               * Arguments:
14985               *
14986               * Y                   The number of the stardust particle to process
14987               *
14988               * ------------------------------------------------------------------------------
14989               *
14990               * Returns:
14991               *
14992               * C flag              The C flag is cleared
14993               *
14994               * ******************************************************************************
14995               
14996               DV42:
14997 45A4 D022  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Fetch the Y-th dust particle's z_hi coordinate into A
     45A6 0EE8     
14998               
14999                                                                          ; Fall through into DV41 to do:
15000                                                                          ;
15001                                                                          ; (P R) = 256 * DELTA / A
15002                                                                          ; = 256 * DELTA / Y-th stardust particle's z_hi
15003               
15004               * ******************************************************************************
15005               *
15006               * Name: DV41
15007               * Type: Subroutine
15008               * Category: Maths (Arithmetic)
15009               * Summary: Calculate (P R) = 256 * DELTA / A
15010               *
15011               * ------------------------------------------------------------------------------
15012               *
15013               * Calculate the following division and remainder:
15014               *
15015               * P = DELTA / A
15016               *
15017               * R = remainder as a fraction of A, where 1.0 = 255
15018               *
15019               * Another way of saying the above is this:
15020               *
15021               * (P R) = 256 * DELTA / A
15022               *
15023               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
15024               * keep the remainder.
15025               *
15026               * ------------------------------------------------------------------------------
15027               *
15028               * Returns:
15029               *
15030               * C flag              The C flag is cleared
15031               *
15032               * ******************************************************************************
15033               
15034               DV41:
15035 45A8 D800  30        movb ra,@Q                      ; STA Q             ; Store A in Q
     45AA 0090     
15036               
15037 45AC D020  30        movb @DELTA,ra                  ; LDA DELTA         ; Fetch the speed from DELTA into A
     45AE 008C     
15038               
15039                                                                          ; Fall through into DVID4 to do:
15040                                                                          ;
15041                                                                          ; (P R) = 256 * A / Q
15042                                                                          ; = 256 * DELTA / A
15043               
15044               * ******************************************************************************
15045               *
15046               * Name: DVID4
15047               * Type: Subroutine
15048               * Category: Maths (Arithmetic)
15049               * Summary: Calculate (P R) = 256 * A / Q
15050               * Deep dive: Shift-and-subtract division
15051               *
15052               * ------------------------------------------------------------------------------
15053               *
15054               * Calculate the following division and remainder:
15055               *
15056               * P = A / Q
15057               *
15058               * R = remainder as a fraction of Q, where 1.0 = 255
15059               *
15060               * Another way of saying the above is this:
15061               *
15062               * (P R) = 256 * A / Q
15063               *
15064               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
15065               * keep the remainder.
15066               *
15067               * ------------------------------------------------------------------------------
15068               *
15069               * Returns:
15070               *
15071               * C flag              The C flag is cleared
15072               *
15073               * ******************************************************************************
15074               
15075               DVID4:
15076 45B0 0201  20        li   rx,>08*256                 ; LDX #8            ; Set a counter in X to count the 8 bits in A
     45B2 0800     
15077               
15078                      .asla                           ; ASL A             ; Shift A left and store in P (we will build the result
     **** ****     > ASLA
0001 45B4 0240  22        andi ra,>ff00
     45B6 FF00     
0002 45B8 0A10  18        sla  ra,1
                   < elite.a99
15079 45BA D800  30        movb ra,@P                      ; STA P             ; in P)
     45BC 001B     
15080               
15081 45BE 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 for us to build a remainder
     45C0 0000     
15082               
15083               DVL4:
15084 45C2 06A0  28        bl   @rola                      ; ROL A             ; Shift A to the left
     45C4 8018     
15085               
15086 45C6 1803  14        joc  DV8                        ; BCS DV8           ; If the C flag is set (i.e. bit 7 of A was set) then
15087                                                                          ; skip straight to the subtraction
15088               
15089 45C8 9020  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     45CA 0090     
15090 45CC 1705  14        jnc  DV5                        ; BCC DV5
15091               
15092               DV8:
15093                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 45CE 1801  14        joc  !
0002 45D0 7004  18        sb   rone,ra
0003               !:
0004 45D2 7020  30        sb   @Q,ra
     45D4 0090     
                   < elite.a99
15094               
15095                      .sec                            ; SEC               ; Set the C flag, so that P gets a 1 shifted into bit 0
     **** ****     > SEC
0001 45D6 0A15  18        sla  rmone,1
                   < elite.a99
15096               
15097               DV5:
15098 45D8 0208  20        li   rarg1,P                    ; ROL P             ; Shift P to the left, pulling the C flag into bit 0
     45DA 001B     
15099 45DC 06A0  28        bl   @rol                       ;
     45DE 8028     
15100               
15101 45E0 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
15102               
15103 45E2 16EF  14        jne  DVL4                       ; BNE DVL4          ; Loop back for the next bit until we have done all 8
15104                                                                          ; bits of P
15105               
15106 45E4 0460  28        b    @LL28+4                    ; JMP LL28+4        ; Jump to LL28+4 to convert the remainder in A into an
     45E6 933C     
15107                                                                          ; integer representation of the fractional value A / Q,
15108                                                                          ; in R, where 1.0 = 255. LL28+4 always returns with the
15109                                                                          ; C flag cleared, and we return from the subroutine
15110                                                                          ; using a tail call
15111               
15112               * ******************************************************************************
15113               *
15114               * Name: DVID3B2
15115               * Type: Subroutine
15116               * Category: Maths (Arithmetic)
15117               * Summary: Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
15118               * Deep dive: Shift-and-subtract division
15119               *
15120               * ------------------------------------------------------------------------------
15121               *
15122               * Calculate the following:
15123               *
15124               * K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
15125               *
15126               * The actual division here is done as an 8-bit calculation using LL31, but this
15127               * routine shifts both the numerator (the top part of the division) and the
15128               * denominator (the bottom part of the division) around to get the multi-byte
15129               * result we want.
15130               *
15131               * Specifically, it shifts both of them to the left as far as possible, keeping a
15132               * tally of how many shifts get done in each one - and specifically, the
15133               * difference in the number of shifts between the top and bottom (as shifting
15134               * both of them once in the same direction won't change the result). It then
15135               * divides the two highest bytes with the simple 8-bit routine in LL31, and
15136               * shifts the result by the difference in the number of shifts, which acts as a
15137               * scale factor to get the correct result.
15138               *
15139               * ------------------------------------------------------------------------------
15140               *
15141               * Returns:
15142               *
15143               * K(3 2 1 0)          The result of the division
15144               *
15145               * X                   X is preserved
15146               *
15147               * ******************************************************************************
15148               
15149               DVID3B2:
15150 45E8 D800  30        movb ra,@P+2                    ; STA P+2           ; Set P+2 = A
     45EA 001D     
15151               
15152 45EC D020  30        movb @INWK+6,ra                 ; LDA INWK+6        ; Set Q = z_lo
     45EE 0059     
15153 45F0 D800  30        movb ra,@Q                      ; STA Q
     45F2 0090     
15154               
15155 45F4 D020  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set R = z_hi
     45F6 005A     
15156 45F8 D800  30        movb ra,@R                      ; STA R
     45FA 0091     
15157               
15158 45FC D020  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set S = z_sign
     45FE 005B     
15159 4600 D800  30        movb ra,@S                      ; STA S
     4602 0092     
15160               
15161               DVID3B:
15162                                                                          ; Given the above assignments, we now want to calculate
15163                                                                          ; the following to get the result we want:
15164                                                                          ;
15165                                                                          ; K(3 2 1 0) = P(2 1 0) / (S R Q)
15166 4604 D020  30        movb @P,ra                      ; LDA P             ; Make sure P(2 1 0) is at least 1
     4606 001B     
15167 4608 0260  22        ori  ra,>01*256                 ; ORA #1
     460A 0100     
15168 460C D800  30        movb ra,@P                      ; STA P
     460E 001B     
15169               
15170 4610 D020  30        movb @P+2,ra                    ; LDA P+2           ; Set T to the sign of P+2 * S (i.e. the sign of the
     4612 001D     
15171                      .eor @S                         ; EOR S             ; result) and store it in T
     **** ****     > EOR
0001 4614 D1A0  30        movb @S,rtmp
     4616 0092     
0002 4618 2806  18        xor  rtmp,ra
                   < elite.a99
15172 461A 0240  22        andi ra,>80*256                 ; AND #%10000000
     461C 8000     
15173 461E D800  30        movb ra,@T                      ; STA T
     4620 00D1     
15174               
15175 4622 0202  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0 to store the scale factor
     4624 0000     
15176               
15177 4626 D020  30        movb @P+2,ra                    ; LDA P+2           ; Clear the sign bit of P+2, so the division can be done
     4628 001D     
15178 462A 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; with positive numbers and we'll set the correct sign
     462C 7F00     
15179                                                                          ; below, once all the maths is done
15180                                                                          ;
15181                                                                          ; This also leaves A = P+2, which we use below
15182               
15183               DVL9:
15184                                                                          ; We now shift (A P+1 P) left until A >= 64, counting
15185                                                                          ; the number of shifts in Y. This makes the top part of
15186                                                                          ; the division as large as possible, thus retaining as
15187                                                                          ; much accuracy as we can.  When we come to return the
15188                                                                          ; final result, we shift the result by the number of
15189                                                                          ; places in Y, and in the correct direction
15190 462E 0280  22        ci   ra,>40*256                 ; CMP #64           ; If A >= 64, jump down to DV14
     4630 4000     
15191 4632 180F  14        joc  DV14                       ; BCS DV14
15192               
15193                      .asl @P                         ; ASL P             ; Shift (A P+1 P) to the left
     **** ****     > ASL
0001 4634 D1A0  30        movb @P,rtmp
     4636 001B     
0002 4638 0246  22        andi rtmp,>ff00
     463A FF00     
0003 463C 0A16  18        sla  rtmp,1
0004 463E D806  30        movb rtmp,@P
     4640 001B     
                   < elite.a99
15194 4642 0208  20        li   rarg1,P+1                  ; ROL P+1
     4644 001C     
15195 4646 06A0  28        bl   @rol                       ;
     4648 8028     
15196 464A 06A0  28        bl   @rola                      ; ROL A
     464C 8018     
15197               
15198 464E B084  18        ab   rone,ry                    ; INY               ; Increment the scale factor in Y
15199               
15200 4650 16EE  14        jne  DVL9                       ; BNE DVL9          ; Loop up to DVL9 (this BNE is effectively a JMP, as Y
15201                                                                          ; will never be zero)
15202               
15203               DV14:
15204                                                                          ; If we get here, A >= 64 and contains the highest byte
15205                                                                          ; of the numerator, scaled up by the number of left
15206                                                                          ; shifts in Y
15207 4652 D800  30        movb ra,@P+2                    ; STA P+2           ; Store A in P+2, so we now have the scaled value of
     4654 001D     
15208                                                                          ; the numerator in P(2 1 0)
15209               
15210 4656 D020  30        movb @S,ra                      ; LDA S             ; Set A = |S|
     4658 0092     
15211 465A 0240  22        andi ra,>7f*256                 ; AND #%01111111
     465C 7F00     
15212               
15213 465E 110F  14        jlt  DV9                        ; BMI DV9           ; If bit 7 of A is set, jump down to DV9 to skip the
15214                                                                          ; left-shifting of the denominator (though this branch
15215                                                                          ; instruction has no effect as bit 7 of the above AND
15216                                                                          ; can never be set, which is why this instruction was
15217                                                                          ; removed from later versions)
15218               
15219               DVL6:
15220                                                                          ; We now shift (S R Q) left until bit 7 of S is set,
15221                                                                          ; reducing Y by the number of shifts. This makes the
15222                                                                          ; bottom part of the division as large as possible, thus
15223                                                                          ; retaining as much accuracy as we can. When we come to
15224                                                                          ; return the final result, we shift the result by the
15225                                                                          ; total number of places in Y, and in the correct
15226                                                                          ; direction, to give us the correct result
15227                                                                          ;
15228                                                                          ; We set A to |S| above, so the following actually
15229                                                                          ; shifts (A R Q)
15230 4660 7084  18        sb   rone,ry                    ; DEY               ; Decrement the scale factor in Y
15231               
15232                      .asl @Q                         ; ASL Q             ; Shift (A R Q) to the left
     **** ****     > ASL
0001 4662 D1A0  30        movb @Q,rtmp
     4664 0090     
0002 4666 0246  22        andi rtmp,>ff00
     4668 FF00     
0003 466A 0A16  18        sla  rtmp,1
0004 466C D806  30        movb rtmp,@Q
     466E 0090     
                   < elite.a99
15233 4670 0208  20        li   rarg1,R                    ; ROL R
     4672 0091     
15234 4674 06A0  28        bl   @rol                       ;
     4676 8028     
15235 4678 06A0  28        bl   @rola                      ; ROL A
     467A 8018     
15236               
15237 467C 15F1  14        jgt  DVL6                       ; BPL DVL6          ; Loop up to DVL6 to do another shift, until bit 7 of A
15238                                                                          ; is set and we can't shift left any further
15239               
15240               DV9:
15241                                                                          ; We have now shifted both the numerator and denominator
15242                                                                          ; left as far as they will go, keeping a tally of the
15243                                                                          ; overall scale factor of the various shifts in Y. We
15244                                                                          ; can now divide just the two highest bytes to get our
15245                                                                          ; result
15246 467E D800  30        movb ra,@Q                      ; STA Q             ; Set Q = A, the highest byte of the denominator
     4680 0090     
15247               
15248 4682 0200  20        li   ra,>fe*256                 ; LDA #254          ; Set R to have bits 1-7 set, so we can pass this to
     4684 FE00     
15249 4686 D800  30        movb ra,@R                      ; STA R             ; LL31 to act as the bit counter in the division
     4688 0091     
15250               
15251 468A D020  30        movb @P+2,ra                    ; LDA P+2           ; Set A to the highest byte of the numerator
     468C 001D     
15252               
15253 468E 0206  20        li   rtmp,LL31                  ; JSR LL31          ; Call LL31 to calculate:
     4690 9346     
15254 4692 06A0  28        bl   @jsr                       ;
     4694 8002     
15255                                                                          ;
15256                                                                          ; R = 256 * A / Q
15257                                                                          ; = 256 * numerator / denominator
15258               
15259                                                                          ; The result of our division is now in R, so we just
15260                                                                          ; need to shift it back by the scale factor in Y
15261               
15262 4696 0200  20        li   ra,>00*256                 ; LDA #0            ; Set K(3 2 1) = 0 to hold the result (we populate K
     4698 0000     
15263 469A D800  30        movb ra,@K+1                    ; STA K+1           ; next)
     469C 003E     
15264 469E D800  30        movb ra,@K+2                    ; STA K+2
     46A0 003F     
15265 46A2 D800  30        movb ra,@K+3                    ; STA K+3
     46A4 0040     
15266               
15267 46A6 D002  18        movb ry,ra                      ; TYA               ; If Y is positive, jump to DV12
15268 46A8 1527  14        jgt  DV12                       ; BPL DV12
15269               
15270                                                                          ; If we get here then Y is negative, so we need to shift
15271                                                                          ; the result R to the left by Y places, and then set the
15272                                                                          ; correct sign for the result
15273               
15274 46AA D020  30        movb @R,ra                      ; LDA R             ; Set A = R
     46AC 0091     
15275               
15276               DVL8:
15277                      .asla                           ; ASL A             ; Shift (K+3 K+2 K+1 A) left
     **** ****     > ASLA
0001 46AE 0240  22        andi ra,>ff00
     46B0 FF00     
0002 46B2 0A10  18        sla  ra,1
                   < elite.a99
15278 46B4 0208  20        li   rarg1,K+1                  ; ROL K+1
     46B6 003E     
15279 46B8 06A0  28        bl   @rol                       ;
     46BA 8028     
15280 46BC 0208  20        li   rarg1,K+2                  ; ROL K+2
     46BE 003F     
15281 46C0 06A0  28        bl   @rol                       ;
     46C2 8028     
15282 46C4 0208  20        li   rarg1,K+3                  ; ROL K+3
     46C6 0040     
15283 46C8 06A0  28        bl   @rol                       ;
     46CA 8028     
15284               
15285 46CC B084  18        ab   rone,ry                    ; INY               ; Increment the scale factor in Y
15286               
15287 46CE 16EF  14        jne  DVL8                       ; BNE DVL8          ; Loop back to DVL8 until we have shifted left by Y
15288                                                                          ; places
15289               
15290 46D0 D800  30        movb ra,@K                      ; STA K             ; Store A in K so the result is now in K(3 2 1 0)
     46D2 003D     
15291               
15292 46D4 D020  30        movb @K+3,ra                    ; LDA K+3           ; Set K+3 to the sign in T, which we set above to the
     46D6 0040     
15293 46D8 F020  30        socb @T,ra                      ; ORA T             ; correct sign for the result
     46DA 00D1     
15294 46DC D800  30        movb ra,@K+3                    ; STA K+3
     46DE 0040     
15295               
15296 46E0 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     46E2 800E     
15297               
15298               DV13:
15299                                                                          ; If we get here then Y is zero, so we don't need to
15300                                                                          ; shift the result R, we just need to set the correct
15301                                                                          ; sign for the result
15302 46E4 D020  30        movb @R,ra                      ; LDA R             ; Store R in K so the result is now in K(3 2 1 0)
     46E6 0091     
15303 46E8 D800  30        movb ra,@K                      ; STA K
     46EA 003D     
15304               
15305 46EC D020  30        movb @T,ra                      ; LDA T             ; Set K+3 to the sign in T, which we set above to the
     46EE 00D1     
15306 46F0 D800  30        movb ra,@K+3                    ; STA K+3           ; correct sign for the result
     46F2 0040     
15307               
15308 46F4 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     46F6 800E     
15309               
15310               DV12:
15311 46F8 13F5  14        jeq  DV13                       ; BEQ DV13          ; We jumped here having set A to the scale factor in Y,
15312                                                                          ; so this jumps up to DV13 if Y = 0
15313               
15314                                                                          ; If we get here then Y is positive and non-zero, so we
15315                                                                          ; need to shift the result R to the right by Y places
15316                                                                          ; and then set the correct sign for the result. We also
15317                                                                          ; know that K(3 2 1) will stay 0, as we are shifting the
15318                                                                          ; lowest byte to the right, so no set bits will make
15319                                                                          ; their way into the top three bytes
15320               
15321 46FA D020  30        movb @R,ra                      ; LDA R             ; Set A = R
     46FC 0091     
15322               
15323               DVL10:
15324 46FE 0910  18        srl  ra,1                       ; LSR A             ; Shift A right
15325               
15326 4700 7084  18        sb   rone,ry                    ; DEY               ; Decrement the scale factor in Y
15327               
15328 4702 16FD  14        jne  DVL10                      ; BNE DVL10         ; Loop back to DVL10 until we have shifted right by Y
15329                                                                          ; places
15330               
15331 4704 D800  30        movb ra,@K                      ; STA K             ; Store the shifted A in K so the result is now in
     4706 003D     
15332                                                                          ; K(3 2 1 0)
15333               
15334 4708 D020  30        movb @T,ra                      ; LDA T             ; Set K+3 to the sign in T, which we set above to the
     470A 00D1     
15335 470C D800  30        movb ra,@K+3                    ; STA K+3           ; correct sign for the result
     470E 0040     
15336               
15337 4710 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4712 800E     
15338               
15339               * ******************************************************************************
15340               *
15341               * Name: cntr
15342               * Type: Subroutine
15343               * Category: Dashboard
15344               * Summary: Apply damping to the pitch or roll dashboard indicator
15345               *
15346               * ------------------------------------------------------------------------------
15347               *
15348               * Apply damping to the value in X, where X ranges from 1 to 255 with 128 as the
15349               * centre point (so X represents a position on a centre-based dashboard slider,
15350               * such as pitch or roll). If the value is in the left-hand side of the slider
15351               * (1-127) then it bumps the value up by 1 so it moves towards the centre, and
15352               * if it's in the right-hand side, it reduces it by 1, also moving it towards the
15353               * centre.
15354               *
15355               * ******************************************************************************
15356               
15357               cntr_:
15358 4714 D020  30        movb @DAMP,ra                   ; LDA DAMP          ; If DAMP is non-zero, then keyboard damping is not
     4716 0F4A     
15359 4718 1608  14        jne  RE1                        ; BNE RE1           ; enabled, so jump to RE1 to return from the subroutine
15360               
15361 471A D001  18        movb rx,ra                      ; TXA               ; If X < 128, then it's in the left-hand side of the
15362 471C 1502  14        jgt  BUMP                       ; BPL BUMP          ; dashboard slider, so jump to BUMP to bump it up by 1,
15363                                                                          ; to move it closer to the centre
15364               
15365 471E 7044  18        sb   rone,rx                    ; DEX               ; Otherwise X >= 128, so it's in the right-hand side
15366 4720 1104  14        jlt  RE1                        ; BMI RE1           ; of the dashboard slider, so decrement X by 1, and if
15367                                                                          ; it's still >= 128, jump to RE1 to return from the
15368                                                                          ; subroutine, otherwise fall through to BUMP to undo
15369                                                                          ; the bump and then return
15370               
15371               BUMP:
15372 4722 B044  18        ab   rone,rx                    ; INX               ; Bump X up by 1, and if it hasn't overshot the end of
15373 4724 1602  14        jne  RE1                        ; BNE RE1           ; the dashboard slider, jump to RE1 to return from the
15374                                                                          ; subroutine, otherwise fall through to REDU to drop
15375                                                                          ; it down by 1 again
15376               
15377               REDU:
15378 4726 7044  18        sb   rone,rx                    ; DEX               ; Reduce X by 1, and if we have reached 0 jump up to
15379 4728 13FC  14        jeq  BUMP                       ; BEQ BUMP          ; BUMP to add 1, because we need the value to be in the
15380                                                                          ; range 1 to 255
15381               
15382               RE1:
15383 472A 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     472C 800E     
15384               
15385               * ******************************************************************************
15386               *
15387               * Name: BUMP2
15388               * Type: Subroutine
15389               * Category: Dashboard
15390               * Summary: Bump up the value of the pitch or roll dashboard indicator
15391               *
15392               * ------------------------------------------------------------------------------
15393               *
15394               * Increase ("bump up") X by A, where X is either the current rate of pitch or
15395               * the current rate of roll.
15396               *
15397               * The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
15398               * This is the amount by which the pitch or roll is currently changing, so 1
15399               * means it is decreasing at the maximum rate, 128 means it is not changing,
15400               * and 255 means it is increasing at the maximum rate. These values correspond
15401               * to the line on the DC or RL indicators on the dashboard, with 1 meaning full
15402               * left, 128 meaning the middle, and 255 meaning full right.
15403               *
15404               * If bumping up X would push it past 255, then X is set to 255.
15405               *
15406               * If keyboard auto-recentre is configured and the result is less than 128, we
15407               * bump X up to the mid-point, 128. This is the equivalent of having a roll or
15408               * pitch in the left half of the indicator, when increasing the roll or pitch
15409               * should jump us straight to the mid-point.
15410               *
15411               * ------------------------------------------------------------------------------
15412               *
15413               * Other entry points:
15414               *
15415               * RE2+2               Restore A from T and return from the subroutine
15416               *
15417               * ******************************************************************************
15418               
15419               BUMP2:
15420 472E D800  30        movb ra,@T                      ; STA T             ; Store argument A in T so we can restore it later
     4730 00D1     
15421               
15422 4732 D001  18        movb rx,ra                      ; TXA               ; Copy argument X into A
15423               
15424                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 4734 0A13  18        sla  rzero,1
                   < elite.a99
15425                                                                          ; C flag affecting the result
15426               
15427                      .adc @T,ra                      ; ADC T             ; Set X = A = argument X + argument A
     **** ****     > ADC
0001 4736 1701  14        jnc  !
0002 4738 B004  18        ab   rone,ra
0003               !:
0004 473A B020  30        ab   @T,ra
     473C 00D1     
                   < elite.a99
15428 473E D040  18        movb ra,rx                      ; TAX
15429               
15430 4740 1702  14        jnc  RE2                        ; BCC RE2           ; If the C flag is clear, then we didn't overflow, so
15431                                                                          ; jump to RE2 to auto-recentre and return the result
15432               
15433 4742 0201  20        li   rx,>ff*256                 ; LDX #255          ; We have an overflow, so set X to the maximum possible
     4744 FF00     
15434                                                                          ; value of 255
15435               
15436               RE2:
15437 4746 1511  14        jgt  RE3+2                      ; BPL RE3+2         ; If X has bit 7 clear (i.e. the result < 128), then
15438                                                                          ; jump to RE3+2 in routine REDU2 to do an auto-recentre,
15439                                                                          ; if configured, because the result is on the left side
15440                                                                          ; of the centre point of 128
15441               
15442                                                                          ; Jumps to RE2+2 end up here
15443               
15444 4748 D020  30        movb @T,ra                      ; LDA T             ; Restore the original argument A from T into A
     474A 00D1     
15445               
15446 474C 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     474E 800E     
15447               
15448               * ******************************************************************************
15449               *
15450               * Name: REDU2
15451               * Type: Subroutine
15452               * Category: Dashboard
15453               * Summary: Reduce the value of the pitch or roll dashboard indicator
15454               *
15455               * ------------------------------------------------------------------------------
15456               *
15457               * Reduce X by A, where X is either the current rate of pitch or the current
15458               * rate of roll.
15459               *
15460               * The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
15461               * This is the amount by which the pitch or roll is currently changing, so 1
15462               * means it is decreasing at the maximum rate, 128 means it is not changing,
15463               * and 255 means it is increasing at the maximum rate. These values correspond
15464               * to the line on the DC or RL indicators on the dashboard, with 1 meaning full
15465               * left, 128 meaning the middle, and 255 meaning full right.
15466               *
15467               * If reducing X would bring it below 1, then X is set to 1.
15468               *
15469               * If keyboard auto-recentre is configured and the result is greater than 128, we
15470               * reduce X down to the mid-point, 128. This is the equivalent of having a roll
15471               * or pitch in the right half of the indicator, when decreasing the roll or pitch
15472               * should jump us straight to the mid-point.
15473               *
15474               * ------------------------------------------------------------------------------
15475               *
15476               * Other entry points:
15477               *
15478               * RE3+2               Auto-recentre the value in X, if keyboard auto-recentre
15479               * is configured
15480               *
15481               * ******************************************************************************
15482               
15483               REDU2:
15484 4750 D800  30        movb ra,@T                      ; STA T             ; Store argument A in T so we can restore it later
     4752 00D1     
15485               
15486 4754 D001  18        movb rx,ra                      ; TXA               ; Copy argument X into A
15487               
15488                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 4756 0A15  18        sla  rmone,1
                   < elite.a99
15489                                                                          ; C flag affecting the result
15490               
15491                      .sbc @T,ra                      ; SBC T             ; Set X = A = argument X - argument A
     **** ****     > SBC
0001 4758 1801  14        joc  !
0002 475A 7004  18        sb   rone,ra
0003               !:
0004 475C 7020  30        sb   @T,ra
     475E 00D1     
                   < elite.a99
15492 4760 D040  18        movb ra,rx                      ; TAX
15493               
15494 4762 1802  14        joc  RE3                        ; BCS RE3           ; If the C flag is set, then we didn't underflow, so
15495                                                                          ; jump to RE3 to auto-recentre and return the result
15496               
15497 4764 0201  20        li   rx,>01*256                 ; LDX #1            ; We have an underflow, so set X to the minimum possible
     4766 0100     
15498                                                                          ; value, 1
15499               
15500               RE3:
15501 4768 15EF  14        jgt  RE2+2                      ; BPL RE2+2         ; If X has bit 7 clear (i.e. the result < 128), then
15502                                                                          ; jump to RE2+2 above to return the result as is,
15503                                                                          ; because the result is on the left side of the centre
15504                                                                          ; point of 128, so we don't need to auto-centre
15505               
15506                                                                          ; Jumps to RE3+2 end up here
15507               
15508                                                                          ; If we get here, then we need to apply auto-recentre,
15509                                                                          ; if it is configured
15510               
15511 476A D020  30        movb @DJD,ra                    ; LDA DJD           ; If keyboard auto-recentre is disabled, then
     476C 0F4B     
15512 476E 16EC  14        jne  RE2+2                      ; BNE RE2+2         ; jump to RE2+2 to restore A and return
15513               
15514 4770 0201  20        li   rx,>80*256                 ; LDX #128          ; If we get here then keyboard auto-recentre is enabled,
     4772 8000     
15515 4774 11E9  14        jlt  RE2+2                      ; BMI RE2+2         ; so set X to 128 (the middle of our range) and jump to
15516                                                                          ; RE2+2 to restore A and return from the subroutine
15517                                                                          ; (this BMI is effectively a JMP as bit 7 of X is always
15518                                                                          ; set)
15519               
15520               * ******************************************************************************
15521               *
15522               * Name: ARCTAN
15523               * Type: Subroutine
15524               * Category: Maths (Geometry)
15525               * Summary: Calculate A = arctan(P / Q)
15526               * Deep dive: The sine, cosine and arctan tables
15527               *
15528               * ------------------------------------------------------------------------------
15529               *
15530               * Calculate the following:
15531               *
15532               * A = arctan(P / Q)
15533               *
15534               * In other words, this finds the angle in the right-angled triangle where the
15535               * opposite side to angle A is length P and the adjacent side to angle A has
15536               * length Q, so:
15537               *
15538               * tan(A) = P / Q
15539               *
15540               * The result in A is an integer representing the angle in radians. The routine
15541               * returns values in the range 0 to 128, which covers 0 to 180 degrees (or 0 to
15542               * PI radians).
15543               *
15544               * ******************************************************************************
15545               
15546               ARCTAN:
15547 4776 D020  30        movb @P,ra                      ; LDA P             ; Set T1 = P EOR Q, which will have the sign of P * Q
     4778 001B     
15548                      .eor @Q                         ; EOR Q             ;
     **** ****     > EOR
0001 477A D1A0  30        movb @Q,rtmp
     477C 0090     
0002 477E 2806  18        xor  rtmp,ra
                   < elite.a99
15549               * AND #%10000000         \ The AND is commented out in the original source
15550 4780 D800  30        movb ra,@T1                     ; STA T1
     4782 0006     
15551               
15552 4784 D020  30        movb @Q,ra                      ; LDA Q             ; If Q = 0, jump to AR2 to return a right angle
     4786 0090     
15553 4788 132B  14        jeq  AR2                        ; BEQ AR2
15554               
15555                      .asla                           ; ASL A             ; Set Q = |Q| * 2 (this is a quick way of clearing the
     **** ****     > ASLA
0001 478A 0240  22        andi ra,>ff00
     478C FF00     
0002 478E 0A10  18        sla  ra,1
                   < elite.a99
15556 4790 D800  30        movb ra,@Q                      ; STA Q             ; sign bit, and we don't need to shift right again as we
     4792 0090     
15557                                                                          ; only ever use this value in the division with |P| * 2,
15558                                                                          ; which we set next)
15559               
15560 4794 D020  30        movb @P,ra                      ; LDA P             ; Set A = |P| * 2
     4796 001B     
15561                      .asla                           ; ASL A
     **** ****     > ASLA
0001 4798 0240  22        andi ra,>ff00
     479A FF00     
0002 479C 0A10  18        sla  ra,1
                   < elite.a99
15562               
15563 479E 9020  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, i.e. |P| > |Q|, jump to AR1 to swap P
     47A0 0090     
15564 47A2 180A  14        joc  AR1                        ; BCS AR1           ; and Q around, so we can still use the lookup table
15565               
15566 47A4 0206  20        li   rtmp,ARS1                  ; JSR ARS1          ; Call ARS1 to set the following from the lookup table:
     47A6 47FC     
15567 47A8 06A0  28        bl   @jsr                       ;
     47AA 8002     
15568                                                                          ;
15569                                                                          ; A = arctan(A / Q)
15570                                                                          ; = arctan(|P / Q|)
15571               
15572                      .sec                            ; SEC               ; Set the C flag so the SBC instruction in AR3 will be
     **** ****     > SEC
0001 47AC 0A15  18        sla  rmone,1
                   < elite.a99
15573                                                                          ; correct, should we jump there
15574               
15575               AR4:
15576 47AE D060  30        movb @T1,rx                     ; LDX T1            ; If T1 is negative, i.e. P and Q have different signs,
     47B0 0006     
15577 47B2 111A  14        jlt  AR3                        ; BMI AR3           ; jump down to AR3 to return arctan(-|P / Q|)
15578               
15579 47B4 0460  24        b    @rts                       ; RTS               ; Otherwise P and Q have the same sign, so our result is
     47B6 800E     
15580                                                                          ; correct and we can return from the subroutine
15581               
15582               AR1:
15583                                                                          ; We want to calculate arctan(t) where |t| > 1, so we
15584                                                                          ; can use the calculation described in the documentation
15585                                                                          ; for the ACT table, i.e. 64 - arctan(1 / t)
15586 47B8 D060  30        movb @Q,rx                      ; LDX Q             ; Swap the values in Q and P, using the fact that we
     47BA 0090     
15587 47BC D800  30        movb ra,@Q                      ; STA Q             ; called AR1 with A = P
     47BE 0090     
15588 47C0 D801  30        movb rx,@P                      ; STX P             ;
     47C2 001B     
15589 47C4 D001  18        movb rx,ra                      ; TXA               ; This also sets A = P (which now contains the original
15590                                                                          ; argument |Q|)
15591               
15592 47C6 0206  20        li   rtmp,ARS1                  ; JSR ARS1          ; Call ARS1 to set the following from the lookup table:
     47C8 47FC     
15593 47CA 06A0  28        bl   @jsr                       ;
     47CC 8002     
15594                                                                          ;
15595                                                                          ; A = arctan(A / Q)
15596                                                                          ; = arctan(|Q / P|)
15597                                                                          ; = arctan(1 / |P / Q|)
15598               
15599 47CE D800  30        movb ra,@T                      ; STA T             ; Set T = 64 - T
     47D0 00D1     
15600 47D2 0200  20        li   ra,>40*256                 ; LDA #64
     47D4 4000     
15601                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 47D6 1801  14        joc  !
0002 47D8 7004  18        sb   rone,ra
0003               !:
0004 47DA 7020  30        sb   @T,ra
     47DC 00D1     
                   < elite.a99
15602               
15603 47DE 18E7  14        joc  AR4                        ; BCS AR4           ; Jump to AR4 to continue the calculation (this BCS is
15604                                                                          ; effectively a JMP as the subtraction will never
15605                                                                          ; underflow, as ARS1 returns values in the range 0-31)
15606               
15607               AR2:
15608                                                                          ; If we get here then Q = 0, so tan(A) = infinity and
15609                                                                          ; A is a right angle, or 0.25 of a circle. We allocate
15610                                                                          ; 255 to a full circle, so we should return 63 for a
15611                                                                          ; right angle
15612 47E0 0200  20        li   ra,>3f*256                 ; LDA #63           ; Set A to 63, to represent a right angle
     47E2 3F00     
15613               
15614 47E4 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     47E6 800E     
15615               
15616               AR3:
15617                                                                          ; A contains arctan(|P / Q|) but P and Q have different
15618                                                                          ; signs, so we need to return arctan(-|P / Q|), using
15619                                                                          ; the calculation described in the documentation for the
15620                                                                          ; ACT table, i.e. 128 - A
15621 47E8 D800  30        movb ra,@T                      ; STA T             ; Set A = 128 - A
     47EA 00D1     
15622 47EC 0200  20        li   ra,>80*256                 ; LDA #128          ;
     47EE 8000     
15623               * SEC                    \ The SEC instruction is commented out in the original
15624                      .sbc @T,ra                      ; SBC T             ; source, and isn't required as we did a SEC before
     **** ****     > SBC
0001 47F0 1801  14        joc  !
0002 47F2 7004  18        sb   rone,ra
0003               !:
0004 47F4 7020  30        sb   @T,ra
     47F6 00D1     
                   < elite.a99
15625                                                                          ; calling AR3
15626               
15627 47F8 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     47FA 800E     
15628               
15629               ARS1:
15630                                                                          ; This routine fetches arctan(A / Q) from the ACT table,
15631                                                                          ; so A will be set to an integer in the range 0 to 31
15632                                                                          ; that represents an angle from 0 to 45 degrees (or 0 to
15633                                                                          ; PI / 4 radians)
15634 47FC 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     47FE 9338     
15635 4800 06A0  28        bl   @jsr                       ;
     4802 8002     
15636                                                                          ;
15637                                                                          ; R = 256 * A / Q
15638               
15639 4804 D020  30        movb @R,ra                      ; LDA R             ; Set X = R / 8
     4806 0091     
15640 4808 0910  18        srl  ra,1                       ; LSR A             ; = 32 * A / Q
15641 480A 0910  18        srl  ra,1                       ; LSR A             ;
15642 480C 0910  18        srl  ra,1                       ; LSR A             ; so X has the value t * 32 where t = A / Q, which is
15643 480E D040  18        movb ra,rx                      ; TAX               ; what we need to look up values in the ACT table
15644               
15645 4810 D021  34        movb @ACT(rx),ra                ; LDA ACT,X         ; Fetch ACT+X from the ACT table into A, so now:
     4812 4818     
15646                                                                          ;
15647                                                                          ; A = value in ACT + X
15648                                                                          ; = value in ACT + (32 * A / Q)
15649                                                                          ; = arctan(A / Q)
15650               
15651 4814 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4816 800E     
15652               
15653               * ******************************************************************************
15654               *
15655               * Name: ACT
15656               * Type: Variable
15657               * Category: Maths (Geometry)
15658               * Summary: Arctan table
15659               * Deep dive: The sine, cosine and arctan tables
15660               *
15661               * ------------------------------------------------------------------------------
15662               *
15663               * This table contains lookup values for arctangent calculations involving angles
15664               * in the range 0 to 45 degrees (or 0 to PI / 4 radians).
15665               *
15666               * To calculate the value of theta in the following:
15667               *
15668               * theta = arctan(t)
15669               *
15670               * where 0 <= t < 1, we look up the value in:
15671               *
15672               * ACT + (t * 32)
15673               *
15674               * The result will be an integer representing the angle in radians, where 256
15675               * represents a full circle of 360 degrees (2 * PI radians). The result of the
15676               * lookup will therefore be an integer in the range 0 to 31, as this represents
15677               * 0 to 45 degrees (0 to PI / 4 radians).
15678               *
15679               * The table does not support values of t >= 1 or t < 0 directly, so if we need
15680               * to calculate the arctangent for an angle greater than 45 degrees, we can apply
15681               * the following calculation to the result from the table:
15682               *
15683               * * For t > 1, arctan(t) = 64 - arctan(1 / t)
15684               *
15685               * For negative values of t where -1 < t < 0, we can apply the following
15686               * calculation to the result from the table:
15687               *
15688               * * For t < 0, arctan(-t) = 128 - arctan(t)
15689               *
15690               * Finally, if t < -1, we can do the first calculation to get arctan(|t|), and
15691               * the second to get arctan(-|t|).
15692               *
15693               * ******************************************************************************
15694               
15695               ACT:
15696                      ; FOR I%, 0, 31
15697               
15698                      ; EQUB INT((128 / PI) * ATN(I% / 32) + 0.5) ;
15699               
15700                      ; NEXT
15701               
15702 4818 12              byte >12
15703 4819   13            byte >13
15704 481A 14              byte >14
15705 481B   15            byte >15
15706 481C 16              byte >16
15707 481D   17            byte >17
15708 481E 18              byte >18
15709 481F   19            byte >19
15710 4820 1A              byte >1a
15711 4821   1B            byte >1b
15712 4822 1B              byte >1b
15713 4823   1C            byte >1c
15714 4824 1D              byte >1d
15715 4825   1D            byte >1d
15716 4826 1E              byte >1e
15717 4827   1F            byte >1f
15718 4828 20              byte >20
15719 4829   20            byte >20
15720 482A 21              byte >21
15721 482B   21            byte >21
15722 482C 22              byte >22
15723 482D   22            byte >22
15724 482E 23              byte >23
15725 482F   24            byte >24
15726 4830 24              byte >24
15727 4831   24            byte >24
15728 4832 25              byte >25
15729 4833   25            byte >25
15730 4834 26              byte >26
15731 4835   26            byte >26
15732 4836 27              byte >27
15733 4837   27            byte >27
15734               
15735               * ******************************************************************************
15736               *
15737               * Name: WARP
15738               * Type: Subroutine
15739               * Category: Flight
15740               * Summary: Perform an in-system jump
15741               *
15742               * ------------------------------------------------------------------------------
15743               *
15744               * This is called when we press "J" during flight. The following checks are
15745               * performed:
15746               *
15747               * * Make sure we don't have any ships or space stations in the vicinity
15748               *
15749               * * Make sure we are not in witchspace
15750               *
15751               * * If we are facing the planet, make sure we aren't too close
15752               *
15753               * * If we are facing the sun, make sure we aren't too close
15754               *
15755               * If the above checks are passed, then we perform an in-system jump by moving
15756               * the sun and planet in the opposite direction to travel, so we appear to jump
15757               * in space. This means that any asteroids, cargo canisters or escape pods get
15758               * dragged along for the ride.
15759               *
15760               * ******************************************************************************
15761               
15762               WARP:
15773               
15774 4838 D020  30        movb @MANY+AST,ra               ; LDA MANY+AST      ; Set X to the total number of asteroids, escape pods
     483A 0D57     
15775                      .clc                            ; CLC               ; and cargo canisters in the vicinity
     **** ****     > CLC
0001 483C 0A13  18        sla  rzero,1
                   < elite.a99
15776                      .adc @MANY+ESC,ra               ; ADC MANY+ESC      ;
     **** ****     > ADC
0001 483E 1701  14        jnc  !
0002 4840 B004  18        ab   rone,ra
0003               !:
0004 4842 B020  30        ab   @MANY+ESC,ra
     4844 0D5A     
                   < elite.a99
15777                      .adc @MANY+OIL,ra               ; ADC MANY+OIL      ; This code saves one byte of memory over the code in
     **** ****     > ADC
0001 4846 1701  14        jnc  !
0002 4848 B004  18        ab   rone,ra
0003               !:
0004 484A B020  30        ab   @MANY+OIL,ra
     484C 0D58     
                   < elite.a99
15778 484E D040  18        movb ra,rx                      ; TAX               ; the source disc version. The second CLC is not needed
15779                                                                          ; as there is no way that adding the number of asteroids
15780                                                                          ; and the number of escape pods will cause a carry
15781               
15783               
15784 4850 D021  34        movb @FRIN+2(rx),ra             ; LDA FRIN+2,X      ; If the slot at FRIN+2+X is non-zero, then we have
     4852 0D42     
15785                                                                          ; something else in the vicinity besides asteroids,
15786                                                                          ; escape pods and cargo canisters, so to check whether
15787                                                                          ; we can jump, we first grab the slot contents into A
15788               
15789 4854 F020  30        socb @SSPR,ra                   ; ORA SSPR          ; If there is a space station nearby, then SSPR will
     4856 0D55     
15790                                                                          ; be non-zero, so OR'ing with SSPR will produce a
15791                                                                          ; non-zero result if either A or SSPR are non-zero
15792               
15793 4858 F020  30        socb @MJ,ra                     ; ORA MJ            ; If we are in witchspace, then MJ will be non-zero, so
     485A 0D5C     
15794                                                                          ; OR'ing with MJ will produce a non-zero result if
15795                                                                          ; either A or SSPR or MJ are non-zero
15796               
15797 485C 163A  14        jne  WA1                        ; BNE WA1           ; A is non-zero if we have either a ship or a space
15798                                                                          ; station in the vicinity, or we are in witchspace, in
15799                                                                          ; which case jump to WA1 to make a low beep to show that
15800                                                                          ; we can't do an in-system jump
15801               
15802 485E D0A0  30        movb @K.+8,ry                   ; LDY K%+8          ; Otherwise we can do an in-system jump, so now we fetch
     4860 0908     
15803                                                                          ; the byte at K%+8, which contains the z_sign for the
15804                                                                          ; first ship slot, i.e. the distance of the planet
15805               
15806 4862 1107  14        jlt  WA3                        ; BMI WA3           ; If the planet's z_sign is negative, then the planet
15807                                                                          ; is behind us, so jump to WA3 to skip the following
15808               
15809 4864 D080  18        movb ra,ry                      ; TAY               ; Set A = Y = 0 (as we didn't BNE above) so the call
15810                                                                          ; to MAS2 measures the distance to the planet
15811               
15812 4866 0206  20        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to set A to the largest distance to the
     4868 1786     
15813 486A 06A0  28        bl   @jsr                       ;
     486C 8002     
15814                                                                          ; planet in any of the three axes (we could also call
15815                                                                          ; routine m to do the same thing, as A = 0)
15816               
15824               
15825 486E 0910  18        srl  ra,1                       ; LSR A             ; If A < 2 then jump to WA1 to abort the in-system jump
15826 4870 1330  14        jeq  WA1                        ; BEQ WA1           ; with a low beep, as we are facing the planet and are
15827                                                                          ; too close to jump in that direction
15828                                                                          ;
15829                                                                          ; These instructions between them save one byte of
15830                                                                          ; memory over the CMP-based code in the source disc
15831                                                                          ; version, as LSR A is a one-byte opcode, while CMP #2
15832                                                                          ; takes up two bytes (though the code does exactly the
15833                                                                          ; same thing)
15834               
15836               
15837               WA3:
15838 4872 D0A0  30        movb @K.+NI.+8,ry               ; LDY K%+NI%+8      ; Fetch the z_sign (byte #8) of the second ship in the
     4874 092C     
15839                                                                          ; ship data workspace at K%, which is reserved for the
15840                                                                          ; sun or the space station (in this case it's the
15841                                                                          ; former, as we already confirmed there isn't a space
15842                                                                          ; station in the vicinity)
15843               
15844 4876 1108  14        jlt  WA2                        ; BMI WA2           ; If the sun's z_sign is negative, then the sun is
15845                                                                          ; behind us, so jump to WA2 to skip the following
15846               
15847 4878 0202  20        li   ry,(NI.)*256               ; LDY #NI%          ; Set Y to point to the offset of the ship data block
     487A 2400     
15848                                                                          ; for the sun, which is NI% (as each block is NI% bytes
15849                                                                          ; long, and the sun is the second block)
15850               
15851 487C 0206  20        li   rtmp,m_                    ; JSR m             ; Call m to set A to the largest distance to the sun
     487E 1782     
15852 4880 06A0  28        bl   @jsr                       ;
     4882 8002     
15853                                                                          ; in any of the three axes
15854               
15862               
15863 4884 0910  18        srl  ra,1                       ; LSR A             ; If A < 2 then jump to WA1 to abort the in-system jump
15864 4886 1325  14        jeq  WA1                        ; BEQ WA1           ; with a low beep, as we are facing the planet and are
15865                                                                          ; too close to jump in that direction
15866                                                                          ;
15867                                                                          ; These instructions between them save one byte of
15868                                                                          ; memory over the CMP-based code in the source disc
15869                                                                          ; version, as LSR A is a one-byte opcode, while CMP #2
15870                                                                          ; takes up two bytes (though the code does exactly the
15871                                                                          ; same thing)
15872               
15874               
15875               WA2:
15876                                                                          ; If we get here, then we can do an in-system jump, as
15877                                                                          ; we don't have any ships or space stations in the
15878                                                                          ; vicinity, we are not in witchspace, and if we are
15879                                                                          ; facing the planet or the sun, we aren't too close to
15880                                                                          ; jump towards it
15881                                                                          ;
15882                                                                          ; We do an in-system jump by moving the sun and planet,
15883                                                                          ; rather than moving our own local bubble (this is why
15884                                                                          ; in-system jumps drag asteroids, cargo canisters and
15885                                                                          ; escape pods along for the ride). Specifically, we move
15886                                                                          ; them in the z-axis by a fixed amount in the opposite
15887                                                                          ; direction to travel, thus performing a jump towards
15888                                                                          ; our destination
15889 4888 0200  20        li   ra,>81*256                 ; LDA #&81          ; Set R = R = P = &81
     488A 8100     
15890 488C D800  30        movb ra,@S                      ; STA S
     488E 0092     
15891 4890 D800  30        movb ra,@R                      ; STA R
     4892 0091     
15892 4894 D800  30        movb ra,@P                      ; STA P
     4896 001B     
15893               
15894 4898 D020  30        movb @K.+8,ra                   ; LDA K%+8          ; Set A = z_sign for the planet
     489A 0908     
15895               
15896 489C 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     489E 44BA     
15897 48A0 06A0  28        bl   @jsr                       ;
     48A2 8002     
15898                                                                          ; = (z_sign &81) + &8181
15899                                                                          ; = (z_sign &81) - &0181
15900                                                                          ;
15901                                                                          ; This moves the planet against the direction of travel
15902                                                                          ; by reducing z_sign by 1, as the above maths is:
15903                                                                          ;
15904                                                                          ; z_sign 00000000
15905                                                                          ; +   00000000 10000001
15906                                                                          ; -   00000001 10000001
15907                                                                          ;
15908                                                                          ; or:
15909                                                                          ;
15910                                                                          ; z_sign 00000000
15911                                                                          ; +   00000000 00000000
15912                                                                          ; -   00000001 00000000
15913                                                                          ;
15914                                                                          ; i.e. the high byte is z_sign - 1, making sure the sign
15915                                                                          ; is preserved
15916               
15917 48A4 D800  30        movb ra,@K.+8                   ; STA K%+8          ; Set the planet's z_sign to the high byte of the result
     48A6 0908     
15918               
15919 48A8 D020  30        movb @K.+NI.+8,ra               ; LDA K%+NI%+8      ; Set A = z_sign for the sun
     48AA 092C     
15920               
15921 48AC 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     48AE 44BA     
15922 48B0 06A0  28        bl   @jsr                       ;
     48B2 8002     
15923                                                                          ; = (z_sign &81) + &8181
15924                                                                          ; = (z_sign &81) - &0181
15925                                                                          ;
15926                                                                          ; which moves the sun against the direction of travel
15927                                                                          ; by reducing z_sign by 1
15928               
15929 48B4 D800  30        movb ra,@K.+NI.+8               ; STA K%+NI%+8      ; Set the planet's z_sign to the high byte of the result
     48B6 092C     
15930               
15931 48B8 0200  20        li   ra,>01*256                 ; LDA #1            ; Temporarily set the view type to a non-zero value, so
     48BA 0100     
15932 48BC D800  30        movb ra,@QQ11                   ; STA QQ11          ; the call to LOOK1 below clears the screen before
     48BE 0096     
15933                                                                          ; switching to the space view
15934               
15935 48C0 D800  30        movb ra,@MCNT                   ; STA MCNT          ; Set the main loop counter to 1, so the next iteration
     48C2 0099     
15936                                                                          ; through the main loop will potentially spawn ships
15937                                                                          ; (see part 2 of the main game loop at me3)
15938               
15939 48C4 0910  18        srl  ra,1                       ; LSR A             ; Set EV, the extra vessels spawning counter, to 0
15940 48C6 D800  30        movb ra,@EV                     ; STA EV            ; (the LSR produces a 0 as A was previously 1)
     48C8 0D63     
15941               
15942 48CA D060  30        movb @VIEW,rx                   ; LDX VIEW          ; Set X to the current view (front, rear, left or right)
     48CC 0D5F     
15943 48CE 0460  28        b    @LOOK1                     ; JMP LOOK1         ; and jump to LOOK1 to initialise that view, returning
     48D0 4AC4     
15944                                                                          ; from the subroutine using a tail call
15945               
15946               WA1:
15947 48D2 0200  20        li   ra,>28*256                 ; LDA #40           ; If we get here then we can't do an in-system jump, so
     48D4 2800     
15948 48D6 0460  24        b    @NOISE                     ; JMP NOISE         ; call the NOISE routine with A = 40 to make a long, low
     48D8 8BA4     
15949                                                                          ; beep and return from the subroutine using a tail call
15950               
15951               * ******************************************************************************
15952               *
15953               * Name: LASLI
15954               * Type: Subroutine
15955               * Category: Drawing lines
15956               * Summary: Draw the laser lines for when we fire our lasers
15957               *
15958               * ------------------------------------------------------------------------------
15959               *
15960               * Draw the laser lines, aiming them to slightly different place each time so
15961               * they appear to flicker and dance. Also heat up the laser temperature and drain
15962               * some energy.
15963               *
15964               * ------------------------------------------------------------------------------
15965               *
15966               * Other entry points:
15967               *
15968               * LASLI2              Just draw the current laser lines without moving the
15969               * centre point, draining energy or heating up. This has
15970               * the effect of removing the lines from the screen
15971               *
15972               * LASLI-1             Contains an RTS
15973               *
15974               * ******************************************************************************
15975               
15976               LASLI:
15977 48DA 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     48DC 8070     
15978 48DE 06A0  28        bl   @jsr                       ;
     48E0 8002     
15979               
15980 48E2 0240  22        andi ra,>07*256                 ; AND #7            ; Restrict A to a random value in the range 0 to 7
     48E4 0700     
15981               
15982                      .adi ((Y-4)*256)                ; ADC #Y-4          ; Set LASY to four pixels above the centre of the
     **** ****     > ADI
0001 48E6 1701  14        jnc  !
0002 48E8 B004  18        ab   rone,ra
0003               !:
0004 48EA 0220  22        ai   ra,((Y-4)*256)
     48EC 5C00     
                   < elite.a99
15983 48EE D800  30        movb ra,@LASY                   ; STA LASY          ; screen (#Y), plus our random number, so the laser
     48F0 0F15     
15984                                                                          ; dances above and below the centre point
15985               
15986 48F2 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     48F4 8070     
15987 48F6 06A0  28        bl   @jsr                       ;
     48F8 8002     
15988               
15989 48FA 0240  22        andi ra,>07*256                 ; AND #7            ; Restrict A to a random value in the range 0 to 7
     48FC 0700     
15990               
15991                      .adi ((X-4)*256)                ; ADC #X-4          ; Set LASX to four pixels left of the centre of the
     **** ****     > ADI
0001 48FE 1701  14        jnc  !
0002 4900 B004  18        ab   rone,ra
0003               !:
0004 4902 0220  22        ai   ra,((X-4)*256)
     4904 7C00     
                   < elite.a99
15992 4906 D800  30        movb ra,@LASX                   ; STA LASX          ; screen (#X), plus our random number, so the laser
     4908 0F14     
15993                                                                          ; dances to the left and right of the centre point
15994               
15995 490A D020  30        movb @GNTMP,ra                  ; LDA GNTMP         ; Add 8 to the laser temperature in GNTMP
     490C 0D61     
15996                      .adi (>08*256)                  ; ADC #8
     **** ****     > ADI
0001 490E 1701  14        jnc  !
0002 4910 B004  18        ab   rone,ra
0003               !:
0004 4912 0220  22        ai   ra,(>08*256)
     4914 0800     
                   < elite.a99
15997 4916 D800  30        movb ra,@GNTMP                  ; STA GNTMP
     4918 0D61     
15998               
15999 491A 0206  20        li   rtmp,DENGY                 ; JSR DENGY         ; Call DENGY to deplete our energy banks by 1
     491C 6CD6     
16000 491E 06A0  28        bl   @jsr                       ;
     4920 8002     
16001               
16002               LASLI2:
16003 4922 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view (i.e. QQ11 is non-zero)
     4924 0096     
16004 4926 1632  14        jne  PU1-1                      ; BNE PU1-1         ; then jump to MA9 to return from the main flight loop
16005                                                                          ; (as PU1-1 is an RTS)
16006               
16007 4928 0200  20        li   ra,>20*256                 ; LDA #32           ; Set A = 32 and Y = 224 for the first set of laser
     492A 2000     
16008 492C 0202  20        li   ry,>e0*256                 ; LDY #224          ; lines (the wider pair of lines)
     492E E000     
16009               
16010 4930 0206  20        li   rtmp,las_                  ; JSR las           ; Call las below to draw the first set of laser lines
     4932 4940     
16011 4934 06A0  28        bl   @jsr                       ;
     4936 8002     
16012               
16013 4938 0200  20        li   ra,>30*256                 ; LDA #48           ; Fall through into las with A = 48 and Y = 208 to draw
     493A 3000     
16014 493C 0202  20        li   ry,>d0*256                 ; LDY #208          ; a second set of lines (the narrower pair)
     493E D000     
16015               
16016                                                                          ; The following routine draws two laser lines, one from
16017                                                                          ; the centre point down to point A on the bottom row,
16018                                                                          ; and the other from the centre point down to point Y
16019                                                                          ; on the bottom row. We therefore get lines from the
16020                                                                          ; centre point to points 32, 48, 208 and 224 along the
16021                                                                          ; bottom row, giving us the triangular laser effect
16022                                                                          ; we're after
16023               
16024               las_:
16025 4940 D800  30        movb ra,@X2                     ; STA X2            ; Set X2 = A
     4942 0033     
16026               
16027 4944 D020  30        movb @LASX,ra                   ; LDA LASX          ; Set (X1, Y1) to the random centre point we set above
     4946 0F14     
16028 4948 D800  30        movb ra,@X1                     ; STA X1
     494A 0031     
16029 494C D020  30        movb @LASY,ra                   ; LDA LASY
     494E 0F15     
16030 4950 D800  30        movb ra,@Y1                     ; STA Y1
     4952 0032     
16031               
16032 4954 0200  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
     4956 BF00     
16033 4958 D800  30        movb ra,@Y2                     ; STA Y2            ; y-coordinate of the mid-point of the space view, so
     495A 0034     
16034                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
16035                                                                          ; pixel row of the space view
16036               
16037 495C 0206  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
     495E 224E     
16038 4960 06A0  28        bl   @jsr                       ;
     4962 8002     
16039                                                                          ; the centre point to (A, 191)
16040               
16041 4964 D020  30        movb @LASX,ra                   ; LDA LASX          ; Set (X1, Y1) to the random centre point we set above
     4966 0F14     
16042 4968 D800  30        movb ra,@X1                     ; STA X1
     496A 0031     
16043 496C D020  30        movb @LASY,ra                   ; LDA LASY
     496E 0F15     
16044 4970 D800  30        movb ra,@Y1                     ; STA Y1
     4972 0032     
16045               
16046 4974 D802  30        movb ry,@X2                     ; STY X2            ; Set X2 = Y
     4976 0033     
16047               
16048 4978 0200  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1, the y-coordinate of the bottom
     497A BF00     
16049 497C D800  30        movb ra,@Y2                     ; STA Y2            ; pixel row of the space view (as before)
     497E 0034     
16050               
16051 4980 0460  28        b    @LOIN                      ; JMP LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
     4982 224E     
16052                                                                          ; the centre point to (Y, 191), and return from
16053                                                                          ; the subroutine using a tail call
16054               
16055               * ******************************************************************************
16056               *
16057               * Name: PLUT
16058               * Type: Subroutine
16059               * Category: Flight
16060               * Summary: Flip the coordinate axes for the four different views
16061               * Deep dive: Flipping axes between space views
16062               *
16063               * ------------------------------------------------------------------------------
16064               *
16065               * This routine flips the relevant geometric axes in INWK depending on which
16066               * view we are looking through (front, rear, left, right).
16067               *
16068               * ------------------------------------------------------------------------------
16069               *
16070               * Other entry points:
16071               *
16072               * PU1-1               Contains an RTS
16073               *
16074               * ******************************************************************************
16075               
16076               PLUT:
16077 4984 D060  30        movb @VIEW,rx                   ; LDX VIEW          ; Load the current view into X:
     4986 0D5F     
16078                                                                          ;
16079                                                                          ; 0 = front
16080                                                                          ; 1 = rear
16081                                                                          ; 2 = left
16082                                                                          ; 3 = right
16083               
16084 4988 1602  14        jne  PU1                        ; BNE PU1           ; If the current view is the front view, return from the
16085 498A 0460  24        b    @rts                       ; RTS               ; subroutine, as the geometry in INWK is already correct
     498C 800E     
16086               
16087               PU1:
16088 498E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the view, so now:
16089                                                                          ;
16090                                                                          ; 0 = rear
16091                                                                          ; 1 = left
16092                                                                          ; 2 = right
16093               
16094 4990 163A  14        jne  PU2                        ; BNE PU2           ; If the current view is left or right, jump to PU2,
16095                                                                          ; otherwise this is the rear view, so continue on
16096               
16097 4992 D020  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Flip the sign of x_sign
     4994 0055     
16098                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4996 0206  20        li   rtmp,(>80*256)
     4998 8000     
0002 499A 2806  18        xor  rtmp,ra
                   < elite.a99
16099 499C D800  30        movb ra,@INWK+2                 ; STA INWK+2
     499E 0055     
16100               
16101 49A0 D020  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Flip the sign of z_sign
     49A2 005B     
16102                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49A4 0206  20        li   rtmp,(>80*256)
     49A6 8000     
0002 49A8 2806  18        xor  rtmp,ra
                   < elite.a99
16103 49AA D800  30        movb ra,@INWK+8                 ; STA INWK+8
     49AC 005B     
16104               
16105 49AE D020  30        movb @INWK+10,ra                ; LDA INWK+10       ; Flip the sign of nosev_x_hi
     49B0 005D     
16106                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49B2 0206  20        li   rtmp,(>80*256)
     49B4 8000     
0002 49B6 2806  18        xor  rtmp,ra
                   < elite.a99
16107 49B8 D800  30        movb ra,@INWK+10                ; STA INWK+10
     49BA 005D     
16108               
16109 49BC D020  30        movb @INWK+14,ra                ; LDA INWK+14       ; Flip the sign of nosev_z_hi
     49BE 0061     
16110                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49C0 0206  20        li   rtmp,(>80*256)
     49C2 8000     
0002 49C4 2806  18        xor  rtmp,ra
                   < elite.a99
16111 49C6 D800  30        movb ra,@INWK+14                ; STA INWK+14
     49C8 0061     
16112               
16113 49CA D020  30        movb @INWK+16,ra                ; LDA INWK+16       ; Flip the sign of roofv_x_hi
     49CC 0063     
16114                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49CE 0206  20        li   rtmp,(>80*256)
     49D0 8000     
0002 49D2 2806  18        xor  rtmp,ra
                   < elite.a99
16115 49D4 D800  30        movb ra,@INWK+16                ; STA INWK+16
     49D6 0063     
16116               
16117 49D8 D020  30        movb @INWK+20,ra                ; LDA INWK+20       ; Flip the sign of roofv_z_hi
     49DA 0067     
16118                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49DC 0206  20        li   rtmp,(>80*256)
     49DE 8000     
0002 49E0 2806  18        xor  rtmp,ra
                   < elite.a99
16119 49E2 D800  30        movb ra,@INWK+20                ; STA INWK+20
     49E4 0067     
16120               
16121 49E6 D020  30        movb @INWK+22,ra                ; LDA INWK+22       ; Flip the sign of sidev_x_hi
     49E8 0069     
16122                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49EA 0206  20        li   rtmp,(>80*256)
     49EC 8000     
0002 49EE 2806  18        xor  rtmp,ra
                   < elite.a99
16123 49F0 D800  30        movb ra,@INWK+22                ; STA INWK+22
     49F2 0069     
16124               
16125 49F4 D020  30        movb @INWK+26,ra                ; LDA INWK+26       ; Flip the sign of roofv_z_hi
     49F6 006D     
16126                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49F8 0206  20        li   rtmp,(>80*256)
     49FA 8000     
0002 49FC 2806  18        xor  rtmp,ra
                   < elite.a99
16127 49FE D800  30        movb ra,@INWK+26                ; STA INWK+26
     4A00 006D     
16128               
16129 4A02 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4A04 800E     
16130               
16131               PU2:
16132                                                                          ; We enter this with X set to the view, as follows:
16133                                                                          ;
16134                                                                          ; 1 = left
16135                                                                          ; 2 = right
16136 4A06 0200  20        li   ra,>00*256                 ; LDA #0            ; Set RAT2 = 0 (left view) or -1 (right view)
     4A08 0000     
16137 4A0A 0281  22        ci   rx,>02*256                 ; CPX #2
     4A0C 0200     
16138 4A0E 06A0  28        bl   @rora                      ; ROR A
     4A10 803C     
16139 4A12 D800  30        movb ra,@RAT2                   ; STA RAT2
     4A14 00AB     
16140               
16141                      .eoi (>80*256)                  ; EOR #%10000000    ; Set RAT = -1 (left view) or 0 (right view)
     **** ****     > EOI
0001 4A16 0206  20        li   rtmp,(>80*256)
     4A18 8000     
0002 4A1A 2806  18        xor  rtmp,ra
                   < elite.a99
16142 4A1C D800  30        movb ra,@RAT                    ; STA RAT
     4A1E 00AA     
16143               
16144 4A20 D020  30        movb @INWK,ra                   ; LDA INWK          ; Swap x_lo and z_lo
     4A22 0053     
16145 4A24 D060  30        movb @INWK+6,rx                 ; LDX INWK+6
     4A26 0059     
16146 4A28 D800  30        movb ra,@INWK+6                 ; STA INWK+6
     4A2A 0059     
16147 4A2C D801  30        movb rx,@INWK                   ; STX INWK
     4A2E 0053     
16148               
16149 4A30 D020  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Swap x_hi and z_hi
     4A32 0054     
16150 4A34 D060  30        movb @INWK+7,rx                 ; LDX INWK+7
     4A36 005A     
16151 4A38 D800  30        movb ra,@INWK+7                 ; STA INWK+7
     4A3A 005A     
16152 4A3C D801  30        movb rx,@INWK+1                 ; STX INWK+1
     4A3E 0054     
16153               
16154 4A40 D020  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Swap x_sign and z_sign
     4A42 0055     
16155                      .eor @RAT                       ; EOR RAT           ; If left view, flip sign of new z_sign
     **** ****     > EOR
0001 4A44 D1A0  30        movb @RAT,rtmp
     4A46 00AA     
0002 4A48 2806  18        xor  rtmp,ra
                   < elite.a99
16156 4A4A D040  18        movb ra,rx                      ; TAX               ; If right view, flip sign of new x_sign
16157 4A4C D020  30        movb @INWK+8,ra                 ; LDA INWK+8
     4A4E 005B     
16158                      .eor @RAT2                      ; EOR RAT2
     **** ****     > EOR
0001 4A50 D1A0  30        movb @RAT2,rtmp
     4A52 00AB     
0002 4A54 2806  18        xor  rtmp,ra
                   < elite.a99
16159 4A56 D800  30        movb ra,@INWK+2                 ; STA INWK+2
     4A58 0055     
16160 4A5A D801  30        movb rx,@INWK+8                 ; STX INWK+8
     4A5C 005B     
16161               
16162 4A5E 0202  20        li   ry,>09*256                 ; LDY #9            ; Swap nosev_x_lo and nosev_z_lo
     4A60 0900     
16163 4A62 0206  20        li   rtmp,PUS1                  ; JSR PUS1          ; Swap nosev_x_hi and nosev_z_hi
     4A64 4A7A     
16164 4A66 06A0  28        bl   @jsr                       ;
     4A68 8002     
16165                                                                          ; If left view, flip sign of new nosev_z_hi
16166                                                                          ; If right view, flip sign of new nosev_x_hi
16167               
16168 4A6A 0202  20        li   ry,>0f*256                 ; LDY #15           ; Swap roofv_x_lo and roofv_z_lo
     4A6C 0F00     
16169 4A6E 0206  20        li   rtmp,PUS1                  ; JSR PUS1          ; Swap roofv_x_hi and roofv_z_hi
     4A70 4A7A     
16170 4A72 06A0  28        bl   @jsr                       ;
     4A74 8002     
16171                                                                          ; If left view, flip sign of new roofv_z_hi
16172                                                                          ; If right view, flip sign of new roofv_x_hi
16173               
16174 4A76 0202  20        li   ry,>15*256                 ; LDY #21           ; Swap sidev_x_lo and sidev_z_lo
     4A78 1500     
16175                                                                          ; Swap sidev_x_hi and sidev_z_hi
16176                                                                          ; If left view, flip sign of new sidev_z_hi
16177                                                                          ; If right view, flip sign of new sidev_x_hi
16178               
16179               PUS1:
16180 4A7A D022  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Swap the low x and z bytes for the vector in Y:
     4A7C 0053     
16181 4A7E D062  34        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ;
     4A80 0057     
16182 4A82 D880  38        movb ra,@INWK+4(ry)             ; STA INWK+4,Y      ; * For Y =  9 swap nosev_x_lo and nosev_z_lo
     4A84 0057     
16183 4A86 D881  38        movb rx,@INWK(ry)               ; STX INWK,Y        ; * For Y = 15 swap roofv_x_lo and roofv_z_lo
     4A88 0053     
16184                                                                          ; * For Y = 21 swap sidev_x_lo and sidev_z_lo
16185               
16186 4A8A D022  34        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Swap the high x and z bytes for the offset in Y:
     4A8C 0054     
16187                      .eor @RAT                       ; EOR RAT           ;
     **** ****     > EOR
0001 4A8E D1A0  30        movb @RAT,rtmp
     4A90 00AA     
0002 4A92 2806  18        xor  rtmp,ra
                   < elite.a99
16188 4A94 D040  18        movb ra,rx                      ; TAX               ; * If left view, flip sign of new z-coordinate
16189 4A96 D022  34        movb @INWK+5(ry),ra             ; LDA INWK+5,Y      ; * If right view, flip sign of new x-coordinate
     4A98 0058     
16190                      .eor @RAT2                      ; EOR RAT2
     **** ****     > EOR
0001 4A9A D1A0  30        movb @RAT2,rtmp
     4A9C 00AB     
0002 4A9E 2806  18        xor  rtmp,ra
                   < elite.a99
16191 4AA0 D880  38        movb ra,@INWK+1(ry)             ; STA INWK+1,Y
     4AA2 0054     
16192 4AA4 D881  38        movb rx,@INWK+5(ry)             ; STX INWK+5,Y
     4AA6 0058     
16193               
16194                                                                          ; Fall through into LOOK1 to return from the subroutine
16195               
16196               * ******************************************************************************
16197               *
16198               * Name: LOOK1
16199               * Type: Subroutine
16200               * Category: Flight
16201               * Summary: Initialise the space view
16202               *
16203               * ------------------------------------------------------------------------------
16204               *
16205               * Initialise the space view, with the direction of view given in X. This clears
16206               * the upper screen and draws the laser crosshairs, if the view in X has lasers
16207               * fitted. It also wipes all the ships from the scanner, so we can recalculate
16208               * ship positions for the new view (they get put back in the main flight loop).
16209               *
16210               * ------------------------------------------------------------------------------
16211               *
16212               * Arguments:
16213               *
16214               * X                   The space view to set:
16215               *
16216               * * 0 = front
16217               * * 1 = rear
16218               * * 2 = left
16219               * * 3 = right
16220               *
16221               * ------------------------------------------------------------------------------
16222               *
16223               * Other entry points:
16224               *
16225               * LO2                 Contains an RTS
16226               *
16227               * ******************************************************************************
16228               
16229               LO2:
16230 4AA8 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4AAA 800E     
16231               
16232               LQ:
16233 4AAC D801  30        movb rx,@VIEW                   ; STX VIEW          ; Set the current space view to X
     4AAE 0D5F     
16234               
16235 4AB0 0206  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     4AB2 4B2A     
16236 4AB4 06A0  28        bl   @jsr                       ;
     4AB6 8002     
16237                                                                          ; and set the current view type in QQ11 to 0 (space
16238                                                                          ; view)
16239               
16240 4AB8 0206  20        li   rtmp,SIGHT                 ; JSR SIGHT         ; Draw the laser crosshairs
     4ABA 4AF0     
16241 4ABC 06A0  28        bl   @jsr                       ;
     4ABE 8002     
16242               
16243 4AC0 0460  28        b    @NWSTARS                   ; JMP NWSTARS       ; Set up a new stardust field and return from the
     4AC2 6BDA     
16244                                                                          ; subroutine using a tail call
16245               
16246               LOOK1:
16247 4AC4 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0, the type number of a space view
     4AC6 0000     
16248               
16249 4AC8 D0A0  30        movb @QQ11,ry                   ; LDY QQ11          ; If the current view is not a space view, jump up to LQ
     4ACA 0096     
16250 4ACC 16EF  14        jne  LQ                         ; BNE LQ            ; to set up a new space view
16251               
16252 4ACE 9060  30        cb   @VIEW,rx                   ; CPX VIEW          ; If the current view is already of type X, jump to LO2
     4AD0 0D5F     
16253 4AD2 13EA  14        jeq  LO2                        ; BEQ LO2           ; to return from the subroutine (as LO2 contains an RTS)
16254               
16255 4AD4 D801  30        movb rx,@VIEW                   ; STX VIEW          ; Change the current space view to X
     4AD6 0D5F     
16256               
16257 4AD8 0206  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     4ADA 4B2A     
16258 4ADC 06A0  28        bl   @jsr                       ;
     4ADE 8002     
16259                                                                          ; and set the current view type in QQ11 to 0 (space
16260                                                                          ; view)
16261               
16262 4AE0 0206  20        li   rtmp,FLIP                  ; JSR FLIP          ; Swap the x- and y-coordinates of all the stardust
     4AE2 2964     
16263 4AE4 06A0  28        bl   @jsr                       ;
     4AE6 8002     
16264                                                                          ; particles and redraw the stardust field
16265               
16266 4AE8 0206  20        li   rtmp,WPSHPS                ; JSR WPSHPS        ; Wipe all the ships from the scanner and mark them all
     4AEA 6C24     
16267 4AEC 06A0  28        bl   @jsr                       ;
     4AEE 8002     
16268                                                                          ; as not being shown on-screen
16269               
16270                                                                          ; And fall through into SIGHT to draw the laser
16271                                                                          ; crosshairs
16272               
16273               * ******************************************************************************
16274               *
16275               * Name: SIGHT
16276               * Type: Subroutine
16277               * Category: Flight
16278               * Summary: Draw the laser crosshairs
16279               *
16280               * ******************************************************************************
16281               
16282               SIGHT:
16283 4AF0 D0A0  30        movb @VIEW,ry                   ; LDY VIEW          ; Fetch the laser power for our new view
     4AF2 0D5F     
16284 4AF4 D022  34        movb @LASER(ry),ra              ; LDA LASER,Y
     4AF6 0310     
16285               
16286 4AF8 13D7  14        jeq  LO2                        ; BEQ LO2           ; If it is zero (i.e. there is no laser fitted to this
16287                                                                          ; view), jump to LO2 to return from the subroutine (as
16288                                                                          ; LO2 contains an RTS)
16289               
16290 4AFA 0200  20        li   ra,>80*256                 ; LDA #128          ; Set QQ19 to the x-coordinate of the centre of the
     4AFC 8000     
16291 4AFE D800  30        movb ra,@QQ19                   ; STA QQ19          ; screen
     4B00 007F     
16292               
16293 4B02 0200  20        li   ra,(Y-24)*256              ; LDA #Y-24         ; Set QQ19+1 to the y-coordinate of the centre of the
     4B04 4800     
16294 4B06 D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; screen, minus 24 (because TT15 will add 24 to the
     4B08 0080     
16295                                                                          ; coordinate when it draws the crosshairs)
16296               
16297 4B0A 0200  20        li   ra,>14*256                 ; LDA #20           ; Set QQ19+2 to size 20 for the crosshairs size
     4B0C 1400     
16298 4B0E D800  30        movb ra,@QQ19+2                 ; STA QQ19+2
     4B10 0081     
16299               
16300 4B12 0206  20        li   rtmp,TT15                  ; JSR TT15          ; Call TT15 to draw crosshairs of size 20 just to the
     4B14 5316     
16301 4B16 06A0  28        bl   @jsr                       ;
     4B18 8002     
16302                                                                          ; left of the middle of the screen
16303               
16304 4B1A 0200  20        li   ra,>0a*256                 ; LDA #10           ; Set QQ19+2 to size 10 for the crosshairs size
     4B1C 0A00     
16305 4B1E D800  30        movb ra,@QQ19+2                 ; STA QQ19+2
     4B20 0081     
16306               
16307 4B22 0460  28        b    @TT15                      ; JMP TT15          ; Call TT15 to draw crosshairs of size 10 at the same
     4B24 5316     
16308                                                                          ; location, which will remove the centre part from the
16309                                                                          ; laser crosshairs, leaving a gap in the middle, and
16310                                                                          ; return from the subroutine using a tail call
16311               
16312               * ******************************************************************************
16313               *
16314               * Name: TT66
16315               * Type: Subroutine
16316               * Category: Drawing the screen
16317               * Summary: Clear the screen and set the current view type
16318               *
16319               * ------------------------------------------------------------------------------
16320               *
16321               * Clear the top part of the screen, draw a white border, and set the current
16322               * view type in QQ11 to A.
16323               *
16324               * ------------------------------------------------------------------------------
16325               *
16326               * Arguments:
16327               *
16328               * A                   The type of the new current view (see QQ11 for a list of
16329               * view types)
16330               *
16331               * ------------------------------------------------------------------------------
16332               *
16333               * Other entry points:
16334               *
16335               * TT66-2              Call TT66 with A = 1
16336               *
16337               * ******************************************************************************
16338               
16339 4B26 0200  20        li   ra,>01*256                 ; LDA #1            ; Set the view type to 1 when this is called via the
     4B28 0100     
16340                                                                          ; TT66-2 entry point
16341               
16342               TT66:
16343 4B2A D800  30        movb ra,@QQ11                   ; STA QQ11          ; Set the current view type in QQ11 to A
     4B2C 0096     
16344               
16345                                                                          ; Fall through into TTX66 to clear the screen and draw a
16346                                                                          ; white border
16347               
16348               * ******************************************************************************
16349               *
16350               * Name: TTX66
16351               * Type: Subroutine
16352               * Category: Drawing the screen
16353               * Summary: Clear the top part of the screen and draw a white border
16354               *
16355               * ------------------------------------------------------------------------------
16356               *
16357               * Clear the top part of the screen (the space view) and draw a white border
16358               * along the top and sides.
16359               *
16360               * ------------------------------------------------------------------------------
16361               *
16362               * Other entry points:
16363               *
16364               * BOX                 Just draw the border and (if this is a space view) the
16365               * view name. This can be used to remove the border and
16366               * view name, as it is drawn using EOR logic
16367               *
16368               * ******************************************************************************
16369               
16370               TTX66:
16371 4B2E 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     4B30 8000     
16372 4B32 D800  30        movb ra,@QQ17                   ; STA QQ17
     4B34 007E     
16373               
16380               
16381                      .asla                           ; ASL A             ; Set LAS2 to 0, as 128 << 1 = %10000000 << 1 = 0. This
     **** ****     > ASLA
0001 4B36 0240  22        andi ra,>ff00
     4B38 FF00     
0002 4B3A 0A10  18        sla  ra,1
                   < elite.a99
16382 4B3C D800  30        movb ra,@LAS2                   ; STA LAS2          ; stops any laser pulsing
     4B3E 0D5D     
16383               
16385               
16386 4B40 D800  30        movb ra,@DLY                    ; STA DLY           ; Set the delay in DLY to 0, to indicate that we are
     4B42 0D64     
16387                                                                          ; no longer showing an in-flight message, so any new
16388                                                                          ; in-flight messages will be shown instantly
16389               
16390 4B44 D800  30        movb ra,@de_                    ; STA de            ; Clear de, the flag that appends " DESTROYED" to the
     4B46 0D65     
16391                                                                          ; end of the next text token, so that it doesn't
16392               
16393 4B48 0201  20        li   rx,>60*256                 ; LDX #&60          ; Set X to the screen memory page for the top row of the
     4B4A 6000     
16394                                                                          ; screen (as screen memory starts at &6000)
16395               
16396               BOL1:
16397 4B4C 0206  20        li   rtmp,ZES1                  ; JSR ZES1          ; Call ZES1 to zero-fill the page in X, which clears
     4B4E 8812     
16398 4B50 06A0  28        bl   @jsr                       ;
     4B52 8002     
16399                                                                          ; that character row on the screen
16400               
16401 4B54 B044  18        ab   rone,rx                    ; INX               ; Increment X to point to the next page, i.e. the next
16402                                                                          ; character row
16403               
16404 4B56 0281  22        ci   rx,>78*256                 ; CPX #&78          ; Loop back to BOL1 until we have cleared page &7700,
     4B58 7800     
16405 4B5A 16F8  14        jne  BOL1                       ; BNE BOL1          ; the last character row in the space view part of the
16406                                                                          ; screen (the top part)
16407               
16408 4B5C D060  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Fetch into X the number that's shown on-screen during
     4B5E 002F     
16409                                                                          ; the hyperspace countdown
16410               
16411 4B60 1304  14        jeq  BOX                        ; BEQ BOX           ; If the counter is zero then we are not counting down
16412                                                                          ; to hyperspace, so jump to BOX to skip the next
16413                                                                          ; instruction
16414               
16415 4B62 0206  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1),
     4B64 5D36     
16416 4B66 06A0  28        bl   @jsr                       ;
     4B68 8002     
16417                                                                          ; i.e. print the hyperspace countdown in the top-left
16418                                                                          ; corner
16419               
16420               BOX:
16421 4B6A 0202  20        li   ry,>01*256                 ; LDY #1            ; Move the text cursor to row 1
     4B6C 0100     
16422 4B6E D802  30        movb ry,@YC                     ; STY YC
     4B70 002D     
16423               
16424 4B72 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to tt66 to skip
     4B74 0096     
16425 4B76 1616  14        jne  tt66_                      ; BNE tt66          ; displaying the view name
16426               
16427 4B78 0202  20        li   ry,>0b*256                 ; LDY #11           ; Move the text cursor to row 11
     4B7A 0B00     
16428 4B7C D802  30        movb ry,@XC                     ; STY XC
     4B7E 002C     
16429               
16430 4B80 D020  30        movb @VIEW,ra                   ; LDA VIEW          ; Load the current view into A:
     4B82 0D5F     
16431                                                                          ;
16432                                                                          ; 0 = front
16433                                                                          ; 1 = rear
16434                                                                          ; 2 = left
16435                                                                          ; 3 = right
16436               
16437 4B84 0260  22        ori  ra,>60*256                 ; ORA #&60          ; OR with &60 so we get a value of &60 to &63 (96 to 99)
     4B86 6000     
16438               
16439 4B88 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print recursive token 96 to 99, which will be in the
     4B8A 66DC     
16440 4B8C 06A0  28        bl   @jsr                       ;
     4B8E 8002     
16441                                                                          ; range "FRONT" to "RIGHT"
16442               
16443 4B90 0206  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     4B92 5E64     
16444 4B94 06A0  28        bl   @jsr                       ;
     4B96 8002     
16445               
16446 4B98 0200  20        li   ra,>af*256                 ; LDA #175          ; Print recursive token 15 ("VIEW ")
     4B9A AF00     
16447 4B9C 0206  20        li   rtmp,TT27                  ; JSR TT27
     4B9E 66DC     
16448 4BA0 06A0  28        bl   @jsr                       ;
     4BA2 8002     
16449               
16450               tt66_:
16451 4BA4 0201  20        li   rx,>00*256                 ; LDX #0            ; Set (X1, Y1) to (0, 0)
     4BA6 0000     
16452 4BA8 D801  30        movb rx,@X1                     ; STX X1
     4BAA 0031     
16453 4BAC D801  30        movb rx,@Y1                     ; STX Y1
     4BAE 0032     
16454               
16455 4BB0 D801  30        movb rx,@QQ17                   ; STX QQ17          ; Set QQ17 = 0 to switch to ALL CAPS
     4BB2 007E     
16456               
16457 4BB4 7044  18        sb   rone,rx                    ; DEX               ; Set X2 = 255
16458 4BB6 D801  30        movb rx,@X2                     ; STX X2
     4BB8 0033     
16459               
16460 4BBA 0206  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1), so
     4BBC 25EE     
16461 4BBE 06A0  28        bl   @jsr                       ;
     4BC0 8002     
16462                                                                          ; that's (0, 0) to (255, 0), along the very top of the
16463                                                                          ; screen
16464               
16465 4BC2 0200  20        li   ra,>02*256                 ; LDA #2            ; Set X1 = X2 = 2
     4BC4 0200     
16466 4BC6 D800  30        movb ra,@X1                     ; STA X1
     4BC8 0031     
16467 4BCA D800  30        movb ra,@X2                     ; STA X2
     4BCC 0033     
16468               
16469 4BCE 0206  20        li   rtmp,BOS2                  ; JSR BOS2          ; Call BOS2 below, which will call BOS1 twice, and then
     4BD0 4BD6     
16470 4BD2 06A0  28        bl   @jsr                       ;
     4BD4 8002     
16471                                                                          ; fall through into BOS2 again, so we effectively do
16472                                                                          ; BOS1 four times, decrementing X1 and X2 each time
16473                                                                          ; before calling LOIN, so this whole loop-within-a-loop
16474                                                                          ; mind-bender ends up drawing these four lines:
16475                                                                          ;
16476                                                                          ; (1, 0)   to (1, 191)
16477                                                                          ; (0, 0)   to (0, 191)
16478                                                                          ; (255, 0) to (255, 191)
16479                                                                          ; (254, 0) to (254, 191)
16480                                                                          ;
16481                                                                          ; So that's a 2-pixel wide vertical border along the
16482                                                                          ; left edge of the upper part of the screen, and a
16483                                                                          ; 2-pixel wide vertical border along the right edge
16484               
16485               BOS2:
16486 4BD6 0206  20        li   rtmp,BOS1                  ; JSR BOS1          ; Call BOS1 below and then fall through into it, which
     4BD8 4BDE     
16487 4BDA 06A0  28        bl   @jsr                       ;
     4BDC 8002     
16488                                                                          ; ends up running BOS1 twice. This is all part of the
16489                                                                          ; loop-the-loop border-drawing mind-bender explained
16490                                                                          ; above
16491               
16492               BOS1:
16493 4BDE 0200  20        li   ra,>00*256                 ; LDA #0            ; Set Y1 = 0
     4BE0 0000     
16494 4BE2 D800  30        movb ra,@Y1                     ; STA Y1
     4BE4 0032     
16495               
16496 4BE6 0200  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
     4BE8 BF00     
16497 4BEA D800  30        movb ra,@Y2                     ; STA Y2            ; y-coordinate of the mid-point of the space view, so
     4BEC 0034     
16498                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
16499                                                                          ; pixel row of the space view
16500               
16501 4BEE 7004  18        sb   rone,ra                    ; DEC X1            ; Decrement X1 and X2
16502 4BF0 7004  18        sb   rone,ra                    ; DEC X2
16503               
16504 4BF2 0460  28        b    @LOIN                      ; JMP LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), and return from
     4BF4 224E     
16505                                                                          ; the subroutine using a tail call
16506               
16507               * ******************************************************************************
16508               *
16509               * Name: DELAY
16510               * Type: Subroutine
16511               * Category: Utility routines
16512               * Summary: Wait for a specified time, in 1/50s of a second
16513               *
16514               * ------------------------------------------------------------------------------
16515               *
16516               * Wait for the number of vertical syncs given in Y, so this effectively waits
16517               * for Y/50 of a second (as the vertical sync occurs 50 times a second).
16518               *
16519               * ------------------------------------------------------------------------------
16520               *
16521               * Arguments:
16522               *
16523               * Y                   The number of vertical sync events to wait for
16524               *
16525               * ------------------------------------------------------------------------------
16526               *
16527               * Other entry points:
16528               *
16529               * DEL8                Wait for 8/50 of a second (0.16 seconds)
16530               *
16531               * DELAY-5             Wait for 2/50 of a second (0.04 seconds)
16532               *
16533               * ******************************************************************************
16534               
16535 4BF6 0202  20        li   ry,>02*256                 ; LDY #2            ; Set Y to 2 vertical syncs
     4BF8 0200     
16536               
16537 4BFA 2C              byte >2c                                            ; Skip the next instruction by turning it into
16538                                                                          ; &2C &A0 &08, or BIT &08A0, which does nothing apart
16539                                                                          ; from affect the flags
16540               
16541               DEL8:
16542 4BFC 0202  20        li   ry,>08*256                 ; LDY #8            ; Set Y to 8 vertical syncs and fall through into DELAY
     4BFE 0800     
16543                                                                          ; to wait for this long
16544               
16545               DELAY:
16546 4C00 0206  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     4C02 4DE2     
16547 4C04 06A0  28        bl   @jsr                       ;
     4C06 8002     
16548                                                                          ; screen gets drawn
16549               
16550 4C08 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter in Y
16551               
16552 4C0A 16FA  14        jne  DELAY                      ; BNE DELAY         ; If Y isn't yet at zero, jump back to DELAY to wait
16553                                                                          ; for another vertical sync
16554               
16555 4C0C 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4C0E 800E     
16556               
16557               * ******************************************************************************
16558               *
16559               * Name: hm
16560               * Type: Subroutine
16561               * Category: Charts
16562               * Summary: Select the closest system and redraw the chart crosshairs
16563               *
16564               * ------------------------------------------------------------------------------
16565               *
16566               * Set the system closest to galactic coordinates (QQ9, QQ10) as the selected
16567               * system, redraw the crosshairs on the chart accordingly (if they are being
16568               * shown), and, if this is not a space view, clear the bottom three text rows of
16569               * the screen.
16570               *
16571               * ******************************************************************************
16572               
16573               hm_:
16574 4C10 0206  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     4C12 5872     
16575 4C14 06A0  28        bl   @jsr                       ;
     4C16 8002     
16576                                                                          ; which will erase the crosshairs currently there
16577               
16578 4C18 0206  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     4C1A 5AB8     
16579 4C1C 06A0  28        bl   @jsr                       ;
     4C1E 8002     
16580                                                                          ; (QQ9, QQ10)
16581               
16582 4C20 0206  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     4C22 5872     
16583 4C24 06A0  28        bl   @jsr                       ;
     4C26 8002     
16584                                                                          ; which will draw the crosshairs at our current home
16585                                                                          ; system
16586               
16587 4C28 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is a space view, return from the subroutine
     4C2A 0096     
16588 4C2C 132A  14        jeq  SC5                        ; BEQ SC5           ; (as SC5 contains an RTS)
16589               
16590                                                                          ; Otherwise fall through into CLYNS to clear space at
16591                                                                          ; the bottom of the screen
16592               
16593               * ******************************************************************************
16594               *
16595               * Name: CLYNS
16596               * Type: Subroutine
16597               * Category: Drawing the screen
16598               * Summary: Clear the bottom three text rows of the mode 4 screen
16599               *
16600               * ------------------------------------------------------------------------------
16601               *
16602               * This routine clears some space at the bottom of the screen and moves the text
16603               * cursor to column 1, row 21.
16604               *
16605               * Specifically, it zeroes the following screen locations:
16606               *
16607               * &7507 to &75F0
16608               * &7607 to &76F0
16609               * &7707 to &77F0
16610               *
16611               * which clears the three bottom text rows of the mode 4 screen (rows 21 to 23),
16612               * clearing each row from text column 1 to 30 (so it doesn't overwrite the box
16613               * border in columns 0 and 32, or the last usable column in column 31).
16614               *
16615               * ------------------------------------------------------------------------------
16616               *
16617               * Returns:
16618               *
16619               * A                   A is set to 0
16620               *
16621               * Y                   Y is set to 0
16622               *
16623               * ******************************************************************************
16624               
16625               CLYNS:
16626 4C2E 0200  20        li   ra,>14*256                 ; LDA #20           ; Move the text cursor to row 20, near the bottom of
     4C30 1400     
16627 4C32 D800  30        movb ra,@YC                     ; STA YC            ; the screen
     4C34 002D     
16628               
16629 4C36 0200  20        li   ra,>75*256                 ; LDA #&75          ; Set the two-byte value in SC to &7507
     4C38 7500     
16630 4C3A D800  30        movb ra,@SC+1                   ; STA SC+1
     4C3C 0008     
16631 4C3E 0200  20        li   ra,>07*256                 ; LDA #7
     4C40 0700     
16632 4C42 D800  30        movb ra,@SC                     ; STA SC
     4C44 0007     
16633               
16634 4C46 0206  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline, which will move the text cursor down
     4C48 4EE6     
16635 4C4A 06A0  28        bl   @jsr                       ;
     4C4C 8002     
16636                                                                          ; a line (to row 21) and back to column 1
16637               
16638 4C4E 0200  20        li   ra,>00*256                 ; LDA #0            ; Call LYN to clear the pixels from &7507 to &75F0
     4C50 0000     
16639 4C52 0206  20        li   rtmp,LYN                   ; JSR LYN
     4C54 4C6C     
16640 4C56 06A0  28        bl   @jsr                       ;
     4C58 8002     
16641               
16642 4C5A B004  18        ab   rone,ra                    ; INC SC+1          ; Increment SC+1 so SC points to &7607
16643               
16644 4C5C 0206  20        li   rtmp,LYN                   ; JSR LYN           ; Call LYN to clear the pixels from &7607 to &76F0
     4C5E 4C6C     
16645 4C60 06A0  28        bl   @jsr                       ;
     4C62 8002     
16646               
16647 4C64 B004  18        ab   rone,ra                    ; INC SC+1          ; Increment SC+1 so SC points to &7707
16648               
16649 4C66 B084  18        ab   rone,ry                    ; INY               ; Move the text cursor to column 1 (as LYN sets Y to 0)
16650 4C68 D802  30        movb ry,@XC                     ; STY XC
     4C6A 002C     
16651               
16652                                                                          ; Fall through into LYN to clear the pixels from &7707
16653                                                                          ; to &77F0
16654               
16655               * ******************************************************************************
16656               *
16657               * Name: LYN
16658               * Type: Subroutine
16659               * Category: Drawing the screen
16660               * Summary: Clear most of a row of pixels
16661               *
16662               * ------------------------------------------------------------------------------
16663               *
16664               * Set pixels 0-233 to the value in A, starting at the pixel pointed to by SC.
16665               *
16666               * ------------------------------------------------------------------------------
16667               *
16668               * Arguments:
16669               *
16670               * A                   The value to store in pixels 1-233 (the only value that
16671               * is actually used is A = 0, which clears those pixels)
16672               *
16673               * ------------------------------------------------------------------------------
16674               *
16675               * Returns:
16676               *
16677               * Y                   Y is set to 0
16678               *
16679               * ------------------------------------------------------------------------------
16680               *
16681               * Other entry points:
16682               *
16683               * SC5                 Contains an RTS
16684               *
16685               * ******************************************************************************
16686               
16687               LYN:
16688 4C6C 0202  20        li   ry,>e9*256                 ; LDY #233          ; Set up a counter in Y to count down from pixel 233
     4C6E E900     
16689               
16690               EE2:
16691                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Store A in the Y-th byte after the address pointed to
     **** ****     > ST_IND_Y_IDX
0001 4C70 D820  42        movb @SC,@rtmplb
     4C72 0007     
     4C74 830D     
0002 4C76 D1A0  30        movb @SC+1,rtmp
     4C78 0008     
0003 4C7A A182  18        a    ry,rtmp
0004 4C7C D580  30        movb RA,*rtmp
                   < elite.a99
16692                                                                          ; by SC
16693               
16694 4C7E 7084  18        sb   rone,ry                    ; DEY               ; Decrement Y
16695               
16696 4C80 16F7  14        jne  EE2                        ; BNE EE2           ; Loop back until Y is zero
16697               
16698               SC5:
16699 4C82 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4C84 800E     
16700               
16701               * ******************************************************************************
16702               *
16703               * Name: SCAN
16704               * Type: Subroutine
16705               * Category: Dashboard
16706               * Summary: Display the current ship on the scanner
16707               * Deep dive: The 3D scanner
16708               *
16709               * ------------------------------------------------------------------------------
16710               *
16711               * This is used both to display a ship on the scanner, and to erase it again.
16712               *
16713               * ------------------------------------------------------------------------------
16714               *
16715               * Arguments:
16716               *
16717               * INWK                The ship's data block
16718               *
16719               * ******************************************************************************
16720               
16721               SCAN:
16722 4C86 D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the ship's scanner flag from byte #31
     4C88 0072     
16723               
16724 4C8A 0240  22        andi ra,>10*256                 ; AND #%00010000    ; If bit 4 is clear then the ship should not be shown
     4C8C 1000     
16725 4C8E 13F9  14        jeq  SC5                        ; BEQ SC5           ; on the scanner, so return from the subroutine (as SC5
16726                                                                          ; contains an RTS)
16727               
16728 4C90 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship's type from TYPE into A
     4C92 009B     
16729               
16730 4C94 11F6  14        jlt  SC5                        ; BMI SC5           ; If this is the planet or the sun, then the type will
16731                                                                          ; have bit 7 set and we don't want to display it on the
16732                                                                          ; scanner, so return from the subroutine (as SC5
16733                                                                          ; contains an RTS)
16734               
16735 4C96 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Set X to the default scanner colour of green/cyan
     4C98 FF00     
16736                                                                          ; (a 4-pixel mode 5 byte in colour 3)
16737               
16738               * CMP #TGL               \ These instructions are commented out in the original
16739               * BEQ SC49               \ source. Along with the block just below, they would
16740                                                                          ; set X to colour 1 (red) for asteroids, cargo canisters
16741                                                                          ; and escape pods, rather than green/cyan. Presumably
16742                                                                          ; they decided it didn't work that well against the red
16743                                                                          ; ellipse and took this code out for release
16744               
16745 4C9A 0280  22        ci   ra,(MSL)*256               ; CMP #MSL          ; If this is not a missile, skip the following
     4C9C 0900     
16746 4C9E 1602  14        jne  B47                        ; BNE B47           ; instruction
16747               
16748 4CA0 0201  20        li   rx,>f0*256                 ; LDX #&F0          ; This is a missile, so set X to colour 2 (yellow/white)
     4CA2 F000     
16749               
16750               B47:
16751               * CMP #AST               \ These instructions are commented out in the original
16752               * BCC P%+4               \ source. See above for an explanation of what they do
16753               * LDX #&0F
16754               * .SC49
16755 4CA4 D801  30        movb rx,@COL                    ; STX COL           ; Store X, the colour of this ship on the scanner, in
     4CA6 00A2     
16756                                                                          ; COL
16757               
16758 4CA8 D020  30        movb @INWK+1,ra                 ; LDA INWK+1        ; If any of x_hi, y_hi and z_hi have a 1 in bit 6 or 7,
     4CAA 0054     
16759 4CAC F020  30        socb @INWK+4,ra                 ; ORA INWK+4        ; then the ship is too far away to be shown on the
     4CAE 0057     
16760 4CB0 F020  30        socb @INWK+7,ra                 ; ORA INWK+7        ; scanner, so return from the subroutine (as SC5
     4CB2 005A     
16761 4CB4 0240  22        andi ra,>c0*256                 ; AND #%11000000    ; contains an RTS)
     4CB6 C000     
16762 4CB8 16E4  14        jne  SC5                        ; BNE SC5
16763               
16764                                                                          ; If we get here, we know x_hi, y_hi and z_hi are all
16765                                                                          ; 63 (%00111111) or less
16766               
16767                                                                          ; Now, we convert the x_hi coordinate of the ship into
16768                                                                          ; the screen x-coordinate of the dot on the scanner,
16769                                                                          ; using the following (see the deep dive on "The 3D
16770                                                                          ; scanner" for an explanation):
16771                                                                          ;
16772                                                                          ; X1 = 123 + (x_sign x_hi)
16773               
16774 4CBA D020  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Set A = x_hi
     4CBC 0054     
16775               
16776                      .clc                            ; CLC               ; Clear the C flag so we can do addition below
     **** ****     > CLC
0001 4CBE 0A13  18        sla  rzero,1
                   < elite.a99
16777               
16778 4CC0 D060  30        movb @INWK+2,rx                 ; LDX INWK+2        ; Set X = x_sign
     4CC2 0055     
16779               
16780 4CC4 1507  14        jgt  SC2                        ; BPL SC2           ; If x_sign is positive, skip the following
16781               
16782                      .eoi (>ff*256)                  ; EOR #%11111111    ; x_sign is negative, so flip the bits in A and add 1
     **** ****     > EOI
0001 4CC6 0206  20        li   rtmp,(>FF*256)
     4CC8 FF00     
0002 4CCA 2806  18        xor  rtmp,ra
                   < elite.a99
16783                      .adi (>01*256)                  ; ADC #1            ; to make it a negative number (bit 7 will now be set
     **** ****     > ADI
0001 4CCC 1701  14        jnc  !
0002 4CCE B004  18        ab   rone,ra
0003               !:
0004 4CD0 0220  22        ai   ra,(>01*256)
     4CD2 0100     
                   < elite.a99
16784                                                                          ; as we confirmed above that bits 6 and 7 are clear). So
16785                                                                          ; this gives A the sign of x_sign and gives it a value
16786                                                                          ; range of -63 (%11000001) to 0
16787               
16788               SC2:
16789                      .adi (>7b*256)                  ; ADC #123          ; Set X1 = 123 + (x_sign x_hi)
     **** ****     > ADI
0001 4CD4 1701  14        jnc  !
0002 4CD6 B004  18        ab   rone,ra
0003               !:
0004 4CD8 0220  22        ai   ra,(>7B*256)
     4CDA 7B00     
                   < elite.a99
16790 4CDC D800  30        movb ra,@X1                     ; STA X1
     4CDE 0031     
16791               
16792                                                                          ; Next, we convert the z_hi coordinate of the ship into
16793                                                                          ; the y-coordinate of the base of the ship's stick,
16794                                                                          ; like this (see the deep dive on "The 3D scanner" for
16795                                                                          ; an explanation):
16796                                                                          ;
16797                                                                          ; SC = 220 - (z_sign z_hi) / 4
16798                                                                          ;
16799                                                                          ; though the following code actually does it like this:
16800                                                                          ;
16801                                                                          ; SC = 255 - (35 + z_hi / 4)
16802               
16803 4CE0 D020  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set A = z_hi / 4
     4CE2 005A     
16804 4CE4 0910  18        srl  ra,1                       ; LSR A             ;
16805 4CE6 0910  18        srl  ra,1                       ; LSR A             ; So A is in the range 0-15
16806               
16807                      .clc                            ; CLC               ; Clear the C flag for the addition below
     **** ****     > CLC
0001 4CE8 0A13  18        sla  rzero,1
                   < elite.a99
16808               
16809 4CEA D060  30        movb @INWK+8,rx                 ; LDX INWK+8        ; Set X = z_sign
     4CEC 005B     
16810               
16811 4CEE 1504  14        jgt  SC3                        ; BPL SC3           ; If z_sign is positive, skip the following
16812               
16813                      .eoi (>ff*256)                  ; EOR #%11111111    ; z_sign is negative, so flip the bits in A and set the
     **** ****     > EOI
0001 4CF0 0206  20        li   rtmp,(>FF*256)
     4CF2 FF00     
0002 4CF4 2806  18        xor  rtmp,ra
                   < elite.a99
16814                      .sec                            ; SEC               ; C flag. As above, this makes A negative, this time
     **** ****     > SEC
0001 4CF6 0A15  18        sla  rmone,1
                   < elite.a99
16815                                                                          ; with a range of -16 (%11110000) to -1 (%11111111). And
16816                                                                          ; as we are about to do an ADC, the SEC effectively adds
16817                                                                          ; another 1 to that value, giving a range of -15 to 0
16818               
16819               SC3:
16820                      .adi (>23*256)                  ; ADC #35           ; Set A = 35 + A to give a number in the range 20 to 50
     **** ****     > ADI
0001 4CF8 1701  14        jnc  !
0002 4CFA B004  18        ab   rone,ra
0003               !:
0004 4CFC 0220  22        ai   ra,(>23*256)
     4CFE 2300     
                   < elite.a99
16821               
16822                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip all the bits and store in SC, so SC is in the
     **** ****     > EOI
0001 4D00 0206  20        li   rtmp,(>FF*256)
     4D02 FF00     
0002 4D04 2806  18        xor  rtmp,ra
                   < elite.a99
16823 4D06 D800  30        movb ra,@SC                     ; STA SC            ; range 205 to 235, with a higher z_hi giving a lower SC
     4D08 0007     
16824               
16825                                                                          ; Now for the stick height, which we calculate using the
16826                                                                          ; following (see the deep dive on "The 3D scanner" for
16827                                                                          ; an explanation):
16828                                                                          ;
16829                                                                          ; A = - (y_sign y_hi) / 2
16830               
16831 4D0A D020  30        movb @INWK+4,ra                 ; LDA INWK+4        ; Set A = y_hi / 2
     4D0C 0057     
16832 4D0E 0910  18        srl  ra,1                       ; LSR A
16833               
16834                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 4D10 0A13  18        sla  rzero,1
                   < elite.a99
16835               
16836 4D12 D060  30        movb @INWK+5,rx                 ; LDX INWK+5        ; Set X = y_sign
     4D14 0058     
16837               
16838 4D16 1104  14        jlt  SCD6                       ; BMI SCD6          ; If y_sign is negative, skip the following, as we
16839                                                                          ; already have a positive value in A
16840               
16841                      .eoi (>ff*256)                  ; EOR #%11111111    ; y_sign is positive, so flip the bits in A and set the
     **** ****     > EOI
0001 4D18 0206  20        li   rtmp,(>FF*256)
     4D1A FF00     
0002 4D1C 2806  18        xor  rtmp,ra
                   < elite.a99
16842                      .sec                            ; SEC               ; C flag. This makes A negative, and as we are about to
     **** ****     > SEC
0001 4D1E 0A15  18        sla  rmone,1
                   < elite.a99
16843                                                                          ; do an ADC below, the SEC effectively adds another 1 to
16844                                                                          ; that value to implement two's complement negation, so
16845                                                                          ; we don't need to add another 1 here
16846               
16847               SCD6:
16848                                                                          ; We now have all the information we need to draw this
16849                                                                          ; ship on the scanner, namely:
16850                                                                          ;
16851                                                                          ; X1 = the screen x-coordinate of the ship's dot
16852                                                                          ;
16853                                                                          ; SC = the screen y-coordinate of the base of the
16854                                                                          ; stick
16855                                                                          ;
16856                                                                          ; A = the screen height of the ship's stick, with the
16857                                                                          ; correct sign for adding to the base of the stick
16858                                                                          ; to get the dot's y-coordinate
16859                                                                          ;
16860                                                                          ; First, though, we have to make sure the dot is inside
16861                                                                          ; the dashboard, by moving it if necessary
16862                      .adc @SC,ra                     ; ADC SC            ; Set A = SC + A, so A now contains the y-coordinate of
     **** ****     > ADC
0001 4D20 1701  14        jnc  !
0002 4D22 B004  18        ab   rone,ra
0003               !:
0004 4D24 B020  30        ab   @SC,ra
     4D26 0007     
                   < elite.a99
16863                                                                          ; the end of the stick, plus the length of the stick, to
16864                                                                          ; give us the screen y-coordinate of the dot
16865               
16866 4D28 1508  14        jgt  ld246_                     ; BPL ld246         ; If the result has bit 0 clear, then the result has
16867                                                                          ; overflowed and is bigger than 256, so jump to ld246 to
16868                                                                          ; set A to the maximum allowed value of 246 (this
16869                                                                          ; instruction isn't required as we test both the maximum
16870                                                                          ; and minimum below, but it might save a few cycles)
16871               
16872 4D2A 0280  22        ci   ra,>c2*256                 ; CMP #194          ; If A >= 194, skip the following instruction, as 194 is
     4D2C C200     
16873 4D2E 1802  14        joc  B48                        ; BCS B48           ; the minimum allowed value of A
16874               
16875 4D30 0200  20        li   ra,>c2*256                 ; LDA #194          ; A < 194, so set A to 194, the minimum allowed value
     4D32 C200     
16876                                                                          ; for the y-coordinate of our ship's dot
16877               
16878               B48:
16879 4D34 0280  22        ci   ra,>f7*256                 ; CMP #247          ; If A < 247, skip the following instruction, as 246 is
     4D36 F700     
16880 4D38 1700  14        jnc  B49                        ; BCC B49           ; the maximum allowed value of A
16881               
16882               ld246_:
16883                      equ  $
16884               B49:
16885 4D3A 0200  20        li   ra,>f6*256                 ; LDA #246          ; A >= 247, so set A to 246, the maximum allowed value
     4D3C F600     
16886                                                                          ; for the y-coordinate of our ship's dot
16887               
16888 4D3E D800  30        movb ra,@Y1                     ; STA Y1            ; Store A in Y1, as it now contains the screen
     4D40 0032     
16889                                                                          ; y-coordinate for the ship's dot, clipped so that it
16890                                                                          ; fits within the dashboard
16891               
16892                      .sec                            ; SEC               ; Set A = A - SC to get the stick length, by reversing
     **** ****     > SEC
0001 4D42 0A15  18        sla  rmone,1
                   < elite.a99
16893                      .sbc @SC,ra                     ; SBC SC            ; the ADC SC we did above. This clears the C flag if the
     **** ****     > SBC
0001 4D44 1801  14        joc  !
0002 4D46 7004  18        sb   rone,ra
0003               !:
0004 4D48 7020  30        sb   @SC,ra
     4D4A 0007     
                   < elite.a99
16894                                                                          ; result is negative (i.e. the stick length is negative)
16895                                                                          ; and sets it if the result is positive (i.e. the stick
16896                                                                          ; length is negative)
16897               
16898                                                                          ; So now we have the following:
16899                                                                          ;
16900                                                                          ; X1 = the screen x-coordinate of the ship's dot,
16901                                                                          ; clipped to fit into the dashboard
16902                                                                          ;
16903                                                                          ; Y1 = the screen y-coordinate of the ship's dot,
16904                                                                          ; clipped to fit into the dashboard
16905                                                                          ;
16906                                                                          ; SC = the screen y-coordinate of the base of the
16907                                                                          ; stick
16908                                                                          ;
16909                                                                          ; A = the screen height of the ship's stick, with the
16910                                                                          ; correct sign for adding to the base of the stick
16911                                                                          ; to get the dot's y-coordinate
16912                                                                          ;
16913                                                                          ; C = 0 if A is negative, 1 if A is positive
16914                                                                          ;
16915                                                                          ; and we can get on with drawing the dot and stick
16916               
16917                      .php                            ; PHP               ; Store the flags (specifically the C flag) from the
     **** ****     > PHP
0001 4D4C 02C6  12        stst rtmp
0002 4D4E D686  30        movb rtmp,*rsp
0003 4D50 060A  14        dec  rsp
                   < elite.a99
16918                                                                          ; above subtraction
16919               
16920               * BCS SC48               \ These instructions are commented out in the original
16921               * EOR #&FF               \ source. They would negate A if the C flag were set,
16922               * ADC #1                 \ which would reverse the direction of all the sticks,
16923                                                                          ; so you could turn your joystick around. Perhaps one of
16924                                                                          ; the authors' test sticks was easier to use upside
16925                                                                          ; down? Who knows...
16926               
16927               SC48:
16928                      .pha                            ; PHA               ; Store the stick height in A on the stack
     **** ****     > PHA
0001 4D52 D680  30        movb ra,*rsp
0002 4D54 060A  14        dec  rsp
                   < elite.a99
16929               
16930 4D56 0206  20        li   rtmp,CPIX4                 ; JSR CPIX4         ; Draw a double-height dot at (X1, Y1). This also leaves
     4D58 6DD2     
16931 4D5A 06A0  28        bl   @jsr                       ;
     4D5C 8002     
16932                                                                          ; the following variables set up for the dot's top-right
16933                                                                          ; pixel, the last pixel to be drawn (as the dot gets
16934                                                                          ; drawn from the bottom up):
16935                                                                          ;
16936                                                                          ; SC(1 0) = screen address of the pixel's character
16937                                                                          ; block
16938                                                                          ;
16939                                                                          ; Y = number of the character row containing the pixel
16940                                                                          ;
16941                                                                          ; X = the pixel's number (0-3) in that row
16942                                                                          ;
16943                                                                          ; We can use there as the starting point for drawing the
16944                                                                          ; stick, if there is one
16945               
16946 4D5E D021  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Load the same mode 5 1-pixel byte that we just used
     4D60 224A     
16947                      .and @COL                       ; AND COL           ; for the top-right pixel, and mask it with the same
     **** ****     > AND
0001 4D62 D1A0  30        movb @COL,rtmp
     4D64 00A2     
0002 4D66 0546  14        inv  rtmp
0003 4D68 5006  18        szcb rtmp,ra
                   < elite.a99
16948 4D6A D800  30        movb ra,@X1                     ; STA X1            ; colour, storing the result in X1, so we can use it as
     4D6C 0031     
16949                                                                          ; the character row byte for the stick
16950               
16951                      .pla                            ; PLA               ; Restore the stick height from the stack into A
     **** ****     > PLA
0001 4D6E 058A  14        inc  rsp
0002 4D70 D01A  26        movb *rsp,ra
                   < elite.a99
16952               
16953                      .plp                            ; PLP               ; Restore the flags from above, so the C flag once again
     **** ****     > PLP
0001 4D72 058A  14        INC  rsp
0002 4D74 D19A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
16954                                                                          ; reflects the sign of the stick height
16955               
16956 4D76 D040  18        movb ra,rx                      ; TAX               ; Copy the stick height into X
16957               
16958 4D78 1314  14        jeq  RTS1                       ; BEQ RTS1          ; If the stick height is zero, then there is no stick to
16959                                                                          ; draw, so return from the subroutine (as RTS contains
16960                                                                          ; an RTS)
16961               
16962 4D7A 1715  14        jnc  RTS3                       ; BCC RTS3          ; If the C flag is clear then the stick height in A is
16963                                                                          ; negative, so jump down to RTS+1
16964               
16965               VLL1:
16966                                                                          ; If we get here then the stick length is positive (so
16967                                                                          ; the dot is below the ellipse and the stick is above
16968                                                                          ; the dot, and we need to draw the stick upwards from
16969                                                                          ; the dot)
16970 4D7C 7084  18        sb   rone,ry                    ; DEY               ; We want to draw the stick upwards, so decrement the
16971                                                                          ; pixel row in Y
16972               
16973 4D7E 1503  14        jgt  VL1                        ; BPL VL1           ; If Y is still positive then it correctly points at the
16974                                                                          ; line above, so jump to VL1 to skip the following
16975               
16976 4D80 0202  20        li   ry,>07*256                 ; LDY #7            ; We just decremented Y up through the top of the
     4D82 0700     
16977                                                                          ; character block, so we need to move it to the last row
16978                                                                          ; in the character above, so set Y to 7, the number of
16979                                                                          ; the last row
16980               
16981 4D84 7004  18        sb   rone,ra                    ; DEC SC+1          ; Decrement the high byte of the screen address to move
16982                                                                          ; to the character block above
16983               
16984               VL1:
16985 4D86 D020  30        movb @X1,ra                     ; LDA X1            ; Set A to the character row byte for the stick, which
     4D88 0031     
16986                                                                          ; we stored in X1 above, and which has the same pixel
16987                                                                          ; pattern as the bottom-right pixel of the dot (so the
16988                                                                          ; stick comes out of the right side of the dot)
16989               
16990                      .eor @SC                        ; EOR (SC),Y        ; Draw the stick on row Y of the character block using
     **** ****     > EOR
0001 4D8A D1A0  30        movb @SC,rtmp
     4D8C 0007     
0002 4D8E 2806  18        xor  rtmp,ra
                   < elite.a99
16991                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; EOR logic
     **** ****     > ST_IND_Y_IDX
0001 4D90 D820  42        movb @SC,@rtmplb
     4D92 0007     
     4D94 830D     
0002 4D96 D1A0  30        movb @SC+1,rtmp
     4D98 0008     
0003 4D9A A182  18        a    ry,rtmp
0004 4D9C D580  30        movb RA,*rtmp
                   < elite.a99
16992               
16993 4D9E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the (positive) stick height in X
16994               
16995 4DA0 16ED  14        jne  VLL1                       ; BNE VLL1          ; If we still have more stick to draw, jump up to VLL1
16996                                                                          ; to draw the next pixel
16997               
16998               RTS1:
16999 4DA2 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4DA4 800E     
17000               
17001                                                                          ; If we get here then the stick length is negative (so
17002                                                                          ; the dot is above the ellipse and the stick is below
17003                                                                          ; the dot, and we need to draw the stick downwards from
17004                                                                          ; the dot)
17005               
17006               RTS3:
17007 4DA6 B084  18        ab   rone,ry                    ; INY               ; We want to draw the stick downwards, so we first
17008                                                                          ; increment the row counter so that it's pointing to the
17009                                                                          ; bottom-right pixel in the dot (as opposed to the top-
17010                                                                          ; right pixel that the call to CPIX4 finished on)
17011               
17012 4DA8 0282  22        ci   ry,>08*256                 ; CPY #8            ; If the row number in Y is less than 8, then it
     4DAA 0800     
17013 4DAC 1603  14        jne  VLL2                       ; BNE VLL2          ; correctly points at the next line down, so jump to
17014                                                                          ; VLL2 to skip the following
17015               
17016 4DAE 0202  20        li   ry,>00*256                 ; LDY #0            ; We just incremented Y down through the bottom of the
     4DB0 0000     
17017                                                                          ; character block, so we need to move it to the first
17018                                                                          ; row in the character below, so set Y to 0, the number
17019                                                                          ; of the first row
17020               
17021 4DB2 B004  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of the screen address to move
17022                                                                          ; to the character block above
17023               
17024               VLL2:
17025 4DB4 B084  18        ab   rone,ry                    ; INY               ; We want to draw the stick itself, heading downwards,
17026                                                                          ; so increment the pixel row in Y
17027               
17028 4DB6 0282  22        ci   ry,>08*256                 ; CPY #8            ; If the row number in Y is less than 8, then it
     4DB8 0800     
17029 4DBA 1603  14        jne  VL2                        ; BNE VL2           ; correctly points at the next line down, so jump to
17030                                                                          ; VL2 to skip the following
17031               
17032 4DBC 0202  20        li   ry,>00*256                 ; LDY #0            ; We just incremented Y down through the bottom of the
     4DBE 0000     
17033                                                                          ; character block, so we need to move it to the first
17034                                                                          ; row in the character below, so set Y to 0, the number
17035                                                                          ; of the first row
17036               
17037 4DC0 B004  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of the screen address to move
17038                                                                          ; to the character block above
17039               
17040               VL2:
17041 4DC2 D020  30        movb @X1,ra                     ; LDA X1            ; Set A to the character row byte for the stick, which
     4DC4 0031     
17042                                                                          ; we stored in X1 above, and which has the same pixel
17043                                                                          ; pattern as the bottom-right pixel of the dot (so the
17044                                                                          ; stick comes out of the right side of the dot)
17045               
17046                      .eor @SC                        ; EOR (SC),Y        ; Draw the stick on row Y of the character block using
     **** ****     > EOR
0001 4DC6 D1A0  30        movb @SC,rtmp
     4DC8 0007     
0002 4DCA 2806  18        xor  rtmp,ra
                   < elite.a99
17047                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; EOR logic
     **** ****     > ST_IND_Y_IDX
0001 4DCC D820  42        movb @SC,@rtmplb
     4DCE 0007     
     4DD0 830D     
0002 4DD2 D1A0  30        movb @SC+1,rtmp
     4DD4 0008     
0003 4DD6 A182  18        a    ry,rtmp
0004 4DD8 D580  30        movb RA,*rtmp
                   < elite.a99
17048               
17049 4DDA B044  18        ab   rone,rx                    ; INX               ; Increment the (negative) stick height in X
17050               
17051 4DDC 16EB  14        jne  VLL2                       ; BNE VLL2          ; If we still have more stick to draw, jump up to VLL2
17052                                                                          ; to draw the next pixel
17053               
17054 4DDE 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4DE0 800E     
17055               
17056               * ******************************************************************************
17057               *
17058               * Name: WSCAN
17059               * Type: Subroutine
17060               * Category: Drawing the screen
17061               * Summary: Wait for the vertical sync
17062               *
17063               * ------------------------------------------------------------------------------
17064               *
17065               * Wait for vertical sync to occur on the video system - in other words, wait
17066               * for the screen to start its refresh cycle, which it does 50 times a second
17067               * (50Hz).
17068               *
17069               * ******************************************************************************
17070               
17071               WSCAN:
17072 4DE2 0200  20        li   ra,>00*256                 ; LDA #0            ; Set DL to 0
     4DE4 0000     
17073 4DE6 D800  30        movb ra,@DL                     ; STA DL
     4DE8 009A     
17074               
17075               B50:
17076 4DEA D020  30        movb @DL,ra                     ; LDA DL            ; Loop round these two instructions until DL is no
     4DEC 009A     
17077 4DEE 13FD  14        jeq  B50                        ; BEQ B50           ; longer 0 (DL gets set to 30 in the LINSCN routine,
17078                                                                          ; which is run when vertical sync has occurred on the
17079                                                                          ; video system, so DL will change to a non-zero value
17080                                                                          ; at the start of each screen refresh)
17081               
17082 4DF0 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4DF2 800E     
17083               
17084               * ******************************************************************************
17085               *
17086               * Save ELTC.bin
17087               *
17088               * ******************************************************************************
17089               
17090                      ; PRINT "ELITE C"
17091                      ; PRINT "Assembled at ", ~CODE_C%
17092                      ; PRINT "Ends at ", ~P%
17093                      ; PRINT "Code size is ", ~(P% - CODE_C%)
17094                      ; PRINT "Execute at ", ~LOAD%
17095                      ; PRINT "Reload at ", ~LOAD_C%
17096               
17097                      ; PRINT "S.ELTC ", ~CODE_C%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_C%
17098                      ; SAVE "3-assembled-output/ELTC.bin", CODE_C%, P%, LOAD%
17099               
17100               * ******************************************************************************
17101               *
17102               * ELITE D FILE
17103               *
17104               * Produces the binary file ELTD.bin that gets loaded by elite-bcfs.asm.
17105               *
17106               * ******************************************************************************
17107               
17108               CODE_D.:
17109                      equ $
17110               
17111               LOAD_D.:
17112                      equ LOAD. + $ - CODE.
17113               
17114               * ******************************************************************************
17115               *
17116               * Name: tnpr
17117               * Type: Subroutine
17118               * Category: Market
17119               * Summary: Work out if we have space for a specific amount of cargo
17120               *
17121               * ------------------------------------------------------------------------------
17122               *
17123               * Given a market item and an amount, work out whether there is room in the
17124               * cargo hold for this item.
17125               *
17126               * For standard tonne canisters, the limit is given by the type of cargo hold we
17127               * have, with a standard cargo hold having a capacity of 20t and an extended
17128               * cargo bay being 35t.
17129               *
17130               * For items measured in kg (gold, platinum), g (gem-stones) and alien items,
17131               * the individual limit on each of these is 200 units.
17132               *
17133               * ------------------------------------------------------------------------------
17134               *
17135               * Arguments:
17136               *
17137               * A                   The number of units of this market item
17138               *
17139               * QQ29                The type of market item (see QQ23 for a list of market
17140               * item numbers)
17141               *
17142               * ------------------------------------------------------------------------------
17143               *
17144               * Returns:
17145               *
17146               * A                   A is preserved
17147               *
17148               * C flag              Returns the result:
17149               *
17150               * * Set if there is no room for this item
17151               *
17152               * * Clear if there is room for this item
17153               *
17154               * ******************************************************************************
17155               
17156               tnpr_:
17157                      .pha                            ; PHA               ; Store A on the stack
     **** ****     > PHA
0001 4DF4 D680  30        movb ra,*rsp
0002 4DF6 060A  14        dec  rsp
                   < elite.a99
17158               
17159 4DF8 0201  20        li   rx,>0c*256                 ; LDX #12           ; If QQ29 > 12 then jump to kg below, as this cargo
     4DFA 0C00     
17160 4DFC 9060  30        cb   @QQ29,rx                   ; CPX QQ29          ; type is gold, platinum, gem-stones or alien items,
     4DFE 0F1B     
17161 4E00 170C  14        jnc  kg_                        ; BCC kg            ; and they have different cargo limits to the standard
17162                                                                          ; tonne canisters
17163               
17164               Tml:
17165                                                                          ; Here we count the tonne canisters we have in the hold
17166                                                                          ; and add to A to see if we have enough room for A more
17167                                                                          ; tonnes of cargo, using X as the loop counter, starting
17168                                                                          ; with X = 12
17169                      .adc @QQ20(rx),ra               ; ADC QQ20,X        ; Set A = A + the number of tonnes we have in the hold
     **** ****     > ADC
0001 4E02 1701  14        jnc  !
0002 4E04 B004  18        ab   rone,ra
0003               !:
0004 4E06 B021  34        ab   @QQ20(RX),ra
     4E08 0317     
                   < elite.a99
17170                                                                          ; of market item number X. Note that the first time we
17171                                                                          ; go round this loop, the C flag is set (as we didn't
17172                                                                          ; branch with the BCC above, so the effect of this loop
17173                                                                          ; is to count the number of tonne canisters in the hold,
17174                                                                          ; and add 1
17175               
17176 4E0A 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
17177               
17178 4E0C 15FA  14        jgt  Tml                        ; BPL Tml           ; Loop back to add in the next market item in the hold,
17179                                                                          ; until we have added up all market items from 12
17180                                                                          ; (minerals) down to 0 (food)
17181               
17182 4E0E 9020  30        cb   @CRGO,ra                   ; CMP CRGO          ; If A < CRGO then the C flag will be clear (we have
     4E10 0316     
17183                                                                          ; room in the hold)
17184                                                                          ;
17185                                                                          ; If A >= CRGO then the C flag will be set (we do not
17186                                                                          ; have room in the hold)
17187                                                                          ;
17188                                                                          ; This works because A contains the number of canisters
17189                                                                          ; plus 1, while CRGO contains our cargo capacity plus 2,
17190                                                                          ; so if we actually have "a" canisters and a capacity
17191                                                                          ; of "c", then:
17192                                                                          ;
17193                                                                          ; A < CRGO means: a+1 <  c+2
17194                                                                          ; a   <  c+1
17195                                                                          ; a   <= c
17196                                                                          ;
17197                                                                          ; So this is why the value in CRGO is 2 higher than the
17198                                                                          ; actual cargo bay size, i.e. it's 22 for the standard
17199                                                                          ; 20-tonne bay, and 37 for the large 35-tonne bay
17200               
17201                      .pla                            ; PLA               ; Restore A from the stack
     **** ****     > PLA
0001 4E12 058A  14        inc  rsp
0002 4E14 D01A  26        movb *rsp,ra
                   < elite.a99
17202               
17203 4E16 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4E18 800E     
17204               
17205               kg_:
17206                                                                          ; Here we count the number of items of this type that
17207                                                                          ; we already have in the hold, and add to A to see if
17208                                                                          ; we have enough room for A more units
17209 4E1A D0A0  30        movb @QQ29,ry                   ; LDY QQ29          ; Set Y to the item number we want to add
     4E1C 0F1B     
17210               
17211                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; Set A = A + the number of units of this item that we
     **** ****     > ADC
0001 4E1E 1701  14        jnc  !
0002 4E20 B004  18        ab   rone,ra
0003               !:
0004 4E22 B022  34        ab   @QQ20(RY),ra
     4E24 0317     
                   < elite.a99
17212                                                                          ; already have in the hold
17213               
17214 4E26 0280  22        ci   ra,>c8*256                 ; CMP #200          ; Is the result greater than 200 (the limit on
     4E28 C800     
17215                                                                          ; individual stocks of gold, platinum, gem-stones and
17216                                                                          ; alien items)?
17217                                                                          ;
17218                                                                          ; If so, this sets the C flag (no room)
17219                                                                          ;
17220                                                                          ; Otherwise it is clear (we have room)
17221               
17222                      .pla                            ; PLA               ; Restore A from the stack
     **** ****     > PLA
0001 4E2A 058A  14        inc  rsp
0002 4E2C D01A  26        movb *rsp,ra
                   < elite.a99
17223               
17224 4E2E 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     4E30 800E     
17225               
17226               * ******************************************************************************
17227               *
17228               * Name: TT20
17229               * Type: Subroutine
17230               * Category: Universe
17231               * Summary: Twist the selected system's seeds four times
17232               * Deep dive: Twisting the system seeds
17233               * Galaxy and system seeds
17234               *
17235               * ------------------------------------------------------------------------------
17236               *
17237               * Twist the three 16-bit seeds in QQ15 (selected system) four times, to
17238               * generate the next system.
17239               *
17240               * ******************************************************************************
17241               
17242               TT20:
17243 4E32 0206  20        li   rtmp,B51                   ; JSR B51           ; This line calls the line below as a subroutine, which
     4E34 4E3A     
17244 4E36 06A0  28        bl   @jsr                       ;
     4E38 8002     
17245                                                                          ; does two twists before returning here, and then we
17246                                                                          ; fall through to the line below for another two
17247                                                                          ; twists, so the net effect of these two consecutive
17248                                                                          ; JSR calls is four twists, not counting the ones
17249                                                                          ; inside your head as you try to follow this process
17250               
17251               B51:
17252 4E3A 0206  20        li   rtmp,TT54                  ; JSR TT54          ; This line calls TT54 as a subroutine to do a twist,
     4E3C 4E42     
17253 4E3E 06A0  28        bl   @jsr                       ;
     4E40 8002     
17254                                                                          ; and then falls through into TT54 to do another twist
17255                                                                          ; before returning from the subroutine
17256               
17257               * ******************************************************************************
17258               *
17259               * Name: TT54
17260               * Type: Subroutine
17261               * Category: Universe
17262               * Summary: Twist the selected system's seeds
17263               * Deep dive: Twisting the system seeds
17264               * Galaxy and system seeds
17265               *
17266               * ------------------------------------------------------------------------------
17267               *
17268               * This routine twists the three 16-bit seeds in QQ15 once.
17269               *
17270               * If we start with seeds s0, s1 and s2 and we want to work out their new values
17271               * after we perform a twist (let's call the new values s0, s1 and s2), then:
17272               *
17273               * s0 = s1
17274               * s1 = s2
17275               * s2 = s0 + s1 + s2
17276               *
17277               * So given an existing set of seeds in s0, s1 and s2, we can get the new values
17278               * s0, s1 and s2 simply by doing the above sums. And if we want to do the
17279               * above in-place without creating three new s variables, then we can do the
17280               * following:
17281               *
17282               * tmp = s0 + s1
17283               * s0 = s1
17284               * s1 = s2
17285               * s2 = tmp + s1
17286               *
17287               * So this is what we do in this routine, where each seed is a 16-bit number.
17288               *
17289               * ******************************************************************************
17290               
17291               TT54:
17292 4E42 D020  30        movb @QQ15,ra                   ; LDA QQ15          ; X = tmp_lo = s0_lo + s1_lo
     4E44 0078     
17293                      .clc                            ; CLC
     **** ****     > CLC
0001 4E46 0A13  18        sla  rzero,1
                   < elite.a99
17294                      .adc @QQ15+2,ra                 ; ADC QQ15+2
     **** ****     > ADC
0001 4E48 1701  14        jnc  !
0002 4E4A B004  18        ab   rone,ra
0003               !:
0004 4E4C B020  30        ab   @QQ15+2,ra
     4E4E 007A     
                   < elite.a99
17295 4E50 D040  18        movb ra,rx                      ; TAX
17296               
17297 4E52 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Y = tmp_hi = s1_hi + s1_hi + C
     4E54 0079     
17298                      .adc @QQ15+3,ra                 ; ADC QQ15+3
     **** ****     > ADC
0001 4E56 1701  14        jnc  !
0002 4E58 B004  18        ab   rone,ra
0003               !:
0004 4E5A B020  30        ab   @QQ15+3,ra
     4E5C 007B     
                   < elite.a99
17299 4E5E D080  18        movb ra,ry                      ; TAY
17300               
17301 4E60 D020  30        movb @QQ15+2,ra                 ; LDA QQ15+2        ; s0_lo = s1_lo
     4E62 007A     
17302 4E64 D800  30        movb ra,@QQ15                   ; STA QQ15
     4E66 0078     
17303               
17304 4E68 D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; s0_hi = s1_hi
     4E6A 007B     
17305 4E6C D800  30        movb ra,@QQ15+1                 ; STA QQ15+1
     4E6E 0079     
17306               
17307 4E70 D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; s1_hi = s2_hi
     4E72 007D     
17308 4E74 D800  30        movb ra,@QQ15+3                 ; STA QQ15+3
     4E76 007B     
17309               
17310 4E78 D020  30        movb @QQ15+4,ra                 ; LDA QQ15+4        ; s1_lo = s2_lo
     4E7A 007C     
17311 4E7C D800  30        movb ra,@QQ15+2                 ; STA QQ15+2
     4E7E 007A     
17312               
17313                      .clc                            ; CLC               ; s2_lo = X + s1_lo
     **** ****     > CLC
0001 4E80 0A13  18        sla  rzero,1
                   < elite.a99
17314 4E82 D001  18        movb rx,ra                      ; TXA
17315                      .adc @QQ15+2,ra                 ; ADC QQ15+2
     **** ****     > ADC
0001 4E84 1701  14        jnc  !
0002 4E86 B004  18        ab   rone,ra
0003               !:
0004 4E88 B020  30        ab   @QQ15+2,ra
     4E8A 007A     
                   < elite.a99
17316 4E8C D800  30        movb ra,@QQ15+4                 ; STA QQ15+4
     4E8E 007C     
17317               
17318 4E90 D002  18        movb ry,ra                      ; TYA               ; s2_hi = Y + s1_hi + C
17319                      .adc @QQ15+3,ra                 ; ADC QQ15+3
     **** ****     > ADC
0001 4E92 1701  14        jnc  !
0002 4E94 B004  18        ab   rone,ra
0003               !:
0004 4E96 B020  30        ab   @QQ15+3,ra
     4E98 007B     
                   < elite.a99
17320 4E9A D800  30        movb ra,@QQ15+5                 ; STA QQ15+5
     4E9C 007D     
17321               
17322 4E9E 0460  24        b    @rts                       ; RTS               ; The twist is complete so return from the subroutine
     4EA0 800E     
17323               
17324               * ******************************************************************************
17325               *
17326               * Name: TT146
17327               * Type: Subroutine
17328               * Category: Universe
17329               * Summary: Print the distance to the selected system in light years
17330               *
17331               * ------------------------------------------------------------------------------
17332               *
17333               * If it is non-zero, print the distance to the selected system in light years.
17334               * If it is zero, just move the text cursor down a line.
17335               *
17336               * Specifically, if the distance in QQ8 is non-zero, print token 31 ("DISTANCE"),
17337               * then a colon, then the distance to one decimal place, then token 35 ("LIGHT
17338               * YEARS"). If the distance is zero, move the cursor down one line.
17339               *
17340               * ******************************************************************************
17341               
17342               TT146:
17343 4EA2 D020  30        movb @QQ8,ra                    ; LDA QQ8           ; Take the two bytes of the 16-bit value in QQ8 and
     4EA4 0F2F     
17344 4EA6 F020  30        socb @QQ8+1,ra                  ; ORA QQ8+1         ; OR them together to check whether there are any
     4EA8 0F30     
17345 4EAA 1603  14        jne  TT63                       ; BNE TT63          ; non-zero bits, and if so, jump to TT63 to print the
17346                                                                          ; distance
17347               
17348 4EAC B004  18        ab   rone,ra                    ; INC YC            ; The distance is zero, so we just move the text cursor
17349 4EAE 0460  24        b    @rts                       ; RTS               ; in YC down by one line and return from the subroutine
     4EB0 800E     
17350               
17351               TT63:
17352 4EB2 0200  20        li   ra,>bf*256                 ; LDA #191          ; Print recursive token 31 ("DISTANCE") followed by
     4EB4 BF00     
17353 4EB6 0206  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     4EB8 66D0     
17354 4EBA 06A0  28        bl   @jsr                       ;
     4EBC 8002     
17355               
17356 4EBE D060  30        movb @QQ8,rx                    ; LDX QQ8           ; Load (Y X) from QQ8, which contains the 16-bit
     4EC0 0F2F     
17357 4EC2 D0A0  30        movb @QQ8+1,ry                  ; LDY QQ8+1         ; distance we want to show
     4EC4 0F30     
17358               
17359                      .sec                            ; SEC               ; Set the C flag so that the call to pr5 will include a
     **** ****     > SEC
0001 4EC6 0A15  18        sla  rmone,1
                   < elite.a99
17360                                                                          ; decimal point, and display the value as (Y X) / 10
17361               
17362 4EC8 0206  20        li   rtmp,pr5_                  ; JSR pr5           ; Print (Y X) to 5 digits, including a decimal point
     4ECA 5D46     
17363 4ECC 06A0  28        bl   @jsr                       ;
     4ECE 8002     
17364               
17365 4ED0 0200  20        li   ra,>c3*256                 ; LDA #195          ; Set A to the recursive token 35 (" LIGHT YEARS") and
     4ED2 C300     
17366                                                                          ; fall through into TT60 to print the token followed
17367                                                                          ; by a paragraph break
17368               
17369               * ******************************************************************************
17370               *
17371               * Name: TT60
17372               * Type: Subroutine
17373               * Category: Text
17374               * Summary: Print a text token and a paragraph break
17375               *
17376               * ------------------------------------------------------------------------------
17377               *
17378               * Print a text token (i.e. a character, control code, two-letter token or
17379               * recursive token). Then print a paragraph break (a blank line between
17380               * paragraphs) by moving the cursor down a line, setting Sentence Case, and then
17381               * printing a newline.
17382               *
17383               * ------------------------------------------------------------------------------
17384               *
17385               * Arguments:
17386               *
17387               * A                   The text token to be printed
17388               *
17389               * ******************************************************************************
17390               
17391               TT60:
17392 4ED4 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A and fall through into TTX69
     4ED6 66DC     
17393 4ED8 06A0  28        bl   @jsr                       ;
     4EDA 8002     
17394                                                                          ; to print the paragraph break
17395               
17396               * ******************************************************************************
17397               *
17398               * Name: TTX69
17399               * Type: Subroutine
17400               * Category: Text
17401               * Summary: Print a paragraph break
17402               *
17403               * ------------------------------------------------------------------------------
17404               *
17405               * Print a paragraph break (a blank line between paragraphs) by moving the cursor
17406               * down a line, setting Sentence Case, and then printing a newline.
17407               *
17408               * ******************************************************************************
17409               
17410               TTX69:
17411 4EDC B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a line
17412               
17413                                                                          ; Fall through into TT69 to set Sentence Case and print
17414                                                                          ; a newline
17415               
17416               * ******************************************************************************
17417               *
17418               * Name: TT69
17419               * Type: Subroutine
17420               * Category: Text
17421               * Summary: Set Sentence Case and print a newline
17422               *
17423               * ******************************************************************************
17424               
17425               TT69:
17426 4EDE 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     4EE0 8000     
17427 4EE2 D800  30        movb ra,@QQ17                   ; STA QQ17
     4EE4 007E     
17428               
17429                                                                          ; Fall through into TT67 to print a newline
17430               
17431               * ******************************************************************************
17432               *
17433               * Name: TT67
17434               * Type: Subroutine
17435               * Category: Text
17436               * Summary: Print a newline
17437               *
17438               * ******************************************************************************
17439               
17440               TT67:
17441 4EE6 0200  20        li   ra,>0d*256                 ; LDA #13           ; Load a newline character into A
     4EE8 0D00     
17442               
17443 4EEA 0460  28        b    @TT27                      ; JMP TT27          ; Print the text token in A and return from the
     4EEC 66DC     
17444                                                                          ; subroutine using a tail call
17445               
17446               * ******************************************************************************
17447               *
17448               * Name: TT70
17449               * Type: Subroutine
17450               * Category: Universe
17451               * Summary: Display "MAINLY " and jump to TT72
17452               *
17453               * ------------------------------------------------------------------------------
17454               *
17455               * This subroutine is called by TT25 when displaying a system's economy.
17456               *
17457               * ******************************************************************************
17458               
17459               TT70:
17460 4EEE 0200  20        li   ra,>ad*256                 ; LDA #173          ; Print recursive token 13 ("MAINLY ")
     4EF0 AD00     
17461 4EF2 0206  20        li   rtmp,TT27                  ; JSR TT27
     4EF4 66DC     
17462 4EF6 06A0  28        bl   @jsr                       ;
     4EF8 8002     
17463               
17464 4EFA 0460  28        b    @TT72                      ; JMP TT72          ; Jump to TT72 to continue printing system data as part
     4EFC 4F82     
17465                                                                          ; of routine TT25
17466               
17467               * ******************************************************************************
17468               *
17469               * Name: spc
17470               * Type: Subroutine
17471               * Category: Text
17472               * Summary: Print a text token followed by a space
17473               *
17474               * ------------------------------------------------------------------------------
17475               *
17476               * Print a text token (i.e. a character, control code, two-letter token or
17477               * recursive token) followed by a space.
17478               *
17479               * ------------------------------------------------------------------------------
17480               *
17481               * Arguments:
17482               *
17483               * A                   The text token to be printed
17484               *
17485               * ******************************************************************************
17486               
17487               spc_:
17488 4EFE 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     4F00 66DC     
17489 4F02 06A0  28        bl   @jsr                       ;
     4F04 8002     
17490               
17491 4F06 0460  28        b    @TT162                     ; JMP TT162         ; Print a space and return from the subroutine using a
     4F08 5E64     
17492                                                                          ; tail call
17493               
17494               * ******************************************************************************
17495               *
17496               * Name: TT25
17497               * Type: Subroutine
17498               * Category: Universe
17499               * Summary: Show the Data on System screen (red key f6)
17500               * Deep dive: Generating system data
17501               * Galaxy and system seeds
17502               *
17503               * ------------------------------------------------------------------------------
17504               *
17505               * Other entry points:
17506               *
17507               * TT72                Used by TT70 to re-enter the routine after displaying
17508               * "MAINLY" for the economy type
17509               *
17510               * ******************************************************************************
17511               
17512               TT25:
17513 4F0A 0206  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     4F0C 4B28     
17514 4F0E 06A0  28        bl   @jsr                       ;
     4F10 8002     
17515                                                                          ; and set the current view type in QQ11 to 1
17516               
17517 4F12 0200  20        li   ra,>09*256                 ; LDA #9            ; Move the text cursor to column 9
     4F14 0900     
17518 4F16 D800  30        movb ra,@XC                     ; STA XC
     4F18 002C     
17519               
17520 4F1A 0200  20        li   ra,>a3*256                 ; LDA #163          ; Print recursive token 3 as a title in capitals at
     4F1C A300     
17521 4F1E 0206  20        li   rtmp,TT27                  ; JSR TT27          ; the top ("DATA ON {selected system name}")
     4F20 66DC     
17522 4F22 06A0  28        bl   @jsr                       ;
     4F24 8002     
17523               
17524 4F26 0206  20        li   rtmp,NLIN                  ; JSR NLIN          ; Draw a horizontal line underneath the title
     4F28 25BE     
17525 4F2A 06A0  28        bl   @jsr                       ;
     4F2C 8002     
17526               
17527 4F2E 0206  20        li   rtmp,TTX69                 ; JSR TTX69         ; Print a paragraph break and set Sentence Case
     4F30 4EDC     
17528 4F32 06A0  28        bl   @jsr                       ;
     4F34 8002     
17529               
17530 4F36 B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one more line
17531               
17532 4F38 0206  20        li   rtmp,TT146                 ; JSR TT146         ; If the distance to this system is non-zero, print
     4F3A 4EA2     
17533 4F3C 06A0  28        bl   @jsr                       ;
     4F3E 8002     
17534                                                                          ; "DISTANCE", then the distance, "LIGHT YEARS" and a
17535                                                                          ; paragraph break, otherwise just move the cursor down
17536                                                                          ; a line
17537               
17538 4F40 0200  20        li   ra,>c2*256                 ; LDA #194          ; Print recursive token 34 ("ECONOMY") followed by
     4F42 C200     
17539 4F44 0206  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     4F46 66D0     
17540 4F48 06A0  28        bl   @jsr                       ;
     4F4A 8002     
17541               
17542 4F4C D020  30        movb @QQ3,ra                    ; LDA QQ3           ; The system economy is determined by the value in QQ3,
     4F4E 0F28     
17543                                                                          ; so fetch it into A. First we work out the system's
17544                                                                          ; prosperity as follows:
17545                                                                          ;
17546                                                                          ; QQ3 = 0 or 5 = %000 or %101 = Rich
17547                                                                          ; QQ3 = 1 or 6 = %001 or %110 = Average
17548                                                                          ; QQ3 = 2 or 7 = %010 or %111 = Poor
17549                                                                          ; QQ3 = 3 or 4 = %011 or %100 = Mainly
17550               
17551                      .clc                            ; CLC               ; If (QQ3 + 1) >> 1 = %10, i.e. if QQ3 = %011 or %100
     **** ****     > CLC
0001 4F50 0A13  18        sla  rzero,1
                   < elite.a99
17552                      .adi (>01*256)                  ; ADC #1            ; (3 or 4), then call TT70, which prints "MAINLY " and
     **** ****     > ADI
0001 4F52 1701  14        jnc  !
0002 4F54 B004  18        ab   rone,ra
0003               !:
0004 4F56 0220  22        ai   ra,(>01*256)
     4F58 0100     
                   < elite.a99
17553 4F5A 0910  18        srl  ra,1                       ; LSR A             ; jumps down to TT72 to print the type of economy
17554 4F5C 0280  22        ci   ra,>02*256                 ; CMP #%00000010
     4F5E 0200     
17555 4F60 13C6  14        jeq  TT70                       ; BEQ TT70
17556               
17557 4F62 D020  30        movb @QQ3,ra                    ; LDA QQ3           ; If (QQ3 + 1) >> 1 < %10, i.e. if QQ3 = %000, %001 or
     4F64 0F28     
17558 4F66 1705  14        jnc  TT71                       ; BCC TT71          ; %010 (0, 1 or 2), then jump to TT71 with A set to the
17559                                                                          ; original value of QQ3
17560               
17561                      .sbi (>05*256)                  ; SBC #5            ; Here QQ3 = %101, %110 or %111 (5, 6 or 7), so subtract
     **** ****     > SBI
0001 4F68 1801  14        joc  !
0002 4F6A 7004  18        sb   rone,ra
0003               !:
0004 4F6C 0220  22        ai   ra,-(>05*256)
     4F6E FB00     
                   < elite.a99
17562                      .clc                            ; CLC               ; 5 to bring it down to 0, 1 or 2 (the C flag is already
     **** ****     > CLC
0001 4F70 0A13  18        sla  rzero,1
                   < elite.a99
17563                                                                          ; set so the SBC will be correct)
17564               
17565               TT71:
17566                      .adi (>aa*256)                  ; ADC #170          ; A is now 0, 1 or 2, so print recursive token 10 + A.
     **** ****     > ADI
0001 4F72 1701  14        jnc  !
0002 4F74 B004  18        ab   rone,ra
0003               !:
0004 4F76 0220  22        ai   ra,(>AA*256)
     4F78 AA00     
                   < elite.a99
17567 4F7A 0206  20        li   rtmp,TT27                  ; JSR TT27          ; This means that:
     4F7C 66DC     
17568 4F7E 06A0  28        bl   @jsr                       ;
     4F80 8002     
17569                                                                          ;
17570                                                                          ; QQ3 = 0 or 5 prints token 10 ("RICH ")
17571                                                                          ; QQ3 = 1 or 6 prints token 11 ("AVERAGE ")
17572                                                                          ; QQ3 = 2 or 7 prints token 12 ("POOR ")
17573               
17574               TT72:
17575 4F82 D020  30        movb @QQ3,ra                    ; LDA QQ3           ; Now to work out the type of economy, which is
     4F84 0F28     
17576 4F86 0910  18        srl  ra,1                       ; LSR A             ; determined by bit 2 of QQ3, as follows:
17577 4F88 0910  18        srl  ra,1                       ; LSR A             ;
17578                                                                          ; QQ3 bit 2 = 0 = Industrial
17579                                                                          ; QQ3 bit 2 = 1 = Agricultural
17580                                                                          ;
17581                                                                          ; So we fetch QQ3 into A and set A = bit 2 of QQ3 using
17582                                                                          ; two right shifts (which will work as QQ3 is only a
17583                                                                          ; 3-bit number)
17584               
17585                      .clc                            ; CLC               ; Print recursive token 8 + A, followed by a paragraph
     **** ****     > CLC
0001 4F8A 0A13  18        sla  rzero,1
                   < elite.a99
17586                      .adi (>a8*256)                  ; ADC #168          ; break and Sentence Case, so:
     **** ****     > ADI
0001 4F8C 1701  14        jnc  !
0002 4F8E B004  18        ab   rone,ra
0003               !:
0004 4F90 0220  22        ai   ra,(>A8*256)
     4F92 A800     
                   < elite.a99
17587 4F94 0206  20        li   rtmp,TT60                  ; JSR TT60          ;
     4F96 4ED4     
17588 4F98 06A0  28        bl   @jsr                       ;
     4F9A 8002     
17589                                                                          ; QQ3 bit 2 = 0 prints token 8 ("INDUSTRIAL")
17590                                                                          ; QQ3 bit 2 = 1 prints token 9 ("AGRICULTURAL")
17591               
17592 4F9C 0200  20        li   ra,>a2*256                 ; LDA #162          ; Print recursive token 2 ("GOVERNMENT") followed by
     4F9E A200     
17593 4FA0 0206  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     4FA2 66D0     
17594 4FA4 06A0  28        bl   @jsr                       ;
     4FA6 8002     
17595               
17596 4FA8 D020  30        movb @QQ4,ra                    ; LDA QQ4           ; The system's government is determined by the value in
     4FAA 0F29     
17597                                                                          ; QQ4, so fetch it into A
17598               
17599                      .clc                            ; CLC               ; Print recursive token 17 + A, followed by a paragraph
     **** ****     > CLC
0001 4FAC 0A13  18        sla  rzero,1
                   < elite.a99
17600                      .adi (>b1*256)                  ; ADC #177          ; break and Sentence Case, so:
     **** ****     > ADI
0001 4FAE 1701  14        jnc  !
0002 4FB0 B004  18        ab   rone,ra
0003               !:
0004 4FB2 0220  22        ai   ra,(>B1*256)
     4FB4 B100     
                   < elite.a99
17601 4FB6 0206  20        li   rtmp,TT60                  ; JSR TT60          ;
     4FB8 4ED4     
17602 4FBA 06A0  28        bl   @jsr                       ;
     4FBC 8002     
17603                                                                          ; QQ4 = 0 prints token 17 ("ANARCHY")
17604                                                                          ; QQ4 = 1 prints token 18 ("FEUDAL")
17605                                                                          ; QQ4 = 2 prints token 19 ("MULTI-GOVERNMENT")
17606                                                                          ; QQ4 = 3 prints token 20 ("DICTATORSHIP")
17607                                                                          ; QQ4 = 4 prints token 21 ("COMMUNIST")
17608                                                                          ; QQ4 = 5 prints token 22 ("CONFEDERACY")
17609                                                                          ; QQ4 = 6 prints token 23 ("DEMOCRACY")
17610                                                                          ; QQ4 = 7 prints token 24 ("CORPORATE STATE")
17611               
17612 4FBE 0200  20        li   ra,>c4*256                 ; LDA #196          ; Print recursive token 36 ("TECH.LEVEL") followed by a
     4FC0 C400     
17613 4FC2 0206  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     4FC4 66D0     
17614 4FC6 06A0  28        bl   @jsr                       ;
     4FC8 8002     
17615               
17616 4FCA D060  30        movb @QQ5,rx                    ; LDX QQ5           ; Fetch the tech level from QQ5 and increment it, as it
     4FCC 0F2A     
17617 4FCE B044  18        ab   rone,rx                    ; INX               ; is stored in the range 0-14 but the displayed range
17618                                                                          ; should be 1-15
17619               
17620                      .clc                            ; CLC               ; Call pr2 to print the technology level as a 3-digit
     **** ****     > CLC
0001 4FD0 0A13  18        sla  rzero,1
                   < elite.a99
17621 4FD2 0206  20        li   rtmp,pr2_                  ; JSR pr2           ; number without a decimal point (by clearing the C
     4FD4 2FAC     
17622 4FD6 06A0  28        bl   @jsr                       ;
     4FD8 8002     
17623                                                                          ; flag)
17624               
17625 4FDA 0206  20        li   rtmp,TTX69                 ; JSR TTX69         ; Print a paragraph break and set Sentence Case
     4FDC 4EDC     
17626 4FDE 06A0  28        bl   @jsr                       ;
     4FE0 8002     
17627               
17628 4FE2 0200  20        li   ra,>c0*256                 ; LDA #192          ; Print recursive token 32 ("POPULATION") followed by a
     4FE4 C000     
17629 4FE6 0206  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     4FE8 66D0     
17630 4FEA 06A0  28        bl   @jsr                       ;
     4FEC 8002     
17631               
17632                      .sec                            ; SEC               ; Call pr2 to print the population as a 3-digit number
     **** ****     > SEC
0001 4FEE 0A15  18        sla  rmone,1
                   < elite.a99
17633 4FF0 D060  30        movb @QQ6,rx                    ; LDX QQ6           ; with a decimal point (by setting the C flag), so the
     4FF2 0F2B     
17634 4FF4 0206  20        li   rtmp,pr2_                  ; JSR pr2           ; number printed will be population / 10
     4FF6 2FAC     
17635 4FF8 06A0  28        bl   @jsr                       ;
     4FFA 8002     
17636               
17637 4FFC 0200  20        li   ra,>c6*256                 ; LDA #198          ; Print recursive token 38 (" BILLION"), followed by a
     4FFE C600     
17638 5000 0206  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case
     5002 4ED4     
17639 5004 06A0  28        bl   @jsr                       ;
     5006 8002     
17640               
17641 5008 0200  20        li   ra,('(')*256               ; LDA #'('          ; Print an opening bracket
     500A 2800     
17642 500C 0206  20        li   rtmp,TT27                  ; JSR TT27
     500E 66DC     
17643 5010 06A0  28        bl   @jsr                       ;
     5012 8002     
17644               
17645 5014 D020  30        movb @QQ15+4,ra                 ; LDA QQ15+4        ; Now to calculate the species, so first check bit 7 of
     5016 007C     
17646 5018 1108  14        jlt  TT75                       ; BMI TT75          ; s2_lo, and if it is set, jump to TT75 as this is an
17647                                                                          ; alien species
17648               
17649 501A 0200  20        li   ra,>bc*256                 ; LDA #188          ; Bit 7 of s2_lo is clear, so print recursive token 28
     501C BC00     
17650 501E 0206  20        li   rtmp,TT27                  ; JSR TT27          ; ("HUMAN COLONIAL")
     5020 66DC     
17651 5022 06A0  28        bl   @jsr                       ;
     5024 8002     
17652               
17653 5026 0460  28        b    @TT76                      ; JMP TT76          ; Jump to TT76 to print "S)" and a paragraph break, so
     5028 50BE     
17654                                                                          ; the whole species string is "(HUMAN COLONIALS)"
17655               
17656               TT75:
17657 502A D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; This is an alien species, and we start with the first
     502C 007D     
17658 502E 0910  18        srl  ra,1                       ; LSR A             ; adjective, so fetch bits 2-7 of s2_hi into A and push
17659 5030 0910  18        srl  ra,1                       ; LSR A             ; onto the stack so we can use this later
17660                      .pha                            ; PHA
     **** ****     > PHA
0001 5032 D680  30        movb ra,*rsp
0002 5034 060A  14        dec  rsp
                   < elite.a99
17661               
17662 5036 0240  22        andi ra,>07*256                 ; AND #%00000111    ; Set A = bits 0-2 of A (so that's bits 2-4 of s2_hi)
     5038 0700     
17663               
17664 503A 0280  22        ci   ra,>03*256                 ; CMP #3            ; If A >= 3, jump to TT205 to skip the first adjective,
     503C 0300     
17665 503E 1808  14        joc  TT205                      ; BCS TT205
17666               
17667                      .adi (>e3*256)                  ; ADC #227          ; Otherwise A = 0, 1 or 2, so print recursive token
     **** ****     > ADI
0001 5040 1701  14        jnc  !
0002 5042 B004  18        ab   rone,ra
0003               !:
0004 5044 0220  22        ai   ra,(>E3*256)
     5046 E300     
                   < elite.a99
17668 5048 0206  20        li   rtmp,spc_                  ; JSR spc           ; 67 + A, followed by a space, so:
     504A 4EFE     
17669 504C 06A0  28        bl   @jsr                       ;
     504E 8002     
17670                                                                          ;
17671                                                                          ; A = 0 prints token 67 ("LARGE") and a space
17672                                                                          ; A = 1 prints token 68 ("FIERCE") and a space
17673                                                                          ; A = 2 prints token 69 ("SMALL") and a space
17674               
17675               TT205:
17676                      .pla                            ; PLA               ; Now for the second adjective, so restore A to bits
     **** ****     > PLA
0001 5050 058A  14        inc  rsp
0002 5052 D01A  26        movb *rsp,ra
                   < elite.a99
17677 5054 0910  18        srl  ra,1                       ; LSR A             ; 2-7 of s2_hi, and throw away bits 2-4 to leave
17678 5056 0910  18        srl  ra,1                       ; LSR A             ; A = bits 5-7 of s2_hi
17679 5058 0910  18        srl  ra,1                       ; LSR A
17680               
17681 505A 0280  22        ci   ra,>06*256                 ; CMP #6            ; If A >= 6, jump to TT206 to skip the second adjective
     505C 0600     
17682 505E 1808  14        joc  TT206                      ; BCS TT206
17683               
17684                      .adi (>e6*256)                  ; ADC #230          ; Otherwise A = 0 to 5, so print recursive token
     **** ****     > ADI
0001 5060 1701  14        jnc  !
0002 5062 B004  18        ab   rone,ra
0003               !:
0004 5064 0220  22        ai   ra,(>E6*256)
     5066 E600     
                   < elite.a99
17685 5068 0206  20        li   rtmp,spc_                  ; JSR spc           ; 70 + A, followed by a space, so:
     506A 4EFE     
17686 506C 06A0  28        bl   @jsr                       ;
     506E 8002     
17687                                                                          ;
17688                                                                          ; A = 0 prints token 70 ("GREEN") and a space
17689                                                                          ; A = 1 prints token 71 ("RED") and a space
17690                                                                          ; A = 2 prints token 72 ("YELLOW") and a space
17691                                                                          ; A = 3 prints token 73 ("BLUE") and a space
17692                                                                          ; A = 4 prints token 74 ("BLACK") and a space
17693                                                                          ; A = 5 prints token 75 ("HARMLESS") and a space
17694               
17695               TT206:
17696 5070 D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Now for the third adjective, so EOR the high bytes of
     5072 007B     
17697                      .eor @QQ15+1                    ; EOR QQ15+1        ; s0 and s1 and extract bits 0-2 of the result:
     **** ****     > EOR
0001 5074 D1A0  30        movb @QQ15+1,rtmp
     5076 0079     
0002 5078 2806  18        xor  rtmp,ra
                   < elite.a99
17698 507A 0240  22        andi ra,>07*256                 ; AND #%00000111    ;
     507C 0700     
17699 507E D800  30        movb ra,@QQ19                   ; STA QQ19          ; A = (s0_hi EOR s1_hi) AND %111
     5080 007F     
17700                                                                          ;
17701                                                                          ; storing the result in QQ19 so we can use it later
17702               
17703 5082 0280  22        ci   ra,>06*256                 ; CMP #6            ; If A >= 6, jump to TT207 to skip the third adjective
     5084 0600     
17704 5086 1808  14        joc  TT207                      ; BCS TT207
17705               
17706                      .adi (>ec*256)                  ; ADC #236          ; Otherwise A = 0 to 5, so print recursive token
     **** ****     > ADI
0001 5088 1701  14        jnc  !
0002 508A B004  18        ab   rone,ra
0003               !:
0004 508C 0220  22        ai   ra,(>EC*256)
     508E EC00     
                   < elite.a99
17707 5090 0206  20        li   rtmp,spc_                  ; JSR spc           ; 76 + A, followed by a space, so:
     5092 4EFE     
17708 5094 06A0  28        bl   @jsr                       ;
     5096 8002     
17709                                                                          ;
17710                                                                          ; A = 0 prints token 76 ("SLIMY") and a space
17711                                                                          ; A = 1 prints token 77 ("BUG-EYED") and a space
17712                                                                          ; A = 2 prints token 78 ("HORNED") and a space
17713                                                                          ; A = 3 prints token 79 ("BONY") and a space
17714                                                                          ; A = 4 prints token 80 ("FAT") and a space
17715                                                                          ; A = 5 prints token 81 ("FURRY") and a space
17716               
17717               TT207:
17718 5098 D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Now for the actual species, so take bits 0-1 of
     509A 007D     
17719 509C 0240  22        andi ra,>03*256                 ; AND #%00000011    ; s2_hi, add this to the value of A that we used for
     509E 0300     
17720                      .clc                            ; CLC               ; the third adjective, and take bits 0-2 of the result
     **** ****     > CLC
0001 50A0 0A13  18        sla  rzero,1
                   < elite.a99
17721                      .adc @QQ19,ra                   ; ADC QQ19
     **** ****     > ADC
0001 50A2 1701  14        jnc  !
0002 50A4 B004  18        ab   rone,ra
0003               !:
0004 50A6 B020  30        ab   @QQ19,ra
     50A8 007F     
                   < elite.a99
17722 50AA 0240  22        andi ra,>07*256                 ; AND #%00000111
     50AC 0700     
17723               
17724                      .adi (>f2*256)                  ; ADC #242          ; A = 0 to 7, so print recursive token 82 + A, so:
     **** ****     > ADI
0001 50AE 1701  14        jnc  !
0002 50B0 B004  18        ab   rone,ra
0003               !:
0004 50B2 0220  22        ai   ra,(>F2*256)
     50B4 F200     
                   < elite.a99
17725 50B6 0206  20        li   rtmp,TT27                  ; JSR TT27          ;
     50B8 66DC     
17726 50BA 06A0  28        bl   @jsr                       ;
     50BC 8002     
17727                                                                          ; A = 0 prints token 82 ("RODENT")
17728                                                                          ; A = 1 prints token 83 ("FROG")
17729                                                                          ; A = 2 prints token 84 ("LIZARD")
17730                                                                          ; A = 3 prints token 85 ("LOBSTER")
17731                                                                          ; A = 4 prints token 86 ("BIRD")
17732                                                                          ; A = 5 prints token 87 ("HUMANOID")
17733                                                                          ; A = 6 prints token 88 ("FELINE")
17734                                                                          ; A = 7 prints token 89 ("INSECT")
17735               
17736               TT76:
17737 50BE 0200  20        li   ra,('S')*256               ; LDA #'S'          ; Print an "S" to pluralise the species
     50C0 5300     
17738 50C2 0206  20        li   rtmp,TT27                  ; JSR TT27
     50C4 66DC     
17739 50C6 06A0  28        bl   @jsr                       ;
     50C8 8002     
17740               
17741 50CA 0200  20        li   ra,(')')*256               ; LDA #')'          ; And finally, print a closing bracket, followed by a
     50CC 2900     
17742 50CE 0206  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case, to end the species
     50D0 4ED4     
17743 50D2 06A0  28        bl   @jsr                       ;
     50D4 8002     
17744                                                                          ; section
17745               
17746 50D6 0200  20        li   ra,>c1*256                 ; LDA #193          ; Print recursive token 33 ("GROSS PRODUCTIVITY"),
     50D8 C100     
17747 50DA 0206  20        li   rtmp,TT68                  ; JSR TT68          ; followed by a colon
     50DC 66D0     
17748 50DE 06A0  28        bl   @jsr                       ;
     50E0 8002     
17749               
17750 50E2 D060  30        movb @QQ7,rx                    ; LDX QQ7           ; Fetch the 16-bit productivity value from QQ7 into
     50E4 0F2D     
17751 50E6 D0A0  30        movb @QQ7+1,ry                  ; LDY QQ7+1         ; (Y X)
     50E8 0F2E     
17752               
17753 50EA 0206  20        li   rtmp,pr6_                  ; JSR pr6           ; Print (Y X) to 5 digits with no decimal point
     50EC 5D44     
17754 50EE 06A0  28        bl   @jsr                       ;
     50F0 8002     
17755               
17756 50F2 0206  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     50F4 5E64     
17757 50F6 06A0  28        bl   @jsr                       ;
     50F8 8002     
17758               
17759 50FA 0200  20        li   ra,>00*256                 ; LDA #0            ; Set QQ17 = 0 to switch to ALL CAPS
     50FC 0000     
17760 50FE D800  30        movb ra,@QQ17                   ; STA QQ17
     5100 007E     
17761               
17762 5102 0200  20        li   ra,('M')*256               ; LDA #'M'          ; Print "M"
     5104 4D00     
17763 5106 0206  20        li   rtmp,TT27                  ; JSR TT27
     5108 66DC     
17764 510A 06A0  28        bl   @jsr                       ;
     510C 8002     
17765               
17766 510E 0200  20        li   ra,>e2*256                 ; LDA #226          ; Print recursive token 66 (" CR"), followed by a
     5110 E200     
17767 5112 0206  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case
     5114 4ED4     
17768 5116 06A0  28        bl   @jsr                       ;
     5118 8002     
17769               
17770 511A 0200  20        li   ra,>fa*256                 ; LDA #250          ; Print recursive token 90 ("AVERAGE RADIUS"), followed
     511C FA00     
17771 511E 0206  20        li   rtmp,TT68                  ; JSR TT68          ; by a colon
     5120 66D0     
17772 5122 06A0  28        bl   @jsr                       ;
     5124 8002     
17773               
17774                                                                          ; The average radius is calculated like this:
17775                                                                          ;
17776                                                                          ; ((s2_hi AND %1111) + 11) * 256 + s1_hi
17777                                                                          ;
17778                                                                          ; or, in terms of memory locations:
17779                                                                          ;
17780                                                                          ; ((QQ15+5 AND %1111) + 11) * 256 + QQ15+3
17781                                                                          ;
17782                                                                          ; Because the multiplication is by 256, this is the
17783                                                                          ; same as saying a 16-bit number, with high byte:
17784                                                                          ;
17785                                                                          ; (QQ15+5 AND %1111) + 11
17786                                                                          ;
17787                                                                          ; and low byte:
17788                                                                          ;
17789                                                                          ; QQ15+3
17790                                                                          ;
17791                                                                          ; so we can set this up in (Y X) and call the pr5
17792                                                                          ; routine to print it out
17793               
17794 5126 D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Set A = QQ15+5
     5128 007D     
17795 512A D060  30        movb @QQ15+3,rx                 ; LDX QQ15+3        ; Set X = QQ15+3
     512C 007B     
17796               
17797 512E 0240  22        andi ra,>0f*256                 ; AND #%00001111    ; Set Y = (A AND %1111) + 11
     5130 0F00     
17798                      .clc                            ; CLC
     **** ****     > CLC
0001 5132 0A13  18        sla  rzero,1
                   < elite.a99
17799                      .adi (>0b*256)                  ; ADC #11
     **** ****     > ADI
0001 5134 1701  14        jnc  !
0002 5136 B004  18        ab   rone,ra
0003               !:
0004 5138 0220  22        ai   ra,(>0B*256)
     513A 0B00     
                   < elite.a99
17800 513C D080  18        movb ra,ry                      ; TAY
17801               
17802 513E 0206  20        li   rtmp,pr5_                  ; JSR pr5           ; Print (Y X) to 5 digits, not including a decimal
     5140 5D46     
17803 5142 06A0  28        bl   @jsr                       ;
     5144 8002     
17804                                                                          ; point, as the C flag will be clear (as the maximum
17805                                                                          ; radius will always fit into 16 bits)
17806               
17807 5146 0206  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     5148 5E64     
17808 514A 06A0  28        bl   @jsr                       ;
     514C 8002     
17809               
17810 514E 0200  20        li   ra,('k')*256               ; LDA #'k'          ; Print "km", returning from the subroutine using a
     5150 6B00     
17811 5152 0206  20        li   rtmp,TT26                  ; JSR TT26          ; tail call
     5154 3172     
17812 5156 06A0  28        bl   @jsr                       ;
     5158 8002     
17813 515A 0200  20        li   ra,('m')*256               ; LDA #'m'
     515C 6D00     
17814 515E 0460  28        b    @TT26                      ; JMP TT26
     5160 3172     
17815               
17816               * ******************************************************************************
17817               *
17818               * Name: TT24
17819               * Type: Subroutine
17820               * Category: Universe
17821               * Summary: Calculate system data from the system seeds
17822               * Deep dive: Generating system data
17823               * Galaxy and system seeds
17824               *
17825               * ------------------------------------------------------------------------------
17826               *
17827               * Calculate system data from the seeds in QQ15 and store them in the relevant
17828               * locations. Specifically, this routine calculates the following from the three
17829               * 16-bit seeds in QQ15 (using only s0_hi, s1_hi and s1_lo):
17830               *
17831               * QQ3 = economy (0-7)
17832               * QQ4 = government (0-7)
17833               * QQ5 = technology level (0-14)
17834               * QQ6 = population * 10 (1-71)
17835               * QQ7 = productivity (96-62480)
17836               *
17837               * The ranges of the various values are shown in brackets. Note that the radius
17838               * and type of inhabitant are calculated on-the-fly in the TT25 routine when
17839               * the system data gets displayed, so they aren't calculated here.
17840               *
17841               * ******************************************************************************
17842               
17843               TT24:
17844 5162 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch s0_hi and extract bits 0-2 to determine the
     5164 0079     
17845 5166 0240  22        andi ra,>07*256                 ; AND #%00000111    ; system's economy, and store in QQ3
     5168 0700     
17846 516A D800  30        movb ra,@QQ3                    ; STA QQ3
     516C 0F28     
17847               
17848 516E D020  30        movb @QQ15+2,ra                 ; LDA QQ15+2        ; Fetch s1_lo and extract bits 3-5 to determine the
     5170 007A     
17849 5172 0910  18        srl  ra,1                       ; LSR A             ; system's government, and store in QQ4
17850 5174 0910  18        srl  ra,1                       ; LSR A
17851 5176 0910  18        srl  ra,1                       ; LSR A
17852 5178 0240  22        andi ra,>07*256                 ; AND #%00000111
     517A 0700     
17853 517C D800  30        movb ra,@QQ4                    ; STA QQ4
     517E 0F29     
17854               
17855 5180 0910  18        srl  ra,1                       ; LSR A             ; If government isn't anarchy or feudal, skip to TT77,
17856 5182 1606  14        jne  TT77                       ; BNE TT77          ; as we need to fix the economy of anarchy and feudal
17857                                                                          ; systems so they can't be rich
17858               
17859 5184 D020  30        movb @QQ3,ra                    ; LDA QQ3           ; Set bit 1 of the economy in QQ3 to fix the economy
     5186 0F28     
17860 5188 0260  22        ori  ra,>02*256                 ; ORA #%00000010    ; for anarchy and feudal governments
     518A 0200     
17861 518C D800  30        movb ra,@QQ3                    ; STA QQ3
     518E 0F28     
17862               
17863               TT77:
17864 5190 D020  30        movb @QQ3,ra                    ; LDA QQ3           ; Now to work out the tech level, which we do like this:
     5192 0F28     
17865                      .eoi (>07*256)                  ; EOR #%00000111    ;
     **** ****     > EOI
0001 5194 0206  20        li   rtmp,(>07*256)
     5196 0700     
0002 5198 2806  18        xor  rtmp,ra
                   < elite.a99
17866                      .clc                            ; CLC               ; flipped_economy + (s1_hi AND %11) + (government / 2)
     **** ****     > CLC
0001 519A 0A13  18        sla  rzero,1
                   < elite.a99
17867 519C D800  30        movb ra,@QQ5                    ; STA QQ5           ;
     519E 0F2A     
17868                                                                          ; or, in terms of memory locations:
17869                                                                          ;
17870                                                                          ; QQ5 = (QQ3 EOR %111) + (QQ15+3 AND %11) + (QQ4 / 2)
17871                                                                          ;
17872                                                                          ; We start by setting QQ5 = QQ3 EOR %111
17873               
17874 51A0 D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; We then take the first 2 bits of s1_hi (QQ15+3) and
     51A2 007B     
17875 51A4 0240  22        andi ra,>03*256                 ; AND #%00000011    ; add it into QQ5
     51A6 0300     
17876                      .adc @QQ5,ra                    ; ADC QQ5
     **** ****     > ADC
0001 51A8 1701  14        jnc  !
0002 51AA B004  18        ab   rone,ra
0003               !:
0004 51AC B020  30        ab   @QQ5,ra
     51AE 0F2A     
                   < elite.a99
17877 51B0 D800  30        movb ra,@QQ5                    ; STA QQ5
     51B2 0F2A     
17878               
17879 51B4 D020  30        movb @QQ4,ra                    ; LDA QQ4           ; And finally we add QQ4 / 2 and store the result in
     51B6 0F29     
17880 51B8 0910  18        srl  ra,1                       ; LSR A             ; QQ5, using LSR then ADC to divide by 2, which rounds
17881                      .adc @QQ5,ra                    ; ADC QQ5           ; up the result for odd-numbered government types
     **** ****     > ADC
0001 51BA 1701  14        jnc  !
0002 51BC B004  18        ab   rone,ra
0003               !:
0004 51BE B020  30        ab   @QQ5,ra
     51C0 0F2A     
                   < elite.a99
17882 51C2 D800  30        movb ra,@QQ5                    ; STA QQ5
     51C4 0F2A     
17883               
17884                      .asla                           ; ASL A             ; Now to work out the population, like so:
     **** ****     > ASLA
0001 51C6 0240  22        andi ra,>ff00
     51C8 FF00     
0002 51CA 0A10  18        sla  ra,1
                   < elite.a99
17885                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 51CC 0240  22        andi ra,>ff00
     51CE FF00     
0002 51D0 0A10  18        sla  ra,1
                   < elite.a99
17886                      .adc @QQ3,ra                    ; ADC QQ3           ; (tech level * 4) + economy + government + 1
     **** ****     > ADC
0001 51D2 1701  14        jnc  !
0002 51D4 B004  18        ab   rone,ra
0003               !:
0004 51D6 B020  30        ab   @QQ3,ra
     51D8 0F28     
                   < elite.a99
17887                      .adc @QQ4,ra                    ; ADC QQ4           ;
     **** ****     > ADC
0001 51DA 1701  14        jnc  !
0002 51DC B004  18        ab   rone,ra
0003               !:
0004 51DE B020  30        ab   @QQ4,ra
     51E0 0F29     
                   < elite.a99
17888                      .adi (>01*256)                  ; ADC #1            ; or, in terms of memory locations:
     **** ****     > ADI
0001 51E2 1701  14        jnc  !
0002 51E4 B004  18        ab   rone,ra
0003               !:
0004 51E6 0220  22        ai   ra,(>01*256)
     51E8 0100     
                   < elite.a99
17889 51EA D800  30        movb ra,@QQ6                    ; STA QQ6           ;
     51EC 0F2B     
17890                                                                          ; QQ6 = (QQ5 * 4) + QQ3 + QQ4 + 1
17891               
17892 51EE D020  30        movb @QQ3,ra                    ; LDA QQ3           ; Finally, we work out productivity, like this:
     51F0 0F28     
17893                      .eoi (>07*256)                  ; EOR #%00000111    ;
     **** ****     > EOI
0001 51F2 0206  20        li   rtmp,(>07*256)
     51F4 0700     
0002 51F6 2806  18        xor  rtmp,ra
                   < elite.a99
17894                      .adi (>03*256)                  ; ADC #3            ; (flipped_economy + 3) * (government + 4)
     **** ****     > ADI
0001 51F8 1701  14        jnc  !
0002 51FA B004  18        ab   rone,ra
0003               !:
0004 51FC 0220  22        ai   ra,(>03*256)
     51FE 0300     
                   < elite.a99
17895 5200 D800  30        movb ra,@P                      ; STA P             ; * population
     5202 001B     
17896 5204 D020  30        movb @QQ4,ra                    ; LDA QQ4           ; * 8
     5206 0F29     
17897                      .adi (>04*256)                  ; ADC #4            ;
     **** ****     > ADI
0001 5208 1701  14        jnc  !
0002 520A B004  18        ab   rone,ra
0003               !:
0004 520C 0220  22        ai   ra,(>04*256)
     520E 0400     
                   < elite.a99
17898 5210 D800  30        movb ra,@Q                      ; STA Q             ; or, in terms of memory locations:
     5212 0090     
17899 5214 0206  20        li   rtmp,MULTU                 ; JSR MULTU         ;
     5216 42DE     
17900 5218 06A0  28        bl   @jsr                       ;
     521A 8002     
17901                                                                          ; QQ7 = (QQ3 EOR %111 + 3) * (QQ4 + 4) * QQ6 * 8
17902                                                                          ;
17903                                                                          ; We do the first step by setting P to the first
17904                                                                          ; expression in brackets and Q to the second, and
17905                                                                          ; calling MULTU, so now (A P) = P * Q. The highest this
17906                                                                          ; can be is 10 * 11 (as the maximum values of economy
17907                                                                          ; and government are 7), so the high byte of the result
17908                                                                          ; will always be 0, so we actually have:
17909                                                                          ;
17910                                                                          ; P = P * Q
17911                                                                          ; = (flipped_economy + 3) * (government + 4)
17912               
17913 521C D020  30        movb @QQ6,ra                    ; LDA QQ6           ; We now take the result in P and multiply by the
     521E 0F2B     
17914 5220 D800  30        movb ra,@Q                      ; STA Q             ; population to get the productivity, by setting Q to
     5222 0090     
17915 5224 0206  20        li   rtmp,MULTU                 ; JSR MULTU         ; the population from QQ6 and calling MULTU again, so
     5226 42DE     
17916 5228 06A0  28        bl   @jsr                       ;
     522A 8002     
17917                                                                          ; now we have:
17918                                                                          ;
17919                                                                          ; (A P) = P * population
17920               
17921                      .asl @P                         ; ASL P             ; Next we multiply the result by 8, as a 16-bit number,
     **** ****     > ASL
0001 522C D1A0  30        movb @P,rtmp
     522E 001B     
0002 5230 0246  22        andi rtmp,>ff00
     5232 FF00     
0003 5234 0A16  18        sla  rtmp,1
0004 5236 D806  30        movb rtmp,@P
     5238 001B     
                   < elite.a99
17922 523A 06A0  28        bl   @rola                      ; ROL A             ; so we shift both bytes to the left three times, using
     523C 8018     
17923                      .asl @P                         ; ASL P             ; the C flag to carry bits from bit 7 of the low byte
     **** ****     > ASL
0001 523E D1A0  30        movb @P,rtmp
     5240 001B     
0002 5242 0246  22        andi rtmp,>ff00
     5244 FF00     
0003 5246 0A16  18        sla  rtmp,1
0004 5248 D806  30        movb rtmp,@P
     524A 001B     
                   < elite.a99
17924 524C 06A0  28        bl   @rola                      ; ROL A             ; into bit 0 of the high byte
     524E 8018     
17925                      .asl @P                         ; ASL P
     **** ****     > ASL
0001 5250 D1A0  30        movb @P,rtmp
     5252 001B     
0002 5254 0246  22        andi rtmp,>ff00
     5256 FF00     
0003 5258 0A16  18        sla  rtmp,1
0004 525A D806  30        movb rtmp,@P
     525C 001B     
                   < elite.a99
17926 525E 06A0  28        bl   @rola                      ; ROL A
     5260 8018     
17927               
17928 5262 D800  30        movb ra,@QQ7+1                  ; STA QQ7+1         ; Finally, we store the productivity in two bytes, with
     5264 0F2E     
17929 5266 D020  30        movb @P,ra                      ; LDA P             ; the low byte in QQ7 and the high byte in QQ7+1
     5268 001B     
17930 526A D800  30        movb ra,@QQ7                    ; STA QQ7
     526C 0F2D     
17931               
17932 526E 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     5270 800E     
17933               
17934               * ******************************************************************************
17935               *
17936               * Name: TT22
17937               * Type: Subroutine
17938               * Category: Charts
17939               * Summary: Show the Long-range Chart (red key f4)
17940               *
17941               * ******************************************************************************
17942               
17943               TT22:
17944 5272 0200  20        li   ra,>40*256                 ; LDA #64           ; Clear the top part of the screen, draw a white border,
     5274 4000     
17945 5276 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 32 (Long-
     5278 4B2A     
17946 527A 06A0  28        bl   @jsr                       ;
     527C 8002     
17947                                                                          ; range Chart)
17948               
17949 527E 0200  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     5280 0700     
17950 5282 D800  30        movb ra,@XC                     ; STA XC
     5284 002C     
17951               
17952 5286 0206  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     5288 5AA4     
17953 528A 06A0  28        bl   @jsr                       ;
     528C 8002     
17954                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
17955               
17956 528E 0200  20        li   ra,>c7*256                 ; LDA #199          ; Print recursive token 39 ("GALACTIC CHART{galaxy
     5290 C700     
17957 5292 0206  20        li   rtmp,TT27                  ; JSR TT27          ; number right-aligned to width 3}")
     5294 66DC     
17958 5296 06A0  28        bl   @jsr                       ;
     5298 8002     
17959               
17960 529A 0206  20        li   rtmp,NLIN                  ; JSR NLIN          ; Draw a horizontal line at pixel row 23 to box in the
     529C 25BE     
17961 529E 06A0  28        bl   @jsr                       ;
     52A0 8002     
17962                                                                          ; title and act as the top frame of the chart, and move
17963                                                                          ; the text cursor down one line
17964               
17965 52A2 0200  20        li   ra,>98*256                 ; LDA #152          ; Draw a screen-wide horizontal line at pixel row 152
     52A4 9800     
17966 52A6 0206  20        li   rtmp,NLIN2                 ; JSR NLIN2         ; for the bottom edge of the chart, so the chart itself
     52A8 25C4     
17967 52AA 06A0  28        bl   @jsr                       ;
     52AC 8002     
17968                                                                          ; is 128 pixels high, starting on row 24 and ending on
17969                                                                          ; row 151
17970               
17971 52AE 0206  20        li   rtmp,TT14                  ; JSR TT14          ; Call TT14 to draw a circle with crosshairs at the
     52B0 53FA     
17972 52B2 06A0  28        bl   @jsr                       ;
     52B4 8002     
17973                                                                          ; current system's galactic coordinates
17974               
17975 52B6 0201  20        li   rx,>00*256                 ; LDX #0            ; We're now going to plot each of the galaxy's systems,
     52B8 0000     
17976                                                                          ; so set up a counter in X for each system, starting at
17977                                                                          ; 0 and looping through to 255
17978               
17979               TT83:
17980 52BA D801  30        movb rx,@XSAV                   ; STX XSAV          ; Store the counter in XSAV
     52BC 0093     
17981               
17982 52BE D060  30        movb @QQ15+3,rx                 ; LDX QQ15+3        ; Fetch the s1_hi seed into X, which gives us the
     52C0 007B     
17983                                                                          ; galactic x-coordinate of this system
17984               
17985 52C2 D0A0  30        movb @QQ15+4,ry                 ; LDY QQ15+4        ; Fetch the s2_lo seed and set bits 4 and 6, storing the
     52C4 007C     
17986 52C6 D002  18        movb ry,ra                      ; TYA               ; result in ZZ to give a random number between 80 and
17987 52C8 0260  22        ori  ra,>50*256                 ; ORA #%01010000    ; (but which will always be the same for this system).
     52CA 5000     
17988 52CC D800  30        movb ra,@ZZ                     ; STA ZZ            ; We use this value to determine the size of the point
     52CE 0097     
17989                                                                          ; for this system on the chart by passing it as the
17990                                                                          ; distance argument to the PIXEL routine below
17991               
17992 52D0 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch the s0_hi seed into A, which gives us the
     52D2 0079     
17993                                                                          ; galactic y-coordinate of this system
17994               
17995 52D4 0910  18        srl  ra,1                       ; LSR A             ; We halve the y-coordinate because the galaxy in
17996                                                                          ; in Elite is rectangular rather than square, and is
17997                                                                          ; twice as wide (x-axis) as it is high (y-axis), so the
17998                                                                          ; chart is 256 pixels wide and 128 high
17999               
18000                      .clc                            ; CLC               ; Add 24 to the halved y-coordinate and store in XX15+1
     **** ****     > CLC
0001 52D6 0A13  18        sla  rzero,1
                   < elite.a99
18001                      .adi (>18*256)                  ; ADC #24           ; (as the top of the chart is on pixel row 24, just
     **** ****     > ADI
0001 52D8 1701  14        jnc  !
0002 52DA B004  18        ab   rone,ra
0003               !:
0004 52DC 0220  22        ai   ra,(>18*256)
     52DE 1800     
                   < elite.a99
18002 52E0 D800  30        movb ra,@XX15+1                 ; STA XX15+1        ; below the line we drew on row 23 above)
     52E2 0032     
18003               
18004 52E4 0206  20        li   rtmp,PIXEL                 ; JSR PIXEL         ; Call PIXEL to draw a point at (X, A), with the size of
     52E6 27BC     
18005 52E8 06A0  28        bl   @jsr                       ;
     52EA 8002     
18006                                                                          ; the point dependent on the distance specified in ZZ
18007                                                                          ; (so a high value of ZZ will produce a 1-pixel point,
18008                                                                          ; a medium value will produce a 2-pixel dash, and a
18009                                                                          ; small value will produce a 4-pixel square)
18010               
18011 52EC 0206  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     52EE 4E32     
18012 52F0 06A0  28        bl   @jsr                       ;
     52F2 8002     
18013                                                                          ; to twist the three 16-bit seeds in QQ15
18014               
18015 52F4 D060  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the loop counter from XSAV
     52F6 0093     
18016               
18017 52F8 B044  18        ab   rone,rx                    ; INX               ; Increment the counter
18018               
18019 52FA 16DF  14        jne  TT83                       ; BNE TT83          ; If X > 0 then we haven't done all 256 systems yet, so
18020                                                                          ; loop back up to TT83
18021               
18022 52FC D020  30        movb @QQ9,ra                    ; LDA QQ9           ; Set QQ19 to the selected system's x-coordinate
     52FE 0F31     
18023 5300 D800  30        movb ra,@QQ19                   ; STA QQ19
     5302 007F     
18024               
18025 5304 D020  30        movb @QQ10,ra                   ; LDA QQ10          ; Set QQ19+1 to the selected system's y-coordinate,
     5306 0F32     
18026 5308 0910  18        srl  ra,1                       ; LSR A             ; halved to fit it into the chart
18027 530A D800  30        movb ra,@QQ19+1                 ; STA QQ19+1
     530C 0080     
18028               
18029 530E 0200  20        li   ra,>04*256                 ; LDA #4            ; Set QQ19+2 to size 4 for the crosshairs size
     5310 0400     
18030 5312 D800  30        movb ra,@QQ19+2                 ; STA QQ19+2
     5314 0081     
18031               
18032                                                                          ; Fall through into TT15 to draw crosshairs of size 4 at
18033                                                                          ; the selected system's coordinates
18034               
18035               * ******************************************************************************
18036               *
18037               * Name: TT15
18038               * Type: Subroutine
18039               * Category: Drawing lines
18040               * Summary: Draw a set of crosshairs
18041               *
18042               * ------------------------------------------------------------------------------
18043               *
18044               * For all views except the Short-range Chart, the centre is drawn 24 pixels to
18045               * the right of the y-coordinate given.
18046               *
18047               * ------------------------------------------------------------------------------
18048               *
18049               * Arguments:
18050               *
18051               * QQ19                The pixel x-coordinate of the centre of the crosshairs
18052               *
18053               * QQ19+1              The pixel y-coordinate of the centre of the crosshairs
18054               *
18055               * QQ19+2              The size of the crosshairs
18056               *
18057               * ******************************************************************************
18058               
18059               TT15:
18060 5316 0200  20        li   ra,>18*256                 ; LDA #24           ; Set A to 24, which we will use as the minimum
     5318 1800     
18061                                                                          ; screen indent for the crosshairs (i.e. the minimum
18062                                                                          ; distance from the top-left corner of the screen)
18063               
18064 531A D060  30        movb @QQ11,rx                   ; LDX QQ11          ; If the current view is not the Short-range Chart,
     531C 0096     
18065 531E 1502  14        jgt  B52                        ; BPL B52           ; which is the only view with bit 7 set, then skip the
18066                                                                          ; following instruction
18067               
18068 5320 0200  20        li   ra,>00*256                 ; LDA #0            ; This is the Short-range Chart, so set A to 0, so the
     5322 0000     
18069                                                                          ; crosshairs can go right up against the screen edges
18070               
18071               B52:
18072 5324 D800  30        movb ra,@QQ19+5                 ; STA QQ19+5        ; Set QQ19+5 to A, which now contains the correct indent
     5326 0084     
18073                                                                          ; for this view
18074               
18075 5328 D020  30        movb @QQ19,ra                   ; LDA QQ19          ; Set A = crosshairs x-coordinate - crosshairs size
     532A 007F     
18076                      .sec                            ; SEC               ; to get the x-coordinate of the left edge of the
     **** ****     > SEC
0001 532C 0A15  18        sla  rmone,1
                   < elite.a99
18077                      .sbc @QQ19+2,ra                 ; SBC QQ19+2        ; crosshairs
     **** ****     > SBC
0001 532E 1801  14        joc  !
0002 5330 7004  18        sb   rone,ra
0003               !:
0004 5332 7020  30        sb   @QQ19+2,ra
     5334 0081     
                   < elite.a99
18078               
18079 5336 1802  14        joc  TT84                       ; BCS TT84          ; If the above subtraction didn't underflow, then A is
18080                                                                          ; positive, so skip the next instruction
18081               
18082 5338 0200  20        li   ra,>00*256                 ; LDA #0            ; The subtraction underflowed, so set A to 0 so the
     533A 0000     
18083                                                                          ; crosshairs don't spill out of the left of the screen
18084               
18085               TT84:
18086                                                                          ; In the following, the authors have used XX15 for
18087                                                                          ; temporary storage. XX15 shares location with X1, Y1,
18088                                                                          ; X2 and Y2, so in the following, you can consider
18089                                                                          ; the variables like this:
18090                                                                          ;
18091                                                                          ; XX15   is the same as X1
18092                                                                          ; XX15+1 is the same as Y1
18093                                                                          ; XX15+2 is the same as X2
18094                                                                          ; XX15+3 is the same as Y2
18095                                                                          ;
18096                                                                          ; Presumably this routine was written at a different
18097                                                                          ; time to the line-drawing routine, before the two
18098                                                                          ; workspaces were merged to save space
18099 533C D800  30        movb ra,@XX15                   ; STA XX15          ; Set XX15 (X1) = A (the x-coordinate of the left edge
     533E 0031     
18100                                                                          ; of the crosshairs)
18101               
18102 5340 D020  30        movb @QQ19,ra                   ; LDA QQ19          ; Set A = crosshairs x-coordinate + crosshairs size
     5342 007F     
18103                      .clc                            ; CLC               ; to get the x-coordinate of the right edge of the
     **** ****     > CLC
0001 5344 0A13  18        sla  rzero,1
                   < elite.a99
18104                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; crosshairs
     **** ****     > ADC
0001 5346 1701  14        jnc  !
0002 5348 B004  18        ab   rone,ra
0003               !:
0004 534A B020  30        ab   @QQ19+2,ra
     534C 0081     
                   < elite.a99
18105               
18106 534E 1702  14        jnc  B53                        ; BCC B53           ; If the above addition didn't overflow, then A is
18107                                                                          ; correct, so skip the next instruction
18108               
18109 5350 0200  20        li   ra,>ff*256                 ; LDA #255          ; The addition overflowed, so set A to 255 so the
     5352 FF00     
18110                                                                          ; crosshairs don't spill out of the right of the screen
18111                                                                          ; (as 255 is the x-coordinate of the rightmost pixel
18112                                                                          ; on-screen)
18113               
18114               B53:
18115 5354 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 (X2) = A (the x-coordinate of the right
     5356 0033     
18116                                                                          ; edge of the crosshairs)
18117               
18118 5358 D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set XX15+1 (Y1) = crosshairs y-coordinate + indent
     535A 0080     
18119                      .clc                            ; CLC               ; to get the y-coordinate of the centre of the
     **** ****     > CLC
0001 535C 0A13  18        sla  rzero,1
                   < elite.a99
18120                      .adc @QQ19+5,ra                 ; ADC QQ19+5        ; crosshairs
     **** ****     > ADC
0001 535E 1701  14        jnc  !
0002 5360 B004  18        ab   rone,ra
0003               !:
0004 5362 B020  30        ab   @QQ19+5,ra
     5364 0084     
                   < elite.a99
18121 5366 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     5368 0032     
18122               
18123 536A 0206  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1),
     536C 25EE     
18124 536E 06A0  28        bl   @jsr                       ;
     5370 8002     
18125                                                                          ; which will draw from the left edge of the crosshairs
18126                                                                          ; to the right edge, through the centre of the
18127                                                                          ; crosshairs
18128               
18129 5372 D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set A = crosshairs y-coordinate - crosshairs size
     5374 0080     
18130                      .sec                            ; SEC               ; to get the y-coordinate of the top edge of the
     **** ****     > SEC
0001 5376 0A15  18        sla  rmone,1
                   < elite.a99
18131                      .sbc @QQ19+2,ra                 ; SBC QQ19+2        ; crosshairs
     **** ****     > SBC
0001 5378 1801  14        joc  !
0002 537A 7004  18        sb   rone,ra
0003               !:
0004 537C 7020  30        sb   @QQ19+2,ra
     537E 0081     
                   < elite.a99
18132               
18133 5380 1802  14        joc  TT86                       ; BCS TT86          ; If the above subtraction didn't underflow, then A is
18134                                                                          ; correct, so skip the next instruction
18135               
18136 5382 0200  20        li   ra,>00*256                 ; LDA #0            ; The subtraction underflowed, so set A to 0 so the
     5384 0000     
18137                                                                          ; crosshairs don't spill out of the top of the screen
18138               
18139               TT86:
18140                      .clc                            ; CLC               ; Set XX15+1 (Y1) = A + indent to get the y-coordinate
     **** ****     > CLC
0001 5386 0A13  18        sla  rzero,1
                   < elite.a99
18141                      .adc @QQ19+5,ra                 ; ADC QQ19+5        ; of the top edge of the indented crosshairs
     **** ****     > ADC
0001 5388 1701  14        jnc  !
0002 538A B004  18        ab   rone,ra
0003               !:
0004 538C B020  30        ab   @QQ19+5,ra
     538E 0084     
                   < elite.a99
18142 5390 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     5392 0032     
18143               
18144 5394 D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set A = crosshairs y-coordinate + crosshairs size
     5396 0080     
18145                      .clc                            ; CLC               ; + indent to get the y-coordinate of the bottom edge
     **** ****     > CLC
0001 5398 0A13  18        sla  rzero,1
                   < elite.a99
18146                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; of the indented crosshairs
     **** ****     > ADC
0001 539A 1701  14        jnc  !
0002 539C B004  18        ab   rone,ra
0003               !:
0004 539E B020  30        ab   @QQ19+2,ra
     53A0 0081     
                   < elite.a99
18147                      .adc @QQ19+5,ra                 ; ADC QQ19+5
     **** ****     > ADC
0001 53A2 1701  14        jnc  !
0002 53A4 B004  18        ab   rone,ra
0003               !:
0004 53A6 B020  30        ab   @QQ19+5,ra
     53A8 0084     
                   < elite.a99
18148               
18149 53AA 0280  22        ci   ra,>98*256                 ; CMP #152          ; If A < 152 then skip the following, as the crosshairs
     53AC 9800     
18150 53AE 1705  14        jnc  TT87                       ; BCC TT87          ; won't spill out of the bottom of the screen
18151               
18152 53B0 D060  30        movb @QQ11,rx                   ; LDX QQ11          ; A >= 152, so we need to check whether this will fit in
     53B2 0096     
18153                                                                          ; this view, so fetch the view type
18154               
18155 53B4 1102  14        jlt  TT87                       ; BMI TT87          ; If this is the Short-range Chart then the y-coordinate
18156                                                                          ; is fine, so skip to TT87
18157               
18158 53B6 0200  20        li   ra,>97*256                 ; LDA #151          ; Otherwise this is the Long-range Chart, so we need to
     53B8 9700     
18159                                                                          ; clip the crosshairs at a maximum y-coordinate of 151
18160               
18161               TT87:
18162 53BA D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; Set XX15+3 (Y2) = A (the y-coordinate of the bottom
     53BC 0034     
18163                                                                          ; edge of the crosshairs)
18164               
18165 53BE D020  30        movb @QQ19,ra                   ; LDA QQ19          ; Set XX15 (X1) = the x-coordinate of the centre of the
     53C0 007F     
18166 53C2 D800  30        movb ra,@XX15                   ; STA XX15          ; crosshairs
     53C4 0031     
18167               
18168 53C6 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 (X2) = the x-coordinate of the centre of
     53C8 0033     
18169                                                                          ; the crosshairs
18170               
18171 53CA 0460  28        b    @LL30                      ; JMP LL30          ; Draw a vertical line (X1, Y1) to (X2, Y2), which will
     53CC 224E     
18172                                                                          ; draw from the top edge of the crosshairs to the bottom
18173                                                                          ; edge, through the centre of the crosshairs, returning
18174                                                                          ; from the subroutine using a tail call
18175               
18176               * ******************************************************************************
18177               *
18178               * Name: TT14
18179               * Type: Subroutine
18180               * Category: Drawing circles
18181               * Summary: Draw a circle with crosshairs on a chart
18182               *
18183               * ------------------------------------------------------------------------------
18184               *
18185               * Draw a circle with crosshairs at the current system's galactic coordinates.
18186               *
18187               * ******************************************************************************
18188               
18189               TT126:
18190 53CE 0200  20        li   ra,>68*256                 ; LDA #104          ; Set QQ19 = 104, for the x-coordinate of the centre of
     53D0 6800     
18191 53D2 D800  30        movb ra,@QQ19                   ; STA QQ19          ; the fixed circle on the Short-range Chart
     53D4 007F     
18192               
18193 53D6 0200  20        li   ra,>5a*256                 ; LDA #90           ; Set QQ19+1 = 90, for the y-coordinate of the centre of
     53D8 5A00     
18194 53DA D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; the fixed circle on the Short-range Chart
     53DC 0080     
18195               
18196 53DE 0200  20        li   ra,>10*256                 ; LDA #16           ; Set QQ19+2 = 16, the size of the crosshairs on the
     53E0 1000     
18197 53E2 D800  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Short-range Chart
     53E4 0081     
18198               
18199 53E6 0206  20        li   rtmp,TT15                  ; JSR TT15          ; Draw the set of crosshairs defined in QQ19, at the
     53E8 5316     
18200 53EA 06A0  28        bl   @jsr                       ;
     53EC 8002     
18201                                                                          ; exact coordinates as this is the Short-range Chart
18202               
18203 53EE D020  30        movb @QQ14,ra                   ; LDA QQ14          ; Set K to the fuel level from QQ14, so this can act as
     53F0 030D     
18204 53F2 D800  30        movb ra,@K                      ; STA K             ; the circle's radius (70 being a full tank)
     53F4 003D     
18205               
18206 53F6 0460  28        b    @TT128                     ; JMP TT128         ; Jump to TT128 to draw a circle with the centre at the
     53F8 5440     
18207                                                                          ; same coordinates as the crosshairs, (QQ19, QQ19+1),
18208                                                                          ; and radius K that reflects the current fuel levels,
18209                                                                          ; returning from the subroutine using a tail call
18210               
18211               TT14:
18212 53FA D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is the Short-range Chart, which
     53FC 0096     
18213 53FE 11E7  14        jlt  TT126                      ; BMI TT126         ; is the only view with bit 7 set, then jump up to TT126
18214                                                                          ; to draw the crosshairs and circle for that view
18215               
18216                                                                          ; Otherwise this is the Long-range Chart, so we draw the
18217                                                                          ; crosshairs and circle for that view instead
18218               
18219 5400 D020  30        movb @QQ14,ra                   ; LDA QQ14          ; Set K to the fuel level from QQ14 divided by 4, so
     5402 030D     
18220 5404 0910  18        srl  ra,1                       ; LSR A             ; this can act as the circle's radius (70 being a full
18221 5406 0910  18        srl  ra,1                       ; LSR A             ; tank, which divides down to a radius of 17)
18222 5408 D800  30        movb ra,@K                      ; STA K
     540A 003D     
18223               
18224 540C D020  30        movb @QQ0,ra                    ; LDA QQ0           ; Set QQ19 to the x-coordinate of the current system,
     540E 0301     
18225 5410 D800  30        movb ra,@QQ19                   ; STA QQ19          ; which will be the centre of the circle and crosshairs
     5412 007F     
18226                                                                          ; we draw
18227               
18228 5414 D020  30        movb @QQ1,ra                    ; LDA QQ1           ; Set QQ19+1 to the y-coordinate of the current system,
     5416 0302     
18229 5418 0910  18        srl  ra,1                       ; LSR A             ; halved because the galactic chart is half as high as
18230 541A D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; it is wide, which will again be the centre of the
     541C 0080     
18231                                                                          ; circle and crosshairs we draw
18232               
18233 541E 0200  20        li   ra,>07*256                 ; LDA #7            ; Set QQ19+2 = 7, the size of the crosshairs on the
     5420 0700     
18234 5422 D800  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Long-range Chart
     5424 0081     
18235               
18236 5426 0206  20        li   rtmp,TT15                  ; JSR TT15          ; Draw the set of crosshairs defined in QQ19, which will
     5428 5316     
18237 542A 06A0  28        bl   @jsr                       ;
     542C 8002     
18238                                                                          ; be drawn 24 pixels to the right of QQ19+1
18239               
18240 542E D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Add 24 to the y-coordinate of the crosshairs in QQ19+1
     5430 0080     
18241                      .clc                            ; CLC               ; so that the centre of the circle matches the centre
     **** ****     > CLC
0001 5432 0A13  18        sla  rzero,1
                   < elite.a99
18242                      .adi (>18*256)                  ; ADC #24           ; of the crosshairs
     **** ****     > ADI
0001 5434 1701  14        jnc  !
0002 5436 B004  18        ab   rone,ra
0003               !:
0004 5438 0220  22        ai   ra,(>18*256)
     543A 1800     
                   < elite.a99
18243 543C D800  30        movb ra,@QQ19+1                 ; STA QQ19+1
     543E 0080     
18244               
18245                                                                          ; Fall through into TT128 to draw a circle with the
18246                                                                          ; centre at the same coordinates as the crosshairs,
18247                                                                          ; (QQ19, QQ19+1), and radius K that reflects the
18248                                                                          ; current fuel levels
18249               
18250               * ******************************************************************************
18251               *
18252               * Name: TT128
18253               * Type: Subroutine
18254               * Category: Drawing circles
18255               * Summary: Draw a circle on a chart
18256               * Deep dive: Drawing circles
18257               *
18258               * ------------------------------------------------------------------------------
18259               *
18260               * Draw a circle with the centre at (QQ19, QQ19+1) and radius K.
18261               *
18262               * ------------------------------------------------------------------------------
18263               *
18264               * Arguments:
18265               *
18266               * QQ19                The x-coordinate of the centre of the circle
18267               *
18268               * QQ19+1              The y-coordinate of the centre of the circle
18269               *
18270               * K                   The radius of the circle
18271               *
18272               * ******************************************************************************
18273               
18274               TT128:
18275 5440 D020  30        movb @QQ19,ra                   ; LDA QQ19          ; Set K3 = the x-coordinate of the centre
     5442 007F     
18276 5444 D800  30        movb ra,@K3                     ; STA K3
     5446 00D2     
18277               
18278 5448 D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set K4 = the y-coordinate of the centre
     544A 0080     
18279 544C D800  30        movb ra,@K4                     ; STA K4
     544E 00E0     
18280               
18281 5450 0201  20        li   rx,>00*256                 ; LDX #0            ; Set the high bytes of K3(1 0) and K4(1 0) to 0
     5452 0000     
18282 5454 D801  30        movb rx,@K4+1                   ; STX K4+1
     5456 00E1     
18283 5458 D801  30        movb rx,@K3+1                   ; STX K3+1
     545A 00D3     
18284               
18285               * STX LSX                \ This instruction is commented out in the original
18286                                                                          ; source
18287               
18288 545C B044  18        ab   rone,rx                    ; INX               ; Set LSP = 1 to reset the ball line heap
18289 545E D801  30        movb rx,@LSP                    ; STX LSP
     5460 0077     
18290               
18291 5462 0201  20        li   rx,>02*256                 ; LDX #2            ; Set STP = 2, the step size for the circle
     5464 0200     
18292 5466 D801  30        movb rx,@STP                    ; STX STP
     5468 00A6     
18293               
18294 546A 0206  20        li   rtmp,CIRCLE2               ; JSR CIRCLE2       ; Call CIRCLE2 to draw a circle with the centre at
     546C 7820     
18295 546E 06A0  28        bl   @jsr                       ;
     5470 8002     
18296                                                                          ; (K3(1 0), K4(1 0)) and radius K
18297               
18298               * LDA #&FF               \ These instructions are commented out in the original
18299               * STA LSX                \ source
18300               
18301 5472 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     5474 800E     
18302               
18303               * ******************************************************************************
18304               *
18305               * Name: TT219
18306               * Type: Subroutine
18307               * Category: Market
18308               * Summary: Show the Buy Cargo screen (red key f1)
18309               *
18310               * ------------------------------------------------------------------------------
18311               *
18312               * Other entry points:
18313               *
18314               * BAY2                Jump into the main loop at FRCE, setting the key
18315               * "pressed" to red key f9 (so we show the Inventory
18316               * screen)
18317               *
18318               * ******************************************************************************
18319               
18320               TT219:
18321               * LDA #2                 \ This instruction is commented out in the original
18322                                                                          ; source. Perhaps this view originally had a QQ11 value
18323                                                                          ; of 2, but it turned out not to need its own unique ID,
18324                                                                          ; so the authors found they could just use a view value
18325                                                                          ; of 1 and save an instruction at the same time?
18326 5476 0206  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     5478 4B28     
18327 547A 06A0  28        bl   @jsr                       ;
     547C 8002     
18328                                                                          ; and set the current view type in QQ11 to 1
18329               
18330 547E 0206  20        li   rtmp,TT163                 ; JSR TT163         ; Print the column headers for the prices table
     5480 5E8E     
18331 5482 06A0  28        bl   @jsr                       ;
     5484 8002     
18332               
18333 5486 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     5488 8000     
18334 548A D800  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     548C 007E     
18335               
18336               * JSR FLKB               \ This instruction is commented out in the original
18337                                                                          ; source. It calls a routine to flush the keyboard
18338                                                                          ; buffer (FLKB) that isn't present in the cassette
18339                                                                          ; version but is in other versions
18340               
18341 548E 0200  20        li   ra,>00*256                 ; LDA #0            ; We're going to loop through all the available market
     5490 0000     
18342 5492 D800  30        movb ra,@QQ29                   ; STA QQ29          ; items, so we set up a counter in QQ29 to denote the
     5494 0F1B     
18343                                                                          ; current item and start it at 0
18344               
18345               TT220:
18346 5496 0206  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to print the item name, market price and
     5498 5D62     
18347 549A 06A0  28        bl   @jsr                       ;
     549C 8002     
18348                                                                          ; availability of the current item, and set QQ24 to the
18349                                                                          ; item's price / 4, QQ25 to the quantity available and
18350                                                                          ; QQ19+1 to byte #1 from the market prices table for
18351                                                                          ; this item
18352               
18353 549E D020  30        movb @QQ25,ra                   ; LDA QQ25          ; If there are some of the current item available, jump
     54A0 0F19     
18354 54A2 1611  14        jne  TT224                      ; BNE TT224         ; to TT224 below to see if we want to buy any
18355               
18356 54A4 0460  28        b    @TT222                     ; JMP TT222         ; Otherwise there are none available, so jump down to
     54A6 559C     
18357                                                                          ; TT222 to skip this item
18358               
18359               TQ4:
18360 54A8 0202  20        li   ry,>b0*256                 ; LDY #176          ; Set Y to the recursive token 16 ("QUANTITY")
     54AA B000     
18361               
18362               Tc:
18363 54AC 0206  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     54AE 5E64     
18364 54B0 06A0  28        bl   @jsr                       ;
     54B2 8002     
18365               
18366 54B4 D002  18        movb ry,ra                      ; TYA               ; Print the recursive token in Y followed by a question
18367 54B6 0206  20        li   rtmp,prq_                  ; JSR prq           ; mark
     54B8 5D52     
18368 54BA 06A0  28        bl   @jsr                       ;
     54BC 8002     
18369               
18370               TTX224:
18371 54BE 0206  20        li   rtmp,dn2_                  ; JSR dn2           ; Call dn2 to make a short, high beep and delay for 1
     54C0 64DC     
18372 54C2 06A0  28        bl   @jsr                       ;
     54C4 8002     
18373                                                                          ; second
18374               
18375               TT224:
18376 54C6 0206  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     54C8 4C2E     
18377 54CA 06A0  28        bl   @jsr                       ;
     54CC 8002     
18378                                                                          ; and move the text cursor to column 1 on row 21, i.e.
18379                                                                          ; the start of the top row of the three bottom rows
18380               
18381 54CE 0200  20        li   ra,>cc*256                 ; LDA #204          ; Print recursive token 44 ("QUANTITY OF ")
     54D0 CC00     
18382 54D2 0206  20        li   rtmp,TT27                  ; JSR TT27
     54D4 66DC     
18383 54D6 06A0  28        bl   @jsr                       ;
     54D8 8002     
18384               
18385 54DA D020  30        movb @QQ29,ra                   ; LDA QQ29          ; Print recursive token 48 + QQ29, which will be in the
     54DC 0F1B     
18386                      .clc                            ; CLC               ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     **** ****     > CLC
0001 54DE 0A13  18        sla  rzero,1
                   < elite.a99
18387                      .adi (>d0*256)                  ; ADC #208          ; prints the current item's name
     **** ****     > ADI
0001 54E0 1701  14        jnc  !
0002 54E2 B004  18        ab   rone,ra
0003               !:
0004 54E4 0220  22        ai   ra,(>D0*256)
     54E6 D000     
                   < elite.a99
18388 54E8 0206  20        li   rtmp,TT27                  ; JSR TT27
     54EA 66DC     
18389 54EC 06A0  28        bl   @jsr                       ;
     54EE 8002     
18390               
18391 54F0 0200  20        li   ra,('/')*256               ; LDA #'/'          ; Print "/"
     54F2 2F00     
18392 54F4 0206  20        li   rtmp,TT27                  ; JSR TT27
     54F6 66DC     
18393 54F8 06A0  28        bl   @jsr                       ;
     54FA 8002     
18394               
18395 54FC 0206  20        li   rtmp,TT152                 ; JSR TT152         ; Print the unit ("t", "kg" or "g") for the current item
     54FE 5E4C     
18396 5500 06A0  28        bl   @jsr                       ;
     5502 8002     
18397                                                                          ; (as the call to TT151 above set QQ19+1 with the
18398                                                                          ; appropriate value)
18399               
18400 5504 0200  20        li   ra,('?')*256               ; LDA #'?'          ; Print "?"
     5506 3F00     
18401 5508 0206  20        li   rtmp,TT27                  ; JSR TT27
     550A 66DC     
18402 550C 06A0  28        bl   @jsr                       ;
     550E 8002     
18403               
18404 5510 0206  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline
     5512 4EE6     
18405 5514 06A0  28        bl   @jsr                       ;
     5516 8002     
18406               
18407 5518 0201  20        li   rx,>00*256                 ; LDX #0            ; These instructions have no effect, as they are
     551A 0000     
18408 551C D801  30        movb rx,@R                      ; STX R             ; repeated at the start of gnum, which we call next.
     551E 0091     
18409 5520 0201  20        li   rx,>0c*256                 ; LDX #12           ; Perhaps they were left behind when code was moved from
     5522 0C00     
18410 5524 D801  30        movb rx,@T1                     ; STX T1            ; here into gnum, and weren't deleted?
     5526 0006     
18411               
18412               * .TT223                 \ This label is commented out in the original source,
18413                                                                          ; and is a duplicate of a label in gnum, so this could
18414                                                                          ; also be a remnant if the code in gnum was originally
18415                                                                          ; here, but got moved into the gnum subroutine
18416               
18417 5528 0206  20        li   rtmp,gnum_                 ; JSR gnum          ; Call gnum to get a number from the keyboard, which
     552A 55CE     
18418 552C 06A0  28        bl   @jsr                       ;
     552E 8002     
18419                                                                          ; will be the quantity of this item we want to purchase,
18420                                                                          ; returning the number entered in A and R
18421               
18422 5530 18BB  14        joc  TQ4                        ; BCS TQ4           ; If gnum set the C flag, the number entered is greater
18423                                                                          ; than the quantity available, so jump up to TQ4 to
18424                                                                          ; display a "Quantity?" error, beep, clear the number
18425                                                                          ; and try again
18426               
18427 5532 D800  30        movb ra,@P                      ; STA P             ; Otherwise we have a valid purchase quantity entered,
     5534 001B     
18428                                                                          ; so store the amount we want to purchase in P
18429               
18430 5536 0206  20        li   rtmp,tnpr_                 ; JSR tnpr          ; Call tnpr to work out whether there is room in the
     5538 4DF4     
18431 553A 06A0  28        bl   @jsr                       ;
     553C 8002     
18432                                                                          ; cargo hold for this item
18433               
18434 553E 0202  20        li   ry,>ce*256                 ; LDY #206          ; Set Y to recursive token 46 (" CARGO{sentence case}")
     5540 CE00     
18435                                                                          ; to pass to the Tc routine if we call it
18436               
18437 5542 18B4  14        joc  Tc                         ; BCS Tc            ; If the C flag is set, then there is no room in the
18438                                                                          ; cargo hold, jump up to Tc to print a "Cargo?" error,
18439                                                                          ; beep, clear the number and try again
18440               
18441 5544 D020  30        movb @QQ24,ra                   ; LDA QQ24          ; There is room in the cargo hold, so now to check
     5546 0F18     
18442 5548 D800  30        movb ra,@Q                      ; STA Q             ; whether we have enough cash, so fetch the item's
     554A 0090     
18443                                                                          ; price / 4, which was returned in QQ24 by the call
18444                                                                          ; to TT151 above and store it in Q
18445               
18446 554C 0206  20        li   rtmp,GCASH                 ; JSR GCASH         ; Call GCASH to calculate:
     554E 61F6     
18447 5550 06A0  28        bl   @jsr                       ;
     5552 8002     
18448                                                                          ;
18449                                                                          ; (Y X) = P * Q * 4
18450                                                                          ;
18451                                                                          ; which will be the total price of this transaction
18452                                                                          ; (as P contains the purchase quantity and Q contains
18453                                                                          ; the item's price / 4)
18454               
18455 5554 0206  20        li   rtmp,LCASH                 ; JSR LCASH         ; Subtract (Y X) cash from the cash pot in CASH
     5556 6166     
18456 5558 06A0  28        bl   @jsr                       ;
     555A 8002     
18457               
18458 555C 0202  20        li   ry,>c5*256                 ; LDY #197          ; If the C flag is clear, we didn't have enough cash,
     555E C500     
18459 5560 17A5  14        jnc  Tc                         ; BCC Tc            ; so set Y to the recursive token 37 ("CASH") and jump
18460                                                                          ; up to Tc to print a "Cash?" error, beep, clear the
18461                                                                          ; number and try again
18462               
18463 5562 D0A0  30        movb @QQ29,ry                   ; LDY QQ29          ; Fetch the current market item number from QQ29 into Y
     5564 0F1B     
18464               
18465 5566 D020  30        movb @R,ra                      ; LDA R             ; Set A to the number of items we just purchased (this
     5568 0091     
18466                                                                          ; was set by gnum above)
18467               
18468                      .pha                            ; PHA               ; Store the quantity just purchased on the stack
     **** ****     > PHA
0001 556A D680  30        movb ra,*rsp
0002 556C 060A  14        dec  rsp
                   < elite.a99
18469               
18470                      .clc                            ; CLC               ; Add the number purchased to the Y-th byte of QQ20,
     **** ****     > CLC
0001 556E 0A13  18        sla  rzero,1
                   < elite.a99
18471                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; which contains the number of items of this type in
     **** ****     > ADC
0001 5570 1701  14        jnc  !
0002 5572 B004  18        ab   rone,ra
0003               !:
0004 5574 B022  34        ab   @QQ20(RY),ra
     5576 0317     
                   < elite.a99
18472 5578 D880  38        movb ra,@QQ20(ry)               ; STA QQ20,Y        ; our hold (so this transfers the bought items into our
     557A 0317     
18473                                                                          ; cargo hold)
18474               
18475 557C D022  34        movb @AVL(ry),ra                ; LDA AVL,Y         ; Subtract the number of items from the Y-th byte of
     557E 0335     
18476                      .sec                            ; SEC               ; AVL, which contains the number of items of this type
     **** ****     > SEC
0001 5580 0A15  18        sla  rmone,1
                   < elite.a99
18477                      .sbc @R,ra                      ; SBC R             ; that are available on the market
     **** ****     > SBC
0001 5582 1801  14        joc  !
0002 5584 7004  18        sb   rone,ra
0003               !:
0004 5586 7020  30        sb   @R,ra
     5588 0091     
                   < elite.a99
18478 558A D880  38        movb ra,@AVL(ry)                ; STA AVL,Y
     558C 0335     
18479               
18480                      .pla                            ; PLA               ; Restore the quantity just purchased
     **** ****     > PLA
0001 558E 058A  14        inc  rsp
0002 5590 D01A  26        movb *rsp,ra
                   < elite.a99
18481               
18482 5592 1304  14        jeq  TT222                      ; BEQ TT222         ; If we didn't buy anything, jump to TT222 to skip the
18483                                                                          ; following instruction
18484               
18485 5594 0206  20        li   rtmp,dn_                   ; JSR dn            ; Call dn to print the amount of cash left in the cash
     5596 64C8     
18486 5598 06A0  28        bl   @jsr                       ;
     559A 8002     
18487                                                                          ; pot, then make a short, high beep to confirm the
18488                                                                          ; purchase, and delay for 1 second
18489               
18490               TT222:
18491 559C D020  30        movb @QQ29,ra                   ; LDA QQ29          ; Move the text cursor to row QQ29 + 5 (where QQ29 is
     559E 0F1B     
18492                      .clc                            ; CLC               ; the item number, starting from 0)
     **** ****     > CLC
0001 55A0 0A13  18        sla  rzero,1
                   < elite.a99
18493                      .adi (>05*256)                  ; ADC #5
     **** ****     > ADI
0001 55A2 1701  14        jnc  !
0002 55A4 B004  18        ab   rone,ra
0003               !:
0004 55A6 0220  22        ai   ra,(>05*256)
     55A8 0500     
                   < elite.a99
18494 55AA D800  30        movb ra,@YC                     ; STA YC
     55AC 002D     
18495               
18496 55AE 0200  20        li   ra,>00*256                 ; LDA #0            ; Move the text cursor to column 0
     55B0 0000     
18497 55B2 D800  30        movb ra,@XC                     ; STA XC
     55B4 002C     
18498               
18499 55B6 B004  18        ab   rone,ra                    ; INC QQ29          ; Increment QQ29 to point to the next item
18500               
18501 55B8 D020  30        movb @QQ29,ra                   ; LDA QQ29          ; If QQ29 >= 17 then jump to BAY2 as we have done the
     55BA 0F1B     
18502 55BC 0280  22        ci   ra,>11*256                 ; CMP #17           ; last item
     55BE 1100     
18503 55C0 1802  14        joc  BAY2                       ; BCS BAY2
18504               
18505 55C2 0460  28        b    @TT220                     ; JMP TT220         ; Otherwise loop back to TT220 to print the next market
     55C4 5496     
18506                                                                          ; item
18507               
18508               BAY2:
18509 55C6 0200  20        li   ra,(f9_)*256               ; LDA #f9           ; Jump into the main loop at FRCE, setting the key
     55C8 7700     
18510 55CA 0460  24        b    @FRCE                      ; JMP FRCE          ; "pressed" to red key f9 (so we show the Inventory
     55CC 82AC     
18511                                                                          ; screen)
18512               
18513               * ******************************************************************************
18514               *
18515               * Name: gnum
18516               * Type: Subroutine
18517               * Category: Market
18518               * Summary: Get a number from the keyboard
18519               *
18520               * ------------------------------------------------------------------------------
18521               *
18522               * Get a number from the keyboard, up to the maximum number in QQ25, for the
18523               * buying and selling of cargo and equipment.
18524               *
18525               * Pressing a key with an ASCII code less than ASCII "0" will return a 0 in A (so
18526               * that includes pressing Space or Return), while pressing a key with an ASCII
18527               * code greater than ASCII "9" will jump to the Inventory screen (so that
18528               * includes all letters and most punctuation).
18529               *
18530               * ------------------------------------------------------------------------------
18531               *
18532               * Arguments:
18533               *
18534               * QQ25                The maximum number allowed
18535               *
18536               * ------------------------------------------------------------------------------
18537               *
18538               * Returns:
18539               *
18540               * A                   The number entered
18541               *
18542               * R                   Also contains the number entered
18543               *
18544               * C flag              Set if the number is too large (> QQ25), clear otherwise
18545               *
18546               * ******************************************************************************
18547               
18548               gnum_:
18549 55CE 0201  20        li   rx,>00*256                 ; LDX #0            ; We will build the number entered in R, so initialise
     55D0 0000     
18550 55D2 D801  30        movb rx,@R                      ; STX R             ; it with 0
     55D4 0091     
18551               
18552 55D6 0201  20        li   rx,>0c*256                 ; LDX #12           ; We will check for up to 12 key presses, so set a
     55D8 0C00     
18553 55DA D801  30        movb rx,@T1                     ; STX T1            ; counter in T1
     55DC 0006     
18554               
18555               TT223:
18556 55DE 0206  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     55E0 8DF4     
18557 55E2 06A0  28        bl   @jsr                       ;
     55E4 8002     
18558                                                                          ; the key's ASCII code in A (and X)
18559               
18560 55E6 D800  30        movb ra,@Q                      ; STA Q             ; Store the key pressed in Q
     55E8 0090     
18561               
18562                      .sec                            ; SEC               ; Subtract ASCII "0" from the key pressed, to leave the
     **** ****     > SEC
0001 55EA 0A15  18        sla  rmone,1
                   < elite.a99
18563                      .sbi (('0')*256)                ; SBC #'0'          ; numeric value of the key in A (if it was a number key)
     **** ****     > SBI
0001 55EC 1801  14        joc  !
0002 55EE 7004  18        sb   rone,ra
0003               !:
0004 55F0 0220  22        ai   ra,-(('0')*256)
     55F2 D000     
                   < elite.a99
18564               
18565 55F4 172B  14        jnc  OUT                        ; BCC OUT           ; If A < 0, jump to OUT to load the current number and
18566                                                                          ; return from the subroutine, as the key pressed was
18567                                                                          ; RETURN (or some other ncharacter with a value less
18568                                                                          ; than ASCII "0")
18569               
18570 55F6 0280  22        ci   ra,>0a*256                 ; CMP #10           ; If A >= 10, jump to BAY2 to display the Inventory
     55F8 0A00     
18571 55FA 18E5  14        joc  BAY2                       ; BCS BAY2          ; screen, as the key pressed was a letter or other
18572                                                                          ; non-digit and is greater than ASCII "9"
18573               
18574 55FC D800  30        movb ra,@S                      ; STA S             ; Store the numeric value of the key pressed in S
     55FE 0092     
18575               
18576 5600 D020  30        movb @R,ra                      ; LDA R             ; Fetch the result so far into A
     5602 0091     
18577               
18578 5604 0280  22        ci   ra,>1a*256                 ; CMP #26           ; If A >= 26, where A is the number entered so far, then
     5606 1A00     
18579 5608 1821  14        joc  OUT                        ; BCS OUT           ; adding a further digit will make it bigger than 256,
18580                                                                          ; so jump to OUT to return from the subroutine with the
18581                                                                          ; result in R (i.e. ignore the last key press)
18582               
18583                      .asla                           ; ASL A             ; Set A = (A * 2) + (A * 8) = A * 10
     **** ****     > ASLA
0001 560A 0240  22        andi ra,>ff00
     560C FF00     
0002 560E 0A10  18        sla  ra,1
                   < elite.a99
18584 5610 D800  30        movb ra,@T                      ; STA T
     5612 00D1     
18585                      .asla                           ; ASL A
     **** ****     > ASLA
0001 5614 0240  22        andi ra,>ff00
     5616 FF00     
0002 5618 0A10  18        sla  ra,1
                   < elite.a99
18586                      .asla                           ; ASL A
     **** ****     > ASLA
0001 561A 0240  22        andi ra,>ff00
     561C FF00     
0002 561E 0A10  18        sla  ra,1
                   < elite.a99
18587                      .adc @T,ra                      ; ADC T
     **** ****     > ADC
0001 5620 1701  14        jnc  !
0002 5622 B004  18        ab   rone,ra
0003               !:
0004 5624 B020  30        ab   @T,ra
     5626 00D1     
                   < elite.a99
18588               
18589                      .adc @S,ra                      ; ADC S             ; Add the pressed digit to A and store in R, so R now
     **** ****     > ADC
0001 5628 1701  14        jnc  !
0002 562A B004  18        ab   rone,ra
0003               !:
0004 562C B020  30        ab   @S,ra
     562E 0092     
                   < elite.a99
18590 5630 D800  30        movb ra,@R                      ; STA R             ; contains its previous value with the new key press
     5632 0091     
18591                                                                          ; tacked onto the end
18592               
18593 5634 9020  30        cb   @QQ25,ra                   ; CMP QQ25          ; If the result in R = the maximum allowed in QQ25, jump
     5636 0F19     
18594 5638 1301  14        jeq  TT226                      ; BEQ TT226         ; to TT226 to print the key press and keep looping (the
18595                                                                          ; BEQ is needed because the BCS below would jump to OUT
18596                                                                          ; if R >= QQ25, which we don't want)
18597               
18598 563A 1808  14        joc  OUT                        ; BCS OUT           ; If the result in R > QQ25, jump to OUT to return from
18599                                                                          ; the subroutine with the result in R
18600               
18601               TT226:
18602 563C D020  30        movb @Q,ra                      ; LDA Q             ; Print the character in Q (i.e. the key that was
     563E 0090     
18603 5640 0206  20        li   rtmp,TT26                  ; JSR TT26          ; pressed, as we stored the ASCII value in Q earlier)
     5642 3172     
18604 5644 06A0  28        bl   @jsr                       ;
     5646 8002     
18605               
18606 5648 7004  18        sb   rone,ra                    ; DEC T1            ; Decrement the loop counter
18607               
18608 564A 16C9  14        jne  TT223                      ; BNE TT223         ; Loop back to TT223 until we have checked for 12 digits
18609               
18610               OUT:
18611 564C D020  30        movb @R,ra                      ; LDA R             ; Set A to the result we have been building in R
     564E 0091     
18612               
18613 5650 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     5652 800E     
18614               
18615               * ******************************************************************************
18616               *
18617               * Name: TT208
18618               * Type: Subroutine
18619               * Category: Market
18620               * Summary: Show the Sell Cargo screen (red key f2)
18621               *
18622               * ******************************************************************************
18623               
18624               TT208:
18625 5654 0200  20        li   ra,>04*256                 ; LDA #4            ; Clear the top part of the screen, draw a white border,
     5656 0400     
18626 5658 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 4 (Sell
     565A 4B2A     
18627 565C 06A0  28        bl   @jsr                       ;
     565E 8002     
18628                                                                          ; Cargo screen)
18629               
18630 5660 0200  20        li   ra,>04*256                 ; LDA #4            ; Move the text cursor to row 4, column 4
     5662 0400     
18631 5664 D800  30        movb ra,@YC                     ; STA YC
     5666 002D     
18632 5668 D800  30        movb ra,@XC                     ; STA XC
     566A 002C     
18633               
18634               * JSR FLKB               \ This instruction is commented out in the original
18635                                                                          ; source. It calls a routine to flush the keyboard
18636                                                                          ; buffer (FLKB) that isn't present in the cassette
18637                                                                          ; version but is in other versions
18638               
18639 566C 0200  20        li   ra,>cd*256                 ; LDA #205          ; Print recursive token 45 ("SELL")
     566E CD00     
18640 5670 0206  20        li   rtmp,TT27                  ; JSR TT27
     5672 66DC     
18641 5674 06A0  28        bl   @jsr                       ;
     5676 8002     
18642               
18643 5678 0200  20        li   ra,>ce*256                 ; LDA #206          ; Print recursive token 46 (" CARGO{sentence case}")
     567A CE00     
18644 567C 0206  20        li   rtmp,TT68                  ; JSR TT68          ; followed by a colon
     567E 66D0     
18645 5680 06A0  28        bl   @jsr                       ;
     5682 8002     
18646               
18647                                                                          ; Fall through into TT210 to show the Inventory screen
18648                                                                          ; with the option to sell
18649               
18650               * ******************************************************************************
18651               *
18652               * Name: TT210
18653               * Type: Subroutine
18654               * Category: Market
18655               * Summary: Show a list of current cargo in our hold, optionally to sell
18656               *
18657               * ------------------------------------------------------------------------------
18658               *
18659               * Show a list of current cargo in our hold, either with the ability to sell (the
18660               * Sell Cargo screen) or without (the Inventory screen), depending on the current
18661               * view.
18662               *
18663               * ------------------------------------------------------------------------------
18664               *
18665               * Arguments:
18666               *
18667               * QQ11                The current view:
18668               *
18669               * * 4 = Sell Cargo
18670               *
18671               * * 8 = Inventory
18672               *
18673               * ******************************************************************************
18674               
18675               TT210:
18676 5684 0202  20        li   ry,>00*256                 ; LDY #0            ; We're going to loop through all the available market
     5686 0000     
18677                                                                          ; items and check whether we have any in the hold (and,
18678                                                                          ; if we are in the Sell Cargo screen, whether we want
18679                                                                          ; to sell any items), so we set up a counter in Y to
18680                                                                          ; denote the current item and start it at 0
18681               
18682               TT211:
18683 5688 D802  30        movb ry,@QQ29                   ; STY QQ29          ; Store the current item number in QQ29
     568A 0F1B     
18684               
18685 568C D062  34        movb @QQ20(ry),rx               ; LDX QQ20,Y        ; Fetch into X the amount of the current item that we
     568E 0317     
18686 5690 135E  14        jeq  TT212                      ; BEQ TT212         ; have in our cargo hold, which is stored in QQ20+Y,
18687                                                                          ; and if there are no items of this type in the hold,
18688                                                                          ; jump down to TT212 to skip to the next item
18689               
18690 5692 D002  18        movb ry,ra                      ; TYA               ; Set Y = Y * 4, so this will act as an index into the
18691                      .asla                           ; ASL A             ; market prices table at QQ23 for this item (as there
     **** ****     > ASLA
0001 5694 0240  22        andi ra,>ff00
     5696 FF00     
0002 5698 0A10  18        sla  ra,1
                   < elite.a99
18692                      .asla                           ; ASL A             ; are four bytes per item in the table)
     **** ****     > ASLA
0001 569A 0240  22        andi ra,>ff00
     569C FF00     
0002 569E 0A10  18        sla  ra,1
                   < elite.a99
18693 56A0 D080  18        movb ra,ry                      ; TAY
18694               
18695 56A2 D022  34        movb @QQ23+1(ry),ra             ; LDA QQ23+1,Y      ; Fetch byte #1 from the market prices table for the
     56A4 8F23     
18696 56A6 D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; current item and store it in QQ19+1, for use by the
     56A8 0080     
18697                                                                          ; call to TT152 below
18698               
18699 56AA D001  18        movb rx,ra                      ; TXA               ; Store the amount of item in the hold (in X) on the
18700                      .pha                            ; PHA               ; stack
     **** ****     > PHA
0001 56AC D680  30        movb ra,*rsp
0002 56AE 060A  14        dec  rsp
                   < elite.a99
18701               
18702 56B0 0206  20        li   rtmp,TT69                  ; JSR TT69          ; Call TT69 to set Sentence Case and print a newline
     56B2 4EDE     
18703 56B4 06A0  28        bl   @jsr                       ;
     56B6 8002     
18704               
18705                      .clc                            ; CLC               ; Print recursive token 48 + QQ29, which will be in the
     **** ****     > CLC
0001 56B8 0A13  18        sla  rzero,1
                   < elite.a99
18706 56BA D020  30        movb @QQ29,ra                   ; LDA QQ29          ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     56BC 0F1B     
18707                      .adi (>d0*256)                  ; ADC #208          ; prints the current item's name
     **** ****     > ADI
0001 56BE 1701  14        jnc  !
0002 56C0 B004  18        ab   rone,ra
0003               !:
0004 56C2 0220  22        ai   ra,(>D0*256)
     56C4 D000     
                   < elite.a99
18708 56C6 0206  20        li   rtmp,TT27                  ; JSR TT27
     56C8 66DC     
18709 56CA 06A0  28        bl   @jsr                       ;
     56CC 8002     
18710               
18711 56CE 0200  20        li   ra,>0e*256                 ; LDA #14           ; Move the text cursor to column 14, for the item's
     56D0 0E00     
18712 56D2 D800  30        movb ra,@XC                     ; STA XC            ; quantity
     56D4 002C     
18713               
18714                      .pla                            ; PLA               ; Restore the amount of item in the hold into X
     **** ****     > PLA
0001 56D6 058A  14        inc  rsp
0002 56D8 D01A  26        movb *rsp,ra
                   < elite.a99
18715 56DA D040  18        movb ra,rx                      ; TAX
18716               
18717                      .clc                            ; CLC               ; Print the 8-bit number in X to 3 digits, without a
     **** ****     > CLC
0001 56DC 0A13  18        sla  rzero,1
                   < elite.a99
18718 56DE 0206  20        li   rtmp,pr2_                  ; JSR pr2           ; decimal point
     56E0 2FAC     
18719 56E2 06A0  28        bl   @jsr                       ;
     56E4 8002     
18720               
18721 56E6 0206  20        li   rtmp,TT152                 ; JSR TT152         ; Print the unit ("t", "kg" or "g") for the market item
     56E8 5E4C     
18722 56EA 06A0  28        bl   @jsr                       ;
     56EC 8002     
18723                                                                          ; whose byte #1 from the market prices table is in
18724                                                                          ; QQ19+1 (which we set up above)
18725               
18726 56EE D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view type in QQ11 is not 4 (Sell Cargo
     56F0 0096     
18727 56F2 0280  22        ci   ra,>04*256                 ; CMP #4            ; screen), jump to TT212 to skip the option to sell
     56F4 0400     
18728 56F6 162B  14        jne  TT212                      ; BNE TT212         ; items
18729               
18730 56F8 0200  20        li   ra,>cd*256                 ; LDA #205          ; Set A to recursive token 45 ("SELL")
     56FA CD00     
18731               
18732 56FC 0206  20        li   rtmp,TT214                 ; JSR TT214         ; Call TT214 to print "Sell(Y/N)?" and return the
     56FE 57C2     
18733 5700 06A0  28        bl   @jsr                       ;
     5702 8002     
18734                                                                          ; response in the C flag
18735               
18736 5704 1724  14        jnc  TT212                      ; BCC TT212         ; If the response was "no", jump to TT212 to move on to
18737                                                                          ; the next item
18738               
18739 5706 D020  30        movb @QQ29,ra                   ; LDA QQ29          ; We are selling this item, so fetch the item number
     5708 0F1B     
18740                                                                          ; from QQ29
18741               
18742 570A 0201  20        li   rx,>ff*256                 ; LDX #255          ; Set QQ17 = 255 to disable printing
     570C FF00     
18743 570E D801  30        movb rx,@QQ17                   ; STX QQ17
     5710 007E     
18744               
18745 5712 0206  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to set QQ24 to the item's price / 4 (the
     5714 5D62     
18746 5716 06A0  28        bl   @jsr                       ;
     5718 8002     
18747                                                                          ; routine doesn't print the item details, as we just
18748                                                                          ; disabled printing)
18749               
18750 571A D0A0  30        movb @QQ29,ry                   ; LDY QQ29          ; Set P to the amount of this item we have in our cargo
     571C 0F1B     
18751 571E D022  34        movb @QQ20(ry),ra               ; LDA QQ20,Y        ; hold (which is the amount to sell)
     5720 0317     
18752 5722 D800  30        movb ra,@P                      ; STA P
     5724 001B     
18753               
18754 5726 D020  30        movb @QQ24,ra                   ; LDA QQ24          ; Set Q to the item's price / 4
     5728 0F18     
18755 572A D800  30        movb ra,@Q                      ; STA Q
     572C 0090     
18756               
18757 572E 0206  20        li   rtmp,GCASH                 ; JSR GCASH         ; Call GCASH to calculate
     5730 61F6     
18758 5732 06A0  28        bl   @jsr                       ;
     5734 8002     
18759                                                                          ;
18760                                                                          ; (Y X) = P * Q * 4
18761                                                                          ;
18762                                                                          ; which will be the total price we make from this sale
18763                                                                          ; (as P contains the quantity we're selling and Q
18764                                                                          ; contains the item's price / 4)
18765               
18766 5736 0206  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH
     5738 61B2     
18767 573A 06A0  28        bl   @jsr                       ;
     573C 8002     
18768               
18769 573E 0200  20        li   ra,>00*256                 ; LDA #0            ; We've made the sale, so set the amount
     5740 0000     
18770 5742 D0A0  30        movb @QQ29,ry                   ; LDY QQ29
     5744 0F1B     
18771 5746 D880  38        movb ra,@QQ20(ry)               ; STA QQ20,Y
     5748 0317     
18772               
18773 574A D800  30        movb ra,@QQ17                   ; STA QQ17          ; Set QQ17 = 0, which enables printing again
     574C 007E     
18774               
18775               TT212:
18776 574E D0A0  30        movb @QQ29,ry                   ; LDY QQ29          ; Fetch the item number from QQ29 into Y, and increment
     5750 0F1B     
18777 5752 B084  18        ab   rone,ry                    ; INY               ; Y to point to the next item
18778               
18779 5754 0282  22        ci   ry,>11*256                 ; CPY #17           ; If Y >= 17 then skip the next instruction as we have
     5756 1100     
18780 5758 1802  14        joc  B54                        ; BCS B54           ; done the last item
18781               
18782 575A 0460  28        b    @TT211                     ; JMP TT211         ; Otherwise loop back to TT211 to print the next item
     575C 5688     
18783                                                                          ; in the hold
18784               
18785               B54:
18786 575E D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view type in QQ11 is not 4 (Sell Cargo
     5760 0096     
18787 5762 0280  22        ci   ra,>04*256                 ; CMP #4            ; screen), skip the next two instructions and just
     5764 0400     
18788 5766 1606  14        jne  B55                        ; BNE B55           ; return from the subroutine
18789               
18790 5768 0206  20        li   rtmp,dn2_                  ; JSR dn2           ; This is the Sell Cargo screen, so call dn2 to make a
     576A 64DC     
18791 576C 06A0  28        bl   @jsr                       ;
     576E 8002     
18792                                                                          ; short, high beep and delay for 1 second
18793               
18794 5770 0460  28        b    @BAY2                      ; JMP BAY2          ; And then jump to BAY2 to display the Inventory
     5772 55C6     
18795                                                                          ; screen, as we have finished selling cargo
18796               
18797               B55:
18798 5774 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     5776 800E     
18799               
18800               * ******************************************************************************
18801               *
18802               * Name: TT213
18803               * Type: Subroutine
18804               * Category: Market
18805               * Summary: Show the Inventory screen (red key f9)
18806               *
18807               * ******************************************************************************
18808               
18809               TT213:
18810 5778 0200  20        li   ra,>08*256                 ; LDA #8            ; Clear the top part of the screen, draw a white border,
     577A 0800     
18811 577C 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 8 (Inventory
     577E 4B2A     
18812 5780 06A0  28        bl   @jsr                       ;
     5782 8002     
18813                                                                          ; screen)
18814               
18815 5784 0200  20        li   ra,>0b*256                 ; LDA #11           ; Move the text cursor to column 11 to print the screen
     5786 0B00     
18816 5788 D800  30        movb ra,@XC                     ; STA XC            ; title
     578A 002C     
18817               
18818 578C 0200  20        li   ra,>a4*256                 ; LDA #164          ; Print recursive token 4 ("INVENTORY{crlf}") followed
     578E A400     
18819 5790 0206  20        li   rtmp,TT60                  ; JSR TT60          ; by a paragraph break and Sentence Case
     5792 4ED4     
18820 5794 06A0  28        bl   @jsr                       ;
     5796 8002     
18821               
18822 5798 0206  20        li   rtmp,NLIN4                 ; JSR NLIN4         ; Draw a horizontal line at pixel row 19 to box in the
     579A 25B8     
18823 579C 06A0  28        bl   @jsr                       ;
     579E 8002     
18824                                                                          ; title. The authors could have used a call to NLIN3
18825                                                                          ; instead and saved the above call to TT60, but you
18826                                                                          ; just can't optimise everything
18827               
18828 57A0 0206  20        li   rtmp,fwl_                  ; JSR fwl           ; Call fwl to print the fuel and cash levels on two
     57A2 6672     
18829 57A4 06A0  28        bl   @jsr                       ;
     57A6 8002     
18830                                                                          ; separate lines
18831               
18832 57A8 D020  30        movb @CRGO,ra                   ; LDA CRGO          ; If our ship's cargo capacity is < 26 (i.e. we do not
     57AA 0316     
18833 57AC 0280  22        ci   ra,>1a*256                 ; CMP #26           ; have a cargo bay extension), skip the following two
     57AE 1A00     
18834 57B0 1706  14        jnc  B56                        ; BCC B56           ; instructions
18835               
18836 57B2 0200  20        li   ra,>6b*256                 ; LDA #107          ; We do have a cargo bay extension, so print recursive
     57B4 6B00     
18837 57B6 0206  20        li   rtmp,TT27                  ; JSR TT27          ; token 107 ("LARGE CARGO{sentence case} BAY")
     57B8 66DC     
18838 57BA 06A0  28        bl   @jsr                       ;
     57BC 8002     
18839               
18840               B56:
18841 57BE 0460  28        b    @TT210                     ; JMP TT210         ; Jump to TT210 to print the contents of our cargo bay
     57C0 5684     
18842                                                                          ; and return from the subroutine using a tail call
18843               
18844               * ******************************************************************************
18845               *
18846               * Name: TT214
18847               * Type: Subroutine
18848               * Category: Keyboard
18849               * Summary: Ask a question with a "Y/N?" prompt and return the response
18850               *
18851               * ------------------------------------------------------------------------------
18852               *
18853               * Arguments:
18854               *
18855               * A                   The text token to print before the "Y/N?" prompt
18856               *
18857               * ------------------------------------------------------------------------------
18858               *
18859               * Returns:
18860               *
18861               * C flag              Set if the response was "yes", clear otherwise
18862               *
18863               * ******************************************************************************
18864               
18865               TT214:
18866                      .pha                            ; PHA               ; Print a space, using the stack to preserve the value
     **** ****     > PHA
0001 57C2 D680  30        movb ra,*rsp
0002 57C4 060A  14        dec  rsp
                   < elite.a99
18867 57C6 0206  20        li   rtmp,TT162                 ; JSR TT162         ; of A
     57C8 5E64     
18868 57CA 06A0  28        bl   @jsr                       ;
     57CC 8002     
18869                      .pla                            ; PLA
     **** ****     > PLA
0001 57CE 058A  14        inc  rsp
0002 57D0 D01A  26        movb *rsp,ra
                   < elite.a99
18870               
18871               TT221:
18872 57D2 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     57D4 66DC     
18873 57D6 06A0  28        bl   @jsr                       ;
     57D8 8002     
18874               
18875 57DA 0200  20        li   ra,>e1*256                 ; LDA #225          ; Print recursive token 65 ("(Y/N)?")
     57DC E100     
18876 57DE 0206  20        li   rtmp,TT27                  ; JSR TT27
     57E0 66DC     
18877 57E2 06A0  28        bl   @jsr                       ;
     57E4 8002     
18878               
18879 57E6 0206  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     57E8 8DF4     
18880 57EA 06A0  28        bl   @jsr                       ;
     57EC 8002     
18881                                                                          ; the key's ASCII code in A and X
18882               
18883 57EE 0260  22        ori  ra,>20*256                 ; ORA #%00100000    ; Set bit 5 in the value of the key pressed, which
     57F0 2000     
18884                                                                          ; converts it to lower case
18885               
18886 57F2 0280  22        ci   ra,('y')*256               ; CMP #'y'          ; If "y" was pressed, jump to TT218
     57F4 7900     
18887 57F6 1304  14        jeq  TT218                      ; BEQ TT218
18888               
18889 57F8 0200  20        li   ra,('n')*256               ; LDA #'n'          ; Otherwise jump to TT26 to print "n" and return from
     57FA 6E00     
18890 57FC 0460  28        b    @TT26                      ; JMP TT26          ; the subroutine using a tail call (so all other
     57FE 3172     
18891                                                                          ; responses apart from "y" indicate a no)
18892               
18893               TT218:
18894 5800 0206  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character in A, i.e. print "y"
     5802 3172     
18895 5804 06A0  28        bl   @jsr                       ;
     5806 8002     
18896               
18897                      .sec                            ; SEC               ; Set the C flag to indicate a "yes" response
     **** ****     > SEC
0001 5808 0A15  18        sla  rmone,1
                   < elite.a99
18898               
18899 580A 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     580C 800E     
18900               
18901               * ******************************************************************************
18902               *
18903               * Name: TT16
18904               * Type: Subroutine
18905               * Category: Charts
18906               * Summary: Move the crosshairs on a chart
18907               *
18908               * ------------------------------------------------------------------------------
18909               *
18910               * Move the chart crosshairs by the amount in X and Y.
18911               *
18912               * ------------------------------------------------------------------------------
18913               *
18914               * Arguments:
18915               *
18916               * X                   The amount to move the crosshairs in the x-axis
18917               *
18918               * Y                   The amount to move the crosshairs in the y-axis
18919               *
18920               * ******************************************************************************
18921               
18922               TT16:
18923 580E D001  18        movb rx,ra                      ; TXA               ; Push the change in X onto the stack (let's call this
18924                      .pha                            ; PHA               ; the x-delta)
     **** ****     > PHA
0001 5810 D680  30        movb ra,*rsp
0002 5812 060A  14        dec  rsp
                   < elite.a99
18925               
18926 5814 7084  18        sb   rone,ry                    ; DEY               ; Negate the change in Y and push it onto the stack
18927 5816 D002  18        movb ry,ra                      ; TYA               ; (let's call this the y-delta)
18928                      .eoi (>ff*256)                  ; EOR #&FF
     **** ****     > EOI
0001 5818 0206  20        li   rtmp,(>FF*256)
     581A FF00     
0002 581C 2806  18        xor  rtmp,ra
                   < elite.a99
18929                      .pha                            ; PHA
     **** ****     > PHA
0001 581E D680  30        movb ra,*rsp
0002 5820 060A  14        dec  rsp
                   < elite.a99
18930               
18931 5822 0206  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     5824 4DE2     
18932 5826 06A0  28        bl   @jsr                       ;
     5828 8002     
18933                                                                          ; screen gets drawn and we can move the crosshairs with
18934                                                                          ; no screen flicker
18935               
18936 582A 0206  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     582C 5872     
18937 582E 06A0  28        bl   @jsr                       ;
     5830 8002     
18938                                                                          ; which will erase the crosshairs currently there
18939               
18940                      .pla                            ; PLA               ; Store the y-delta in QQ19+3 and fetch the current
     **** ****     > PLA
0001 5832 058A  14        inc  rsp
0002 5834 D01A  26        movb *rsp,ra
                   < elite.a99
18941 5836 D800  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; y-coordinate of the crosshairs from QQ10 into A, ready
     5838 0082     
18942 583A D020  30        movb @QQ10,ra                   ; LDA QQ10          ; for the call to TT123
     583C 0F32     
18943               
18944 583E 0206  20        li   rtmp,TT123                 ; JSR TT123         ; Call TT123 to move the selected system's galactic
     5840 5898     
18945 5842 06A0  28        bl   @jsr                       ;
     5844 8002     
18946                                                                          ; y-coordinate by the y-delta, putting the new value in
18947                                                                          ; QQ19+4
18948               
18949 5846 D020  30        movb @QQ19+4,ra                 ; LDA QQ19+4        ; Store the updated y-coordinate in QQ10 (the current
     5848 0083     
18950 584A D800  30        movb ra,@QQ10                   ; STA QQ10          ; y-coordinate of the crosshairs)
     584C 0F32     
18951               
18952 584E D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; This instruction has no effect, as QQ19+1 is
     5850 0080     
18953                                                                          ; overwritten below, both in TT103 and TT105
18954               
18955                      .pla                            ; PLA               ; Store the x-delta in QQ19+3 and fetch the current
     **** ****     > PLA
0001 5852 058A  14        inc  rsp
0002 5854 D01A  26        movb *rsp,ra
                   < elite.a99
18956 5856 D800  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; x-coordinate of the crosshairs from QQ10 into A, ready
     5858 0082     
18957 585A D020  30        movb @QQ9,ra                    ; LDA QQ9           ; for the call to TT123
     585C 0F31     
18958               
18959 585E 0206  20        li   rtmp,TT123                 ; JSR TT123         ; Call TT123 to move the selected system's galactic
     5860 5898     
18960 5862 06A0  28        bl   @jsr                       ;
     5864 8002     
18961                                                                          ; x-coordinate by the x-delta, putting the new value in
18962                                                                          ; QQ19+4
18963               
18964 5866 D020  30        movb @QQ19+4,ra                 ; LDA QQ19+4        ; Store the updated x-coordinate in QQ9 (the current
     5868 0083     
18965 586A D800  30        movb ra,@QQ9                    ; STA QQ9           ; x-coordinate of the crosshairs)
     586C 0F31     
18966               
18967 586E D800  30        movb ra,@QQ19                   ; STA QQ19          ; This instruction has no effect, as QQ19 is overwritten
     5870 007F     
18968                                                                          ; below, both in TT103 and TT105
18969               
18970                                                                          ; Now we've updated the coordinates of the crosshairs,
18971                                                                          ; fall through into TT103 to redraw them at their new
18972                                                                          ; location
18973               
18974               * ******************************************************************************
18975               *
18976               * Name: TT103
18977               * Type: Subroutine
18978               * Category: Charts
18979               * Summary: Draw a small set of crosshairs on a chart
18980               *
18981               * ------------------------------------------------------------------------------
18982               *
18983               * Draw a small set of crosshairs on a galactic chart at the coordinates in
18984               * (QQ9, QQ10).
18985               *
18986               * ******************************************************************************
18987               
18988               TT103:
18989 5872 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; Fetch the current view type into A
     5874 0096     
18990               
18991 5876 1320  14        jeq  TT180                      ; BEQ TT180         ; If this is a space view, return from the subroutine
18992                                                                          ; (as TT180 contains an RTS), as there are no moveable
18993                                                                          ; crosshairs in space
18994               
18995 5878 1121  14        jlt  TT105                      ; BMI TT105         ; If this is the Short-range Chart screen, jump to TT105
18996               
18997 587A D020  30        movb @QQ9,ra                    ; LDA QQ9           ; Store the crosshairs x-coordinate in QQ19
     587C 0F31     
18998 587E D800  30        movb ra,@QQ19                   ; STA QQ19
     5880 007F     
18999               
19000 5882 D020  30        movb @QQ10,ra                   ; LDA QQ10          ; Halve the crosshairs y-coordinate and store it in QQ19
     5884 0F32     
19001 5886 0910  18        srl  ra,1                       ; LSR A             ; (we halve it because the Long-range Chart is half as
19002 5888 D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; high as it is wide)
     588A 0080     
19003               
19004 588C 0200  20        li   ra,>04*256                 ; LDA #4            ; Set QQ19+2 to 4 denote crosshairs of size 4
     588E 0400     
19005 5890 D800  30        movb ra,@QQ19+2                 ; STA QQ19+2
     5892 0081     
19006               
19007 5894 0460  28        b    @TT15                      ; JMP TT15          ; Jump to TT15 to draw crosshairs of size 4 at the
     5896 5316     
19008                                                                          ; crosshairs coordinates, returning from the subroutine
19009                                                                          ; using a tail call
19010               
19011               * ******************************************************************************
19012               *
19013               * Name: TT123
19014               * Type: Subroutine
19015               * Category: Charts
19016               * Summary: Move galactic coordinates by a signed delta
19017               *
19018               * ------------------------------------------------------------------------------
19019               *
19020               * Move an 8-bit galactic coordinate by a certain distance in either direction
19021               * (i.e. a signed 8-bit delta), but only if it doesn't cause the coordinate to
19022               * overflow. The coordinate is in a single axis, so it's either an x-coordinate
19023               * or a y-coordinate.
19024               *
19025               * ------------------------------------------------------------------------------
19026               *
19027               * Arguments:
19028               *
19029               * A                   The galactic coordinate to update
19030               *
19031               * QQ19+3              The delta (can be positive or negative)
19032               *
19033               * ------------------------------------------------------------------------------
19034               *
19035               * Returns:
19036               *
19037               * QQ19+4              The updated coordinate after moving by the delta (this
19038               * will be the same as A if moving by the delta overflows)
19039               *
19040               * ------------------------------------------------------------------------------
19041               *
19042               * Other entry points:
19043               *
19044               * TT180               Contains an RTS
19045               *
19046               * ******************************************************************************
19047               
19048               TT123:
19049 5898 D800  30        movb ra,@QQ19+4                 ; STA QQ19+4        ; Store the original coordinate in temporary storage at
     589A 0083     
19050                                                                          ; QQ19+4
19051               
19052                      .clc                            ; CLC               ; Set A = A + QQ19+3, so A now contains the original
     **** ****     > CLC
0001 589C 0A13  18        sla  rzero,1
                   < elite.a99
19053                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ; coordinate, moved by the delta
     **** ****     > ADC
0001 589E 1701  14        jnc  !
0002 58A0 B004  18        ab   rone,ra
0003               !:
0004 58A2 B020  30        ab   @QQ19+3,ra
     58A4 0082     
                   < elite.a99
19054               
19055 58A6 D060  30        movb @QQ19+3,rx                 ; LDX QQ19+3        ; If the delta is negative, jump to TT124
     58A8 0082     
19056 58AA 1103  14        jlt  TT124                      ; BMI TT124
19057               
19058 58AC 1703  14        jnc  TT125                      ; BCC TT125         ; If the C flag is clear, then the above addition didn't
19059                                                                          ; overflow, so jump to TT125 to return the updated value
19060               
19061 58AE 0460  24        b    @rts                       ; RTS               ; Otherwise the C flag is set and the above addition
     58B0 800E     
19062                                                                          ; overflowed, so do not update the return value
19063               
19064               TT124:
19065 58B2 1702  14        jnc  TT180                      ; BCC TT180         ; If the C flag is clear, then because the delta is
19066                                                                          ; negative, this indicates the addition (which is
19067                                                                          ; effectively a subtraction) underflowed, so jump to
19068                                                                          ; TT180 to return from the subroutine without updating
19069                                                                          ; the return value
19070               
19071               TT125:
19072 58B4 D800  30        movb ra,@QQ19+4                 ; STA QQ19+4        ; Store the updated coordinate in QQ19+4
     58B6 0083     
19073               
19074               TT180:
19075 58B8 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     58BA 800E     
19076               
19077               * ******************************************************************************
19078               *
19079               * Name: TT105
19080               * Type: Subroutine
19081               * Category: Charts
19082               * Summary: Draw crosshairs on the Short-range Chart, with clipping
19083               *
19084               * ------------------------------------------------------------------------------
19085               *
19086               * Check whether the crosshairs are close enough to the current system to appear
19087               * on the Short-range Chart, and if so, draw them.
19088               *
19089               * ******************************************************************************
19090               
19091               TT105:
19092 58BC D020  30        movb @QQ9,ra                    ; LDA QQ9           ; Set A = QQ9 - QQ0, the horizontal distance between the
     58BE 0F31     
19093                      .sec                            ; SEC               ; crosshairs (QQ9) and the current system (QQ0)
     **** ****     > SEC
0001 58C0 0A15  18        sla  rmone,1
                   < elite.a99
19094                      .sbc @QQ0,ra                    ; SBC QQ0
     **** ****     > SBC
0001 58C2 1801  14        joc  !
0002 58C4 7004  18        sb   rone,ra
0003               !:
0004 58C6 7020  30        sb   @QQ0,ra
     58C8 0301     
                   < elite.a99
19095               
19096 58CA 0280  22        ci   ra,>26*256                 ; CMP #38           ; If the horizontal distance in A < 38, then the
     58CC 2600     
19097 58CE 1703  14        jnc  TT179                      ; BCC TT179         ; crosshairs are close enough to the current system to
19098                                                                          ; appear in the Short-range Chart, so jump to TT179 to
19099                                                                          ; check the vertical distance
19100               
19101 58D0 0280  22        ci   ra,>e6*256                 ; CMP #230          ; If the horizontal distance in A < -26, then the
     58D2 E600     
19102 58D4 17F1  14        jnc  TT180                      ; BCC TT180         ; crosshairs are too far from the current system to
19103                                                                          ; appear in the Short-range Chart, so jump to TT180 to
19104                                                                          ; return from the subroutine (as TT180 contains an RTS)
19105               
19106               TT179:
19107                      .asla                           ; ASL A             ; Set QQ19 = 104 + A * 4
     **** ****     > ASLA
0001 58D6 0240  22        andi ra,>ff00
     58D8 FF00     
0002 58DA 0A10  18        sla  ra,1
                   < elite.a99
19108                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 58DC 0240  22        andi ra,>ff00
     58DE FF00     
0002 58E0 0A10  18        sla  ra,1
                   < elite.a99
19109                      .clc                            ; CLC               ; 104 is the x-coordinate of the centre of the chart,
     **** ****     > CLC
0001 58E2 0A13  18        sla  rzero,1
                   < elite.a99
19110                      .adi (>68*256)                  ; ADC #104          ; so this sets QQ19 to the screen pixel x-coordinate
     **** ****     > ADI
0001 58E4 1701  14        jnc  !
0002 58E6 B004  18        ab   rone,ra
0003               !:
0004 58E8 0220  22        ai   ra,(>68*256)
     58EA 6800     
                   < elite.a99
19111 58EC D800  30        movb ra,@QQ19                   ; STA QQ19          ; of the crosshairs
     58EE 007F     
19112               
19113 58F0 D020  30        movb @QQ10,ra                   ; LDA QQ10          ; Set A = QQ10 - QQ1, the vertical distance between the
     58F2 0F32     
19114                      .sec                            ; SEC               ; crosshairs (QQ10) and the current system (QQ1)
     **** ****     > SEC
0001 58F4 0A15  18        sla  rmone,1
                   < elite.a99
19115                      .sbc @QQ1,ra                    ; SBC QQ1
     **** ****     > SBC
0001 58F6 1801  14        joc  !
0002 58F8 7004  18        sb   rone,ra
0003               !:
0004 58FA 7020  30        sb   @QQ1,ra
     58FC 0302     
                   < elite.a99
19116               
19117 58FE 0280  22        ci   ra,>26*256                 ; CMP #38           ; If the vertical distance in A is < 38, then the
     5900 2600     
19118 5902 1703  14        jnc  B57                        ; BCC B57           ; crosshairs are close enough to the current system to
19119                                                                          ; appear in the Short-range Chart, so skip the next two
19120                                                                          ; instructions
19121               
19122 5904 0280  22        ci   ra,>dc*256                 ; CMP #220          ; If the horizontal distance in A is < -36, then the
     5906 DC00     
19123 5908 17D7  14        jnc  TT180                      ; BCC TT180         ; crosshairs are too far from the current system to
19124                                                                          ; appear in the Short-range Chart, so jump to TT180 to
19125                                                                          ; return from the subroutine (as TT180 contains an RTS)
19126               
19127               B57:
19128                      .asla                           ; ASL A             ; Set QQ19+1 = 90 + A * 2
     **** ****     > ASLA
0001 590A 0240  22        andi ra,>ff00
     590C FF00     
0002 590E 0A10  18        sla  ra,1
                   < elite.a99
19129                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 5910 0A13  18        sla  rzero,1
                   < elite.a99
19130                      .adi (>5a*256)                  ; ADC #90           ; 90 is the y-coordinate of the centre of the chart,
     **** ****     > ADI
0001 5912 1701  14        jnc  !
0002 5914 B004  18        ab   rone,ra
0003               !:
0004 5916 0220  22        ai   ra,(>5A*256)
     5918 5A00     
                   < elite.a99
19131 591A D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; so this sets QQ19+1 to the screen pixel x-coordinate
     591C 0080     
19132                                                                          ; of the crosshairs
19133               
19134 591E 0200  20        li   ra,>08*256                 ; LDA #8            ; Set QQ19+2 to 8 denote crosshairs of size 8
     5920 0800     
19135 5922 D800  30        movb ra,@QQ19+2                 ; STA QQ19+2
     5924 0081     
19136               
19137 5926 0460  28        b    @TT15                      ; JMP TT15          ; Jump to TT15 to draw crosshairs of size 8 at the
     5928 5316     
19138                                                                          ; crosshairs coordinates, returning from the subroutine
19139                                                                          ; using a tail call
19140               
19141               * ******************************************************************************
19142               *
19143               * Name: TT23
19144               * Type: Subroutine
19145               * Category: Charts
19146               * Summary: Show the Short-range Chart (red key f5)
19147               *
19148               * ******************************************************************************
19149               
19150               TT23:
19151 592A 0200  20        li   ra,>80*256                 ; LDA #128          ; Clear the top part of the screen, draw a white border,
     592C 8000     
19152 592E 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 128 (Short-
     5930 4B2A     
19153 5932 06A0  28        bl   @jsr                       ;
     5934 8002     
19154                                                                          ; range Chart)
19155               
19156 5936 0200  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     5938 0700     
19157 593A D800  30        movb ra,@XC                     ; STA XC
     593C 002C     
19158               
19159 593E 0200  20        li   ra,>be*256                 ; LDA #190          ; Print recursive token 30 ("SHORT RANGE CHART") and
     5940 BE00     
19160 5942 0206  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; draw a horizontal line at pixel row 19 to box in the
     5944 25B0     
19161 5946 06A0  28        bl   @jsr                       ;
     5948 8002     
19162                                                                          ; title
19163               
19164 594A 0206  20        li   rtmp,TT14                  ; JSR TT14          ; Call TT14 to draw a circle with crosshairs at the
     594C 53FA     
19165 594E 06A0  28        bl   @jsr                       ;
     5950 8002     
19166                                                                          ; current system's galactic coordinates
19167               
19168 5952 0206  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     5954 5872     
19169 5956 06A0  28        bl   @jsr                       ;
     5958 8002     
19170                                                                          ; i.e. at the selected system
19171               
19172 595A 0206  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     595C 5AA4     
19173 595E 06A0  28        bl   @jsr                       ;
     5960 8002     
19174                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
19175               
19176 5962 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0, which we'll use below to zero out the INWK
     5964 0000     
19177                                                                          ; workspace
19178               
19179 5966 D800  30        movb ra,@XX20                   ; STA XX20          ; We're about to start working our way through each of
     5968 00A8     
19180                                                                          ; the galaxy's systems, so set up a counter in XX20 for
19181                                                                          ; each system, starting at 0 and looping through to 255
19182               
19183 596A 0201  20        li   rx,>18*256                 ; LDX #24           ; First, though, we need to zero out the 25 bytes at
     596C 1800     
19184                                                                          ; INWK so we can use them to work out which systems have
19185                                                                          ; room for a label, so set a counter in X for 25 bytes
19186               
19187               EE3:
19188 596E D840  38        movb ra,@INWK(rx)               ; STA INWK,X        ; Set the X-th byte of INWK to zero
     5970 0053     
19189               
19190 5972 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19191               
19192 5974 15FC  14        jgt  EE3                        ; BPL EE3           ; Loop back to EE3 for the next byte until we've zeroed
19193                                                                          ; all 25 bytes
19194               
19195                                                                          ; We now loop through every single system in the galaxy
19196                                                                          ; and check the distance from the current system whose
19197                                                                          ; coordinates are in (QQ0, QQ1). We get the galactic
19198                                                                          ; coordinates of each system from the system's seeds,
19199                                                                          ; like this:
19200                                                                          ;
19201                                                                          ; x = s1_hi (which is stored in QQ15+3)
19202                                                                          ; y = s0_hi (which is stored in QQ15+1)
19203                                                                          ;
19204                                                                          ; so the following loops through each system in the
19205                                                                          ; galaxy in turn and calculates the distance between
19206                                                                          ; (QQ0, QQ1) and (s1_hi, s0_hi) to find the closest one
19207               
19208               TT182:
19209 5976 D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ0, the horizontal distance between
     5978 007B     
19210                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ0, QQ1)
     **** ****     > SEC
0001 597A 0A15  18        sla  rmone,1
                   < elite.a99
19211                      .sbc @QQ0,ra                    ; SBC QQ0
     **** ****     > SBC
0001 597C 1801  14        joc  !
0002 597E 7004  18        sb   rone,ra
0003               !:
0004 5980 7020  30        sb   @QQ0,ra
     5982 0301     
                   < elite.a99
19212               
19213 5984 1807  14        joc  TT184                      ; BCS TT184         ; If a borrow didn't occur, i.e. s1_hi >= QQ0, then the
19214                                                                          ; result is positive, so jump to TT184 and skip the
19215                                                                          ; following two instructions
19216               
19217                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5986 0206  20        li   rtmp,(>FF*256)
     5988 FF00     
0002 598A 2806  18        xor  rtmp,ra
                   < elite.a99
19218                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s1_hi - QQ0|)
     **** ****     > ADI
0001 598C 1701  14        jnc  !
0002 598E B004  18        ab   rone,ra
0003               !:
0004 5990 0220  22        ai   ra,(>01*256)
     5992 0100     
                   < elite.a99
19219               
19220               TT184:
19221 5994 0280  22        ci   ra,>14*256                 ; CMP #20           ; If the horizontal distance in A is >= 20, then this
     5996 1400     
19222 5998 187D  14        joc  TT187                      ; BCS TT187         ; system is too far away from the current system to
19223                                                                          ; appear in the Short-range Chart, so jump to TT187 to
19224                                                                          ; move on to the next system
19225               
19226 599A D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ1, the vertical distance between
     599C 0079     
19227                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ0, QQ1)
     **** ****     > SEC
0001 599E 0A15  18        sla  rmone,1
                   < elite.a99
19228                      .sbc @QQ1,ra                    ; SBC QQ1
     **** ****     > SBC
0001 59A0 1801  14        joc  !
0002 59A2 7004  18        sb   rone,ra
0003               !:
0004 59A4 7020  30        sb   @QQ1,ra
     59A6 0302     
                   < elite.a99
19229               
19230 59A8 1807  14        joc  TT186                      ; BCS TT186         ; If a borrow didn't occur, i.e. s0_hi >= QQ1, then the
19231                                                                          ; result is positive, so jump to TT186 and skip the
19232                                                                          ; following two instructions
19233               
19234                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 59AA 0206  20        li   rtmp,(>FF*256)
     59AC FF00     
0002 59AE 2806  18        xor  rtmp,ra
                   < elite.a99
19235                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s0_hi - QQ1|)
     **** ****     > ADI
0001 59B0 1701  14        jnc  !
0002 59B2 B004  18        ab   rone,ra
0003               !:
0004 59B4 0220  22        ai   ra,(>01*256)
     59B6 0100     
                   < elite.a99
19236               
19237               TT186:
19238 59B8 0280  22        ci   ra,>26*256                 ; CMP #38           ; If the vertical distance in A is >= 38, then this
     59BA 2600     
19239 59BC 186B  14        joc  TT187                      ; BCS TT187         ; system is too far away from the current system to
19240                                                                          ; appear in the Short-range Chart, so jump to TT187 to
19241                                                                          ; move on to the next system
19242               
19243                                                                          ; This system should be shown on the Short-range Chart,
19244                                                                          ; so now we need to work out where the label should go,
19245                                                                          ; and set up the various variables we need to draw the
19246                                                                          ; system's filled circle on the chart
19247               
19248 59BE D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ0, the horizontal distance between
     59C0 007B     
19249                      .sec                            ; SEC               ; this system and the current system, where |A| < 20.
     **** ****     > SEC
0001 59C2 0A15  18        sla  rmone,1
                   < elite.a99
19250                      .sbc @QQ0,ra                    ; SBC QQ0           ; Let's call this the x-delta, as it's the horizontal
     **** ****     > SBC
0001 59C4 1801  14        joc  !
0002 59C6 7004  18        sb   rone,ra
0003               !:
0004 59C8 7020  30        sb   @QQ0,ra
     59CA 0301     
                   < elite.a99
19251                                                                          ; difference between the current system at the centre of
19252                                                                          ; the chart, and this system (and this time we keep the
19253                                                                          ; sign of A, so it can be negative if it's to the left
19254                                                                          ; of the chart's centre, or positive if it's to the
19255                                                                          ; right)
19256               
19257                      .asla                           ; ASL A             ; Set XX12 = 104 + x-delta * 4
     **** ****     > ASLA
0001 59CC 0240  22        andi ra,>ff00
     59CE FF00     
0002 59D0 0A10  18        sla  ra,1
                   < elite.a99
19258                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 59D2 0240  22        andi ra,>ff00
     59D4 FF00     
0002 59D6 0A10  18        sla  ra,1
                   < elite.a99
19259                      .adi (>68*256)                  ; ADC #104          ; 104 is the x-coordinate of the centre of the chart,
     **** ****     > ADI
0001 59D8 1701  14        jnc  !
0002 59DA B004  18        ab   rone,ra
0003               !:
0004 59DC 0220  22        ai   ra,(>68*256)
     59DE 6800     
                   < elite.a99
19260 59E0 D800  30        movb ra,@XX12                   ; STA XX12          ; so this sets XX12 to the centre 104 +/- 76, the pixel
     59E2 0037     
19261                                                                          ; x-coordinate of this system
19262               
19263 59E4 0910  18        srl  ra,1                       ; LSR A             ; Move the text cursor to column x-delta / 2 + 1
19264 59E6 0910  18        srl  ra,1                       ; LSR A             ; which will be in the range 1-10
19265 59E8 0910  18        srl  ra,1                       ; LSR A
19266 59EA D800  30        movb ra,@XC                     ; STA XC
     59EC 002C     
19267 59EE B004  18        ab   rone,ra                    ; INC XC
19268               
19269 59F0 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ1, the vertical distance between
     59F2 0079     
19270                      .sec                            ; SEC               ; this system and the current system, where |A| < 38.
     **** ****     > SEC
0001 59F4 0A15  18        sla  rmone,1
                   < elite.a99
19271                      .sbc @QQ1,ra                    ; SBC QQ1           ; Let's call this the y-delta, as it's the vertical
     **** ****     > SBC
0001 59F6 1801  14        joc  !
0002 59F8 7004  18        sb   rone,ra
0003               !:
0004 59FA 7020  30        sb   @QQ1,ra
     59FC 0302     
                   < elite.a99
19272                                                                          ; difference between the current system at the centre of
19273                                                                          ; the chart, and this system (and this time we keep the
19274                                                                          ; sign of A, so it can be negative if it's above the
19275                                                                          ; chart's centre, or positive if it's below)
19276               
19277                      .asla                           ; ASL A             ; Set K4 = 90 + y-delta * 2
     **** ****     > ASLA
0001 59FE 0240  22        andi ra,>ff00
     5A00 FF00     
0002 5A02 0A10  18        sla  ra,1
                   < elite.a99
19278                      .adi (>5a*256)                  ; ADC #90           ;
     **** ****     > ADI
0001 5A04 1701  14        jnc  !
0002 5A06 B004  18        ab   rone,ra
0003               !:
0004 5A08 0220  22        ai   ra,(>5A*256)
     5A0A 5A00     
                   < elite.a99
19279 5A0C D800  30        movb ra,@K4                     ; STA K4            ; 90 is the y-coordinate of the centre of the chart,
     5A0E 00E0     
19280                                                                          ; so this sets K4 to the centre 90 +/- 74, the pixel
19281                                                                          ; y-coordinate of this system
19282               
19283 5A10 0910  18        srl  ra,1                       ; LSR A             ; Set Y = K4 / 8, so Y contains the number of the text
19284 5A12 0910  18        srl  ra,1                       ; LSR A             ; row that contains this system
19285 5A14 0910  18        srl  ra,1                       ; LSR A
19286 5A16 D080  18        movb ra,ry                      ; TAY
19287               
19288                                                                          ; Now to see if there is room for this system's label.
19289                                                                          ; Ideally we would print the system name on the same
19290                                                                          ; text row as the system, but we only want to print one
19291                                                                          ; label per row, to prevent overlap, so now we check
19292                                                                          ; this system's row, and if that's already occupied,
19293                                                                          ; the row above, and if that's already occupied, the
19294                                                                          ; row below... and if that's already occupied, we give
19295                                                                          ; up and don't print a label for this system
19296               
19297 5A18 D062  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; If the value in INWK+Y is 0 (i.e. the text row
     5A1A 0053     
19298 5A1C 1309  14        jeq  EE4                        ; BEQ EE4           ; containing this system does not already have another
19299                                                                          ; system's label on it), jump to EE4 to store this
19300                                                                          ; system's label on this row
19301               
19302 5A1E B084  18        ab   rone,ry                    ; INY               ; If the value in INWK+Y+1 is 0 (i.e. the text row below
19303 5A20 D062  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; the one containing this system does not already have
     5A22 0053     
19304 5A24 1305  14        jeq  EE4                        ; BEQ EE4           ; another system's label on it), jump to EE4 to store
19305                                                                          ; this system's label on this row
19306               
19307 5A26 7084  18        sb   rone,ry                    ; DEY               ; If the value in INWK+Y-1 is 0 (i.e. the text row above
19308 5A28 7084  18        sb   rone,ry                    ; DEY               ; the one containing this system does not already have
19309 5A2A D062  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; another system's label on it), fall through into to
     5A2C 0053     
19310 5A2E 1610  14        jne  ee1_                       ; BNE ee1           ; EE4 to store this system's label on this row,
19311                                                                          ; otherwise jump to ee1 to skip printing a label for
19312                                                                          ; this system (as there simply isn't room)
19313               
19314               EE4:
19315 5A30 D802  30        movb ry,@YC                     ; STY YC            ; Now to print the label, so move the text cursor to row
     5A32 002D     
19316                                                                          ; Y (which contains the row where we can print this
19317                                                                          ; system's label)
19318               
19319 5A34 0282  22        ci   ry,>03*256                 ; CPY #3            ; If Y < 3, then the system would clash with the chart
     5A36 0300     
19320 5A38 172D  14        jnc  TT187                      ; BCC TT187         ; title, so jump to TT187 to skip showing the system
19321               
19322 5A3A 7044  18        sb   rone,rx                    ; DEX               ; We entered the EE4 routine with X = 0, so this stores
19323 5A3C D881  38        movb rx,@INWK(ry)               ; STX INWK,Y        ; &FF in INWK+Y, to denote that this row is now occupied
     5A3E 0053     
19324                                                                          ; so we don't try to print another system's label on
19325                                                                          ; this row
19326               
19327 5A40 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     5A42 8000     
19328 5A44 D800  30        movb ra,@QQ17                   ; STA QQ17
     5A46 007E     
19329               
19330 5A48 0206  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print out the system name for the seeds
     5A4A 65B8     
19331 5A4C 06A0  28        bl   @jsr                       ;
     5A4E 8002     
19332                                                                          ; in QQ15 (which now contains the seeds for the current
19333                                                                          ; system)
19334               
19335               ee1_:
19336 5A50 0200  20        li   ra,>00*256                 ; LDA #0            ; Now to plot the star, so set the high bytes of K, K3
     5A52 0000     
19337 5A54 D800  30        movb ra,@K3+1                   ; STA K3+1          ; and K4 to 0
     5A56 00D3     
19338 5A58 D800  30        movb ra,@K4+1                   ; STA K4+1
     5A5A 00E1     
19339 5A5C D800  30        movb ra,@K+1                    ; STA K+1
     5A5E 003E     
19340               
19341 5A60 D020  30        movb @XX12,ra                   ; LDA XX12          ; Set the low byte of K3 to XX12, the pixel x-coordinate
     5A62 0037     
19342 5A64 D800  30        movb ra,@K3                     ; STA K3            ; of this system
     5A66 00D2     
19343               
19344 5A68 D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Fetch s2_hi for this system from QQ15+5, extract bit 0
     5A6A 007D     
19345 5A6C 0240  22        andi ra,>01*256                 ; AND #1            ; and add 2 to get the size of the star, which we store
     5A6E 0100     
19346                      .adi (>02*256)                  ; ADC #2            ; in K. This will be either 2, 3 or 4, depending on the
     **** ****     > ADI
0001 5A70 1701  14        jnc  !
0002 5A72 B004  18        ab   rone,ra
0003               !:
0004 5A74 0220  22        ai   ra,(>02*256)
     5A76 0200     
                   < elite.a99
19347 5A78 D800  30        movb ra,@K                      ; STA K             ; value of bit 0, and whether the C flag is set (which
     5A7A 003D     
19348                                                                          ; will vary depending on what happens in the above call
19349                                                                          ; to cpl). Incidentally, the planet's average radius
19350                                                                          ; also uses s2_hi, bits 0-3 to be precise, but that
19351                                                                          ; doesn't mean the two sizes affect each other
19352               
19353                                                                          ; We now have the following:
19354                                                                          ;
19355                                                                          ; K(1 0)  = radius of star (2, 3 or 4)
19356                                                                          ;
19357                                                                          ; K3(1 0) = pixel x-coordinate of system
19358                                                                          ;
19359                                                                          ; K4(1 0) = pixel y-coordinate of system
19360                                                                          ;
19361                                                                          ; which we can now pass to the SUN routine to draw a
19362                                                                          ; small "sun" on the Short-range Chart for this system
19363               
19364 5A7C 0206  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Call FLFLLS to reset the LSO block
     5A7E 6C9A     
19365 5A80 06A0  28        bl   @jsr                       ;
     5A82 8002     
19366               
19367 5A84 0206  20        li   rtmp,SUN                   ; JSR SUN           ; Call SUN to plot a sun with radius K at pixel
     5A86 75B8     
19368 5A88 06A0  28        bl   @jsr                       ;
     5A8A 8002     
19369                                                                          ; coordinate (K3, K4)
19370               
19371 5A8C 0206  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Call FLFLLS to reset the LSO block
     5A8E 6C9A     
19372 5A90 06A0  28        bl   @jsr                       ;
     5A92 8002     
19373               
19374               TT187:
19375 5A94 0206  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     5A96 4E32     
19376 5A98 06A0  28        bl   @jsr                       ;
     5A9A 8002     
19377                                                                          ; to twist the three 16-bit seeds in QQ15
19378               
19379 5A9C B004  18        ab   rone,ra                    ; INC XX20          ; Increment the counter
19380               
19381 5A9E 130B  14        jeq  TT111-1                    ; BEQ TT111-1       ; If X = 0 then we have done all 256 systems, so return
19382                                                                          ; from the subroutine (as TT111-1 contains an RTS)
19383               
19384 5AA0 0460  28        b    @TT182                     ; JMP TT182         ; Otherwise jump back up to TT182 to process the next
     5AA2 5976     
19385                                                                          ; system
19386               
19387               * ******************************************************************************
19388               *
19389               * Name: TT81
19390               * Type: Subroutine
19391               * Category: Universe
19392               * Summary: Set the selected system's seeds to those of system 0
19393               *
19394               * ------------------------------------------------------------------------------
19395               *
19396               * Copy the three 16-bit seeds for the current galaxy's system 0 (QQ21) into the
19397               * seeds for the selected system (QQ15) - in other words, set the selected
19398               * system's seeds to those of system 0.
19399               *
19400               * ******************************************************************************
19401               
19402               TT81:
19403 5AA4 0201  20        li   rx,>05*256                 ; LDX #5            ; Set up a counter in X to copy six bytes (for three
     5AA6 0500     
19404                                                                          ; 16-bit numbers)
19405               
19406 5AA8 D021  34        movb @QQ21(rx),ra               ; LDA QQ21,X        ; Copy the X-th byte in QQ21 to the X-th byte in QQ15
     5AAA 0303     
19407 5AAC D840  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     5AAE 0078     
19408               
19409 5AB0 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19410               
19411 5AB2 15F9  14        jgt  TT81+2                     ; BPL TT81+2        ; Loop back up to the LDA instruction if we still have
19412                                                                          ; more bytes to copy
19413               
19414 5AB4 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     5AB6 800E     
19415               
19416               * ******************************************************************************
19417               *
19418               * Name: TT111
19419               * Type: Subroutine
19420               * Category: Universe
19421               * Summary: Set the current system to the nearest system to a point
19422               *
19423               * ------------------------------------------------------------------------------
19424               *
19425               * Given a set of galactic coordinates in (QQ9, QQ10), find the nearest system
19426               * to this point in the galaxy, and set this as the currently selected system.
19427               *
19428               * ------------------------------------------------------------------------------
19429               *
19430               * Arguments:
19431               *
19432               * QQ9                 The x-coordinate near which we want to find a system
19433               *
19434               * QQ10                The y-coordinate near which we want to find a system
19435               *
19436               * ------------------------------------------------------------------------------
19437               *
19438               * Returns:
19439               *
19440               * QQ8(1 0)            The distance from the current system to the nearest
19441               * system to the original coordinates
19442               *
19443               * QQ9                 The x-coordinate of the nearest system to the original
19444               * coordinates
19445               *
19446               * QQ10                The y-coordinate of the nearest system to the original
19447               * coordinates
19448               *
19449               * QQ15 to QQ15+5      The three 16-bit seeds of the nearest system to the
19450               * original coordinates
19451               *
19452               * ------------------------------------------------------------------------------
19453               *
19454               * Other entry points:
19455               *
19456               * TT111-1             Contains an RTS
19457               *
19458               * ******************************************************************************
19459               
19460               TT111:
19461 5AB8 0206  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     5ABA 5AA4     
19462 5ABC 06A0  28        bl   @jsr                       ;
     5ABE 8002     
19463                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
19464               
19465                                                                          ; We now loop through every single system in the galaxy
19466                                                                          ; and check the distance from (QQ9, QQ10). We get the
19467                                                                          ; galactic coordinates of each system from the system's
19468                                                                          ; seeds, like this:
19469                                                                          ;
19470                                                                          ; x = s1_hi (which is stored in QQ15+3)
19471                                                                          ; y = s0_hi (which is stored in QQ15+1)
19472                                                                          ;
19473                                                                          ; so the following loops through each system in the
19474                                                                          ; galaxy in turn and calculates the distance between
19475                                                                          ; (QQ9, QQ10) and (s1_hi, s0_hi) to find the closest one
19476               
19477 5AC0 0202  20        li   ry,>7f*256                 ; LDY #127          ; Set Y = T = 127 to hold the shortest distance we've
     5AC2 7F00     
19478 5AC4 D802  30        movb ry,@T                      ; STY T             ; found so far, which we initially set to half the
     5AC6 00D1     
19479                                                                          ; distance across the galaxy, or 127, as our coordinate
19480                                                                          ; system ranges from (0,0) to (255, 255)
19481               
19482 5AC8 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = U = 0 to act as a counter for each system in
     5ACA 0000     
19483 5ACC D800  30        movb ra,@U                      ; STA U             ; the current galaxy, which we start at system 0 and
     5ACE 008F     
19484                                                                          ; loop through to 255, the last system
19485               
19486               TT130:
19487 5AD0 D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ9, the horizontal distance between
     5AD2 007B     
19488                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ9, QQ10)
     **** ****     > SEC
0001 5AD4 0A15  18        sla  rmone,1
                   < elite.a99
19489                      .sbc @QQ9,ra                    ; SBC QQ9
     **** ****     > SBC
0001 5AD6 1801  14        joc  !
0002 5AD8 7004  18        sb   rone,ra
0003               !:
0004 5ADA 7020  30        sb   @QQ9,ra
     5ADC 0F31     
                   < elite.a99
19490               
19491 5ADE 1807  14        joc  TT132                      ; BCS TT132         ; If a borrow didn't occur, i.e. s1_hi >= QQ9, then the
19492                                                                          ; result is positive, so jump to TT132 and skip the
19493                                                                          ; following two instructions
19494               
19495                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5AE0 0206  20        li   rtmp,(>FF*256)
     5AE2 FF00     
0002 5AE4 2806  18        xor  rtmp,ra
                   < elite.a99
19496                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s1_hi - QQ9|)
     **** ****     > ADI
0001 5AE6 1701  14        jnc  !
0002 5AE8 B004  18        ab   rone,ra
0003               !:
0004 5AEA 0220  22        ai   ra,(>01*256)
     5AEC 0100     
                   < elite.a99
19497               
19498               TT132:
19499 5AEE 0910  18        srl  ra,1                       ; LSR A             ; Set S = A / 2
19500 5AF0 D800  30        movb ra,@S                      ; STA S             ; = |s1_hi - QQ9| / 2
     5AF2 0092     
19501               
19502 5AF4 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ10, the vertical distance between
     5AF6 0079     
19503                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ9, QQ10)
     **** ****     > SEC
0001 5AF8 0A15  18        sla  rmone,1
                   < elite.a99
19504                      .sbc @QQ10,ra                   ; SBC QQ10
     **** ****     > SBC
0001 5AFA 1801  14        joc  !
0002 5AFC 7004  18        sb   rone,ra
0003               !:
0004 5AFE 7020  30        sb   @QQ10,ra
     5B00 0F32     
                   < elite.a99
19505               
19506 5B02 1807  14        joc  TT134                      ; BCS TT134         ; If a borrow didn't occur, i.e. s0_hi >= QQ10, then the
19507                                                                          ; result is positive, so jump to TT134 and skip the
19508                                                                          ; following two instructions
19509               
19510                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5B04 0206  20        li   rtmp,(>FF*256)
     5B06 FF00     
0002 5B08 2806  18        xor  rtmp,ra
                   < elite.a99
19511                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s0_hi - QQ10|)
     **** ****     > ADI
0001 5B0A 1701  14        jnc  !
0002 5B0C B004  18        ab   rone,ra
0003               !:
0004 5B0E 0220  22        ai   ra,(>01*256)
     5B10 0100     
                   < elite.a99
19512               
19513               TT134:
19514 5B12 0910  18        srl  ra,1                       ; LSR A             ; Set A = S + A / 2
19515                      .clc                            ; CLC               ; = |s1_hi - QQ9| / 2 + |s0_hi - QQ10| / 2
     **** ****     > CLC
0001 5B14 0A13  18        sla  rzero,1
                   < elite.a99
19516                      .adc @S,ra                      ; ADC S             ;
     **** ****     > ADC
0001 5B16 1701  14        jnc  !
0002 5B18 B004  18        ab   rone,ra
0003               !:
0004 5B1A B020  30        ab   @S,ra
     5B1C 0092     
                   < elite.a99
19517                                                                          ; So A now contains the sum of the horizontal and
19518                                                                          ; vertical distances, both divided by 2 so the result
19519                                                                          ; fits into one byte, and although this doesn't contain
19520                                                                          ; the actual distance between the systems, it's a good
19521                                                                          ; enough approximation to use for comparing distances
19522               
19523 5B1E 9020  30        cb   @T,ra                      ; CMP T             ; If A >= T, then this system's distance is bigger than
     5B20 00D1     
19524 5B22 180A  14        joc  TT135                      ; BCS TT135         ; our "minimum distance so far" stored in T, so it's no
19525                                                                          ; closer than the systems we have already found, so
19526                                                                          ; skip to TT135 to move on to the next system
19527               
19528 5B24 D800  30        movb ra,@T                      ; STA T             ; This system is the closest to (QQ9, QQ10) so far, so
     5B26 00D1     
19529                                                                          ; update T with the new "distance" approximation
19530               
19531 5B28 0201  20        li   rx,>05*256                 ; LDX #5            ; As this system is the closest we have found yet, we
     5B2A 0500     
19532                                                                          ; want to store the system's seeds in case it ends up
19533                                                                          ; being the closest of all, so we set up a counter in X
19534                                                                          ; to copy six bytes (for three 16-bit numbers)
19535               
19536               TT136:
19537 5B2C D021  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy the X-th byte in QQ15 to the X-th byte in QQ19,
     5B2E 0078     
19538 5B30 D840  38        movb ra,@QQ19(rx)               ; STA QQ19,X        ; where QQ15 contains the seeds for the system we just
     5B32 007F     
19539                                                                          ; found to be the closest so far, and QQ19 is temporary
19540                                                                          ; storage
19541               
19542 5B34 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19543               
19544 5B36 15FA  14        jgt  TT136                      ; BPL TT136         ; Loop back to TT136 if we still have more bytes to
19545                                                                          ; copy
19546               
19547               TT135:
19548 5B38 0206  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     5B3A 4E32     
19549 5B3C 06A0  28        bl   @jsr                       ;
     5B3E 8002     
19550                                                                          ; to twist the three 16-bit seeds in QQ15
19551               
19552 5B40 B004  18        ab   rone,ra                    ; INC U             ; Increment the system counter in U
19553               
19554 5B42 16C6  14        jne  TT130                      ; BNE TT130         ; If U > 0 then we haven't done all 256 systems yet, so
19555                                                                          ; loop back up to TT130
19556               
19557                                                                          ; We have now finished checking all the systems in the
19558                                                                          ; galaxy, and the seeds for the closest system are in
19559                                                                          ; QQ19, so now we want to copy these seeds to QQ15,
19560                                                                          ; to set the selected system to this closest system
19561               
19562 5B44 0201  20        li   rx,>05*256                 ; LDX #5            ; So we set up a counter in X to copy six bytes (for
     5B46 0500     
19563                                                                          ; three 16-bit numbers)
19564               
19565               TT137:
19566 5B48 D021  34        movb @QQ19(rx),ra               ; LDA QQ19,X        ; Copy the X-th byte in QQ19 to the X-th byte in QQ15
     5B4A 007F     
19567 5B4C D840  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     5B4E 0078     
19568               
19569 5B50 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19570               
19571 5B52 15FA  14        jgt  TT137                      ; BPL TT137         ; Loop back to TT137 if we still have more bytes to
19572                                                                          ; copy
19573               
19574 5B54 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; The y-coordinate of the system described by the seeds
     5B56 0079     
19575 5B58 D800  30        movb ra,@QQ10                   ; STA QQ10          ; in QQ15 is in QQ15+1 (s0_hi), so we copy this to QQ10
     5B5A 0F32     
19576                                                                          ; as this is where we store the selected system's
19577                                                                          ; y-coordinate
19578               
19579 5B5C D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; The x-coordinate of the system described by the seeds
     5B5E 007B     
19580 5B60 D800  30        movb ra,@QQ9                    ; STA QQ9           ; in QQ15 is in QQ15+3 (s1_hi), so we copy this to QQ9
     5B62 0F31     
19581                                                                          ; as this is where we store the selected system's
19582                                                                          ; x-coordinate
19583               
19584                                                                          ; We have now found the closest system to (QQ9, QQ10)
19585                                                                          ; and have set it as the selected system, so now we
19586                                                                          ; need to work out the distance between the selected
19587                                                                          ; system and the current system
19588               
19589                      .sec                            ; SEC               ; Set A = QQ9 - QQ0, the horizontal distance between
     **** ****     > SEC
0001 5B64 0A15  18        sla  rmone,1
                   < elite.a99
19590                      .sbc @QQ0,ra                    ; SBC QQ0           ; the selected system's x-coordinate (QQ9) and the
     **** ****     > SBC
0001 5B66 1801  14        joc  !
0002 5B68 7004  18        sb   rone,ra
0003               !:
0004 5B6A 7020  30        sb   @QQ0,ra
     5B6C 0301     
                   < elite.a99
19591                                                                          ; current system's x-coordinate (QQ0)
19592               
19593 5B6E 1807  14        joc  TT139                      ; BCS TT139         ; If a borrow didn't occur, i.e. QQ9 >= QQ0, then the
19594                                                                          ; result is positive, so jump to TT139 and skip the
19595                                                                          ; following two instructions
19596               
19597                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5B70 0206  20        li   rtmp,(>FF*256)
     5B72 FF00     
0002 5B74 2806  18        xor  rtmp,ra
                   < elite.a99
19598                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |QQ9 - QQ0|)
     **** ****     > ADI
0001 5B76 1701  14        jnc  !
0002 5B78 B004  18        ab   rone,ra
0003               !:
0004 5B7A 0220  22        ai   ra,(>01*256)
     5B7C 0100     
                   < elite.a99
19599               
19600                                                                          ; A now contains the difference between the two
19601                                                                          ; systems' x-coordinates, with the sign removed. We
19602                                                                          ; will refer to this as the x-delta ("delta" means
19603                                                                          ; change or difference in maths)
19604               
19605               TT139:
19606 5B7E 0206  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A
     5B80 42BA     
19607 5B82 06A0  28        bl   @jsr                       ;
     5B84 8002     
19608                                                                          ; = |QQ9 - QQ0| ^ 2
19609                                                                          ; = x_delta ^ 2
19610               
19611 5B86 D800  30        movb ra,@K+1                    ; STA K+1           ; Store (A P) in K(1 0)
     5B88 003E     
19612 5B8A D020  30        movb @P,ra                      ; LDA P
     5B8C 001B     
19613 5B8E D800  30        movb ra,@K                      ; STA K
     5B90 003D     
19614               
19615 5B92 D020  30        movb @QQ10,ra                   ; LDA QQ10          ; Set A = QQ10 - QQ1, the vertical distance between the
     5B94 0F32     
19616                      .sec                            ; SEC               ; selected system's y-coordinate (QQ10) and the current
     **** ****     > SEC
0001 5B96 0A15  18        sla  rmone,1
                   < elite.a99
19617                      .sbc @QQ1,ra                    ; SBC QQ1           ; system's y-coordinate (QQ1)
     **** ****     > SBC
0001 5B98 1801  14        joc  !
0002 5B9A 7004  18        sb   rone,ra
0003               !:
0004 5B9C 7020  30        sb   @QQ1,ra
     5B9E 0302     
                   < elite.a99
19618               
19619 5BA0 1807  14        joc  TT141                      ; BCS TT141         ; If a borrow didn't occur, i.e. QQ10 >= QQ1, then the
19620                                                                          ; result is positive, so jump to TT141 and skip the
19621                                                                          ; following two instructions
19622               
19623                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5BA2 0206  20        li   rtmp,(>FF*256)
     5BA4 FF00     
0002 5BA6 2806  18        xor  rtmp,ra
                   < elite.a99
19624                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |QQ10 - QQ1|)
     **** ****     > ADI
0001 5BA8 1701  14        jnc  !
0002 5BAA B004  18        ab   rone,ra
0003               !:
0004 5BAC 0220  22        ai   ra,(>01*256)
     5BAE 0100     
                   < elite.a99
19625               
19626               TT141:
19627 5BB0 0910  18        srl  ra,1                       ; LSR A             ; Set A = A / 2
19628               
19629                                                                          ; A now contains the difference between the two
19630                                                                          ; systems' y-coordinates, with the sign removed, and
19631                                                                          ; halved. We halve the value because the galaxy in
19632                                                                          ; in Elite is rectangular rather than square, and is
19633                                                                          ; twice as wide (x-axis) as it is high (y-axis), so to
19634                                                                          ; get a distance that matches the shape of the
19635                                                                          ; long-range galaxy chart, we need to halve the
19636                                                                          ; distance between the vertical y-coordinates. We will
19637                                                                          ; refer to this as the y-delta
19638               
19639 5BB2 0206  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A
     5BB4 42BA     
19640 5BB6 06A0  28        bl   @jsr                       ;
     5BB8 8002     
19641                                                                          ; = (|QQ10 - QQ1| / 2) ^ 2
19642                                                                          ; = y_delta ^ 2
19643               
19644                                                                          ; By this point we have the following results:
19645                                                                          ;
19646                                                                          ; K(1 0) = x_delta ^ 2
19647                                                                          ; (A P) = y_delta ^ 2
19648                                                                          ;
19649                                                                          ; so to find the distance between the two points, we
19650                                                                          ; can use Pythagoras - so first we need to add the two
19651                                                                          ; results together, and then take the square root
19652               
19653                      .pha                            ; PHA               ; Store the high byte of the y-axis value on the stack,
     **** ****     > PHA
0001 5BBA D680  30        movb ra,*rsp
0002 5BBC 060A  14        dec  rsp
                   < elite.a99
19654                                                                          ; so we can use A for another purpose
19655               
19656 5BBE D020  30        movb @P,ra                      ; LDA P             ; Set Q = P + K, which adds the low bytes of the two
     5BC0 001B     
19657                      .clc                            ; CLC               ; calculated values
     **** ****     > CLC
0001 5BC2 0A13  18        sla  rzero,1
                   < elite.a99
19658                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 5BC4 1701  14        jnc  !
0002 5BC6 B004  18        ab   rone,ra
0003               !:
0004 5BC8 B020  30        ab   @K,ra
     5BCA 003D     
                   < elite.a99
19659 5BCC D800  30        movb ra,@Q                      ; STA Q
     5BCE 0090     
19660               
19661                      .pla                            ; PLA               ; Restore the high byte of the y-axis value from the
     **** ****     > PLA
0001 5BD0 058A  14        inc  rsp
0002 5BD2 D01A  26        movb *rsp,ra
                   < elite.a99
19662                                                                          ; stack into A again
19663               
19664                      .adc @K+1,ra                    ; ADC K+1           ; Set R = A + K+1, which adds the high bytes of the two
     **** ****     > ADC
0001 5BD4 1701  14        jnc  !
0002 5BD6 B004  18        ab   rone,ra
0003               !:
0004 5BD8 B020  30        ab   @K+1,ra
     5BDA 003E     
                   < elite.a99
19665 5BDC D800  30        movb ra,@R                      ; STA R             ; calculated values, so we now have:
     5BDE 0091     
19666                                                                          ;
19667                                                                          ; (R Q) = K(1 0) + (A P)
19668                                                                          ; = (x_delta ^ 2) + (y_delta ^ 2)
19669               
19670 5BE0 0206  20        li   rtmp,LL5                   ; JSR LL5           ; Set Q = SQRT(R Q), so Q now contains the distance
     5BE2 92AA     
19671 5BE4 06A0  28        bl   @jsr                       ;
     5BE6 8002     
19672                                                                          ; between the two systems, in terms of coordinates
19673               
19674                                                                          ; We now store the distance to the selected system * 4
19675                                                                          ; in the two-byte location QQ8, by taking (0 Q) and
19676                                                                          ; shifting it left twice, storing it in QQ8(1 0)
19677               
19678 5BE8 D020  30        movb @Q,ra                      ; LDA Q             ; First we shift the low byte left by setting
     5BEA 0090     
19679                      .asla                           ; ASL A             ; A = Q * 2, with bit 7 of A going into the C flag
     **** ****     > ASLA
0001 5BEC 0240  22        andi ra,>ff00
     5BEE FF00     
0002 5BF0 0A10  18        sla  ra,1
                   < elite.a99
19680               
19681 5BF2 0201  20        li   rx,>00*256                 ; LDX #0            ; Now we set the high byte in QQ8+1 to 0 and rotate
     5BF4 0000     
19682 5BF6 D801  30        movb rx,@QQ8+1                  ; STX QQ8+1         ; the C flag into bit 0 of QQ8+1
     5BF8 0F30     
19683 5BFA 0208  20        li   rarg1,QQ8+1                ; ROL QQ8+1
     5BFC 0F30     
19684 5BFE 06A0  28        bl   @rol                       ;
     5C00 8028     
19685               
19686                      .asla                           ; ASL A             ; And then we repeat the shift left of (QQ8+1 A)
     **** ****     > ASLA
0001 5C02 0240  22        andi ra,>ff00
     5C04 FF00     
0002 5C06 0A10  18        sla  ra,1
                   < elite.a99
19687 5C08 0208  20        li   rarg1,QQ8+1                ; ROL QQ8+1
     5C0A 0F30     
19688 5C0C 06A0  28        bl   @rol                       ;
     5C0E 8028     
19689               
19690 5C10 D800  30        movb ra,@QQ8                    ; STA QQ8           ; And store A in the low byte, QQ8, so QQ8(1 0) now
     5C12 0F2F     
19691                                                                          ; contains Q * 4. Given that the width of the galaxy is
19692                                                                          ; 256 in coordinate terms, the width of the galaxy
19693                                                                          ; would be 1024 in the units we store in QQ8
19694               
19695 5C14 0460  28        b    @TT24                      ; JMP TT24          ; Call TT24 to calculate system data from the seeds in
     5C16 5162     
19696                                                                          ; QQ15 and store them in the relevant locations, so our
19697                                                                          ; new selected system is fully set up, and return from
19698                                                                          ; the subroutine using a tail call
19699               
19700               * ******************************************************************************
19701               *
19702               * Name: hy6
19703               * Type: Subroutine
19704               * Category: Flight
19705               * Summary: Print a message to say there is no hyperspacing allowed inside the
19706               * station
19707               *
19708               * ------------------------------------------------------------------------------
19709               *
19710               * Print "Docked" at the bottom of the screen to indicate we can't hyperspace
19711               * when docked.
19712               *
19713               * ******************************************************************************
19714               
19715               hy6_:
19716 5C18 0206  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     5C1A 4C2E     
19717 5C1C 06A0  28        bl   @jsr                       ;
     5C1E 8002     
19718                                                                          ; and move the text cursor to column 1 on row 21, i.e.
19719                                                                          ; the start of the top row of the three bottom rows
19720               
19721 5C20 0200  20        li   ra,>0f*256                 ; LDA #15           ; Move the text cursor to column 15 (the middle of the
     5C22 0F00     
19722 5C24 D800  30        movb ra,@XC                     ; STA XC            ; screen), setting A to 15 at the same time for the
     5C26 002C     
19723                                                                          ; following call to TT27
19724               
19725 5C28 0460  28        b    @TT27                      ; JMP TT27          ; Print recursive token 129 ("{sentence case}DOCKED")
     5C2A 66DC     
19726                                                                          ; and return from the subroutine using a tail call
19727               
19728               * ******************************************************************************
19729               *
19730               * Name: hyp
19731               * Type: Subroutine
19732               * Category: Flight
19733               * Summary: Start the hyperspace process
19734               *
19735               * ------------------------------------------------------------------------------
19736               *
19737               * Called when "H" or CTRL-H is pressed during flight. Checks the following:
19738               *
19739               * * We are in space
19740               *
19741               * * We are not already in a hyperspace countdown
19742               *
19743               * If CTRL is being held down, we jump to Ghy to engage the galactic hyperdrive,
19744               * otherwise we check that:
19745               *
19746               * * The selected system is not the current system
19747               *
19748               * * We have enough fuel to make the jump
19749               *
19750               * and if all the pre-jump checks are passed, we print the destination on-screen
19751               * and start the countdown.
19752               *
19753               * ******************************************************************************
19754               
19755               hyp_:
19756 5C2C D020  30        movb @QQ12,ra                   ; LDA QQ12          ; If we are docked (QQ12 = &FF) then jump to hy6 to
     5C2E 009F     
19757 5C30 16F3  14        jne  hy6_                       ; BNE hy6           ; print an error message and return from the subroutine
19758                                                                          ; using a tail call (as we can't hyperspace when docked)
19759               
19760 5C32 D020  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; Fetch QQ22+1, which contains the number that's shown
     5C34 002F     
19761                                                                          ; on-screen during hyperspace countdown
19762               
19763 5C36 165B  14        jne  zZ_+1                      ; BNE zZ_+1         ; If it is non-zero, return from the subroutine (as zZ+1
19764                                                                          ; contains an RTS), as there is already a countdown in
19765                                                                          ; progress
19766               
19767 5C38 0206  20        li   rtmp,CTRL                  ; JSR CTRL          ; Scan the keyboard to see if CTRL is currently pressed
     5C3A 8C18     
19768 5C3C 06A0  28        bl   @jsr                       ;
     5C3E 8002     
19769               
19770 5C40 1136  14        jlt  Ghy                        ; BMI Ghy           ; If it is, then the galactic hyperdrive has been
19771                                                                          ; activated, so jump to Ghy to process it
19772               
19773 5C42 0206  20        li   rtmp,hm_                   ; JSR hm            ; This is a chart view, so call hm to redraw the chart
     5C44 4C10     
19774 5C46 06A0  28        bl   @jsr                       ;
     5C48 8002     
19775                                                                          ; crosshairs
19776               
19777 5C4A D020  30        movb @QQ8,ra                    ; LDA QQ8           ; If both bytes of the distance to the selected system
     5C4C 0F2F     
19778 5C4E F020  30        socb @QQ8+1,ra                  ; ORA QQ8+1         ; in QQ8 are zero, return from the subroutine (as zZ+1
     5C50 0F30     
19779 5C52 134D  14        jeq  zZ_+1                      ; BEQ zZ_+1         ; contains an RTS), as the selected system is the
19780                                                                          ; current system
19781               
19782 5C54 0200  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7, row 23 (in the
     5C56 0700     
19783 5C58 D800  30        movb ra,@XC                     ; STA XC            ; middle of the bottom text row)
     5C5A 002C     
19784 5C5C 0200  20        li   ra,>17*256                 ; LDA #23
     5C5E 1700     
19785 5C60 D800  30        movb ra,@YC                     ; STA YC
     5C62 002D     
19786               
19787 5C64 0200  20        li   ra,>00*256                 ; LDA #0            ; Set QQ17 = 0 to switch to ALL CAPS
     5C66 0000     
19788 5C68 D800  30        movb ra,@QQ17                   ; STA QQ17
     5C6A 007E     
19789               
19790 5C6C 0200  20        li   ra,>bd*256                 ; LDA #189          ; Print recursive token 29 ("HYPERSPACE ")
     5C6E BD00     
19791 5C70 0206  20        li   rtmp,TT27                  ; JSR TT27
     5C72 66DC     
19792 5C74 06A0  28        bl   @jsr                       ;
     5C76 8002     
19793               
19794 5C78 D020  30        movb @QQ8+1,ra                  ; LDA QQ8+1         ; If the high byte of the distance to the selected
     5C7A 0F30     
19795 5C7C 1668  14        jne  TT147                      ; BNE TT147         ; system in QQ8 is > 0, then it is definitely too far to
19796                                                                          ; jump (as our maximum range is 7.0 light years, or a
19797                                                                          ; value of 70 in QQ8(1 0)), so jump to TT147 to print
19798                                                                          ; "RANGE?" and return from the subroutine using a tail
19799                                                                          ; call
19800               
19801 5C7E D020  30        movb @QQ14,ra                   ; LDA QQ14          ; Fetch our current fuel level from Q114 into A
     5C80 030D     
19802               
19803 5C82 9020  30        cb   @QQ8,ra                    ; CMP QQ8           ; If our fuel reserves are less than the distance to the
     5C84 0F2F     
19804 5C86 1763  14        jnc  TT147                      ; BCC TT147         ; selected system, then we don't have enough fuel for
19805                                                                          ; this jump, so jump to TT147 to print "RANGE?" and
19806                                                                          ; return from the subroutine using a tail call
19807               
19808 5C88 0200  20        li   ra,('-')*256               ; LDA #'-'          ; Print a hyphen
     5C8A 2D00     
19809 5C8C 0206  20        li   rtmp,TT27                  ; JSR TT27
     5C8E 66DC     
19810 5C90 06A0  28        bl   @jsr                       ;
     5C92 8002     
19811               
19812 5C94 0206  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print the name of the selected system
     5C96 65B8     
19813 5C98 06A0  28        bl   @jsr                       ;
     5C9A 8002     
19814               
19815                                                                          ; Fall through into wW to start the hyperspace countdown
19816               
19817               * ******************************************************************************
19818               *
19819               * Name: wW
19820               * Type: Subroutine
19821               * Category: Flight
19822               * Summary: Start a hyperspace countdown
19823               *
19824               * ------------------------------------------------------------------------------
19825               *
19826               * Start the hyperspace countdown (for both inter-system hyperspace and the
19827               * galactic hyperdrive).
19828               *
19829               * ******************************************************************************
19830               
19831               wW:
19832 5C9C 0200  20        li   ra,>0f*256                 ; LDA #15           ; The hyperspace countdown starts from 15, so set A to
     5C9E 0F00     
19833                                                                          ; 15 so we can set the two hyperspace counters
19834               
19835 5CA0 D800  30        movb ra,@QQ22+1                 ; STA QQ22+1        ; Set the number in QQ22+1 to A, which is the number
     5CA2 002F     
19836                                                                          ; that's shown on-screen during the hyperspace countdown
19837               
19838 5CA4 D800  30        movb ra,@QQ22                   ; STA QQ22          ; Set the number in QQ22 to 15, which is the internal
     5CA6 002E     
19839                                                                          ; counter that counts down by 1 each iteration of the
19840                                                                          ; main game loop, and each time it reaches zero, the
19841                                                                          ; on-screen counter gets decremented, and QQ22 gets set
19842                                                                          ; to 5, so setting QQ22 to 15 here makes the first tick
19843                                                                          ; of the hyperspace counter longer than subsequent ticks
19844               
19845 5CA8 D040  18        movb ra,rx                      ; TAX               ; Print the 8-bit number in X (i.e. 15) at text location
19846 5CAA 0460  28        b    @ee3_                      ; JMP ee3           ; (0, 1), padded to 5 digits, so it appears in the top
     5CAC 5D36     
19847                                                                          ; left corner of the screen, and return from the
19848                                                                          ; subroutine using a tail call
19849               
19850               * .hy5                   \ This instruction and the hy5 label are commented out
19851               * RTS                    \ in the original - they can actually be found at the
19852                                                                          ; end of the jmp routine below, so perhaps this is where
19853                                                                          ; they were originally, but the authors realised they
19854                                                                          ; could save a byte by using a tail call instead of an
19855                                                                          ; RTS?
19856               
19857               * ******************************************************************************
19858               *
19859               * Name: Ghy
19860               * Type: Subroutine
19861               * Category: Flight
19862               * Summary: Perform a galactic hyperspace jump
19863               * Deep dive: Twisting the system seeds
19864               * Galaxy and system seeds
19865               *
19866               * ------------------------------------------------------------------------------
19867               *
19868               * Engage the galactic hyperdrive. Called from the hyp routine above if CTRL-H is
19869               * being pressed.
19870               *
19871               * This routine also updates the galaxy seeds to point to the next galaxy. Using
19872               * a galactic hyperdrive rotates each seed byte to the left, rolling each byte
19873               * left within itself like this:
19874               *
19875               * 01234567 -> 12345670
19876               *
19877               * to get the seeds for the next galaxy. So after 8 galactic jumps, the seeds
19878               * roll round to those of the first galaxy again.
19879               *
19880               * We always arrive in a new galaxy at galactic coordinates (96, 96), and then
19881               * find the nearest system and set that as our location.
19882               *
19883               * ------------------------------------------------------------------------------
19884               *
19885               * Other entry points:
19886               *
19887               * zZ+1                Contains an RTS
19888               *
19889               * ******************************************************************************
19890               
19891               Ghy:
19920               
19921 5CAE D060  30        movb @GHYP,rx                   ; LDX GHYP          ; Fetch GHYP, which tells us whether we own a galactic
     5CB0 032D     
19922 5CB2 133F  14        jeq  hy5_                       ; BEQ hy5           ; hyperdrive, and if it is zero, which means we don't,
19923                                                                          ; return from the subroutine (as hy5 contains an RTS)
19924               
19925 5CB4 B044  18        ab   rone,rx                    ; INX               ; We own a galactic hyperdrive, so X is &FF, so this
19926                                                                          ; instruction sets X = 0
19927               
19934               
19935 5CB6 D801  30        movb rx,@GHYP                   ; STX GHYP          ; The galactic hyperdrive is a one-use item, so set GHYP
     5CB8 032D     
19936                                                                          ; to 0 so we no longer have one fitted
19937               
19938 5CBA D801  30        movb rx,@FIST                   ; STX FIST          ; Changing galaxy also clears our criminal record, so
     5CBC 0334     
19939                                                                          ; set our legal status in FIST to 0 ("clean")
19940               
19941 5CBE 0206  20        li   rtmp,wW                    ; JSR wW            ; Call wW to start the hyperspace countdown
     5CC0 5C9C     
19942 5CC2 06A0  28        bl   @jsr                       ;
     5CC4 8002     
19943               
19944 5CC6 0201  20        li   rx,>05*256                 ; LDX #5            ; To move galaxy, we rotate the galaxy's seeds left, so
     5CC8 0500     
19945                                                                          ; set a counter in X for the 6 seed bytes
19946               
19947 5CCA B004  18        ab   rone,ra                    ; INC GCNT          ; Increment the current galaxy number in GCNT
19948               
19949 5CCC D020  30        movb @GCNT,ra                   ; LDA GCNT          ; Set GCNT = GCNT mod 8, so we jump from galaxy 7 back
     5CCE 030F     
19950 5CD0 0240  22        andi ra,>07*256                 ; AND #7            ; to galaxy 0 (shown in-game as going from galaxy 8 back
     5CD2 0700     
19951 5CD4 D800  30        movb ra,@GCNT                   ; STA GCNT          ; to the starting point in galaxy 1)
     5CD6 030F     
19952               
19953               G1:
19954 5CD8 D021  34        movb @QQ21(rx),ra               ; LDA QQ21,X        ; Load the X-th seed byte into A
     5CDA 0303     
19955               
19956                      .asla                           ; ASL A             ; Set the C flag to bit 7 of the seed
     **** ****     > ASLA
0001 5CDC 0240  22        andi ra,>ff00
     5CDE FF00     
0002 5CE0 0A10  18        sla  ra,1
                   < elite.a99
19957               
19958 5CE2 0208  20        li   rarg1,QQ21                 ; ROL QQ21,X        ; Rotate the seed in memory, which will add bit 7 back
     5CE4 0303     
19959 5CE6 06A0  28        bl   @rol                       ;
     5CE8 8028     
19960                                                                          ; in as bit 0, so this rolls the seed around on itself
19961               
19962 5CEA 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19963               
19964 5CEC 15F5  14        jgt  G1                         ; BPL G1            ; Loop back for the next seed byte, until we have
19965                                                                          ; rotated them all
19966               
19967               * JSR DORND              \ This instruction is commented out in the original
19968                                                                          ; source, and would set A and X to random numbers, so
19969                                                                          ; perhaps the original plan was to arrive in each new
19970                                                                          ; galaxy in a random place?
19971               
19972               zZ_:
19973 5CEE 0200  20        li   ra,>60*256                 ; LDA #96           ; Set (QQ9, QQ10) to (96, 96), which is where we always
     5CF0 6000     
19974 5CF2 D800  30        movb ra,@QQ9                    ; STA QQ9           ; arrive in a new galaxy (the selected system will be
     5CF4 0F31     
19975 5CF6 D800  30        movb ra,@QQ10                   ; STA QQ10          ; set to the nearest actual system later on)
     5CF8 0F32     
19976               
19977 5CFA 0206  20        li   rtmp,TT110                 ; JSR TT110         ; Call TT110 to show the front space view
     5CFC 60FE     
19978 5CFE 06A0  28        bl   @jsr                       ;
     5D00 8002     
19979               
19981               
19982 5D02 0206  20        li   rtmp,TT111                 ; JSR TT111         ; Call TT111 to set the current system to the nearest
     5D04 5AB8     
19983 5D06 06A0  28        bl   @jsr                       ;
     5D08 8002     
19984                                                                          ; system to (QQ9, QQ10), and put the seeds of the
19985                                                                          ; nearest system into QQ15 to QQ15+5
19986                                                                          ;
19987                                                                          ; This call fixes a bug in the early cassette versions,
19988                                                                          ; where the galactic hyperdrive will take us to
19989                                                                          ; coordinates (96, 96) in the new galaxy, even if there
19990                                                                          ; isn't actually a system there, so if we jump when we
19991                                                                          ; are low on fuel, it is possible to get stuck in the
19992                                                                          ; middle of nowhere when changing galaxy
19993                                                                          ;
19994                                                                          ; This call sets the current system correctly, so we
19995                                                                          ; always arrive at the nearest system to (96, 96)
19996               
19998               
20000               
20001 5D0A 0201  20        li   rx,>00*256                 ; LDX #0            ; Set the distance to the selected system in QQ8(1 0)
     5D0C 0000     
20002 5D0E D801  30        movb rx,@QQ8                    ; STX QQ8           ; to 0
     5D10 0F2F     
20003 5D12 D801  30        movb rx,@QQ8+1                  ; STX QQ8+1
     5D14 0F30     
20004               
20006               
20007 5D16 0200  20        li   ra,>74*256                 ; LDA #116          ; Print recursive token 116 ("GALACTIC HYPERSPACE")
     5D18 7400     
20008 5D1A 0206  20        li   rtmp,MESS                  ; JSR MESS          ; as an in-flight message
     5D1C 8E52     
20009 5D1E 06A0  28        bl   @jsr                       ;
     5D20 8002     
20010               
20011                                                                          ; Fall through into jmp to set the system to the
20012                                                                          ; current system and return from the subroutine there
20013               
20014               * ******************************************************************************
20015               *
20016               * Name: jmp
20017               * Type: Subroutine
20018               * Category: Universe
20019               * Summary: Set the current system to the selected system
20020               *
20021               * ------------------------------------------------------------------------------
20022               *
20023               * Returns:
20024               *
20025               * (QQ0, QQ1)          The galactic coordinates of the new system
20026               *
20027               * ------------------------------------------------------------------------------
20028               *
20029               * Other entry points:
20030               *
20031               * hy5                 Contains an RTS
20032               *
20033               * ******************************************************************************
20034               
20035               jmp_:
20036 5D22 D020  30        movb @QQ9,ra                    ; LDA QQ9           ; Set the current system's galactic x-coordinate to the
     5D24 0F31     
20037 5D26 D800  30        movb ra,@QQ0                    ; STA QQ0           ; x-coordinate of the selected system
     5D28 0301     
20038               
20039 5D2A D020  30        movb @QQ10,ra                   ; LDA QQ10          ; Set the current system's galactic y-coordinate to the
     5D2C 0F32     
20040 5D2E D800  30        movb ra,@QQ1                    ; STA QQ1           ; y-coordinate of the selected system
     5D30 0302     
20041               
20042               hy5_:
20043 5D32 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     5D34 800E     
20044               
20045               * ******************************************************************************
20046               *
20047               * Name: ee3
20048               * Type: Subroutine
20049               * Category: Flight
20050               * Summary: Print the hyperspace countdown in the top-left of the screen
20051               *
20052               * ------------------------------------------------------------------------------
20053               *
20054               * Print the 8-bit number in X at text location (0, 1). Print the number to
20055               * 5 digits, left-padding with spaces for numbers with fewer than 3 digits (so
20056               * numbers < 10000 are right-aligned), with no decimal point.
20057               *
20058               * ------------------------------------------------------------------------------
20059               *
20060               * Arguments:
20061               *
20062               * X                   The number to print
20063               *
20064               * ******************************************************************************
20065               
20066               ee3_:
20067 5D36 0202  20        li   ry,>01*256                 ; LDY #1            ; Move the text cursor to row 1
     5D38 0100     
20068 5D3A D802  30        movb ry,@YC                     ; STY YC
     5D3C 002D     
20069               
20070 5D3E 7084  18        sb   rone,ry                    ; DEY               ; Decrement Y to 0 for the high byte in pr6
20071               
20072 5D40 D802  30        movb ry,@XC                     ; STY XC            ; Move the text cursor to column 0
     5D42 002C     
20073               
20074                                                                          ; Fall through into pr6 to print X to 5 digits, as the
20075                                                                          ; high byte in Y is 0
20076               
20077               * ******************************************************************************
20078               *
20079               * Name: pr6
20080               * Type: Subroutine
20081               * Category: Text
20082               * Summary: Print 16-bit number, left-padded to 5 digits, no point
20083               *
20084               * ------------------------------------------------------------------------------
20085               *
20086               * Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
20087               * numbers with fewer than 3 digits (so numbers < 10000 are right-aligned),
20088               * with no decimal point.
20089               *
20090               * ------------------------------------------------------------------------------
20091               *
20092               * Arguments:
20093               *
20094               * X                   The low byte of the number to print
20095               *
20096               * Y                   The high byte of the number to print
20097               *
20098               * ******************************************************************************
20099               
20100               pr6_:
20101                      .clc                            ; CLC               ; Do not display a decimal point when printing
     **** ****     > CLC
0001 5D44 0A13  18        sla  rzero,1
                   < elite.a99
20102               
20103                                                                          ; Fall through into pr5 to print X to 5 digits
20104               
20105               * ******************************************************************************
20106               *
20107               * Name: pr5
20108               * Type: Subroutine
20109               * Category: Text
20110               * Summary: Print a 16-bit number, left-padded to 5 digits, and optional point
20111               *
20112               * ------------------------------------------------------------------------------
20113               *
20114               * Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
20115               * numbers with fewer than 3 digits (so numbers < 10000 are right-aligned).
20116               * Optionally include a decimal point.
20117               *
20118               * ------------------------------------------------------------------------------
20119               *
20120               * Arguments:
20121               *
20122               * X                   The low byte of the number to print
20123               *
20124               * Y                   The high byte of the number to print
20125               *
20126               * C flag              If set, include a decimal point
20127               *
20128               * ******************************************************************************
20129               
20130               pr5_:
20131 5D46 0200  20        li   ra,>05*256                 ; LDA #5            ; Set the number of digits to print to 5
     5D48 0500     
20132               
20133 5D4A 0460  28        b    @TT11                      ; JMP TT11          ; Call TT11 to print (Y X) to 5 digits and return from
     5D4C 2FB4     
20134                                                                          ; the subroutine using a tail call
20135               
20136               * ******************************************************************************
20137               *
20138               * Name: TT147
20139               * Type: Subroutine
20140               * Category: Flight
20141               * Summary: Print an error when a system is out of hyperspace range
20142               *
20143               * ------------------------------------------------------------------------------
20144               *
20145               * Print "RANGE?" for when the hyperspace distance is too far
20146               *
20147               * ******************************************************************************
20148               
20149               TT147:
20150 5D4E 0200  20        li   ra,>ca*256                 ; LDA #202          ; Load A with token 42 ("RANGE") and fall through into
     5D50 CA00     
20151                                                                          ; prq to print it, followed by a question mark
20152               
20153               * ******************************************************************************
20154               *
20155               * Name: prq
20156               * Type: Subroutine
20157               * Category: Text
20158               * Summary: Print a text token followed by a question mark
20159               *
20160               * ------------------------------------------------------------------------------
20161               *
20162               * Arguments:
20163               *
20164               * A                   The text token to be printed
20165               *
20166               * ------------------------------------------------------------------------------
20167               *
20168               * Other entry points:
20169               *
20170               * prq+3               Print a question mark
20171               *
20172               * ******************************************************************************
20173               
20174               prq_:
20175 5D52 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     5D54 66DC     
20176 5D56 06A0  28        bl   @jsr                       ;
     5D58 8002     
20177               
20178 5D5A 0200  20        li   ra,('?')*256               ; LDA #'?'          ; Print a question mark and return from the
     5D5C 3F00     
20179 5D5E 0460  28        b    @TT27                      ; JMP TT27          ; subroutine using a tail call
     5D60 66DC     
20180               
20181               * ******************************************************************************
20182               *
20183               * Name: TT151
20184               * Type: Subroutine
20185               * Category: Market
20186               * Summary: Print the name, price and availability of a market item
20187               * Deep dive: Market item prices and availability
20188               * Galaxy and system seeds
20189               *
20190               * ------------------------------------------------------------------------------
20191               *
20192               * Arguments:
20193               *
20194               * A                   The number of the market item to print, 0-16 (see QQ23
20195               * for details of item numbers)
20196               *
20197               * ------------------------------------------------------------------------------
20198               *
20199               * Returns:
20200               *
20201               * QQ19+1              Byte #1 from the market prices table for this item
20202               *
20203               * QQ24                The item's price / 4
20204               *
20205               * QQ25                The item's availability
20206               *
20207               * ******************************************************************************
20208               
20209               TT151:
20210                      .pha                            ; PHA               ; Store the item number on the stack and in QQ19+4
     **** ****     > PHA
0001 5D62 D680  30        movb ra,*rsp
0002 5D64 060A  14        dec  rsp
                   < elite.a99
20211 5D66 D800  30        movb ra,@QQ19+4                 ; STA QQ19+4
     5D68 0083     
20212               
20213                      .asla                           ; ASL A             ; Store the item number * 4 in QQ19, so this will act as
     **** ****     > ASLA
0001 5D6A 0240  22        andi ra,>ff00
     5D6C FF00     
0002 5D6E 0A10  18        sla  ra,1
                   < elite.a99
20214                      .asla                           ; ASL A             ; an index into the market prices table at QQ23 for this
     **** ****     > ASLA
0001 5D70 0240  22        andi ra,>ff00
     5D72 FF00     
0002 5D74 0A10  18        sla  ra,1
                   < elite.a99
20215 5D76 D800  30        movb ra,@QQ19                   ; STA QQ19          ; item (as there are four bytes per item in the table)
     5D78 007F     
20216               
20217 5D7A 0200  20        li   ra,>01*256                 ; LDA #1            ; Move the text cursor to column 1, for the item's name
     5D7C 0100     
20218 5D7E D800  30        movb ra,@XC                     ; STA XC
     5D80 002C     
20219               
20220                      .pla                            ; PLA               ; Restore the item number
     **** ****     > PLA
0001 5D82 058A  14        inc  rsp
0002 5D84 D01A  26        movb *rsp,ra
                   < elite.a99
20221               
20222                      .adi (>d0*256)                  ; ADC #208          ; Print recursive token 48 + A, which will be in the
     **** ****     > ADI
0001 5D86 1701  14        jnc  !
0002 5D88 B004  18        ab   rone,ra
0003               !:
0004 5D8A 0220  22        ai   ra,(>D0*256)
     5D8C D000     
                   < elite.a99
20223 5D8E 0206  20        li   rtmp,TT27                  ; JSR TT27          ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     5D90 66DC     
20224 5D92 06A0  28        bl   @jsr                       ;
     5D94 8002     
20225                                                                          ; prints the item's name
20226               
20227 5D96 0200  20        li   ra,>0e*256                 ; LDA #14           ; Move the text cursor to column 14, for the price
     5D98 0E00     
20228 5D9A D800  30        movb ra,@XC                     ; STA XC
     5D9C 002C     
20229               
20230 5D9E D060  30        movb @QQ19,rx                   ; LDX QQ19          ; Fetch byte #1 from the market prices table (units and
     5DA0 007F     
20231 5DA2 D021  34        movb @QQ23+1(rx),ra             ; LDA QQ23+1,X      ; economic_factor) for this item and store in QQ19+1
     5DA4 8F23     
20232 5DA6 D800  30        movb ra,@QQ19+1                 ; STA QQ19+1
     5DA8 0080     
20233               
20234 5DAA D020  30        movb @QQ26,ra                   ; LDA QQ26          ; Fetch the random number for this system visit and
     5DAC 0346     
20235                      .and @QQ23+3(rx)                ; AND QQ23+3,X      ; AND with byte #3 from the market prices table (mask)
     **** ****     > AND
0001 5DAE D1A1  34        movb @QQ23+3(RX),rtmp
     5DB0 8F25     
0002 5DB2 0546  14        inv  rtmp
0003 5DB4 5006  18        szcb rtmp,ra
                   < elite.a99
20236                                                                          ; to give:
20237                                                                          ;
20238                                                                          ; A = random AND mask
20239               
20240                      .clc                            ; CLC               ; Add byte #0 from the market prices table (base_price),
     **** ****     > CLC
0001 5DB6 0A13  18        sla  rzero,1
                   < elite.a99
20241                      .adc @QQ23(rx),ra               ; ADC QQ23,X        ; so we now have:
     **** ****     > ADC
0001 5DB8 1701  14        jnc  !
0002 5DBA B004  18        ab   rone,ra
0003               !:
0004 5DBC B021  34        ab   @QQ23(RX),ra
     5DBE 8F22     
                   < elite.a99
20242 5DC0 D800  30        movb ra,@QQ24                   ; STA QQ24          ;
     5DC2 0F18     
20243                                                                          ; A = base_price + (random AND mask)
20244               
20245 5DC4 0206  20        li   rtmp,TT152                 ; JSR TT152         ; Call TT152 to print the item's unit ("t", "kg" or
     5DC6 5E4C     
20246 5DC8 06A0  28        bl   @jsr                       ;
     5DCA 8002     
20247                                                                          ; "g"), padded to a width of two characters
20248               
20249 5DCC 0206  20        li   rtmp,var_                  ; JSR var           ; Call var to set QQ19+3 = economy * |economic_factor|
     5DCE 5EF6     
20250 5DD0 06A0  28        bl   @jsr                       ;
     5DD2 8002     
20251                                                                          ; (and set the availability of alien items to 0)
20252               
20253 5DD4 D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Fetch the byte #1 that we stored above and jump to
     5DD6 0080     
20254 5DD8 1108  14        jlt  TT155                      ; BMI TT155         ; TT155 if it is negative (i.e. if the economic_factor
20255                                                                          ; is negative)
20256               
20257 5DDA D020  30        movb @QQ24,ra                   ; LDA QQ24          ; Set A = QQ24 + QQ19+3
     5DDC 0F18     
20258                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ;
     **** ****     > ADC
0001 5DDE 1701  14        jnc  !
0002 5DE0 B004  18        ab   rone,ra
0003               !:
0004 5DE2 B020  30        ab   @QQ19+3,ra
     5DE4 0082     
                   < elite.a99
20259                                                                          ; = base_price + (random AND mask)
20260                                                                          ; + (economy * |economic_factor|)
20261                                                                          ;
20262                                                                          ; which is the result we want, as the economic_factor
20263                                                                          ; is positive
20264               
20265 5DE6 0460  28        b    @TT156                     ; JMP TT156         ; Jump to TT156 to multiply the result by 4
     5DE8 5DF8     
20266               
20267               TT155:
20268 5DEA D020  30        movb @QQ24,ra                   ; LDA QQ24          ; Set A = QQ24 - QQ19+3
     5DEC 0F18     
20269                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 5DEE 0A15  18        sla  rmone,1
                   < elite.a99
20270                      .sbc @QQ19+3,ra                 ; SBC QQ19+3        ; = base_price + (random AND mask)
     **** ****     > SBC
0001 5DF0 1801  14        joc  !
0002 5DF2 7004  18        sb   rone,ra
0003               !:
0004 5DF4 7020  30        sb   @QQ19+3,ra
     5DF6 0082     
                   < elite.a99
20271                                                                          ; - (economy * |economic_factor|)
20272                                                                          ;
20273                                                                          ; which is the result we want, as economic_factor
20274                                                                          ; is negative
20275               
20276               TT156:
20277 5DF8 D800  30        movb ra,@QQ24                   ; STA QQ24          ; Store the result in QQ24 and P
     5DFA 0F18     
20278 5DFC D800  30        movb ra,@P                      ; STA P
     5DFE 001B     
20279               
20280 5E00 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 and call GC2 to calculate (Y X) = (A P) * 4,
     5E02 0000     
20281 5E04 0206  20        li   rtmp,GC2                   ; JSR GC2           ; which is the same as (Y X) = P * 4 because A = 0
     5E06 61FE     
20282 5E08 06A0  28        bl   @jsr                       ;
     5E0A 8002     
20283               
20284                      .sec                            ; SEC               ; We now have our final price, * 10, so we can call pr5
     **** ****     > SEC
0001 5E0C 0A15  18        sla  rmone,1
                   < elite.a99
20285 5E0E 0206  20        li   rtmp,pr5_                  ; JSR pr5           ; to print (Y X) to 5 digits, including a decimal
     5E10 5D46     
20286 5E12 06A0  28        bl   @jsr                       ;
     5E14 8002     
20287                                                                          ; point, as the C flag is set
20288               
20289 5E16 D0A0  30        movb @QQ19+4,ry                 ; LDY QQ19+4        ; We now move on to availability, so fetch the market
     5E18 0083     
20290                                                                          ; item number that we stored in QQ19+4 at the start
20291               
20292 5E1A 0200  20        li   ra,>05*256                 ; LDA #5            ; Set A to 5 so we can print the availability to 5
     5E1C 0500     
20293                                                                          ; digits (right-padded with spaces)
20294               
20295 5E1E D062  34        movb @AVL(ry),rx                ; LDX AVL,Y         ; Set X to the item's availability, which is given in
     5E20 0335     
20296                                                                          ; the AVL table
20297               
20298 5E22 D801  30        movb rx,@QQ25                   ; STX QQ25          ; Store the availability in QQ25
     5E24 0F19     
20299               
20300                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 5E26 0A13  18        sla  rzero,1
                   < elite.a99
20301               
20302 5E28 1306  14        jeq  TT172                      ; BEQ TT172         ; If none are available, jump to TT172 to print a tab
20303                                                                          ; and a "-"
20304               
20305 5E2A 0206  20        li   rtmp,pr2_+2                ; JSR pr2+2         ; Otherwise print the 8-bit number in X to 5 digits,
     5E2C 2FAE     
20306 5E2E 06A0  28        bl   @jsr                       ;
     5E30 8002     
20307                                                                          ; right-aligned with spaces. This works because we set
20308                                                                          ; A to 5 above, and we jump into the pr2 routine just
20309                                                                          ; after the first instruction, which would normally
20310                                                                          ; set the number of digits to 3
20311               
20312 5E32 0460  28        b    @TT152                     ; JMP TT152         ; Print the unit ("t", "kg" or "g") for the market item,
     5E34 5E4C     
20313                                                                          ; with a following space if required to make it two
20314                                                                          ; characters long, and return from the subroutine using
20315                                                                          ; a tail call
20316               
20317               TT172:
20318 5E36 D020  30        movb @XC,ra                     ; LDA XC            ; Move the text cursor in XC to the right by 4 columns,
     5E38 002C     
20319                      .adi (>04*256)                  ; ADC #4            ; so the cursor is where the last digit would be if we
     **** ****     > ADI
0001 5E3A 1701  14        jnc  !
0002 5E3C B004  18        ab   rone,ra
0003               !:
0004 5E3E 0220  22        ai   ra,(>04*256)
     5E40 0400     
                   < elite.a99
20320 5E42 D800  30        movb ra,@XC                     ; STA XC            ; were printing a 5-digit availability number
     5E44 002C     
20321               
20322 5E46 0200  20        li   ra,('-')*256               ; LDA #'-'          ; Print a "-" character by jumping to TT162+2, which
     5E48 2D00     
20323 5E4A 160D  14        jne  TT162+2                    ; BNE TT162+2       ; contains JMP TT27 (this BNE is effectively a JMP as A
20324                                                                          ; will never be zero), and return from the subroutine
20325                                                                          ; using a tail call
20326               
20327               * ******************************************************************************
20328               *
20329               * Name: TT152
20330               * Type: Subroutine
20331               * Category: Market
20332               * Summary: Print the unit ("t", "kg" or "g") for a market item
20333               *
20334               * ------------------------------------------------------------------------------
20335               *
20336               * Print the unit ("t", "kg" or "g") for the market item whose byte #1 from the
20337               * market prices table is in QQ19+1, right-padded with spaces to a width of two
20338               * characters (so that's "t ", "kg" or "g ").
20339               *
20340               * ******************************************************************************
20341               
20342               TT152:
20343 5E4C D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Fetch the economic_factor from QQ19+1
     5E4E 0080     
20344               
20345 5E50 0240  22        andi ra,>60*256                 ; AND #96           ; If bits 5 and 6 are both clear, jump to TT160 to
     5E52 6000     
20346 5E54 130B  14        jeq  TT160                      ; BEQ TT160         ; print "t" for tonne, followed by a space, and return
20347                                                                          ; from the subroutine using a tail call
20348               
20349 5E56 0280  22        ci   ra,>20*256                 ; CMP #32           ; If bit 5 is set, jump to TT161 to print "kg" for
     5E58 2000     
20350 5E5A 130F  14        jeq  TT161                      ; BEQ TT161         ; kilograms, and return from the subroutine using a tail
20351                                                                          ; call
20352               
20353 5E5C 0206  20        li   rtmp,TT16a                 ; JSR TT16a         ; Otherwise call TT16a to print "g" for grams, and fall
     5E5E 5E86     
20354 5E60 06A0  28        bl   @jsr                       ;
     5E62 8002     
20355                                                                          ; through into TT162 to print a space and return from
20356                                                                          ; the subroutine
20357               
20358               * ******************************************************************************
20359               *
20360               * Name: TT162
20361               * Type: Subroutine
20362               * Category: Text
20363               * Summary: Print a space
20364               *
20365               * ------------------------------------------------------------------------------
20366               *
20367               * Other entry points:
20368               *
20369               * TT162+2             Jump to TT27 to print the text token in A
20370               *
20371               * ******************************************************************************
20372               
20373               TT162:
20374 5E64 0200  20        li   ra,(' ')*256               ; LDA #' '          ; Load a space character into A
     5E66 2000     
20375               
20376 5E68 0460  28        b    @TT27                      ; JMP TT27          ; Print the text token in A and return from the
     5E6A 66DC     
20377                                                                          ; subroutine using a tail call
20378               
20379               * ******************************************************************************
20380               *
20381               * Name: TT160
20382               * Type: Subroutine
20383               * Category: Market
20384               * Summary: Print "t" (for tonne) and a space
20385               *
20386               * ******************************************************************************
20387               
20388               TT160:
20389 5E6C 0200  20        li   ra,('t')*256               ; LDA #'t'          ; Load a "t" character into A
     5E6E 7400     
20390               
20391 5E70 0206  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character, using TT216 so that it doesn't
     5E72 3172     
20392 5E74 06A0  28        bl   @jsr                       ;
     5E76 8002     
20393                                                                          ; change the character case
20394               
20395 5E78 17F5  14        jnc  TT162                      ; BCC TT162         ; Jump to TT162 to print a space and return from the
20396                                                                          ; subroutine using a tail call (this BCC is effectively
20397                                                                          ; a JMP as the C flag is cleared by TT26)
20398               
20399               * ******************************************************************************
20400               *
20401               * Name: TT161
20402               * Type: Subroutine
20403               * Category: Market
20404               * Summary: Print "kg" (for kilograms)
20405               *
20406               * ******************************************************************************
20407               
20408               TT161:
20409 5E7A 0200  20        li   ra,('k')*256               ; LDA #'k'          ; Load a "k" character into A
     5E7C 6B00     
20410               
20411 5E7E 0206  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character, using TT216 so that it doesn't
     5E80 3172     
20412 5E82 06A0  28        bl   @jsr                       ;
     5E84 8002     
20413                                                                          ; change the character case, and fall through into
20414                                                                          ; TT16a to print a "g" character
20415               
20416               * ******************************************************************************
20417               *
20418               * Name: TT16a
20419               * Type: Subroutine
20420               * Category: Market
20421               * Summary: Print "g" (for grams)
20422               *
20423               * ******************************************************************************
20424               
20425               TT16a:
20426 5E86 0200  20        li   ra,('g')*256               ; LDA #'g'          ; Load a "g" character into A
     5E88 6700     
20427               
20428 5E8A 0460  28        b    @TT26                      ; JMP TT26          ; Print the character, using TT216 so that it doesn't
     5E8C 3172     
20429                                                                          ; change the character case, and return from the
20430                                                                          ; subroutine using a tail call
20431               
20432               * ******************************************************************************
20433               *
20434               * Name: TT163
20435               * Type: Subroutine
20436               * Category: Market
20437               * Summary: Print the headers for the table of market prices
20438               *
20439               * ------------------------------------------------------------------------------
20440               *
20441               * Print the column headers for the prices table in the Buy Cargo and Market
20442               * Price screens.
20443               *
20444               * ******************************************************************************
20445               
20446               TT163:
20447 5E8E 0200  20        li   ra,>11*256                 ; LDA #17           ; Move the text cursor in XC to column 17
     5E90 1100     
20448 5E92 D800  30        movb ra,@XC                     ; STA XC
     5E94 002C     
20449               
20450 5E96 0200  20        li   ra,>ff*256                 ; LDA #255          ; Print recursive token 95 token ("UNIT  QUANTITY
     5E98 FF00     
20451 5E9A 16E5  14        jne  TT162+2                    ; BNE TT162+2       ; {crlf} PRODUCT   UNIT PRICE FOR SALE{crlf}{lf}") by
20452                                                                          ; jumping to TT162+2, which contains JMP TT27 (this BNE
20453                                                                          ; is effectively a JMP as A will never be zero), and
20454                                                                          ; return from the subroutine using a tail call
20455               
20456               * ******************************************************************************
20457               *
20458               * Name: TT167
20459               * Type: Subroutine
20460               * Category: Market
20461               * Summary: Show the Market Price screen (red key f7)
20462               *
20463               * ******************************************************************************
20464               
20465               TT167:
20466 5E9C 0200  20        li   ra,>10*256                 ; LDA #16           ; Clear the top part of the screen, draw a white border,
     5E9E 1000     
20467 5EA0 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 16 (Market
     5EA2 4B2A     
20468 5EA4 06A0  28        bl   @jsr                       ;
     5EA6 8002     
20469                                                                          ; Price screen)
20470               
20471 5EA8 0200  20        li   ra,>05*256                 ; LDA #5            ; Move the text cursor to column 5
     5EAA 0500     
20472 5EAC D800  30        movb ra,@XC                     ; STA XC
     5EAE 002C     
20473               
20474 5EB0 0200  20        li   ra,>a7*256                 ; LDA #167          ; Print recursive token 7 ("{current system name} MARKET
     5EB2 A700     
20475 5EB4 0206  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; PRICES") and draw a horizontal line at pixel row 19
     5EB6 25B0     
20476 5EB8 06A0  28        bl   @jsr                       ;
     5EBA 8002     
20477                                                                          ; to box in the title
20478               
20479 5EBC 0200  20        li   ra,>03*256                 ; LDA #3            ; Move the text cursor to row 3
     5EBE 0300     
20480 5EC0 D800  30        movb ra,@YC                     ; STA YC
     5EC2 002D     
20481               
20482 5EC4 0206  20        li   rtmp,TT163                 ; JSR TT163         ; Print the column headers for the prices table
     5EC6 5E8E     
20483 5EC8 06A0  28        bl   @jsr                       ;
     5ECA 8002     
20484               
20485 5ECC 0200  20        li   ra,>00*256                 ; LDA #0            ; We're going to loop through all the available market
     5ECE 0000     
20486 5ED0 D800  30        movb ra,@QQ29                   ; STA QQ29          ; items, so we set up a counter in QQ29 to denote the
     5ED2 0F1B     
20487                                                                          ; current item and start it at 0
20488               
20489               TT168:
20490 5ED4 0201  20        li   rx,>80*256                 ; LDX #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     5ED6 8000     
20491 5ED8 D801  30        movb rx,@QQ17                   ; STX QQ17          ; next letter in capitals
     5EDA 007E     
20492               
20493 5EDC 0206  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to print the item name, market price and
     5EDE 5D62     
20494 5EE0 06A0  28        bl   @jsr                       ;
     5EE2 8002     
20495                                                                          ; availability of the current item, and set QQ24 to the
20496                                                                          ; item's price / 4, QQ25 to the quantity available and
20497                                                                          ; QQ19+1 to byte #1 from the market prices table for
20498                                                                          ; this item
20499               
20500 5EE4 B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one row
20501               
20502 5EE6 B004  18        ab   rone,ra                    ; INC QQ29          ; Increment QQ29 to point to the next item
20503               
20504 5EE8 D020  30        movb @QQ29,ra                   ; LDA QQ29          ; If QQ29 >= 17 then jump to TT168 as we have done the
     5EEA 0F1B     
20505 5EEC 0280  22        ci   ra,>11*256                 ; CMP #17           ; last item
     5EEE 1100     
20506 5EF0 17F1  14        jnc  TT168                      ; BCC TT168
20507               
20508 5EF2 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     5EF4 800E     
20509               
20510               * ******************************************************************************
20511               *
20512               * Name: var
20513               * Type: Subroutine
20514               * Category: Market
20515               * Summary: Calculate QQ19+3 = economy * |economic_factor|
20516               *
20517               * ------------------------------------------------------------------------------
20518               *
20519               * Set QQ19+3 = economy * |economic_factor|, given byte #1 of the market prices
20520               * table for an item. Also sets the availability of alien items to 0.
20521               *
20522               * This routine forms part of the calculations for market item prices (TT151)
20523               * and availability (GVL).
20524               *
20525               * ------------------------------------------------------------------------------
20526               *
20527               * Arguments:
20528               *
20529               * QQ19+1              Byte #1 of the market prices table for this market item
20530               * (which contains the economic_factor in bits 0-5, and the
20531               * sign of the economic_factor in bit 7)
20532               *
20533               * ******************************************************************************
20534               
20535               var_:
20536 5EF6 D020  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Extract bits 0-5 from QQ19+1 into A, to get the
     5EF8 0080     
20537 5EFA 0240  22        andi ra,>1f*256                 ; AND #31           ; economic_factor without its sign, in other words:
     5EFC 1F00     
20538                                                                          ;
20539                                                                          ; A = |economic_factor|
20540               
20541 5EFE D0A0  30        movb @QQ28,ry                   ; LDY QQ28          ; Set Y to the economy byte of the current system
     5F00 0F1A     
20542               
20543 5F02 D800  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Store A in QQ19+2
     5F04 0081     
20544               
20545                      .clc                            ; CLC               ; Clear the C flag so we can do additions below
     **** ****     > CLC
0001 5F06 0A13  18        sla  rzero,1
                   < elite.a99
20546               
20547 5F08 0200  20        li   ra,>00*256                 ; LDA #0            ; Set AVL+16 (availability of alien items) to 0,
     5F0A 0000     
20548 5F0C D800  30        movb ra,@AVL+16                 ; STA AVL+16        ; setting A to 0 in the process
     5F0E 0345     
20549               
20550               TT153:
20551                                                                          ; We now do the multiplication by doing a series of
20552                                                                          ; additions in a loop, building the result in A. Each
20553                                                                          ; loop adds QQ19+2 (|economic_factor|) to A, and it
20554                                                                          ; loops the number of times given by the economy byte;
20555                                                                          ; in other words, because A starts at 0, this sets:
20556                                                                          ;
20557                                                                          ; A = economy * |economic_factor|
20558 5F10 7084  18        sb   rone,ry                    ; DEY               ; Decrement the economy in Y, exiting the loop when it
20559 5F12 1106  14        jlt  TT154                      ; BMI TT154         ; becomes negative
20560               
20561                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; Add QQ19+2 to A
     **** ****     > ADC
0001 5F14 1701  14        jnc  !
0002 5F16 B004  18        ab   rone,ra
0003               !:
0004 5F18 B020  30        ab   @QQ19+2,ra
     5F1A 0081     
                   < elite.a99
20562               
20563 5F1C 0460  28        b    @TT153                     ; JMP TT153         ; Loop back to TT153 to do another addition
     5F1E 5F10     
20564               
20565               TT154:
20566 5F20 D800  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; Store the result in QQ19+3
     5F22 0082     
20567               
20568 5F24 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     5F26 800E     
20569               
20570               * ******************************************************************************
20571               *
20572               * Name: hyp1
20573               * Type: Subroutine
20574               * Category: Universe
20575               * Summary: Process a jump to the system closest to (QQ9, QQ10)
20576               *
20577               * ------------------------------------------------------------------------------
20578               *
20579               * Do a hyperspace jump to the system closest to galactic coordinates
20580               * (QQ9, QQ10), and set up the current system's state to those of the new system.
20581               *
20582               * ------------------------------------------------------------------------------
20583               *
20584               * Returns:
20585               *
20586               * (QQ0, QQ1)          The galactic coordinates of the new system
20587               *
20588               * QQ2 to QQ2+6        The seeds of the new system
20589               *
20590               * EV                  Set to 0
20591               *
20592               * QQ28                The new system's economy
20593               *
20594               * tek                 The new system's tech level
20595               *
20596               * gov                 The new system's government
20597               *
20598               * ------------------------------------------------------------------------------
20599               *
20600               * Other entry points:
20601               *
20602               * hyp1+3              Jump straight to the system at (QQ9, QQ10) without
20603               * first calculating which system is closest. We do this
20604               * if we already know that (QQ9, QQ10) points to a system
20605               *
20606               * ******************************************************************************
20607               
20608               hyp1_:
20609 5F28 0206  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     5F2A 5AB8     
20610 5F2C 06A0  28        bl   @jsr                       ;
     5F2E 8002     
20611                                                                          ; (QQ9, QQ10)
20612               
20613 5F30 0206  20        li   rtmp,jmp_                  ; JSR jmp           ; Set the current system to the selected system
     5F32 5D22     
20614 5F34 06A0  28        bl   @jsr                       ;
     5F36 8002     
20615               
20616 5F38 0201  20        li   rx,>05*256                 ; LDX #5            ; We now want to copy the seeds for the selected system
     5F3A 0500     
20617                                                                          ; in QQ15 into QQ2, where we store the seeds for the
20618                                                                          ; current system, so set up a counter in X for copying
20619                                                                          ; 6 bytes (for three 16-bit seeds)
20620               
20621               TT112:
20622 5F3C D021  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy the X-th byte in QQ15 to the X-th byte in QQ2, to
     5F3E 0078     
20623 5F40 D840  38        movb ra,@QQ2(rx)                ; STA QQ2,X         ; update the selected system to the new one. Note that
     5F42 0F22     
20624                                                                          ; this approach has a minor bug associated with it: if
20625                                                                          ; your hyperspace counter hits 0 just as you're docking,
20626                                                                          ; then you will magically appear in the station in your
20627                                                                          ; hyperspace destination, without having to go to the
20628                                                                          ; effort of actually flying there. This bug was fixed in
20629                                                                          ; later versions by saving the destination seeds in a
20630                                                                          ; separate location called safehouse, and using those
20631                                                                          ; instead... but that isn't the case in this version
20632               
20633 5F44 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
20634               
20635 5F46 15FA  14        jgt  TT112                      ; BPL TT112         ; Loop back to TT112 if we still have more bytes to
20636                                                                          ; copy
20637               
20638 5F48 B044  18        ab   rone,rx                    ; INX               ; Set X = 0 (as we ended the above loop with X = &FF)
20639               
20640 5F4A D801  30        movb rx,@EV                     ; STX EV            ; Set EV, the extra vessels spawning counter, to 0, as
     5F4C 0D63     
20641                                                                          ; we are entering a new system with no extra vessels
20642                                                                          ; spawned
20643               
20644 5F4E D020  30        movb @QQ3,ra                    ; LDA QQ3           ; Set the current system's economy in QQ28 to the
     5F50 0F28     
20645 5F52 D800  30        movb ra,@QQ28                   ; STA QQ28          ; selected system's economy from QQ3
     5F54 0F1A     
20646               
20647 5F56 D020  30        movb @QQ5,ra                    ; LDA QQ5           ; Set the current system's tech level in tek to the
     5F58 0F2A     
20648 5F5A D800  30        movb ra,@tek_                   ; STA tek           ; selected system's economy from QQ5
     5F5C 0F1D     
20649               
20650 5F5E D020  30        movb @QQ4,ra                    ; LDA QQ4           ; Set the current system's government in gov to the
     5F60 0F29     
20651 5F62 D800  30        movb ra,@gov_                   ; STA gov           ; selected system's government from QQ4
     5F64 0F1C     
20652               
20653 5F66 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     5F68 800E     
20654               
20655               * ******************************************************************************
20656               *
20657               * Name: GVL
20658               * Type: Subroutine
20659               * Category: Universe
20660               * Summary: Calculate the availability of market items
20661               * Deep dive: Market item prices and availability
20662               * Galaxy and system seeds
20663               *
20664               * ------------------------------------------------------------------------------
20665               *
20666               * Calculate the availability for each market item and store it in AVL. This is
20667               * called on arrival in a new system.
20668               *
20669               * ------------------------------------------------------------------------------
20670               *
20671               * Other entry points:
20672               *
20673               * hyR                 Contains an RTS
20674               *
20675               * ******************************************************************************
20676               
20677               GVL:
20678 5F6A 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     5F6C 8070     
20679 5F6E 06A0  28        bl   @jsr                       ;
     5F70 8002     
20680               
20681 5F72 D800  30        movb ra,@QQ26                   ; STA QQ26          ; Set QQ26 to the random byte that's used in the market
     5F74 0346     
20682                                                                          ; calculations
20683               
20684 5F76 0201  20        li   rx,>00*256                 ; LDX #0            ; We are now going to loop through the market item
     5F78 0000     
20685 5F7A D801  30        movb rx,@XX4                    ; STX XX4           ; availability table in AVL, so set a counter in XX4
     5F7C 00A7     
20686                                                                          ; (and X) for the market item number, starting with 0
20687               
20688               hy9_:
20689 5F7E D021  34        movb @QQ23+1(rx),ra             ; LDA QQ23+1,X      ; Fetch byte #1 from the market prices table (units and
     5F80 8F23     
20690 5F82 D800  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; economic_factor) for item number X and store it in
     5F84 0080     
20691                                                                          ; QQ19+1
20692               
20693 5F86 0206  20        li   rtmp,var_                  ; JSR var           ; Call var to set QQ19+3 = economy * |economic_factor|
     5F88 5EF6     
20694 5F8A 06A0  28        bl   @jsr                       ;
     5F8C 8002     
20695                                                                          ; (and set the availability of alien items to 0)
20696               
20697 5F8E D021  34        movb @QQ23+3(rx),ra             ; LDA QQ23+3,X      ; Fetch byte #3 from the market prices table (mask) and
     5F90 8F25     
20698                      .and @QQ26                      ; AND QQ26          ; AND with the random number for this system visit
     **** ****     > AND
0001 5F92 D1A0  30        movb @QQ26,rtmp
     5F94 0346     
0002 5F96 0546  14        inv  rtmp
0003 5F98 5006  18        szcb rtmp,ra
                   < elite.a99
20699                                                                          ; to give:
20700                                                                          ;
20701                                                                          ; A = random AND mask
20702               
20703                      .clc                            ; CLC               ; Add byte #2 from the market prices table
     **** ****     > CLC
0001 5F9A 0A13  18        sla  rzero,1
                   < elite.a99
20704                      .adc @QQ23+2(rx),ra             ; ADC QQ23+2,X      ; (base_quantity) so we now have:
     **** ****     > ADC
0001 5F9C 1701  14        jnc  !
0002 5F9E B004  18        ab   rone,ra
0003               !:
0004 5FA0 B021  34        ab   @QQ23+2(RX),ra
     5FA2 8F24     
                   < elite.a99
20705                                                                          ;
20706                                                                          ; A = base_quantity + (random AND mask)
20707               
20708 5FA4 D0A0  30        movb @QQ19+1,ry                 ; LDY QQ19+1        ; Fetch the byte #1 that we stored above and jump to
     5FA6 0080     
20709 5FA8 1107  14        jlt  TT157                      ; BMI TT157         ; TT157 if it is negative (i.e. if the economic_factor
20710                                                                          ; is negative)
20711               
20712                      .sec                            ; SEC               ; Set A = A - QQ19+3
     **** ****     > SEC
0001 5FAA 0A15  18        sla  rmone,1
                   < elite.a99
20713                      .sbc @QQ19+3,ra                 ; SBC QQ19+3        ;
     **** ****     > SBC
0001 5FAC 1801  14        joc  !
0002 5FAE 7004  18        sb   rone,ra
0003               !:
0004 5FB0 7020  30        sb   @QQ19+3,ra
     5FB2 0082     
                   < elite.a99
20714                                                                          ; = base_quantity + (random AND mask)
20715                                                                          ; - (economy * |economic_factor|)
20716                                                                          ;
20717                                                                          ; which is the result we want, as the economic_factor
20718                                                                          ; is positive
20719               
20720 5FB4 0460  28        b    @TT158                     ; JMP TT158         ; Jump to TT158 to skip TT157
     5FB6 5FC2     
20721               
20722               TT157:
20723                      .clc                            ; CLC               ; Set A = A + QQ19+3
     **** ****     > CLC
0001 5FB8 0A13  18        sla  rzero,1
                   < elite.a99
20724                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ;
     **** ****     > ADC
0001 5FBA 1701  14        jnc  !
0002 5FBC B004  18        ab   rone,ra
0003               !:
0004 5FBE B020  30        ab   @QQ19+3,ra
     5FC0 0082     
                   < elite.a99
20725                                                                          ; = base_quantity + (random AND mask)
20726                                                                          ; + (economy * |economic_factor|)
20727                                                                          ;
20728                                                                          ; which is the result we want, as the economic_factor
20729                                                                          ; is negative
20730               
20731               TT158:
20732 5FC2 1502  14        jgt  TT159                      ; BPL TT159         ; If A < 0, then set A = 0, so we don't have negative
20733 5FC4 0200  20        li   ra,>00*256                 ; LDA #0            ; availability
     5FC6 0000     
20734               
20735               TT159:
20736 5FC8 D0A0  30        movb @XX4,ry                    ; LDY XX4           ; Fetch the counter (the market item number) into Y
     5FCA 00A7     
20737               
20738 5FCC 0240  22        andi ra,>3f*256                 ; AND #%00111111    ; Take bits 0-5 of A, i.e. A mod 64, and store this as
     5FCE 3F00     
20739 5FD0 D880  38        movb ra,@AVL(ry)                ; STA AVL,Y         ; this item's availability in the Y=th byte of AVL, so
     5FD2 0335     
20740                                                                          ; each item has a maximum availability of 63t
20741               
20742 5FD4 B084  18        ab   rone,ry                    ; INY               ; Increment the counter into XX44, Y and A
20743 5FD6 D002  18        movb ry,ra                      ; TYA
20744 5FD8 D800  30        movb ra,@XX4                    ; STA XX4
     5FDA 00A7     
20745               
20746                      .asla                           ; ASL A             ; Set X = counter * 4, so that X points to the next
     **** ****     > ASLA
0001 5FDC 0240  22        andi ra,>ff00
     5FDE FF00     
0002 5FE0 0A10  18        sla  ra,1
                   < elite.a99
20747                      .asla                           ; ASL A             ; item's entry in the four-byte market prices table,
     **** ****     > ASLA
0001 5FE2 0240  22        andi ra,>ff00
     5FE4 FF00     
0002 5FE6 0A10  18        sla  ra,1
                   < elite.a99
20748 5FE8 D040  18        movb ra,rx                      ; TAX               ; ready for the next loop
20749               
20750 5FEA 0280  22        ci   ra,>3f*256                 ; CMP #63           ; If A < 63, jump back up to hy9 to set the availability
     5FEC 3F00     
20751 5FEE 17C7  14        jnc  hy9_                       ; BCC hy9           ; for the next market item
20752               
20753               hyR:
20754 5FF0 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     5FF2 800E     
20755               
20756               * ******************************************************************************
20757               *
20758               * Name: GTHG
20759               * Type: Subroutine
20760               * Category: Universe
20761               * Summary: Spawn a Thargoid ship and a Thargon companion
20762               * Deep dive: Fixing ship positions
20763               *
20764               * ******************************************************************************
20765               
20766               GTHG:
20767 5FF4 0206  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK
     5FF6 8026     
20768 5FF8 06A0  28        bl   @jsr                       ;
     5FFA 8002     
20769                                                                          ;
20770                                                                          ; Note that because Ze uses the value of X returned by
20771                                                                          ; DORND, and X contains the value of A returned by the
20772                                                                          ; previous call to DORND, this does not set the new ship
20773                                                                          ; to a totally random location. See the deep dive on
20774                                                                          ; "Fixing ship positions" for details
20775               
20776 5FFC 0200  20        li   ra,>ff*256                 ; LDA #%11111111    ; Set the AI flag in byte #32 so that the ship has AI,
     5FFE FF00     
20777 6000 D800  30        movb ra,@INWK+32                ; STA INWK+32       ; is extremely and aggressively hostile, and has E.C.M.
     6002 0073     
20778               
20779 6004 0200  20        li   ra,(THG)*256               ; LDA #THG          ; Call NWSHP to add a new Thargoid ship to our local
     6006 0600     
20780 6008 0206  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; bubble of universe
     600A 6F6E     
20781 600C 06A0  28        bl   @jsr                       ;
     600E 8002     
20782               
20783 6010 0200  20        li   ra,(TGL)*256               ; LDA #TGL          ; Call NWSHP to add a new Thargon ship to our local
     6012 0C00     
20784 6014 0460  28        b    @NWSHP                     ; JMP NWSHP         ; bubble of universe, and return from the subroutine
     6016 6F6E     
20785                                                                          ; using a tail call
20786               
20787               * ******************************************************************************
20788               *
20789               * Name: MJP
20790               * Type: Subroutine
20791               * Category: Flight
20792               * Summary: Process a mis-jump into witchspace
20793               *
20794               * ------------------------------------------------------------------------------
20795               *
20796               * Process a mis-jump into witchspace (which happens very rarely). Witchspace has
20797               * a strange, almost dust-free aspect to it, and it is populated by hostile
20798               * Thargoids. Using our escape pod will be fatal, and our position on the
20799               * galactic chart is in-between systems. It is a scary place...
20800               *
20801               * There is a 0.78% chance that this routine is called from TT18 instead of doing
20802               * a normal hyperspace, or we can manually trigger a mis-jump by holding down
20803               * CTRL after first enabling the "author display" configuration option ("X") when
20804               * paused.
20805               *
20806               * ------------------------------------------------------------------------------
20807               *
20808               * Other entry points:
20809               *
20810               * ptg                 Called when the user manually forces a mis-jump
20811               *
20812               * ******************************************************************************
20813               
20814               ptg_:
20815                      .lsr @COK                       ; LSR COK           ; Set bit 0 of the competition flags in COK, so that the
     **** ****     > LSR
0001 6018 D1A0  30        movb @COK,rtmp
     601A 030E     
0002 601C 0916  18        srl  rtmp,1
0003 601E D806  30        movb rtmp,@COK
     6020 030E     
                   < elite.a99
20816                      .sec                            ; SEC               ; competition code will include the fact that we have
     **** ****     > SEC
0001 6022 0A15  18        sla  rmone,1
                   < elite.a99
20817 6024 0208  20        li   rarg1,COK                  ; ROL COK           ; manually forced a mis-jump into witchspace
     6026 030E     
20818 6028 06A0  28        bl   @rol                       ;
     602A 8028     
20819               
20820               MJP:
20821               * LDA #1                 \ This instruction is commented out in the original
20822                                                                          ; source - it is not required as a call to TT66-2 sets
20823                                                                          ; A to 1 for us. This is presumably an example of the
20824                                                                          ; authors saving a couple of bytes by calling TT66-2
20825                                                                          ; instead of TT66, while leaving the original LDA
20826                                                                          ; instruction in place
20827 602C 0206  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     602E 4B28     
20828 6030 06A0  28        bl   @jsr                       ;
     6032 8002     
20829                                                                          ; and set the current view type in QQ11 to 1
20830               
20831 6034 0206  20        li   rtmp,LL164                 ; JSR LL164         ; Call LL164 to show the hyperspace tunnel and make the
     6036 3E3C     
20832 6038 06A0  28        bl   @jsr                       ;
     603A 8002     
20833                                                                          ; hyperspace sound for a second time (as we already
20834                                                                          ; called LL164 in TT18)
20835               
20836 603C 0206  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces, as
     603E 7F26     
20837 6040 06A0  28        bl   @jsr                       ;
     6042 8002     
20838                                                                          ; well as setting Y to &FF
20839               
20840 6044 D802  30        movb ry,@MJ                     ; STY MJ            ; Set the mis-jump flag in MJ to &FF, to indicate that
     6046 0D5C     
20841                                                                          ; we are now in witchspace
20842               
20843               MJP1:
20844 6048 0206  20        li   rtmp,GTHG                  ; JSR GTHG          ; Call GTHG to spawn a Thargoid ship and a Thargon
     604A 5FF4     
20845 604C 06A0  28        bl   @jsr                       ;
     604E 8002     
20846                                                                          ; companion
20847               
20848 6050 0200  20        li   ra,>03*256                 ; LDA #3            ; Fetch the number of Thargoid ships from MANY+THG, and
     6052 0300     
20849 6054 9020  30        cb   @MANY+THG,ra               ; CMP MANY+THG      ; if it is less than or equal to 3, loop back to MJP1 to
     6056 0D53     
20850 6058 18F7  14        joc  MJP1                       ; BCS MJP1          ; spawn another one, until we have four Thargoids
20851               
20852 605A D800  30        movb ra,@NOSTM                  ; STA NOSTM         ; Set NOSTM (the maximum number of stardust particles)
     605C 0F33     
20853                                                                          ; to 3, so there are fewer bits of stardust in
20854                                                                          ; witchspace (normal space has a maximum of 18)
20855               
20856 605E 0201  20        li   rx,>00*256                 ; LDX #0            ; Initialise the front space view
     6060 0000     
20857 6062 0206  20        li   rtmp,LOOK1                 ; JSR LOOK1
     6064 4AC4     
20858 6066 06A0  28        bl   @jsr                       ;
     6068 8002     
20859               
20860 606A D020  30        movb @QQ1,ra                    ; LDA QQ1           ; Fetch the current system's galactic y-coordinate in
     606C 0302     
20861                      .eoi (>1f*256)                  ; EOR #%00011111    ; QQ1 and flip bits 0-5, so we end up somewhere in the
     **** ****     > EOI
0001 606E 0206  20        li   rtmp,(>1F*256)
     6070 1F00     
0002 6072 2806  18        xor  rtmp,ra
                   < elite.a99
20862 6074 D800  30        movb ra,@QQ1                    ; STA QQ1           ; vicinity of our original destination, but above or
     6076 0302     
20863                                                                          ; below it in the galactic chart
20864               
20865 6078 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     607A 800E     
20866               
20867               * ******************************************************************************
20868               *
20869               * Name: TT18
20870               * Type: Subroutine
20871               * Category: Flight
20872               * Summary: Try to initiate a jump into hyperspace
20873               *
20874               * ------------------------------------------------------------------------------
20875               *
20876               * Try to go through hyperspace. Called from TT102 in the main loop when the
20877               * hyperspace countdown has finished.
20878               *
20879               * ******************************************************************************
20880               
20881               TT18:
20882 607C D020  30        movb @QQ14,ra                   ; LDA QQ14          ; Subtract the distance to the selected system (in QQ8)
     607E 030D     
20883                      .sec                            ; SEC               ; from the amount of fuel in our tank (in QQ14) into A
     **** ****     > SEC
0001 6080 0A15  18        sla  rmone,1
                   < elite.a99
20884                      .sbc @QQ8,ra                    ; SBC QQ8
     **** ****     > SBC
0001 6082 1801  14        joc  !
0002 6084 7004  18        sb   rone,ra
0003               !:
0004 6086 7020  30        sb   @QQ8,ra
     6088 0F2F     
                   < elite.a99
20885               
20886 608A D800  30        movb ra,@QQ14                   ; STA QQ14          ; Store the updated fuel amount in QQ14
     608C 030D     
20887               
20888 608E D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is not a space view, jump to ee5
     6090 0096     
20889 6092 1608  14        jne  ee5_                       ; BNE ee5           ; to skip the following
20890               
20891 6094 0206  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     6096 4B2A     
20892 6098 06A0  28        bl   @jsr                       ;
     609A 8002     
20893                                                                          ; and set the current view type in QQ11 to 0 (space
20894                                                                          ; view)
20895               
20896 609C 0206  20        li   rtmp,LL164                 ; JSR LL164         ; Call LL164 to show the hyperspace tunnel and make the
     609E 3E3C     
20897 60A0 06A0  28        bl   @jsr                       ;
     60A2 8002     
20898                                                                          ; hyperspace sound
20899               
20900               ee5_:
20901 60A4 0206  20        li   rtmp,CTRL                  ; JSR CTRL          ; Scan the keyboard to see if CTRL is currently pressed,
     60A6 8C18     
20902 60A8 06A0  28        bl   @jsr                       ;
     60AA 8002     
20903                                                                          ; returning a negative value in A if it is
20904               
20905                      .and @PATG                      ; AND PATG          ; If the game is configured to show the author's names
     **** ****     > AND
0001 60AC D1A0  30        movb @PATG,rtmp
     60AE 0F4C     
0002 60B0 0546  14        inv  rtmp
0003 60B2 5006  18        szcb rtmp,ra
                   < elite.a99
20906                                                                          ; on the start-up screen, then PATG will contain &FF,
20907                                                                          ; otherwise it will be 0
20908               
20909 60B4 11B1  14        jlt  ptg_                       ; BMI ptg           ; By now, A will be negative if we are holding down CTRL
20910                                                                          ; and author names are configured, which is what we have
20911                                                                          ; to do in order to trigger a manual mis-jump, so jump
20912                                                                          ; to ptg to do a mis-jump (ptg not only mis-jumps, but
20913                                                                          ; updates the competition flags, so Acornsoft could tell
20914                                                                          ; from the competition code whether this feature had
20915                                                                          ; been used)
20916               
20917 60B6 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     60B8 8070     
20918 60BA 06A0  28        bl   @jsr                       ;
     60BC 8002     
20919               
20920 60BE 0280  22        ci   ra,>fd*256                 ; CMP #253          ; If A >= 253 (0.78% chance) then jump to MJP to trigger
     60C0 FD00     
20921 60C2 18B4  14        joc  MJP                        ; BCS MJP           ; a mis-jump into witchspace
20922               
20923               * JSR TT111              \ This instruction is commented out in the original
20924                                                                          ; source. It finds the closest system to coordinates
20925                                                                          ; (QQ9, QQ10), but we don't need to do this as the
20926                                                                          ; crosshairs will already be on a system by this point
20927               
20928 60C4 0206  20        li   rtmp,hyp1_+3               ; JSR hyp1+3        ; Jump straight to the system at (QQ9, QQ10) without
     60C6 5F2B     
20929 60C8 06A0  28        bl   @jsr                       ;
     60CA 8002     
20930                                                                          ; first calculating which system is closest
20931               
20932 60CC 0206  20        li   rtmp,GVL                   ; JSR GVL           ; Calculate the availability for each market item in the
     60CE 5F6A     
20933 60D0 06A0  28        bl   @jsr                       ;
     60D2 8002     
20934                                                                          ; new system
20935               
20936 60D4 0206  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     60D6 7F26     
20937 60D8 06A0  28        bl   @jsr                       ;
     60DA 8002     
20938               
20939 60DC 0206  20        li   rtmp,SOLAR                 ; JSR SOLAR         ; Halve our legal status, update the missile indicators,
     60DE 6B66     
20940 60E0 06A0  28        bl   @jsr                       ;
     60E2 8002     
20941                                                                          ; and set up data blocks and slots for the planet and
20942                                                                          ; sun
20943               
20944 60E4 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view in QQ11 is not a space view (0) or
     60E6 0096     
20945 60E8 0240  22        andi ra,>3f*256                 ; AND #%00111111    ; one of the charts (64 or 128), return from the
     60EA 3F00     
20946 60EC 1681  14        jne  hyR                        ; BNE hyR           ; subroutine (as hyR contains an RTS)
20947               
20948 60EE 0206  20        li   rtmp,TTX66                 ; JSR TTX66         ; Otherwise clear the screen and draw a white border
     60F0 4B2E     
20949 60F2 06A0  28        bl   @jsr                       ;
     60F4 8002     
20950               
20951 60F6 D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is one of the charts, jump to
     60F8 0096     
20952 60FA 1630  14        jne  TT114                      ; BNE TT114         ; TT114 (from which we jump to the correct routine to
20953                                                                          ; display the chart)
20954               
20955 60FC B004  18        ab   rone,ra                    ; INC QQ11          ; This is a space view, so increment QQ11 to 1
20956               
20957                                                                          ; Fall through into TT110 to show the front space view
20958               
20959               * ******************************************************************************
20960               *
20961               * Name: TT110
20962               * Type: Subroutine
20963               * Category: Flight
20964               * Summary: Launch from a station or show the front space view
20965               *
20966               * ------------------------------------------------------------------------------
20967               *
20968               * Launch the ship (if we are docked), or show the front space view (if we are
20969               * already in space).
20970               *
20971               * Called when red key f0 is pressed while docked (launch), after we arrive in a
20972               * new galaxy, or after a hyperspace if the current view is a space view.
20973               *
20974               * ******************************************************************************
20975               
20976               TT110:
20977 60FE D060  30        movb @QQ12,rx                   ; LDX QQ12          ; If we are not docked (QQ12 = 0) then jump to NLUNCH
     6100 009F     
20978 6102 1326  14        jeq  NLUNCH                     ; BEQ NLUNCH        ; to skip the launch tunnel and setup process
20979               
20980 6104 0206  20        li   rtmp,LAUN                  ; JSR LAUN          ; Show the space station launch tunnel
     6106 3E62     
20981 6108 06A0  28        bl   @jsr                       ;
     610A 8002     
20982               
20983 610C 0206  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     610E 7F26     
20984 6110 06A0  28        bl   @jsr                       ;
     6112 8002     
20985               
20986 6114 0206  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     6116 5AB8     
20987 6118 06A0  28        bl   @jsr                       ;
     611A 8002     
20988                                                                          ; (QQ9, QQ10)
20989               
20990 611C B004  18        ab   rone,ra                    ; INC INWK+8        ; Increment z_sign ready for the call to SOS, so the
20991                                                                          ; planet appears at a z_sign of 1 in front of us when
20992                                                                          ; we launch
20993               
20994 611E 0206  20        li   rtmp,SOS1                  ; JSR SOS1          ; Call SOS1 to set up the planet's data block and add it
     6120 6B42     
20995 6122 06A0  28        bl   @jsr                       ;
     6124 8002     
20996                                                                          ; to FRIN, where it will get put in the first slot as
20997                                                                          ; it's the first one to be added to our local bubble of
20998                                                                          ; universe following the call to RES2 above
20999               
21000 6126 0200  20        li   ra,>80*256                 ; LDA #128          ; For the space station, set z_sign to &80, so it's
     6128 8000     
21001 612A D800  30        movb ra,@INWK+8                 ; STA INWK+8        ; behind us (&80 is negative)
     612C 005B     
21002               
21003 612E B004  18        ab   rone,ra                    ; INC INWK+7        ; And increment z_hi, so it's only just behind us
21004               
21005 6130 0206  20        li   rtmp,NWSPS                 ; JSR NWSPS         ; Add a new space station to our local bubble of
     6132 6F1E     
21006 6134 06A0  28        bl   @jsr                       ;
     6136 8002     
21007                                                                          ; universe
21008               
21009 6138 0200  20        li   ra,>0c*256                 ; LDA #12           ; Set our launch speed in DELTA to 12
     613A 0C00     
21010 613C D800  30        movb ra,@DELTA                  ; STA DELTA
     613E 008C     
21011               
21012 6140 0206  20        li   rtmp,BAD                   ; JSR BAD           ; Call BAD to work out how much illegal contraband we
     6142 842A     
21013 6144 06A0  28        bl   @jsr                       ;
     6146 8002     
21014                                                                          ; are carrying in our hold (A is up to 40 for a
21015                                                                          ; standard hold crammed with contraband, up to 70 for
21016                                                                          ; an extended cargo hold full of narcotics and slaves)
21017               
21018 6148 F020  30        socb @FIST,ra                   ; ORA FIST          ; OR the value in A with our legal status in FIST to
     614A 0334     
21019                                                                          ; get a new value that is at least as high as both
21020                                                                          ; values, to reflect the fact that launching with a
21021                                                                          ; hold full of contraband can only make matters worse
21022               
21023 614C D800  30        movb ra,@FIST                   ; STA FIST          ; Update our legal status with the new value
     614E 0334     
21024               
21025               NLUNCH:
21026 6150 0201  20        li   rx,>00*256                 ; LDX #0            ; Set QQ12 to 0 to indicate we are not docked
     6152 0000     
21027 6154 D801  30        movb rx,@QQ12                   ; STX QQ12
     6156 009F     
21028               
21029 6158 0460  28        b    @LOOK1                     ; JMP LOOK1         ; Jump to LOOK1 to switch to the front view (X = 0),
     615A 4AC4     
21030                                                                          ; returning from the subroutine using a tail call
21031               
21032               * ******************************************************************************
21033               *
21034               * Name: TT114
21035               * Type: Subroutine
21036               * Category: Charts
21037               * Summary: Display either the Long-range or Short-range Chart
21038               *
21039               * ------------------------------------------------------------------------------
21040               *
21041               * Display either the Long-range or Short-range Chart, depending on the current
21042               * view setting. Called from TT18 once we know the current view is one of the
21043               * charts.
21044               *
21045               * ------------------------------------------------------------------------------
21046               *
21047               * Arguments:
21048               *
21049               * A                   The current view, loaded from QQ11
21050               *
21051               * ******************************************************************************
21052               
21053               TT114:
21054 615C 1102  14        jlt  TT115                      ; BMI TT115         ; If bit 7 of the current view is set (i.e. the view is
21055                                                                          ; the Short-range Chart, 128), skip to TT115 below to
21056                                                                          ; jump to TT23 to display the chart
21057               
21058 615E 0460  28        b    @TT22                      ; JMP TT22          ; Otherwise the current view is the Long-range Chart, so
     6160 5272     
21059                                                                          ; jump to TT22 to display it
21060               
21061               TT115:
21062 6162 0460  28        b    @TT23                      ; JMP TT23          ; Jump to TT23 to display the Short-range Chart
     6164 592A     
21063               
21064               * ******************************************************************************
21065               *
21066               * Name: LCASH
21067               * Type: Subroutine
21068               * Category: Maths (Arithmetic)
21069               * Summary: Subtract an amount of cash from the cash pot
21070               *
21071               * ------------------------------------------------------------------------------
21072               *
21073               * Subtract (Y X) cash from the cash pot in CASH, but only if there is enough
21074               * cash in the pot. As CASH is a four-byte number, this calculates:
21075               *
21076               * CASH(0 1 2 3) = CASH(0 1 2 3) - (0 0 Y X)
21077               *
21078               * ------------------------------------------------------------------------------
21079               *
21080               * Returns:
21081               *
21082               * C flag              If set, there was enough cash to do the subtraction
21083               *
21084               * If clear, there was not enough cash to do the
21085               * subtraction
21086               *
21087               * ******************************************************************************
21088               
21089               LCASH:
21090 6166 D801  30        movb rx,@T1                     ; STX T1            ; Subtract the least significant bytes:
     6168 0006     
21091 616A D020  30        movb @CASH+3,ra                 ; LDA CASH+3        ;
     616C 030C     
21092                      .sec                            ; SEC               ; CASH+3 = CASH+3 - X
     **** ****     > SEC
0001 616E 0A15  18        sla  rmone,1
                   < elite.a99
21093                      .sbc @T1,ra                     ; SBC T1
     **** ****     > SBC
0001 6170 1801  14        joc  !
0002 6172 7004  18        sb   rone,ra
0003               !:
0004 6174 7020  30        sb   @T1,ra
     6176 0006     
                   < elite.a99
21094 6178 D800  30        movb ra,@CASH+3                 ; STA CASH+3
     617A 030C     
21095               
21096 617C D802  30        movb ry,@T1                     ; STY T1            ; Then the second most significant bytes:
     617E 0006     
21097 6180 D020  30        movb @CASH+2,ra                 ; LDA CASH+2        ;
     6182 030B     
21098                      .sbc @T1,ra                     ; SBC T1            ; CASH+2 = CASH+2 - Y
     **** ****     > SBC
0001 6184 1801  14        joc  !
0002 6186 7004  18        sb   rone,ra
0003               !:
0004 6188 7020  30        sb   @T1,ra
     618A 0006     
                   < elite.a99
21099 618C D800  30        movb ra,@CASH+2                 ; STA CASH+2
     618E 030B     
21100               
21101 6190 D020  30        movb @CASH+1,ra                 ; LDA CASH+1        ; Then the third most significant bytes (which are 0):
     6192 030A     
21102                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 6194 1801  14        joc  !
0002 6196 7004  18        sb   rone,ra
0003               !:
0004 6198 0220  22        ai   ra,-(>00*256)
     619A 0000     
                   < elite.a99
21103 619C D800  30        movb ra,@CASH+1                 ; STA CASH+1        ; CASH+1 = CASH+1 - 0
     619E 030A     
21104               
21105 61A0 D020  30        movb @CASH,ra                   ; LDA CASH          ; And finally the most significant bytes (which are 0):
     61A2 0309     
21106                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 61A4 1801  14        joc  !
0002 61A6 7004  18        sb   rone,ra
0003               !:
0004 61A8 0220  22        ai   ra,-(>00*256)
     61AA 0000     
                   < elite.a99
21107 61AC D800  30        movb ra,@CASH                   ; STA CASH          ; CASH = CASH - 0
     61AE 0309     
21108               
21109 61B0 1820  14        joc  TT113                      ; BCS TT113         ; If the C flag is set then the subtraction didn't
21110                                                                          ; underflow, so the value in CASH is correct and we can
21111                                                                          ; jump to TT113 to return from the subroutine with the
21112                                                                          ; C flag set to indicate success (as TT113 contains an
21113                                                                          ; RTS)
21114               
21115                                                                          ; Otherwise we didn't have enough cash in CASH to
21116                                                                          ; subtract (Y X) from it, so fall through into
21117                                                                          ; MCASH to reverse the sum and restore the original
21118                                                                          ; value in CASH, and returning with the C flag clear
21119               
21120               * ******************************************************************************
21121               *
21122               * Name: MCASH
21123               * Type: Subroutine
21124               * Category: Maths (Arithmetic)
21125               * Summary: Add an amount of cash to the cash pot
21126               *
21127               * ------------------------------------------------------------------------------
21128               *
21129               * Add (Y X) cash to the cash pot in CASH. As CASH is a four-byte number, this
21130               * calculates:
21131               *
21132               * CASH(0 1 2 3) = CASH(0 1 2 3) + (Y X)
21133               *
21134               * ------------------------------------------------------------------------------
21135               *
21136               * Other entry points:
21137               *
21138               * TT113               Contains an RTS
21139               *
21140               * ******************************************************************************
21141               
21142               MCASH:
21143 61B2 D001  18        movb rx,ra                      ; TXA               ; Add the least significant bytes:
21144                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 61B4 0A13  18        sla  rzero,1
                   < elite.a99
21145                      .adc @CASH+3,ra                 ; ADC CASH+3        ; CASH+3 = CASH+3 + X
     **** ****     > ADC
0001 61B6 1701  14        jnc  !
0002 61B8 B004  18        ab   rone,ra
0003               !:
0004 61BA B020  30        ab   @CASH+3,ra
     61BC 030C     
                   < elite.a99
21146 61BE D800  30        movb ra,@CASH+3                 ; STA CASH+3
     61C0 030C     
21147               
21148 61C2 D002  18        movb ry,ra                      ; TYA               ; Then the second most significant bytes:
21149                      .adc @CASH+2,ra                 ; ADC CASH+2        ;
     **** ****     > ADC
0001 61C4 1701  14        jnc  !
0002 61C6 B004  18        ab   rone,ra
0003               !:
0004 61C8 B020  30        ab   @CASH+2,ra
     61CA 030B     
                   < elite.a99
21150 61CC D800  30        movb ra,@CASH+2                 ; STA CASH+2        ; CASH+2 = CASH+2 + Y
     61CE 030B     
21151               
21152 61D0 D020  30        movb @CASH+1,ra                 ; LDA CASH+1        ; Then the third most significant bytes (which are 0):
     61D2 030A     
21153                      .adi (>00*256)                  ; ADC #0            ;
     **** ****     > ADI
0001 61D4 1701  14        jnc  !
0002 61D6 B004  18        ab   rone,ra
0003               !:
0004 61D8 0220  22        ai   ra,(>00*256)
     61DA 0000     
                   < elite.a99
21154 61DC D800  30        movb ra,@CASH+1                 ; STA CASH+1        ; CASH+1 = CASH+1 + 0
     61DE 030A     
21155               
21156 61E0 D020  30        movb @CASH,ra                   ; LDA CASH          ; And finally the most significant bytes (which are 0):
     61E2 0309     
21157                      .adi (>00*256)                  ; ADC #0            ;
     **** ****     > ADI
0001 61E4 1701  14        jnc  !
0002 61E6 B004  18        ab   rone,ra
0003               !:
0004 61E8 0220  22        ai   ra,(>00*256)
     61EA 0000     
                   < elite.a99
21158 61EC D800  30        movb ra,@CASH                   ; STA CASH          ; CASH = CASH + 0
     61EE 0309     
21159               
21160                      .clc                            ; CLC               ; Clear the C flag, so if the above was done following
     **** ****     > CLC
0001 61F0 0A13  18        sla  rzero,1
                   < elite.a99
21161                                                                          ; a failed LCASH call, the C flag correctly indicates
21162                                                                          ; failure
21163               
21164               TT113:
21165 61F2 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     61F4 800E     
21166               
21167               * ******************************************************************************
21168               *
21169               * Name: GCASH
21170               * Type: Subroutine
21171               * Category: Maths (Arithmetic)
21172               * Summary: Calculate (Y X) = P * Q * 4
21173               *
21174               * ------------------------------------------------------------------------------
21175               *
21176               * Calculate the following multiplication of unsigned 8-bit numbers:
21177               *
21178               * (Y X) = P * Q * 4
21179               *
21180               * ******************************************************************************
21181               
21182               GCASH:
21183 61F6 0206  20        li   rtmp,MULTU                 ; JSR MULTU         ; Call MULTU to calculate (A P) = P * Q
     61F8 42DE     
21184 61FA 06A0  28        bl   @jsr                       ;
     61FC 8002     
21185               
21186               * ******************************************************************************
21187               *
21188               * Name: GC2
21189               * Type: Subroutine
21190               * Category: Maths (Arithmetic)
21191               * Summary: Calculate (Y X) = (A P) * 4
21192               *
21193               * ------------------------------------------------------------------------------
21194               *
21195               * Calculate the following multiplication of unsigned 16-bit numbers:
21196               *
21197               * (Y X) = (A P) * 4
21198               *
21199               * ******************************************************************************
21200               
21201               GC2:
21202                      .asl @P                         ; ASL P             ; Set (A P) = (A P) * 4
     **** ****     > ASL
0001 61FE D1A0  30        movb @P,rtmp
     6200 001B     
0002 6202 0246  22        andi rtmp,>ff00
     6204 FF00     
0003 6206 0A16  18        sla  rtmp,1
0004 6208 D806  30        movb rtmp,@P
     620A 001B     
                   < elite.a99
21203 620C 06A0  28        bl   @rola                      ; ROL A
     620E 8018     
21204                      .asl @P                         ; ASL P
     **** ****     > ASL
0001 6210 D1A0  30        movb @P,rtmp
     6212 001B     
0002 6214 0246  22        andi rtmp,>ff00
     6216 FF00     
0003 6218 0A16  18        sla  rtmp,1
0004 621A D806  30        movb rtmp,@P
     621C 001B     
                   < elite.a99
21205 621E 06A0  28        bl   @rola                      ; ROL A
     6220 8018     
21206               
21207 6222 D080  18        movb ra,ry                      ; TAY               ; Set (Y X) = (A P)
21208 6224 D060  30        movb @P,rx                      ; LDX P
     6226 001B     
21209               
21210 6228 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     622A 800E     
21211               
21212               * ******************************************************************************
21213               *
21214               * Name: EQSHP
21215               * Type: Subroutine
21216               * Category: Equipment
21217               * Summary: Show the Equip Ship screen (red key f3)
21218               *
21219               * ------------------------------------------------------------------------------
21220               *
21221               * Other entry points:
21222               *
21223               * err                 Beep, pause and go to the docking bay (i.e. show the
21224               * Status Mode screen)
21225               *
21226               * pres                Given an item number A with the item name in recursive
21227               * token Y, show an error to say that the item is already
21228               * present, refund the cost of the item, and then beep and
21229               * exit to the docking bay (i.e. show the Status Mode
21230               * screen)
21231               *
21232               * ******************************************************************************
21233               
21234               bay_:
21235 622C 0460  24        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     622E 8650     
21236                                                                          ; screen)
21237               
21238               EQSHP:
21239 6230 0206  20        li   rtmp,DIALS                 ; JSR DIALS         ; Call DIALS to update the dashboard
     6232 3272     
21240 6234 06A0  28        bl   @jsr                       ;
     6236 8002     
21241               
21242 6238 0200  20        li   ra,>20*256                 ; LDA #32           ; Clear the top part of the screen, draw a white border,
     623A 2000     
21243 623C 0206  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 32 (Equip
     623E 4B2A     
21244 6240 06A0  28        bl   @jsr                       ;
     6242 8002     
21245                                                                          ; Ship screen)
21246               
21247 6244 0200  20        li   ra,>0c*256                 ; LDA #12           ; Move the text cursor to column 12
     6246 0C00     
21248 6248 D800  30        movb ra,@XC                     ; STA XC
     624A 002C     
21249               
21250 624C 0200  20        li   ra,>cf*256                 ; LDA #207          ; Print recursive token 47 ("EQUIP") followed by a space
     624E CF00     
21251 6250 0206  20        li   rtmp,spc_                  ; JSR spc
     6252 4EFE     
21252 6254 06A0  28        bl   @jsr                       ;
     6256 8002     
21253               
21254 6258 0200  20        li   ra,>b9*256                 ; LDA #185          ; Print recursive token 25 ("SHIP") and draw a
     625A B900     
21255 625C 0206  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; horizontal line at pixel row 19 to box in the title
     625E 25B0     
21256 6260 06A0  28        bl   @jsr                       ;
     6262 8002     
21257               
21258 6264 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     6266 8000     
21259 6268 D800  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     626A 007E     
21260               
21261 626C B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
21262               
21263 626E D020  30        movb @tek_,ra                   ; LDA tek           ; Fetch the tech level of the current system from tek
     6270 0F1D     
21264                      .clc                            ; CLC               ; and add 3 (the tech level is stored as 0-14, so A is
     **** ****     > CLC
0001 6272 0A13  18        sla  rzero,1
                   < elite.a99
21265                      .adi (>03*256)                  ; ADC #3            ; now set to between 3 and 17)
     **** ****     > ADI
0001 6274 1701  14        jnc  !
0002 6276 B004  18        ab   rone,ra
0003               !:
0004 6278 0220  22        ai   ra,(>03*256)
     627A 0300     
                   < elite.a99
21266               
21267 627C 0280  22        ci   ra,>0c*256                 ; CMP #12           ; If A >= 12 then set A = 12, so A is now set to between
     627E 0C00     
21268 6280 1702  14        jnc  B58                        ; BCC B58           ; 3 and 12
21269 6282 0200  20        li   ra,>0c*256                 ; LDA #12
     6284 0C00     
21270               
21271               B58:
21272 6286 D800  30        movb ra,@Q                      ; STA Q             ; Set QQ25 = A (so QQ25 is in the range 3-12 and
     6288 0090     
21273 628A D800  30        movb ra,@QQ25                   ; STA QQ25          ; represents number of the most advanced item available
     628C 0F19     
21274 628E B004  18        ab   rone,ra                    ; INC Q             ; in this system, which we can pass to gnum below when
21275                                                                          ; asking which item we want to buy)
21276                                                                          ;
21277                                                                          ; Set Q = A + 1 (so Q is in the range 4-13 and contains
21278                                                                          ; QQ25 + 1, i.e. the highest item number on sale + 1)
21279               
21280 6290 0200  20        li   ra,>46*256                 ; LDA #70           ; Set A = 70 - QQ14, where QQ14 contains the current
     6292 4600     
21281                      .sec                            ; SEC               ; fuel in light years * 10, so this leaves the amount
     **** ****     > SEC
0001 6294 0A15  18        sla  rmone,1
                   < elite.a99
21282                      .sbc @QQ14,ra                   ; SBC QQ14          ; of fuel we need to fill 'er up (in light years * 10)
     **** ****     > SBC
0001 6296 1801  14        joc  !
0002 6298 7004  18        sb   rone,ra
0003               !:
0004 629A 7020  30        sb   @QQ14,ra
     629C 030D     
                   < elite.a99
21283               
21284                      .asla                           ; ASL A             ; The price of fuel is always 2 Cr per light year, so we
     **** ****     > ASLA
0001 629E 0240  22        andi ra,>ff00
     62A0 FF00     
0002 62A2 0A10  18        sla  ra,1
                   < elite.a99
21285 62A4 D800  38        movb ra,@PRXS                   ; STA PRXS          ; double A and store it in PRXS, as the first price in
     62A6 2DF0     
21286                                                                          ; the price list (which is reserved for fuel), and
21287                                                                          ; because the table contains prices as price * 10, it's
21288                                                                          ; in the right format (so tank containing 7.0 light
21289                                                                          ; years of fuel would be 14.0 Cr, or a PRXS value of
21290                                                                          ; 140)
21291               
21292 62A8 0201  20        li   rx,>01*256                 ; LDX #1            ; We are now going to work our way through the equipment
     62AA 0100     
21293                                                                          ; price list at PRXS, printing out the equipment that is
21294                                                                          ; available at this station, so set a counter in X,
21295                                                                          ; starting at 1, to hold the number of the current item
21296                                                                          ; plus 1 (so the item number in X loops through 1-13)
21297               
21298               EQL1:
21299 62AC D801  30        movb rx,@XX13                   ; STX XX13          ; Store the current item number + 1 in XX13
     62AE 0098     
21300               
21301 62B0 0206  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline
     62B2 4EE6     
21302 62B4 06A0  28        bl   @jsr                       ;
     62B6 8002     
21303               
21304 62B8 D060  30        movb @XX13,rx                   ; LDX XX13          ; Print the current item number + 1 to 3 digits, left-
     62BA 0098     
21305                      .clc                            ; CLC               ; padding with spaces, and with no decimal point, so the
     **** ****     > CLC
0001 62BC 0A13  18        sla  rzero,1
                   < elite.a99
21306 62BE 0206  20        li   rtmp,pr2_                  ; JSR pr2           ; items are numbered from 1
     62C0 2FAC     
21307 62C2 06A0  28        bl   @jsr                       ;
     62C4 8002     
21308               
21309 62C6 0206  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     62C8 5E64     
21310 62CA 06A0  28        bl   @jsr                       ;
     62CC 8002     
21311               
21312 62CE D020  30        movb @XX13,ra                   ; LDA XX13          ; Print recursive token 104 + XX13, which will be in the
     62D0 0098     
21313                      .clc                            ; CLC               ; range 105 ("FUEL") to 116 ("GALACTIC HYPERSPACE ")
     **** ****     > CLC
0001 62D2 0A13  18        sla  rzero,1
                   < elite.a99
21314                      .adi (>68*256)                  ; ADC #104          ; so this prints the current item's name
     **** ****     > ADI
0001 62D4 1701  14        jnc  !
0002 62D6 B004  18        ab   rone,ra
0003               !:
0004 62D8 0220  22        ai   ra,(>68*256)
     62DA 6800     
                   < elite.a99
21315 62DC 0206  20        li   rtmp,TT27                  ; JSR TT27
     62DE 66DC     
21316 62E0 06A0  28        bl   @jsr                       ;
     62E2 8002     
21317               
21318 62E4 D020  30        movb @XX13,ra                   ; LDA XX13          ; Call prx-3 to set (Y X) to the price of the item with
     62E6 0098     
21319 62E8 0206  20        li   rtmp,prx_-3                ; JSR prx-3         ; number XX13 - 1 (as XX13 contains the item number + 1)
     62EA 6515     
21320 62EC 06A0  28        bl   @jsr                       ;
     62EE 8002     
21321               
21322                      .sec                            ; SEC               ; Set the C flag so we will print a decimal point when
     **** ****     > SEC
0001 62F0 0A15  18        sla  rmone,1
                   < elite.a99
21323                                                                          ; we print the price
21324               
21325 62F2 0200  20        li   ra,>19*256                 ; LDA #25           ; Move the text cursor to column 25
     62F4 1900     
21326 62F6 D800  30        movb ra,@XC                     ; STA XC
     62F8 002C     
21327               
21328 62FA 0200  20        li   ra,>06*256                 ; LDA #6            ; Print the number in (Y X) to 6 digits, left-padding
     62FC 0600     
21329 62FE 0206  20        li   rtmp,TT11                  ; JSR TT11          ; with spaces and including a decimal point, which will
     6300 2FB4     
21330 6302 06A0  28        bl   @jsr                       ;
     6304 8002     
21331                                                                          ; be the correct price for this item as (Y X) contains
21332                                                                          ; the price * 10, so the trailing zero will go after the
21333                                                                          ; decimal point (i.e. 5250 will be printed as 525.0)
21334               
21335 6306 D060  30        movb @XX13,rx                   ; LDX XX13          ; Increment the current item number in XX13
     6308 0098     
21336 630A B044  18        ab   rone,rx                    ; INX
21337               
21338 630C 9060  30        cb   @Q,rx                      ; CPX Q             ; If X < Q, loop back up to print the next item on the
     630E 0090     
21339 6310 17CD  14        jnc  EQL1                       ; BCC EQL1          ; list of equipment available at this station
21340               
21341 6312 0206  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     6314 4C2E     
21342 6316 06A0  28        bl   @jsr                       ;
     6318 8002     
21343                                                                          ; and move the text cursor to column 1 on row 21, i.e.
21344                                                                          ; the start of the top row of the three bottom rows
21345               
21346 631A 0200  20        li   ra,>7f*256                 ; LDA #127          ; Print recursive token 127 ("ITEM") followed by a
     631C 7F00     
21347 631E 0206  20        li   rtmp,prq_                  ; JSR prq           ; question mark
     6320 5D52     
21348 6322 06A0  28        bl   @jsr                       ;
     6324 8002     
21349               
21350 6326 0206  20        li   rtmp,gnum_                 ; JSR gnum          ; Call gnum to get a number from the keyboard, which
     6328 55CE     
21351 632A 06A0  28        bl   @jsr                       ;
     632C 8002     
21352                                                                          ; will be the number of the item we want to purchase,
21353                                                                          ; returning the number entered in A and R, and setting
21354                                                                          ; the C flag if the number is bigger than the highest
21355                                                                          ; item number in QQ25
21356               
21357 632E 1602  14        jne  FIX004                     ; BNE FIX004        ; If no number was entered, jump up to bay to go to the
21358                                                                          ; docking bay (i.e. show the Status Mode screen)
21359 6330 0460  28        b    @bay_                      ; JMP bay
     6332 622C     
21360               FIX004:
21361 6334 1702  14        jnc  FIX005                     ; BCC FIX005        ; If the number entered was too big, jump up to bay to
21362                                                                          ; go to the docking bay (i.e. show the Status Mode
21363                                                                          ; screen)
21364 6336 0460  28        b    @bay_                      ; JMP bay
     6338 622C     
21365               FIX005:
21366                      .sbi (>00*256)                  ; SBC #0            ; Set A to the number entered - 1 (because the C flag is
     **** ****     > SBI
0001 633A 1801  14        joc  !
0002 633C 7004  18        sb   rone,ra
0003               !:
0004 633E 0220  22        ai   ra,-(>00*256)
     6340 0000     
                   < elite.a99
21367                                                                          ; clear), which will be the actual item number we want
21368                                                                          ; to buy
21369               
21370 6342 0201  20        li   rx,>02*256                 ; LDX #2            ; Move the text cursor to column 2
     6344 0200     
21371 6346 D801  30        movb rx,@XC                     ; STX XC
     6348 002C     
21372               
21373 634A B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
21374               
21375                      .pha                            ; PHA               ; While preserving the value in A, call eq to subtract
     **** ****     > PHA
0001 634C D680  30        movb ra,*rsp
0002 634E 060A  14        dec  rsp
                   < elite.a99
21376 6350 0206  20        li   rtmp,eq_                   ; JSR eq            ; the price of the item we want to buy (which is in A)
     6352 64EC     
21377 6354 06A0  28        bl   @jsr                       ;
     6356 8002     
21378                      .pla                            ; PLA               ; from our cash pot, but only if we have enough cash in
     **** ****     > PLA
0001 6358 058A  14        inc  rsp
0002 635A D01A  26        movb *rsp,ra
                   < elite.a99
21379                                                                          ; the pot. If we don't have enough cash, exit to the
21380                                                                          ; docking bay (i.e. show the Status Mode screen)
21381               
21382 635C 1606  14        jne  et0_                       ; BNE et0           ; If A is not 0 (i.e. the item we've just bought is not
21383                                                                          ; fuel), skip to et0
21384               
21385 635E D800  30        movb ra,@MCNT                   ; STA MCNT          ; We just bought fuel, so we zero the main loop counter
     6360 0099     
21386               
21387 6362 0201  20        li   rx,>46*256                 ; LDX #70           ; Set the current fuel level * 10 in QQ14 to 70, or 7.0
     6364 4600     
21388 6366 D801  30        movb rx,@QQ14                   ; STX QQ14          ; light years (a full tank)
     6368 030D     
21389               
21390               et0_:
21391 636A 0280  22        ci   ra,>01*256                 ; CMP #1            ; If A is not 1 (i.e. the item we've just bought is not
     636C 0100     
21392 636E 160E  14        jne  et1_                       ; BNE et1           ; a missile), skip to et1
21393               
21394 6370 D060  30        movb @NOMSL,rx                  ; LDX NOMSL         ; Fetch the current number of missiles from NOMSL into X
     6372 0333     
21395               
21396 6374 B044  18        ab   rone,rx                    ; INX               ; Increment X to the new number of missiles
21397               
21398 6376 0202  20        li   ry,>75*256                 ; LDY #117          ; Set Y to recursive token 117 ("ALL")
     6378 7500     
21399               
21400 637A 0281  22        ci   rx,>05*256                 ; CPX #5            ; If buying this missile would give us 5 missiles, this
     637C 0500     
21401 637E 1856  14        joc  pres_                      ; BCS pres          ; is more than the maximum of 4 missiles that we can
21402                                                                          ; fit, so jump to pres to show the error "All Present",
21403                                                                          ; beep and exit to the docking bay (i.e. show the Status
21404                                                                          ; Mode screen)
21405               
21406 6380 D801  30        movb rx,@NOMSL                  ; STX NOMSL         ; Otherwise update the number of missiles in NOMSL
     6382 0333     
21407               
21408 6384 0206  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     6386 7FDC     
21409 6388 06A0  28        bl   @jsr                       ;
     638A 8002     
21410                                                                          ; them are targeted
21411               
21412               et1_:
21413 638C 0202  20        li   ry,>6b*256                 ; LDY #107          ; Set Y to recursive token 107 ("LARGE CARGO{sentence
     638E 6B00     
21414                                                                          ; case} BAY")
21415               
21416 6390 0280  22        ci   ra,>02*256                 ; CMP #2            ; If A is not 2 (i.e. the item we've just bought is not
     6392 0200     
21417 6394 1607  14        jne  et2_                       ; BNE et2           ; a large cargo bay), skip to et2
21418               
21419 6396 0201  20        li   rx,>25*256                 ; LDX #37           ; If our current cargo capacity in CRGO is 37, then we
     6398 2500     
21420 639A 9060  30        cb   @CRGO,rx                   ; CPX CRGO          ; already have a large cargo bay fitted, so jump to pres
     639C 0316     
21421 639E 1346  14        jeq  pres_                      ; BEQ pres          ; to show the error "Large Cargo Bay Present", beep and
21422                                                                          ; exit to the docking bay (i.e. show the Status Mode
21423                                                                          ; screen)
21424               
21425 63A0 D801  30        movb rx,@CRGO                   ; STX CRGO          ; Otherwise we just scored ourselves a large cargo bay,
     63A2 0316     
21426                                                                          ; so update our current cargo capacity in CRGO to 37
21427               
21428               et2_:
21429 63A4 0280  22        ci   ra,>03*256                 ; CMP #3            ; If A is not 3 (i.e. the item we've just bought is not
     63A6 0300     
21430 63A8 1605  14        jne  et3_                       ; BNE et3           ; an E.C.M. system), skip to et3
21431               
21432 63AA B084  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 108 ("E.C.M.SYSTEM")
21433               
21434 63AC D060  30        movb @ECM,rx                    ; LDX ECM           ; If we already have an E.C.M. fitted (i.e. ECM is
     63AE 0328     
21435 63B0 163D  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "E.C.M.
21436                                                                          ; System Present", beep and exit to the docking bay
21437                                                                          ; (i.e. show the Status Mode screen)
21438               
21439 63B2 7004  18        sb   rone,ra                    ; DEC ECM           ; Otherwise we just took delivery of a brand new E.C.M.
21440                                                                          ; system, so set ECM to &FF (as ECM was 0 before the DEC
21441                                                                          ; instruction)
21442               
21443               et3_:
21444 63B4 0280  22        ci   ra,>04*256                 ; CMP #4            ; If A is not 4 (i.e. the item we've just bought is not
     63B6 0400     
21445 63B8 1612  14        jne  et4_                       ; BNE et4           ; an extra pulse laser), skip to et4
21446               
21447 63BA 0206  20        li   rtmp,qv_                   ; JSR qv            ; Print a menu listing the four views, with a "View ?"
     63BC 652E     
21448 63BE 06A0  28        bl   @jsr                       ;
     63C0 8002     
21449                                                                          ; prompt, and ask for a view number, which is returned
21450                                                                          ; in X (which now contains 0-3)
21451               
21452 63C2 0200  20        li   ra,>04*256                 ; LDA #4            ; This instruction doesn't appear to do anything, as we
     63C4 0400     
21453                                                                          ; either don't need it (if we already have this laser)
21454                                                                          ; or we set A to 4 below (if we buy it)
21455               
21456 63C6 D0A1  34        movb @LASER(rx),ry              ; LDY LASER,X       ; If there is no laser mounted in the chosen view (i.e.
     63C8 0310     
21457 63CA 1303  14        jeq  ed4_                       ; BEQ ed4           ; LASER+X, which contains the laser power for view X, is
21458                                                                          ; zero), jump to ed4 to buy a pulse laser
21459               
21460               ed7_:
21461 63CC 0202  20        li   ry,>bb*256                 ; LDY #187          ; Otherwise we already have a laser mounted in this
     63CE BB00     
21462 63D0 162D  14        jne  pres_                      ; BNE pres          ; view, so jump to pres with Y set to token 27
21463                                                                          ; (" LASER") to show the error "Laser Present", beep
21464                                                                          ; and exit to the docking bay (i.e. show the Status
21465                                                                          ; Mode screen)
21466               
21467               ed4_:
21468 63D2 0200  20        li   ra,(POW)*256               ; LDA #POW          ; We just bought a pulse laser for view X, so we need
     63D4 0F00     
21469 63D6 D840  38        movb ra,@LASER(rx)              ; STA LASER,X       ; to fit it by storing the laser power for a pulse laser
     63D8 0310     
21470                                                                          ; (given in POW) in LASER+X
21471               
21472 63DA 0200  20        li   ra,>04*256                 ; LDA #4            ; Set A to 4 as we just overwrote the original value,
     63DC 0400     
21473                                                                          ; and we still need it set correctly so we can continue
21474                                                                          ; through the conditional statements for all the other
21475                                                                          ; equipment
21476               
21477               et4_:
21478 63DE 0280  22        ci   ra,>05*256                 ; CMP #5            ; If A is not 5 (i.e. the item we've just bought is not
     63E0 0500     
21479 63E2 161C  14        jne  et5_                       ; BNE et5           ; an extra beam laser), skip to et5
21480               
21481 63E4 0206  20        li   rtmp,qv_                   ; JSR qv            ; Print a menu listing the four views, with a "View ?"
     63E6 652E     
21482 63E8 06A0  28        bl   @jsr                       ;
     63EA 8002     
21483                                                                          ; prompt, and ask for a view number, which is returned
21484                                                                          ; in X (which now contains 0-3)
21485               
21486 63EC D801  30        movb rx,@T1                     ; STX T1            ; Store the view in T1 so we can retrieve it below
     63EE 0006     
21487               
21488 63F0 0200  20        li   ra,>05*256                 ; LDA #5            ; Set A to 5 as the call to qv will have overwritten
     63F2 0500     
21489                                                                          ; the original value, and we still need it set
21490                                                                          ; correctly so we can continue through the conditional
21491                                                                          ; statements for all the other equipment
21492               
21493 63F4 D0A1  34        movb @LASER(rx),ry              ; LDY LASER,X       ; If there is no laser mounted in the chosen view (i.e.
     63F6 0310     
21494 63F8 130B  14        jeq  ed5_                       ; BEQ ed5           ; LASER+X, which contains the laser power for view X,
21495                                                                          ; is zero), jump to ed5 to buy a beam laser
21496               
21497               * BPL P%+4               \ This instruction is commented out in the original
21498                                                                          ; source, though it would have no effect (it would
21499                                                                          ; simply skip the BMI if A is positive, which is what
21500                                                                          ; BMI does anyway)
21501               
21502 63FA 11E8  14        jlt  ed7_                       ; BMI ed7           ; If there is a beam laser already mounted in the chosen
21503                                                                          ; view (i.e. LASER+X has bit 7 set, which indicates a
21504                                                                          ; beam laser rather than a pulse laser), skip back to
21505                                                                          ; ed7 to print a "Laser Present" error, beep and exit
21506                                                                          ; to the docking bay (i.e. show the Status Mode screen)
21507               
21508 63FC 0200  20        li   ra,>04*256                 ; LDA #4            ; If we get here then we already have a pulse laser in
     63FE 0400     
21509 6400 0206  20        li   rtmp,prx_                  ; JSR prx           ; the selected view, so we call prx to set (Y X) to the
     6402 6518     
21510 6404 06A0  28        bl   @jsr                       ;
     6406 8002     
21511                                                                          ; price of equipment item number 4 (extra pulse laser)
21512                                                                          ; so we can give a refund of the pulse laser
21513               
21514 6408 0206  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH, so we refund
     640A 61B2     
21515 640C 06A0  28        bl   @jsr                       ;
     640E 8002     
21516                                                                          ; the price of the pulse laser we are exchanging for a
21517                                                                          ; new beam laser
21518               
21519               ed5_:
21520 6410 0200  20        li   ra,(POW+128)*256           ; LDA #POW+128      ; We just bought a beam laser for view X, so we need
     6412 8F00     
21521 6414 D060  30        movb @T1,rx                     ; LDX T1            ; to fit it by storing the laser power for a beam laser
     6416 0006     
21522 6418 D840  38        movb ra,@LASER(rx)              ; STA LASER,X       ; (given in POW+128) in LASER+X, using the view number
     641A 0310     
21523                                                                          ; we stored in T1 earlier, as the call to prx will have
21524                                                                          ; overwritten the original value in X
21525               
21526               et5_:
21527 641C 0202  20        li   ry,>6f*256                 ; LDY #111          ; Set Y to recursive token 107 ("FUEL SCOOPS")
     641E 6F00     
21528               
21529 6420 0280  22        ci   ra,>06*256                 ; CMP #6            ; If A is not 6 (i.e. the item we've just bought is not
     6422 0600     
21530 6424 1620  14        jne  et6_                       ; BNE et6           ; a fuel scoop), skip to et6
21531               
21532 6426 D060  30        movb @BST,rx                    ; LDX BST           ; If we already have fuel scoops fitted (i.e. BST is
     6428 0329     
21533 642A 131C  14        jeq  ed9_                       ; BEQ ed9           ; zero), jump to ed9, otherwise fall through into pres
21534                                                                          ; to show the error "Fuel Scoops Present", beep and
21535                                                                          ; exit to the docking bay (i.e. show the Status Mode
21536                                                                          ; screen)
21537               
21538               pres_:
21539                                                                          ; If we get here we need to show an error to say that
21540                                                                          ; the item whose name is in recursive token Y is already
21541                                                                          ; present, and then process a refund for the cost of
21542                                                                          ; item number A
21543 642C D802  30        movb ry,@K                      ; STY K             ; Store the item's name in K
     642E 003D     
21544               
21545 6430 0206  20        li   rtmp,prx_                  ; JSR prx           ; Call prx to set (Y X) to the price of equipment item
     6432 6518     
21546 6434 06A0  28        bl   @jsr                       ;
     6436 8002     
21547                                                                          ; number A
21548               
21549 6438 0206  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH, as the station
     643A 61B2     
21550 643C 06A0  28        bl   @jsr                       ;
     643E 8002     
21551                                                                          ; already took the money for this item in the JSR eq
21552                                                                          ; instruction above, but we can't fit the item, so need
21553                                                                          ; our money back
21554               
21555 6440 D020  30        movb @K,ra                      ; LDA K             ; Print the recursive token in K (the item's name)
     6442 003D     
21556 6444 0206  20        li   rtmp,spc_                  ; JSR spc           ; followed by a space
     6446 4EFE     
21557 6448 06A0  28        bl   @jsr                       ;
     644A 8002     
21558               
21559 644C 0200  20        li   ra,>1f*256                 ; LDA #31           ; Print recursive token 145 ("PRESENT")
     644E 1F00     
21560 6450 0206  20        li   rtmp,TT27                  ; JSR TT27
     6452 66DC     
21561 6454 06A0  28        bl   @jsr                       ;
     6456 8002     
21562               
21563               err_:
21564 6458 0206  20        li   rtmp,dn2_                  ; JSR dn2           ; Call dn2 to make a short, high beep and delay for 1
     645A 64DC     
21565 645C 06A0  28        bl   @jsr                       ;
     645E 8002     
21566                                                                          ; second
21567               
21568 6460 0460  24        b    @BAY                       ; JMP BAY           ; Jump to BAY to go to the docking bay (i.e. show the
     6462 8650     
21569                                                                          ; Status Mode screen)
21570               
21571               ed9_:
21572 6464 7004  18        sb   rone,ra                    ; DEC BST           ; We just bought a shiny new fuel scoop, so set BST to
21573                                                                          ; &FF (as BST was 0 before the jump to ed9 above)
21574               
21575               et6_:
21576 6466 B084  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 112 ("E.C.M.SYSTEM")
21577               
21578 6468 0280  22        ci   ra,>07*256                 ; CMP #7            ; If A is not 7 (i.e. the item we've just bought is not
     646A 0700     
21579 646C 1604  14        jne  et7_                       ; BNE et7           ; an escape pod), skip to et7
21580               
21581 646E D060  30        movb @ESCP,rx                   ; LDX ESCP          ; If we already have an escape pod fitted (i.e. ESCP is
     6470 032E     
21582 6472 16DC  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "Escape Pod
21583                                                                          ; Present", beep and exit to the docking bay (i.e. show
21584                                                                          ; the Status Mode screen)
21585               
21586 6474 7004  18        sb   rone,ra                    ; DEC ESCP          ; Otherwise we just bought an escape pod, so set ESCP
21587                                                                          ; to &FF (as ESCP was 0 before the DEC instruction)
21588               
21589               et7_:
21590 6476 B084  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 113 ("ENERGY BOMB")
21591               
21592 6478 0280  22        ci   ra,>08*256                 ; CMP #8            ; If A is not 8 (i.e. the item we've just bought is not
     647A 0800     
21593 647C 1607  14        jne  et8_                       ; BNE et8           ; an energy bomb), skip to et8
21594               
21595 647E D060  30        movb @BOMB,rx                   ; LDX BOMB          ; If we already have an energy bomb fitted (i.e. BOMB
     6480 032A     
21596 6482 16D4  14        jne  pres_                      ; BNE pres          ; is non-zero), jump to pres to show the error "Energy
21597                                                                          ; Bomb Present", beep and exit to the docking bay (i.e.
21598                                                                          ; show the Status Mode screen)
21599               
21600 6484 0201  20        li   rx,>7f*256                 ; LDX #&7F          ; Otherwise we just bought an energy bomb, so set BOMB
     6486 7F00     
21601 6488 D801  30        movb rx,@BOMB                   ; STX BOMB          ; to &7F
     648A 032A     
21602               
21603               et8_:
21604 648C B084  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 114 ("ENERGY UNIT")
21605               
21606 648E 0280  22        ci   ra,>09*256                 ; CMP #9            ; If A is not 9 (i.e. the item we've just bought is not
     6490 0900     
21607 6492 1604  14        jne  etA                        ; BNE etA           ; an energy unit), skip to etA
21608               
21609 6494 D060  30        movb @ENGY,rx                   ; LDX ENGY          ; If we already have an energy unit fitted (i.e. ENGY is
     6496 032B     
21610 6498 16C9  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "Energy Unit
21611                                                                          ; Present", beep and exit to the docking bay (i.e. show
21612                                                                          ; the Status Mode screen)
21613               
21614 649A B004  18        ab   rone,ra                    ; INC ENGY          ; Otherwise we just picked up an energy unit, so set
21615                                                                          ; ENGY to 1 (as ENGY was 0 before the INC instruction)
21616               
21617               etA:
21618 649C B084  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 115 ("DOCKING
21619                                                                          ; COMPUTERS")
21620               
21621 649E 0280  22        ci   ra,>0a*256                 ; CMP #10           ; If A is not 10 (i.e. the item we've just bought is not
     64A0 0A00     
21622 64A2 1604  14        jne  etB                        ; BNE etB           ; a docking computer), skip to etB
21623               
21624 64A4 D060  30        movb @DKCMP,rx                  ; LDX DKCMP         ; If we already have a docking computer fitted (i.e.
     64A6 032C     
21625 64A8 16C1  14        jne  pres_                      ; BNE pres          ; DKCMP is non-zero), jump to pres to show the error
21626                                                                          ; "Docking Computer Present", beep and exit to the
21627                                                                          ; docking bay (i.e. show the Status Mode screen)
21628               
21629 64AA 7004  18        sb   rone,ra                    ; DEC DKCMP         ; Otherwise we just got hold of a docking computer, so
21630                                                                          ; set DKCMP to &FF (as DKCMP was 0 before the DEC
21631                                                                          ; instruction)
21632               
21633               etB:
21634 64AC B084  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 116 ("GALACTIC
21635                                                                          ; HYPERSPACE ")
21636               
21637 64AE 0280  22        ci   ra,>0b*256                 ; CMP #11           ; If A is not 11 (i.e. the item we've just bought is not
     64B0 0B00     
21638 64B2 1604  14        jne  et9_                       ; BNE et9           ; a galactic hyperdrive), skip to et9
21639               
21640 64B4 D060  30        movb @GHYP,rx                   ; LDX GHYP          ; If we already have a galactic hyperdrive fitted (i.e.
     64B6 032D     
21641 64B8 16B9  14        jne  pres_                      ; BNE pres          ; GHYP is non-zero), jump to pres to show the error
21642                                                                          ; "Galactic Hyperspace Present", beep and exit to the
21643                                                                          ; docking bay (i.e. show the Status Mode screen)
21644               
21645 64BA 7004  18        sb   rone,ra                    ; DEC GHYP          ; Otherwise we just splashed out on a galactic
21646                                                                          ; hyperdrive, so set GHYP to &FF (as GHYP was 0 before
21647                                                                          ; the DEC instruction)
21648               
21649               et9_:
21650 64BC 0206  20        li   rtmp,dn_                   ; JSR dn            ; We are done buying equipment, so print the amount of
     64BE 64C8     
21651 64C0 06A0  28        bl   @jsr                       ;
     64C2 8002     
21652                                                                          ; cash left in the cash pot, then make a short, high
21653                                                                          ; beep to confirm the purchase, and delay for 1 second
21654               
21655 64C4 0460  28        b    @EQSHP                     ; JMP EQSHP         ; Jump back up to EQSHP to show the Equip Ship screen
     64C6 6230     
21656                                                                          ; again and see if we can't track down another bargain
21657               
21658               * ******************************************************************************
21659               *
21660               * Name: dn
21661               * Type: Subroutine
21662               * Category: Market
21663               * Summary: Print the amount of money we have left in the cash pot, then make
21664               * a short, high beep and delay for 1 second
21665               *
21666               * ******************************************************************************
21667               
21668               dn_:
21669 64C8 0206  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     64CA 5E64     
21670 64CC 06A0  28        bl   @jsr                       ;
     64CE 8002     
21671               
21672 64D0 0200  20        li   ra,>77*256                 ; LDA #119          ; Print recursive token 119 ("CASH:{cash} CR{crlf}")
     64D2 7700     
21673 64D4 0206  20        li   rtmp,spc_                  ; JSR spc           ; followed by a space
     64D6 4EFE     
21674 64D8 06A0  28        bl   @jsr                       ;
     64DA 8002     
21675               
21676                                                                          ; Fall through into dn2 to make a beep and delay for
21677                                                                          ; 1 second before returning from the subroutine
21678               
21679               * ******************************************************************************
21680               *
21681               * Name: dn2
21682               * Type: Subroutine
21683               * Category: Text
21684               * Summary: Make a short, high beep and delay for 1 second
21685               *
21686               * ******************************************************************************
21687               
21688               dn2_:
21689 64DC 0206  20        li   rtmp,BEEP                  ; JSR BEEP          ; Call the BEEP subroutine to make a short, high beep
     64DE 8BA0     
21690 64E0 06A0  28        bl   @jsr                       ;
     64E2 8002     
21691               
21692 64E4 0202  20        li   ry,>32*256                 ; LDY #50           ; Delay for 50 vertical syncs (50/50 = 1 second) and
     64E6 3200     
21693 64E8 0460  28        b    @DELAY                     ; JMP DELAY         ; return from the subroutine using a tail call
     64EA 4C00     
21694               
21695               * ******************************************************************************
21696               *
21697               * Name: eq
21698               * Type: Subroutine
21699               * Category: Equipment
21700               * Summary: Subtract the price of equipment from the cash pot
21701               *
21702               * ------------------------------------------------------------------------------
21703               *
21704               * If we have enough cash, subtract the price of a specified piece of equipment
21705               * from our cash pot and return from the subroutine. If we don't have enough
21706               * cash, exit to the docking bay (i.e. show the Status Mode screen).
21707               *
21708               * ------------------------------------------------------------------------------
21709               *
21710               * Arguments:
21711               *
21712               * A                   The item number of the piece of equipment (0-11) as
21713               * shown in the table at PRXS
21714               *
21715               * ******************************************************************************
21716               
21717               eq_:
21718 64EC 0206  20        li   rtmp,prx_                  ; JSR prx           ; Call prx to set (Y X) to the price of equipment item
     64EE 6518     
21719 64F0 06A0  28        bl   @jsr                       ;
     64F2 8002     
21720                                                                          ; number A
21721               
21722 64F4 0206  20        li   rtmp,LCASH                 ; JSR LCASH         ; Subtract (Y X) cash from the cash pot, but only if
     64F6 6166     
21723 64F8 06A0  28        bl   @jsr                       ;
     64FA 8002     
21724                                                                          ; we have enough cash
21725               
21726 64FC 1816  14        joc  c_                         ; BCS c             ; If the C flag is set then we did have enough cash for
21727                                                                          ; the transaction, so jump to c to return from the
21728                                                                          ; subroutine (as c contains an RTS)
21729               
21730 64FE 0200  20        li   ra,>c5*256                 ; LDA #197          ; Otherwise we don't have enough cash to buy this piece
     6500 C500     
21731 6502 0206  20        li   rtmp,prq_                  ; JSR prq           ; of equipment, so print recursive token 37 ("CASH")
     6504 5D52     
21732 6506 06A0  28        bl   @jsr                       ;
     6508 8002     
21733                                                                          ; followed by a question mark
21734               
21735 650A 0460  28        b    @err_                      ; JMP err           ; Jump to err to beep, pause and go to the docking bay
     650C 6458     
21736                                                                          ; (i.e. show the Status Mode screen)
21737               
21738               * ******************************************************************************
21739               *
21740               * Name: prx
21741               * Type: Subroutine
21742               * Category: Equipment
21743               * Summary: Return the price of a piece of equipment
21744               *
21745               * ------------------------------------------------------------------------------
21746               *
21747               * This routine returns the price of equipment as listed in the table at PRXS.
21748               *
21749               * ------------------------------------------------------------------------------
21750               *
21751               * Arguments:
21752               *
21753               * A                   The item number of the piece of equipment (0-11) as
21754               * shown in the table at PRXS
21755               *
21756               * ------------------------------------------------------------------------------
21757               *
21758               * Returns:
21759               *
21760               * (Y X)               The item price in Cr * 10 (Y = high byte, X = low byte)
21761               *
21762               * ------------------------------------------------------------------------------
21763               *
21764               * Other entry points:
21765               *
21766               * prx-3               Return the price of the item with number A - 1
21767               *
21768               * c                   Contains an RTS
21769               *
21770               * ******************************************************************************
21771               
21772                      .sec                            ; SEC               ; Decrement A (for when this routine is called via
     **** ****     > SEC
0001 650E 0A15  18        sla  rmone,1
                   < elite.a99
21773                      .sbi (>01*256)                  ; SBC #1            ; prx-3)
     **** ****     > SBI
0001 6510 1801  14        joc  !
0002 6512 7004  18        sb   rone,ra
0003               !:
0004 6514 0220  22        ai   ra,-(>01*256)
     6516 FF00     
                   < elite.a99
21774               
21775               prx_:
21776                      .asla                           ; ASL A             ; Set Y = A * 2, so it can act as an index into the
     **** ****     > ASLA
0001 6518 0240  22        andi ra,>ff00
     651A FF00     
0002 651C 0A10  18        sla  ra,1
                   < elite.a99
21777 651E D080  18        movb ra,ry                      ; TAY               ; PRXS table, which has two bytes per entry
21778               
21779 6520 D062  34        movb @PRXS(ry),rx               ; LDX PRXS,Y        ; Fetch the low byte of the price into X
     6522 2DF0     
21780               
21781 6524 D022  34        movb @PRXS+1(ry),ra             ; LDA PRXS+1,Y      ; Fetch the high byte of the price into A and transfer
     6526 2DF1     
21782 6528 D080  18        movb ra,ry                      ; TAY               ; it to X, so the price is now in (Y X)
21783               
21784               c_:
21785 652A 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     652C 800E     
21786               
21787               * ******************************************************************************
21788               *
21789               * Name: qv
21790               * Type: Subroutine
21791               * Category: Equipment
21792               * Summary: Print a menu of the four space views, for buying lasers
21793               *
21794               * ------------------------------------------------------------------------------
21795               *
21796               * Print a menu in the bottom-middle of the screen, at row 16, column 12, that
21797               * lists the four available space views, like this:
21798               *
21799               * 0 Front
21800               * 1 Rear
21801               * 2 Left
21802               * 3 Right
21803               *
21804               * Also print a "View ?" prompt and ask for a view number. The menu is shown
21805               * when we choose to buy a new laser in the Equip Ship screen.
21806               *
21807               * ------------------------------------------------------------------------------
21808               *
21809               * Returns:
21810               *
21811               * X                   The chosen view number (0-3)
21812               *
21813               * ******************************************************************************
21814               
21815               qv_:
21816 652E 0202  20        li   ry,>10*256                 ; LDY #16           ; Move the text cursor to row 16, and at the same time
     6530 1000     
21817 6532 D802  30        movb ry,@YC                     ; STY YC            ; set Y to a counter going from 16 to 19 in the loop
     6534 002D     
21818                                                                          ; below
21819               
21820               qv1_:
21821 6536 0201  20        li   rx,>0c*256                 ; LDX #12           ; Move the text cursor to column 12
     6538 0C00     
21822 653A D801  30        movb rx,@XC                     ; STX XC
     653C 002C     
21823               
21824 653E D002  18        movb ry,ra                      ; TYA               ; Transfer the counter value from Y to A
21825               
21826                      .clc                            ; CLC               ; Print ASCII character "0" - 16 + A, so as A goes from
     **** ****     > CLC
0001 6540 0A13  18        sla  rzero,1
                   < elite.a99
21827                      .adi (('0'-16)*256)             ; ADC #'0'-16       ; 16 to 19, this prints "0" through "3" followed by a
     **** ****     > ADI
0001 6542 1701  14        jnc  !
0002 6544 B004  18        ab   rone,ra
0003               !:
0004 6546 0220  22        ai   ra,(('0'-16)*256)
     6548 2000     
                   < elite.a99
21828 654A 0206  20        li   rtmp,spc_                  ; JSR spc           ; space
     654C 4EFE     
21829 654E 06A0  28        bl   @jsr                       ;
     6550 8002     
21830               
21831 6552 D020  30        movb @YC,ra                     ; LDA YC            ; Print recursive text token 80 + YC, so as YC goes from
     6554 002D     
21832                      .clc                            ; CLC               ; 16 to 19, this prints "FRONT", "REAR", "LEFT" and
     **** ****     > CLC
0001 6556 0A13  18        sla  rzero,1
                   < elite.a99
21833                      .adi (>50*256)                  ; ADC #80           ; "RIGHT"
     **** ****     > ADI
0001 6558 1701  14        jnc  !
0002 655A B004  18        ab   rone,ra
0003               !:
0004 655C 0220  22        ai   ra,(>50*256)
     655E 5000     
                   < elite.a99
21834 6560 0206  20        li   rtmp,TT27                  ; JSR TT27
     6562 66DC     
21835 6564 06A0  28        bl   @jsr                       ;
     6566 8002     
21836               
21837 6568 B004  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a row, and increment the
21838                                                                          ; counter in YC at the same time
21839               
21840 656A D0A0  30        movb @YC,ry                     ; LDY YC            ; Update Y with the incremented counter in YC
     656C 002D     
21841               
21842 656E 0282  22        ci   ry,>14*256                 ; CPY #20           ; If Y < 20 then loop back up to qv1 to print the next
     6570 1400     
21843 6572 17E1  14        jnc  qv1_                       ; BCC qv1           ; view in the menu
21844               
21845               qv3_:
21846 6574 0206  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     6576 4C2E     
21847 6578 06A0  28        bl   @jsr                       ;
     657A 8002     
21848                                                                          ; and move the text cursor to column 1 on row 21, i.e.
21849                                                                          ; the start of the top row of the three bottom rows
21850               
21851               qv2_:
21852 657C 0200  20        li   ra,>af*256                 ; LDA #175          ; Print recursive text token 15 ("VIEW ") followed by
     657E AF00     
21853 6580 0206  20        li   rtmp,prq_                  ; JSR prq           ; a question mark
     6582 5D52     
21854 6584 06A0  28        bl   @jsr                       ;
     6586 8002     
21855               
21856 6588 0206  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     658A 8DF4     
21857 658C 06A0  28        bl   @jsr                       ;
     658E 8002     
21858                                                                          ; the key's ASCII code in A (and X)
21859               
21860                      .sec                            ; SEC               ; Subtract ASCII "0" from the key pressed, to leave the
     **** ****     > SEC
0001 6590 0A15  18        sla  rmone,1
                   < elite.a99
21861                      .sbi (('0')*256)                ; SBC #'0'          ; numeric value of the key in A (if it was a number key)
     **** ****     > SBI
0001 6592 1801  14        joc  !
0002 6594 7004  18        sb   rone,ra
0003               !:
0004 6596 0220  22        ai   ra,-(('0')*256)
     6598 D000     
                   < elite.a99
21862               
21863 659A 0280  22        ci   ra,>04*256                 ; CMP #4            ; If the number entered in A >= 4, then it is not a
     659C 0400     
21864 659E 18EA  14        joc  qv3_                       ; BCS qv3           ; valid view number, so jump back to qv3 to try again
21865               
21866 65A0 D040  18        movb ra,rx                      ; TAX               ; We have a valid view number, so transfer it to X
21867               
21868 65A2 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     65A4 800E     
21869               
21870               * ******************************************************************************
21871               *
21872               * Save ELTD.bin
21873               *
21874               * ******************************************************************************
21875               
21876                      ; PRINT "ELITE D"
21877                      ; PRINT "Assembled at ", ~CODE_D%
21878                      ; PRINT "Ends at ", ~P%
21879                      ; PRINT "Code size is ", ~(P% - CODE_D%)
21880                      ; PRINT "Execute at ", ~LOAD%
21881                      ; PRINT "Reload at ", ~LOAD_D%
21882               
21883                      ; PRINT "S.ELTD ", ~CODE_D%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_D%
21884                      ; SAVE "3-assembled-output/ELTD.bin", CODE_D%, P%, LOAD%
21885               
21886               * ******************************************************************************
21887               *
21888               * ELITE E FILE
21889               *
21890               * Produces the binary file ELTE.bin that gets loaded by elite-bcfs.asm.
21891               *
21892               * ******************************************************************************
21893               
21894               CODE_E.:
21895                      equ $
21896               
21897               LOAD_E.:
21898                      equ LOAD. + $ - CODE.
21899               
21900               * ******************************************************************************
21901               *
21902               * Name: Authors' names
21903               * Type: Variable
21904               * Category: Copy protection
21905               * Summary: The authors' names and a copyright notice, buried in the code
21906               *
21907               * ------------------------------------------------------------------------------
21908               *
21909               * This copyright notice is not used anywhere and it is obfuscated by EOR'ing
21910               * each character with 164, but presumably the authors wanted their names buried
21911               * in the code somewhere. Though they do also have recursive token 94, which
21912               * reads "BY D.BRABEN & I.BELL" and can be displayed on the title screen using
21913               * the "X" configuration option, so this isn't the only author name easter egg
21914               * in the game. It contains the following text:
21915               *
21916               * (C)Bell/Braben1984
21917               *
21918               * ******************************************************************************
21919               
21920 65A6 8C              byte '(' ^ 164
21921 65A7   E7            byte 'C' ^ 164
21922 65A8 8D              byte ')' ^ 164
21923 65A9   E6            byte 'B' ^ 164
21924 65AA C1              byte 'e' ^ 164
21925 65AB   C8            byte 'l' ^ 164
21926 65AC C8              byte 'l' ^ 164
21927 65AD   8B            byte '/' ^ 164
21928 65AE E6              byte 'B' ^ 164
21929 65AF   D6            byte 'r' ^ 164
21930 65B0 C5              byte 'a' ^ 164
21931 65B1   C6            byte 'b' ^ 164
21932 65B2 C1              byte 'e' ^ 164
21933 65B3   CA            byte 'n' ^ 164
21934 65B4 95              byte '1' ^ 164
21935 65B5   9D            byte '9' ^ 164
21936 65B6 9C              byte '8' ^ 164
21937 65B7   90            byte '4' ^ 164
21938               
21939               * ******************************************************************************
21940               *
21941               * Name: cpl
21942               * Type: Subroutine
21943               * Category: Universe
21944               * Summary: Print the selected system name
21945               * Deep dive: Generating system names
21946               * Galaxy and system seeds
21947               *
21948               * ------------------------------------------------------------------------------
21949               *
21950               * Print control code 3 (the selected system name, i.e. the one in the crosshairs
21951               * in the Short-range Chart).
21952               *
21953               * ******************************************************************************
21954               
21955               cpl_:
21956 65B8 0201  20        li   rx,>05*256                 ; LDX #5            ; First we need to back up the seeds in QQ15, so set up
     65BA 0500     
21957                                                                          ; a counter in X to cover three 16-bit seeds (i.e.
21958                                                                          ; 6 bytes)
21959               
21960               TT53:
21961 65BC D021  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy byte X from QQ15 to QQ19
     65BE 0078     
21962 65C0 D840  38        movb ra,@QQ19(rx)               ; STA QQ19,X
     65C2 007F     
21963               
21964 65C4 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
21965               
21966 65C6 15FA  14        jgt  TT53                       ; BPL TT53          ; Loop back for the next byte to back up
21967               
21968 65C8 0202  20        li   ry,>03*256                 ; LDY #3            ; Step 1: Now that the seeds are backed up, we can
     65CA 0300     
21969                                                                          ; start the name-generation process. We will either
21970                                                                          ; need to loop three or four times, so for now set
21971                                                                          ; up a counter in Y to loop four times
21972               
21973                      .bit @QQ15                      ; BIT QQ15          ; Check bit 6 of s0_lo, which is stored in QQ15
     **** ****     > BIT
0001 65CC D1A0  30        movb @QQ15,rtmp
     65CE 0078     
0002 65D0 0546  14        inv  rtmp
0003 65D2 D1C4  18        movb rone,rtmp2
0004 65D4 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
21974               
21975                      .bvs B59                        ; BVS B59           ; If bit 6 is set then skip over the next instruction
     **** ****     > BVS
0001 65D6 1801  14        joc  !
0002 65D8 1001  14        jmp  B59
0003               !:
                   < elite.a99
21976               
21977 65DA 7084  18        sb   rone,ry                    ; DEY               ; Bit 6 is clear, so we only want to loop three times,
21978                                                                          ; so decrement the loop counter in Y
21979               
21980               B59:
21981 65DC D802  30        movb ry,@T                      ; STY T             ; Store the loop counter in T
     65DE 00D1     
21982               
21983               TT55:
21984 65E0 D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Step 2: Load s2_hi, which is stored in QQ15+5, and
     65E2 007D     
21985 65E4 0240  22        andi ra,>1f*256                 ; AND #%00011111    ; extract bits 0-4 by AND'ing with %11111
     65E6 1F00     
21986               
21987 65E8 1306  14        jeq  B60                        ; BEQ B60           ; If all those bits are zero, then skip the following
21988                                                                          ; two instructions to go to step 3
21989               
21990 65EA 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now have a number in the range 1-31, which we can
     65EC 8000     
21991                                                                          ; easily convert into a two-letter token, but first we
21992                                                                          ; need to add 128 (or set bit 7) to get a range of
21993                                                                          ; 129-159
21994               
21995 65EE 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the two-letter token in A
     65F0 66DC     
21996 65F2 06A0  28        bl   @jsr                       ;
     65F4 8002     
21997               
21998               B60:
21999 65F6 0206  20        li   rtmp,TT54                  ; JSR TT54          ; Step 3: twist the seeds in QQ15
     65F8 4E42     
22000 65FA 06A0  28        bl   @jsr                       ;
     65FC 8002     
22001               
22002 65FE 7004  18        sb   rone,ra                    ; DEC T             ; Decrement the loop counter
22003               
22004 6600 15EF  14        jgt  TT55                       ; BPL TT55          ; Loop back for the next two letters
22005               
22006 6602 0201  20        li   rx,>05*256                 ; LDX #5            ; We have printed the system name, so we can now
     6604 0500     
22007                                                                          ; restore the seeds we backed up earlier. Set up a
22008                                                                          ; counter in X to cover three 16-bit seeds (i.e. 6
22009                                                                          ; bytes)
22010               
22011               TT56:
22012 6606 D021  34        movb @QQ19(rx),ra               ; LDA QQ19,X        ; Copy byte X from QQ19 to QQ15
     6608 007F     
22013 660A D840  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     660C 0078     
22014               
22015 660E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22016               
22017 6610 15FA  14        jgt  TT56                       ; BPL TT56          ; Loop back for the next byte to restore
22018               
22019 6612 0460  24        b    @rts                       ; RTS               ; Once all the seeds are restored, return from the
     6614 800E     
22020                                                                          ; subroutine
22021               
22022               * ******************************************************************************
22023               *
22024               * Name: cmn
22025               * Type: Subroutine
22026               * Category: Status
22027               * Summary: Print the commander's name
22028               *
22029               * ------------------------------------------------------------------------------
22030               *
22031               * Print control code 4 (the commander's name).
22032               *
22033               * ------------------------------------------------------------------------------
22034               *
22035               * Other entry points:
22036               *
22037               * cmn-1               Contains an RTS
22038               *
22039               * ******************************************************************************
22040               
22041               cmn_:
22042 6616 0202  20        li   ry,>00*256                 ; LDY #0            ; Set up a counter in Y, starting from 0
     6618 0000     
22043               
22044               QUL4:
22045 661A D022  34        movb @NA.(ry),ra                ; LDA NA%,Y         ; The commander's name is stored at NA%, so load the
     661C 21C8     
22046                                                                          ; Y-th character from NA%
22047               
22048 661E 0280  22        ci   ra,>0d*256                 ; CMP #13           ; If we have reached the end of the name, return from
     6620 0D00     
22049 6622 1307  14        jeq  ypl_-1                     ; BEQ ypl-1         ; the subroutine (ypl-1 points to the RTS below)
22050               
22051 6624 0206  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character we just loaded
     6626 3172     
22052 6628 06A0  28        bl   @jsr                       ;
     662A 8002     
22053               
22054 662C B084  18        ab   rone,ry                    ; INY               ; Increment the loop counter
22055               
22056 662E 16F5  14        jne  QUL4                       ; BNE QUL4          ; Loop back for the next character
22057               
22058 6630 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6632 800E     
22059               
22060               * ******************************************************************************
22061               *
22062               * Name: ypl
22063               * Type: Subroutine
22064               * Category: Universe
22065               * Summary: Print the current system name
22066               *
22067               * ------------------------------------------------------------------------------
22068               *
22069               * Print control code 2 (the current system name).
22070               *
22071               * ------------------------------------------------------------------------------
22072               *
22073               * Other entry points:
22074               *
22075               * ypl-1               Contains an RTS
22076               *
22077               * ******************************************************************************
22078               
22079               ypl_:
22080 6634 D020  30        movb @MJ,ra                     ; LDA MJ            ; Check the mis-jump flag at MJ, and if it is non-zero
     6636 0D5C     
22081 6638 16ED  14        jne  cmn_-1                     ; BNE cmn-1         ; then we are in witchspace, and witchspace doesn't have
22082                                                                          ; a system name, so return from the subroutine (cmn-1
22083                                                                          ; contains an RTS)
22084               
22085 663A 0206  20        li   rtmp,TT62                  ; JSR TT62          ; Call TT62 below to swap the three 16-bit seeds in
     663C 664A     
22086 663E 06A0  28        bl   @jsr                       ;
     6640 8002     
22087                                                                          ; QQ2 and QQ15 (before the swap, QQ2 contains the seeds
22088                                                                          ; for the current system, while QQ15 contains the seeds
22089                                                                          ; for the selected system)
22090               
22091 6642 0206  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print out the system name for the seeds
     6644 65B8     
22092 6646 06A0  28        bl   @jsr                       ;
     6648 8002     
22093                                                                          ; in QQ15 (which now contains the seeds for the current
22094                                                                          ; system)
22095               
22096                                                                          ; Now we fall through into the TT62 subroutine, which
22097                                                                          ; will swap QQ2 and QQ15 once again, so everything goes
22098                                                                          ; back into the right place, and the RTS at the end of
22099                                                                          ; TT62 will return from the subroutine
22100               
22101               TT62:
22102 664A 0201  20        li   rx,>05*256                 ; LDX #5            ; Set up a counter in X for the three 16-bit seeds we
     664C 0500     
22103                                                                          ; want to swap (i.e. 6 bytes)
22104               
22105               TT78:
22106 664E D021  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Swap byte X between QQ2 and QQ15
     6650 0078     
22107 6652 D0A1  34        movb @QQ2(rx),ry                ; LDY QQ2,X
     6654 0F22     
22108 6656 D840  38        movb ra,@QQ2(rx)                ; STA QQ2,X
     6658 0F22     
22109 665A D842  38        movb ry,@QQ15(rx)               ; STY QQ15,X
     665C 0078     
22110               
22111 665E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22112               
22113 6660 15F6  14        jgt  TT78                       ; BPL TT78          ; Loop back for the next byte to swap
22114               
22115 6662 0460  24        b    @rts                       ; RTS               ; Once all bytes are swapped, return from the
     6664 800E     
22116                                                                          ; subroutine
22117               
22118               * ******************************************************************************
22119               *
22120               * Name: tal
22121               * Type: Subroutine
22122               * Category: Universe
22123               * Summary: Print the current galaxy number
22124               *
22125               * ------------------------------------------------------------------------------
22126               *
22127               * Print control code 1 (the current galaxy number, right-aligned to width 3).
22128               *
22129               * ******************************************************************************
22130               
22131               tal_:
22132                      .clc                            ; CLC               ; We don't want to print the galaxy number with a
     **** ****     > CLC
0001 6666 0A13  18        sla  rzero,1
                   < elite.a99
22133                                                                          ; decimal point, so clear the C flag for pr2 to take as
22134                                                                          ; an argument
22135               
22136 6668 D060  30        movb @GCNT,rx                   ; LDX GCNT          ; Load the current galaxy number from GCNT into X
     666A 030F     
22137               
22138 666C B044  18        ab   rone,rx                    ; INX               ; Add 1 to the galaxy number, as the galaxy numbers
22139                                                                          ; are 0-7 internally, but we want to display them as
22140                                                                          ; galaxy 1 through 8
22141               
22142 666E 0460  28        b    @pr2_                      ; JMP pr2           ; Jump to pr2, which prints the number in X to a width
     6670 2FAC     
22143                                                                          ; of 3 figures, left-padding with spaces to a width of
22144                                                                          ; 3, and return from the subroutine using a tail call
22145               
22146               * ******************************************************************************
22147               *
22148               * Name: fwl
22149               * Type: Subroutine
22150               * Category: Status
22151               * Summary: Print fuel and cash levels
22152               *
22153               * ------------------------------------------------------------------------------
22154               *
22155               * Print control code 5 ("FUEL: ", fuel level, " LIGHT YEARS", newline, "CASH:",
22156               * control code 0).
22157               *
22158               * ******************************************************************************
22159               
22160               fwl_:
22161 6672 0200  20        li   ra,>69*256                 ; LDA #105          ; Print recursive token 105 ("FUEL") followed by a
     6674 6900     
22162 6676 0206  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     6678 66D0     
22163 667A 06A0  28        bl   @jsr                       ;
     667C 8002     
22164               
22165 667E D060  30        movb @QQ14,rx                   ; LDX QQ14          ; Load the current fuel level from QQ14
     6680 030D     
22166               
22167                      .sec                            ; SEC               ; We want to print the fuel level with a decimal point,
     **** ****     > SEC
0001 6682 0A15  18        sla  rmone,1
                   < elite.a99
22168                                                                          ; so set the C flag for pr2 to take as an argument
22169               
22170 6684 0206  20        li   rtmp,pr2_                  ; JSR pr2           ; Call pr2, which prints the number in X to a width of
     6686 2FAC     
22171 6688 06A0  28        bl   @jsr                       ;
     668A 8002     
22172                                                                          ; 3 figures (i.e. in the format x.x, which will always
22173                                                                          ; be exactly 3 characters as the maximum fuel is 7.0)
22174               
22175 668C 0200  20        li   ra,>c3*256                 ; LDA #195          ; Print recursive token 35 ("LIGHT YEARS") followed by
     668E C300     
22176 6690 0206  20        li   rtmp,plf_                  ; JSR plf           ; a newline
     6692 66C4     
22177 6694 06A0  28        bl   @jsr                       ;
     6696 8002     
22178               
22179               PCASH:
22180 6698 0200  20        li   ra,>77*256                 ; LDA #119          ; Print recursive token 119 ("CASH:" then control code
     669A 7700     
22181 669C 161F  14        jne  TT27                       ; BNE TT27          ; 0, which prints cash levels, then " CR" and newline)
22182               
22183               * ******************************************************************************
22184               *
22185               * Name: csh
22186               * Type: Subroutine
22187               * Category: Status
22188               * Summary: Print the current amount of cash
22189               *
22190               * ------------------------------------------------------------------------------
22191               *
22192               * Print control code 0 (the current amount of cash, right-aligned to width 9,
22193               * followed by " CR" and a newline).
22194               *
22195               * ******************************************************************************
22196               
22197               csh_:
22198 669E 0201  20        li   rx,>03*256                 ; LDX #3            ; We are going to use the BPRNT routine to print out
     66A0 0300     
22199                                                                          ; the current amount of cash, which is stored as a
22200                                                                          ; 32-bit number at location CASH. BPRNT prints out
22201                                                                          ; the 32-bit number stored in K, so before we call
22202                                                                          ; BPRNT, we need to copy the four bytes from CASH into
22203                                                                          ; K, so first we set up a counter in X for the 4 bytes
22204               
22205               pc1_:
22206 66A2 D021  34        movb @CASH(rx),ra               ; LDA CASH,X        ; Copy byte X from CASH to K
     66A4 0309     
22207 66A6 D840  38        movb ra,@K(rx)                  ; STA K,X
     66A8 003D     
22208               
22209 66AA 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22210               
22211 66AC 15FA  14        jgt  pc1_                       ; BPL pc1           ; Loop back for the next byte to copy
22212               
22213 66AE 0200  20        li   ra,>09*256                 ; LDA #9            ; We want to print the cash amount using up to 9 digits
     66B0 0900     
22214 66B2 D800  30        movb ra,@U                      ; STA U             ; (including the decimal point), so store this in U
     66B4 008F     
22215                                                                          ; for BRPNT to take as an argument
22216               
22217                      .sec                            ; SEC               ; We want to print the cash amount with a decimal point,
     **** ****     > SEC
0001 66B6 0A15  18        sla  rmone,1
                   < elite.a99
22218                                                                          ; so set the C flag for BRPNT to take as an argument
22219               
22220 66B8 0206  20        li   rtmp,BPRNT                 ; JSR BPRNT         ; Print the amount of cash to 9 digits with a decimal
     66BA 2FCC     
22221 66BC 06A0  28        bl   @jsr                       ;
     66BE 8002     
22222                                                                          ; point
22223               
22224 66C0 0200  20        li   ra,>e2*256                 ; LDA #226          ; Print recursive token 66 (" CR") followed by a
     66C2 E200     
22225                                                                          ; newline by falling through into plf
22226               
22227               * ******************************************************************************
22228               *
22229               * Name: plf
22230               * Type: Subroutine
22231               * Category: Text
22232               * Summary: Print a text token followed by a newline
22233               *
22234               * ------------------------------------------------------------------------------
22235               *
22236               * Arguments:
22237               *
22238               * A                   The text token to be printed
22239               *
22240               * ******************************************************************************
22241               
22242               plf_:
22243 66C4 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     66C6 66DC     
22244 66C8 06A0  28        bl   @jsr                       ;
     66CA 8002     
22245               
22246 66CC 0460  28        b    @TT67                      ; JMP TT67          ; Jump to TT67 to print a newline and return from the
     66CE 4EE6     
22247                                                                          ; subroutine using a tail call
22248               
22249               * ******************************************************************************
22250               *
22251               * Name: TT68
22252               * Type: Subroutine
22253               * Category: Text
22254               * Summary: Print a text token followed by a colon
22255               *
22256               * ------------------------------------------------------------------------------
22257               *
22258               * Arguments:
22259               *
22260               * A                   The text token to be printed
22261               *
22262               * ******************************************************************************
22263               
22264               TT68:
22265 66D0 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A and fall through into TT73
     66D2 66DC     
22266 66D4 06A0  28        bl   @jsr                       ;
     66D6 8002     
22267                                                                          ; to print a colon
22268               
22269               * ******************************************************************************
22270               *
22271               * Name: TT73
22272               * Type: Subroutine
22273               * Category: Text
22274               * Summary: Print a colon
22275               *
22276               * ******************************************************************************
22277               
22278               TT73:
22279 66D8 0200  20        li   ra,(':')*256               ; LDA #':'          ; Set A to ASCII ":" and fall through into TT27 to
     66DA 3A00     
22280                                                                          ; actually print the colon
22281               
22282               * ******************************************************************************
22283               *
22284               * Name: TT27
22285               * Type: Subroutine
22286               * Category: Text
22287               * Summary: Print a text token
22288               * Deep dive: Printing text tokens
22289               *
22290               * ------------------------------------------------------------------------------
22291               *
22292               * Print a text token (i.e. a character, control code, two-letter token or
22293               * recursive token).
22294               *
22295               * ------------------------------------------------------------------------------
22296               *
22297               * Arguments:
22298               *
22299               * A                   The text token to be printed
22300               *
22301               * ******************************************************************************
22302               
22303               TT27:
22304 66DC D040  18        movb ra,rx                      ; TAX               ; Copy the token number from A to X. We can then keep
22305                                                                          ; decrementing X and testing it against zero, while
22306                                                                          ; keeping the original token number intact in A; this
22307                                                                          ; effectively implements a switch statement on the
22308                                                                          ; value of the token
22309               
22310 66DE 13DF  14        jeq  csh_                       ; BEQ csh           ; If token = 0, this is control code 0 (current amount
22311                                                                          ; of cash and newline), so jump to csh to print the
22312                                                                          ; amount of cash and return from the subroutine using
22313                                                                          ; a tail call
22314               
22315 66E0 116E  14        jlt  TT43                       ; BMI TT43          ; If token > 127, this is either a two-letter token
22316                                                                          ; (128-159) or a recursive token (160-255), so jump
22317                                                                          ; to TT43 to process tokens
22318               
22319 66E2 7044  18        sb   rone,rx                    ; DEX               ; If token = 1, this is control code 1 (current galaxy
22320 66E4 13C0  14        jeq  tal_                       ; BEQ tal           ; number), so jump to tal to print the galaxy number and
22321                                                                          ; return from the subroutine using a tail call
22322               
22323 66E6 7044  18        sb   rone,rx                    ; DEX               ; If token = 2, this is control code 2 (current system
22324 66E8 13A5  14        jeq  ypl_                       ; BEQ ypl           ; name), so jump to ypl to print the current system name
22325                                                                          ; and return from the subroutine using a tail call
22326               
22327 66EA 7044  18        sb   rone,rx                    ; DEX               ; If token > 3, skip the following instruction
22328 66EC 1602  14        jne  B61                        ; BNE B61
22329               
22330 66EE 0460  28        b    @cpl_                      ; JMP cpl           ; This token is control code 3 (selected system name)
     66F0 65B8     
22331                                                                          ; so jump to cpl to print the selected system name
22332                                                                          ; and return from the subroutine using a tail call
22333               
22334               B61:
22335 66F2 7044  18        sb   rone,rx                    ; DEX               ; If token = 4, this is control code 4 (commander
22336 66F4 1390  14        jeq  cmn_                       ; BEQ cmn           ; name), so jump to cmm to print the commander name
22337                                                                          ; and return from the subroutine using a tail call
22338               
22339 66F6 7044  18        sb   rone,rx                    ; DEX               ; If token = 5, this is control code 5 (fuel, newline,
22340 66F8 13BC  14        jeq  fwl_                       ; BEQ fwl           ; cash, newline), so jump to fwl to print the fuel level
22341                                                                          ; and return from the subroutine using a tail call
22342               
22343 66FA 7044  18        sb   rone,rx                    ; DEX               ; If token > 6, skip the following three instructions
22344 66FC 1606  14        jne  B62                        ; BNE B62
22345               
22346 66FE 0200  20        li   ra,>80*256                 ; LDA #%10000000    ; This token is control code 6 (switch to Sentence
     6700 8000     
22347 6702 D800  30        movb ra,@QQ17                   ; STA QQ17          ; Case), so set bit 7 of QQ17 to switch to Sentence Case
     6704 007E     
22348 6706 0460  24        b    @rts                       ; RTS               ; and return from the subroutine as we are done
     6708 800E     
22349               
22350               B62:
22351 670A 7044  18        sb   rone,rx                    ; DEX               ; If token > 8, skip the following two instructions
22352 670C 7044  18        sb   rone,rx                    ; DEX
22353 670E 1604  14        jne  B63                        ; BNE B63
22354               
22355 6710 D801  30        movb rx,@QQ17                   ; STX QQ17          ; This token is control code 8 (switch to ALL CAPS), so
     6712 007E     
22356 6714 0460  24        b    @rts                       ; RTS               ; set QQ17 to 0 to switch to ALL CAPS and return from
     6716 800E     
22357                                                                          ; the subroutine as we are done
22358               
22359               B63:
22360 6718 7044  18        sb   rone,rx                    ; DEX               ; If token = 9, this is control code 9 (tab to column
22361 671A 1339  14        jeq  crlf_                      ; BEQ crlf          ; 21 and print a colon), so jump to crlf
22362               
22363 671C 0280  22        ci   ra,>60*256                 ; CMP #96           ; By this point, token is either 7, or in 10-127.
     671E 6000     
22364 6720 186A  14        joc  ex_                        ; BCS ex            ; Check token number in A and if token >= 96, then the
22365                                                                          ; token is in 96-127, which is a recursive token, so
22366                                                                          ; jump to ex, which prints recursive tokens in this
22367                                                                          ; range (i.e. where the recursive token number is
22368                                                                          ; correct and doesn't need correcting)
22369               
22370 6722 0280  22        ci   ra,>0e*256                 ; CMP #14           ; If token < 14, skip the following two instructions
     6724 0E00     
22371 6726 1703  14        jnc  B64                        ; BCC B64
22372               
22373 6728 0280  22        ci   ra,>20*256                 ; CMP #32           ; If token < 32, then this means token is in 14-31, so
     672A 2000     
22374 672C 172B  14        jnc  qw_                        ; BCC qw            ; this is a recursive token that needs 114 adding to it
22375                                                                          ; to get the recursive token number, so jump to qw
22376                                                                          ; which will do this
22377               
22378                                                                          ; By this point, token is either 7 (beep) or in 10-13
22379                                                                          ; (line feeds and carriage returns), or in 32-95
22380                                                                          ; (ASCII letters, numbers and punctuation)
22381               
22382               B64:
22383 672E D060  30        movb @QQ17,rx                   ; LDX QQ17          ; Fetch QQ17, which controls letter case, into X
     6730 007E     
22384               
22385 6732 1343  14        jeq  TT74                       ; BEQ TT74          ; If QQ17 = 0, then ALL CAPS is set, so jump to TT74
22386                                                                          ; to print this character as is (i.e. as a capital)
22387               
22388 6734 1113  14        jlt  TT41                       ; BMI TT41          ; If QQ17 has bit 7 set, then we are using Sentence
22389                                                                          ; Case, so jump to TT41, which will print the
22390                                                                          ; character in upper or lower case, depending on
22391                                                                          ; whether this is the first letter in a word
22392               
22393                      .bit @QQ17                      ; BIT QQ17          ; If we get here, QQ17 is not 0 and bit 7 is clear, so
     **** ****     > BIT
0001 6736 D1A0  30        movb @QQ17,rtmp
     6738 007E     
0002 673A 0546  14        inv  rtmp
0003 673C D1C4  18        movb rone,rtmp2
0004 673E 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
22394                      .bvs TT46                       ; BVS TT46          ; either it is bit 6 that is set, or some other flag in
     **** ****     > BVS
0001 6740 1801  14        joc  !
0002 6742 1032  14        jmp  TT46
0003               !:
                   < elite.a99
22395                                                                          ; QQ17 is set (bits 0-5). So check whether bit 6 is set.
22396                                                                          ; If it is, then ALL CAPS has been set (as bit 7 is
22397                                                                          ; clear) but bit 6 is still indicating that the next
22398                                                                          ; character should be printed in lower case, so we need
22399                                                                          ; to fix this. We do this with a jump to TT46, which
22400                                                                          ; will print this character in upper case and clear bit
22401                                                                          ; 6, so the flags are consistent with ALL CAPS going
22402                                                                          ; forward
22403               
22404                                                                          ; If we get here, some other flag is set in QQ17 (one
22405                                                                          ; of bits 0-5 is set), which shouldn't happen in this
22406                                                                          ; version of Elite. If this were the case, then we
22407                                                                          ; would fall through into TT42 to print in lower case,
22408                                                                          ; which is how printing all words in lower case could
22409                                                                          ; be supported (by setting QQ17 to 1, say)
22410               
22411               * ******************************************************************************
22412               *
22413               * Name: TT42
22414               * Type: Subroutine
22415               * Category: Text
22416               * Summary: Print a letter in lower case
22417               *
22418               * ------------------------------------------------------------------------------
22419               *
22420               * Arguments:
22421               *
22422               * A                   The character to be printed. Can be one of the
22423               * following:
22424               *
22425               * * 7 (beep)
22426               *
22427               * * 10-13 (line feeds and carriage returns)
22428               *
22429               * * 32-95 (ASCII capital letters, numbers and
22430               * punctuation)
22431               *
22432               * ------------------------------------------------------------------------------
22433               *
22434               * Other entry points:
22435               *
22436               * TT44                Jumps to TT26 to print the character in A (used to
22437               * enable us to use a branch instruction to jump to TT26)
22438               *
22439               * ******************************************************************************
22440               
22441               TT42:
22442 6744 0280  22        ci   ra,('A')*256               ; CMP #'A'          ; If A < ASCII "A", then this is punctuation, so jump
     6746 4100     
22443 6748 1707  14        jnc  TT44                       ; BCC TT44          ; to TT26 (via TT44) to print the character as is, as
22444                                                                          ; we don't care about the character's case
22445               
22446 674A 0280  22        ci   ra,('Z'+1)*256             ; CMP #'Z'+1        ; If A >= (ASCII "Z" + 1), then this is also
     674C 5B00     
22447 674E 1804  14        joc  TT44                       ; BCS TT44          ; punctuation, so jump to TT26 (via TT44) to print the
22448                                                                          ; character as is, as we don't care about the
22449                                                                          ; character's case
22450               
22451                      .adi (>20*256)                  ; ADC #32           ; Add 32 to the character, to convert it from upper to
     **** ****     > ADI
0001 6750 1701  14        jnc  !
0002 6752 B004  18        ab   rone,ra
0003               !:
0004 6754 0220  22        ai   ra,(>20*256)
     6756 2000     
                   < elite.a99
22452                                                                          ; lower case
22453               
22454               TT44:
22455 6758 0460  28        b    @TT26                      ; JMP TT26          ; Print the character in A
     675A 3172     
22456               
22457               * ******************************************************************************
22458               *
22459               * Name: TT41
22460               * Type: Subroutine
22461               * Category: Text
22462               * Summary: Print a letter according to Sentence Case
22463               *
22464               * ------------------------------------------------------------------------------
22465               *
22466               * The rules for printing in Sentence Case are as follows:
22467               *
22468               * * If QQ17 bit 6 is set, print lower case (via TT45)
22469               *
22470               * * If QQ17 bit 6 is clear, then:
22471               *
22472               * * If character is punctuation, just print it
22473               *
22474               * * If character is a letter, set QQ17 bit 6 and print letter as a capital
22475               *
22476               * ------------------------------------------------------------------------------
22477               *
22478               * Arguments:
22479               *
22480               * A                   The character to be printed. Can be one of the
22481               * following:
22482               *
22483               * * 7 (beep)
22484               *
22485               * * 10-13 (line feeds and carriage returns)
22486               *
22487               * * 32-95 (ASCII capital letters, numbers and
22488               * punctuation)
22489               *
22490               * X                   Contains the current value of QQ17
22491               *
22492               * QQ17                Bit 7 is set
22493               *
22494               * ******************************************************************************
22495               
22496               TT41:
22497                                                                          ; If we get here, then QQ17 has bit 7 set, so we are in
22498                                                                          ; Sentence Case
22499                      .bit @QQ17                      ; BIT QQ17          ; If QQ17 also has bit 6 set, jump to TT45 to print
     **** ****     > BIT
0001 675C D1A0  30        movb @QQ17,rtmp
     675E 007E     
0002 6760 0546  14        inv  rtmp
0003 6762 D1C4  18        movb rone,rtmp2
0004 6764 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
22500                      .bvs TT45                       ; BVS TT45          ; this character in lower case
     **** ****     > BVS
0001 6766 1801  14        joc  !
0002 6768 1017  14        jmp  TT45
0003               !:
                   < elite.a99
22501               
22502                                                                          ; If we get here, then QQ17 has bit 6 clear and bit 7
22503                                                                          ; set, so we are in Sentence Case and we need to print
22504                                                                          ; the next letter in upper case
22505               
22506 676A 0280  22        ci   ra,('A')*256               ; CMP #'A'          ; If A < ASCII "A", then this is punctuation, so jump
     676C 4100     
22507 676E 1725  14        jnc  TT74                       ; BCC TT74          ; to TT26 (via TT44) to print the character as is, as
22508                                                                          ; we don't care about the character's case
22509               
22510                      .pha                            ; PHA               ; Otherwise this is a letter, so store the token number
     **** ****     > PHA
0001 6770 D680  30        movb ra,*rsp
0002 6772 060A  14        dec  rsp
                   < elite.a99
22511               
22512 6774 D001  18        movb rx,ra                      ; TXA               ; Set bit 6 in QQ17 (X contains the current QQ17)
22513 6776 0260  22        ori  ra,>40*256                 ; ORA #%1000000     ; so the next letter after this one is printed in lower
     6778 4000     
22514 677A D800  30        movb ra,@QQ17                   ; STA QQ17          ; case
     677C 007E     
22515               
22516                      .pla                            ; PLA               ; Restore the token number into A
     **** ****     > PLA
0001 677E 058A  14        inc  rsp
0002 6780 D01A  26        movb *rsp,ra
                   < elite.a99
22517               
22518 6782 16EA  14        jne  TT44                       ; BNE TT44          ; Jump to TT26 (via TT44) to print the character in A
22519                                                                          ; (this BNE is effectively a JMP as A will never be
22520                                                                          ; zero)
22521               
22522               * ******************************************************************************
22523               *
22524               * Name: qw
22525               * Type: Subroutine
22526               * Category: Text
22527               * Summary: Print a recursive token in the range 128-145
22528               *
22529               * ------------------------------------------------------------------------------
22530               *
22531               * Print a recursive token where the token number is in 128-145 (so the value
22532               * passed to TT27 is in the range 14-31).
22533               *
22534               * ------------------------------------------------------------------------------
22535               *
22536               * Arguments:
22537               *
22538               * A                   A value from 128-145, which refers to a recursive token
22539               * in the range 14-31
22540               *
22541               * ******************************************************************************
22542               
22543               qw_:
22544                      .adi (>72*256)                  ; ADC #114          ; This is a recursive token in the range 0-95, so add
     **** ****     > ADI
0001 6784 1701  14        jnc  !
0002 6786 B004  18        ab   rone,ra
0003               !:
0004 6788 0220  22        ai   ra,(>72*256)
     678A 7200     
                   < elite.a99
22545 678C 1634  14        jne  ex_                        ; BNE ex            ; 114 to the argument to get the token number 128-145
22546                                                                          ; and jump to ex to print it
22547               
22548               * ******************************************************************************
22549               *
22550               * Name: crlf
22551               * Type: Subroutine
22552               * Category: Text
22553               * Summary: Tab to column 21 and print a colon
22554               *
22555               * ------------------------------------------------------------------------------
22556               *
22557               * Print control code 9 (tab to column 21 and print a colon). The subroutine
22558               * name is pretty misleading, as it doesn't have anything to do with carriage
22559               * returns or line feeds.
22560               *
22561               * ******************************************************************************
22562               
22563               crlf_:
22564 678E 0200  20        li   ra,>15*256                 ; LDA #21           ; Set the X-column in XC to 21
     6790 1500     
22565 6792 D800  30        movb ra,@XC                     ; STA XC
     6794 002C     
22566               
22567 6796 16A0  14        jne  TT73                       ; BNE TT73          ; Jump to TT73, which prints a colon (this BNE is
22568                                                                          ; effectively a JMP as A will never be zero)
22569               
22570               * ******************************************************************************
22571               *
22572               * Name: TT45
22573               * Type: Subroutine
22574               * Category: Text
22575               * Summary: Print a letter in lower case
22576               *
22577               * ------------------------------------------------------------------------------
22578               *
22579               * This routine prints a letter in lower case. Specifically:
22580               *
22581               * * If QQ17 = 255, abort printing this character as printing is disabled
22582               *
22583               * * If this is a letter then print in lower case
22584               *
22585               * * Otherwise this is punctuation, so clear bit 6 in QQ17 and print
22586               *
22587               * ------------------------------------------------------------------------------
22588               *
22589               * Arguments:
22590               *
22591               * A                   The character to be printed. Can be one of the
22592               * following:
22593               *
22594               * * 7 (beep)
22595               *
22596               * * 10-13 (line feeds and carriage returns)
22597               *
22598               * * 32-95 (ASCII capital letters, numbers and
22599               * punctuation)
22600               *
22601               * X                   Contains the current value of QQ17
22602               *
22603               * QQ17                Bits 6 and 7 are set
22604               *
22605               * ******************************************************************************
22606               
22607               TT45:
22608                                                                          ; If we get here, then QQ17 has bit 6 and 7 set, so we
22609                                                                          ; are in Sentence Case and we need to print the next
22610                                                                          ; letter in lower case
22611 6798 0281  22        ci   rx,>ff*256                 ; CPX #255          ; If QQ17 = 255 then printing is disabled, so return
     679A FF00     
22612 679C 1602  14        jne  FIX006                     ; BNE FIX006        ; from the subroutine (as TT48 contains an RTS)
22613 679E 0460  28        b    @TT48                      ; JMP TT48
     67A0 6880     
22614               
22615               FIX006:
22616 67A2 0280  22        ci   ra,('A')*256               ; CMP #'A'          ; If A >= ASCII "A", then jump to TT42, which will
     67A4 4100     
22617 67A6 18CE  14        joc  TT42                       ; BCS TT42          ; print the letter in lowercase
22618               
22619                                                                          ; Otherwise this is not a letter, it's punctuation, so
22620                                                                          ; this is effectively a word break. We therefore fall
22621                                                                          ; through to TT46 to print the character and set QQ17
22622                                                                          ; to ensure the next word starts with a capital letter
22623               
22624               * ******************************************************************************
22625               *
22626               * Name: TT46
22627               * Type: Subroutine
22628               * Category: Text
22629               * Summary: Print a character and switch to capitals
22630               *
22631               * ------------------------------------------------------------------------------
22632               *
22633               * Print a character and clear bit 6 in QQ17, so that the next letter that gets
22634               * printed after this will start with a capital letter.
22635               *
22636               * ------------------------------------------------------------------------------
22637               *
22638               * Arguments:
22639               *
22640               * A                   The character to be printed. Can be one of the
22641               * following:
22642               *
22643               * * 7 (beep)
22644               *
22645               * * 10-13 (line feeds and carriage returns)
22646               *
22647               * * 32-95 (ASCII capital letters, numbers and
22648               * punctuation)
22649               *
22650               * X                   Contains the current value of QQ17
22651               *
22652               * QQ17                Bits 6 and 7 are set
22653               *
22654               * ******************************************************************************
22655               
22656               TT46:
22657                      .pha                            ; PHA               ; Store the token number
     **** ****     > PHA
0001 67A8 D680  30        movb ra,*rsp
0002 67AA 060A  14        dec  rsp
                   < elite.a99
22658               
22659 67AC D001  18        movb rx,ra                      ; TXA               ; Clear bit 6 in QQ17 (X contains the current QQ17) so
22660 67AE 0240  22        andi ra,>bf*256                 ; AND #%10111111    ; the next letter after this one is printed in upper
     67B0 BF00     
22661 67B2 D800  30        movb ra,@QQ17                   ; STA QQ17          ; case
     67B4 007E     
22662               
22663                      .pla                            ; PLA               ; Restore the token number into A
     **** ****     > PLA
0001 67B6 058A  14        inc  rsp
0002 67B8 D01A  26        movb *rsp,ra
                   < elite.a99
22664               
22665                                                                          ; Now fall through into TT74 to print the character
22666               
22667               * ******************************************************************************
22668               *
22669               * Name: TT74
22670               * Type: Subroutine
22671               * Category: Text
22672               * Summary: Print a character
22673               *
22674               * ------------------------------------------------------------------------------
22675               *
22676               * Arguments:
22677               *
22678               * A                   The character to be printed
22679               *
22680               * ******************************************************************************
22681               
22682               TT74:
22683 67BA 0460  28        b    @TT26                      ; JMP TT26          ; Print the character in A
     67BC 3172     
22684               
22685               * ******************************************************************************
22686               *
22687               * Name: TT43
22688               * Type: Subroutine
22689               * Category: Text
22690               * Summary: Print a two-letter token or recursive token 0-95
22691               *
22692               * ------------------------------------------------------------------------------
22693               *
22694               * Print a two-letter token, or a recursive token where the token number is in
22695               * 0-95 (so the value passed to TT27 is in the range 160-255).
22696               *
22697               * ------------------------------------------------------------------------------
22698               *
22699               * Arguments:
22700               *
22701               * A                   One of the following:
22702               *
22703               * * 128-159 (two-letter token)
22704               *
22705               * * 160-255 (the argument to TT27 that refers to a
22706               * recursive token in the range 0-95)
22707               *
22708               * ******************************************************************************
22709               
22710               TT43:
22711 67BE 0280  22        ci   ra,>a0*256                 ; CMP #160          ; If token >= 160, then this is a recursive token, so
     67C0 A000     
22712 67C2 1815  14        joc  TT47                       ; BCS TT47          ; jump to TT47 below to process it
22713               
22714 67C4 0240  22        andi ra,>7f*256                 ; AND #127          ; This is a two-letter token with number 128-159. The
     67C6 7F00     
22715                      .asla                           ; ASL A             ; set of two-letter tokens is stored in a lookup table
     **** ****     > ASLA
0001 67C8 0240  22        andi ra,>ff00
     67CA FF00     
0002 67CC 0A10  18        sla  ra,1
                   < elite.a99
22716                                                                          ; at QQ16, with each token taking up two bytes, so to
22717                                                                          ; convert this into the token's position in the table,
22718                                                                          ; we subtract 128 (or just clear bit 7) and multiply
22719                                                                          ; by 2 (or shift left)
22720               
22721 67CE D080  18        movb ra,ry                      ; TAY               ; Transfer the token's position into Y so we can look
22722                                                                          ; up the token using absolute indexed mode
22723               
22724 67D0 D022  34        movb @QQ16(ry),ra               ; LDA QQ16,Y        ; Get the first letter of the token and print it
     67D2 8EE2     
22725 67D4 0206  20        li   rtmp,TT27                  ; JSR TT27
     67D6 66DC     
22726 67D8 06A0  28        bl   @jsr                       ;
     67DA 8002     
22727               
22728 67DC D022  34        movb @QQ16+1(ry),ra             ; LDA QQ16+1,Y      ; Get the second letter of the token
     67DE 8EE3     
22729               
22730 67E0 0280  22        ci   ra,('?')*256               ; CMP #'?'          ; If the second letter of the token is a question mark
     67E2 3F00     
22731 67E4 1602  14        jne  FIX007                     ; BNE FIX007        ; then this is a one-letter token, so just return from
22732                                                                          ; the subroutine without printing (as TT48 contains an
22733                                                                          ; RTS)
22734 67E6 0460  28        b    @TT48                      ; JMP TT48
     67E8 6880     
22735               FIX007:
22736 67EA 0460  28        b    @TT27                      ; JMP TT27          ; Print the second letter and return from the
     67EC 66DC     
22737                                                                          ; subroutine
22738               
22739               TT47:
22740                      .sbi (>a0*256)                  ; SBC #160          ; This is a recursive token in the range 160-255, so
     **** ****     > SBI
0001 67EE 1801  14        joc  !
0002 67F0 7004  18        sb   rone,ra
0003               !:
0004 67F2 0220  22        ai   ra,-(>A0*256)
     67F4 6000     
                   < elite.a99
22741                                                                          ; subtract 160 from the argument to get the token
22742                                                                          ; number 0-95 and fall through into ex to print it
22743               
22744               * ******************************************************************************
22745               *
22746               * Name: ex
22747               * Type: Subroutine
22748               * Category: Text
22749               * Summary: Print a recursive token
22750               * Deep dive: Printing text tokens
22751               *
22752               * ------------------------------------------------------------------------------
22753               *
22754               * This routine works its way through the recursive text tokens that are stored
22755               * in tokenised form in the table at QQ18, and when it finds token number A,
22756               * it prints it. Tokens are null-terminated in memory and fill three pages,
22757               * but there is no lookup table as that would consume too much memory, so the
22758               * only way to find the correct token is to start at the beginning and look
22759               * through the table byte by byte, counting tokens as we go until we are in the
22760               * right place. This approach might not be terribly speed efficient, but it is
22761               * certainly memory-efficient.
22762               *
22763               * ------------------------------------------------------------------------------
22764               *
22765               * Arguments:
22766               *
22767               * A                   The recursive token to be printed, in the range 0-148
22768               *
22769               * ------------------------------------------------------------------------------
22770               *
22771               * Other entry points:
22772               *
22773               * TT48                Contains an RTS
22774               *
22775               * ******************************************************************************
22776               
22777               ex_:
22778 67F6 D040  18        movb ra,rx                      ; TAX               ; Copy the token number into X
22779               
22780 67F8 0200  20        li   ra,((QQ18)%256)*256        ; LDA #LO(QQ18)     ; Set V(1 0) to point to the recursive token table at
     67FA 0000     
22781 67FC D800  30        movb ra,@V                      ; STA V             ; location QQ18
     67FE 0022     
22782 6800 0200  20        li   ra,((QQ18)/256)*256        ; LDA #HI(QQ18)
     6802 0400     
22783 6804 D800  30        movb ra,@V+1                    ; STA V+1
     6806 0023     
22784               
22785 6808 0202  20        li   ry,>00*256                 ; LDY #0            ; Set a counter Y to point to the character offset
     680A 0000     
22786                                                                          ; as we scan through the table
22787               
22788 680C D001  18        movb rx,ra                      ; TXA               ; Copy the token number back into A, so both A and X
22789                                                                          ; now contain the token number we want to print
22790               
22791 680E 1311  14        jeq  TT50                       ; BEQ TT50          ; If the token number we want is 0, then we have
22792                                                                          ; already found the token we are looking for, so jump
22793                                                                          ; to TT50, otherwise start working our way through the
22794                                                                          ; null-terminated token table until we find the X-th
22795                                                                          ; token
22796               
22797               TT51:
22798                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch the Y-th character from the token table page
     **** ****     > LD_IND_Y_IDX
0001 6810 D820  42        movb @V,@rtmplb
     6812 0022     
     6814 830D     
0002 6816 D1A0  30        movb @V+1,rtmp
     6818 0023     
0003 681A A182  18        a    ry,rtmp
0004 681C D016  26        movb *rtmp,RA
                   < elite.a99
22799                                                                          ; we are currently scanning
22800               
22801 681E 1304  14        jeq  TT49                       ; BEQ TT49          ; If the character is null, we've reached the end of
22802                                                                          ; this token, so jump to TT49
22803               
22804 6820 B084  18        ab   rone,ry                    ; INY               ; Increment character pointer and loop back around for
22805 6822 16F6  14        jne  TT51                       ; BNE TT51          ; the next character in this token, assuming Y hasn't
22806                                                                          ; yet wrapped around to 0
22807               
22808 6824 B004  18        ab   rone,ra                    ; INC V+1           ; If it has wrapped round to 0, we have just crossed
22809 6826 16F4  14        jne  TT51                       ; BNE TT51          ; into a new page, so increment V+1 so that V points
22810                                                                          ; to the start of the new page
22811               
22812               TT49:
22813 6828 B084  18        ab   rone,ry                    ; INY               ; Increment the character pointer
22814               
22815 682A 1601  14        jne  TT59                       ; BNE TT59          ; If Y hasn't just wrapped around to 0, skip the next
22816                                                                          ; instruction
22817               
22818 682C B004  18        ab   rone,ra                    ; INC V+1           ; We have just crossed into a new page, so increment
22819                                                                          ; V+1 so that V points to the start of the new page
22820               
22821               TT59:
22822 682E 7044  18        sb   rone,rx                    ; DEX               ; We have just reached a new token, so decrement the
22823                                                                          ; token number we are looking for
22824               
22825 6830 16EF  14        jne  TT51                       ; BNE TT51          ; Assuming we haven't yet reached the token number in
22826                                                                          ; X, look back up to keep fetching characters
22827               
22828               TT50:
22829                                                                          ; We have now reached the correct token in the token
22830                                                                          ; table, with Y pointing to the start of the token as
22831                                                                          ; an offset within the page pointed to by V, so let's
22832                                                                          ; print the recursive token. Because recursive tokens
22833                                                                          ; can contain other recursive tokens, we need to store
22834                                                                          ; our current state on the stack, so we can retrieve
22835                                                                          ; it after printing each character in this token
22836 6832 D002  18        movb ry,ra                      ; TYA               ; Store the offset in Y on the stack
22837                      .pha                            ; PHA
     **** ****     > PHA
0001 6834 D680  30        movb ra,*rsp
0002 6836 060A  14        dec  rsp
                   < elite.a99
22838               
22839 6838 D020  30        movb @V+1,ra                    ; LDA V+1           ; Store the high byte of V (the page containing the
     683A 0023     
22840                      .pha                            ; PHA               ; token we have found) on the stack, so the stack now
     **** ****     > PHA
0001 683C D680  30        movb ra,*rsp
0002 683E 060A  14        dec  rsp
                   < elite.a99
22841                                                                          ; contains the address of the start of this token
22842               
22843                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Load the character at offset Y in the token table,
     **** ****     > LD_IND_Y_IDX
0001 6840 D820  42        movb @V,@rtmplb
     6842 0022     
     6844 830D     
0002 6846 D1A0  30        movb @V+1,rtmp
     6848 0023     
0003 684A A182  18        a    ry,rtmp
0004 684C D016  26        movb *rtmp,RA
                   < elite.a99
22844                                                                          ; which is the next character of this token that we
22845                                                                          ; want to print
22846               
22847                      .eoi ((RE)*256)                 ; EOR #RE           ; Tokens are stored in memory having been EOR'd with the
     **** ****     > EOI
0001 684E 0206  20        li   rtmp,((RE)*256)
     6850 2300     
0002 6852 2806  18        xor  rtmp,ra
                   < elite.a99
22848                                                                          ; value of RE - which is 35 for all versions of Elite
22849                                                                          ; except for NES, where RE is 62 - so we repeat the
22850                                                                          ; EOR to get the actual character to print
22851               
22852 6854 0206  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A, which could be a letter,
     6856 66DC     
22853 6858 06A0  28        bl   @jsr                       ;
     685A 8002     
22854                                                                          ; number, control code, two-letter token or another
22855                                                                          ; recursive token
22856               
22857                      .pla                            ; PLA               ; Restore the high byte of V (the page containing the
     **** ****     > PLA
0001 685C 058A  14        inc  rsp
0002 685E D01A  26        movb *rsp,ra
                   < elite.a99
22858 6860 D800  30        movb ra,@V+1                    ; STA V+1           ; token we have found) into V+1
     6862 0023     
22859               
22860                      .pla                            ; PLA               ; Restore the offset into Y
     **** ****     > PLA
0001 6864 058A  14        inc  rsp
0002 6866 D01A  26        movb *rsp,ra
                   < elite.a99
22861 6868 D080  18        movb ra,ry                      ; TAY
22862               
22863 686A B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next character in the
22864                                                                          ; token we are printing
22865               
22866 686C 1601  14        jne  B65                        ; BNE B65           ; If Y is zero then we have just crossed into a new
22867 686E B004  18        ab   rone,ra                    ; INC V+1           ; page, so increment V+1 so that V points to the start
22868                                                                          ; of the new page
22869               
22870               B65:
22871                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Load the next character we want to print into A
     **** ****     > LD_IND_Y_IDX
0001 6870 D820  42        movb @V,@rtmplb
     6872 0022     
     6874 830D     
0002 6876 D1A0  30        movb @V+1,rtmp
     6878 0023     
0003 687A A182  18        a    ry,rtmp
0004 687C D016  26        movb *rtmp,RA
                   < elite.a99
22872               
22873 687E 16D9  14        jne  TT50                       ; BNE TT50          ; If this is not the null character at the end of the
22874                                                                          ; token, jump back up to TT50 to print the next
22875                                                                          ; character, otherwise we are done printing
22876               
22877               TT48:
22878 6880 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6882 800E     
22879               
22880               * ******************************************************************************
22881               *
22882               * Name: DOEXP
22883               * Type: Subroutine
22884               * Category: Drawing ships
22885               * Summary: Draw an exploding ship
22886               * Deep dive: Drawing explosion clouds
22887               * Generating random numbers
22888               *
22889               * ******************************************************************************
22890               
22891               EX2:
22892 6884 D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bits 5 and 7 of the ship's byte #31 to denote that
     6886 0072     
22893 6888 0260  22        ori  ra,>a0*256                 ; ORA #%10100000    ; the ship is exploding and has been killed
     688A A000     
22894 688C D800  30        movb ra,@INWK+31                ; STA INWK+31
     688E 0072     
22895               
22896 6890 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6892 800E     
22897               
22898               DOEXP:
22899 6894 D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; If bit 6 of the ship's byte #31 is clear, then the
     6896 0072     
22900 6898 0240  22        andi ra,>40*256                 ; AND #%01000000    ; ship is not already exploding so there is no existing
     689A 4000     
22901 689C 1304  14        jeq  B66                        ; BEQ B66           ; explosion cloud to remove, so skip the following
22902                                                                          ; instruction
22903               
22904 689E 0206  20        li   rtmp,PTCLS                 ; JSR PTCLS         ; Call PTCLS to remove the existing cloud by drawing it
     68A0 69C4     
22905 68A2 06A0  28        bl   @jsr                       ;
     68A4 8002     
22906                                                                          ; again
22907               
22908               B66:
22909 68A6 D020  30        movb @INWK+6,ra                 ; LDA INWK+6        ; Set T = z_lo
     68A8 0059     
22910 68AA D800  30        movb ra,@T                      ; STA T
     68AC 00D1     
22911               
22912 68AE D020  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set A = z_hi, so (A T) = z
     68B0 005A     
22913               
22914 68B2 0280  22        ci   ra,>20*256                 ; CMP #32           ; If z_hi < 32, skip the next two instructions
     68B4 2000     
22915 68B6 1703  14        jnc  B67                        ; BCC B67
22916               
22917 68B8 0200  20        li   ra,>fe*256                 ; LDA #&FE          ; Set A = 254 and jump to yy (this BNE is effectively a
     68BA FE00     
22918 68BC 1615  14        jne  yy_                        ; BNE yy            ; JMP, as A is never zero)
22919               
22920               B67:
22921                      .asl @T                         ; ASL T             ; Shift (A T) left twice
     **** ****     > ASL
0001 68BE D1A0  30        movb @T,rtmp
     68C0 00D1     
0002 68C2 0246  22        andi rtmp,>ff00
     68C4 FF00     
0003 68C6 0A16  18        sla  rtmp,1
0004 68C8 D806  30        movb rtmp,@T
     68CA 00D1     
                   < elite.a99
22922 68CC 06A0  28        bl   @rola                      ; ROL A
     68CE 8018     
22923                      .asl @T                         ; ASL T
     **** ****     > ASL
0001 68D0 D1A0  30        movb @T,rtmp
     68D2 00D1     
0002 68D4 0246  22        andi rtmp,>ff00
     68D6 FF00     
0003 68D8 0A16  18        sla  rtmp,1
0004 68DA D806  30        movb rtmp,@T
     68DC 00D1     
                   < elite.a99
22924 68DE 06A0  28        bl   @rola                      ; ROL A
     68E0 8018     
22925               
22926                      .sec                            ; SEC               ; And then shift A left once more, inserting a 1 into
     **** ****     > SEC
0001 68E2 0A15  18        sla  rmone,1
                   < elite.a99
22927 68E4 06A0  28        bl   @rola                      ; ROL A             ; bit 0
     68E6 8018     
22928               
22929                                                                          ; Overall, the above multiplies A by 8 and makes sure it
22930                                                                          ; is at least 1, to leave a one-byte distance in A. We
22931                                                                          ; can use this as the distance for our cloud, to ensure
22932                                                                          ; that the explosion cloud is visible even for ships
22933                                                                          ; that blow up a long way away
22934               
22935               yy_:
22936 68E8 D800  30        movb ra,@Q                      ; STA Q             ; Store the distance to the explosion in Q
     68EA 0090     
22937               
22938 68EC 0202  20        li   ry,>01*256                 ; LDY #1            ; Fetch byte #1 of the ship line heap, which contains
     68EE 0100     
22939                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; the cloud counter
     **** ****     > LD_IND_Y_IDX
0001 68F0 D820  42        movb @XX19,@rtmplb
     68F2 0074     
     68F4 830D     
0002 68F6 D1A0  30        movb @XX19+1,rtmp
     68F8 0075     
0003 68FA A182  18        a    ry,rtmp
0004 68FC D016  26        movb *rtmp,RA
                   < elite.a99
22940               
22941                      .adi (>04*256)                  ; ADC #4            ; Add 4 to the cloud counter, so it ticks onwards every
     **** ****     > ADI
0001 68FE 1701  14        jnc  !
0002 6900 B004  18        ab   rone,ra
0003               !:
0004 6902 0220  22        ai   ra,(>04*256)
     6904 0400     
                   < elite.a99
22942                                                                          ; we redraw it
22943               
22944 6906 18BE  14        joc  EX2                        ; BCS EX2           ; If the addition overflowed, jump up to EX2 to update
22945                                                                          ; the explosion flags and return from the subroutine
22946               
22947                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store the updated cloud counter in byte #1 of the ship
     **** ****     > ST_IND_Y_IDX
0001 6908 D820  42        movb @XX19,@rtmplb
     690A 0074     
     690C 830D     
0002 690E D1A0  30        movb @XX19+1,rtmp
     6910 0075     
0003 6912 A182  18        a    ry,rtmp
0004 6914 D580  30        movb RA,*rtmp
                   < elite.a99
22948                                                                          ; line heap
22949               
22950 6916 0206  20        li   rtmp,DVID4                 ; JSR DVID4         ; Calculate the following:
     6918 45B0     
22951 691A 06A0  28        bl   @jsr                       ;
     691C 8002     
22952                                                                          ;
22953                                                                          ; (P R) = 256 * A / Q
22954                                                                          ; = 256 * cloud counter / distance
22955                                                                          ;
22956                                                                          ; We are going to use this as our cloud size, so the
22957                                                                          ; further away the cloud, the smaller it is, and as the
22958                                                                          ; cloud counter ticks onward, the cloud expands
22959               
22960 691E D020  30        movb @P,ra                      ; LDA P             ; Set A = P, so we now have:
     6920 001B     
22961                                                                          ;
22962                                                                          ; (A R) = 256 * cloud counter / distance
22963               
22964 6922 0280  22        ci   ra,>1c*256                 ; CMP #&1C          ; If A < 28, skip the next two instructions
     6924 1C00     
22965 6926 1703  14        jnc  B68                        ; BCC B68
22966               
22967 6928 0200  20        li   ra,>fe*256                 ; LDA #&FE          ; Set A = 254 and skip the following (this BNE is
     692A FE00     
22968 692C 161B  14        jne  LABEL_1                    ; BNE LABEL_1       ; effectively a JMP as A is never zero)
22969               
22970               B68:
22971                      .asl @R                         ; ASL R             ; Shift (A R) left three times to multiply by 8
     **** ****     > ASL
0001 692E D1A0  30        movb @R,rtmp
     6930 0091     
0002 6932 0246  22        andi rtmp,>ff00
     6934 FF00     
0003 6936 0A16  18        sla  rtmp,1
0004 6938 D806  30        movb rtmp,@R
     693A 0091     
                   < elite.a99
22972 693C 06A0  28        bl   @rola                      ; ROL A
     693E 8018     
22973                      .asl @R                         ; ASL R
     **** ****     > ASL
0001 6940 D1A0  30        movb @R,rtmp
     6942 0091     
0002 6944 0246  22        andi rtmp,>ff00
     6946 FF00     
0003 6948 0A16  18        sla  rtmp,1
0004 694A D806  30        movb rtmp,@R
     694C 0091     
                   < elite.a99
22974 694E 06A0  28        bl   @rola                      ; ROL A
     6950 8018     
22975                      .asl @R                         ; ASL R
     **** ****     > ASL
0001 6952 D1A0  30        movb @R,rtmp
     6954 0091     
0002 6956 0246  22        andi rtmp,>ff00
     6958 FF00     
0003 695A 0A16  18        sla  rtmp,1
0004 695C D806  30        movb rtmp,@R
     695E 0091     
                   < elite.a99
22976 6960 06A0  28        bl   @rola                      ; ROL A
     6962 8018     
22977               
22978                                                                          ; Overall, the above multiplies (A R) by 8 to leave a
22979                                                                          ; one-byte cloud size in A, given by the following:
22980                                                                          ;
22981                                                                          ; A = 8 * cloud counter / distance
22982               
22983               LABEL_1:
22984 6964 7084  18        sb   rone,ry                    ; DEY               ; Decrement Y to 0
22985               
22986                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store the cloud size in byte #0 of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 6966 D820  42        movb @XX19,@rtmplb
     6968 0074     
     696A 830D     
0002 696C D1A0  30        movb @XX19+1,rtmp
     696E 0075     
0003 6970 A182  18        a    ry,rtmp
0004 6972 D580  30        movb RA,*rtmp
                   < elite.a99
22987               
22988 6974 D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Clear bit 6 of the ship's byte #31 to denote that the
     6976 0072     
22989 6978 0240  22        andi ra,>bf*256                 ; AND #%10111111    ; explosion has not yet been drawn
     697A BF00     
22990 697C D800  30        movb ra,@INWK+31                ; STA INWK+31
     697E 0072     
22991               
22992 6980 0240  22        andi ra,>08*256                 ; AND #%00001000    ; If bit 3 of the ship's byte #31 is clear, then nothing
     6982 0800     
22993 6984 1602  14        jne  FIX008                     ; BNE FIX008        ; is being drawn on-screen for this ship anyway, so
22994 6986 0460  28        b    @TT48                      ; JMP TT48          ; return from the subroutine (as TT48 contains an RTS)
     6988 6880     
22995               
22996               FIX008:
22997 698A 0202  20        li   ry,>02*256                 ; LDY #2            ; Otherwise it's time to draw an explosion cloud, so
     698C 0200     
22998                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; fetch byte #2 of the ship line heap into Y, which we
     **** ****     > LD_IND_Y_IDX
0001 698E D820  42        movb @XX19,@rtmplb
     6990 0074     
     6992 830D     
0002 6994 D1A0  30        movb @XX19+1,rtmp
     6996 0075     
0003 6998 A182  18        a    ry,rtmp
0004 699A D016  26        movb *rtmp,RA
                   < elite.a99
22999 699C D080  18        movb ra,ry                      ; TAY               ; set to the explosion count for this ship (i.e. the
23000                                                                          ; number of vertices used as origins for explosion
23001                                                                          ; clouds)
23002                                                                          ;
23003                                                                          ; The explosion count is stored as 4 * n + 6, where n is
23004                                                                          ; the number of vertices, so the following loop copies
23005                                                                          ; the coordinates of the first n vertices from the heap
23006                                                                          ; at XX3, which is where we stored all the visible
23007                                                                          ; vertex coordinates in part 8 of the LL9 routine, and
23008                                                                          ; sticks them in the ship line heap pointed to by XX19,
23009                                                                          ; starting at byte #7 (so it leaves the first 6 bytes of
23010                                                                          ; the ship line heap alone)
23011               
23012               EXL1:
23013 699E D022  34        movb @XX3-7(ry),ra              ; LDA XX3-7,Y       ; Copy byte Y-7 from the XX3 heap, into the Y-th byte of
     69A0 00F9     
23014                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 69A2 D820  42        movb @XX19,@rtmplb
     69A4 0074     
     69A6 830D     
0002 69A8 D1A0  30        movb @XX19+1,rtmp
     69AA 0075     
0003 69AC A182  18        a    ry,rtmp
0004 69AE D580  30        movb RA,*rtmp
                   < elite.a99
23015               
23016 69B0 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
23017               
23018 69B2 0282  22        ci   ry,>06*256                 ; CPY #6            ; Keep copying vertex coordinates into the ship line
     69B4 0600     
23019 69B6 16F3  14        jne  EXL1                       ; BNE EXL1          ; heap until Y = 6 (which will copy n vertices, where n
23020                                                                          ; is the number of vertices we should be exploding)
23021               
23022 69B8 D020  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 6 of the ship's byte #31 to denote that the
     69BA 0072     
23023 69BC 0260  22        ori  ra,>40*256                 ; ORA #%01000000    ; explosion has been drawn (as it's about to be)
     69BE 4000     
23024 69C0 D800  30        movb ra,@INWK+31                ; STA INWK+31
     69C2 0072     
23025               
23026               PTCLS:
23027                                                                          ; This part of the routine actually draws the explosion
23028                                                                          ; cloud
23029 69C4 0202  20        li   ry,>00*256                 ; LDY #0            ; Fetch byte #0 of the ship line heap, which contains
     69C6 0000     
23030                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; the cloud size we stored above, and store it in Q
     **** ****     > LD_IND_Y_IDX
0001 69C8 D820  42        movb @XX19,@rtmplb
     69CA 0074     
     69CC 830D     
0002 69CE D1A0  30        movb @XX19+1,rtmp
     69D0 0075     
0003 69D2 A182  18        a    ry,rtmp
0004 69D4 D016  26        movb *rtmp,RA
                   < elite.a99
23031 69D6 D800  30        movb ra,@Q                      ; STA Q
     69D8 0090     
23032               
23033 69DA B084  18        ab   rone,ry                    ; INY               ; Increment the index in Y to point to byte #1
23034               
23035                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch byte #1 of the ship line heap, which contains
     **** ****     > LD_IND_Y_IDX
0001 69DC D820  42        movb @XX19,@rtmplb
     69DE 0074     
     69E0 830D     
0002 69E2 D1A0  30        movb @XX19+1,rtmp
     69E4 0075     
0003 69E6 A182  18        a    ry,rtmp
0004 69E8 D016  26        movb *rtmp,RA
                   < elite.a99
23036                                                                          ; the cloud counter. We are now going to process this
23037                                                                          ; into the number of particles in each vertex's cloud
23038               
23039 69EA 1503  14        jgt  B69                        ; BPL B69           ; If the cloud counter < 128, then we are in the first
23040                                                                          ; half of the cloud's existence, so skip the next
23041                                                                          ; instruction
23042               
23043                      .eoi (>ff*256)                  ; EOR #&FF          ; Flip the value of A so that in the second half of the
     **** ****     > EOI
0001 69EC 0206  20        li   rtmp,(>FF*256)
     69EE FF00     
0002 69F0 2806  18        xor  rtmp,ra
                   < elite.a99
23044                                                                          ; cloud's existence, A counts down instead of up
23045               
23046               B69:
23047 69F2 0910  18        srl  ra,1                       ; LSR A             ; Divide A by 8 so that is has a maximum value of 15
23048 69F4 0910  18        srl  ra,1                       ; LSR A
23049 69F6 0910  18        srl  ra,1                       ; LSR A
23050               
23051 69F8 0260  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1 and store it in U, to
     69FA 0100     
23052 69FC D800  30        movb ra,@U                      ; STA U             ; give us the number of particles in the explosion for
     69FE 008F     
23053                                                                          ; each vertex
23054               
23055 6A00 B084  18        ab   rone,ry                    ; INY               ; Increment the index in Y to point to byte #2
23056               
23057                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch byte #2 of the ship line heap, which contains
     **** ****     > LD_IND_Y_IDX
0001 6A02 D820  42        movb @XX19,@rtmplb
     6A04 0074     
     6A06 830D     
0002 6A08 D1A0  30        movb @XX19+1,rtmp
     6A0A 0075     
0003 6A0C A182  18        a    ry,rtmp
0004 6A0E D016  26        movb *rtmp,RA
                   < elite.a99
23058 6A10 D800  30        movb ra,@TGT                    ; STA TGT           ; the explosion count for this ship (i.e. the number of
     6A12 00A0     
23059                                                                          ; vertices used as origins for explosion clouds) and
23060                                                                          ; store it in TGT
23061               
23062 6A14 D020  30        movb @RAND+1,ra                 ; LDA RAND+1        ; Fetch the current random number seed in RAND+1 and
     6A16 0001     
23063                      .pha                            ; PHA               ; store it on the stack, so we can re-randomise the
     **** ****     > PHA
0001 6A18 D680  30        movb ra,*rsp
0002 6A1A 060A  14        dec  rsp
                   < elite.a99
23064                                                                          ; seeds when we are done
23065               
23066 6A1C 0202  20        li   ry,>06*256                 ; LDY #6            ; Set Y = 6 to point to the byte before the first vertex
     6A1E 0600     
23067                                                                          ; coordinate we stored on the ship line heap above (we
23068                                                                          ; increment it below so it points to the first vertex)
23069               
23070               EXL5:
23071 6A20 0201  20        li   rx,>03*256                 ; LDX #3            ; We are about to fetch a pair of coordinates from the
     6A22 0300     
23072                                                                          ; ship line heap, so set a counter in X for 4 bytes
23073               
23074               EXL3:
23075 6A24 B084  18        ab   rone,ry                    ; INY               ; Increment the index in Y so it points to the next byte
23076                                                                          ; from the coordinate we are copying
23077               
23078                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Copy the Y-th byte from the ship line heap to the X-th
     **** ****     > LD_IND_Y_IDX
0001 6A26 D820  42        movb @XX19,@rtmplb
     6A28 0074     
     6A2A 830D     
0002 6A2C D1A0  30        movb @XX19+1,rtmp
     6A2E 0075     
0003 6A30 A182  18        a    ry,rtmp
0004 6A32 D016  26        movb *rtmp,RA
                   < elite.a99
23079 6A34 D840  38        movb ra,@K3(rx)                 ; STA K3,X          ; byte of K3
     6A36 00D2     
23080               
23081 6A38 7044  18        sb   rone,rx                    ; DEX               ; Decrement the X index
23082               
23083 6A3A 15F4  14        jgt  EXL3                       ; BPL EXL3          ; Loop back to EXL3 until we have copied all four bytes
23084               
23085                                                                          ; The above loop copies the vertex coordinates from the
23086                                                                          ; ship line heap to K3, reversing them as we go, so it
23087                                                                          ; sets the following:
23088                                                                          ;
23089                                                                          ; K3+3 = x_lo
23090                                                                          ; K3+2 = x_hi
23091                                                                          ; K3+1 = y_lo
23092                                                                          ; K3+0 = y_hi
23093               
23094 6A3C D802  30        movb ry,@CNT                    ; STY CNT           ; Set CNT to the index that points to the next vertex on
     6A3E 00A4     
23095                                                                          ; the ship line heap
23096               
23097 6A40 0202  20        li   ry,>02*256                 ; LDY #2            ; Set Y = 2, which we will use to point to bytes #3 to
     6A42 0200     
23098                                                                          ; #6, after incrementing it
23099               
23100                                                                          ; This next loop copies bytes #3 to #6 from the ship
23101                                                                          ; line heap into the four random number seeds in RAND to
23102                                                                          ; RAND+3, EOR'ing them with the vertex index so they are
23103                                                                          ; different for every vertex. This enables us to
23104                                                                          ; generate random numbers for drawing each vertex that
23105                                                                          ; are random but repeatable, which we need when we
23106                                                                          ; redraw the cloud to remove it
23107                                                                          ;
23108                                                                          ; Note that we haven't actually set the values of bytes
23109                                                                          ; #3 to #6 in the ship line heap, so we have no idea
23110                                                                          ; what they are, we just use what's already there. But
23111                                                                          ; the fact that those bytes are stored for this ship
23112                                                                          ; means we can repeat the random generation of the
23113                                                                          ; cloud, which is the important bit
23114               
23115               EXL2:
23116 6A44 B084  18        ab   rone,ry                    ; INY               ; Increment the index in Y so it points to the next
23117                                                                          ; random number seed to copy
23118               
23119                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y-th byte from the ship line heap
     **** ****     > LD_IND_Y_IDX
0001 6A46 D820  42        movb @XX19,@rtmplb
     6A48 0074     
     6A4A 830D     
0002 6A4C D1A0  30        movb @XX19+1,rtmp
     6A4E 0075     
0003 6A50 A182  18        a    ry,rtmp
0004 6A52 D016  26        movb *rtmp,RA
                   < elite.a99
23120               
23121                      .eor @CNT                       ; EOR CNT           ; EOR with the vertex index, so the seeds are different
     **** ****     > EOR
0001 6A54 D1A0  30        movb @CNT,rtmp
     6A56 00A4     
0002 6A58 2806  18        xor  rtmp,ra
                   < elite.a99
23122                                                                          ; for each vertex
23123               
23124 6A5A D880  38        movb ra,@>FFFD(ry)              ; STA &FFFD,Y       ; Y is going from 3 to 6, so this stores the four bytes
     6A5C FFFD     
23125                                                                          ; in memory locations &00, &01, &02 and &03, which are
23126                                                                          ; the memory locations of RAND through RAND+3
23127               
23128 6A5E 0282  22        ci   ry,>06*256                 ; CPY #6            ; Loop back to EXL2 until Y = 6, which means we have
     6A60 0600     
23129 6A62 16F0  14        jne  EXL2                       ; BNE EXL2          ; copied four bytes
23130               
23131 6A64 D0A0  30        movb @U,ry                      ; LDY U             ; Set Y to the number of particles in the explosion for
     6A66 008F     
23132                                                                          ; each vertex, which we stored in U above. We will now
23133                                                                          ; use this as a loop counter to iterate through all the
23134                                                                          ; particles in the explosion
23135               
23136               EXL4:
23137 6A68 0206  20        li   rtmp,DORND2                ; JSR DORND2        ; Set ZZ to a random number, making sure the C flag
     6A6A 806E     
23138 6A6C 06A0  28        bl   @jsr                       ;
     6A6E 8002     
23139 6A70 D800  30        movb ra,@ZZ                     ; STA ZZ            ; doesn't affect the outcome
     6A72 0097     
23140               
23141 6A74 D020  30        movb @K3+1,ra                   ; LDA K3+1          ; Set (A R) = (y_hi y_lo)
     6A76 00D3     
23142 6A78 D800  30        movb ra,@R                      ; STA R             ; = y
     6A7A 0091     
23143 6A7C D020  30        movb @K3,ra                     ; LDA K3
     6A7E 00D2     
23144               
23145 6A80 0206  20        li   rtmp,EXS1                  ; JSR EXS1          ; Set (A X) = (A R) +/- random * cloud size
     6A82 6AE4     
23146 6A84 06A0  28        bl   @jsr                       ;
     6A86 8002     
23147                                                                          ; = y +/- random * cloud size
23148               
23149 6A88 1627  14        jne  EX11                       ; BNE EX11          ; If A is non-zero, the particle is off-screen as the
23150                                                                          ; coordinate is bigger than 255), so jump to EX11 to do
23151                                                                          ; the next particle
23152               
23153 6A8A 0281  22        ci   rx,(2*Y-1)*256             ; CPX #2*Y-1        ; If X > the y-coordinate of the bottom of the screen,
     6A8C BF00     
23154 6A8E 1824  14        joc  EX11                       ; BCS EX11          ; the particle is off the bottom of the screen, so jump
23155                                                                          ; to EX11 to do the next particle
23156               
23157                                                                          ; Otherwise X contains a random y-coordinate within the
23158                                                                          ; cloud
23159               
23160 6A90 D801  30        movb rx,@Y1                     ; STX Y1            ; Set Y1 = our random y-coordinate within the cloud
     6A92 0032     
23161               
23162 6A94 D020  30        movb @K3+3,ra                   ; LDA K3+3          ; Set (A R) = (x_hi x_lo)
     6A96 00D5     
23163 6A98 D800  30        movb ra,@R                      ; STA R
     6A9A 0091     
23164 6A9C D020  30        movb @K3+2,ra                   ; LDA K3+2
     6A9E 00D4     
23165               
23166 6AA0 0206  20        li   rtmp,EXS1                  ; JSR EXS1          ; Set (A X) = (A R) +/- random * cloud size
     6AA2 6AE4     
23167 6AA4 06A0  28        bl   @jsr                       ;
     6AA6 8002     
23168                                                                          ; = x +/- random * cloud size
23169               
23170 6AA8 1606  14        jne  EX4                        ; BNE EX4           ; If A is non-zero, the particle is off-screen as the
23171                                                                          ; coordinate is bigger than 255), so jump to EX11 to do
23172                                                                          ; the next particle
23173               
23174                                                                          ; Otherwise X contains a random x-coordinate within the
23175                                                                          ; cloud
23176               
23177 6AAA D020  30        movb @Y1,ra                     ; LDA Y1            ; Set A = our random y-coordinate within the cloud
     6AAC 0032     
23178               
23179 6AAE 0206  20        li   rtmp,PIXEL                 ; JSR PIXEL         ; Draw a point at screen coordinate (X, A) with the
     6AB0 27BC     
23180 6AB2 06A0  28        bl   @jsr                       ;
     6AB4 8002     
23181                                                                          ; point size determined by the distance in ZZ
23182               
23183               EX4:
23184 6AB6 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter for the next particle
23185               
23186 6AB8 15D7  14        jgt  EXL4                       ; BPL EXL4          ; Loop back to EXL4 until we have done all the particles
23187                                                                          ; in the cloud
23188               
23189 6ABA D0A0  30        movb @CNT,ry                    ; LDY CNT           ; Set Y to the index that points to the next vertex on
     6ABC 00A4     
23190                                                                          ; the ship line heap
23191               
23192 6ABE 90A0  30        cb   @TGT,ry                    ; CPY TGT           ; If Y < TGT, which we set to the explosion count for
     6AC0 00A0     
23193 6AC2 17AE  14        jnc  EXL5                       ; BCC EXL5          ; this ship (i.e. the number of vertices used as origins
23194                                                                          ; for explosion clouds), loop back to EXL5 to do a cloud
23195                                                                          ; for the next vertex
23196               
23197                      .pla                            ; PLA               ; Restore the current random number seed to RAND+1 that
     **** ****     > PLA
0001 6AC4 058A  14        inc  rsp
0002 6AC6 D01A  26        movb *rsp,ra
                   < elite.a99
23198 6AC8 D800  30        movb ra,@RAND+1                 ; STA RAND+1        ; we stored at the start of the routine
     6ACA 0001     
23199               
23200 6ACC D020  30        movb @K.+6,ra                   ; LDA K%+6          ; Store the z_lo coordinate for the planet (which will
     6ACE 0906     
23201 6AD0 D800  30        movb ra,@RAND+3                 ; STA RAND+3        ; be pretty random) in the RAND+3 seed
     6AD2 0003     
23202               
23203 6AD4 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6AD6 800E     
23204               
23205               EX11:
23206 6AD8 0206  20        li   rtmp,DORND2                ; JSR DORND2        ; Set A and X to random numbers, making sure the C flag
     6ADA 806E     
23207 6ADC 06A0  28        bl   @jsr                       ;
     6ADE 8002     
23208                                                                          ; doesn't affect the outcome
23209               
23210 6AE0 0460  28        b    @EX4                       ; JMP EX4           ; We just skipped a particle, so jump up to EX4 to do
     6AE2 6AB6     
23211                                                                          ; the next one
23212               
23213               EXS1:
23214                                                                          ; This routine calculates the following:
23215                                                                          ;
23216                                                                          ; (A X) = (A R) +/- random * cloud size
23217                                                                          ;
23218                                                                          ; returning with the flags set for the high byte in A
23219 6AE4 D800  30        movb ra,@S                      ; STA S             ; Store A in S so we can use it later
     6AE6 0092     
23220               
23221 6AE8 0206  20        li   rtmp,DORND2                ; JSR DORND2        ; Set A and X to random numbers, making sure the C flag
     6AEA 806E     
23222 6AEC 06A0  28        bl   @jsr                       ;
     6AEE 8002     
23223                                                                          ; doesn't affect the outcome
23224               
23225 6AF0 06A0  28        bl   @rola                      ; ROL A             ; Set A = A * 2
     6AF2 8018     
23226               
23227 6AF4 1811  14        joc  EX5                        ; BCS EX5           ; If bit 7 of A was set (50% chance), jump to EX5
23228               
23229 6AF6 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set A = A * Q / 256
     6AF8 4338     
23230 6AFA 06A0  28        bl   @jsr                       ;
     6AFC 8002     
23231                                                                          ; = random << 1 * projected cloud size / 256
23232               
23233                      .adc @R,ra                      ; ADC R             ; Set (A X) = (S R) + A
     **** ****     > ADC
0001 6AFE 1701  14        jnc  !
0002 6B00 B004  18        ab   rone,ra
0003               !:
0004 6B02 B020  30        ab   @R,ra
     6B04 0091     
                   < elite.a99
23234 6B06 D040  18        movb ra,rx                      ; TAX               ; = (S R) + random * projected cloud size
23235                                                                          ;
23236                                                                          ; where S contains the argument A, starting with the low
23237                                                                          ; bytes
23238               
23239 6B08 D020  30        movb @S,ra                      ; LDA S             ; And then the high bytes
     6B0A 0092     
23240                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 6B0C 1701  14        jnc  !
0002 6B0E B004  18        ab   rone,ra
0003               !:
0004 6B10 0220  22        ai   ra,(>00*256)
     6B12 0000     
                   < elite.a99
23241               
23242 6B14 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6B16 800E     
23243               
23244               EX5:
23245 6B18 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     6B1A 4338     
23246 6B1C 06A0  28        bl   @jsr                       ;
     6B1E 8002     
23247 6B20 D800  30        movb ra,@T                      ; STA T             ; = random << 1 * projected cloud size / 256
     6B22 00D1     
23248               
23249 6B24 D020  30        movb @R,ra                      ; LDA R             ; Set (A X) = (S R) - T
     6B26 0091     
23250                      .sbc @T,ra                      ; SBC T             ;
     **** ****     > SBC
0001 6B28 1801  14        joc  !
0002 6B2A 7004  18        sb   rone,ra
0003               !:
0004 6B2C 7020  30        sb   @T,ra
     6B2E 00D1     
                   < elite.a99
23251 6B30 D040  18        movb ra,rx                      ; TAX               ; where S contains the argument A, starting with the low
23252                                                                          ; bytes
23253               
23254 6B32 D020  30        movb @S,ra                      ; LDA S             ; And then the high bytes
     6B34 0092     
23255                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 6B36 1801  14        joc  !
0002 6B38 7004  18        sb   rone,ra
0003               !:
0004 6B3A 0220  22        ai   ra,-(>00*256)
     6B3C 0000     
                   < elite.a99
23256               
23257 6B3E 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6B40 800E     
23258               
23259               * ******************************************************************************
23260               *
23261               * Name: SOS1
23262               * Type: Subroutine
23263               * Category: Universe
23264               * Summary: Update the missile indicators, set up the planet data block
23265               *
23266               * ------------------------------------------------------------------------------
23267               *
23268               * Update the missile indicators, and set up a data block for the planet, but
23269               * only setting the pitch and roll counters to 127 (no damping).
23270               *
23271               * ******************************************************************************
23272               
23273               SOS1:
23274 6B42 0206  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     6B44 7FDC     
23275 6B46 06A0  28        bl   @jsr                       ;
     6B48 8002     
23276                                                                          ; them are targeted
23277               
23278 6B4A 0200  20        li   ra,>7f*256                 ; LDA #127          ; Set the pitch and roll counters to 127, so that's a
     6B4C 7F00     
23279 6B4E D800  30        movb ra,@INWK+29                ; STA INWK+29       ; clockwise roll and a diving pitch with no damping, so
     6B50 0070     
23280 6B52 D800  30        movb ra,@INWK+30                ; STA INWK+30       ; the planet's rotation doesn't slow down
     6B54 0071     
23281               
23282 6B56 D020  30        movb @tek_,ra                   ; LDA tek           ; Set A = 128 or 130 depending on bit 1 of the system's
     6B58 0F1D     
23283 6B5A 0240  22        andi ra,>02*256                 ; AND #%00000010    ; tech level in tek
     6B5C 0200     
23284 6B5E 0260  22        ori  ra,>80*256                 ; ORA #%10000000
     6B60 8000     
23285               
23286 6B62 0460  28        b    @NWSHP                     ; JMP NWSHP         ; Add a new planet to our local bubble of universe,
     6B64 6F6E     
23287                                                                          ; with the planet type defined by A (128 is a planet
23288                                                                          ; with an equator and meridian, 130 is a planet with
23289                                                                          ; a crater)
23290               
23291               * ******************************************************************************
23292               *
23293               * Name: SOLAR
23294               * Type: Subroutine
23295               * Category: Universe
23296               * Summary: Set up various aspects of arriving in a new system
23297               *
23298               * ------------------------------------------------------------------------------
23299               *
23300               * Halve our legal status, update the missile indicators, and set up data blocks
23301               * and slots for the planet and sun.
23302               *
23303               * ******************************************************************************
23304               
23305               SOLAR:
23306                      .lsr @FIST                      ; LSR FIST          ; Halve our legal status in FIST, making us less bad,
     **** ****     > LSR
0001 6B66 D1A0  30        movb @FIST,rtmp
     6B68 0334     
0002 6B6A 0916  18        srl  rtmp,1
0003 6B6C D806  30        movb rtmp,@FIST
     6B6E 0334     
                   < elite.a99
23307                                                                          ; and moving bit 0 into the C flag (so every time we
23308                                                                          ; arrive in a new system, our legal status improves a
23309                                                                          ; bit)
23310               
23311 6B70 0206  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace, which
     6B72 7FB4     
23312 6B74 06A0  28        bl   @jsr                       ;
     6B76 8002     
23313                                                                          ; doesn't affect the C flag
23314               
23315 6B78 D020  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch s0_hi
     6B7A 0079     
23316               
23317 6B7C 0240  22        andi ra,>07*256                 ; AND #%00000111    ; Extract bits 0-2 (which also happen to determine the
     6B7E 0700     
23318                                                                          ; economy), which will be between 0 and 7
23319               
23320                      .adi (>06*256)                  ; ADC #6            ; Add 6 + C, and divide by 2, to get a result between 3
     **** ****     > ADI
0001 6B80 1701  14        jnc  !
0002 6B82 B004  18        ab   rone,ra
0003               !:
0004 6B84 0220  22        ai   ra,(>06*256)
     6B86 0600     
                   < elite.a99
23321 6B88 0910  18        srl  ra,1                       ; LSR A             ; and 7, at the same time shifting bit 0 of the result
23322                                                                          ; of the addition into the C flag
23323               
23324 6B8A D800  30        movb ra,@INWK+8                 ; STA INWK+8        ; Store the result in z_sign in byte #6
     6B8C 005B     
23325               
23326 6B8E 06A0  28        bl   @rora                      ; ROR A             ; Halve A, rotating in the C flag, which was previously
     6B90 803C     
23327 6B92 D800  30        movb ra,@INWK+2                 ; STA INWK+2        ; bit 0 of s0_hi + 6 + C, so when this is stored in both
     6B94 0055     
23328 6B96 D800  30        movb ra,@INWK+5                 ; STA INWK+5        ; x_sign and y_sign, it moves the planet to the upper
     6B98 0058     
23329                                                                          ; right or lower left
23330               
23331 6B9A 0206  20        li   rtmp,SOS1                  ; JSR SOS1          ; Call SOS1 to set up the planet's data block and add it
     6B9C 6B42     
23332 6B9E 06A0  28        bl   @jsr                       ;
     6BA0 8002     
23333                                                                          ; to FRIN, where it will get put in the first slot as
23334                                                                          ; it's the first one to be added to our local bubble of
23335                                                                          ; this new system's universe
23336               
23337 6BA2 D020  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Fetch s1_hi, extract bits 0-2, set bits 0 and 7 and
     6BA4 007B     
23338 6BA6 0240  22        andi ra,>07*256                 ; AND #%00000111    ; store in z_sign, so the sun is behind us at a distance
     6BA8 0700     
23339 6BAA 0260  22        ori  ra,>81*256                 ; ORA #%10000001    ; of 1 to 7
     6BAC 8100     
23340 6BAE D800  30        movb ra,@INWK+8                 ; STA INWK+8
     6BB0 005B     
23341               
23342 6BB2 D020  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Fetch s2_hi, extract bits 0-1 and store in x_sign and
     6BB4 007D     
23343 6BB6 0240  22        andi ra,>03*256                 ; AND #%00000011    ; y_sign, so the sun is either dead centre in our rear
     6BB8 0300     
23344 6BBA D800  30        movb ra,@INWK+2                 ; STA INWK+2        ; laser crosshairs, or off to the top left by a distance
     6BBC 0055     
23345 6BBE D800  30        movb ra,@INWK+1                 ; STA INWK+1        ; of 1 or 2 when we look out the back
     6BC0 0054     
23346               
23347 6BC2 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the pitch and roll counters to 0 (no rotation)
     6BC4 0000     
23348 6BC6 D800  30        movb ra,@INWK+29                ; STA INWK+29
     6BC8 0070     
23349 6BCA D800  30        movb ra,@INWK+30                ; STA INWK+30
     6BCC 0071     
23350               
23351 6BCE 0200  20        li   ra,>81*256                 ; LDA #129          ; Set A = 129, the ship type for the sun
     6BD0 8100     
23352               
23353 6BD2 0206  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Call NWSHP to set up the sun's data block and add it
     6BD4 6F6E     
23354 6BD6 06A0  28        bl   @jsr                       ;
     6BD8 8002     
23355                                                                          ; to FRIN, where it will get put in the second slot as
23356                                                                          ; it's the second one to be added to our local bubble
23357                                                                          ; of this new system's universe
23358               
23359               * ******************************************************************************
23360               *
23361               * Name: NWSTARS
23362               * Type: Subroutine
23363               * Category: Stardust
23364               * Summary: Initialise the stardust field
23365               *
23366               * ------------------------------------------------------------------------------
23367               *
23368               * This routine is called when the space view is initialised in routine LOOK1.
23369               *
23370               * ******************************************************************************
23371               
23372               NWSTARS:
23373 6BDA D020  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to WPSHPS to skip
     6BDC 0096     
23374               * ORA MJ                 \ the initialisation of the SX, SY and SZ tables. The OR
23375 6BDE 1622  14        jne  WPSHPS                     ; BNE WPSHPS        ; instruction is commented out in the original source,
23376                                                                          ; but it would have the effect of also skipping the
23377                                                                          ; initialisation if we had mis-jumped into witchspace
23378               
23379               * ******************************************************************************
23380               *
23381               * Name: nWq
23382               * Type: Subroutine
23383               * Category: Stardust
23384               * Summary: Create a random cloud of stardust
23385               *
23386               * ------------------------------------------------------------------------------
23387               *
23388               * Create a random cloud of stardust containing the correct number of dust
23389               * particles, i.e. NOSTM of them, which is 3 in witchspace and 18 (#NOST) in
23390               * normal space. Also clears the scanner and initialises the LSO block.
23391               *
23392               * This is called by the DEATH routine when it displays our untimely demise.
23393               *
23394               * ******************************************************************************
23395               
23396               nWq:
23397 6BE0 D0A0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     6BE2 0F33     
23398                                                                          ; we can use it as a counter through all the stardust
23399               
23400               SAL4:
23401 6BE4 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     6BE6 8070     
23402 6BE8 06A0  28        bl   @jsr                       ;
     6BEA 8002     
23403               
23404 6BEC 0260  22        ori  ra,>08*256                 ; ORA #8            ; Set A so that it's at least 8
     6BEE 0800     
23405               
23406 6BF0 D880  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; Store A in the Y-th particle's z_hi coordinate at
     6BF2 0EE8     
23407                                                                          ; SZ+Y, so the particle appears in front of us
23408               
23409 6BF4 D800  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the particle's z_hi coordinate
     6BF6 0097     
23410               
23411 6BF8 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     6BFA 8070     
23412 6BFC 06A0  28        bl   @jsr                       ;
     6BFE 8002     
23413               
23414 6C00 D880  38        movb ra,@SX(ry)                 ; STA SX,Y          ; Store A in the Y-th particle's x_hi coordinate at
     6C02 034C     
23415                                                                          ; SX+Y, so the particle appears in front of us
23416               
23417 6C04 D800  30        movb ra,@X1                     ; STA X1            ; Set X1 to the particle's x_hi coordinate
     6C06 0031     
23418               
23419 6C08 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     6C0A 8070     
23420 6C0C 06A0  28        bl   @jsr                       ;
     6C0E 8002     
23421               
23422 6C10 D880  38        movb ra,@SY(ry)                 ; STA SY,Y          ; Store A in the Y-th particle's y_hi coordinate at
     6C12 0EC2     
23423                                                                          ; SY+Y, so the particle appears in front of us
23424               
23425 6C14 D800  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 to the particle's y_hi coordinate
     6C16 0032     
23426               
23427 6C18 0206  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ
     6C1A 276C     
23428 6C1C 06A0  28        bl   @jsr                       ;
     6C1E 8002     
23429               
23430 6C20 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point to the next particle of
23431                                                                          ; stardust
23432               
23433 6C22 16E0  14        jne  SAL4                       ; BNE SAL4          ; Loop back to SAL4 until we have randomised all the
23434                                                                          ; stardust particles
23435               
23436                                                                          ; Fall through into WPSHPS to clear the scanner and
23437                                                                          ; reset the LSO block
23438               
23439               * ******************************************************************************
23440               *
23441               * Name: WPSHPS
23442               * Type: Subroutine
23443               * Category: Dashboard
23444               * Summary: Clear the scanner, reset the ball line and sun line heaps
23445               *
23446               * ------------------------------------------------------------------------------
23447               *
23448               * Remove all ships from the scanner, reset the sun line heap at LSO, and reset
23449               * the ball line heap at LSX2 and LSY2.
23450               *
23451               * ******************************************************************************
23452               
23453               WPSHPS:
23454 6C24 0201  20        li   rx,>00*256                 ; LDX #0            ; Set up a counter in X to work our way through all the
     6C26 0000     
23455                                                                          ; ship slots in FRIN
23456               
23457               WSL1:
23458 6C28 D021  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the ship type in slot X
     6C2A 0D40     
23459               
23460 6C2C 1330  14        jeq  WS2                        ; BEQ WS2           ; If the slot contains 0 then it is empty and we have
23461                                                                          ; checked all the slots (as they are always shuffled
23462                                                                          ; down in the main loop to close up and gaps), so jump
23463                                                                          ; to WS2 as we are done
23464               
23465 6C2E 112D  14        jlt  WS1                        ; BMI WS1           ; If the slot contains a ship type with bit 7 set, then
23466                                                                          ; it contains the planet or the sun, so jump down to WS1
23467                                                                          ; to skip this slot, as the planet and sun don't appear
23468                                                                          ; on the scanner
23469               
23470 6C30 D800  30        movb ra,@TYPE                   ; STA TYPE          ; Store the ship type in TYPE
     6C32 009B     
23471               
23472 6C34 0206  20        li   rtmp,GINF                  ; JSR GINF          ; Call GINF to get the address of the data block for
     6C36 6F00     
23473 6C38 06A0  28        bl   @jsr                       ;
     6C3A 8002     
23474                                                                          ; ship slot X and store it in INF
23475               
23476 6C3C 0202  20        li   ry,>1f*256                 ; LDY #31           ; We now want to copy the first 32 bytes from the ship's
     6C3E 1F00     
23477                                                                          ; data block into INWK, so set a counter in Y
23478               
23479               WSL2:
23480                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Copy the Y-th byte from the data block pointed to by
     **** ****     > LD_IND_Y_IDX
0001 6C40 D820  42        movb @INF,@rtmplb
     6C42 0020     
     6C44 830D     
0002 6C46 D1A0  30        movb @INF+1,rtmp
     6C48 0021     
0003 6C4A A182  18        a    ry,rtmp
0004 6C4C D016  26        movb *rtmp,RA
                   < elite.a99
23481 6C4E D880  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; INF into the Y-th byte of INWK workspace
     6C50 0053     
23482               
23483 6C52 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point at the next byte
23484               
23485 6C54 15F5  14        jgt  WSL2                       ; BPL WSL2          ; Loop back to WSL2 until we have copied all 32 bytes
23486               
23487 6C56 D801  30        movb rx,@XSAV                   ; STX XSAV          ; Store the ship slot number in XSAV while we call SCAN
     6C58 0093     
23488               
23489 6C5A 0206  20        li   rtmp,SCAN                  ; JSR SCAN          ; Call SCAN to plot this ship on the scanner, which will
     6C5C 4C86     
23490 6C5E 06A0  28        bl   @jsr                       ;
     6C60 8002     
23491                                                                          ; remove it as it's plotted with EOR logic
23492               
23493 6C62 D060  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the ship slot number from XSAV into X
     6C64 0093     
23494               
23495 6C66 0202  20        li   ry,>1f*256                 ; LDY #31           ; Clear bits 3, 4 and 6 in the ship's byte #31, which
     6C68 1F00     
23496                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; stops drawing the ship on-screen (bit 3), hides it
     **** ****     > LD_IND_Y_IDX
0001 6C6A D820  42        movb @INF,@rtmplb
     6C6C 0020     
     6C6E 830D     
0002 6C70 D1A0  30        movb @INF+1,rtmp
     6C72 0021     
0003 6C74 A182  18        a    ry,rtmp
0004 6C76 D016  26        movb *rtmp,RA
                   < elite.a99
23497 6C78 0240  22        andi ra,>a7*256                 ; AND #%10100111    ; from the scanner (bit 4) and stops any lasers firing
     6C7A A700     
23498                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; (bit 6)
     **** ****     > ST_IND_Y_IDX
0001 6C7C D820  42        movb @INF,@rtmplb
     6C7E 0020     
     6C80 830D     
0002 6C82 D1A0  30        movb @INF+1,rtmp
     6C84 0021     
0003 6C86 A182  18        a    ry,rtmp
0004 6C88 D580  30        movb RA,*rtmp
                   < elite.a99
23499               
23500               WS1:
23501 6C8A B044  18        ab   rone,rx                    ; INX               ; Increment X to point to the next ship slot
23502               
23503 6C8C 16CD  14        jne  WSL1                       ; BNE WSL1          ; Loop back up to process the next slot (this BNE is
23504                                                                          ; effectively a JMP as X will never be zero)
23505               
23506               WS2:
23507 6C8E 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Set LSX2 = LSY2 = &FF to clear the ball line heap
     6C90 FF00     
23508 6C92 D801  30        movb rx,@LSX2                   ; STX LSX2
     6C94 0E26     
23509 6C96 D801  30        movb rx,@LSY2                   ; STX LSY2
     6C98 0E74     
23510               
23511                                                                          ; Fall through into FLFLLS to reset the LSO block
23512               
23513               * ******************************************************************************
23514               *
23515               * Name: FLFLLS
23516               * Type: Subroutine
23517               * Category: Drawing suns
23518               * Summary: Reset the sun line heap
23519               *
23520               * ------------------------------------------------------------------------------
23521               *
23522               * Reset the sun line heap at LSO by zero-filling it and setting the first byte
23523               * to &FF.
23524               *
23525               * ------------------------------------------------------------------------------
23526               *
23527               * Returns:
23528               *
23529               * A                   A is set to 0
23530               *
23531               * ******************************************************************************
23532               
23533               FLFLLS:
23534 6C9A 0202  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     6C9C BF00     
23535                                                                          ; view, so this sets Y as a counter for the number of
23536                                                                          ; lines in the space view (i.e. 191), which is also the
23537                                                                          ; number of lines in the LSO block
23538               
23539 6C9E 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can zero-fill the LSO block
     6CA0 0000     
23540               
23541               SAL6:
23542 6CA2 D880  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; Set the Y-th byte of the LSO block to 0
     6CA4 0D66     
23543               
23544 6CA6 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter
23545               
23546 6CA8 16FC  14        jne  SAL6                       ; BNE SAL6          ; Loop back until we have filled all the way to LSO+1
23547               
23548 6CAA 7084  18        sb   rone,ry                    ; DEY               ; Decrement Y to value of &FF (as we exit the above loop
23549                                                                          ; with Y = 0)
23550               
23551 6CAC D802  30        movb ry,@LSX                    ; STY LSX           ; Set the first byte of the LSO block, which has its own
     6CAE 0D66     
23552                                                                          ; label LSX, to &FF, to indicate that the sun line heap
23553                                                                          ; is empty
23554               
23555 6CB0 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6CB2 800E     
23556               
23557               * ******************************************************************************
23558               *
23559               * Name: DET1
23560               * Type: Subroutine
23561               * Category: Drawing the screen
23562               * Summary: Show or hide the dashboard (for when we die)
23563               *
23564               * ------------------------------------------------------------------------------
23565               *
23566               * This routine sets the screen to show the number of text rows given in X.
23567               *
23568               * It is used when we are killed, as reducing the number of rows from the usual
23569               * 31 to 24 has the effect of hiding the dashboard, leaving a monochrome image
23570               * of ship debris and explosion clouds. Increasing the rows back up to 31 makes
23571               * the dashboard reappear, as the dashboard's screen memory doesn't get touched
23572               * by this process.
23573               *
23574               * ------------------------------------------------------------------------------
23575               *
23576               * Arguments:
23577               *
23578               * X                   The number of text rows to display on the screen (24
23579               * will hide the dashboard, 31 will make it reappear)
23580               *
23581               * ------------------------------------------------------------------------------
23582               *
23583               * Returns:
23584               *
23585               * A                   A is set to 6
23586               *
23587               * ******************************************************************************
23588               
23589               DET1:
23590 6CB4 0200  20        li   ra,>06*256                 ; LDA #6            ; Set A to 6 so we can update 6845 register R6 below
     6CB6 0600     
23591               
23592 6CB8 0300  22        limi 0                          ; SEI               ; Disable interrupts so we can update the 6845
     6CBA 0000     
23593               
23594 6CBC D800  38        movb ra,@VIA+>00                ; STA VIA+&00       ; Set 6845 register R6 to the value in X. Register R6
     6CBE FE00     
23595 6CC0 D801  38        movb rx,@VIA+>01                ; STX VIA+&01       ; is the "vertical displayed" register, which sets the
     6CC2 FE01     
23596                                                                          ; number of rows shown on the screen
23597               
23598 6CC4 0300  22        limi 2                          ; CLI               ; Re-enable interrupts
     6CC6 0002     
23599               
23600 6CC8 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6CCA 800E     
23601               
23602               * ******************************************************************************
23603               *
23604               * Name: SHD
23605               * Type: Subroutine
23606               * Category: Flight
23607               * Summary: Charge a shield and drain some energy from the energy banks
23608               *
23609               * ------------------------------------------------------------------------------
23610               *
23611               * Charge up a shield, and if it needs charging, drain some energy from the
23612               * energy banks.
23613               *
23614               * ------------------------------------------------------------------------------
23615               *
23616               * Arguments:
23617               *
23618               * X                   The value of the shield to recharge
23619               *
23620               * ******************************************************************************
23621               
23622 6CCC 7044  18        sb   rone,rx                    ; DEX               ; Increment the shield value so that it doesn't go past
23623                                                                          ; a maximum of 255
23624               
23625 6CCE 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6CD0 800E     
23626               
23627               SHD:
23628 6CD2 B044  18        ab   rone,rx                    ; INX               ; Increment the shield value
23629               
23630 6CD4 13FD  14        jeq  SHD-2                      ; BEQ SHD-2         ; If the shield value is 0 then this means it was 255
23631                                                                          ; before, which is the maximum value, so jump to SHD-2
23632                                                                          ; to bring it back down to 258 and return
23633               
23634                                                                          ; Otherwise fall through into DENGY to drain our energy
23635                                                                          ; to pay for all this shield charging
23636               
23637               * ******************************************************************************
23638               *
23639               * Name: DENGY
23640               * Type: Subroutine
23641               * Category: Flight
23642               * Summary: Drain some energy from the energy banks
23643               *
23644               * ------------------------------------------------------------------------------
23645               *
23646               * Returns:
23647               *
23648               * Z flag              Set if we have no energy left, clear otherwise
23649               *
23650               * ******************************************************************************
23651               
23652               DENGY:
23653 6CD6 7004  18        sb   rone,ra                    ; DEC ENERGY        ; Decrement the energy banks in ENERGY
23654               
23655                      .php                            ; PHP               ; Save the flags on the stack
     **** ****     > PHP
0001 6CD8 02C6  12        stst rtmp
0002 6CDA D686  30        movb rtmp,*rsp
0003 6CDC 060A  14        dec  rsp
                   < elite.a99
23656               
23657 6CDE 1601  14        jne  B70                        ; BNE B70           ; If the energy levels are not yet zero, skip the
23658                                                                          ; following instruction
23659               
23660 6CE0 B004  18        ab   rone,ra                    ; INC ENERGY        ; The minimum allowed energy level is 1, and we just
23661                                                                          ; reached 0, so increment ENERGY back to 1
23662               
23663               B70:
23664                      .plp                            ; PLP               ; Restore the flags from the stack, so we return with
     **** ****     > PLP
0001 6CE2 058A  14        INC  rsp
0002 6CE4 D19A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
23665                                                                          ; the Z flag from the DEC instruction above
23666               
23667 6CE6 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6CE8 800E     
23668               
23669               * ******************************************************************************
23670               *
23671               * Name: COMPAS
23672               * Type: Subroutine
23673               * Category: Dashboard
23674               * Summary: Update the compass
23675               *
23676               * ******************************************************************************
23677               
23678               COMPAS:
23679 6CEA 0206  20        li   rtmp,DOT                   ; JSR DOT           ; Call DOT to redraw (i.e. remove) the current compass
     6CEC 6DB4     
23680 6CEE 06A0  28        bl   @jsr                       ;
     6CF0 8002     
23681                                                                          ; dot
23682               
23683 6CF2 D020  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     6CF4 0D55     
23684 6CF6 1634  14        jne  SP1                        ; BNE SP1           ; SP1 to draw the space station on the compass
23685               
23686 6CF8 0206  20        li   rtmp,SPS1                  ; JSR SPS1          ; Otherwise we need to draw the planet on the compass,
     6CFA 896E     
23687 6CFC 06A0  28        bl   @jsr                       ;
     6CFE 8002     
23688                                                                          ; so first call SPS1 to calculate the vector to the
23689                                                                          ; planet and store it in XX15
23690               
23691 6D00 0460  28        b    @SP2                       ; JMP SP2           ; Jump to SP2 to draw XX15 on the compass, returning
     6D02 6D68     
23692                                                                          ; from the subroutine using a tail call
23693               
23694               * ******************************************************************************
23695               *
23696               * Name: SPS2
23697               * Type: Subroutine
23698               * Category: Maths (Arithmetic)
23699               * Summary: Calculate (Y X) = A / 10
23700               *
23701               * ------------------------------------------------------------------------------
23702               *
23703               * Calculate the following, where A is a sign-magnitude 8-bit integer and the
23704               * result is a signed 16-bit integer:
23705               *
23706               * (Y X) = A / 10
23707               *
23708               * ------------------------------------------------------------------------------
23709               *
23710               * Returns:
23711               *
23712               * C flag              The C flag is cleared
23713               *
23714               * ******************************************************************************
23715               
23716               SPS2:
23717                      .asla                           ; ASL A             ; Set X = |A| * 2, and set the C flag to the sign bit of
     **** ****     > ASLA
0001 6D04 0240  22        andi ra,>ff00
     6D06 FF00     
0002 6D08 0A10  18        sla  ra,1
                   < elite.a99
23718 6D0A D040  18        movb ra,rx                      ; TAX               ; A
23719               
23720 6D0C 0200  20        li   ra,>00*256                 ; LDA #0            ; Set Y to have the sign bit from A in bit 7, with the
     6D0E 0000     
23721 6D10 06A0  28        bl   @rora                      ; ROR A             ; rest of its bits zeroed, so Y now contains the sign of
     6D12 803C     
23722 6D14 D080  18        movb ra,ry                      ; TAY               ; the original argument
23723               
23724 6D16 0200  20        li   ra,>14*256                 ; LDA #20           ; Set Q = 20
     6D18 1400     
23725 6D1A D800  30        movb ra,@Q                      ; STA Q
     6D1C 0090     
23726               
23727 6D1E D001  18        movb rx,ra                      ; TXA               ; Copy X into A, so A now contains the argument A * 2
23728               
23729 6D20 0206  20        li   rtmp,DVID4                 ; JSR DVID4         ; Calculate the following:
     6D22 45B0     
23730 6D24 06A0  28        bl   @jsr                       ;
     6D26 8002     
23731                                                                          ;
23732                                                                          ; P = A / Q
23733                                                                          ; = |argument A| * 2 / 20
23734                                                                          ; = |argument A| / 10
23735               
23736 6D28 D060  30        movb @P,rx                      ; LDX P             ; Set X to the result
     6D2A 001B     
23737               
23738 6D2C D002  18        movb ry,ra                      ; TYA               ; If the sign of the original argument A is negative,
23739 6D2E 1104  14        jlt  LL163                      ; BMI LL163         ; jump to LL163 to flip the sign of the result
23740               
23741 6D30 0202  20        li   ry,>00*256                 ; LDY #0            ; Set the high byte of the result to 0, as the result is
     6D32 0000     
23742                                                                          ; positive
23743               
23744 6D34 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6D36 800E     
23745               
23746               LL163:
23747 6D38 0202  20        li   ry,>ff*256                 ; LDY #&FF          ; The result is negative, so set the high byte to &FF
     6D3A FF00     
23748               
23749 6D3C D001  18        movb rx,ra                      ; TXA               ; Flip the low byte and add 1 to get the negated low
23750                      .eoi (>ff*256)                  ; EOR #&FF          ; byte, using two's complement
     **** ****     > EOI
0001 6D3E 0206  20        li   rtmp,(>FF*256)
     6D40 FF00     
0002 6D42 2806  18        xor  rtmp,ra
                   < elite.a99
23751 6D44 D040  18        movb ra,rx                      ; TAX
23752 6D46 B044  18        ab   rone,rx                    ; INX
23753               
23754 6D48 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6D4A 800E     
23755               
23756               * ******************************************************************************
23757               *
23758               * Name: SPS4
23759               * Type: Subroutine
23760               * Category: Maths (Geometry)
23761               * Summary: Calculate the vector to the space station
23762               *
23763               * ------------------------------------------------------------------------------
23764               *
23765               * Calculate the vector between our ship and the space station and store it in
23766               * XX15.
23767               *
23768               * ******************************************************************************
23769               
23770               SPS4:
23771 6D4C 0201  20        li   rx,>08*256                 ; LDX #8            ; First we need to copy the space station's coordinates
     6D4E 0800     
23772                                                                          ; into K3, so set a counter to copy the first 9 bytes
23773                                                                          ; (the 3-byte x, y and z coordinates) from the station's
23774                                                                          ; data block at K% + NI% into K3
23775               
23776               SPL1:
23777 6D50 D021  34        movb @K.+NI.(rx),ra             ; LDA K%+NI%,X      ; Copy the X-th byte from the station's data block at
     6D52 0924     
23778 6D54 D840  38        movb ra,@K3(rx)                 ; STA K3,X          ; K% + NI% to the X-th byte of K3
     6D56 00D2     
23779               
23780 6D58 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
23781               
23782 6D5A 15FA  14        jgt  SPL1                       ; BPL SPL1          ; Loop back to SPL1 until we have copied all 9 bytes
23783               
23784 6D5C 0460  24        b    @TAS2                      ; JMP TAS2          ; Call TAS2 to build XX15 from K3, returning from the
     6D5E 8992     
23785                                                                          ; subroutine using a tail call
23786               
23787               * ******************************************************************************
23788               *
23789               * Name: SP1
23790               * Type: Subroutine
23791               * Category: Dashboard
23792               * Summary: Draw the space station on the compass
23793               *
23794               * ******************************************************************************
23795               
23796               SP1:
23797 6D60 0206  20        li   rtmp,SPS4                  ; JSR SPS4          ; Call SPS4 to calculate the vector to the space station
     6D62 6D4C     
23798 6D64 06A0  28        bl   @jsr                       ;
     6D66 8002     
23799                                                                          ; and store it in XX15
23800               
23801                                                                          ; Fall through into SP2 to draw XX15 on the compass
23802               
23803               * ******************************************************************************
23804               *
23805               * Name: SP2
23806               * Type: Subroutine
23807               * Category: Dashboard
23808               * Summary: Draw a dot on the compass, given the planet/station vector
23809               *
23810               * ------------------------------------------------------------------------------
23811               *
23812               * Draw a dot on the compass to represent the planet or station, whose normalised
23813               * vector is in XX15.
23814               *
23815               * XX15 to XX15+2      The normalised vector to the planet or space station,
23816               * stored as x in XX15, y in XX15+1 and z in XX15+2
23817               *
23818               * ******************************************************************************
23819               
23820               SP2:
23821 6D68 D020  30        movb @XX15,ra                   ; LDA XX15          ; Set A to the x-coordinate of the planet or station to
     6D6A 0031     
23822                                                                          ; show on the compass, which will be in the range -96 to
23823                                                                          ; +96 as the vector has been normalised
23824               
23825 6D6C 0206  20        li   rtmp,SPS2                  ; JSR SPS2          ; Set (Y X) = A / 10, so X will be from -9 to +9, which
     6D6E 6D04     
23826 6D70 06A0  28        bl   @jsr                       ;
     6D72 8002     
23827                                                                          ; is the x-offset from the centre of the compass of the
23828                                                                          ; dot we want to draw. Returns with the C flag clear
23829               
23830 6D74 D001  18        movb rx,ra                      ; TXA               ; Set COMX = 195 + X, as 186 is the pixel x-coordinate
23831                      .adi (>c3*256)                  ; ADC #195          ; of the leftmost dot possible on the compass, and X can
     **** ****     > ADI
0001 6D76 1701  14        jnc  !
0002 6D78 B004  18        ab   rone,ra
0003               !:
0004 6D7A 0220  22        ai   ra,(>C3*256)
     6D7C C300     
                   < elite.a99
23832 6D7E D800  30        movb ra,@COMX                   ; STA COMX          ; be -9, which would be 195 - 9 = 186. This also means
     6D80 0F16     
23833                                                                          ; that the highest value for COMX is 195 + 9 = 204,
23834                                                                          ; which is the pixel x-coordinate of the rightmost dot
23835                                                                          ; in the compass... but the compass dot is actually two
23836                                                                          ; pixels wide, so the compass dot can overlap the right
23837                                                                          ; edge of the compass, but not the left edge
23838               
23839 6D82 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A to the y-coordinate of the planet or station to
     6D84 0032     
23840                                                                          ; show on the compass, which will be in the range -96 to
23841                                                                          ; +96 as the vector has been normalised
23842               
23843 6D86 0206  20        li   rtmp,SPS2                  ; JSR SPS2          ; Set (Y X) = A / 10, so X will be from -9 to +9, which
     6D88 6D04     
23844 6D8A 06A0  28        bl   @jsr                       ;
     6D8C 8002     
23845                                                                          ; is the x-offset from the centre of the compass of the
23846                                                                          ; dot we want to draw. Returns with the C flag clear
23847               
23848 6D8E D801  30        movb rx,@T                      ; STX T             ; Set COMY = 204 - X, as 203 is the pixel y-coordinate
     6D90 00D1     
23849 6D92 0200  20        li   ra,>cc*256                 ; LDA #204          ; of the centre of the compass, the C flag is clear,
     6D94 CC00     
23850                      .sbc @T,ra                      ; SBC T             ; and the y-axis needs to be flipped around (because
     **** ****     > SBC
0001 6D96 1801  14        joc  !
0002 6D98 7004  18        sb   rone,ra
0003               !:
0004 6D9A 7020  30        sb   @T,ra
     6D9C 00D1     
                   < elite.a99
23851 6D9E D800  30        movb ra,@COMY                   ; STA COMY          ; when the planet or station is above us, and the
     6DA0 0F17     
23852                                                                          ; vector is therefore positive, we want to show the dot
23853                                                                          ; higher up on the compass, which has a smaller pixel
23854                                                                          ; y-coordinate). So this calculation does this:
23855                                                                          ;
23856                                                                          ; COMY = 204 - X - (1 - 0) = 203 - X
23857               
23858 6DA2 0200  20        li   ra,>f0*256                 ; LDA #&F0          ; Set A to a 4-pixel mode 5 byte row in colour 2
     6DA4 F000     
23859                                                                          ; (yellow/white), the colour for when the planet or
23860                                                                          ; station in the compass is in front of us
23861               
23862 6DA6 D060  30        movb @XX15+2,rx                 ; LDX XX15+2        ; If the z-coordinate of the XX15 vector is positive,
     6DA8 0033     
23863 6DAA 1502  14        jgt  B71                        ; BPL B71           ; skip the following instruction
23864               
23865 6DAC 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; The z-coordinate of XX15 is negative, so the planet or
     6DAE FF00     
23866                                                                          ; station is behind us and the compass dot should be in
23867                                                                          ; green/cyan, so set A to a 4-pixel mode 5 byte row in
23868                                                                          ; colour 3
23869               
23870               B71:
23871 6DB0 D800  30        movb ra,@COMC                   ; STA COMC          ; Store the compass colour in COMC
     6DB2 0F48     
23872               
23873                                                                          ; Fall through into DOT to draw the dot on the compass
23874               
23875               * ******************************************************************************
23876               *
23877               * Name: DOT
23878               * Type: Subroutine
23879               * Category: Dashboard
23880               * Summary: Draw a dash on the compass
23881               *
23882               * ------------------------------------------------------------------------------
23883               *
23884               * Arguments:
23885               *
23886               * COMX                The screen pixel x-coordinate of the dash
23887               *
23888               * COMY                The screen pixel y-coordinate of the dash
23889               *
23890               * COMC                The colour and thickness of the dash:
23891               *
23892               * * &F0 = a double-height dash in yellow/white, for when
23893               * the object in the compass is in front of us
23894               *
23895               * * &FF = a single-height dash in green/cyan, for when
23896               * the object in the compass is behind us
23897               *
23898               * ******************************************************************************
23899               
23900               DOT:
23901 6DB4 D020  30        movb @COMY,ra                   ; LDA COMY          ; Set Y1 = COMY, the y-coordinate of the dash
     6DB6 0F17     
23902 6DB8 D800  30        movb ra,@Y1                     ; STA Y1
     6DBA 0032     
23903               
23904 6DBC D020  30        movb @COMX,ra                   ; LDA COMX          ; Set X1 = COMX, the x-coordinate of the dash
     6DBE 0F16     
23905 6DC0 D800  30        movb ra,@X1                     ; STA X1
     6DC2 0031     
23906               
23907 6DC4 D020  30        movb @COMC,ra                   ; LDA COMC          ; Set COL = COMC, the mode 5 colour byte for the dash
     6DC6 0F48     
23908 6DC8 D800  30        movb ra,@COL                    ; STA COL
     6DCA 00A2     
23909               
23910 6DCC 0280  22        ci   ra,>f0*256                 ; CMP #&F0          ; If COL is &F0 then the planet/station is in front of
     6DCE F000     
23911 6DD0 1605  14        jne  CPIX2                      ; BNE CPIX2         ; us and we want to draw a double-height dash, so if it
23912                                                                          ; isn't &F0 jump to CPIX2 to draw a single-height dash
23913               
23914                                                                          ; Otherwise fall through into CPIX4 to draw a double-
23915                                                                          ; height dash
23916               
23917               * ******************************************************************************
23918               *
23919               * Name: CPIX4
23920               * Type: Subroutine
23921               * Category: Drawing pixels
23922               * Summary: Draw a double-height dot on the dashboard
23923               *
23924               * ------------------------------------------------------------------------------
23925               *
23926               * Draw a double-height mode 5 dot (2 pixels high, 2 pixels wide).
23927               *
23928               * ------------------------------------------------------------------------------
23929               *
23930               * Arguments:
23931               *
23932               * X1                  The screen pixel x-coordinate of the bottom-left corner
23933               * of the dot
23934               *
23935               * Y1                  The screen pixel y-coordinate of the bottom-left corner
23936               * of the dot
23937               *
23938               * COL                 The colour of the dot as a mode 5 character row byte
23939               *
23940               * ******************************************************************************
23941               
23942               CPIX4:
23943 6DD2 0206  20        li   rtmp,CPIX2                 ; JSR CPIX2         ; Call CPIX2 to draw a single-height dash at (X1, Y1)
     6DD4 6DDC     
23944 6DD6 06A0  28        bl   @jsr                       ;
     6DD8 8002     
23945               
23946 6DDA 7004  18        sb   rone,ra                    ; DEC Y1            ; Decrement Y1
23947               
23948                                                                          ; Fall through into CPIX2 to draw a second single-height
23949                                                                          ; dash on the pixel row above the first one, to create a
23950                                                                          ; double-height dot
23951               
23952               * ******************************************************************************
23953               *
23954               * Name: CPIX2
23955               * Type: Subroutine
23956               * Category: Drawing pixels
23957               * Summary: Draw a single-height dash on the dashboard
23958               * Deep dive: Drawing colour pixels in mode 5
23959               *
23960               * ------------------------------------------------------------------------------
23961               *
23962               * Draw a single-height mode 5 dash (1 pixel high, 2 pixels wide).
23963               *
23964               * ------------------------------------------------------------------------------
23965               *
23966               * Arguments:
23967               *
23968               * X1                  The screen pixel x-coordinate of the dash
23969               *
23970               * Y1                  The screen pixel y-coordinate of the dash
23971               *
23972               * COL                 The colour of the dash as a mode 5 character row byte
23973               *
23974               * ******************************************************************************
23975               
23976               CPIX2:
23977 6DDC D020  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate into A
     6DDE 0032     
23978               
23979               * .CPIX                  \ This label is commented out in the original source. It
23980                                                                          ; would provide a new entry point with A specifying the
23981                                                                          ; y-coordinate instead of Y1, but it isn't used anywhere
23982               
23983 6DE0 D080  18        movb ra,ry                      ; TAY               ; Store the y-coordinate in Y
23984               
23985 6DE2 0910  18        srl  ra,1                       ; LSR A             ; Set A = A / 8, so A now contains the character row we
23986 6DE4 0910  18        srl  ra,1                       ; LSR A             ; need to draw in (as each character row contains 8
23987 6DE6 0910  18        srl  ra,1                       ; LSR A             ; pixel rows)
23988               
23989 6DE8 0260  22        ori  ra,>60*256                 ; ORA #&60          ; Each character row in Elite's screen mode takes up one
     6DEA 6000     
23990                                                                          ; page in memory (256 bytes), so we now OR with &60 to
23991                                                                          ; get the page containing the dash (see the comments in
23992                                                                          ; routine TT26 for more discussion about calculating
23993                                                                          ; screen memory addresses)
23994               
23995 6DEC D800  30        movb ra,@SCH                    ; STA SCH           ; Store the screen page in the high byte of SC(1 0)
     6DEE 0008     
23996               
23997 6DF0 D020  30        movb @X1,ra                     ; LDA X1            ; Each character block contains 8 pixel rows, so to get
     6DF2 0031     
23998 6DF4 0240  22        andi ra,>f8*256                 ; AND #%11111000    ; the address of the first byte in the character block
     6DF6 F800     
23999                                                                          ; that we need to draw into, as an offset from the start
24000                                                                          ; of the row, we clear bits 0-2
24001               
24002 6DF8 D800  30        movb ra,@SC                     ; STA SC            ; Store the address of the character block in the low
     6DFA 0007     
24003                                                                          ; byte of SC(1 0), so now SC(1 0) points to the
24004                                                                          ; character block we need to draw into
24005               
24006 6DFC D002  18        movb ry,ra                      ; TYA               ; Set Y to just bits 0-2 of the y-coordinate, which will
24007 6DFE 0240  22        andi ra,>07*256                 ; AND #%00000111    ; be the number of the pixel row we need to draw into
     6E00 0700     
24008 6E02 D080  18        movb ra,ry                      ; TAY               ; within the character block
24009               
24010 6E04 D020  30        movb @X1,ra                     ; LDA X1            ; Copy bits 0-1 of X1 to bits 1-2 of X, and clear the C
     6E06 0031     
24011 6E08 0240  22        andi ra,>06*256                 ; AND #%00000110    ; flag in the process (using the LSR). X will now be
     6E0A 0600     
24012 6E0C 0910  18        srl  ra,1                       ; LSR A             ; a value between 0 and 3, and will be the pixel number
24013 6E0E D040  18        movb ra,rx                      ; TAX               ; in the character row for the left pixel in the dash.
24014                                                                          ; This is because each character row is one byte that
24015                                                                          ; contains 4 pixels, but covers 8 screen coordinates, so
24016                                                                          ; this effectively does the division by 2 that we need
24017               
24018 6E10 D021  34        movb @CTWOS(rx),ra              ; LDA CTWOS,X       ; Fetch a mode 5 1-pixel byte with the pixel position
     6E12 2249     
24019                      .and @COL                       ; AND COL           ; at X, and AND with the colour byte so that pixel takes
     **** ****     > AND
0001 6E14 D1A0  30        movb @COL,rtmp
     6E16 00A2     
0002 6E18 0546  14        inv  rtmp
0003 6E1A 5006  18        szcb rtmp,ra
                   < elite.a99
24020                                                                          ; on the colour we want to draw (i.e. A is acting as a
24021                                                                          ; mask on the colour byte)
24022               
24023                      .eor @SC                        ; EOR (SC),Y        ; Draw the pixel on-screen using EOR logic, so we can
     **** ****     > EOR
0001 6E1C D1A0  30        movb @SC,rtmp
     6E1E 0007     
0002 6E20 2806  18        xor  rtmp,ra
                   < elite.a99
24024                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; remove it later without ruining the background that's
     **** ****     > ST_IND_Y_IDX
0001 6E22 D820  42        movb @SC,@rtmplb
     6E24 0007     
     6E26 830D     
0002 6E28 D1A0  30        movb @SC+1,rtmp
     6E2A 0008     
0003 6E2C A182  18        a    ry,rtmp
0004 6E2E D580  30        movb RA,*rtmp
                   < elite.a99
24025                                                                          ; already on-screen
24026               
24027 6E30 D021  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Fetch a mode 5 1-pixel byte with the pixel position
     6E32 224A     
24028                                                                          ; at X+1, so we can draw the right pixel of the dash
24029               
24030 6E34 150A  14        jgt  CP1                        ; BPL CP1           ; The CTWOS table has an extra row at the end of it that
24031                                                                          ; repeats the first value, %10001000, so if we have not
24032                                                                          ; fetched that value, then the right pixel of the dash
24033                                                                          ; is in the same character block as the left pixel, so
24034                                                                          ; jump to CP1 to draw it
24035               
24036 6E36 D020  30        movb @SC,ra                     ; LDA SC            ; Otherwise the left pixel we drew was at the last
     6E38 0007     
24037                      .adi (>08*256)                  ; ADC #8            ; position of four in this character block, so we add
     **** ****     > ADI
0001 6E3A 1701  14        jnc  !
0002 6E3C B004  18        ab   rone,ra
0003               !:
0004 6E3E 0220  22        ai   ra,(>08*256)
     6E40 0800     
                   < elite.a99
24038 6E42 D800  30        movb ra,@SC                     ; STA SC            ; 8 to the screen address to move onto the next block
     6E44 0007     
24039                                                                          ; along (as there are 8 bytes in a character block).
24040                                                                          ; The C flag was cleared above, so this ADC is correct
24041               
24042 6E46 D021  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Re-fetch the mode 5 1-pixel byte, as we just overwrote
     6E48 224A     
24043                                                                          ; A (the byte will still be the fifth byte from the
24044                                                                          ; table, which is correct as we want to draw the
24045                                                                          ; leftmost pixel in the next character along as the
24046                                                                          ; dash's right pixel)
24047               
24048               CP1:
24049                      .and @COL                       ; AND COL           ; Apply the colour mask to the pixel byte, as above
     **** ****     > AND
0001 6E4A D1A0  30        movb @COL,rtmp
     6E4C 00A2     
0002 6E4E 0546  14        inv  rtmp
0003 6E50 5006  18        szcb rtmp,ra
                   < elite.a99
24050               
24051                      .eor @SC                        ; EOR (SC),Y        ; Draw the dash's right pixel according to the mask in
     **** ****     > EOR
0001 6E52 D1A0  30        movb @SC,rtmp
     6E54 0007     
0002 6E56 2806  18        xor  rtmp,ra
                   < elite.a99
24052                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; A, with the colour in COL, using EOR logic, just as
     **** ****     > ST_IND_Y_IDX
0001 6E58 D820  42        movb @SC,@rtmplb
     6E5A 0007     
     6E5C 830D     
0002 6E5E D1A0  30        movb @SC+1,rtmp
     6E60 0008     
0003 6E62 A182  18        a    ry,rtmp
0004 6E64 D580  30        movb RA,*rtmp
                   < elite.a99
24053                                                                          ; above
24054               
24055 6E66 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6E68 800E     
24056               
24057               * ******************************************************************************
24058               *
24059               * Name: OOPS
24060               * Type: Subroutine
24061               * Category: Flight
24062               * Summary: Take some damage
24063               *
24064               * ------------------------------------------------------------------------------
24065               *
24066               * We just took some damage, so reduce the shields if we have any, or reduce the
24067               * energy levels and potentially take some damage to the cargo if we don't.
24068               *
24069               * ------------------------------------------------------------------------------
24070               *
24071               * Arguments:
24072               *
24073               * A                   The amount of damage to take
24074               *
24075               * INF                 The address of the ship block for the ship that attacked
24076               * us, or the ship that we just ran into
24077               *
24078               * ******************************************************************************
24079               
24080               OOPS:
24081 6E6A D800  30        movb ra,@T                      ; STA T             ; Store the amount of damage in T
     6E6C 00D1     
24082               
24083 6E6E 0202  20        li   ry,>08*256                 ; LDY #8            ; Fetch byte #8 (z_sign) for the ship attacking us, and
     6E70 0800     
24084 6E72 0201  20        li   rx,>00*256                 ; LDX #0            ; set X = 0
     6E74 0000     
24085                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y
     **** ****     > LD_IND_Y_IDX
0001 6E76 D820  42        movb @INF,@rtmplb
     6E78 0020     
     6E7A 830D     
0002 6E7C D1A0  30        movb @INF+1,rtmp
     6E7E 0021     
0003 6E80 A182  18        a    ry,rtmp
0004 6E82 D016  26        movb *rtmp,RA
                   < elite.a99
24086               
24087 6E84 110E  14        jlt  OO1                        ; BMI OO1           ; If A is negative, then we got hit in the rear, so jump
24088                                                                          ; to OO1 to process damage to the aft shield
24089               
24090 6E86 D020  30        movb @FSH,ra                    ; LDA FSH           ; Otherwise the forward shield was damaged, so fetch the
     6E88 0F11     
24091                      .sbc @T,ra                      ; SBC T             ; shield strength from FSH and subtract the damage in T
     **** ****     > SBC
0001 6E8A 1801  14        joc  !
0002 6E8C 7004  18        sb   rone,ra
0003               !:
0004 6E8E 7020  30        sb   @T,ra
     6E90 00D1     
                   < elite.a99
24092               
24093 6E92 1704  14        jnc  OO2                        ; BCC OO2           ; If the C flag is clear then this amount of damage was
24094                                                                          ; too much for the shields, so jump to OO2 to set the
24095                                                                          ; shield level to 0 and start taking damage directly
24096                                                                          ; from the energy banks
24097               
24098 6E94 D800  30        movb ra,@FSH                    ; STA FSH           ; Store the new value of the forward shield in FSH
     6E96 0F11     
24099               
24100 6E98 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6E9A 800E     
24101               
24102               OO2:
24103               * LDX #0                 \ This instruction is commented out in the original
24104                                                                          ; source, and isn't required as X is set to 0 above
24105 6E9C D801  30        movb rx,@FSH                    ; STX FSH           ; Set the forward shield to 0
     6E9E 0F11     
24106               
24107 6EA0 170D  14        jnc  OO3                        ; BCC OO3           ; Jump to OO3 to start taking damage directly from the
24108                                                                          ; energy banks (this BCC is effectively a JMP as the C
24109                                                                          ; flag is clear, as we jumped to OO2 with a BCC)
24110               
24111               OO1:
24112 6EA2 D020  30        movb @ASH,ra                    ; LDA ASH           ; The aft shield was damaged, so fetch the shield
     6EA4 0F12     
24113                      .sbc @T,ra                      ; SBC T             ; strength from ASH and subtract the damage in T
     **** ****     > SBC
0001 6EA6 1801  14        joc  !
0002 6EA8 7004  18        sb   rone,ra
0003               !:
0004 6EAA 7020  30        sb   @T,ra
     6EAC 00D1     
                   < elite.a99
24114               
24115 6EAE 1704  14        jnc  OO5                        ; BCC OO5           ; If the C flag is clear then this amount of damage was
24116                                                                          ; too much for the shields, so jump to OO5 to set the
24117                                                                          ; shield level to 0 and start taking damage directly
24118                                                                          ; from the energy banks
24119               
24120 6EB0 D800  30        movb ra,@ASH                    ; STA ASH           ; Store the new value of the aft shield in ASH
     6EB2 0F12     
24121               
24122 6EB4 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6EB6 800E     
24123               
24124               OO5:
24125               * LDX #0                 \ This instruction is commented out in the original
24126                                                                          ; source, and isn't required as X is set to 0 above
24127 6EB8 D801  30        movb rx,@ASH                    ; STX ASH           ; Set the aft shield to 0
     6EBA 0F12     
24128               
24129               OO3:
24130                      .adc @ENERGY,ra                 ; ADC ENERGY        ; A is negative and contains the amount by which the
     **** ****     > ADC
0001 6EBC 1701  14        jnc  !
0002 6EBE B004  18        ab   rone,ra
0003               !:
0004 6EC0 B020  30        ab   @ENERGY,ra
     6EC2 0F13     
                   < elite.a99
24131 6EC4 D800  30        movb ra,@ENERGY                 ; STA ENERGY        ; damage overwhelmed the shields, so this drains the
     6EC6 0F13     
24132                                                                          ; energy banks by that amount (and because the energy
24133                                                                          ; banks are shown over four indicators rather than one,
24134                                                                          ; but with the same value range of 0-255, energy will
24135                                                                          ; appear to drain away four times faster than the
24136                                                                          ; shields did)
24137               
24138 6EC8 1301  14        jeq  B72                        ; BEQ B72           ; If we have just run out of energy, skip the next
24139                                                                          ; instruction to jump straight to our death
24140               
24141 6ECA 1802  14        joc  B73                        ; BCS B73           ; If the C flag is set, then subtracting the damage from
24142                                                                          ; the energy banks didn't underflow, so we had enough
24143                                                                          ; energy to survive, and we can skip the next
24144                                                                          ; instruction to make a sound and take some damage
24145               
24146               B72:
24147 6ECC 0460  24        b    @DEATH                     ; JMP DEATH         ; Otherwise our energy levels are either 0 or negative,
     6ECE 8472     
24148                                                                          ; and in either case that means we jump to our DEATH,
24149                                                                          ; returning from the subroutine using a tail call
24150               
24151               B73:
24152 6ED0 0206  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; We didn't die, so call EXNO3 to make the sound of a
     6ED2 8B22     
24153 6ED4 06A0  28        bl   @jsr                       ;
     6ED6 8002     
24154                                                                          ; collision
24155               
24156 6ED8 0460  24        b    @OUCH                      ; JMP OUCH          ; And jump to OUCH to take damage and return from the
     6EDA 8E94     
24157                                                                          ; subroutine using a tail call
24158               
24159               * ******************************************************************************
24160               *
24161               * Name: SPS3
24162               * Type: Subroutine
24163               * Category: Maths (Geometry)
24164               * Summary: Copy a space coordinate from the K% block into K3
24165               *
24166               * ------------------------------------------------------------------------------
24167               *
24168               * Copy one of the planet's coordinates into the corresponding location in the
24169               * temporary variable K3. The high byte and absolute value of the sign byte are
24170               * copied into the first two K3 bytes, and the sign of the sign byte is copied
24171               * into the highest K3 byte.
24172               *
24173               * The comments below are written for copying the planet's x-coordinate into
24174               * K3(2 1 0).
24175               *
24176               * ------------------------------------------------------------------------------
24177               *
24178               * Arguments:
24179               *
24180               * X                   Determines which coordinate to copy, and to where:
24181               *
24182               * * X = 0 copies (x_sign, x_hi) into K3(2 1 0)
24183               *
24184               * * X = 3 copies (y_sign, y_hi) into K3(5 4 3)
24185               *
24186               * * X = 6 copies (z_sign, z_hi) into K3(8 7 6)
24187               *
24188               * ******************************************************************************
24189               
24190               SPS3:
24191 6EDC D021  34        movb @K.+1(rx),ra               ; LDA K%+1,X        ; Copy x_hi into K3+X
     6EDE 0901     
24192 6EE0 D840  38        movb ra,@K3(rx)                 ; STA K3,X
     6EE2 00D2     
24193               
24194 6EE4 D021  34        movb @K.+2(rx),ra               ; LDA K%+2,X        ; Set A = Y = x_sign
     6EE6 0902     
24195 6EE8 D080  18        movb ra,ry                      ; TAY
24196               
24197 6EEA 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Set K3+1 = |x_sign|
     6EEC 7F00     
24198 6EEE D840  38        movb ra,@K3+1(rx)               ; STA K3+1,X
     6EF0 00D3     
24199               
24200 6EF2 D002  18        movb ry,ra                      ; TYA               ; Set K3+2 = the sign of x_sign
24201 6EF4 0240  22        andi ra,>80*256                 ; AND #%10000000
     6EF6 8000     
24202 6EF8 D840  38        movb ra,@K3+2(rx)               ; STA K3+2,X
     6EFA 00D4     
24203               
24204 6EFC 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6EFE 800E     
24205               
24206               * ******************************************************************************
24207               *
24208               * Name: GINF
24209               * Type: Subroutine
24210               * Category: Universe
24211               * Summary: Fetch the address of a ship's data block into INF
24212               *
24213               * ------------------------------------------------------------------------------
24214               *
24215               * Get the address of the data block for ship slot X and store it in INF. This
24216               * address is fetched from the UNIV table, which stores the addresses of the 13
24217               * ship data blocks in workspace K%.
24218               *
24219               * ------------------------------------------------------------------------------
24220               *
24221               * Arguments:
24222               *
24223               * X                   The ship slot number for which we want the data block
24224               * address
24225               *
24226               * ******************************************************************************
24227               
24228               GINF:
24229 6F00 D001  18        movb rx,ra                      ; TXA               ; Set Y = X * 2
24230                      .asla                           ; ASL A
     **** ****     > ASLA
0001 6F02 0240  22        andi ra,>ff00
     6F04 FF00     
0002 6F06 0A10  18        sla  ra,1
                   < elite.a99
24231 6F08 D080  18        movb ra,ry                      ; TAY
24232               
24233 6F0A D022  34        movb @UNIV(ry),ra               ; LDA UNIV,Y        ; Get the high byte of the address of the X-th ship
     6F0C 221F     
24234 6F0E D800  30        movb ra,@INF                    ; STA INF           ; from UNIV and store it in INF
     6F10 0020     
24235               
24236 6F12 D022  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y      ; Get the low byte of the address of the X-th ship
     6F14 2220     
24237 6F16 D800  30        movb ra,@INF+1                  ; STA INF+1         ; from UNIV and store it in INF
     6F18 0021     
24238               
24239 6F1A 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     6F1C 800E     
24240               
24241               * ******************************************************************************
24242               *
24243               * Name: NWSPS
24244               * Type: Subroutine
24245               * Category: Universe
24246               * Summary: Add a new space station to our local bubble of universe
24247               *
24248               * ******************************************************************************
24249               
24250               NWSPS:
24251 6F1E 0206  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Light up the space station bulb on the dashboard
     6F20 70D6     
24252 6F22 06A0  28        bl   @jsr                       ;
     6F24 8002     
24253               
24254 6F26 0201  20        li   rx,>01*256                 ; LDX #%00000001    ; Set the AI flag in byte #32 to %00000001 (friendly, no
     6F28 0100     
24255 6F2A D801  30        movb rx,@INWK+32                ; STX INWK+32       ; AI, has an E.C.M.)
     6F2C 0073     
24256               
24257 6F2E 7044  18        sb   rone,rx                    ; DEX               ; Set pitch counter to 0 (no pitch, roll only)
24258 6F30 D801  30        movb rx,@INWK+30                ; STX INWK+30
     6F32 0071     
24259               
24260               * STX INWK+31            \ This instruction is commented out in the original
24261                                                                          ; source. It would set the exploding state and missile
24262                                                                          ; count to 0
24263               
24264 6F34 D801  30        movb rx,@FRIN+1                 ; STX FRIN+1        ; Set the second slot in the FRIN table to 0, so when we
     6F36 0D41     
24265                                                                          ; fall through into NWSHP below, the new station that
24266                                                                          ; gets created will go into slot FRIN+1, as this will be
24267                                                                          ; the first empty slot that the routine finds
24268               
24269 6F38 7044  18        sb   rone,rx                    ; DEX               ; Set the roll counter to 255 (maximum anti-clockwise
24270 6F3A D801  30        movb rx,@INWK+29                ; STX INWK+29       ; roll with no damping)
     6F3C 0070     
24271               
24272 6F3E 0201  20        li   rx,>0a*256                 ; LDX #10           ; Call NwS1 to flip the sign of nosev_x_hi (byte #10)
     6F40 0A00     
24273 6F42 0206  20        li   rtmp,NwS1                  ; JSR NwS1
     6F44 7080     
24274 6F46 06A0  28        bl   @jsr                       ;
     6F48 8002     
24275               
24276 6F4A 0206  20        li   rtmp,NwS1                  ; JSR NwS1          ; And again to flip the sign of nosev_y_hi (byte #12)
     6F4C 7080     
24277 6F4E 06A0  28        bl   @jsr                       ;
     6F50 8002     
24278               
24279 6F52 0206  20        li   rtmp,NwS1                  ; JSR NwS1          ; And again to flip the sign of nosev_z_hi (byte #14)
     6F54 7080     
24280 6F56 06A0  28        bl   @jsr                       ;
     6F58 8002     
24281               
24282 6F5A 0200  20        li   ra,((LSO)%256)*256         ; LDA #LO(LSO)      ; Set bytes #33 and #34 to point to LSO for the ship
     6F5C 6600     
24283 6F5E D800  30        movb ra,@INWK+33                ; STA INWK+33       ; line heap for the space station
     6F60 0074     
24284 6F62 0200  20        li   ra,((LSO)/256)*256         ; LDA #HI(LSO)
     6F64 0D00     
24285 6F66 D800  30        movb ra,@INWK+34                ; STA INWK+34
     6F68 0075     
24286               
24287 6F6A 0200  20        li   ra,(SST)*256               ; LDA #SST          ; Set A to the space station type, and fall through
     6F6C 0800     
24288                                                                          ; into NWSHP to finish adding the space station to the
24289                                                                          ; universe
24290               
24291               * ******************************************************************************
24292               *
24293               * Name: NWSHP
24294               * Type: Subroutine
24295               * Category: Universe
24296               * Summary: Add a new ship to our local bubble of universe
24297               *
24298               * ------------------------------------------------------------------------------
24299               *
24300               * This creates a new block of ship data in the K% workspace, allocates a new
24301               * block in the ship line heap at WP, adds the new ship's type into the first
24302               * empty slot in FRIN, and adds a pointer to the ship data into UNIV. If there
24303               * isn't enough free memory for the new ship, it isn't added.
24304               *
24305               * ------------------------------------------------------------------------------
24306               *
24307               * Arguments:
24308               *
24309               * A                   The type of the ship to add (see variable XX21 for a
24310               * list of ship types)
24311               *
24312               * ------------------------------------------------------------------------------
24313               *
24314               * Returns:
24315               *
24316               * C flag              Set if the ship was successfully added, clear if it
24317               * wasn't (as there wasn't enough free memory)
24318               *
24319               * INF                 Points to the new ship's data block in K%
24320               *
24321               * ******************************************************************************
24322               
24323               NWSHP:
24324 6F6E D800  30        movb ra,@T                      ; STA T             ; Store the ship type in location T
     6F70 00D1     
24325               
24326 6F72 0201  20        li   rx,>00*256                 ; LDX #0            ; Before we can add a new ship, we need to check
     6F74 0000     
24327                                                                          ; whether we have an empty slot we can put it in. To do
24328                                                                          ; this, we need to loop through all the slots to look
24329                                                                          ; for an empty one, so set a counter in X that starts
24330                                                                          ; from the first slot at 0. When ships are killed, then
24331                                                                          ; the slots are shuffled down by the KILLSHP routine, so
24332                                                                          ; the first empty slot will always come after the last
24333                                                                          ; filled slot. This allows us to tack the new ship's
24334                                                                          ; data block and ship line heap onto the end of the
24335                                                                          ; existing ship data and heap, as shown in the memory
24336                                                                          ; map below
24337               
24338               NWL1:
24339 6F76 D021  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Load the ship type for the X-th slot
     6F78 0D40     
24340               
24341 6F7A 1307  14        jeq  NW1                        ; BEQ NW1           ; If it is zero, then this slot is empty and we can use
24342                                                                          ; it for our new ship, so jump down to NW1
24343               
24344 6F7C B044  18        ab   rone,rx                    ; INX               ; Otherwise increment X to point to the next slot
24345               
24346 6F7E 0281  22        ci   rx,(NOSH)*256              ; CPX #NOSH         ; If we haven't reached the last slot yet, loop back up
     6F80 0C00     
24347 6F82 17F9  14        jnc  NWL1                       ; BCC NWL1          ; to NWL1 to check the next slot (note that this means
24348                                                                          ; only slots from 0 to #NOSH - 1 are populated by this
24349                                                                          ; routine, but there is one more slot reserved in FRIN,
24350                                                                          ; which is used to identify the end of the slot list
24351                                                                          ; when shuffling the slots down in the KILLSHP routine)
24352               
24353               NW3:
24354                      .clc                            ; CLC               ; Otherwise we don't have an empty slot, so we can't
     **** ****     > CLC
0001 6F84 0A13  18        sla  rzero,1
                   < elite.a99
24355 6F86 0460  24        b    @rts                       ; RTS               ; add a new ship, so clear the C flag to indicate that
     6F88 800E     
24356                                                                          ; we have not managed to create the new ship, and return
24357                                                                          ; from the subroutine
24358               
24359               NW1:
24360                                                                          ; If we get here, then we have found an empty slot at
24361                                                                          ; index X, so we can go ahead and create our new ship.
24362                                                                          ; We do that by creating a ship data block at INWK and,
24363                                                                          ; when we are done, copying the block from INWK into
24364                                                                          ; the K% workspace (specifically, to INF)
24365 6F8A 0206  20        li   rtmp,GINF                  ; JSR GINF          ; Get the address of the data block for ship slot X
     6F8C 6F00     
24366 6F8E 06A0  28        bl   @jsr                       ;
     6F90 8002     
24367                                                                          ; (which is in workspace K%) and store it in INF
24368               
24369 6F92 D020  30        movb @T,ra                      ; LDA T             ; If the type of ship that we want to create is
     6F94 00D1     
24370 6F96 115F  14        jlt  NW2                        ; BMI NW2           ; negative, then this indicates a planet or sun, so
24371                                                                          ; jump down to NW2, as the next section sets up a ship
24372                                                                          ; data block, which doesn't apply to planets and suns,
24373                                                                          ; as they don't have things like shields, missiles,
24374                                                                          ; vertices and edges
24375               
24376                                                                          ; This is a ship, so first we need to set up various
24377                                                                          ; pointers to the ship blueprint we will need. The
24378                                                                          ; blueprints for each ship type in Elite are stored
24379                                                                          ; in a table at location XX21, so refer to the comments
24380                                                                          ; on that variable for more details on the data we're
24381                                                                          ; about to access
24382               
24383                      .asla                           ; ASL A             ; Set Y = ship type * 2
     **** ****     > ASLA
0001 6F98 0240  22        andi ra,>ff00
     6F9A FF00     
0002 6F9C 0A10  18        sla  ra,1
                   < elite.a99
24384 6F9E D080  18        movb ra,ry                      ; TAY
24385               
24386 6FA0 D022  34        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; The ship blueprints at XX21 start with a lookup
     6FA2 A7D4     
24387 6FA4 D800  30        movb ra,@XX0                    ; STA XX0           ; table that points to the individual ship blueprints,
     6FA6 001E     
24388                                                                          ; so this fetches the low byte of this particular ship
24389                                                                          ; type's blueprint and stores it in XX0
24390               
24391 6FA8 D022  34        movb @XX21-1(ry),ra             ; LDA XX21-1,Y      ; Fetch the high byte of this particular ship type's
     6FAA A7D5     
24392 6FAC D800  30        movb ra,@XX0+1                  ; STA XX0+1         ; blueprint and store it in XX0+1, so XX0(1 0) now
     6FAE 001F     
24393                                                                          ; contains the address of this ship's blueprint
24394               
24395 6FB0 0282  22        ci   ry,(2*SST)*256             ; CPY #2*SST        ; If the ship type is a space station (SST), then jump
     6FB2 1000     
24396 6FB4 1336  14        jeq  NW6                        ; BEQ NW6           ; to NW6, skipping the heap space steps below, as the
24397                                                                          ; space station has its own line heap at LSO (which it
24398                                                                          ; shares with the sun)
24399               
24400                                                                          ; We now want to allocate space for a heap that we can
24401                                                                          ; use to store the lines we draw for our new ship (so it
24402                                                                          ; can easily be erased from the screen again). SLSP
24403                                                                          ; points to the start of the current heap space, and we
24404                                                                          ; can extend it downwards with the heap for our new ship
24405                                                                          ; (as the heap space always ends just before the WP
24406                                                                          ; workspace)
24407               
24408 6FB6 0202  20        li   ry,>05*256                 ; LDY #5            ; Fetch ship blueprint byte #5, which contains the
     6FB8 0500     
24409                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; maximum heap size required for plotting the new ship,
     **** ****     > LD_IND_Y_IDX
0001 6FBA D820  42        movb @XX0,@rtmplb
     6FBC 001E     
     6FBE 830D     
0002 6FC0 D1A0  30        movb @XX0+1,rtmp
     6FC2 001F     
0003 6FC4 A182  18        a    ry,rtmp
0004 6FC6 D016  26        movb *rtmp,RA
                   < elite.a99
24410 6FC8 D800  30        movb ra,@T1                     ; STA T1            ; and store it in T1
     6FCA 0006     
24411               
24412 6FCC D020  30        movb @SLSP,ra                   ; LDA SLSP          ; Take the 16-bit address in SLSP and subtract T1,
     6FCE 0F1E     
24413                      .sec                            ; SEC               ; storing the 16-bit result in INWK(34 33), so this now
     **** ****     > SEC
0001 6FD0 0A15  18        sla  rmone,1
                   < elite.a99
24414                      .sbc @T1,ra                     ; SBC T1            ; points to the start of the line heap for our new ship
     **** ****     > SBC
0001 6FD2 1801  14        joc  !
0002 6FD4 7004  18        sb   rone,ra
0003               !:
0004 6FD6 7020  30        sb   @T1,ra
     6FD8 0006     
                   < elite.a99
24415 6FDA D800  30        movb ra,@INWK+33                ; STA INWK+33
     6FDC 0074     
24416 6FDE D020  30        movb @SLSP+1,ra                 ; LDA SLSP+1
     6FE0 0F1F     
24417                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 6FE2 1801  14        joc  !
0002 6FE4 7004  18        sb   rone,ra
0003               !:
0004 6FE6 0220  22        ai   ra,-(>00*256)
     6FE8 0000     
                   < elite.a99
24418 6FEA D800  30        movb ra,@INWK+34                ; STA INWK+34
     6FEC 0075     
24419               
24420                                                                          ; We now need to check that there is enough free space
24421                                                                          ; for both this new line heap and the new data block
24422                                                                          ; for our ship. In memory, this is the layout of the
24423                                                                          ; ship data blocks and ship line heaps:
24424                                                                          ;
24425                                                                          ; +-----------------------------------+   &0F34
24426                                                                          ; |                                   |
24427                                                                          ; | WP workspace                      |
24428                                                                          ; |                                   |
24429                                                                          ; +-----------------------------------+   &0D40 = WP
24430                                                                          ; |                                   |
24431                                                                          ; | Current ship line heap            |
24432                                                                          ; |                                   |
24433                                                                          ; +-----------------------------------+   SLSP
24434                                                                          ; |                                   |
24435                                                                          ; | Proposed heap for new ship        |
24436                                                                          ; |                                   |
24437                                                                          ; +-----------------------------------+   INWK(34 33)
24438                                                                          ; |                                   |
24439                                                                          ; .                                   .
24440                                                                          ; .                                   .
24441                                                                          ; .                                   .
24442                                                                          ; .                                   .
24443                                                                          ; .                                   .
24444                                                                          ; |                                   |
24445                                                                          ; +-----------------------------------+   INF + NI%
24446                                                                          ; |                                   |
24447                                                                          ; | Proposed data block for new ship  |
24448                                                                          ; |                                   |
24449                                                                          ; +-----------------------------------+   INF
24450                                                                          ; |                                   |
24451                                                                          ; | Existing ship data blocks         |
24452                                                                          ; |                                   |
24453                                                                          ; +-----------------------------------+   &0900 = K%
24454                                                                          ;
24455                                                                          ; So, to work out if we have enough space, we have to
24456                                                                          ; make sure there is room between the end of our new
24457                                                                          ; ship data block at INF + NI%, and the start of the
24458                                                                          ; proposed heap for our new ship at the address we
24459                                                                          ; stored in INWK(34 33). Or, to put it another way, we
24460                                                                          ; and to make sure that:
24461                                                                          ;
24462                                                                          ; INWK(34 33) > INF + NI%
24463                                                                          ;
24464                                                                          ; which is the same as saying:
24465                                                                          ;
24466                                                                          ; INWK+33 - INF > NI%
24467                                                                          ;
24468                                                                          ; because INWK is in zero page, so INWK+34 = 0
24469               
24470 6FEE D020  30        movb @INWK+33,ra                ; LDA INWK+33       ; Calculate INWK+33 - INF, again using 16-bit
     6FF0 0074     
24471               * SEC                    \ arithmetic, and put the result in (A Y), so the high
24472                      .sbc @INF,ra                    ; SBC INF           ; byte is in A and the low byte in Y. The SEC
     **** ****     > SBC
0001 6FF2 1801  14        joc  !
0002 6FF4 7004  18        sb   rone,ra
0003               !:
0004 6FF6 7020  30        sb   @INF,ra
     6FF8 0020     
                   < elite.a99
24473 6FFA D080  18        movb ra,ry                      ; TAY               ; instruction is commented out in the original source;
24474 6FFC D020  30        movb @INWK+34,ra                ; LDA INWK+34       ; as the previous subtraction will never underflow, it
     6FFE 0075     
24475                      .sbc @INF+1,ra                  ; SBC INF+1         ; is superfluous
     **** ****     > SBC
0001 7000 1801  14        joc  !
0002 7002 7004  18        sb   rone,ra
0003               !:
0004 7004 7020  30        sb   @INF+1,ra
     7006 0021     
                   < elite.a99
24476               
24477 7008 17BD  14        jnc  NW3+1                      ; BCC NW3+1         ; If we have an underflow from the subtraction, then
24478                                                                          ; INF > INWK+33 and we definitely don't have enough
24479                                                                          ; room for this ship, so jump to NW3+1, which returns
24480                                                                          ; from the subroutine (with the C flag already cleared)
24481               
24482 700A 1603  14        jne  NW4                        ; BNE NW4           ; If the subtraction of the high bytes in A is not
24483                                                                          ; zero, and we don't have underflow, then we definitely
24484                                                                          ; have enough space, so jump to NW4 to continue setting
24485                                                                          ; up the new ship
24486               
24487 700C 0282  22        ci   ry,(NI.)*256               ; CPY #NI%          ; Otherwise the high bytes are the same in our
     700E 2400     
24488 7010 17B9  14        jnc  NW3+1                      ; BCC NW3+1         ; subtraction, so now we compare the low byte of the
24489                                                                          ; result (which is in Y) with NI%. This is the same as
24490                                                                          ; doing INWK+33 - INF > NI% (see above). If this isn't
24491                                                                          ; true, the C flag will be clear and we don't have
24492                                                                          ; enough space, so we jump to NW3+1, which returns
24493                                                                          ; from the subroutine (with the C flag already cleared)
24494               
24495               NW4:
24496 7012 D020  30        movb @INWK+33,ra                ; LDA INWK+33       ; If we get here then we do have enough space for our
     7014 0074     
24497 7016 D800  30        movb ra,@SLSP                   ; STA SLSP          ; new ship, so store the new bottom of the ship line
     7018 0F1E     
24498 701A D020  30        movb @INWK+34,ra                ; LDA INWK+34       ; heap (i.e. INWK+33) in SLSP, doing both the high and
     701C 0075     
24499 701E D800  30        movb ra,@SLSP+1                 ; STA SLSP+1        ; low bytes
     7020 0F1F     
24500               
24501               NW6:
24502 7022 0202  20        li   ry,>0e*256                 ; LDY #14           ; Fetch ship blueprint byte #14, which contains the
     7024 0E00     
24503                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; ship's energy, and store it in byte #35
     **** ****     > LD_IND_Y_IDX
0001 7026 D820  42        movb @XX0,@rtmplb
     7028 001E     
     702A 830D     
0002 702C D1A0  30        movb @XX0+1,rtmp
     702E 001F     
0003 7030 A182  18        a    ry,rtmp
0004 7032 D016  26        movb *rtmp,RA
                   < elite.a99
24504 7034 D800  30        movb ra,@INWK+35                ; STA INWK+35
     7036 0076     
24505               
24506 7038 0202  20        li   ry,>13*256                 ; LDY #19           ; Fetch ship blueprint byte #19, which contains the
     703A 1300     
24507                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of missiles and laser power, and AND with %111
     **** ****     > LD_IND_Y_IDX
0001 703C D820  42        movb @XX0,@rtmplb
     703E 001E     
     7040 830D     
0002 7042 D1A0  30        movb @XX0+1,rtmp
     7044 001F     
0003 7046 A182  18        a    ry,rtmp
0004 7048 D016  26        movb *rtmp,RA
                   < elite.a99
24508 704A 0240  22        andi ra,>07*256                 ; AND #%00000111    ; to extract the number of missiles before storing in
     704C 0700     
24509 704E D800  30        movb ra,@INWK+31                ; STA INWK+31       ; byte #31
     7050 0072     
24510               
24511 7052 D020  30        movb @T,ra                      ; LDA T             ; Restore the ship type we stored above
     7054 00D1     
24512               
24513               NW2:
24514 7056 D840  38        movb ra,@FRIN(rx)               ; STA FRIN,X        ; Store the ship type in the X-th byte of FRIN, so the
     7058 0D40     
24515                                                                          ; this slot is now shown as occupied in the index table
24516               
24517 705A D040  18        movb ra,rx                      ; TAX               ; Copy the ship type into X
24518               
24519 705C 1101  14        jlt  B74                        ; BMI B74           ; If the ship type is negative (planet or sun), then
24520                                                                          ; skip the following instruction
24521               
24522 705E B004  18        ab   rone,ra                    ; INC MANY,X        ; Increment the total number of ships of type X
24523               
24524               B74:
24525 7060 0202  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; The final step is to copy the new ship's data block
     7062 2300     
24526                                                                          ; from INWK to INF, so set up a counter for NI% bytes
24527                                                                          ; in Y
24528               
24529               NWL3:
24530 7064 D022  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Load the Y-th byte of INWK and store in the Y-th byte
     7066 0053     
24531                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; of the workspace pointed to by INF
     **** ****     > ST_IND_Y_IDX
0001 7068 D820  42        movb @INF,@rtmplb
     706A 0020     
     706C 830D     
0002 706E D1A0  30        movb @INF+1,rtmp
     7070 0021     
0003 7072 A182  18        a    ry,rtmp
0004 7074 D580  30        movb RA,*rtmp
                   < elite.a99
24532               
24533 7076 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
24534               
24535 7078 15F5  14        jgt  NWL3                       ; BPL NWL3          ; Loop back for the next byte until we have copied them
24536                                                                          ; all over
24537               
24538                      .sec                            ; SEC               ; We have successfully created our new ship, so set the
     **** ****     > SEC
0001 707A 0A15  18        sla  rmone,1
                   < elite.a99
24539                                                                          ; C flag to indicate success
24540               
24541 707C 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     707E 800E     
24542               
24543               * ******************************************************************************
24544               *
24545               * Name: NwS1
24546               * Type: Subroutine
24547               * Category: Universe
24548               * Summary: Flip the sign and double an INWK byte
24549               *
24550               * ------------------------------------------------------------------------------
24551               *
24552               * Flip the sign of the INWK byte at offset X, and increment X by 2. This is
24553               * used by the space station creation routine at NWSPS.
24554               *
24555               * ------------------------------------------------------------------------------
24556               *
24557               * Arguments:
24558               *
24559               * X                   The offset of the INWK byte to be flipped
24560               *
24561               * ------------------------------------------------------------------------------
24562               *
24563               * Returns:
24564               *
24565               * X                   X is incremented by 2
24566               *
24567               * ******************************************************************************
24568               
24569               NwS1:
24570 7080 D021  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Load the X-th byte of INWK into A and flip bit 7,
     7082 0053     
24571                      .eoi (>80*256)                  ; EOR #%10000000    ; storing the result back in the X-th byte of INWK
     **** ****     > EOI
0001 7084 0206  20        li   rtmp,(>80*256)
     7086 8000     
0002 7088 2806  18        xor  rtmp,ra
                   < elite.a99
24572 708A D840  38        movb ra,@INWK(rx)               ; STA INWK,X
     708C 0053     
24573               
24574 708E B044  18        ab   rone,rx                    ; INX               ; Add 2 to X
24575 7090 B044  18        ab   rone,rx                    ; INX
24576               
24577 7092 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7094 800E     
24578               
24579               * ******************************************************************************
24580               *
24581               * Name: ABORT
24582               * Type: Subroutine
24583               * Category: Dashboard
24584               * Summary: Disarm missiles and update the dashboard indicators
24585               *
24586               * ------------------------------------------------------------------------------
24587               *
24588               * Arguments:
24589               *
24590               * Y                   The new status of the leftmost missile indicator
24591               *
24592               * ******************************************************************************
24593               
24594               ABORT:
24595 7096 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Set X to &FF, which is the value of MSTG when we have
     7098 FF00     
24596                                                                          ; no target lock for our missile
24597               
24598                                                                          ; Fall through into ABORT2 to set the missile lock to
24599                                                                          ; the value in X, which effectively disarms the missile
24600               
24601               * ******************************************************************************
24602               *
24603               * Name: ABORT2
24604               * Type: Subroutine
24605               * Category: Dashboard
24606               * Summary: Set/unset the lock target for a missile and update the dashboard
24607               *
24608               * ------------------------------------------------------------------------------
24609               *
24610               * Set the lock target for the leftmost missile and update the dashboard.
24611               *
24612               * ------------------------------------------------------------------------------
24613               *
24614               * Arguments:
24615               *
24616               * X                   The slot number of the ship to lock our missile onto, or
24617               * &FF to remove missile lock
24618               *
24619               * Y                   The new colour of the missile indicator:
24620               *
24621               * * &00 = black (no missile)
24622               *
24623               * * &0E = red (armed and locked)
24624               *
24625               * * &E0 = yellow/white (armed)
24626               *
24627               * * &EE = green/cyan (disarmed)
24628               *
24629               * ******************************************************************************
24630               
24631               ABORT2:
24632 709A D801  30        movb rx,@MSTG                   ; STX MSTG          ; Store the target of our missile lock in MSTG
     709C 0052     
24633               
24634 709E D060  30        movb @NOMSL,rx                  ; LDX NOMSL         ; Call MSBAR to update the leftmost indicator in the
     70A0 0333     
24635 70A2 0206  20        li   rtmp,MSBAR                 ; JSR MSBAR         ; dashboard's missile bar, which returns with Y = 0
     70A4 7102     
24636 70A6 06A0  28        bl   @jsr                       ;
     70A8 8002     
24637               
24638 70AA D802  30        movb ry,@MSAR                   ; STY MSAR          ; Set MSAR = 0 to indicate that the leftmost missile
     70AC 0D5E     
24639                                                                          ; is no longer seeking a target lock
24640               
24641 70AE 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     70B0 800E     
24642               
24643               * ******************************************************************************
24644               *
24645               * Name: ECBLB2
24646               * Type: Subroutine
24647               * Category: Dashboard
24648               * Summary: Start up the E.C.M. (light up the indicator, start the countdown
24649               * and make the E.C.M. sound)
24650               *
24651               * ******************************************************************************
24652               
24653               ECBLB2:
24654 70B2 0200  20        li   ra,>20*256                 ; LDA #32           ; Set the E.C.M. countdown timer in ECMA to 32
     70B4 2000     
24655 70B6 D800  30        movb ra,@ECMA                   ; STA ECMA
     70B8 0030     
24656               
24657                      .asla                           ; ASL A             ; Call the NOISE routine with A = 64 to make the sound
     **** ****     > ASLA
0001 70BA 0240  22        andi ra,>ff00
     70BC FF00     
0002 70BE 0A10  18        sla  ra,1
                   < elite.a99
24658 70C0 0206  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the E.C.M. being switched on
     70C2 8BA4     
24659 70C4 06A0  28        bl   @jsr                       ;
     70C6 8002     
24660               
24661                                                                          ; Fall through into ECBLB to light up the E.C.M. bulb
24662               
24663               * ******************************************************************************
24664               *
24665               * Name: ECBLB
24666               * Type: Subroutine
24667               * Category: Dashboard
24668               * Summary: Light up the E.C.M. indicator bulb ("E") on the dashboard
24669               *
24670               * ******************************************************************************
24671               
24672               ECBLB:
24673 70C8 0200  20        li   ra,(7*8)*256               ; LDA #7*8          ; The E.C.M. bulb is in character block number 7
     70CA 3800     
24674                                                                          ; with each character taking 8 bytes, so this sets the
24675                                                                          ; low byte of the screen address of the character block
24676                                                                          ; we want to draw to
24677               
24678 70CC 0201  20        li   rx,((ECBT)%256)*256        ; LDX #LO(ECBT)     ; Set (Y X) to point to the character definition in
     70CE F600     
24679 70D0 0202  20        li   ry,((ECBT)/256)*256        ; LDY #HI(ECBT)     ; ECBT. The LDY has no effect, as we overwrite Y with
     70D2 7000     
24680                                                                          ; the jump to BULB-2, which writes the high byte of SPBT
24681                                                                          ; into Y. This works as long as ECBT and SPBT are in
24682                                                                          ; the same page of memory, so perhaps the BNE below got
24683                                                                          ; changed from BULB to BULB-2 so they could remove the
24684                                                                          ; LDY, but for some reason it didn't get culled? Who
24685                                                                          ; knows...
24686               
24687 70D4 1605  14        jne  BULB-2                     ; BNE BULB-2        ; Jump down to BULB-2 (this BNE is effectively a JMP as
24688                                                                          ; A will never be zero)
24689               
24690               * ******************************************************************************
24691               *
24692               * Name: SPBLB
24693               * Type: Subroutine
24694               * Category: Dashboard
24695               * Summary: Light up the space station indicator ("S") on the dashboard
24696               *
24697               * ******************************************************************************
24698               
24699               SPBLB:
24700 70D6 0200  20        li   ra,(24*8)*256              ; LDA #24*8         ; The space station bulb is in character block number 24
     70D8 C000     
24701                                                                          ; with each character taking 8 bytes, so this sets the
24702                                                                          ; low byte of the screen address of the character block
24703                                                                          ; we want to draw to
24704               
24705 70DA 0201  20        li   rx,((SPBT)%256)*256        ; LDX #LO(SPBT)     ; Set (Y X) to point to the character definition in SPBT
     70DC F900     
24706 70DE 0202  20        li   ry,((SPBT)/256)*256        ; LDY #HI(SPBT)
     70E0 7000     
24707               
24708                                                                          ; Fall through into BULB to draw the space station bulb
24709               
24710               * ******************************************************************************
24711               *
24712               * Name: BULB
24713               * Type: Subroutine
24714               * Category: Dashboard
24715               * Summary: Draw an indicator bulb on the dashboard
24716               *
24717               * ------------------------------------------------------------------------------
24718               *
24719               * Arguments:
24720               *
24721               * A                   The y-coordinate of the bulb as a low-byte screen
24722               * address offset within screen page &7D (as both bulbs
24723               * are on this character row in the dashboard)
24724               *
24725               * (Y X)               The address of the character definition of the bulb to
24726               * be drawn (i.e. ECBT for the E.C.M. bulb, or SPBT for the
24727               * space station bulb)
24728               *
24729               * ------------------------------------------------------------------------------
24730               *
24731               * Other entry points:
24732               *
24733               * BULB-2              Set the Y screen address
24734               *
24735               * ******************************************************************************
24736               
24737               BULB:
24738 70E2 D800  30        movb ra,@SC                     ; STA SC            ; Store the low byte of the screen address in SC
     70E4 0007     
24739               
24740 70E6 D801  30        movb rx,@P+1                    ; STX P+1           ; Set P(2 1) = (Y X)
     70E8 001C     
24741 70EA D802  30        movb ry,@P+2                    ; STY P+2
     70EC 001D     
24742               
24743 70EE 0200  20        li   ra,>7d*256                 ; LDA #&7D          ; Set A to the high byte of the screen address, which is
     70F0 7D00     
24744                                                                          ; &7D as the bulbs are both in the character row from
24745                                                                          ; &7D00 to &7DFF
24746               
24747 70F2 0460  28        b    @RREN                      ; JMP RREN          ; Call RREN to print the character definition pointed to
     70F4 3226     
24748                                                                          ; by P(2 1) at the screen address pointed to by (A SC),
24749                                                                          ; returning from the subroutine using a tail call
24750               
24751               * ******************************************************************************
24752               *
24753               * Name: ECBT
24754               * Type: Variable
24755               * Category: Dashboard
24756               * Summary: The character bitmap for the E.C.M. indicator bulb
24757               *
24758               * ------------------------------------------------------------------------------
24759               *
24760               * The character bitmap for the E.C.M. indicator's "E" bulb that gets displayed
24761               * on the dashboard.
24762               *
24763               * The E.C.M. indicator uses the first 5 rows of the space station's "S" bulb
24764               * below, as the bottom 5 rows of the "E" match the top 5 rows of the "S".
24765               *
24766               * Each pixel is in mode 5 colour 2 (%10), which is yellow/white.
24767               *
24768               * ******************************************************************************
24769               
24770               ECBT:
24771 70F6 E0              byte >e0                                            ; x x x .
24772 70F7   E0            byte >e0                                            ; x x x .
24773 70F8 80              byte >80                                            ; x . . .
24774                                                                          ; x x x .
24775                                                                          ; x x x .
24776                                                                          ; x . . .
24777                                                                          ; x x x .
24778                                                                          ; x x x .
24779               
24780               * ******************************************************************************
24781               *
24782               * Name: SPBT
24783               * Type: Variable
24784               * Category: Dashboard
24785               * Summary: The bitmap definition for the space station indicator bulb
24786               *
24787               * ------------------------------------------------------------------------------
24788               *
24789               * The bitmap definition for the space station indicator's "S" bulb that gets
24790               * displayed on the dashboard.
24791               *
24792               * Each pixel is in mode 5 colour 2 (%10), which is yellow/white.
24793               *
24794               * ******************************************************************************
24795               
24796               SPBT:
24797 70F9   E0            byte >e0                                            ; x x x .
24798 70FA E0              byte >e0                                            ; x x x .
24799 70FB   80            byte >80                                            ; x . . .
24800 70FC E0              byte >e0                                            ; x x x .
24801 70FD   E0            byte >e0                                            ; x x x .
24802 70FE 20              byte >20                                            ; . . x .
24803 70FF   E0            byte >e0                                            ; x x x .
24804 7100 E0              byte >e0                                            ; x x x .
24805               
24806               * ******************************************************************************
24807               *
24808               * Name: MSBAR
24809               * Type: Subroutine
24810               * Category: Dashboard
24811               * Summary: Draw a specific indicator in the dashboard's missile bar
24812               *
24813               * ------------------------------------------------------------------------------
24814               *
24815               * Each indicator is a rectangle that's 3 pixels wide and 5 pixels high. If the
24816               * indicator is set to black, this effectively removes a missile.
24817               *
24818               * ------------------------------------------------------------------------------
24819               *
24820               * Arguments:
24821               *
24822               * X                   The number of the missile indicator to update (counting
24823               * from right to left, so indicator NOMSL is the leftmost
24824               * indicator)
24825               *
24826               * Y                   The colour of the missile indicator:
24827               *
24828               * * &00 = black (no missile)
24829               *
24830               * * &0E = red (armed and locked)
24831               *
24832               * * &E0 = yellow/white (armed)
24833               *
24834               * * &EE = green/cyan (disarmed)
24835               *
24836               * ------------------------------------------------------------------------------
24837               *
24838               * Returns:
24839               *
24840               * X                   X is preserved
24841               *
24842               * Y                   Y is set to 0
24843               *
24844               * ******************************************************************************
24845               
24846               MSBAR:
24847 7102 D001  18        movb rx,ra                      ; TXA               ; Set T = X * 8
24848                      .asla                           ; ASL A
     **** ****     > ASLA
0001 7104 0240  22        andi ra,>ff00
     7106 FF00     
0002 7108 0A10  18        sla  ra,1
                   < elite.a99
24849                      .asla                           ; ASL A
     **** ****     > ASLA
0001 710A 0240  22        andi ra,>ff00
     710C FF00     
0002 710E 0A10  18        sla  ra,1
                   < elite.a99
24850                      .asla                           ; ASL A
     **** ****     > ASLA
0001 7110 0240  22        andi ra,>ff00
     7112 FF00     
0002 7114 0A10  18        sla  ra,1
                   < elite.a99
24851 7116 D800  30        movb ra,@T                      ; STA T
     7118 00D1     
24852               
24853 711A 0200  20        li   ra,>31*256                 ; LDA #49           ; Set SC = 49 - T
     711C 3100     
24854                      .sbc @T,ra                      ; SBC T             ; = 48 + 1 - (X * 8)
     **** ****     > SBC
0001 711E 1801  14        joc  !
0002 7120 7004  18        sb   rone,ra
0003               !:
0004 7122 7020  30        sb   @T,ra
     7124 00D1     
                   < elite.a99
24855 7126 D800  30        movb ra,@SC                     ; STA SC
     7128 0007     
24856               
24857                                                                          ; So the low byte of SC(1 0) contains the row address
24858                                                                          ; for the rightmost missile indicator, made up as
24859                                                                          ; follows:
24860                                                                          ;
24861                                                                          ; * 48 (character block 7, as byte #7 * 8 = 48), the
24862                                                                          ; character block of the rightmost missile
24863                                                                          ;
24864                                                                          ; * 1 (so we start drawing on the second row of the
24865                                                                          ; character block)
24866                                                                          ;
24867                                                                          ; * Move left one character (8 bytes) for each count
24868                                                                          ; of X, so when X = 0 we are drawing the rightmost
24869                                                                          ; missile, for X = 1 we hop to the left by one
24870                                                                          ; character, and so on
24871               
24872 712A 0200  20        li   ra,>7e*256                 ; LDA #&7E          ; Set the high byte of SC(1 0) to &7E, the character row
     712C 7E00     
24873 712E D800  30        movb ra,@SCH                    ; STA SCH           ; that contains the missile indicators (i.e. the bottom
     7130 0008     
24874                                                                          ; row of the screen)
24875               
24876 7132 D002  18        movb ry,ra                      ; TYA               ; Set A to the correct colour, which is a 3-pixel wide
24877                                                                          ; mode 5 character row in the correct colour (for
24878                                                                          ; example, a green block has Y = &EE, or %11101110, so
24879                                                                          ; the missile blocks are 3 pixels wide, with the
24880                                                                          ; fourth pixel on the character row being empty)
24881               
24882 7134 0202  20        li   ry,>05*256                 ; LDY #5            ; We now want to draw this line five times, so set a
     7136 0500     
24883                                                                          ; counter in Y
24884               
24885               MBL1:
24886                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the 3-pixel row, and as we do not use EOR logic,
     **** ****     > ST_IND_Y_IDX
0001 7138 D820  42        movb @SC,@rtmplb
     713A 0007     
     713C 830D     
0002 713E D1A0  30        movb @SC+1,rtmp
     7140 0008     
0003 7142 A182  18        a    ry,rtmp
0004 7144 D580  30        movb RA,*rtmp
                   < elite.a99
24887                                                                          ; this will overwrite anything that is already there
24888                                                                          ; (so drawing a black missile will delete what's there)
24889               
24890 7146 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter for the next row
24891               
24892 7148 16F7  14        jne  MBL1                       ; BNE MBL1          ; Loop back to MBL1 if have more rows to draw
24893               
24894 714A 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     714C 800E     
24895               
24896               * ******************************************************************************
24897               *
24898               * Name: PROJ
24899               * Type: Subroutine
24900               * Category: Maths (Geometry)
24901               * Summary: Project the current ship or planet onto the screen
24902               * Deep dive: Extended screen coordinates
24903               *
24904               * ------------------------------------------------------------------------------
24905               *
24906               * Project the current ship's location or the planet onto the screen, either
24907               * returning the screen coordinates of the projection (if it's on-screen), or
24908               * returning an error via the C flag.
24909               *
24910               * In this context, "on-screen" means that the point is projected into the
24911               * following range:
24912               *
24913               * centre of screen - 1024 < x < centre of screen + 1024
24914               * centre of screen - 1024 < y < centre of screen + 1024
24915               *
24916               * This is to cater for ships (and, more likely, planets and suns) whose centres
24917               * are off-screen but whose edges may still be visible.
24918               *
24919               * The projection calculation is:
24920               *
24921               * K3(1 0) = #X + x / z
24922               * K4(1 0) = #Y + y / z
24923               *
24924               * where #X and #Y are the pixel x-coordinate and y-coordinate of the centre of
24925               * the screen.
24926               *
24927               * ------------------------------------------------------------------------------
24928               *
24929               * Arguments:
24930               *
24931               * INWK                The ship data block for the ship to project on-screen
24932               *
24933               * ------------------------------------------------------------------------------
24934               *
24935               * Returns:
24936               *
24937               * K3(1 0)             The x-coordinate of the ship's projection on-screen
24938               *
24939               * K4(1 0)             The y-coordinate of the ship's projection on-screen
24940               *
24941               * C flag              Set if the ship's projection doesn't fit on the screen,
24942               * clear if it does project onto the screen
24943               *
24944               * A                   Contains K4+1, the high byte of the y-coordinate
24945               *
24946               * ******************************************************************************
24947               
24948               PROJ:
24949 714E D020  30        movb @INWK,ra                   ; LDA INWK          ; Set P(1 0) = (x_hi x_lo)
     7150 0053     
24950 7152 D800  30        movb ra,@P                      ; STA P             ; = x
     7154 001B     
24951 7156 D020  30        movb @INWK+1,ra                 ; LDA INWK+1
     7158 0054     
24952 715A D800  30        movb ra,@P+1                    ; STA P+1
     715C 001C     
24953               
24954 715E D020  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Set A = x_sign
     7160 0055     
24955               
24956 7162 0206  20        li   rtmp,PLS6                  ; JSR PLS6          ; Call PLS6 to calculate:
     7164 7B34     
24957 7166 06A0  28        bl   @jsr                       ;
     7168 8002     
24958                                                                          ;
24959                                                                          ; (X K) = (A P+1 P) / (z_sign z_hi z_lo)
24960                                                                          ; = (x_sign x_hi x_lo) / (z_sign z_hi z_lo)
24961                                                                          ; = x / z
24962               
24963 716A 1832  14        joc  PL2-1                      ; BCS PL2-1         ; If the C flag is set then the result overflowed and
24964                                                                          ; the coordinate doesn't fit on the screen, so return
24965                                                                          ; from the subroutine with the C flag set (as PL2-1
24966                                                                          ; contains an RTS)
24967               
24968 716C D020  30        movb @K,ra                      ; LDA K             ; Set K3(1 0) = (X K) + #X
     716E 003D     
24969                      .adi ((X)*256)                  ; ADC #X            ; = #X + x / z
     **** ****     > ADI
0001 7170 1701  14        jnc  !
0002 7172 B004  18        ab   rone,ra
0003               !:
0004 7174 0220  22        ai   ra,((X)*256)
     7176 8000     
                   < elite.a99
24970 7178 D800  30        movb ra,@K3                     ; STA K3            ;
     717A 00D2     
24971                                                                          ; first doing the low bytes
24972               
24973 717C D001  18        movb rx,ra                      ; TXA               ; And then the high bytes. #X is the x-coordinate of
24974                      .adi (>00*256)                  ; ADC #0            ; the centre of the space view, so this converts the
     **** ****     > ADI
0001 717E 1701  14        jnc  !
0002 7180 B004  18        ab   rone,ra
0003               !:
0004 7182 0220  22        ai   ra,(>00*256)
     7184 0000     
                   < elite.a99
24975 7186 D800  30        movb ra,@K3+1                   ; STA K3+1          ; space x-coordinate into a screen x-coordinate
     7188 00D3     
24976               
24977 718A D020  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P(1 0) = (y_hi y_lo)
     718C 0056     
24978 718E D800  30        movb ra,@P                      ; STA P
     7190 001B     
24979 7192 D020  30        movb @INWK+4,ra                 ; LDA INWK+4
     7194 0057     
24980 7196 D800  30        movb ra,@P+1                    ; STA P+1
     7198 001C     
24981               
24982 719A D020  30        movb @INWK+5,ra                 ; LDA INWK+5        ; Set A = -y_sign
     719C 0058     
24983                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 719E 0206  20        li   rtmp,(>80*256)
     71A0 8000     
0002 71A2 2806  18        xor  rtmp,ra
                   < elite.a99
24984               
24985 71A4 0206  20        li   rtmp,PLS6                  ; JSR PLS6          ; Call PLS6 to calculate:
     71A6 7B34     
24986 71A8 06A0  28        bl   @jsr                       ;
     71AA 8002     
24987                                                                          ;
24988                                                                          ; (X K) = (A P+1 P) / (z_sign z_hi z_lo)
24989                                                                          ; = -(y_sign y_hi y_lo) / (z_sign z_hi z_lo)
24990                                                                          ; = -y / z
24991               
24992 71AC 1811  14        joc  PL2-1                      ; BCS PL2-1         ; If the C flag is set then the result overflowed and
24993                                                                          ; the coordinate doesn't fit on the screen, so return
24994                                                                          ; from the subroutine with the C flag set (as PL2-1
24995                                                                          ; contains an RTS)
24996               
24997 71AE D020  30        movb @K,ra                      ; LDA K             ; Set K4(1 0) = (X K) + #Y
     71B0 003D     
24998                      .adi ((Y)*256)                  ; ADC #Y            ; = #Y - y / z
     **** ****     > ADI
0001 71B2 1701  14        jnc  !
0002 71B4 B004  18        ab   rone,ra
0003               !:
0004 71B6 0220  22        ai   ra,((Y)*256)
     71B8 6000     
                   < elite.a99
24999 71BA D800  30        movb ra,@K4                     ; STA K4            ;
     71BC 00E0     
25000                                                                          ; first doing the low bytes
25001               
25002 71BE D001  18        movb rx,ra                      ; TXA               ; And then the high bytes. #Y is the y-coordinate of
25003                      .adi (>00*256)                  ; ADC #0            ; the centre of the space view, so this converts the
     **** ****     > ADI
0001 71C0 1701  14        jnc  !
0002 71C2 B004  18        ab   rone,ra
0003               !:
0004 71C4 0220  22        ai   ra,(>00*256)
     71C6 0000     
                   < elite.a99
25004 71C8 D800  30        movb ra,@K4+1                   ; STA K4+1          ; space x-coordinate into a screen y-coordinate
     71CA 00E1     
25005               
25006                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 71CC 0A13  18        sla  rzero,1
                   < elite.a99
25007               
25008 71CE 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     71D0 800E     
25009               
25010               * ******************************************************************************
25011               *
25012               * Name: PL2
25013               * Type: Subroutine
25014               * Category: Drawing planets
25015               * Summary: Remove the planet or sun from the screen
25016               *
25017               * ------------------------------------------------------------------------------
25018               *
25019               * Other entry points:
25020               *
25021               * PL2-1               Contains an RTS
25022               *
25023               * ******************************************************************************
25024               
25025               PL2:
25026 71D2 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; Shift bit 0 of the planet/sun's type into the C flag
     71D4 009B     
25027 71D6 0910  18        srl  ra,1                       ; LSR A
25028               
25029 71D8 1802  14        joc  B75                        ; BCS B75           ; If the planet/sun's type has bit 0 clear, then it's
25030                                                                          ; either 128 or 130, which is a planet; meanwhile, the
25031                                                                          ; sun has type 129, which has bit 0 set. So if this is
25032                                                                          ; the sun, skip the following instruction
25033               
25034 71DA 0460  28        b    @WPLS2                     ; JMP WPLS2         ; This is the planet, so jump to WPLS2 to remove it from
     71DC 78FE     
25035                                                                          ; screen, returning from the subroutine using a tail
25036                                                                          ; call
25037               
25038               B75:
25039 71DE 0460  28        b    @WPLS                      ; JMP WPLS          ; This is the sun, so jump to WPLS to remove it from
     71E0 7970     
25040                                                                          ; screen, returning from the subroutine using a tail
25041                                                                          ; call
25042               
25043               * ******************************************************************************
25044               *
25045               * Name: PLANET
25046               * Type: Subroutine
25047               * Category: Drawing planets
25048               * Summary: Draw the planet or sun
25049               *
25050               * ------------------------------------------------------------------------------
25051               *
25052               * Arguments:
25053               *
25054               * INWK                The planet or sun's ship data block
25055               *
25056               * ******************************************************************************
25057               
25058               PLANET:
25059 71E2 D020  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set A = z_sign (the highest byte in the planet/sun's
     71E4 005B     
25060                                                                          ; coordinates)
25061               
25062 71E6 11F5  14        jlt  PL2                        ; BMI PL2           ; If A is negative then the planet/sun is behind us, so
25063                                                                          ; jump to PL2 to remove it from the screen, returning
25064                                                                          ; from the subroutine using a tail call
25065               
25066 71E8 0280  22        ci   ra,>30*256                 ; CMP #48           ; If A >= 48 then the planet/sun is too far away to be
     71EA 3000     
25067 71EC 18F2  14        joc  PL2                        ; BCS PL2           ; seen, so jump to PL2 to remove it from the screen,
25068                                                                          ; returning from the subroutine using a tail call
25069               
25070 71EE F020  30        socb @INWK+7,ra                 ; ORA INWK+7        ; Set A to 0 if both z_sign and z_hi are 0
     71F0 005A     
25071               
25072 71F2 13EF  14        jeq  PL2                        ; BEQ PL2           ; If both z_sign and z_hi are 0, then the planet/sun is
25073                                                                          ; too close to be shown, so jump to PL2 to remove it
25074                                                                          ; from the screen, returning from the subroutine using a
25075                                                                          ; tail call
25076               
25077 71F4 0206  20        li   rtmp,PROJ                  ; JSR PROJ          ; Project the planet/sun onto the screen, returning the
     71F6 714E     
25078 71F8 06A0  28        bl   @jsr                       ;
     71FA 8002     
25079                                                                          ; centre's coordinates in K3(1 0) and K4(1 0)
25080               
25081 71FC 18EA  14        joc  PL2                        ; BCS PL2           ; If the C flag is set by PROJ then the planet/sun is
25082                                                                          ; not visible on-screen, so jump to PL2 to remove it
25083                                                                          ; from the screen, returning from the subroutine using
25084                                                                          ; a tail call
25085               
25086 71FE 0200  20        li   ra,>60*256                 ; LDA #96           ; Set (A P+1 P) = (0 96 0) = 24576
     7200 6000     
25087 7202 D800  30        movb ra,@P+1                    ; STA P+1           ;
     7204 001C     
25088 7206 0200  20        li   ra,>00*256                 ; LDA #0            ; This represents the planet/sun's radius at a distance
     7208 0000     
25089 720A D800  30        movb ra,@P                      ; STA P             ; of z = 1
     720C 001B     
25090               
25091 720E 0206  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     7210 45E8     
25092 7212 06A0  28        bl   @jsr                       ;
     7214 8002     
25093                                                                          ;
25094                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
25095                                                                          ; = (0 96 0) / z
25096                                                                          ; = 24576 / z
25097                                                                          ;
25098                                                                          ; so K now contains the planet/sun's radius, reduced by
25099                                                                          ; the actual distance to the planet/sun. We know that
25100                                                                          ; K+3 and K+2 will be 0, as the number we are dividing,
25101                                                                          ; (0 96 0), fits into the two bottom bytes, so the
25102                                                                          ; result is actually in K(1 0)
25103               
25104 7216 D020  30        movb @K+1,ra                    ; LDA K+1           ; If the high byte of the reduced radius is zero, jump
     7218 003E     
25105 721A 1304  14        jeq  PL82                       ; BEQ PL82          ; to PL82, as K contains the radius on its own
25106               
25107 721C 0200  20        li   ra,>f8*256                 ; LDA #248          ; Otherwise set K = 248, to round up the radius in
     721E F800     
25108 7220 D800  30        movb ra,@K                      ; STA K             ; K(1 0) to the nearest integer (if we consider the low
     7222 003D     
25109                                                                          ; byte to be the fractional part)
25110               
25111               PL82:
25112 7224 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; If the planet/sun's type has bit 0 clear, then it's
     7226 009B     
25113 7228 0910  18        srl  ra,1                       ; LSR A             ; either 128 or 130, which is a planet (the sun has type
25114 722A 1702  14        jnc  PL9                        ; BCC PL9           ; 129, which has bit 0 set). So jump to PL9 to draw the
25115                                                                          ; planet with radius K, returning from the subroutine
25116                                                                          ; using a tail call
25117               
25118 722C 0460  28        b    @SUN                       ; JMP SUN           ; Otherwise jump to SUN to draw the sun with radius K,
     722E 75B8     
25119                                                                          ; returning from the subroutine using a tail call
25120               
25121               * ******************************************************************************
25122               *
25123               * Name: PL9 (Part 1 of 3)
25124               * Type: Subroutine
25125               * Category: Drawing planets
25126               * Summary: Draw the planet, with either an equator and meridian, or a crater
25127               *
25128               * ------------------------------------------------------------------------------
25129               *
25130               * Draw the planet with radius K at pixel coordinate (K3, K4), and with either an
25131               * equator and meridian, or a crater.
25132               *
25133               * ------------------------------------------------------------------------------
25134               *
25135               * Arguments:
25136               *
25137               * K(1 0)              The planet's radius
25138               *
25139               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25140               *
25141               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25142               *
25143               * INWK                The planet's ship data block
25144               *
25145               * ******************************************************************************
25146               
25147               PL9:
25148 7230 0206  20        li   rtmp,WPLS2                 ; JSR WPLS2         ; Call WPLS2 to remove the planet from the screen
     7232 78FE     
25149 7234 06A0  28        bl   @jsr                       ;
     7236 8002     
25150               
25151 7238 0206  20        li   rtmp,CIRCLE                ; JSR CIRCLE        ; Call CIRCLE to draw the planet's new circle
     723A 77F2     
25152 723C 06A0  28        bl   @jsr                       ;
     723E 8002     
25153               
25154 7240 1803  14        joc  PL20                       ; BCS PL20          ; If the call to CIRCLE returned with the C flag set,
25155                                                                          ; then the circle does not fit on-screen, so jump to
25156                                                                          ; PL20 to return from the subroutine
25157               
25158 7242 D020  30        movb @K+1,ra                    ; LDA K+1           ; If K+1 is zero, jump to PL25 as K(1 0) < 256, so the
     7244 003E     
25159 7246 1302  14        jeq  PL25                       ; BEQ PL25          ; planet fits on the screen and we can draw meridians or
25160                                                                          ; craters
25161               
25162               PL20:
25163 7248 0460  24        b    @rts                       ; RTS               ; The planet doesn't fit on-screen, so return from the
     724A 800E     
25164                                                                          ; subroutine
25165               
25166               PL25:
25167 724C D020  30        movb @TYPE,ra                   ; LDA TYPE          ; If the planet type is 128 then it has an equator and
     724E 009B     
25168 7250 0280  22        ci   ra,>80*256                 ; CMP #128          ; a meridian, so this jumps to PL26 if this is not a
     7252 8000     
25169 7254 1643  14        jne  PL26                       ; BNE PL26          ; planet with an equator - in other words, if it is a
25170                                                                          ; planet with a crater
25171               
25172                                                                          ; Otherwise this is a planet with an equator and
25173                                                                          ; meridian, so fall through into the following to draw
25174                                                                          ; them
25175               
25176               * ******************************************************************************
25177               *
25178               * Name: PL9 (Part 2 of 3)
25179               * Type: Subroutine
25180               * Category: Drawing planets
25181               * Summary: Draw the planet's equator and meridian
25182               * Deep dive: Drawing meridians and equators
25183               *
25184               * ------------------------------------------------------------------------------
25185               *
25186               * Draw the planet's equator and meridian.
25187               *
25188               * ------------------------------------------------------------------------------
25189               *
25190               * Arguments:
25191               *
25192               * K(1 0)              The planet's radius
25193               *
25194               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25195               *
25196               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25197               *
25198               * INWK                The planet's ship data block
25199               *
25200               * ******************************************************************************
25201               
25202 7256 D020  30        movb @K,ra                      ; LDA K             ; If the planet's radius is less than 6, the planet is
     7258 003D     
25203 725A 0280  22        ci   ra,>06*256                 ; CMP #6            ; too small to show a meridian, so jump to PL20 to
     725C 0600     
25204 725E 17F4  14        jnc  PL20                       ; BCC PL20          ; return from the subroutine
25205               
25206 7260 D020  30        movb @INWK+14,ra                ; LDA INWK+14       ; Set P = -nosev_z_hi
     7262 0061     
25207                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 7264 0206  20        li   rtmp,(>80*256)
     7266 8000     
0002 7268 2806  18        xor  rtmp,ra
                   < elite.a99
25208 726A D800  30        movb ra,@P                      ; STA P
     726C 001B     
25209               
25210 726E D020  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z_hi
     7270 0067     
25211               
25212 7272 0206  20        li   rtmp,PLS4                  ; JSR PLS4          ; Call PLS4 to calculate the following:
     7274 7AEC     
25213 7276 06A0  28        bl   @jsr                       ;
     7278 8002     
25214                                                                          ;
25215                                                                          ; CNT2 = arctan(P / A) / 4
25216                                                                          ; = arctan(-nosev_z_hi / roofv_z_hi) / 4
25217                                                                          ;
25218                                                                          ; and do the following if nosev_z_hi >= 0:
25219                                                                          ;
25220                                                                          ; CNT2 = CNT2 + PI
25221               
25222 727A 0201  20        li   rx,>09*256                 ; LDX #9            ; Set X to 9 so the call to PLS1 divides nosev_x
     727C 0900     
25223               
25224 727E 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     7280 73A0     
25225 7282 06A0  28        bl   @jsr                       ;
     7284 8002     
25226 7286 D800  30        movb ra,@K2                     ; STA K2            ;
     7288 00AC     
25227 728A D802  30        movb ry,@XX16                   ; STY XX16          ; (XX16 K2) = nosev_x / z
     728C 0009     
25228                                                                          ;
25229                                                                          ; and increment X to point to nosev_y for the next call
25230               
25231 728E 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     7290 73A0     
25232 7292 06A0  28        bl   @jsr                       ;
     7294 8002     
25233 7296 D800  30        movb ra,@K2+1                   ; STA K2+1          ;
     7298 00AD     
25234 729A D802  30        movb ry,@XX16+1                 ; STY XX16+1        ; (XX16+1 K2+1) = nosev_y / z
     729C 000A     
25235               
25236 729E 0201  20        li   rx,>0f*256                 ; LDX #15           ; Set X to 15 so the call to PLS5 divides roofv_x
     72A0 0F00     
25237               
25238 72A2 0206  20        li   rtmp,PLS5                  ; JSR PLS5          ; Call PLS5 to calculate the following:
     72A4 7B10     
25239 72A6 06A0  28        bl   @jsr                       ;
     72A8 8002     
25240                                                                          ;
25241                                                                          ; (XX16+2 K2+2) = roofv_x / z
25242                                                                          ;
25243                                                                          ; (XX16+3 K2+3) = roofv_y / z
25244               
25245 72AA 0206  20        li   rtmp,PLS2                  ; JSR PLS2          ; Call PLS2 to draw the first meridian
     72AC 73DE     
25246 72AE 06A0  28        bl   @jsr                       ;
     72B0 8002     
25247               
25248 72B2 D020  30        movb @INWK+14,ra                ; LDA INWK+14       ; Set P = -nosev_z_hi
     72B4 0061     
25249                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 72B6 0206  20        li   rtmp,(>80*256)
     72B8 8000     
0002 72BA 2806  18        xor  rtmp,ra
                   < elite.a99
25250 72BC D800  30        movb ra,@P                      ; STA P
     72BE 001B     
25251               
25252 72C0 D020  30        movb @INWK+26,ra                ; LDA INWK+26       ; Set A = sidev_z_hi, so the second meridian will be at
     72C2 006D     
25253                                                                          ; 90 degrees to the first
25254               
25255 72C4 0206  20        li   rtmp,PLS4                  ; JSR PLS4          ; Call PLS4 to calculate the following:
     72C6 7AEC     
25256 72C8 06A0  28        bl   @jsr                       ;
     72CA 8002     
25257                                                                          ;
25258                                                                          ; CNT2 = arctan(P / A) / 4
25259                                                                          ; = arctan(-nosev_z_hi / sidev_z_hi) / 4
25260                                                                          ;
25261                                                                          ; and do the following if nosev_z_hi >= 0:
25262                                                                          ;
25263                                                                          ; CNT2 = CNT2 + PI
25264               
25265 72CC 0201  20        li   rx,>15*256                 ; LDX #21           ; Set X to 21 so the call to PLS5 divides sidev_x
     72CE 1500     
25266               
25267 72D0 0206  20        li   rtmp,PLS5                  ; JSR PLS5          ; Call PLS5 to calculate the following:
     72D2 7B10     
25268 72D4 06A0  28        bl   @jsr                       ;
     72D6 8002     
25269                                                                          ;
25270                                                                          ; (XX16+2 K2+2) = sidev_x / z
25271                                                                          ;
25272                                                                          ; (XX16+3 K2+3) = sidev_y / z
25273               
25274 72D8 0460  28        b    @PLS2                      ; JMP PLS2          ; Jump to PLS2 to draw the second meridian, returning
     72DA 73DE     
25275                                                                          ; from the subroutine using a tail call
25276               
25277               * ******************************************************************************
25278               *
25279               * Name: PL9 (Part 3 of 3)
25280               * Type: Subroutine
25281               * Category: Drawing planets
25282               * Summary: Draw the planet's crater
25283               * Deep dive: Drawing craters
25284               *
25285               * ------------------------------------------------------------------------------
25286               *
25287               * Draw the planet's crater.
25288               *
25289               * ------------------------------------------------------------------------------
25290               *
25291               * Arguments:
25292               *
25293               * K(1 0)              The planet's radius
25294               *
25295               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25296               *
25297               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25298               *
25299               * INWK                The planet's ship data block
25300               *
25301               * ******************************************************************************
25302               
25303               PL26:
25304 72DC D020  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z_hi
     72DE 0067     
25305               
25306 72E0 11B3  14        jlt  PL20                       ; BMI PL20          ; If A is negative, the crater is on the far side of the
25307                                                                          ; planet, so return from the subroutine (as PL2
25308                                                                          ; contains an RTS)
25309               
25310 72E2 0201  20        li   rx,>0f*256                 ; LDX #15           ; Set X = 15, so the following call to PLS3 operates on
     72E4 0F00     
25311                                                                          ; roofv
25312               
25313 72E6 0206  20        li   rtmp,PLS3                  ; JSR PLS3          ; Call PLS3 to calculate:
     72E8 7AA0     
25314 72EA 06A0  28        bl   @jsr                       ;
     72EC 8002     
25315                                                                          ;
25316                                                                          ; (Y A P) = 222 * roofv_x / z
25317                                                                          ;
25318                                                                          ; to give the x-coordinate of the crater offset and
25319                                                                          ; increment X to point to roofv_y for the next call
25320               
25321                      .clc                            ; CLC               ; Calculate:
     **** ****     > CLC
0001 72EE 0A13  18        sla  rzero,1
                   < elite.a99
25322                      .adc @K3,ra                     ; ADC K3            ;
     **** ****     > ADC
0001 72F0 1701  14        jnc  !
0002 72F2 B004  18        ab   rone,ra
0003               !:
0004 72F4 B020  30        ab   @K3,ra
     72F6 00D2     
                   < elite.a99
25323 72F8 D800  30        movb ra,@K3                     ; STA K3            ; K3(1 0) = (Y A) + K3(1 0)
     72FA 00D2     
25324                                                                          ; = 222 * roofv_x / z + x-coordinate of planet
25325                                                                          ; centre
25326                                                                          ;
25327                                                                          ; starting with the high bytes
25328               
25329 72FC D002  18        movb ry,ra                      ; TYA               ; And then doing the low bytes, so now K3(1 0) contains
25330                      .adc @K3+1,ra                   ; ADC K3+1          ; the x-coordinate of the crater offset plus the planet
     **** ****     > ADC
0001 72FE 1701  14        jnc  !
0002 7300 B004  18        ab   rone,ra
0003               !:
0004 7302 B020  30        ab   @K3+1,ra
     7304 00D3     
                   < elite.a99
25331 7306 D800  30        movb ra,@K3+1                   ; STA K3+1          ; centre to give the x-coordinate of the crater's centre
     7308 00D3     
25332               
25333 730A 0206  20        li   rtmp,PLS3                  ; JSR PLS3          ; Call PLS3 to calculate:
     730C 7AA0     
25334 730E 06A0  28        bl   @jsr                       ;
     7310 8002     
25335                                                                          ;
25336                                                                          ; (Y A P) = 222 * roofv_y / z
25337                                                                          ;
25338                                                                          ; to give the y-coordinate of the crater offset
25339               
25340 7312 D800  30        movb ra,@P                      ; STA P             ; Calculate:
     7314 001B     
25341 7316 D020  30        movb @K4,ra                     ; LDA K4            ;
     7318 00E0     
25342                      .sec                            ; SEC               ; K4(1 0) = K4(1 0) - (Y A)
     **** ****     > SEC
0001 731A 0A15  18        sla  rmone,1
                   < elite.a99
25343                      .sbc @P,ra                      ; SBC P             ; = 222 * roofv_y / z - y-coordinate of planet
     **** ****     > SBC
0001 731C 1801  14        joc  !
0002 731E 7004  18        sb   rone,ra
0003               !:
0004 7320 7020  30        sb   @P,ra
     7322 001B     
                   < elite.a99
25344 7324 D800  30        movb ra,@K4                     ; STA K4            ; centre
     7326 00E0     
25345                                                                          ;
25346                                                                          ; starting with the low bytes
25347               
25348 7328 D802  30        movb ry,@P                      ; STY P             ; And then doing the low bytes, so now K4(1 0) contains
     732A 001B     
25349 732C D020  30        movb @K4+1,ra                   ; LDA K4+1          ; the y-coordinate of the crater offset plus the planet
     732E 00E1     
25350                      .sbc @P,ra                      ; SBC P             ; centre to give the y-coordinate of the crater's centre
     **** ****     > SBC
0001 7330 1801  14        joc  !
0002 7332 7004  18        sb   rone,ra
0003               !:
0004 7334 7020  30        sb   @P,ra
     7336 001B     
                   < elite.a99
25351 7338 D800  30        movb ra,@K4+1                   ; STA K4+1
     733A 00E1     
25352               
25353 733C 0201  20        li   rx,>09*256                 ; LDX #9            ; Set X = 9, so the following call to PLS1 operates on
     733E 0900     
25354                                                                          ; nosev
25355               
25356 7340 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     7342 73A0     
25357 7344 06A0  28        bl   @jsr                       ;
     7346 8002     
25358                                                                          ;
25359                                                                          ; (Y A) = nosev_x / z
25360                                                                          ;
25361                                                                          ; and increment X to point to nosev_y for the next call
25362               
25363 7348 0910  18        srl  ra,1                       ; LSR A             ; Set (XX16 K2) = (Y A) / 2
25364 734A D800  30        movb ra,@K2                     ; STA K2
     734C 00AC     
25365 734E D802  30        movb ry,@XX16                   ; STY XX16
     7350 0009     
25366               
25367 7352 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     7354 73A0     
25368 7356 06A0  28        bl   @jsr                       ;
     7358 8002     
25369                                                                          ;
25370                                                                          ; (Y A) = nosev_y / z
25371                                                                          ;
25372                                                                          ; and increment X to point to nosev_z for the next call
25373               
25374 735A 0910  18        srl  ra,1                       ; LSR A             ; Set (XX16+1 K2+1) = (Y A) / 2
25375 735C D800  30        movb ra,@K2+1                   ; STA K2+1
     735E 00AD     
25376 7360 D802  30        movb ry,@XX16+1                 ; STY XX16+1
     7362 000A     
25377               
25378 7364 0201  20        li   rx,>15*256                 ; LDX #21           ; Set X = 21, so the following call to PLS1 operates on
     7366 1500     
25379                                                                          ; sidev
25380               
25381 7368 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     736A 73A0     
25382 736C 06A0  28        bl   @jsr                       ;
     736E 8002     
25383                                                                          ;
25384                                                                          ; (Y A) = sidev_x / z
25385                                                                          ;
25386                                                                          ; and increment X to point to sidev_y for the next call
25387               
25388 7370 0910  18        srl  ra,1                       ; LSR A             ; Set (XX16+2 K2+2) = (Y A) / 2
25389 7372 D800  30        movb ra,@K2+2                   ; STA K2+2
     7374 00AE     
25390 7376 D802  30        movb ry,@XX16+2                 ; STY XX16+2
     7378 000B     
25391               
25392 737A 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     737C 73A0     
25393 737E 06A0  28        bl   @jsr                       ;
     7380 8002     
25394                                                                          ;
25395                                                                          ; (Y A) = sidev_y / z
25396                                                                          ;
25397                                                                          ; and increment X to point to sidev_z for the next call
25398               
25399 7382 0910  18        srl  ra,1                       ; LSR A             ; Set (XX16+3 K2+3) = (Y A) / 2
25400 7384 D800  30        movb ra,@K2+3                   ; STA K2+3
     7386 00AF     
25401 7388 D802  30        movb ry,@XX16+3                 ; STY XX16+3
     738A 000C     
25402               
25403 738C 0200  20        li   ra,>40*256                 ; LDA #64           ; Set TGT = 64, so we draw a full ellipse in the call to
     738E 4000     
25404 7390 D800  30        movb ra,@TGT                    ; STA TGT           ; PLS22 below
     7392 00A0     
25405               
25406 7394 0200  20        li   ra,>00*256                 ; LDA #0            ; Set CNT2 = 0 as we are drawing a full ellipse, so we
     7396 0000     
25407 7398 D800  30        movb ra,@CNT2                   ; STA CNT2          ; don't need to apply an offset
     739A 00A5     
25408               
25409 739C 0460  28        b    @PLS22                     ; JMP PLS22         ; Jump to PLS22 to draw the crater, returning from the
     739E 73E6     
25410                                                                          ; subroutine using a tail call
25411               
25412               * ******************************************************************************
25413               *
25414               * Name: PLS1
25415               * Type: Subroutine
25416               * Category: Drawing planets
25417               * Summary: Calculate (Y A) = nosev_x / z
25418               *
25419               * ------------------------------------------------------------------------------
25420               *
25421               * Calculate the following division of a specified value from one of the
25422               * orientation vectors (in this example, nosev_x):
25423               *
25424               * (Y A) = nosev_x / z
25425               *
25426               * where z is the z-coordinate of the planet from INWK. The result is an 8-bit
25427               * magnitude in A, with maximum value 254, and just a sign bit (bit 7) in Y.
25428               *
25429               * ------------------------------------------------------------------------------
25430               *
25431               * Arguments:
25432               *
25433               * X                   Determines which of the INWK orientation vectors to
25434               * divide:
25435               *
25436               * * X = 9, 11, 13: divides nosev_x, nosev_y, nosev_z
25437               *
25438               * * X = 15, 17, 19: divides roofv_x, roofv_y, roofv_z
25439               *
25440               * * X = 21, 23, 25: divides sidev_x, sidev_y, sidev_z
25441               *
25442               * INWK                The planet's ship data block
25443               *
25444               * ------------------------------------------------------------------------------
25445               *
25446               * Returns:
25447               *
25448               * A                   The result as an 8-bit magnitude with maximum value 254
25449               *
25450               * Y                   The sign of the result in bit 7
25451               *
25452               * K+3                 Also the sign of the result in bit 7
25453               *
25454               * X                   X gets incremented by 2 so it points to the next
25455               * coordinate in this orientation vector (so consecutive
25456               * calls to the routine will start with x, then move onto y
25457               * and then z)
25458               *
25459               * ******************************************************************************
25460               
25461               PLS1:
25462 73A0 D021  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Set P = nosev_x_lo
     73A2 0053     
25463 73A4 D800  30        movb ra,@P                      ; STA P
     73A6 001B     
25464               
25465 73A8 D021  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Set P+1 = |nosev_x_hi|
     73AA 0054     
25466 73AC 0240  22        andi ra,>7f*256                 ; AND #%01111111
     73AE 7F00     
25467 73B0 D800  30        movb ra,@P+1                    ; STA P+1
     73B2 001C     
25468               
25469 73B4 D021  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Set A = sign bit of nosev_x_lo
     73B6 0054     
25470 73B8 0240  22        andi ra,>80*256                 ; AND #%10000000
     73BA 8000     
25471               
25472 73BC 0206  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     73BE 45E8     
25473 73C0 06A0  28        bl   @jsr                       ;
     73C2 8002     
25474                                                                          ;
25475                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
25476               
25477 73C4 D020  30        movb @K,ra                      ; LDA K             ; Fetch the lowest byte of the result into A
     73C6 003D     
25478               
25479 73C8 D0A0  30        movb @K+1,ry                    ; LDY K+1           ; Fetch the second byte of the result into Y
     73CA 003E     
25480               
25481 73CC 1302  14        jeq  B76                        ; BEQ B76           ; If the second byte is 0, skip the next instruction
25482               
25483 73CE 0200  20        li   ra,>fe*256                 ; LDA #254          ; The second byte is non-zero, so the result won't fit
     73D0 FE00     
25484                                                                          ; into one byte, so set A = 254 as our maximum one-byte
25485                                                                          ; value to return
25486               
25487               B76:
25488 73D2 D0A0  30        movb @K+3,ry                    ; LDY K+3           ; Fetch the sign of the result from K+3 into Y
     73D4 0040     
25489               
25490 73D6 B044  18        ab   rone,rx                    ; INX               ; Add 2 to X so the index points to the next coordinate
25491 73D8 B044  18        ab   rone,rx                    ; INX               ; in this orientation vector (so consecutive calls to
25492                                                                          ; the routine will start with x, then move onto y and z)
25493               
25494 73DA 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     73DC 800E     
25495               
25496               * ******************************************************************************
25497               *
25498               * Name: PLS2
25499               * Type: Subroutine
25500               * Category: Drawing planets
25501               * Summary: Draw a half-ellipse
25502               * Deep dive: Drawing ellipses
25503               * Drawing meridians and equators
25504               *
25505               * ------------------------------------------------------------------------------
25506               *
25507               * Draw a half-ellipse, used for the planet's equator and meridian.
25508               *
25509               * ******************************************************************************
25510               
25511               PLS2:
25512 73DE 0200  20        li   ra,>1f*256                 ; LDA #31           ; Set TGT = 31, so we only draw half an ellipse
     73E0 1F00     
25513 73E2 D800  30        movb ra,@TGT                    ; STA TGT
     73E4 00A0     
25514               
25515                                                                          ; Fall through into PLS22 to draw the half-ellipse
25516               
25517               * ******************************************************************************
25518               *
25519               * Name: PLS22
25520               * Type: Subroutine
25521               * Category: Drawing planets
25522               * Summary: Draw an ellipse or half-ellipse
25523               * Deep dive: Drawing ellipses
25524               * Drawing meridians and equators
25525               * Drawing craters
25526               *
25527               * ------------------------------------------------------------------------------
25528               *
25529               * Draw an ellipse or half-ellipse, to be used for the planet's equator and
25530               * meridian (in which case we draw half an ellipse), or crater (in which case we
25531               * draw a full ellipse).
25532               *
25533               * The ellipse is defined by a centre point, plus two conjugate radius vectors,
25534               * u and v, where:
25535               *
25536               * u = [ u_x ]       v = [ v_x ]
25537               * [ u_y ]           [ v_y ]
25538               *
25539               * The individual components of these 2D vectors (i.e. u_x, u_y etc.) are 16-bit
25540               * sign-magnitude numbers, where the high bytes contain only the sign bit (in
25541               * bit 7), with bits 0 to 6 being clear. This means that as we store u_x as
25542               * (XX16 K2), for example, we know that |u_x| = K2.
25543               *
25544               * This routine calls BLINE to draw each line segment in the ellipse, passing the
25545               * coordinates as follows:
25546               *
25547               * K6(1 0) = K3(1 0) + u_x * cos(CNT2) + v_x * sin(CNT2)
25548               *
25549               * K6(3 2) = K4(1 0) - u_y * cos(CNT2) - v_y * sin(CNT2)
25550               *
25551               * The y-coordinates are negated because BLINE expects pixel coordinates but the
25552               * u and v vectors are extracted from the orientation vector. The y-axis runs
25553               * in the opposite direction in 3D space to that on the screen, so we need to
25554               * negate the 3D space coordinates before we can combine them with the ellipse's
25555               * centre coordinates.
25556               *
25557               * ------------------------------------------------------------------------------
25558               *
25559               * Arguments:
25560               *
25561               * K(1 0)              The planet's radius
25562               *
25563               * K3(1 0)             The pixel x-coordinate of the centre of the ellipse
25564               *
25565               * K4(1 0)             The pixel y-coordinate of the centre of the ellipse
25566               *
25567               * (XX16 K2)           The x-component of u (i.e. u_x), where XX16 contains
25568               * just the sign of the sign-magnitude number
25569               *
25570               * (XX16+1 K2+1)       The y-component of u (i.e. u_y), where XX16+1 contains
25571               * just the sign of the sign-magnitude number
25572               *
25573               * (XX16+2 K2+2)       The x-component of v (i.e. v_x), where XX16+2 contains
25574               * just the sign of the sign-magnitude number
25575               *
25576               * (XX16+3 K2+3)       The y-component of v (i.e. v_y), where XX16+3 contains
25577               * just the sign of the sign-magnitude number
25578               *
25579               * TGT                 The number of segments to draw:
25580               *
25581               * * 32 for a half ellipse (a meridian)
25582               *
25583               * * 64 for a full ellipse (a crater)
25584               *
25585               * CNT2                The starting segment for drawing the half-ellipse
25586               *
25587               * ******************************************************************************
25588               
25589               PLS22:
25590 73E6 0201  20        li   rx,>00*256                 ; LDX #0            ; Set CNT = 0
     73E8 0000     
25591 73EA D801  30        movb rx,@CNT                    ; STX CNT
     73EC 00A4     
25592               
25593 73EE 7044  18        sb   rone,rx                    ; DEX               ; Set FLAG = &FF to start a new line in the ball line
25594 73F0 D801  30        movb rx,@FLAG                   ; STX FLAG          ; heap when calling BLIN below, so the crater or
     73F2 00A3     
25595                                                                          ; meridian is separate from any previous ellipses
25596               
25597               PLL4:
25598 73F4 D020  30        movb @CNT2,ra                   ; LDA CNT2          ; Set X = CNT2 mod 32
     73F6 00A5     
25599 73F8 0240  22        andi ra,>1f*256                 ; AND #31           ;
     73FA 1F00     
25600 73FC D040  18        movb ra,rx                      ; TAX               ; So X is the starting segment, reduced to the range 0
25601                                                                          ; to 32, so as there are 64 segments in the circle, this
25602                                                                          ; reduces the starting angle to 0 to 180 degrees, so we
25603                                                                          ; can use X as an index into the sine table (which only
25604                                                                          ; contains values for segments 0 to 31)
25605                                                                          ;
25606                                                                          ; Also, because CNT2 mod 32 is in the range 0 to 180
25607                                                                          ; degrees, we know that sin(CNT2 mod 32) is always
25608                                                                          ; positive, or to put it another way:
25609                                                                          ;
25610                                                                          ; sin(CNT2 mod 32) = |sin(CNT2)|
25611               
25612 73FE D021  34        movb @SNE(rx),ra                ; LDA SNE,X         ; Set Q = sin(X)
     7400 4112     
25613 7402 D800  30        movb ra,@Q                      ; STA Q             ; = sin(CNT2 mod 32)
     7404 0090     
25614                                                                          ; = |sin(CNT2)|
25615               
25616 7406 D020  30        movb @K2+2,ra                   ; LDA K2+2          ; Set A = K2+2
     7408 00AE     
25617                                                                          ; = |v_x|
25618               
25619 740A 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     740C 4338     
25620 740E 06A0  28        bl   @jsr                       ;
     7410 8002     
25621 7412 D800  30        movb ra,@R                      ; STA R             ; = |v_x| * |sin(CNT2)|
     7414 0091     
25622               
25623 7416 D020  30        movb @K2+3,ra                   ; LDA K2+3          ; Set A = K2+3
     7418 00AF     
25624                                                                          ; = |v_y|
25625               
25626 741A 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set K = A * Q / 256
     741C 4338     
25627 741E 06A0  28        bl   @jsr                       ;
     7420 8002     
25628 7422 D800  30        movb ra,@K                      ; STA K             ; = |v_y| * |sin(CNT2)|
     7424 003D     
25629               
25630 7426 D060  30        movb @CNT2,rx                   ; LDX CNT2          ; If CNT2 >= 33 then this sets the C flag, otherwise
     7428 00A5     
25631 742A 0281  22        ci   rx,>21*256                 ; CPX #33           ; it's clear, so this means that:
     742C 2100     
25632                                                                          ;
25633                                                                          ; * C is clear if the segment starts in the first half
25634                                                                          ; of the circle, 0 to 180 degrees
25635                                                                          ;
25636                                                                          ; * C is set if the segment starts in the second half
25637                                                                          ; of the circle, 180 to 360 degrees
25638                                                                          ;
25639                                                                          ; In other words, the C flag contains the sign bit for
25640                                                                          ; sin(CNT2), which is positive for 0 to 180 degrees
25641                                                                          ; and negative for 180 to 360 degrees
25642               
25643 742E 0200  20        li   ra,>00*256                 ; LDA #0            ; Shift the C flag into the sign bit of XX16+5, so
     7430 0000     
25644 7432 06A0  28        bl   @rora                      ; ROR A             ; XX16+5 has the correct sign for sin(CNT2)
     7434 803C     
25645 7436 D800  30        movb ra,@XX16+5                 ; STA XX16+5        ;
     7438 000E     
25646                                                                          ; Because we set the following above:
25647                                                                          ;
25648                                                                          ; K = |v_y| * |sin(CNT2)|
25649                                                                          ; R = |v_x| * |sin(CNT2)|
25650                                                                          ;
25651                                                                          ; we can add XX16+5 as the high byte to give us the
25652                                                                          ; following:
25653                                                                          ;
25654                                                                          ; (XX16+5 K) = |v_y| * sin(CNT2)
25655                                                                          ; (XX16+5 R) = |v_x| * sin(CNT2)
25656               
25657 743A D020  30        movb @CNT2,ra                   ; LDA CNT2          ; Set X = (CNT2 + 16) mod 32
     743C 00A5     
25658                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 743E 0A13  18        sla  rzero,1
                   < elite.a99
25659                      .adi (>10*256)                  ; ADC #16           ; So we can use X as a lookup index into the SNE table
     **** ****     > ADI
0001 7440 1701  14        jnc  !
0002 7442 B004  18        ab   rone,ra
0003               !:
0004 7444 0220  22        ai   ra,(>10*256)
     7446 1000     
                   < elite.a99
25660 7448 0240  22        andi ra,>1f*256                 ; AND #31           ; to get the cosine (as there are 16 segments in a
     744A 1F00     
25661 744C D040  18        movb ra,rx                      ; TAX               ; quarter-circle)
25662                                                                          ;
25663                                                                          ; Also, because the sine table only contains positive
25664                                                                          ; values, we know that sin((CNT2 + 16) mod 32) will
25665                                                                          ; always be positive, or to put it another way:
25666                                                                          ;
25667                                                                          ; sin((CNT2 + 16) mod 32) = |cos(CNT2)|
25668               
25669 744E D021  34        movb @SNE(rx),ra                ; LDA SNE,X         ; Set Q = sin(X)
     7450 4112     
25670 7452 D800  30        movb ra,@Q                      ; STA Q             ; = sin((CNT2 + 16) mod 32)
     7454 0090     
25671                                                                          ; = |cos(CNT2)|
25672               
25673 7456 D020  30        movb @K2+1,ra                   ; LDA K2+1          ; Set A = K2+1
     7458 00AD     
25674                                                                          ; = |u_y|
25675               
25676 745A 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set K+2 = A * Q / 256
     745C 4338     
25677 745E 06A0  28        bl   @jsr                       ;
     7460 8002     
25678 7462 D800  30        movb ra,@K+2                    ; STA K+2           ; = |u_y| * |cos(CNT2)|
     7464 003F     
25679               
25680 7466 D020  30        movb @K2,ra                     ; LDA K2            ; Set A = K2
     7468 00AC     
25681                                                                          ; = |u_x|
25682               
25683 746A 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set P = A * Q / 256
     746C 4338     
25684 746E 06A0  28        bl   @jsr                       ;
     7470 8002     
25685 7472 D800  30        movb ra,@P                      ; STA P             ; = |u_x| * |cos(CNT2)|
     7474 001B     
25686                                                                          ;
25687                                                                          ; The call to FMLTU also sets the C flag, so in the
25688                                                                          ; following, ADC #15 adds 16 rather than 15
25689               
25690 7476 D020  30        movb @CNT2,ra                   ; LDA CNT2          ; If (CNT2 + 16) mod 64 >= 33 then this sets the C flag,
     7478 00A5     
25691                      .adi (>0f*256)                  ; ADC #15           ; otherwise it's clear, so this means that:
     **** ****     > ADI
0001 747A 1701  14        jnc  !
0002 747C B004  18        ab   rone,ra
0003               !:
0004 747E 0220  22        ai   ra,(>0F*256)
     7480 0F00     
                   < elite.a99
25692 7482 0240  22        andi ra,>3f*256                 ; AND #63           ;
     7484 3F00     
25693 7486 0280  22        ci   ra,>21*256                 ; CMP #33           ; * C is clear if the segment starts in the first or
     7488 2100     
25694                                                                          ; last quarter of the circle, 0 to 90 degrees or 270
25695                                                                          ; to 360 degrees
25696                                                                          ;
25697                                                                          ; * C is set if the segment starts in the second or
25698                                                                          ; third quarter of the circle, 90 to 270 degrees
25699                                                                          ;
25700                                                                          ; In other words, the C flag contains the sign bit for
25701                                                                          ; cos(CNT2), which is positive for 0 to 90 degrees or
25702                                                                          ; 270 to 360 degrees, and negative for 90 to 270 degrees
25703               
25704 748A 0200  20        li   ra,>00*256                 ; LDA #0            ; Shift the C flag into the sign bit of XX16+4, so:
     748C 0000     
25705 748E 06A0  28        bl   @rora                      ; ROR A             ; XX16+4 has the correct sign for cos(CNT2)
     7490 803C     
25706 7492 D800  30        movb ra,@XX16+4                 ; STA XX16+4        ;
     7494 000D     
25707                                                                          ; Because we set the following above:
25708                                                                          ;
25709                                                                          ; K+2 = |u_y| * |cos(CNT2)|
25710                                                                          ; P   = |u_x| * |cos(CNT2)|
25711                                                                          ;
25712                                                                          ; we can add XX16+4 as the high byte to give us the
25713                                                                          ; following:
25714                                                                          ;
25715                                                                          ; (XX16+4 K+2) = |u_y| * cos(CNT2)
25716                                                                          ; (XX16+4 P)   = |u_x| * cos(CNT2)
25717               
25718 7496 D020  30        movb @XX16+5,ra                 ; LDA XX16+5        ; Set S = the sign of XX16+2 * XX16+5
     7498 000E     
25719                      .eor @XX16+2                    ; EOR XX16+2        ; = the sign of v_x * XX16+5
     **** ****     > EOR
0001 749A D1A0  30        movb @XX16+2,rtmp
     749C 000B     
0002 749E 2806  18        xor  rtmp,ra
                   < elite.a99
25720 74A0 D800  30        movb ra,@S                      ; STA S             ;
     74A2 0092     
25721                                                                          ; So because we set this above:
25722                                                                          ;
25723                                                                          ; (XX16+5 R) = |v_x| * sin(CNT2)
25724                                                                          ;
25725                                                                          ; we now have this:
25726                                                                          ;
25727                                                                          ; (S R) = v_x * sin(CNT2)
25728               
25729 74A4 D020  30        movb @XX16+4,ra                 ; LDA XX16+4        ; Set A = the sign of XX16 * XX16+4
     74A6 000D     
25730                      .eor @XX16                      ; EOR XX16          ; = the sign of u_x * XX16+4
     **** ****     > EOR
0001 74A8 D1A0  30        movb @XX16,rtmp
     74AA 0009     
0002 74AC 2806  18        xor  rtmp,ra
                   < elite.a99
25731                                                                          ;
25732                                                                          ; So because we set this above:
25733                                                                          ;
25734                                                                          ; (XX16+4 P)   = |u_x| * cos(CNT2)
25735                                                                          ;
25736                                                                          ; we now have this:
25737                                                                          ;
25738                                                                          ; (A P) = u_x * cos(CNT2)
25739               
25740 74AE 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     74B0 44BA     
25741 74B2 06A0  28        bl   @jsr                       ;
     74B4 8002     
25742                                                                          ; = u_x * cos(CNT2) + v_x * sin(CNT2)
25743               
25744 74B6 D800  30        movb ra,@T                      ; STA T             ; Store the high byte in T, so the result is now:
     74B8 00D1     
25745                                                                          ;
25746                                                                          ; (T X) = u_x * cos(CNT2) + v_x * sin(CNT2)
25747               
25748 74BA 1515  14        jgt  PL42                       ; BPL PL42          ; If the result is positive, jump down to PL42
25749               
25750 74BC D001  18        movb rx,ra                      ; TXA               ; The result is negative, so we need to negate the
25751                      .eoi (>ff*256)                  ; EOR #%11111111    ; magnitude using two's complement, first doing the low
     **** ****     > EOI
0001 74BE 0206  20        li   rtmp,(>FF*256)
     74C0 FF00     
0002 74C2 2806  18        xor  rtmp,ra
                   < elite.a99
25752                      .clc                            ; CLC               ; byte in X
     **** ****     > CLC
0001 74C4 0A13  18        sla  rzero,1
                   < elite.a99
25753                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 74C6 1701  14        jnc  !
0002 74C8 B004  18        ab   rone,ra
0003               !:
0004 74CA 0220  22        ai   ra,(>01*256)
     74CC 0100     
                   < elite.a99
25754 74CE D040  18        movb ra,rx                      ; TAX
25755               
25756 74D0 D020  30        movb @T,ra                      ; LDA T             ; And then the high byte in T, making sure to leave the
     74D2 00D1     
25757                      .eoi (>7f*256)                  ; EOR #%01111111    ; sign bit alone
     **** ****     > EOI
0001 74D4 0206  20        li   rtmp,(>7F*256)
     74D6 7F00     
0002 74D8 2806  18        xor  rtmp,ra
                   < elite.a99
25758                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 74DA 1701  14        jnc  !
0002 74DC B004  18        ab   rone,ra
0003               !:
0004 74DE 0220  22        ai   ra,(>00*256)
     74E0 0000     
                   < elite.a99
25759 74E2 D800  30        movb ra,@T                      ; STA T
     74E4 00D1     
25760               
25761               PL42:
25762 74E6 D001  18        movb rx,ra                      ; TXA               ; Set K6(1 0) = K3(1 0) + (T X)
25763                      .adc @K3,ra                     ; ADC K3            ;
     **** ****     > ADC
0001 74E8 1701  14        jnc  !
0002 74EA B004  18        ab   rone,ra
0003               !:
0004 74EC B020  30        ab   @K3,ra
     74EE 00D2     
                   < elite.a99
25764 74F0 D800  30        movb ra,@K6                     ; STA K6            ; starting with the low bytes
     74F2 0082     
25765               
25766 74F4 D020  30        movb @T,ra                      ; LDA T             ; And then doing the high bytes, so we now get:
     74F6 00D1     
25767                      .adc @K3+1,ra                   ; ADC K3+1          ;
     **** ****     > ADC
0001 74F8 1701  14        jnc  !
0002 74FA B004  18        ab   rone,ra
0003               !:
0004 74FC B020  30        ab   @K3+1,ra
     74FE 00D3     
                   < elite.a99
25768 7500 D800  30        movb ra,@K6+1                   ; STA K6+1          ; K6(1 0) = K3(1 0) + (T X)
     7502 0083     
25769                                                                          ; = K3(1 0) + u_x * cos(CNT2)
25770                                                                          ; + v_x * sin(CNT2)
25771                                                                          ;
25772                                                                          ; K3(1 0) is the x-coordinate of the centre of the
25773                                                                          ; ellipse, so we now have the correct x-coordinate for
25774                                                                          ; our ellipse segment that we can pass to BLINE below
25775               
25776 7504 D020  30        movb @K,ra                      ; LDA K             ; Set R = K = |v_y| * sin(CNT2)
     7506 003D     
25777 7508 D800  30        movb ra,@R                      ; STA R
     750A 0091     
25778               
25779 750C D020  30        movb @XX16+5,ra                 ; LDA XX16+5        ; Set S = the sign of XX16+3 * XX16+5
     750E 000E     
25780                      .eor @XX16+3                    ; EOR XX16+3        ; = the sign of v_y * XX16+5
     **** ****     > EOR
0001 7510 D1A0  30        movb @XX16+3,rtmp
     7512 000C     
0002 7514 2806  18        xor  rtmp,ra
                   < elite.a99
25781 7516 D800  30        movb ra,@S                      ; STA S             ;
     7518 0092     
25782                                                                          ; So because we set this above:
25783                                                                          ;
25784                                                                          ; (XX16+5 K) = |v_y| * sin(CNT2)
25785                                                                          ;
25786                                                                          ; and we just set R = K, we now have this:
25787                                                                          ;
25788                                                                          ; (S R) = v_y * sin(CNT2)
25789               
25790 751A D020  30        movb @K+2,ra                    ; LDA K+2           ; Set P = K+2 = |u_y| * cos(CNT2)
     751C 003F     
25791 751E D800  30        movb ra,@P                      ; STA P
     7520 001B     
25792               
25793 7522 D020  30        movb @XX16+4,ra                 ; LDA XX16+4        ; Set A = the sign of XX16+1 * XX16+4
     7524 000D     
25794                      .eor @XX16+1                    ; EOR XX16+1        ; = the sign of u_y * XX16+4
     **** ****     > EOR
0001 7526 D1A0  30        movb @XX16+1,rtmp
     7528 000A     
0002 752A 2806  18        xor  rtmp,ra
                   < elite.a99
25795                                                                          ;
25796                                                                          ; So because we set this above:
25797                                                                          ;
25798                                                                          ; (XX16+4 K+2) = |u_y| * cos(CNT2)
25799                                                                          ;
25800                                                                          ; and we just set P = K+2, we now have this:
25801                                                                          ;
25802                                                                          ; (A P) = u_y * cos(CNT2)
25803               
25804 752C 0206  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     752E 44BA     
25805 7530 06A0  28        bl   @jsr                       ;
     7532 8002     
25806                                                                          ; =  u_y * cos(CNT2) + v_y * sin(CNT2)
25807               
25808                      .eoi (>80*256)                  ; EOR #%10000000    ; Store the negated high byte in T, so the result is
     **** ****     > EOI
0001 7534 0206  20        li   rtmp,(>80*256)
     7536 8000     
0002 7538 2806  18        xor  rtmp,ra
                   < elite.a99
25809 753A D800  30        movb ra,@T                      ; STA T             ; now:
     753C 00D1     
25810                                                                          ;
25811                                                                          ; (T X) = - u_y * cos(CNT2) - v_y * sin(CNT2)
25812                                                                          ;
25813                                                                          ; This negation is necessary because BLINE expects us
25814                                                                          ; to pass pixel coordinates, where y-coordinates get
25815                                                                          ; larger as we go down the screen; u_y and v_y, on the
25816                                                                          ; other hand, are extracted from the orientation
25817                                                                          ; vectors, where y-coordinates get larger as we go up
25818                                                                          ; in space, so to rectify this we need to negate the
25819                                                                          ; result in (T X) before we can add it to the
25820                                                                          ; y-coordinate of the ellipse's centre in BLINE
25821               
25822 753E 1515  14        jgt  PL43                       ; BPL PL43          ; If the result is positive, jump down to PL43
25823               
25824 7540 D001  18        movb rx,ra                      ; TXA               ; The result is negative, so we need to negate the
25825                      .eoi (>ff*256)                  ; EOR #%11111111    ; magnitude using two's complement, first doing the low
     **** ****     > EOI
0001 7542 0206  20        li   rtmp,(>FF*256)
     7544 FF00     
0002 7546 2806  18        xor  rtmp,ra
                   < elite.a99
25826                      .clc                            ; CLC               ; byte in X
     **** ****     > CLC
0001 7548 0A13  18        sla  rzero,1
                   < elite.a99
25827                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 754A 1701  14        jnc  !
0002 754C B004  18        ab   rone,ra
0003               !:
0004 754E 0220  22        ai   ra,(>01*256)
     7550 0100     
                   < elite.a99
25828 7552 D040  18        movb ra,rx                      ; TAX
25829               
25830 7554 D020  30        movb @T,ra                      ; LDA T             ; And then the high byte in T, making sure to leave the
     7556 00D1     
25831                      .eoi (>7f*256)                  ; EOR #%01111111    ; sign bit alone
     **** ****     > EOI
0001 7558 0206  20        li   rtmp,(>7F*256)
     755A 7F00     
0002 755C 2806  18        xor  rtmp,ra
                   < elite.a99
25832                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 755E 1701  14        jnc  !
0002 7560 B004  18        ab   rone,ra
0003               !:
0004 7562 0220  22        ai   ra,(>00*256)
     7564 0000     
                   < elite.a99
25833 7566 D800  30        movb ra,@T                      ; STA T
     7568 00D1     
25834               
25835               PL43:
25836                                                                          ; We now call BLINE to draw the ellipse line segment
25837                                                                          ;
25838                                                                          ; The first few instructions of BLINE do the following:
25839                                                                          ;
25840                                                                          ; K6(3 2) = K4(1 0) + (T X)
25841                                                                          ;
25842                                                                          ; which gives:
25843                                                                          ;
25844                                                                          ; K6(3 2) = K4(1 0) - u_y * cos(CNT2)
25845                                                                          ; - v_y * sin(CNT2)
25846                                                                          ;
25847                                                                          ; K4(1 0) is the pixel y-coordinate of the centre of the
25848                                                                          ; ellipse, so this gives us the correct y-coordinate for
25849                                                                          ; our ellipse segment (we already calculated the
25850                                                                          ; x-coordinate in K3(1 0) above)
25851 756A 0206  20        li   rtmp,BLINE                 ; JSR BLINE         ; Call BLINE to draw this segment, which also returns
     756C 283E     
25852 756E 06A0  28        bl   @jsr                       ;
     7570 8002     
25853                                                                          ; the updated value of CNT in A
25854               
25855 7572 9020  30        cb   @TGT,ra                    ; CMP TGT           ; If CNT > TGT then jump to PL40 to stop drawing the
     7574 00A0     
25856 7576 1301  14        jeq  B77                        ; BEQ B77           ; ellipse (which is how we draw half-ellipses)
25857 7578 180D  14        joc  PL40                       ; BCS PL40
25858               
25859               B77:
25860 757A D020  30        movb @CNT2,ra                   ; LDA CNT2          ; Set CNT2 = (CNT2 + STP) mod 64
     757C 00A5     
25861                      .clc                            ; CLC
     **** ****     > CLC
0001 757E 0A13  18        sla  rzero,1
                   < elite.a99
25862                      .adc @STP,ra                    ; ADC STP
     **** ****     > ADC
0001 7580 1701  14        jnc  !
0002 7582 B004  18        ab   rone,ra
0003               !:
0004 7584 B020  30        ab   @STP,ra
     7586 00A6     
                   < elite.a99
25863 7588 0240  22        andi ra,>3f*256                 ; AND #63
     758A 3F00     
25864 758C D800  30        movb ra,@CNT2                   ; STA CNT2
     758E 00A5     
25865               
25866 7590 0460  28        b    @PLL4                      ; JMP PLL4          ; Jump back to PLL4 to draw the next segment
     7592 73F4     
25867               
25868               PL40:
25869 7594 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7596 800E     
25870               
25871               * ******************************************************************************
25872               *
25873               * Name: SUN (Part 1 of 4)
25874               * Type: Subroutine
25875               * Category: Drawing suns
25876               * Summary: Draw the sun: Set up all the variables needed to draw the sun
25877               * Deep dive: Drawing the sun
25878               *
25879               * ------------------------------------------------------------------------------
25880               *
25881               * Draw a new sun with radius K at pixel coordinate (K3, K4), removing the old
25882               * sun if there is one. This routine is used to draw the sun, as well as the
25883               * star systems on the Short-range Chart.
25884               *
25885               * The first part sets up all the variables needed to draw the new sun.
25886               *
25887               * ------------------------------------------------------------------------------
25888               *
25889               * Arguments:
25890               *
25891               * K                   The new sun's radius
25892               *
25893               * K3(1 0)             Pixel x-coordinate of the centre of the new sun
25894               *
25895               * K4(1 0)             Pixel y-coordinate of the centre of the new sun
25896               *
25897               * SUNX(1 0)           The x-coordinate of the vertical centre axis of the old
25898               * sun (the one currently on-screen)
25899               *
25900               * ******************************************************************************
25901               
25902 7598 0460  28        b    @WPLS                      ; JMP WPLS          ; Jump to WPLS to remove the old sun from the screen. We
     759A 7970     
25903                                                                          ; only get here via the BCS just after the SUN entry
25904                                                                          ; point below, when there is no new sun to draw
25905               
25906               PLF3:
25907                                                                          ; This is called from below to negate X and set A to
25908                                                                          ; &FF, for when the new sun's centre is off the bottom
25909                                                                          ; of the screen (so we don't need to draw its bottom
25910                                                                          ; half)
25911                                                                          ;
25912                                                                          ; This happens when the y-coordinate of the centre of
25913                                                                          ; the sun is bigger than the y-coordinate of the bottom
25914                                                                          ; of the space view
25915 759C D001  18        movb rx,ra                      ; TXA               ; Negate X using two's complement, so X = ~X + 1
25916                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 759E 0206  20        li   rtmp,(>FF*256)
     75A0 FF00     
0002 75A2 2806  18        xor  rtmp,ra
                   < elite.a99
25917                      .clc                            ; CLC
     **** ****     > CLC
0001 75A4 0A13  18        sla  rzero,1
                   < elite.a99
25918                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 75A6 1701  14        jnc  !
0002 75A8 B004  18        ab   rone,ra
0003               !:
0004 75AA 0220  22        ai   ra,(>01*256)
     75AC 0100     
                   < elite.a99
25919 75AE D040  18        movb ra,rx                      ; TAX
25920               
25921               PLF17:
25922                                                                          ; This is called from below to set A to &FF, for when
25923                                                                          ; the new sun's centre is right on the bottom of the
25924                                                                          ; screen (so we don't need to draw its bottom half)
25925 75B0 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A = &FF
     75B2 FF00     
25926               
25927 75B4 0460  28        b    @PLF5                      ; JMP PLF5          ; Jump to PLF5
     75B6 7640     
25928               
25929               SUN:
25930 75B8 0200  20        li   ra,>01*256                 ; LDA #1            ; Set LSX = 1 to indicate the sun line heap is about to
     75BA 0100     
25931 75BC D800  30        movb ra,@LSX                    ; STA LSX           ; be filled up
     75BE 0D66     
25932               
25933 75C0 0206  20        li   rtmp,CHKON                 ; JSR CHKON         ; Call CHKON to check whether any part of the new sun's
     75C2 7A14     
25934 75C4 06A0  28        bl   @jsr                       ;
     75C6 8002     
25935                                                                          ; circle appears on-screen, and if it does, set P(2 1)
25936                                                                          ; to the maximum y-coordinate of the new sun on-screen
25937               
25938 75C8 18E7  14        joc  PLF3-3                     ; BCS PLF3-3        ; If CHKON set the C flag then the new sun's circle does
25939                                                                          ; not appear on-screen, so jump to WPLS (via the JMP at
25940                                                                          ; the top of this routine) to remove the sun from the
25941                                                                          ; screen, returning from the subroutine using a tail
25942                                                                          ; call
25943               
25944 75CA 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     75CC 0000     
25945               
25946 75CE D060  30        movb @K,rx                      ; LDX K             ; Set X = K = radius of the new sun
     75D0 003D     
25947               
25948 75D2 0281  22        ci   rx,>60*256                 ; CPX #96           ; If X >= 96, set the C flag and rotate it into bit 0
     75D4 6000     
25949 75D6 06A0  28        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     75D8 8018     
25950               
25951 75DA 0281  22        ci   rx,>28*256                 ; CPX #40           ; If X >= 40, set the C flag and rotate it into bit 0
     75DC 2800     
25952 75DE 06A0  28        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     75E0 8018     
25953               
25954 75E2 0281  22        ci   rx,>10*256                 ; CPX #16           ; If X >= 16, set the C flag and rotate it into bit 0
     75E4 1000     
25955 75E6 06A0  28        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     75E8 8018     
25956               
25957                                                                          ; By now, A contains the following:
25958                                                                          ;
25959                                                                          ; * If radius is 96-255 then A = %111 = 7
25960                                                                          ;
25961                                                                          ; * If radius is 40-95  then A = %11  = 3
25962                                                                          ;
25963                                                                          ; * If radius is 16-39  then A = %1   = 1
25964                                                                          ;
25965                                                                          ; * If radius is 0-15   then A = %0   = 0
25966                                                                          ;
25967                                                                          ; The value of A determines the size of the new sun's
25968                                                                          ; ragged fringes - the bigger the sun, the bigger the
25969                                                                          ; fringes
25970               
25971               PLF18:
25972 75EA D800  30        movb ra,@CNT                    ; STA CNT           ; Store the fringe size in CNT
     75EC 00A4     
25973               
25974                                                                          ; We now calculate the highest pixel y-coordinate of the
25975                                                                          ; new sun, given that P(2 1) contains the 16-bit maximum
25976                                                                          ; y-coordinate of the new sun on-screen
25977               
25978 75EE 0200  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     75F0 BF00     
25979                                                                          ; view, so this sets Y to the y-coordinate of the bottom
25980                                                                          ; of the space view
25981               
25982 75F2 D060  30        movb @P+2,rx                    ; LDX P+2           ; If P+2 is non-zero, the maximum y-coordinate is off
     75F4 001D     
25983 75F6 1608  14        jne  PLF2                       ; BNE PLF2          ; the bottom of the screen, so skip to PLF2 with A set
25984                                                                          ; to the y-coordinate of the bottom of the space view
25985               
25986 75F8 9020  30        cb   @P+1,ra                    ; CMP P+1           ; If A < P+1, the maximum y-coordinate is underneath the
     75FA 001C     
25987 75FC 1705  14        jnc  PLF2                       ; BCC PLF2          ; dashboard, so skip to PLF2 with A set to the
25988                                                                          ; y-coordinate of the bottom of the space view
25989               
25990 75FE D020  30        movb @P+1,ra                    ; LDA P+1           ; Set A = P+1, the low byte of the maximum y-coordinate
     7600 001C     
25991                                                                          ; of the sun on-screen
25992               
25993 7602 1602  14        jne  PLF2                       ; BNE PLF2          ; If A is non-zero, skip to PLF2 as it contains the
25994                                                                          ; value we are after
25995               
25996 7604 0200  20        li   ra,>01*256                 ; LDA #1            ; Otherwise set A = 1, the top line of the screen
     7606 0100     
25997               
25998               PLF2:
25999 7608 D800  30        movb ra,@TGT                    ; STA TGT           ; Set TGT to A, the maximum y-coordinate of the sun on
     760A 00A0     
26000                                                                          ; screen
26001               
26002                                                                          ; We now calculate the number of lines we need to draw
26003                                                                          ; and the direction in which we need to draw them, both
26004                                                                          ; from the centre of the new sun
26005               
26006 760C 0200  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set (A X) = y-coordinate of bottom of screen - K4(1 0)
     760E BF00     
26007                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 7610 0A15  18        sla  rmone,1
                   < elite.a99
26008                      .sbc @K4,ra                     ; SBC K4            ; Starting with the low bytes
     **** ****     > SBC
0001 7612 1801  14        joc  !
0002 7614 7004  18        sb   rone,ra
0003               !:
0004 7616 7020  30        sb   @K4,ra
     7618 00E0     
                   < elite.a99
26009 761A D040  18        movb ra,rx                      ; TAX
26010               
26011 761C 0200  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so (A X) now contains
     761E 0000     
26012                      .sbc @K4+1,ra                   ; SBC K4+1          ; the number of lines between the centre of the sun and
     **** ****     > SBC
0001 7620 1801  14        joc  !
0002 7622 7004  18        sb   rone,ra
0003               !:
0004 7624 7020  30        sb   @K4+1,ra
     7626 00E1     
                   < elite.a99
26013                                                                          ; the bottom of the screen. If it is positive then the
26014                                                                          ; centre of the sun is above the bottom of the screen,
26015                                                                          ; if it is negative then the centre of the sun is below
26016                                                                          ; the bottom of the screen
26017               
26018 7628 11B9  14        jlt  PLF3                       ; BMI PLF3          ; If A < 0, then this means the new sun's centre is off
26019                                                                          ; the bottom of the screen, so jump up to PLF3 to negate
26020                                                                          ; the height in X (so it becomes positive), set A to &FF
26021                                                                          ; and jump down to PLF5
26022               
26023 762A 1606  14        jne  PLF4                       ; BNE PLF4          ; If A > 0, then the new sun's centre is at least a full
26024                                                                          ; screen above the bottom of the space view, so jump
26025                                                                          ; down to PLF4 to set X = radius and A = 0
26026               
26027 762C B044  18        ab   rone,rx                    ; INX               ; Set the flags depending on the value of X
26028 762E 7044  18        sb   rone,rx                    ; DEX
26029               
26030 7630 13BF  14        jeq  PLF17                      ; BEQ PLF17         ; If X = 0 (we already know A = 0 by this point) then
26031                                                                          ; jump up to PLF17 to set A to &FF before jumping down
26032                                                                          ; to PLF5
26033               
26034 7632 9060  30        cb   @K,rx                      ; CPX K             ; If X < the radius in K, jump down to PLF5, so if
     7634 003D     
26035 7636 1704  14        jnc  PLF5                       ; BCC PLF5          ; X >= the radius in K, we set X = radius and A = 0
26036               
26037               PLF4:
26038 7638 D060  30        movb @K,rx                      ; LDX K             ; Set X to the radius
     763A 003D     
26039               
26040 763C 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     763E 0000     
26041               
26042               PLF5:
26043 7640 D801  30        movb rx,@V                      ; STX V             ; Store the height in V
     7642 0022     
26044               
26045 7644 D800  30        movb ra,@V+1                    ; STA V+1           ; Store the direction in V+1
     7646 0023     
26046               
26047 7648 D020  30        movb @K,ra                      ; LDA K             ; Set (A P) = K * K
     764A 003D     
26048 764C 0206  20        li   rtmp,SQUA2                 ; JSR SQUA2
     764E 42BA     
26049 7650 06A0  28        bl   @jsr                       ;
     7652 8002     
26050               
26051 7654 D800  30        movb ra,@K2+1                   ; STA K2+1          ; Set K2(1 0) = (A P) = K * K
     7656 00AD     
26052 7658 D020  30        movb @P,ra                      ; LDA P
     765A 001B     
26053 765C D800  30        movb ra,@K2                     ; STA K2
     765E 00AC     
26054               
26055                                                                          ; By the time we get here, the variables should be set
26056                                                                          ; up as shown in the header for part 3 below
26057               
26058               * ******************************************************************************
26059               *
26060               * Name: SUN (Part 2 of 4)
26061               * Type: Subroutine
26062               * Category: Drawing suns
26063               * Summary: Draw the sun: Start from the bottom of the screen and erase the
26064               * old sun line by line
26065               * Deep dive: Drawing the sun
26066               *
26067               * ------------------------------------------------------------------------------
26068               *
26069               * This part erases the old sun, starting at the bottom of the screen and working
26070               * upwards until we reach the bottom of the new sun.
26071               *
26072               * ******************************************************************************
26073               
26074 7660 0202  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; Set Y = y-coordinate of the bottom of the screen,
     7662 BF00     
26075                                                                          ; which we use as a counter in the following routine to
26076                                                                          ; redraw the old sun
26077               
26078 7664 D020  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     7666 0028     
26079 7668 D800  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     766A 0026     
26080 766C D020  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     766E 0029     
26081 7670 D800  30        movb ra,@YY+1                   ; STA YY+1
     7672 0027     
26082               
26083               PLFL2:
26084 7674 90A0  30        cb   @TGT,ry                    ; CPY TGT           ; If Y = TGT, we have reached the line where we will
     7676 00A0     
26085 7678 1309  14        jeq  PLFL                       ; BEQ PLFL          ; start drawing the new sun, so there is no need to
26086                                                                          ; keep erasing the old one, so jump down to PLFL
26087               
26088 767A D022  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     767C 0D66     
26089                                                                          ; gives us the half-width of the old sun's line on this
26090                                                                          ; line of the screen
26091               
26092 767E 1304  14        jeq  PLF13                      ; BEQ PLF13         ; If A = 0, skip the following call to HLOIN2 as there
26093                                                                          ; is no sun line on this line of the screen
26094               
26095 7680 0206  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     7682 25DA     
26096 7684 06A0  28        bl   @jsr                       ;
     7686 8002     
26097                                                                          ; with centre point YY(1 0) and half-width A, and remove
26098                                                                          ; the line from the sun line heap once done
26099               
26100               PLF13:
26101 7688 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
26102               
26103 768A 16F4  14        jne  PLFL2                      ; BNE PLFL2         ; Loop back for the next line in the line heap until
26104                                                                          ; we have either gone through the entire heap, or
26105                                                                          ; reached the bottom row of the new sun
26106               
26107               * ******************************************************************************
26108               *
26109               * Name: SUN (Part 3 of 4)
26110               * Type: Subroutine
26111               * Category: Drawing suns
26112               * Summary: Draw the sun: Continue to move up the screen, drawing the new sun
26113               * line by line
26114               * Deep dive: Drawing the sun
26115               *
26116               * ------------------------------------------------------------------------------
26117               *
26118               * This part draws the new sun. By the time we get to this point, the following
26119               * variables should have been set up by parts 1 and 2:
26120               *
26121               * ------------------------------------------------------------------------------
26122               *
26123               * Arguments:
26124               *
26125               * V                   As we draw lines for the new sun, V contains the
26126               * vertical distance between the line we're drawing and the
26127               * centre of the new sun. As we draw lines and move up the
26128               * screen, we either decrement (bottom half) or increment
26129               * (top half) this value. See the deep dive on "Drawing the
26130               * sun" to see a diagram that shows V in action
26131               *
26132               * V+1                 This determines which half of the new sun we are drawing
26133               * as we work our way up the screen, line by line:
26134               *
26135               * * 0 means we are drawing the bottom half, so the lines
26136               * get wider as we work our way up towards the centre,
26137               * at which point we will move into the top half, and
26138               * V+1 will switch to &FF
26139               *
26140               * * &FF means we are drawing the top half, so the lines
26141               * get smaller as we work our way up, away from the
26142               * centre
26143               *
26144               * TGT                 The maximum y-coordinate of the new sun on-screen (i.e.
26145               * the screen y-coordinate of the bottom row of the new
26146               * sun)
26147               *
26148               * CNT                 The fringe size of the new sun
26149               *
26150               * K2(1 0)             The new sun's radius squared, i.e. K^2
26151               *
26152               * Y                   The y-coordinate of the bottom row of the new sun
26153               *
26154               * ******************************************************************************
26155               
26156               PLFL:
26157 768C D020  30        movb @V,ra                      ; LDA V             ; Set (T P) = V * V
     768E 0022     
26158 7690 0206  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; = V^2
     7692 42BA     
26159 7694 06A0  28        bl   @jsr                       ;
     7696 8002     
26160 7698 D800  30        movb ra,@T                      ; STA T
     769A 00D1     
26161               
26162 769C D020  30        movb @K2,ra                     ; LDA K2            ; Set (R Q) = K^2 - V^2
     769E 00AC     
26163                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 76A0 0A15  18        sla  rmone,1
                   < elite.a99
26164                      .sbc @P,ra                      ; SBC P             ; First calculating the low bytes
     **** ****     > SBC
0001 76A2 1801  14        joc  !
0002 76A4 7004  18        sb   rone,ra
0003               !:
0004 76A6 7020  30        sb   @P,ra
     76A8 001B     
                   < elite.a99
26165 76AA D800  30        movb ra,@Q                      ; STA Q
     76AC 0090     
26166               
26167 76AE D020  30        movb @K2+1,ra                   ; LDA K2+1          ; And then doing the high bytes
     76B0 00AD     
26168                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 76B2 1801  14        joc  !
0002 76B4 7004  18        sb   rone,ra
0003               !:
0004 76B6 7020  30        sb   @T,ra
     76B8 00D1     
                   < elite.a99
26169 76BA D800  30        movb ra,@R                      ; STA R
     76BC 0091     
26170               
26171 76BE D802  30        movb ry,@Y1                     ; STY Y1            ; Store Y in Y1, so we can restore it after the call to
     76C0 0032     
26172                                                                          ; LL5
26173               
26174 76C2 0206  20        li   rtmp,LL5                   ; JSR LL5           ; Set Q = SQRT(R Q)
     76C4 92AA     
26175 76C6 06A0  28        bl   @jsr                       ;
     76C8 8002     
26176                                                                          ; = SQRT(K^2 - V^2)
26177                                                                          ;
26178                                                                          ; So Q contains the half-width of the new sun's line at
26179                                                                          ; height V from the sun's centre - in other words, it
26180                                                                          ; contains the half-width of the sun's line on the
26181                                                                          ; current pixel row Y
26182               
26183 76CA D0A0  30        movb @Y1,ry                     ; LDY Y1            ; Restore Y from Y1
     76CC 0032     
26184               
26185 76CE 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     76D0 8070     
26186 76D2 06A0  28        bl   @jsr                       ;
     76D4 8002     
26187               
26188                      .and @CNT                       ; AND CNT           ; Reduce A to a random number in the range 0 to CNT,
     **** ****     > AND
0001 76D6 D1A0  30        movb @CNT,rtmp
     76D8 00A4     
0002 76DA 0546  14        inv  rtmp
0003 76DC 5006  18        szcb rtmp,ra
                   < elite.a99
26189                                                                          ; where CNT is the fringe size of the new sun
26190               
26191                      .clc                            ; CLC               ; Set A = A + Q
     **** ****     > CLC
0001 76DE 0A13  18        sla  rzero,1
                   < elite.a99
26192                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 76E0 1701  14        jnc  !
0002 76E2 B004  18        ab   rone,ra
0003               !:
0004 76E4 B020  30        ab   @Q,ra
     76E6 0090     
                   < elite.a99
26193                                                                          ; So A now contains the half-width of the sun on row
26194                                                                          ; V, plus a random variation based on the fringe size
26195               
26196 76E8 1702  14        jnc  PLF44                      ; BCC PLF44         ; If the above addition did not overflow, skip the
26197                                                                          ; following instruction
26198               
26199 76EA 0200  20        li   ra,>ff*256                 ; LDA #255          ; The above overflowed, so set the value of A to 255
     76EC FF00     
26200               
26201                                                                          ; So A contains the half-width of the new sun on pixel
26202                                                                          ; line Y, changed by a random amount within the size of
26203                                                                          ; the sun's fringe
26204               
26205               PLF44:
26206 76EE D062  34        movb @LSO(ry),rx                ; LDX LSO,Y         ; Set X to the line heap value for the old sun's line
     76F0 0D66     
26207                                                                          ; at row Y
26208               
26209 76F2 D880  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; Store the half-width of the new row Y line in the line
     76F4 0D66     
26210                                                                          ; heap
26211               
26212 76F6 1346  14        jeq  PLF11                      ; BEQ PLF11         ; If X = 0 then there was no sun line on pixel row Y, so
26213                                                                          ; jump to PLF11
26214               
26215 76F8 D020  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     76FA 0028     
26216 76FC D800  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     76FE 0026     
26217 7700 D020  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     7702 0029     
26218 7704 D800  30        movb ra,@YY+1                   ; STA YY+1
     7706 0027     
26219               
26220 7708 D001  18        movb rx,ra                      ; TXA               ; Transfer the line heap value for the old sun's line
26221                                                                          ; from X into A
26222               
26223 770A 0206  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     770C 79A6     
26224 770E 06A0  28        bl   @jsr                       ;
     7710 8002     
26225                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26226                                                                          ; the line for the old sun
26227               
26228 7712 D020  30        movb @X1,ra                     ; LDA X1            ; Store X1 and X2, the ends of the line for the old sun,
     7714 0031     
26229 7716 D800  30        movb ra,@XX                     ; STA XX            ; in XX and XX+1
     7718 0024     
26230 771A D020  30        movb @X2,ra                     ; LDA X2
     771C 0033     
26231 771E D800  30        movb ra,@XX+1                   ; STA XX+1
     7720 0025     
26232               
26233 7722 D020  30        movb @K3,ra                     ; LDA K3            ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
     7724 00D2     
26234 7726 D800  30        movb ra,@YY                     ; STA YY            ; of the new sun
     7728 0026     
26235 772A D020  30        movb @K3+1,ra                   ; LDA K3+1
     772C 00D3     
26236 772E D800  30        movb ra,@YY+1                   ; STA YY+1
     7730 0027     
26237               
26238 7732 D022  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the half-width of the new row Y line from the
     7734 0D66     
26239                                                                          ; line heap (which we stored above)
26240               
26241 7736 0206  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     7738 79A6     
26242 773A 06A0  28        bl   @jsr                       ;
     773C 8002     
26243                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26244                                                                          ; the line for the new sun
26245               
26246 773E 180C  14        joc  PLF23                      ; BCS PLF23         ; If the C flag is set, the new line doesn't fit on the
26247                                                                          ; screen, so jump to PLF23 to just draw the old line
26248                                                                          ; without drawing the new one
26249               
26250                                                                          ; At this point the old line is from XX to XX+1 and the
26251                                                                          ; new line is from X1 to X2, and both fit on-screen. We
26252                                                                          ; now want to remove the old line and draw the new one.
26253                                                                          ; We could do this by simply drawing the old one then
26254                                                                          ; drawing the new one, but instead Elite does this by
26255                                                                          ; drawing first from X1 to XX and then from X2 to XX+1,
26256                                                                          ; which you can see in action by looking at all the
26257                                                                          ; permutations below of the four points on the line and
26258                                                                          ; imagining what happens if you draw from X1 to XX and
26259                                                                          ; X2 to XX+1 using EOR logic. The six possible
26260                                                                          ; permutations are as follows, along with the result of
26261                                                                          ; drawing X1 to XX and then X2 to XX+1:
26262                                                                          ;
26263                                                                          ; X1    X2    XX____XX+1      ->      +__+  +  +
26264                                                                          ;
26265                                                                          ; X1    XX____X2____XX+1      ->      +__+__+  +
26266                                                                          ;
26267                                                                          ; X1    XX____XX+1  X2        ->      +__+__+__+
26268                                                                          ;
26269                                                                          ; XX____X1____XX+1  X2        ->      +  +__+__+
26270                                                                          ;
26271                                                                          ; XX____XX+1  X1    X2        ->      +  +  +__+
26272                                                                          ;
26273                                                                          ; XX____X1____X2____XX+1      ->      +  +__+  +
26274                                                                          ;
26275                                                                          ; They all end up with a line between X1 and X2, which
26276                                                                          ; is what we want. There's probably a mathematical proof
26277                                                                          ; of why this works somewhere, but the above is probably
26278                                                                          ; easier to follow.
26279                                                                          ;
26280                                                                          ; We can draw from X1 to XX and X2 to XX+1 by swapping
26281                                                                          ; XX and X2 and drawing from X1 to X2, and then drawing
26282                                                                          ; from XX to XX+1, so let's do this now
26283               
26284 7740 D020  30        movb @X2,ra                     ; LDA X2            ; Swap XX and X2
     7742 0033     
26285 7744 D060  30        movb @XX,rx                     ; LDX XX
     7746 0024     
26286 7748 D801  30        movb rx,@X2                     ; STX X2
     774A 0033     
26287 774C D800  30        movb ra,@XX                     ; STA XX
     774E 0024     
26288               
26289 7750 0206  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1)
     7752 25EE     
26290 7754 06A0  28        bl   @jsr                       ;
     7756 8002     
26291               
26292               PLF23:
26293                                                                          ; If we jump here from the BCS above when there is no
26294                                                                          ; new line this will just draw the old line
26295 7758 D020  30        movb @XX,ra                     ; LDA XX            ; Set X1 = XX
     775A 0024     
26296 775C D800  30        movb ra,@X1                     ; STA X1
     775E 0031     
26297               
26298 7760 D020  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X2 = XX+1
     7762 0025     
26299 7764 D800  30        movb ra,@X2                     ; STA X2
     7766 0033     
26300               
26301               PLF16:
26302 7768 0206  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1)
     776A 25EE     
26303 776C 06A0  28        bl   @jsr                       ;
     776E 8002     
26304               
26305               PLF6:
26306 7770 7084  18        sb   rone,ry                    ; DEY               ; Decrement the line number in Y to move to the line
26307                                                                          ; above
26308               
26309 7772 1334  14        jeq  PLF8                       ; BEQ PLF8          ; If we have reached the top of the screen, jump to PLF8
26310                                                                          ; as we are done drawing (the top line of the screen is
26311                                                                          ; the border, so we don't draw there)
26312               
26313 7774 D020  30        movb @V+1,ra                    ; LDA V+1           ; If V+1 is non-zero then we are doing the top half of
     7776 0023     
26314 7778 1617  14        jne  PLF10                      ; BNE PLF10         ; the new sun, so jump down to PLF10 to increment V and
26315                                                                          ; decrease the width of the line we draw
26316               
26317 777A 7004  18        sb   rone,ra                    ; DEC V             ; Decrement V, the height of the sun that we use to work
26318                                                                          ; out the width, so this makes the line get wider, as we
26319                                                                          ; move up towards the sun's centre
26320               
26321 777C 1687  14        jne  PLFL                       ; BNE PLFL          ; If V is non-zero, jump back up to PLFL to do the next
26322                                                                          ; screen line up
26323               
26324 777E 7004  18        sb   rone,ra                    ; DEC V+1           ; Otherwise V is 0 and we have reached the centre of the
26325                                                                          ; sun, so decrement V+1 to -1 so we start incrementing V
26326                                                                          ; each time, thus doing the top half of the new sun
26327               
26328               PLFLS:
26329 7780 0460  28        b    @PLFL                      ; JMP PLFL          ; Jump back up to PLFL to do the next screen line up
     7782 768C     
26330               
26331               PLF11:
26332                                                                          ; If we get here then there is no old sun line on this
26333                                                                          ; line, so we can just draw the new sun's line
26334 7784 D060  30        movb @K3,rx                     ; LDX K3            ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
     7786 00D2     
26335 7788 D801  30        movb rx,@YY                     ; STX YY            ; of the new sun's line
     778A 0026     
26336 778C D060  30        movb @K3+1,rx                   ; LDX K3+1
     778E 00D3     
26337 7790 D801  30        movb rx,@YY+1                   ; STX YY+1
     7792 0027     
26338               
26339 7794 0206  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     7796 79A6     
26340 7798 06A0  28        bl   @jsr                       ;
     779A 8002     
26341                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26342                                                                          ; the line for the new sun
26343               
26344 779C 17E5  14        jnc  PLF16                      ; BCC PLF16         ; If the line is on-screen, jump up to PLF16 to draw the
26345                                                                          ; line and loop round for the next line up
26346               
26347 779E 0200  20        li   ra,>00*256                 ; LDA #0            ; The line is not on-screen, so set the line heap for
     77A0 0000     
26348 77A2 D880  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; line Y to 0, which means there is no sun line here
     77A4 0D66     
26349               
26350 77A6 13E4  14        jeq  PLF6                       ; BEQ PLF6          ; Jump up to PLF6 to loop round for the next line up
26351                                                                          ; (this BEQ is effectively a JMP as A is always zero)
26352               
26353               PLF10:
26354 77A8 D060  30        movb @V,rx                      ; LDX V             ; Increment V, the height of the sun that we use to work
     77AA 0022     
26355 77AC B044  18        ab   rone,rx                    ; INX               ; out the width, so this makes the line get narrower, as
26356 77AE D801  30        movb rx,@V                      ; STX V             ; we move up and away from the sun's centre
     77B0 0022     
26357               
26358 77B2 9060  30        cb   @K,rx                      ; CPX K             ; If V <= the radius of the sun, we still have lines to
     77B4 003D     
26359 77B6 17E4  14        jnc  PLFLS                      ; BCC PLFLS         ; draw, so jump up to PLFL (via PLFLS) to do the next
26360 77B8 13E3  14        jeq  PLFLS                      ; BEQ PLFLS         ; screen line up
26361               
26362               * ******************************************************************************
26363               *
26364               * Name: SUN (Part 4 of 4)
26365               * Type: Subroutine
26366               * Category: Drawing suns
26367               * Summary: Draw the sun: Continue to the top of the screen, erasing the old
26368               * sun line by line
26369               * Deep dive: Drawing the sun
26370               *
26371               * ------------------------------------------------------------------------------
26372               *
26373               * This part erases any remaining traces of the old sun, now that we have drawn
26374               * all the way to the top of the new sun.
26375               *
26376               * ------------------------------------------------------------------------------
26377               *
26378               * Other entry points:
26379               *
26380               * RTS2                Contains an RTS
26381               *
26382               * ******************************************************************************
26383               
26384 77BA D020  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     77BC 0028     
26385 77BE D800  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     77C0 0026     
26386 77C2 D020  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     77C4 0029     
26387 77C6 D800  30        movb ra,@YY+1                   ; STA YY+1
     77C8 0027     
26388               
26389               PLFL3:
26390 77CA D022  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     77CC 0D66     
26391                                                                          ; gives us the half-width of the old sun's line on this
26392                                                                          ; line of the screen
26393               
26394 77CE 1304  14        jeq  PLF9                       ; BEQ PLF9          ; If A = 0, skip the following call to HLOIN2 as there
26395                                                                          ; is no sun line on this line of the screen
26396               
26397 77D0 0206  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     77D2 25DA     
26398 77D4 06A0  28        bl   @jsr                       ;
     77D6 8002     
26399                                                                          ; with centre point YY(1 0) and half-width A, and remove
26400                                                                          ; the line from the sun line heap once done
26401               
26402               PLF9:
26403 77D8 7084  18        sb   rone,ry                    ; DEY               ; Decrement the line number in Y to move to the line
26404                                                                          ; above
26405               
26406 77DA 16F7  14        jne  PLFL3                      ; BNE PLFL3         ; Jump up to PLFL3 to redraw the next line up, until we
26407                                                                          ; have reached the top of the screen
26408               
26409               PLF8:
26410                                                                          ; If we get here, we have successfully made it from the
26411                                                                          ; bottom line of the screen to the top, and the old sun
26412                                                                          ; has been replaced by the new one
26413                      .clc                            ; CLC               ; Clear the C flag to indicate success in drawing the
     **** ****     > CLC
0001 77DC 0A13  18        sla  rzero,1
                   < elite.a99
26414                                                                          ; sun
26415               
26416 77DE D020  30        movb @K3,ra                     ; LDA K3            ; Set SUNX(1 0) = K3(1 0)
     77E0 00D2     
26417 77E2 D800  30        movb ra,@SUNX                   ; STA SUNX
     77E4 0028     
26418 77E6 D020  30        movb @K3+1,ra                   ; LDA K3+1
     77E8 00D3     
26419 77EA D800  30        movb ra,@SUNX+1                 ; STA SUNX+1
     77EC 0029     
26420               
26421               RTS2:
26422 77EE 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     77F0 800E     
26423               
26424               * ******************************************************************************
26425               *
26426               * Name: CIRCLE
26427               * Type: Subroutine
26428               * Category: Drawing circles
26429               * Summary: Draw a circle for the planet
26430               * Deep dive: Drawing circles
26431               *
26432               * ------------------------------------------------------------------------------
26433               *
26434               * Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
26435               * planet's main outline.
26436               *
26437               * ------------------------------------------------------------------------------
26438               *
26439               * Arguments:
26440               *
26441               * K                   The planet's radius
26442               *
26443               * K3(1 0)             Pixel x-coordinate of the centre of the planet
26444               *
26445               * K4(1 0)             Pixel y-coordinate of the centre of the planet
26446               *
26447               * ******************************************************************************
26448               
26449               CIRCLE:
26450 77F2 0206  20        li   rtmp,CHKON                 ; JSR CHKON         ; Call CHKON to check whether the circle fits on-screen
     77F4 7A14     
26451 77F6 06A0  28        bl   @jsr                       ;
     77F8 8002     
26452               
26453 77FA 18F9  14        joc  RTS2                       ; BCS RTS2          ; If CHKON set the C flag then the circle does not fit
26454                                                                          ; on-screen, so return from the subroutine (as RTS2
26455                                                                          ; contains an RTS)
26456               
26457 77FC 0200  20        li   ra,>00*256                 ; LDA #0            ; Set LSX2 = 0 to indicate that the ball line heap is
     77FE 0000     
26458 7800 D800  30        movb ra,@LSX2                   ; STA LSX2          ; not empty, as we are about to fill it
     7802 0E26     
26459               
26460 7804 D060  30        movb @K,rx                      ; LDX K             ; Set X = K = radius
     7806 003D     
26461               
26462 7808 0200  20        li   ra,>08*256                 ; LDA #8            ; Set A = 8
     780A 0800     
26463               
26464 780C 0281  22        ci   rx,>08*256                 ; CPX #8            ; If the radius < 8, skip to PL89
     780E 0800     
26465 7810 1705  14        jnc  PL89                       ; BCC PL89
26466               
26467 7812 0910  18        srl  ra,1                       ; LSR A             ; Halve A so A = 4
26468               
26469 7814 0281  22        ci   rx,>3c*256                 ; CPX #60           ; If the radius < 60, skip to PL89
     7816 3C00     
26470 7818 1701  14        jnc  PL89                       ; BCC PL89
26471               
26472 781A 0910  18        srl  ra,1                       ; LSR A             ; Halve A so A = 2
26473               
26474               PL89:
26475 781C D800  30        movb ra,@STP                    ; STA STP           ; Set STP = A. STP is the step size for the circle, so
     781E 00A6     
26476                                                                          ; the above sets a smaller step size for bigger circles
26477               
26478                                                                          ; Fall through into CIRCLE2 to draw the circle with the
26479                                                                          ; correct step size
26480               
26481               * ******************************************************************************
26482               *
26483               * Name: CIRCLE2
26484               * Type: Subroutine
26485               * Category: Drawing circles
26486               * Summary: Draw a circle (for the planet or chart)
26487               * Deep dive: Drawing circles
26488               *
26489               * ------------------------------------------------------------------------------
26490               *
26491               * Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
26492               * planet and the chart circles.
26493               *
26494               * ------------------------------------------------------------------------------
26495               *
26496               * Arguments:
26497               *
26498               * STP                 The step size for the circle
26499               *
26500               * K                   The circle's radius
26501               *
26502               * K3(1 0)             Pixel x-coordinate of the centre of the circle
26503               *
26504               * K4(1 0)             Pixel y-coordinate of the centre of the circle
26505               *
26506               * ------------------------------------------------------------------------------
26507               *
26508               * Returns:
26509               *
26510               * C flag              The C flag is cleared
26511               *
26512               * ******************************************************************************
26513               
26514               CIRCLE2:
26515 7820 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Set FLAG = &FF to reset the ball line heap in the call
     7822 FF00     
26516 7824 D801  30        movb rx,@FLAG                   ; STX FLAG          ; to the BLINE routine below
     7826 00A3     
26517               
26518 7828 B044  18        ab   rone,rx                    ; INX               ; Set CNT = 0, our counter that goes up to 64, counting
26519 782A D801  30        movb rx,@CNT                    ; STX CNT           ; segments in our circle
     782C 00A4     
26520               
26521               PLL3:
26522 782E D020  30        movb @CNT,ra                    ; LDA CNT           ; Set A = CNT
     7830 00A4     
26523               
26524 7832 0206  20        li   rtmp,FMLTU2                ; JSR FMLTU2        ; Call FMLTU2 to calculate:
     7834 4326     
26525 7836 06A0  28        bl   @jsr                       ;
     7838 8002     
26526                                                                          ;
26527                                                                          ; A = K * sin(A)
26528                                                                          ; = K * sin(CNT)
26529               
26530 783A 0201  20        li   rx,>00*256                 ; LDX #0            ; Set T = 0, so we have the following:
     783C 0000     
26531 783E D801  30        movb rx,@T                      ; STX T             ;
     7840 00D1     
26532                                                                          ; (T A) = K * sin(CNT)
26533                                                                          ;
26534                                                                          ; which is the x-coordinate of the circle for this count
26535               
26536 7842 D060  30        movb @CNT,rx                    ; LDX CNT           ; If CNT < 33 then jump to PL37, as this is the right
     7844 00A4     
26537 7846 0281  22        ci   rx,>21*256                 ; CPX #33           ; half of the circle and the sign of the x-coordinate is
     7848 2100     
26538 784A 1712  14        jnc  PL37                       ; BCC PL37          ; correct
26539               
26540                      .eoi (>ff*256)                  ; EOR #%11111111    ; This is the left half of the circle, so we want to
     **** ****     > EOI
0001 784C 0206  20        li   rtmp,(>FF*256)
     784E FF00     
0002 7850 2806  18        xor  rtmp,ra
                   < elite.a99
26541                      .adi (>00*256)                  ; ADC #0            ; flip the sign of the x-coordinate in (T A) using two's
     **** ****     > ADI
0001 7852 1701  14        jnc  !
0002 7854 B004  18        ab   rone,ra
0003               !:
0004 7856 0220  22        ai   ra,(>00*256)
     7858 0000     
                   < elite.a99
26542 785A D040  18        movb ra,rx                      ; TAX               ; complement, so we start with the low byte and store it
26543                                                                          ; in X (the ADC adds 1 as we know the C flag is set)
26544               
26545 785C 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; And then we flip the high byte in T
     785E FF00     
26546                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 7860 1701  14        jnc  !
0002 7862 B004  18        ab   rone,ra
0003               !:
0004 7864 0220  22        ai   ra,(>00*256)
     7866 0000     
                   < elite.a99
26547 7868 D800  30        movb ra,@T                      ; STA T
     786A 00D1     
26548               
26549 786C D001  18        movb rx,ra                      ; TXA               ; Finally, we restore the low byte from X, so we have
26550                                                                          ; now negated the x-coordinate in (T A)
26551               
26552                      .clc                            ; CLC               ; Clear the C flag so we can do some more addition below
     **** ****     > CLC
0001 786E 0A13  18        sla  rzero,1
                   < elite.a99
26553               
26554               PL37:
26555                      .adc @K3,ra                     ; ADC K3            ; We now calculate the following:
     **** ****     > ADC
0001 7870 1701  14        jnc  !
0002 7872 B004  18        ab   rone,ra
0003               !:
0004 7874 B020  30        ab   @K3,ra
     7876 00D2     
                   < elite.a99
26556 7878 D800  30        movb ra,@K6                     ; STA K6            ;
     787A 0082     
26557                                                                          ; K6(1 0) = (T A) + K3(1 0)
26558                                                                          ;
26559                                                                          ; to add the coordinates of the centre to our circle
26560                                                                          ; point, starting with the low bytes
26561               
26562 787C D020  30        movb @K3+1,ra                   ; LDA K3+1          ; And then doing the high bytes, so we now have:
     787E 00D3     
26563                      .adc @T,ra                      ; ADC T             ;
     **** ****     > ADC
0001 7880 1701  14        jnc  !
0002 7882 B004  18        ab   rone,ra
0003               !:
0004 7884 B020  30        ab   @T,ra
     7886 00D1     
                   < elite.a99
26564 7888 D800  30        movb ra,@K6+1                   ; STA K6+1          ; K6(1 0) = K * sin(CNT) + K3(1 0)
     788A 0083     
26565                                                                          ;
26566                                                                          ; which is the result we want for the x-coordinate
26567               
26568 788C D020  30        movb @CNT,ra                    ; LDA CNT           ; Set A = CNT + 16
     788E 00A4     
26569                      .clc                            ; CLC
     **** ****     > CLC
0001 7890 0A13  18        sla  rzero,1
                   < elite.a99
26570                      .adi (>10*256)                  ; ADC #16
     **** ****     > ADI
0001 7892 1701  14        jnc  !
0002 7894 B004  18        ab   rone,ra
0003               !:
0004 7896 0220  22        ai   ra,(>10*256)
     7898 1000     
                   < elite.a99
26571               
26572 789A 0206  20        li   rtmp,FMLTU2                ; JSR FMLTU2        ; Call FMLTU2 to calculate:
     789C 4326     
26573 789E 06A0  28        bl   @jsr                       ;
     78A0 8002     
26574                                                                          ;
26575                                                                          ; A = K * sin(A)
26576                                                                          ; = K * sin(CNT + 16)
26577                                                                          ; = K * cos(CNT)
26578               
26579 78A2 D040  18        movb ra,rx                      ; TAX               ; Set X = A
26580                                                                          ; = K * cos(CNT)
26581               
26582 78A4 0200  20        li   ra,>00*256                 ; LDA #0            ; Set T = 0, so we have the following:
     78A6 0000     
26583 78A8 D800  30        movb ra,@T                      ; STA T             ;
     78AA 00D1     
26584                                                                          ; (T X) = K * cos(CNT)
26585                                                                          ;
26586                                                                          ; which is the y-coordinate of the circle for this count
26587               
26588 78AC D020  30        movb @CNT,ra                    ; LDA CNT           ; Set A = (CNT + 15) mod 64
     78AE 00A4     
26589                      .adi (>0f*256)                  ; ADC #15
     **** ****     > ADI
0001 78B0 1701  14        jnc  !
0002 78B2 B004  18        ab   rone,ra
0003               !:
0004 78B4 0220  22        ai   ra,(>0F*256)
     78B6 0F00     
                   < elite.a99
26590 78B8 0240  22        andi ra,>3f*256                 ; AND #63
     78BA 3F00     
26591               
26592 78BC 0280  22        ci   ra,>21*256                 ; CMP #33           ; If A < 33 (i.e. CNT is 0-16 or 48-64) then jump to
     78BE 2100     
26593 78C0 1712  14        jnc  PL38                       ; BCC PL38          ; PL38, as this is the bottom half of the circle and the
26594                                                                          ; sign of the y-coordinate is correct
26595               
26596 78C2 D001  18        movb rx,ra                      ; TXA               ; This is the top half of the circle, so we want to
26597                      .eoi (>ff*256)                  ; EOR #%11111111    ; flip the sign of the y-coordinate in (T X) using two's
     **** ****     > EOI
0001 78C4 0206  20        li   rtmp,(>FF*256)
     78C6 FF00     
0002 78C8 2806  18        xor  rtmp,ra
                   < elite.a99
26598                      .adi (>00*256)                  ; ADC #0            ; complement, so we start with the low byte in X (the
     **** ****     > ADI
0001 78CA 1701  14        jnc  !
0002 78CC B004  18        ab   rone,ra
0003               !:
0004 78CE 0220  22        ai   ra,(>00*256)
     78D0 0000     
                   < elite.a99
26599 78D2 D040  18        movb ra,rx                      ; TAX               ; ADC adds 1 as we know the C flag is set)
26600               
26601 78D4 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; And then we flip the high byte in T, so we have
     78D6 FF00     
26602                      .adi (>00*256)                  ; ADC #0            ; now negated the y-coordinate in (T X)
     **** ****     > ADI
0001 78D8 1701  14        jnc  !
0002 78DA B004  18        ab   rone,ra
0003               !:
0004 78DC 0220  22        ai   ra,(>00*256)
     78DE 0000     
                   < elite.a99
26603 78E0 D800  30        movb ra,@T                      ; STA T
     78E2 00D1     
26604               
26605                      .clc                            ; CLC               ; Clear the C flag so the addition at the start of BLINE
     **** ****     > CLC
0001 78E4 0A13  18        sla  rzero,1
                   < elite.a99
26606                                                                          ; will work
26607               
26608               PL38:
26609 78E6 0206  20        li   rtmp,BLINE                 ; JSR BLINE         ; Call BLINE to draw this segment, which also increases
     78E8 283E     
26610 78EA 06A0  28        bl   @jsr                       ;
     78EC 8002     
26611                                                                          ; CNT by STP, the step size
26612               
26613 78EE 0280  22        ci   ra,>41*256                 ; CMP #65           ; If CNT >= 65 then skip the next instruction
     78F0 4100     
26614 78F2 1802  14        joc  B78                        ; BCS B78
26615               
26616 78F4 0460  28        b    @PLL3                      ; JMP PLL3          ; Jump back for the next segment
     78F6 782E     
26617               
26618               B78:
26619                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 78F8 0A13  18        sla  rzero,1
                   < elite.a99
26620               
26621 78FA 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     78FC 800E     
26622               
26623               * ******************************************************************************
26624               *
26625               * Name: WPLS2
26626               * Type: Subroutine
26627               * Category: Drawing planets
26628               * Summary: Remove the planet from the screen
26629               * Deep dive: The ball line heap
26630               *
26631               * ------------------------------------------------------------------------------
26632               *
26633               * We do this by redrawing it using the lines stored in the ball line heap when
26634               * the planet was originally drawn by the BLINE routine.
26635               *
26636               * ******************************************************************************
26637               
26638               WPLS2:
26639 78FE D0A0  30        movb @LSX2,ry                   ; LDY LSX2          ; If LSX2 is non-zero (which indicates the ball line
     7900 0E26     
26640 7902 162C  14        jne  WP1                        ; BNE WP1           ; heap is empty), jump to WP1 to reset the line heap
26641                                                                          ; without redrawing the planet
26642               
26643                                                                          ; Otherwise Y is now 0, so we can use it as a counter to
26644                                                                          ; loop through the lines in the line heap, redrawing
26645                                                                          ; each one to remove the planet from the screen, before
26646                                                                          ; resetting the line heap once we are done
26647               
26648               WPL1:
26649 7904 90A0  30        cb   @LSP,ry                    ; CPY LSP           ; If Y >= LSP then we have reached the end of the line
     7906 0077     
26650 7908 1829  14        joc  WP1                        ; BCS WP1           ; heap and have finished redrawing the planet (as LSP
26651                                                                          ; points to the end of the heap), so jump to WP1 to
26652                                                                          ; reset the line heap, returning from the subroutine
26653                                                                          ; using a tail call
26654               
26655 790A D022  34        movb @LSY2(ry),ra               ; LDA LSY2,Y        ; Set A to the y-coordinate of the current heap entry
     790C 0E74     
26656               
26657 790E 0280  22        ci   ra,>ff*256                 ; CMP #&FF          ; If the y-coordinate is &FF, this indicates that the
     7910 FF00     
26658 7912 1318  14        jeq  WP2                        ; BEQ WP2           ; next point in the heap denotes the start of a line
26659                                                                          ; segment, so jump to WP2 to put it into (X1, Y1)
26660               
26661 7914 D800  30        movb ra,@Y2                     ; STA Y2            ; Set (X2, Y2) to the x- and y-coordinates from the
     7916 0034     
26662 7918 D022  34        movb @LSX2(ry),ra               ; LDA LSX2,Y        ; heap
     791A 0E26     
26663 791C D800  30        movb ra,@X2                     ; STA X2
     791E 0033     
26664               
26665 7920 0206  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2)
     7922 224E     
26666 7924 06A0  28        bl   @jsr                       ;
     7926 8002     
26667               
26668 7928 B084  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
26669               
26670 792A D020  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP is non-zero then we swapped the coordinates
     792C 00A1     
26671 792E 16EA  14        jne  WPL1                       ; BNE WPL1          ; when filling the heap in BLINE, so loop back WPL1
26672                                                                          ; for the next point in the heap
26673               
26674 7930 D020  30        movb @X2,ra                     ; LDA X2            ; Swap (X1, Y1) and (X2, Y2), so the next segment will
     7932 0033     
26675 7934 D800  30        movb ra,@X1                     ; STA X1            ; be drawn from the current (X2, Y2) to the next point
     7936 0031     
26676 7938 D020  30        movb @Y2,ra                     ; LDA Y2            ; in the heap
     793A 0034     
26677 793C D800  30        movb ra,@Y1                     ; STA Y1
     793E 0032     
26678               
26679 7940 0460  28        b    @WPL1                      ; JMP WPL1          ; Loop back to WPL1 for the next point in the heap
     7942 7904     
26680               
26681               WP2:
26682 7944 B084  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
26683               
26684 7946 D022  34        movb @LSX2(ry),ra               ; LDA LSX2,Y        ; Set (X1, Y1) to the x- and y-coordinates from the
     7948 0E26     
26685 794A D800  30        movb ra,@X1                     ; STA X1            ; heap
     794C 0031     
26686 794E D022  34        movb @LSY2(ry),ra               ; LDA LSY2,Y
     7950 0E74     
26687 7952 D800  30        movb ra,@Y1                     ; STA Y1
     7954 0032     
26688               
26689 7956 B084  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
26690               
26691 7958 0460  28        b    @WPL1                      ; JMP WPL1          ; Loop back to WPL1 for the next point in the heap
     795A 7904     
26692               
26693               * ******************************************************************************
26694               *
26695               * Name: WP1
26696               * Type: Subroutine
26697               * Category: Drawing planets
26698               * Summary: Reset the ball line heap
26699               *
26700               * ******************************************************************************
26701               
26702               WP1:
26703 795C 0200  20        li   ra,>01*256                 ; LDA #1            ; Set LSP = 1 to reset the ball line heap pointer
     795E 0100     
26704 7960 D800  30        movb ra,@LSP                    ; STA LSP
     7962 0077     
26705               
26706 7964 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Set LSX2 = &FF to indicate the ball line heap is empty
     7966 FF00     
26707 7968 D800  30        movb ra,@LSX2                   ; STA LSX2
     796A 0E26     
26708               
26709 796C 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     796E 800E     
26710               
26711               * ******************************************************************************
26712               *
26713               * Name: WPLS
26714               * Type: Subroutine
26715               * Category: Drawing suns
26716               * Summary: Remove the sun from the screen
26717               * Deep dive: Drawing the sun
26718               *
26719               * ------------------------------------------------------------------------------
26720               *
26721               * We do this by redrawing it using the lines stored in the sun line heap when
26722               * the sun was originally drawn by the SUN routine.
26723               *
26724               * ------------------------------------------------------------------------------
26725               *
26726               * Arguments:
26727               *
26728               * SUNX(1 0)           The x-coordinate of the vertical centre axis of the sun
26729               *
26730               * ------------------------------------------------------------------------------
26731               *
26732               * Other entry points:
26733               *
26734               * WPLS-1              Contains an RTS
26735               *
26736               * ******************************************************************************
26737               
26738               WPLS:
26739 7970 D020  30        movb @LSX,ra                    ; LDA LSX           ; If LSX < 0, the sun line heap is empty, so return from
     7972 0D66     
26740 7974 11FC  14        jlt  WPLS-1                     ; BMI WPLS-1        ; the subroutine (as WPLS-1 contains an RTS)
26741               
26742 7976 D020  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     7978 0028     
26743 797A D800  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the sun that's currently on
     797C 0026     
26744 797E D020  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; screen
     7980 0029     
26745 7982 D800  30        movb ra,@YY+1                   ; STA YY+1
     7984 0027     
26746               
26747 7986 0202  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     7988 BF00     
26748                                                                          ; view, so this sets Y as a counter for the number of
26749                                                                          ; lines in the space view (i.e. 191), which is also the
26750                                                                          ; number of lines in the LSO block
26751               
26752               WPL2:
26753 798A D022  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     798C 0D66     
26754                                                                          ; gives us the half-width of the sun's line on this line
26755                                                                          ; of the screen
26756               
26757 798E 1304  14        jeq  B79                        ; BEQ B79           ; If A = 0, skip the following call to HLOIN2 as there
26758                                                                          ; is no sun line on this line of the screen
26759               
26760 7990 0206  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     7992 25DA     
26761 7994 06A0  28        bl   @jsr                       ;
     7996 8002     
26762                                                                          ; with centre point YY(1 0) and half-width A, and remove
26763                                                                          ; the line from the sun line heap once done
26764               
26765               B79:
26766 7998 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
26767               
26768 799A 16F7  14        jne  WPL2                       ; BNE WPL2          ; Loop back for the next line in the line heap until
26769                                                                          ; we have gone through the entire heap
26770               
26771 799C 7084  18        sb   rone,ry                    ; DEY               ; This sets Y to &FF, as we end the loop with Y = 0
26772               
26773 799E D802  30        movb ry,@LSX                    ; STY LSX           ; Set LSX to &FF to indicate the sun line heap is empty
     79A0 0D66     
26774               
26775 79A2 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     79A4 800E     
26776               
26777               * ******************************************************************************
26778               *
26779               * Name: EDGES
26780               * Type: Subroutine
26781               * Category: Drawing lines
26782               * Summary: Draw a horizontal line given a centre and a half-width
26783               *
26784               * ------------------------------------------------------------------------------
26785               *
26786               * Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
26787               * centre x-coordinate YY(1 0), and length A in either direction from the centre
26788               * (so a total line length of 2 * A). In other words, this line:
26789               *
26790               * X1             YY(1 0)             X2
26791               * +-----------------+-----------------+
26792               * <- A ->           <- A ->
26793               *
26794               * The resulting line gets clipped to the edges of the screen, if needed. If the
26795               * calculation doesn't overflow, we return with the C flag clear, otherwise the C
26796               * flag gets set to indicate failure and the Y-th LSO entry gets set to 0.
26797               *
26798               * ------------------------------------------------------------------------------
26799               *
26800               * Arguments:
26801               *
26802               * A                   The half-length of the line
26803               *
26804               * YY(1 0)             The centre x-coordinate
26805               *
26806               * ------------------------------------------------------------------------------
26807               *
26808               * Returns:
26809               *
26810               * C flag              Clear if the line fits on-screen, set if it doesn't
26811               *
26812               * X1, X2              The x-coordinates of the clipped line
26813               *
26814               * LSO+Y               If the line doesn't fit, LSO+Y is set to 0
26815               *
26816               * Y                   Y is preserved
26817               *
26818               * ******************************************************************************
26819               
26820               EDGES:
26821 79A6 D800  30        movb ra,@T                      ; STA T             ; Set T to the line's half-length in argument A
     79A8 00D1     
26822               
26823                      .clc                            ; CLC               ; We now calculate:
     **** ****     > CLC
0001 79AA 0A13  18        sla  rzero,1
                   < elite.a99
26824                      .adc @YY,ra                     ; ADC YY            ;
     **** ****     > ADC
0001 79AC 1701  14        jnc  !
0002 79AE B004  18        ab   rone,ra
0003               !:
0004 79B0 B020  30        ab   @YY,ra
     79B2 0026     
                   < elite.a99
26825 79B4 D800  30        movb ra,@X2                     ; STA X2            ; (A X2) = YY(1 0) + A
     79B6 0033     
26826                                                                          ;
26827                                                                          ; to set X2 to the x-coordinate of the right end of the
26828                                                                          ; line, starting with the low bytes
26829               
26830 79B8 D020  30        movb @YY+1,ra                   ; LDA YY+1          ; And then adding the high bytes
     79BA 0027     
26831                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 79BC 1701  14        jnc  !
0002 79BE B004  18        ab   rone,ra
0003               !:
0004 79C0 0220  22        ai   ra,(>00*256)
     79C2 0000     
                   < elite.a99
26832               
26833 79C4 1120  14        jlt  ED1                        ; BMI ED1           ; If the addition is negative then the calculation has
26834                                                                          ; overflowed, so jump to ED1 to return a failure
26835               
26836 79C6 1304  14        jeq  B80                        ; BEQ B80           ; If the high byte A from the result is 0, skip the
26837                                                                          ; next two instructions, as the result already fits on
26838                                                                          ; the screen
26839               
26840 79C8 0200  20        li   ra,>fe*256                 ; LDA #254          ; The high byte is positive and non-zero, so we went
     79CA FE00     
26841 79CC D800  30        movb ra,@X2                     ; STA X2            ; past the right edge of the screen, so clip X2 to the
     79CE 0033     
26842                                                                          ; x-coordinate of the right edge of the screen
26843               
26844               B80:
26845 79D0 D020  30        movb @YY,ra                     ; LDA YY            ; We now calculate:
     79D2 0026     
26846                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 79D4 0A15  18        sla  rmone,1
                   < elite.a99
26847                      .sbc @T,ra                      ; SBC T             ; (A X1) = YY(1 0) - argument A
     **** ****     > SBC
0001 79D6 1801  14        joc  !
0002 79D8 7004  18        sb   rone,ra
0003               !:
0004 79DA 7020  30        sb   @T,ra
     79DC 00D1     
                   < elite.a99
26848 79DE D800  30        movb ra,@X1                     ; STA X1            ;
     79E0 0031     
26849                                                                          ; to set X1 to the x-coordinate of the left end of the
26850                                                                          ; line, starting with the low bytes
26851               
26852 79E2 D020  30        movb @YY+1,ra                   ; LDA YY+1          ; And then subtracting the high bytes
     79E4 0027     
26853                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 79E6 1801  14        joc  !
0002 79E8 7004  18        sb   rone,ra
0003               !:
0004 79EA 0220  22        ai   ra,-(>00*256)
     79EC 0000     
                   < elite.a99
26854               
26855 79EE 1603  14        jne  ED3                        ; BNE ED3           ; If the high byte subtraction is non-zero, then skip
26856                                                                          ; to ED3
26857               
26858                      .clc                            ; CLC               ; Otherwise the high byte of the subtraction was zero,
     **** ****     > CLC
0001 79F0 0A13  18        sla  rzero,1
                   < elite.a99
26859                                                                          ; so the line fits on-screen and we clear the C flag to
26860                                                                          ; indicate success
26861               
26862 79F2 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     79F4 800E     
26863               
26864               ED3:
26865 79F6 1507  14        jgt  ED1                        ; BPL ED1           ; If the addition is positive then the calculation has
26866                                                                          ; underflowed, so jump to ED1 to return a failure
26867               
26868 79F8 0200  20        li   ra,>02*256                 ; LDA #2            ; The high byte is negative and non-zero, so we went
     79FA 0200     
26869 79FC D800  30        movb ra,@X1                     ; STA X1            ; past the left edge of the screen, so clip X1 to the
     79FE 0031     
26870                                                                          ; x-coordinate of the left edge of the screen
26871               
26872                      .clc                            ; CLC               ; The line does fit on-screen, so clear the C flag to
     **** ****     > CLC
0001 7A00 0A13  18        sla  rzero,1
                   < elite.a99
26873                                                                          ; indicate success
26874               
26875 7A02 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7A04 800E     
26876               
26877               ED1:
26878 7A06 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the Y-th byte of the LSO block to 0
     7A08 0000     
26879 7A0A D880  38        movb ra,@LSO(ry)                ; STA LSO,Y
     7A0C 0D66     
26880               
26881                      .sec                            ; SEC               ; The line does not fit on the screen, so set the C flag
     **** ****     > SEC
0001 7A0E 0A15  18        sla  rmone,1
                   < elite.a99
26882                                                                          ; to indicate this result
26883               
26884 7A10 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7A12 800E     
26885               
26886               * ******************************************************************************
26887               *
26888               * Name: CHKON
26889               * Type: Subroutine
26890               * Category: Drawing circles
26891               * Summary: Check whether any part of a circle appears on the extended screen
26892               *
26893               * ------------------------------------------------------------------------------
26894               *
26895               * Arguments:
26896               *
26897               * K                   The circle's radius
26898               *
26899               * K3(1 0)             Pixel x-coordinate of the centre of the circle
26900               *
26901               * K4(1 0)             Pixel y-coordinate of the centre of the circle
26902               *
26903               * ------------------------------------------------------------------------------
26904               *
26905               * Returns:
26906               *
26907               * C flag              Clear if any part of the circle appears on-screen, set
26908               * if none of the circle appears on-screen
26909               *
26910               * (A X)               Minimum y-coordinate of the circle on-screen (i.e. the
26911               * y-coordinate of the top edge of the circle)
26912               *
26913               * P(2 1)              Maximum y-coordinate of the circle on-screen (i.e. the
26914               * y-coordinate of the bottom edge of the circle)
26915               *
26916               * ******************************************************************************
26917               
26918               CHKON:
26919 7A14 D020  30        movb @K3,ra                     ; LDA K3            ; Set A = K3 + K
     7A16 00D2     
26920                      .clc                            ; CLC
     **** ****     > CLC
0001 7A18 0A13  18        sla  rzero,1
                   < elite.a99
26921                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 7A1A 1701  14        jnc  !
0002 7A1C B004  18        ab   rone,ra
0003               !:
0004 7A1E B020  30        ab   @K,ra
     7A20 003D     
                   < elite.a99
26922               
26923 7A22 D020  30        movb @K3+1,ra                   ; LDA K3+1          ; Set A = K3+1 + 0 + any carry from above, so this
     7A24 00D3     
26924                      .adi (>00*256)                  ; ADC #0            ; effectively sets A to the high byte of K3(1 0) + K:
     **** ****     > ADI
0001 7A26 1701  14        jnc  !
0002 7A28 B004  18        ab   rone,ra
0003               !:
0004 7A2A 0220  22        ai   ra,(>00*256)
     7A2C 0000     
                   < elite.a99
26925                                                                          ;
26926                                                                          ; (A ?) = K3(1 0) + K
26927                                                                          ;
26928                                                                          ; so A is the high byte of the x-coordinate of the right
26929                                                                          ; edge of the circle
26930               
26931 7A2E 1135  14        jlt  PL21                       ; BMI PL21          ; If A is negative then the right edge of the circle is
26932                                                                          ; to the left of the screen, so jump to PL21 to set the
26933                                                                          ; C flag and return from the subroutine, as the whole
26934                                                                          ; circle is off-screen to the left
26935               
26936 7A30 D020  30        movb @K3,ra                     ; LDA K3            ; Set A = K3 - K
     7A32 00D2     
26937                      .sec                            ; SEC
     **** ****     > SEC
0001 7A34 0A15  18        sla  rmone,1
                   < elite.a99
26938                      .sbc @K,ra                      ; SBC K
     **** ****     > SBC
0001 7A36 1801  14        joc  !
0002 7A38 7004  18        sb   rone,ra
0003               !:
0004 7A3A 7020  30        sb   @K,ra
     7A3C 003D     
                   < elite.a99
26939               
26940 7A3E D020  30        movb @K3+1,ra                   ; LDA K3+1          ; Set A = K3+1 - 0 - any carry from above, so this
     7A40 00D3     
26941                      .sbi (>00*256)                  ; SBC #0            ; effectively sets A to the high byte of K3(1 0) - K:
     **** ****     > SBI
0001 7A42 1801  14        joc  !
0002 7A44 7004  18        sb   rone,ra
0003               !:
0004 7A46 0220  22        ai   ra,-(>00*256)
     7A48 0000     
                   < elite.a99
26942                                                                          ;
26943                                                                          ; (A ?) = K3(1 0) - K
26944                                                                          ;
26945                                                                          ; so A is the high byte of the x-coordinate of the left
26946                                                                          ; edge of the circle
26947               
26948 7A4A 1101  14        jlt  PL31                       ; BMI PL31          ; If A is negative then the left edge of the circle is
26949                                                                          ; to the left of the screen, and we already know the
26950                                                                          ; right edge is either on-screen or off-screen to the
26951                                                                          ; right, so skip to PL31 to move on to the y-coordinate
26952                                                                          ; checks, as at least part of the circle is on-screen in
26953                                                                          ; terms of the x-axis
26954               
26955 7A4C 1626  14        jne  PL21                       ; BNE PL21          ; If A is non-zero, then the left edge of the circle is
26956                                                                          ; to the right of the screen, so jump to PL21 to set the
26957                                                                          ; C flag and return from the subroutine, as the whole
26958                                                                          ; circle is off-screen to the right
26959               
26960               PL31:
26961 7A4E D020  30        movb @K4,ra                     ; LDA K4            ; Set P+1 = K4 + K
     7A50 00E0     
26962                      .clc                            ; CLC
     **** ****     > CLC
0001 7A52 0A13  18        sla  rzero,1
                   < elite.a99
26963                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 7A54 1701  14        jnc  !
0002 7A56 B004  18        ab   rone,ra
0003               !:
0004 7A58 B020  30        ab   @K,ra
     7A5A 003D     
                   < elite.a99
26964 7A5C D800  30        movb ra,@P+1                    ; STA P+1
     7A5E 001C     
26965               
26966 7A60 D020  30        movb @K4+1,ra                   ; LDA K4+1          ; Set A = K4+1 + 0 + any carry from above, so this
     7A62 00E1     
26967                      .adi (>00*256)                  ; ADC #0            ; does the following:
     **** ****     > ADI
0001 7A64 1701  14        jnc  !
0002 7A66 B004  18        ab   rone,ra
0003               !:
0004 7A68 0220  22        ai   ra,(>00*256)
     7A6A 0000     
                   < elite.a99
26968                                                                          ;
26969                                                                          ; (A P+1) = K4(1 0) + K
26970                                                                          ;
26971                                                                          ; so A is the high byte of the y-coordinate of the
26972                                                                          ; bottom edge of the circle
26973               
26974 7A6C 1116  14        jlt  PL21                       ; BMI PL21          ; If A is negative then the bottom edge of the circle is
26975                                                                          ; above the top of the screen, so jump to PL21 to set
26976                                                                          ; the C flag and return from the subroutine, as the
26977                                                                          ; whole circle is off-screen to the top
26978               
26979 7A6E D800  30        movb ra,@P+2                    ; STA P+2           ; Store the high byte in P+2, so now we have:
     7A70 001D     
26980                                                                          ;
26981                                                                          ; P(2 1) = K4(1 0) + K
26982                                                                          ;
26983                                                                          ; i.e. the maximum y-coordinate of the circle on-screen
26984                                                                          ; (which we return)
26985               
26986 7A72 D020  30        movb @K4,ra                     ; LDA K4            ; Set X = K4 - K
     7A74 00E0     
26987                      .sec                            ; SEC
     **** ****     > SEC
0001 7A76 0A15  18        sla  rmone,1
                   < elite.a99
26988                      .sbc @K,ra                      ; SBC K
     **** ****     > SBC
0001 7A78 1801  14        joc  !
0002 7A7A 7004  18        sb   rone,ra
0003               !:
0004 7A7C 7020  30        sb   @K,ra
     7A7E 003D     
                   < elite.a99
26989 7A80 D040  18        movb ra,rx                      ; TAX
26990               
26991 7A82 D020  30        movb @K4+1,ra                   ; LDA K4+1          ; Set A = K4+1 - 0 - any carry from above, so this
     7A84 00E1     
26992                      .sbi (>00*256)                  ; SBC #0            ; does the following:
     **** ****     > SBI
0001 7A86 1801  14        joc  !
0002 7A88 7004  18        sb   rone,ra
0003               !:
0004 7A8A 0220  22        ai   ra,-(>00*256)
     7A8C 0000     
                   < elite.a99
26993                                                                          ;
26994                                                                          ; (A X) = K4(1 0) - K
26995                                                                          ;
26996                                                                          ; so A is the high byte of the y-coordinate of the top
26997                                                                          ; edge of the circle
26998               
26999 7A8E 1179  14        jlt  PL44                       ; BMI PL44          ; If A is negative then the top edge of the circle is
27000                                                                          ; above the top of the screen, and we already know the
27001                                                                          ; bottom edge is either on-screen or below the bottom
27002                                                                          ; of the screen, so skip to PL44 to clear the C flag and
27003                                                                          ; return from the subroutine using a tail call, as part
27004                                                                          ; of the circle definitely appears on-screen
27005               
27006 7A90 1604  14        jne  PL21                       ; BNE PL21          ; If A is non-zero, then the top edge of the circle is
27007                                                                          ; below the bottom of the screen, so jump to PL21 to set
27008                                                                          ; the C flag and return from the subroutine, as the
27009                                                                          ; whole circle is off-screen to the bottom
27010               
27011 7A92 0281  22        ci   rx,(2*Y-1)*256             ; CPX #2*Y-1        ; If we get here then A is zero, which means the top
     7A94 BF00     
27012                                                                          ; edge of the circle is within the screen boundary, so
27013                                                                          ; now we need to check whether it is in the space view
27014                                                                          ; (in which case it is on-screen) or the dashboard (in
27015                                                                          ; which case the top of the circle is hidden by the
27016                                                                          ; dashboard, so the circle isn't on-screen). We do this
27017                                                                          ; by checking the low byte of the result in X against
27018                                                                          ; 2 * #Y - 1, and returning the C flag from this
27019                                                                          ; comparison. The constant #Y is the y-coordinate of the
27020                                                                          ; mid-point of the space view, so 2 * #Y - 1, the
27021                                                                          ; y-coordinate of the bottom pixel row of the space
27022                                                                          ; view. So this does the following:
27023                                                                          ;
27024                                                                          ; * The C flag is set if coordinate (A X) is below the
27025                                                                          ; bottom row of the space view, i.e. the top edge of
27026                                                                          ; the circle is hidden by the dashboard
27027                                                                          ;
27028                                                                          ; * The C flag is clear if coordinate (A X) is above
27029                                                                          ; the bottom row of the space view, i.e. the top
27030                                                                          ; edge of the circle is on-screen
27031               
27032 7A96 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7A98 800E     
27033               
27034               * ******************************************************************************
27035               *
27036               * Name: PL21
27037               * Type: Subroutine
27038               * Category: Drawing planets
27039               * Summary: Return from a planet/sun-drawing routine with a failure flag
27040               *
27041               * ------------------------------------------------------------------------------
27042               *
27043               * Set the C flag and return from the subroutine. This is used to return from a
27044               * planet- or sun-drawing routine with the C flag indicating an overflow in the
27045               * calculation.
27046               *
27047               * ******************************************************************************
27048               
27049               PL21:
27050                      .sec                            ; SEC               ; Set the C flag to indicate an overflow
     **** ****     > SEC
0001 7A9A 0A15  18        sla  rmone,1
                   < elite.a99
27051               
27052 7A9C 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7A9E 800E     
27053               
27054               * ******************************************************************************
27055               *
27056               * Name: PLS3
27057               * Type: Subroutine
27058               * Category: Drawing planets
27059               * Summary: Calculate (Y A P) = 222 * roofv_x / z
27060               *
27061               * ------------------------------------------------------------------------------
27062               *
27063               * Calculate the following, with X determining the vector to use:
27064               *
27065               * (Y A P) = 222 * roofv_x / z
27066               *
27067               * though in reality only (Y A) is used.
27068               *
27069               * Although the code below supports a range of values of X, in practice the
27070               * routine is only called with X = 15, and then again after X has been
27071               * incremented to 17. So the values calculated by PLS1 use roofv_x first, then
27072               * roofv_y. The comments below refer to roofv_x, for the first call.
27073               *
27074               * ------------------------------------------------------------------------------
27075               *
27076               * Arguments:
27077               *
27078               * X                   Determines which of the INWK orientation vectors to
27079               * divide:
27080               *
27081               * * X = 15: divides roofv_x
27082               *
27083               * * X = 17: divides roofv_y
27084               *
27085               * ------------------------------------------------------------------------------
27086               *
27087               * Returns:
27088               *
27089               * X                   X gets incremented by 2 so it points to the next
27090               * coordinate in this orientation vector (so consecutive
27091               * calls to the routine will start with x, then move onto y
27092               * and then z)
27093               *
27094               * ******************************************************************************
27095               
27096               PLS3:
27097 7AA0 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     7AA2 73A0     
27098 7AA4 06A0  28        bl   @jsr                       ;
     7AA6 8002     
27099 7AA8 D800  30        movb ra,@P                      ; STA P             ;
     7AAA 001B     
27100                                                                          ; P = |roofv_x / z|
27101                                                                          ; K+3 = sign of roofv_x / z
27102                                                                          ;
27103                                                                          ; and increment X to point to roofv_y for the next call
27104               
27105 7AAC 0200  20        li   ra,>de*256                 ; LDA #222          ; Set Q = 222, the offset to the crater
     7AAE DE00     
27106 7AB0 D800  30        movb ra,@Q                      ; STA Q
     7AB2 0090     
27107               
27108 7AB4 D801  30        movb rx,@U                      ; STX U             ; Store the vector index X in U for retrieval after the
     7AB6 008F     
27109                                                                          ; call to MULTU
27110               
27111 7AB8 0206  20        li   rtmp,MULTU                 ; JSR MULTU         ; Call MULTU to calculate
     7ABA 42DE     
27112 7ABC 06A0  28        bl   @jsr                       ;
     7ABE 8002     
27113                                                                          ;
27114                                                                          ; (A P) = P * Q
27115                                                                          ; = 222 * |roofv_x / z|
27116               
27117 7AC0 D060  30        movb @U,rx                      ; LDX U             ; Restore the vector index from U into X
     7AC2 008F     
27118               
27119 7AC4 D0A0  30        movb @K+3,ry                    ; LDY K+3           ; If the sign of the result in K+3 is positive, skip to
     7AC6 0040     
27120 7AC8 150D  14        jgt  PL12                       ; BPL PL12          ; PL12 to return with Y = 0
27121               
27122                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise the result should be negative, so negate the
     **** ****     > EOI
0001 7ACA 0206  20        li   rtmp,(>FF*256)
     7ACC FF00     
0002 7ACE 2806  18        xor  rtmp,ra
                   < elite.a99
27123                      .clc                            ; CLC               ; high byte of the result using two's complement with
     **** ****     > CLC
0001 7AD0 0A13  18        sla  rzero,1
                   < elite.a99
27124                      .adi (>01*256)                  ; ADC #1            ; A = ~A + 1
     **** ****     > ADI
0001 7AD2 1701  14        jnc  !
0002 7AD4 B004  18        ab   rone,ra
0003               !:
0004 7AD6 0220  22        ai   ra,(>01*256)
     7AD8 0100     
                   < elite.a99
27125               
27126 7ADA 1304  14        jeq  PL12                       ; BEQ PL12          ; If A = 0, jump to PL12 to return with (Y A) = 0
27127               
27128 7ADC 0202  20        li   ry,>ff*256                 ; LDY #&FF          ; Set Y = &FF to be a negative high byte
     7ADE FF00     
27129               
27130 7AE0 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7AE2 800E     
27131               
27132               PL12:
27133 7AE4 0202  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0 to be a positive high byte
     7AE6 0000     
27134               
27135 7AE8 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7AEA 800E     
27136               
27137               * ******************************************************************************
27138               *
27139               * Name: PLS4
27140               * Type: Subroutine
27141               * Category: Drawing planets
27142               * Summary: Calculate CNT2 = arctan(P / A) / 4
27143               *
27144               * ------------------------------------------------------------------------------
27145               *
27146               * Calculate the following:
27147               *
27148               * CNT2 = arctan(P / A) / 4
27149               *
27150               * and do the following if nosev_z_hi >= 0:
27151               *
27152               * CNT2 = CNT2 + 32
27153               *
27154               * which is the equivalent of adding 180 degrees to the result (or PI radians),
27155               * as there are 64 segments in a full circle.
27156               *
27157               * This routine is called with the following arguments when calculating the
27158               * equator and meridian for planets:
27159               *
27160               * * A = roofv_z_hi, P = -nosev_z_hi
27161               *
27162               * * A = sidev_z_hi, P = -nosev_z_hi
27163               *
27164               * So it calculates the angle between the planet's orientation vectors, in the
27165               * z-axis.
27166               *
27167               * ******************************************************************************
27168               
27169               PLS4:
27170 7AEC D800  30        movb ra,@Q                      ; STA Q             ; Set Q = A
     7AEE 0090     
27171               
27172 7AF0 0206  20        li   rtmp,ARCTAN                ; JSR ARCTAN        ; Call ARCTAN to calculate:
     7AF2 4776     
27173 7AF4 06A0  28        bl   @jsr                       ;
     7AF6 8002     
27174                                                                          ;
27175                                                                          ; A = arctan(P / Q)
27176                                                                          ; arctan(P / A)
27177                                                                          ;
27178                                                                          ; The result in A will be in the range 0 to 128, which
27179                                                                          ; represents an angle of 0 to 180 degrees (or 0 to PI
27180                                                                          ; radians)
27181               
27182 7AF8 D060  30        movb @INWK+14,rx                ; LDX INWK+14       ; If nosev_z_hi is negative, skip the following
     7AFA 0061     
27183 7AFC 1103  14        jlt  B81                        ; BMI B81           ; instruction to leave the angle in A as a positive
27184                                                                          ; integer in the range 0 to 128 (so when we calculate
27185                                                                          ; CNT2 below, it will be in the right half of the
27186                                                                          ; anti-clockwise arc that we describe when drawing
27187                                                                          ; circles, i.e. from 6 o'clock, through 3 o'clock and
27188                                                                          ; on to 12 o'clock)
27189               
27190                      .eoi (>80*256)                  ; EOR #%10000000    ; If we get here then nosev_z_hi is positive, so flip
     **** ****     > EOI
0001 7AFE 0206  20        li   rtmp,(>80*256)
     7B00 8000     
0002 7B02 2806  18        xor  rtmp,ra
                   < elite.a99
27191                                                                          ; bit 7 of the angle in A, which is the same as adding
27192                                                                          ; 128 to give a result in the range 129 to 256 (i.e. 129
27193                                                                          ; to 0), or 180 to 360 degrees (so when we calculate
27194                                                                          ; CNT2 below, it will be in the left half of the
27195                                                                          ; anti-clockwise arc that we describe when drawing
27196                                                                          ; circles, i.e. from 12 o'clock, through 9 o'clock and
27197                                                                          ; on to 6 o'clock)
27198               
27199               B81:
27200 7B04 0910  18        srl  ra,1                       ; LSR A             ; Set CNT2 = A / 4
27201 7B06 0910  18        srl  ra,1                       ; LSR A
27202 7B08 D800  30        movb ra,@CNT2                   ; STA CNT2
     7B0A 00A5     
27203               
27204 7B0C 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7B0E 800E     
27205               
27206               * ******************************************************************************
27207               *
27208               * Name: PLS5
27209               * Type: Subroutine
27210               * Category: Drawing planets
27211               * Summary: Calculate roofv_x / z and roofv_y / z
27212               *
27213               * ------------------------------------------------------------------------------
27214               *
27215               * Calculate the following divisions of a specified value from one of the
27216               * orientation vectors (in this example, roofv):
27217               *
27218               * (XX16+2 K2+2) = roofv_x / z
27219               *
27220               * (XX16+3 K2+3) = roofv_y / z
27221               *
27222               * ------------------------------------------------------------------------------
27223               *
27224               * Arguments:
27225               *
27226               * X                   Determines which of the INWK orientation vectors to
27227               * divide:
27228               *
27229               * * X = 15: divides roofv_x and roofv_y
27230               *
27231               * * X = 21: divides sidev_x and sidev_y
27232               *
27233               * INWK                The planet's ship data block
27234               *
27235               * ******************************************************************************
27236               
27237               PLS5:
27238 7B10 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     7B12 73A0     
27239 7B14 06A0  28        bl   @jsr                       ;
     7B16 8002     
27240 7B18 D800  30        movb ra,@K2+2                   ; STA K2+2          ;
     7B1A 00AE     
27241 7B1C D802  30        movb ry,@XX16+2                 ; STY XX16+2        ; K+2    = |roofv_x / z|
     7B1E 000B     
27242                                                                          ; XX16+2 = sign of roofv_x / z
27243                                                                          ;
27244                                                                          ; i.e. (XX16+2 K2+2) = roofv_x / z
27245                                                                          ;
27246                                                                          ; and increment X to point to roofv_y for the next call
27247               
27248 7B20 0206  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     7B22 73A0     
27249 7B24 06A0  28        bl   @jsr                       ;
     7B26 8002     
27250 7B28 D800  30        movb ra,@K2+3                   ; STA K2+3          ;
     7B2A 00AF     
27251 7B2C D802  30        movb ry,@XX16+3                 ; STY XX16+3        ; K+3    = |roofv_y / z|
     7B2E 000C     
27252                                                                          ; XX16+3 = sign of roofv_y / z
27253                                                                          ;
27254                                                                          ; i.e. (XX16+3 K2+3) = roofv_y / z
27255                                                                          ;
27256                                                                          ; and increment X to point to roofv_z for the next call
27257               
27258 7B30 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7B32 800E     
27259               
27260               * ******************************************************************************
27261               *
27262               * Name: PLS6
27263               * Type: Subroutine
27264               * Category: Drawing planets
27265               * Summary: Calculate (X K) = (A P+1 P) / (z_sign z_hi z_lo)
27266               *
27267               * ------------------------------------------------------------------------------
27268               *
27269               * Calculate the following:
27270               *
27271               * (X K) = (A P+1 P) / (z_sign z_hi z_lo)
27272               *
27273               * returning an overflow in the C flag if the result is >= 1024.
27274               *
27275               * ------------------------------------------------------------------------------
27276               *
27277               * Arguments:
27278               *
27279               * INWK                The planet or sun's ship data block
27280               *
27281               * ------------------------------------------------------------------------------
27282               *
27283               * Returns:
27284               *
27285               * C flag              Set if the result >= 1024, clear otherwise
27286               *
27287               * ------------------------------------------------------------------------------
27288               *
27289               * Other entry points:
27290               *
27291               * PL44                Clear the C flag and return from the subroutine
27292               *
27293               * ******************************************************************************
27294               
27295               PLS6:
27296 7B34 0206  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     7B36 45E8     
27297 7B38 06A0  28        bl   @jsr                       ;
     7B3A 8002     
27298                                                                          ;
27299                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
27300               
27301 7B3C D020  30        movb @K+3,ra                    ; LDA K+3           ; Set A = |K+3| OR K+2
     7B3E 0040     
27302 7B40 0240  22        andi ra,>7f*256                 ; AND #%01111111
     7B42 7F00     
27303 7B44 F020  30        socb @K+2,ra                    ; ORA K+2
     7B46 003F     
27304               
27305 7B48 16A8  14        jne  PL21                       ; BNE PL21          ; If A is non-zero then the two high bytes of K(3 2 1 0)
27306                                                                          ; are non-zero, so jump to PL21 to set the C flag and
27307                                                                          ; return from the subroutine
27308               
27309                                                                          ; We can now just consider K(1 0), as we know the top
27310                                                                          ; two bytes of K(3 2 1 0) are both 0
27311               
27312 7B4A D060  30        movb @K+1,rx                    ; LDX K+1           ; Set X = K+1, so now (X K) contains the result in
     7B4C 003E     
27313                                                                          ; K(1 0), which is the format we want to return the
27314                                                                          ; result in
27315               
27316 7B4E 0281  22        ci   rx,>04*256                 ; CPX #4            ; If the high byte of K(1 0) >= 4 then the result is
     7B50 0400     
27317 7B52 1818  14        joc  PL6                        ; BCS PL6           ; >= 1024, so return from the subroutine with the C flag
27318                                                                          ; set to indicate an overflow (as PL6 contains an RTS)
27319               
27320 7B54 D020  30        movb @K+3,ra                    ; LDA K+3           ; Fetch the sign of the result from K+3 (which we know
     7B56 0040     
27321                                                                          ; has zeroes in bits 0-6, so this just fetches the sign)
27322               
27323               * CLC                    \ This instruction is commented out in the original
27324                                                                          ; source. It would have no effect as we know the C flag
27325                                                                          ; is already clear, as we skipped past the BCS above
27326               
27327 7B58 1515  14        jgt  PL6                        ; BPL PL6           ; If the sign bit is clear and the result is positive,
27328                                                                          ; then the result is already correct, so return from
27329                                                                          ; the subroutine with the C flag clear to indicate
27330                                                                          ; success (as PL6 contains an RTS)
27331               
27332 7B5A D020  30        movb @K,ra                      ; LDA K             ; Otherwise we need to negate the result, which we do
     7B5C 003D     
27333                      .eoi (>ff*256)                  ; EOR #%11111111    ; using two's complement, starting with the low byte:
     **** ****     > EOI
0001 7B5E 0206  20        li   rtmp,(>FF*256)
     7B60 FF00     
0002 7B62 2806  18        xor  rtmp,ra
                   < elite.a99
27334                      .adi (>01*256)                  ; ADC #1            ;
     **** ****     > ADI
0001 7B64 1701  14        jnc  !
0002 7B66 B004  18        ab   rone,ra
0003               !:
0004 7B68 0220  22        ai   ra,(>01*256)
     7B6A 0100     
                   < elite.a99
27335 7B6C D800  30        movb ra,@K                      ; STA K             ; K = ~K + 1
     7B6E 003D     
27336               
27337 7B70 D001  18        movb rx,ra                      ; TXA               ; And then the high byte:
27338                      .eoi (>ff*256)                  ; EOR #%11111111    ;
     **** ****     > EOI
0001 7B72 0206  20        li   rtmp,(>FF*256)
     7B74 FF00     
0002 7B76 2806  18        xor  rtmp,ra
                   < elite.a99
27339                      .adi (>00*256)                  ; ADC #0            ; X = ~X
     **** ****     > ADI
0001 7B78 1701  14        jnc  !
0002 7B7A B004  18        ab   rone,ra
0003               !:
0004 7B7C 0220  22        ai   ra,(>00*256)
     7B7E 0000     
                   < elite.a99
27340 7B80 D040  18        movb ra,rx                      ; TAX
27341               
27342               PL44:
27343                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 7B82 0A13  18        sla  rzero,1
                   < elite.a99
27344               
27345               PL6:
27346 7B84 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7B86 800E     
27347               
27348               * ******************************************************************************
27349               *
27350               * Name: TT17
27351               * Type: Subroutine
27352               * Category: Keyboard
27353               * Summary: Scan the keyboard for cursor key or joystick movement
27354               *
27355               * ------------------------------------------------------------------------------
27356               *
27357               * Scan the keyboard and joystick for cursor key or stick movement, and return
27358               * the result as deltas (changes) in x- and y-coordinates as follows:
27359               *
27360               * * For joystick, X and Y are integers between -2 and +2 depending on how far
27361               * the stick has moved
27362               *
27363               * * For keyboard, X and Y are integers between -1 and +1 depending on which
27364               * keys are pressed
27365               *
27366               * ------------------------------------------------------------------------------
27367               *
27368               * Returns:
27369               *
27370               * A                   The key pressed, if the arrow keys were used
27371               *
27372               * X                   Change in the x-coordinate according to the cursor keys
27373               * being pressed or joystick movement, as an integer (see
27374               * above)
27375               *
27376               * Y                   Change in the y-coordinate according to the cursor keys
27377               * being pressed or joystick movement, as an integer (see
27378               * above)
27379               *
27380               * ******************************************************************************
27381               
27382               TT17:
27383 7B88 0206  20        li   rtmp,DOKEY                 ; JSR DOKEY         ; Scan the keyboard for flight controls and pause keys,
     7B8A 8CFE     
27384 7B8C 06A0  28        bl   @jsr                       ;
     7B8E 8002     
27385                                                                          ; (or the equivalent on joystick) and update the key
27386                                                                          ; logger, setting KL to the key pressed
27387               
27388 7B90 D020  30        movb @JSTK,ra                   ; LDA JSTK          ; If the joystick is not configured, jump down to TJ1,
     7B92 0F50     
27389 7B94 132D  14        jeq  TJ1                        ; BEQ TJ1           ; otherwise we move the cursor with the joystick
27390               
27391 7B96 D020  30        movb @JSTX,ra                   ; LDA JSTX          ; Fetch the joystick roll, ranging from 1 to 255 with
     7B98 009C     
27392                                                                          ; 128 as the centre point
27393               
27394                      .eoi (>ff*256)                  ; EOR #&FF          ; Flip the sign so A = -JSTX, because the joystick roll
     **** ****     > EOI
0001 7B9A 0206  20        li   rtmp,(>FF*256)
     7B9C FF00     
0002 7B9E 2806  18        xor  rtmp,ra
                   < elite.a99
27395                                                                          ; works in the opposite way to moving a cursor on-screen
27396                                                                          ; in terms of left and right
27397               
27398 7BA0 0206  20        li   rtmp,TJS1                  ; JSR TJS1          ; Call TJS1 just below to set A to a value between -2
     7BA2 7BB0     
27399 7BA4 06A0  28        bl   @jsr                       ;
     7BA6 8002     
27400                                                                          ; and +2 depending on the joystick roll value (moving
27401                                                                          ; the stick sideways)
27402               
27403 7BA8 D002  18        movb ry,ra                      ; TYA               ; Copy Y to A
27404               
27405 7BAA D040  18        movb ra,rx                      ; TAX               ; Copy A to X, so X contains the joystick roll value
27406               
27407 7BAC D020  30        movb @JSTY,ra                   ; LDA JSTY          ; Fetch the joystick pitch, ranging from 1 to 255 with
     7BAE 009D     
27408                                                                          ; 128 as the centre point, and fall through into TJS1 to
27409                                                                          ; set Y to the joystick pitch value (moving the stick up
27410                                                                          ; and down)
27411               
27412               TJS1:
27413 7BB0 D080  18        movb ra,ry                      ; TAY               ; Store A in Y
27414               
27415 7BB2 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the result, A = 0
     7BB4 0000     
27416               
27417 7BB6 0282  22        ci   ry,>10*256                 ; CPY #16           ; If Y >= 16 set the C flag, so A = A - 1
     7BB8 1000     
27418                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 7BBA 1801  14        joc  !
0002 7BBC 7004  18        sb   rone,ra
0003               !:
0004 7BBE 0220  22        ai   ra,-(>00*256)
     7BC0 0000     
                   < elite.a99
27419               
27420               * CPY #&20               \ These instructions are commented out in the original
27421               * SBC #0                 \ source, but they would make the joystick move the
27422                                                                          ; cursor faster by increasing the range of Y by -1 to +1
27423               
27424 7BC2 0282  22        ci   ry,>40*256                 ; CPY #64           ; If Y >= 64 set the C flag, so A = A - 1
     7BC4 4000     
27425                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 7BC6 1801  14        joc  !
0002 7BC8 7004  18        sb   rone,ra
0003               !:
0004 7BCA 0220  22        ai   ra,-(>00*256)
     7BCC 0000     
                   < elite.a99
27426               
27427 7BCE 0282  22        ci   ry,>c0*256                 ; CPY #192          ; If Y >= 192 set the C flag, so A = A + 1
     7BD0 C000     
27428                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 7BD2 1701  14        jnc  !
0002 7BD4 B004  18        ab   rone,ra
0003               !:
0004 7BD6 0220  22        ai   ra,(>00*256)
     7BD8 0000     
                   < elite.a99
27429               
27430 7BDA 0282  22        ci   ry,>e0*256                 ; CPY #224          ; If Y >= 224 set the C flag, so A = A + 1
     7BDC E000     
27431                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 7BDE 1701  14        jnc  !
0002 7BE0 B004  18        ab   rone,ra
0003               !:
0004 7BE2 0220  22        ai   ra,(>00*256)
     7BE4 0000     
                   < elite.a99
27432               
27433               * CPY #&F0               \ These instructions are commented out in the original
27434               * ADC #0                 \ source, but they would make the joystick move the
27435                                                                          ; cursor faster by increasing the range of Y by -1 to +1
27436               
27437 7BE6 D080  18        movb ra,ry                      ; TAY               ; Copy the value of A into Y
27438               
27439 7BE8 D020  30        movb @KL,ra                     ; LDA KL            ; Set A to the value of KL (the key pressed)
     7BEA 0041     
27440               
27441 7BEC 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7BEE 800E     
27442               
27443               TJ1:
27444 7BF0 D020  30        movb @KL,ra                     ; LDA KL            ; Set A to the value of KL (the key pressed)
     7BF2 0041     
27445               
27446 7BF4 0201  20        li   rx,>00*256                 ; LDX #0            ; Set the initial values for the results, X = Y = 0,
     7BF6 0000     
27447 7BF8 0202  20        li   ry,>00*256                 ; LDY #0            ; which we now increase or decrease appropriately
     7BFA 0000     
27448               
27449 7BFC 0280  22        ci   ra,>19*256                 ; CMP #&19          ; If left arrow was pressed, set X = X - 1
     7BFE 1900     
27450 7C00 1601  14        jne  B82                        ; BNE B82
27451 7C02 7044  18        sb   rone,rx                    ; DEX
27452               
27453               B82:
27454 7C04 0280  22        ci   ra,>79*256                 ; CMP #&79          ; If right arrow was pressed, set X = X + 1
     7C06 7900     
27455 7C08 1601  14        jne  B83                        ; BNE B83
27456 7C0A B044  18        ab   rone,rx                    ; INX
27457               
27458               B83:
27459 7C0C 0280  22        ci   ra,>39*256                 ; CMP #&39          ; If up arrow was pressed, set Y = Y + 1
     7C0E 3900     
27460 7C10 1601  14        jne  B84                        ; BNE B84
27461 7C12 B084  18        ab   rone,ry                    ; INY
27462               
27463               B84:
27464 7C14 0280  22        ci   ra,>29*256                 ; CMP #&29          ; If down arrow was pressed, set Y = Y - 1
     7C16 2900     
27465 7C18 1601  14        jne  B85                        ; BNE B85
27466 7C1A 7084  18        sb   rone,ry                    ; DEY
27467               
27468               B85:
27469 7C1C 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7C1E 800E     
27470               
27471               * ******************************************************************************
27472               *
27473               * Name: ping
27474               * Type: Subroutine
27475               * Category: Universe
27476               * Summary: Set the selected system to the current system
27477               *
27478               * ******************************************************************************
27479               
27480               ping_:
27481 7C20 0201  20        li   rx,>01*256                 ; LDX #1            ; We want to copy the X- and Y-coordinates of the
     7C22 0100     
27482                                                                          ; current system in (QQ0, QQ1) to the selected system's
27483                                                                          ; coordinates in (QQ9, QQ10), so set up a counter to
27484                                                                          ; copy two bytes
27485               
27486               pl1_:
27487 7C24 D021  34        movb @QQ0(rx),ra                ; LDA QQ0,X         ; Load byte X from the current system in QQ0/QQ1
     7C26 0301     
27488               
27489 7C28 D840  38        movb ra,@QQ9(rx)                ; STA QQ9,X         ; Store byte X in the selected system in QQ9/QQ10
     7C2A 0F31     
27490               
27491 7C2C 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
27492               
27493 7C2E 15FA  14        jgt  pl1_                       ; BPL pl1           ; Loop back for the next byte to copy
27494               
27495 7C30 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7C32 800E     
27496               
27497               * ******************************************************************************
27498               *
27499               * Save ELTE.bin
27500               *
27501               * ******************************************************************************
27502               
27503                      ; PRINT "ELITE E"
27504                      ; PRINT "Assembled at ", ~CODE_E%
27505                      ; PRINT "Ends at ", ~P%
27506                      ; PRINT "Code size is ", ~(P% - CODE_E%)
27507                      ; PRINT "Execute at ", ~LOAD%
27508                      ; PRINT "Reload at ", ~LOAD_E%
27509               
27510                      ; PRINT "S.ELTE ", ~CODE_E%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_E%
27511                      ; SAVE "3-assembled-output/ELTE.bin", CODE_E%, P%, LOAD%
27512               
27513               * ******************************************************************************
27514               *
27515               * ELITE F FILE
27516               *
27517               * Produces the binary file ELTF.bin that gets loaded by elite-bcfs.asm.
27518               *
27519               * ******************************************************************************
27520               
27521               CODE_F.:
27522                      equ $
27523               
27524               LOAD_F.:
27525                      equ LOAD. + $ - CODE.
27526               
27527               * ******************************************************************************
27528               *
27529               * Name: KS3
27530               * Type: Subroutine
27531               * Category: Universe
27532               * Summary: Set the SLSP ship line heap pointer after shuffling ship slots
27533               *
27534               * ------------------------------------------------------------------------------
27535               *
27536               * The final part of the KILLSHP routine, called after we have shuffled the ship
27537               * slots and sorted out our missiles. This simply sets SLSP to the new bottom of
27538               * the ship line heap.
27539               *
27540               * ------------------------------------------------------------------------------
27541               *
27542               * Arguments:
27543               *
27544               * P(1 0)              Points to the ship line heap of the ship in the last
27545               * occupied slot (i.e. it points to the bottom of the
27546               * descending heap)
27547               *
27548               * ******************************************************************************
27549               
27550               KS3:
27551 7C34 D020  30        movb @P,ra                      ; LDA P             ; After shuffling the ship slots, P(1 0) will point to
     7C36 001B     
27552 7C38 D800  30        movb ra,@SLSP                   ; STA SLSP          ; the new bottom of the ship line heap, so store this in
     7C3A 0F1E     
27553 7C3C D020  30        movb @P+1,ra                    ; LDA P+1           ; SLSP(1 0), which stores the bottom of the heap
     7C3E 001C     
27554 7C40 D800  30        movb ra,@SLSP+1                 ; STA SLSP+1
     7C42 0F1F     
27555               
27556 7C44 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7C46 800E     
27557               
27558               * ******************************************************************************
27559               *
27560               * Name: KS1
27561               * Type: Subroutine
27562               * Category: Universe
27563               * Summary: Remove the current ship from our local bubble of universe
27564               *
27565               * ------------------------------------------------------------------------------
27566               *
27567               * Part 12 of the main flight loop calls this routine to remove the ship that is
27568               * currently being analysed by the flight loop. Once the ship is removed, it
27569               * jumps back to MAL1 to rejoin the main flight loop, with X pointing to the
27570               * same slot that we just cleared (and which now contains the next ship in the
27571               * local bubble of universe).
27572               *
27573               * ------------------------------------------------------------------------------
27574               *
27575               * Arguments:
27576               *
27577               * XX0                 The address of the blueprint for this ship
27578               *
27579               * INF                 The address of the data block for this ship
27580               *
27581               * ******************************************************************************
27582               
27583               KS1:
27584 7C48 D060  30        movb @XSAV,rx                   ; LDX XSAV          ; Store the current ship's slot number in XSAV
     7C4A 0093     
27585               
27586 7C4C 0206  20        li   rtmp,KILLSHP               ; JSR KILLSHP       ; Call KILLSHP to remove the ship in slot X from our
     7C4E 7D10     
27587 7C50 06A0  28        bl   @jsr                       ;
     7C52 8002     
27588                                                                          ; local bubble of universe
27589               
27590 7C54 D060  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the current ship's slot number from XSAV,
     7C56 0093     
27591                                                                          ; which now points to the next ship in the bubble
27592               
27593 7C58 0460  24        b    @MAL1                      ; JMP MAL1          ; Jump to MAL1 to rejoin the main flight loop at the
     7C5A 118C     
27594                                                                          ; start of the ship analysis loop
27595               
27596               * ******************************************************************************
27597               *
27598               * Name: KS4
27599               * Type: Subroutine
27600               * Category: Universe
27601               * Summary: Remove the space station and replace it with the sun
27602               *
27603               * ******************************************************************************
27604               
27605               KS4:
27606 7C5C 0206  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     7C5E 7FB4     
27607 7C60 06A0  28        bl   @jsr                       ;
     7C62 8002     
27608               
27609 7C64 0206  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Reset the LSO block, returns with A = 0
     7C66 6C9A     
27610 7C68 06A0  28        bl   @jsr                       ;
     7C6A 8002     
27611               
27612 7C6C D800  30        movb ra,@FRIN+1                 ; STA FRIN+1        ; Set the second slot in the FRIN table to 0, which
     7C6E 0D41     
27613                                                                          ; sets this slot to empty, so when we call NWSHP below
27614                                                                          ; the new sun that gets created will go into FRIN+1
27615               
27616 7C70 D800  30        movb ra,@SSPR                   ; STA SSPR          ; Set the "space station present" flag to 0, as we are
     7C72 0D55     
27617                                                                          ; no longer in the space station's safe zone
27618               
27619 7C74 0206  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Call SPBLB to redraw the space station bulb, which
     7C76 70D6     
27620 7C78 06A0  28        bl   @jsr                       ;
     7C7A 8002     
27621                                                                          ; will erase it from the dashboard
27622               
27623 7C7C 0200  20        li   ra,>06*256                 ; LDA #6            ; Set the sun's y_sign to 6
     7C7E 0600     
27624 7C80 D800  30        movb ra,@INWK+5                 ; STA INWK+5
     7C82 0058     
27625               
27626 7C84 0200  20        li   ra,>81*256                 ; LDA #129          ; Set A = 129, the ship type for the sun
     7C86 8100     
27627               
27628 7C88 0460  28        b    @NWSHP                     ; JMP NWSHP         ; Call NWSHP to set up the sun's data block and add it
     7C8A 6F6E     
27629                                                                          ; to FRIN, where it will get put in the second slot as
27630                                                                          ; we just cleared out the second slot, and the first
27631                                                                          ; slot is already taken by the planet
27632               
27633               * ******************************************************************************
27634               *
27635               * Name: KS2
27636               * Type: Subroutine
27637               * Category: Universe
27638               * Summary: Check the local bubble for missiles with target lock
27639               *
27640               * ------------------------------------------------------------------------------
27641               *
27642               * Check the local bubble of universe to see if there are any missiles with
27643               * target lock in the vicinity. If there are, then check their targets; if we
27644               * just removed their target in the KILLSHP routine, then switch off their AI so
27645               * they just drift in space, otherwise update their targets to reflect the newly
27646               * shuffled slot numbers.
27647               *
27648               * This is called from KILLSHP once the slots have been shuffled down, following
27649               * the removal of a ship.
27650               *
27651               * ------------------------------------------------------------------------------
27652               *
27653               * Arguments:
27654               *
27655               * XX4                 The slot number of the ship we removed just before
27656               * calling this routine
27657               *
27658               * ******************************************************************************
27659               
27660               KS2:
27661 7C8C 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; We want to go through the ships in our local bubble
     7C8E FF00     
27662                                                                          ; and pick out all the missiles, so set X to &FF to
27663                                                                          ; use as a counter
27664               
27665               KSL4:
27666 7C90 B044  18        ab   rone,rx                    ; INX               ; Increment the counter (so it starts at 0 on the first
27667                                                                          ; iteration)
27668               
27669 7C92 D021  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; If slot X is empty then we have worked our way through
     7C94 0D40     
27670 7C96 13CE  14        jeq  KS3                        ; BEQ KS3           ; all the slots, so jump to KS3 to stop looking
27671               
27672 7C98 0280  22        ci   ra,(MSL)*256               ; CMP #MSL          ; If the slot does not contain a missile, loop back to
     7C9A 0900     
27673 7C9C 16F9  14        jne  KSL4                       ; BNE KSL4          ; KSL4 to check the next slot
27674               
27675                                                                          ; We have found a slot containing a missile, so now we
27676                                                                          ; want to check whether it has target lock
27677               
27678 7C9E D001  18        movb rx,ra                      ; TXA               ; Set Y = X * 2 and fetch the Y-th address from UNIV
27679                      .asla                           ; ASL A             ; and store it in SC and SC+1 - in other words, set
     **** ****     > ASLA
0001 7CA0 0240  22        andi ra,>ff00
     7CA2 FF00     
0002 7CA4 0A10  18        sla  ra,1
                   < elite.a99
27680 7CA6 D080  18        movb ra,ry                      ; TAY               ; SC(1 0) to point to the missile's ship data block
27681 7CA8 D022  34        movb @UNIV(ry),ra               ; LDA UNIV,Y
     7CAA 221F     
27682 7CAC D800  30        movb ra,@SC                     ; STA SC
     7CAE 0007     
27683 7CB0 D022  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y
     7CB2 2220     
27684 7CB4 D800  30        movb ra,@SC+1                   ; STA SC+1
     7CB6 0008     
27685               
27686 7CB8 0202  20        li   ry,>20*256                 ; LDY #32           ; Fetch byte #32 from the missile's ship data (AI)
     7CBA 2000     
27687                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y
     **** ****     > LD_IND_Y_IDX
0001 7CBC D820  42        movb @SC,@rtmplb
     7CBE 0007     
     7CC0 830D     
0002 7CC2 D1A0  30        movb @SC+1,rtmp
     7CC4 0008     
0003 7CC6 A182  18        a    ry,rtmp
0004 7CC8 D016  26        movb *rtmp,RA
                   < elite.a99
27688               
27689 7CCA 15E2  14        jgt  KSL4                       ; BPL KSL4          ; If bit 7 of byte #32 is clear, then the missile is
27690                                                                          ; dumb and has no AI, so loop back to KSL4 to move on
27691                                                                          ; to the next slot
27692               
27693 7CCC 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Otherwise this missile has AI, so clear bit 7 and
     7CCE 7F00     
27694 7CD0 0910  18        srl  ra,1                       ; LSR A             ; shift right to set the C flag to the missile's "is
27695                                                                          ; locked" flag, and A to the target's slot number
27696               
27697 7CD2 9020  30        cb   @XX4,ra                    ; CMP XX4           ; If this missile's target is less than XX4, then the
     7CD4 00A7     
27698 7CD6 17DC  14        jnc  KSL4                       ; BCC KSL4          ; target's slot isn't being shuffled down, so jump to
27699                                                                          ; KSL4 to move on to the next slot
27700               
27701 7CD8 1311  14        jeq  KS6                        ; BEQ KS6           ; If this missile was locked onto the ship that we just
27702                                                                          ; removed in KILLSHP, jump to KS6 to stop the missile
27703                                                                          ; from continuing to hunt it down
27704               
27705                      .sbi (>01*256)                  ; SBC #1            ; Otherwise this missile is locked and has AI enabled,
     **** ****     > SBI
0001 7CDA 1801  14        joc  !
0002 7CDC 7004  18        sb   rone,ra
0003               !:
0004 7CDE 0220  22        ai   ra,-(>01*256)
     7CE0 FF00     
                   < elite.a99
27706                                                                          ; and its target will have moved down a slot, so
27707                                                                          ; subtract 1 from the target number (we know C is set
27708                                                                          ; from the BCC above)
27709               
27710                      .asla                           ; ASL A             ; Shift the target number left by 1, so it's in bits
     **** ****     > ASLA
0001 7CE2 0240  22        andi ra,>ff00
     7CE4 FF00     
0002 7CE6 0A10  18        sla  ra,1
                   < elite.a99
27711                                                                          ; 1-6 once again, and also set bit 0 to 1, as the C
27712                                                                          ; flag is still set, so this makes sure the missile is
27713                                                                          ; still set to being locked
27714               
27715 7CE8 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7, so the missile's AI is enabled
     7CEA 8000     
27716               
27717                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Update the missile's AI flag to the value in A
     **** ****     > ST_IND_Y_IDX
0001 7CEC D820  42        movb @SC,@rtmplb
     7CEE 0007     
     7CF0 830D     
0002 7CF2 D1A0  30        movb @SC+1,rtmp
     7CF4 0008     
0003 7CF6 A182  18        a    ry,rtmp
0004 7CF8 D580  30        movb RA,*rtmp
                   < elite.a99
27718               
27719 7CFA 16CA  14        jne  KSL4                       ; BNE KSL4          ; Loop back to KSL4 to move on to the next slot (this
27720                                                                          ; BNE is effectively a JMP as A will never be zero)
27721               
27722               KS6:
27723 7CFC 0200  20        li   ra,>00*256                 ; LDA #0            ; The missile's target lock just got removed, so set the
     7CFE 0000     
27724                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; AI flag to 0 to make it dumb and not locked
     **** ****     > ST_IND_Y_IDX
0001 7D00 D820  42        movb @SC,@rtmplb
     7D02 0007     
     7D04 830D     
0002 7D06 D1A0  30        movb @SC+1,rtmp
     7D08 0008     
0003 7D0A A182  18        a    ry,rtmp
0004 7D0C D580  30        movb RA,*rtmp
                   < elite.a99
27725               
27726 7D0E 13C0  14        jeq  KSL4                       ; BEQ KSL4          ; Loop back to KSL4 to move on to the next slot (this
27727                                                                          ; BEQ is effectively a JMP as A is always zero)
27728               
27729               * ******************************************************************************
27730               *
27731               * Name: KILLSHP
27732               * Type: Subroutine
27733               * Category: Universe
27734               * Summary: Remove a ship from our local bubble of universe
27735               *
27736               * ------------------------------------------------------------------------------
27737               *
27738               * Remove the ship in slot X from our local bubble of universe. This happens
27739               * when we kill a ship, collide with a ship and destroy it, or when a ship moves
27740               * outside our local bubble.
27741               *
27742               * We also use this routine when we move out of range of the space station, in
27743               * which case we replace it with the sun.
27744               *
27745               * When removing a ship, this creates a gap in the ship slots at FRIN, so we
27746               * shuffle all the later slots down to close the gap. We also shuffle the ship
27747               * data blocks at K% and ship line heap at WP, to reclaim all the memory that
27748               * the removed ship used to occupy.
27749               *
27750               * ------------------------------------------------------------------------------
27751               *
27752               * Arguments:
27753               *
27754               * X                   The slot number of the ship to remove
27755               *
27756               * XX0                 The address of the blueprint for the ship to remove
27757               *
27758               * INF                 The address of the data block for the ship to remove
27759               *
27760               * ******************************************************************************
27761               
27762               KILLSHP:
27763 7D10 D801  30        movb rx,@XX4                    ; STX XX4           ; Store the slot number of the ship to remove in XX4
     7D12 00A7     
27764               
27771               
27772 7D14 9060  30        cb   @MSTG,rx                   ; CPX MSTG          ; Check whether this slot matches the slot number in
     7D16 0052     
27773                                                                          ; MSTG, which is the target of our missile lock
27774                                                                          ;
27775                                                                          ; This instructions saves two bytes of memory over the
27776                                                                          ; LDA and CMP-based code in the source disc version, as
27777                                                                          ; CPX MSTG is a two-byte opcode, while LDA MSTG and
27778                                                                          ; CMP XX4 take up four bytes between them (the code does
27779                                                                          ; the same thing)
27780               
27782               
27783 7D18 160C  14        jne  KS5                        ; BNE KS5           ; If our missile is not locked on this ship, jump to KS5
27784               
27785 7D1A 0202  20        li   ry,>ee*256                 ; LDY #&EE          ; Otherwise we need to remove our missile lock, so call
     7D1C EE00     
27786 7D1E 0206  20        li   rtmp,ABORT                 ; JSR ABORT         ; ABORT to disarm the missile and update the missile
     7D20 7096     
27787 7D22 06A0  28        bl   @jsr                       ;
     7D24 8002     
27788                                                                          ; indicators on the dashboard to green/cyan (Y = &EE)
27789               
27790 7D26 0200  20        li   ra,>c8*256                 ; LDA #200          ; Print recursive token 40 ("TARGET LOST") as an
     7D28 C800     
27791 7D2A 0206  20        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     7D2C 8E52     
27792 7D2E 06A0  28        bl   @jsr                       ;
     7D30 8002     
27793               
27794               KS5:
27795 7D32 D0A0  30        movb @XX4,ry                    ; LDY XX4           ; Restore the slot number of the ship to remove into Y
     7D34 00A7     
27796               
27797 7D36 D062  34        movb @FRIN(ry),rx               ; LDX FRIN,Y        ; Fetch the contents of the slot, which contains the
     7D38 0D40     
27798                                                                          ; ship type
27799               
27800 7D3A 0281  22        ci   rx,(SST)*256               ; CPX #SST          ; If this is the space station, then jump to KS4 to
     7D3C 0800     
27801 7D3E 138E  14        jeq  KS4                        ; BEQ KS4           ; replace the space station with the sun
27802               
27803 7D40 7004  18        sb   rone,ra                    ; DEC MANY,X        ; Decrease the number of this type of ship in our little
27804                                                                          ; bubble, which is stored in MANY+X (where X is the ship
27805                                                                          ; type)
27806               
27807 7D42 D060  30        movb @XX4,rx                    ; LDX XX4           ; Restore the slot number of the ship to remove into X
     7D44 00A7     
27808               
27809                                                                          ; We now want to remove this ship and reclaim all the
27810                                                                          ; memory that it uses. Removing the ship will leave a
27811                                                                          ; gap in three places, which we need to close up:
27812                                                                          ;
27813                                                                          ; * The ship slots in FRIN
27814                                                                          ;
27815                                                                          ; * The ship data blocks in K%
27816                                                                          ;
27817                                                                          ; * The descending ship line heap at WP down
27818                                                                          ;
27819                                                                          ; The rest of this routine closes up these gaps by
27820                                                                          ; looping through all the occupied ship slots after the
27821                                                                          ; slot we are removing, one by one, and shuffling each
27822                                                                          ; ship's slot, data block and line heap down to close
27823                                                                          ; up the gaps left by the removed ship. As part of this,
27824                                                                          ; we have to make sure we update any address pointers
27825                                                                          ; so they point to the newly shuffled data blocks and
27826                                                                          ; line heaps
27827                                                                          ;
27828                                                                          ; In the following, when shuffling a ship's data down
27829                                                                          ; into the preceding empty slot, we call the ship that
27830                                                                          ; we are shuffling down the "source", and we call the
27831                                                                          ; empty slot we are shuffling it into the "destination"
27832                                                                          ;
27833                                                                          ; Before we start looping through the ships we need to
27834                                                                          ; shuffle down, we need to set up some variables to
27835                                                                          ; point to the source and destination line heaps
27836               
27837 7D46 0202  20        li   ry,>05*256                 ; LDY #5            ; Fetch byte #5 of the removed ship's blueprint into A,
     7D48 0500     
27838                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; which gives the ship's maximum heap size for the ship
     **** ****     > LD_IND_Y_IDX
0001 7D4A D820  42        movb @XX0,@rtmplb
     7D4C 001E     
     7D4E 830D     
0002 7D50 D1A0  30        movb @XX0+1,rtmp
     7D52 001F     
0003 7D54 A182  18        a    ry,rtmp
0004 7D56 D016  26        movb *rtmp,RA
                   < elite.a99
27839                                                                          ; we are removing (i.e. the size of the gap in the heap
27840                                                                          ; created by the ship removal)
27841               
27842                                                                          ; INF currently contains the ship data for the ship we
27843                                                                          ; are removing, and INF(34 33) contains the address of
27844                                                                          ; the bottom of the ship's heap, so we can calculate
27845                                                                          ; the address of the top of the heap by adding the heap
27846                                                                          ; size to this address
27847               
27848 7D58 0202  20        li   ry,>21*256                 ; LDY #33           ; First we add A and the address in INF+33, to get the
     7D5A 2100     
27849                      .clc                            ; CLC               ; low byte of the top of the heap, which we store in P
     **** ****     > CLC
0001 7D5C 0A13  18        sla  rzero,1
                   < elite.a99
27850                      .adc_ind_y_idx @INF,ra          ; ADC (INF),Y
     **** ****     > ADC_IND_Y_IDX
0001 7D5E 04C0  14        clr  ra
0002 7D60 1701  14        jnc  !
0003 7D62 B004  18        ab   rone,ra
0004               !:
0005 7D64 D820  42        movb @INF,@rtmplb
     7D66 0020     
     7D68 830D     
0006 7D6A D1A0  30        movb @INF+1,rtmp
     7D6C 0021     
0007 7D6E A182  18        a    ry,rtmp
0008 7D70 B016  26        ab   *rtmp,ra
                   < elite.a99
27851 7D72 D800  30        movb ra,@P                      ; STA P
     7D74 001B     
27852               
27853 7D76 B084  18        ab   rone,ry                    ; INY               ; And next we add A and the address in INF+34, with any
27854                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; carry from the previous addition, to get the high byte
     **** ****     > LD_IND_Y_IDX
0001 7D78 D820  42        movb @INF,@rtmplb
     7D7A 0020     
     7D7C 830D     
0002 7D7E D1A0  30        movb @INF+1,rtmp
     7D80 0021     
0003 7D82 A182  18        a    ry,rtmp
0004 7D84 D016  26        movb *rtmp,RA
                   < elite.a99
27855                      .adi (>00*256)                  ; ADC #0            ; of the top of the heap, which we store in P+1, so
     **** ****     > ADI
0001 7D86 1701  14        jnc  !
0002 7D88 B004  18        ab   rone,ra
0003               !:
0004 7D8A 0220  22        ai   ra,(>00*256)
     7D8C 0000     
                   < elite.a99
27856 7D8E D800  30        movb ra,@P+1                    ; STA P+1           ; P(1 0) points to the top of this ship's heap
     7D90 001C     
27857               
27858                                                                          ; Now, we're ready to start looping through the ships
27859                                                                          ; we want to move, moving the slots, data blocks and
27860                                                                          ; line heap from the source to the destination. In the
27861                                                                          ; following, we set up SC to point to the source data,
27862                                                                          ; and INF (which currently points to the removed ship's
27863                                                                          ; data that we can now overwrite) points to the
27864                                                                          ; destination
27865                                                                          ;
27866                                                                          ; So P(1 0) now points to the top of the line heap for
27867                                                                          ; the destination
27868               
27869               KSL1:
27870 7D92 B044  18        ab   rone,rx                    ; INX               ; On entry, X points to the empty slot we want to
27871                                                                          ; shuffle the next ship into (the destination), so
27872                                                                          ; this increment points X to the next slot - i.e. the
27873                                                                          ; source slot we want to shuffle down
27874               
27875 7D94 D021  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Copy the contents of the source slot into the
     7D96 0D40     
27876 7D98 D840  38        movb ra,@FRIN-1(rx)             ; STA FRIN-1,X      ; destination slot
     7D9A 0D3F     
27877               
27878 7D9C 1602  14        jne  FIX009                     ; BNE FIX009        ; If the slot we just shuffled down contains 0, then
27879 7D9E 0460  28        b    @KS2                       ; JMP KS2           ; the source slot is empty and we are done shuffling,
     7DA0 7C8C     
27880                                                                          ; so jump to KS2 to move on to processing missiles
27881               FIX009:
27882                      .asla                           ; ASL A             ; Otherwise we have a source ship to shuffle down into
     **** ****     > ASLA
0001 7DA2 0240  22        andi ra,>ff00
     7DA4 FF00     
0002 7DA6 0A10  18        sla  ra,1
                   < elite.a99
27883 7DA8 D080  18        movb ra,ry                      ; TAY               ; the destination, so set Y = A * 2 so it can act as an
27884                                                                          ; index into the two-byte ship blueprint lookup table
27885                                                                          ; at XX21 for the source ship
27886               
27887 7DAA D022  34        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; Set SC(0 1) to point to the blueprint data for the
     7DAC A7D4     
27888 7DAE D800  30        movb ra,@SC                     ; STA SC            ; source ship
     7DB0 0007     
27889 7DB2 D022  34        movb @XX21-1(ry),ra             ; LDA XX21-1,Y
     7DB4 A7D5     
27890 7DB6 D800  30        movb ra,@SC+1                   ; STA SC+1
     7DB8 0008     
27891               
27892 7DBA 0202  20        li   ry,>05*256                 ; LDY #5            ; Fetch blueprint byte #5 for the source ship, which
     7DBC 0500     
27893                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; gives us its maximum heap size, and store it in T
     **** ****     > LD_IND_Y_IDX
0001 7DBE D820  42        movb @SC,@rtmplb
     7DC0 0007     
     7DC2 830D     
0002 7DC4 D1A0  30        movb @SC+1,rtmp
     7DC6 0008     
0003 7DC8 A182  18        a    ry,rtmp
0004 7DCA D016  26        movb *rtmp,RA
                   < elite.a99
27894 7DCC D800  30        movb ra,@T                      ; STA T
     7DCE 00D1     
27895               
27896                                                                          ; We now subtract T from P(1 0), so P(1 0) will point to
27897                                                                          ; the bottom of the line heap for the destination
27898                                                                          ; (which we will use later when closing up the gap in
27899                                                                          ; the heap space)
27900               
27901 7DD0 D020  30        movb @P,ra                      ; LDA P             ; First, we subtract the low bytes
     7DD2 001B     
27902                      .sec                            ; SEC
     **** ****     > SEC
0001 7DD4 0A15  18        sla  rmone,1
                   < elite.a99
27903                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 7DD6 1801  14        joc  !
0002 7DD8 7004  18        sb   rone,ra
0003               !:
0004 7DDA 7020  30        sb   @T,ra
     7DDC 00D1     
                   < elite.a99
27904 7DDE D800  30        movb ra,@P                      ; STA P
     7DE0 001B     
27905               
27906 7DE2 D020  30        movb @P+1,ra                    ; LDA P+1           ; And then we do the high bytes, for which we subtract
     7DE4 001C     
27907                      .sbi (>00*256)                  ; SBC #0            ; 0 to include any carry, so this is effectively doing
     **** ****     > SBI
0001 7DE6 1801  14        joc  !
0002 7DE8 7004  18        sb   rone,ra
0003               !:
0004 7DEA 0220  22        ai   ra,-(>00*256)
     7DEC 0000     
                   < elite.a99
27908 7DEE D800  30        movb ra,@P+1                    ; STA P+1           ; P(1 0) = P(1 0) - (0 T)
     7DF0 001C     
27909               
27910                                                                          ; Next, we want to set SC(1 0) to point to the source
27911                                                                          ; ship's data block
27912               
27913 7DF2 D001  18        movb rx,ra                      ; TXA               ; Set Y = X * 2 so it can act as an index into the
27914                      .asla                           ; ASL A             ; two-byte lookup table at UNIV, which contains the
     **** ****     > ASLA
0001 7DF4 0240  22        andi ra,>ff00
     7DF6 FF00     
0002 7DF8 0A10  18        sla  ra,1
                   < elite.a99
27915 7DFA D080  18        movb ra,ry                      ; TAY               ; addresses of the ship data blocks. In this case we are
27916                                                                          ; multiplying X by 2, and X contains the source ship's
27917                                                                          ; slot number so Y is now an index for the source ship's
27918                                                                          ; entry in UNIV
27919               
27920 7DFC D022  34        movb @UNIV(ry),ra               ; LDA UNIV,Y        ; Set SC(1 0) to the address of the data block for the
     7DFE 221F     
27921 7E00 D800  30        movb ra,@SC                     ; STA SC            ; source ship
     7E02 0007     
27922 7E04 D022  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y
     7E06 2220     
27923 7E08 D800  30        movb ra,@SC+1                   ; STA SC+1
     7E0A 0008     
27924               
27925                                                                          ; We have now set up our variables as follows:
27926                                                                          ;
27927                                                                          ; SC(1 0) points to the source's ship data block
27928                                                                          ;
27929                                                                          ; INF(1 0) points to the destination's ship data block
27930                                                                          ;
27931                                                                          ; P(1 0) points to the destination's line heap
27932                                                                          ;
27933                                                                          ; so let's start copying data from the source to the
27934                                                                          ; destination
27935               
27936 7E0C 0202  20        li   ry,>23*256                 ; LDY #35           ; We are going to be using Y as a counter for the 36
     7E0E 2300     
27937                                                                          ; bytes of ship data we want to copy from the source
27938                                                                          ; to the destination, so we set it to 35 to start things
27939                                                                          ; off, and will decrement Y for each byte we copy
27940               
27941                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; Fetch byte #35 of the source's ship data block at SC,
     **** ****     > LD_IND_Y_IDX
0001 7E10 D820  42        movb @SC,@rtmplb
     7E12 0007     
     7E14 830D     
0002 7E16 D1A0  30        movb @SC+1,rtmp
     7E18 0008     
0003 7E1A A182  18        a    ry,rtmp
0004 7E1C D016  26        movb *rtmp,RA
                   < elite.a99
27942                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; and store it in byte #35 of the destination's block
     **** ****     > ST_IND_Y_IDX
0001 7E1E D820  42        movb @INF,@rtmplb
     7E20 0020     
     7E22 830D     
0002 7E24 D1A0  30        movb @INF+1,rtmp
     7E26 0021     
0003 7E28 A182  18        a    ry,rtmp
0004 7E2A D580  30        movb RA,*rtmp
                   < elite.a99
27943                                                                          ; at INF, so that's the ship's energy copied from the
27944                                                                          ; source to the destination. One down, quite a few to
27945                                                                          ; go...
27946               
27947 7E2C 7084  18        sb   rone,ry                    ; DEY               ; Fetch byte #34 of the source ship, which is the
27948                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; high byte of the source ship's line heap, and store
     **** ****     > LD_IND_Y_IDX
0001 7E2E D820  42        movb @SC,@rtmplb
     7E30 0007     
     7E32 830D     
0002 7E34 D1A0  30        movb @SC+1,rtmp
     7E36 0008     
0003 7E38 A182  18        a    ry,rtmp
0004 7E3A D016  26        movb *rtmp,RA
                   < elite.a99
27949 7E3C D800  30        movb ra,@K+1                    ; STA K+1           ; in K+1
     7E3E 003E     
27950               
27951 7E40 D020  30        movb @P+1,ra                    ; LDA P+1           ; Set the low byte of the destination's heap pointer
     7E42 001C     
27952                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; to P+1
     **** ****     > ST_IND_Y_IDX
0001 7E44 D820  42        movb @INF,@rtmplb
     7E46 0020     
     7E48 830D     
0002 7E4A D1A0  30        movb @INF+1,rtmp
     7E4C 0021     
0003 7E4E A182  18        a    ry,rtmp
0004 7E50 D580  30        movb RA,*rtmp
                   < elite.a99
27953               
27954 7E52 7084  18        sb   rone,ry                    ; DEY               ; Fetch byte #33 of the source ship, which is the
27955                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; low byte of the source ship's heap, and store in K
     **** ****     > LD_IND_Y_IDX
0001 7E54 D820  42        movb @SC,@rtmplb
     7E56 0007     
     7E58 830D     
0002 7E5A D1A0  30        movb @SC+1,rtmp
     7E5C 0008     
0003 7E5E A182  18        a    ry,rtmp
0004 7E60 D016  26        movb *rtmp,RA
                   < elite.a99
27956 7E62 D800  30        movb ra,@K                      ; STA K             ; so now we have the following:
     7E64 003D     
27957                                                                          ;
27958                                                                          ; K(1 0) points to the source's line heap
27959               
27960 7E66 D020  30        movb @P,ra                      ; LDA P             ; Set the low byte of the destination's heap pointer
     7E68 001B     
27961                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; to P, so now the destination's heap pointer is to
     **** ****     > ST_IND_Y_IDX
0001 7E6A D820  42        movb @INF,@rtmplb
     7E6C 0020     
     7E6E 830D     
0002 7E70 D1A0  30        movb @INF+1,rtmp
     7E72 0021     
0003 7E74 A182  18        a    ry,rtmp
0004 7E76 D580  30        movb RA,*rtmp
                   < elite.a99
27962                                                                          ; P(1 0), so that's the heap pointer in bytes #33 and
27963                                                                          ; #34 done
27964               
27965 7E78 7084  18        sb   rone,ry                    ; DEY               ; Luckily, we can just copy the rest of the source's
27966                                                                          ; ship data block into the destination, as there are no
27967                                                                          ; more address pointers, so first we decrement our
27968                                                                          ; counter in Y to point to the next byte (the AI flag)
27969                                                                          ; in byte #32) and then start looping
27970               
27971               KSL2:
27972                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; Copy the Y-th byte of the source to the Y-th byte of
     **** ****     > LD_IND_Y_IDX
0001 7E7A D820  42        movb @SC,@rtmplb
     7E7C 0007     
     7E7E 830D     
0002 7E80 D1A0  30        movb @SC+1,rtmp
     7E82 0008     
0003 7E84 A182  18        a    ry,rtmp
0004 7E86 D016  26        movb *rtmp,RA
                   < elite.a99
27973                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; the destination
     **** ****     > ST_IND_Y_IDX
0001 7E88 D820  42        movb @INF,@rtmplb
     7E8A 0020     
     7E8C 830D     
0002 7E8E D1A0  30        movb @INF+1,rtmp
     7E90 0021     
0003 7E92 A182  18        a    ry,rtmp
0004 7E94 D580  30        movb RA,*rtmp
                   < elite.a99
27974               
27975 7E96 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter
27976               
27977 7E98 15F0  14        jgt  KSL2                       ; BPL KSL2          ; Loop back to KSL2 to copy the next byte until we have
27978                                                                          ; copied the whole block
27979               
27980                                                                          ; We have now shuffled the ship's slot and the ship's
27981                                                                          ; data block, so we only have the heap data itself to do
27982               
27983 7E9A D020  30        movb @SC,ra                     ; LDA SC            ; First, we copy SC into INF, so when we loop round
     7E9C 0007     
27984 7E9E D800  30        movb ra,@INF                    ; STA INF           ; again, INF will correctly point to the destination for
     7EA0 0020     
27985 7EA2 D020  30        movb @SC+1,ra                   ; LDA SC+1          ; the next iteration
     7EA4 0008     
27986 7EA6 D800  30        movb ra,@INF+1                  ; STA INF+1
     7EA8 0021     
27987               
27988 7EAA D0A0  30        movb @T,ry                      ; LDY T             ; Now we want to move the contents of the heap, as all
     7EAC 00D1     
27989                                                                          ; we did above was to update the pointers, so first
27990                                                                          ; we set a counter in Y that is initially set to T
27991                                                                          ; (which we set above to the maximum heap size for the
27992                                                                          ; source ship)
27993                                                                          ;
27994                                                                          ; As a reminder, we have already set the following:
27995                                                                          ;
27996                                                                          ; K(1 0) points to the source's line heap
27997                                                                          ;
27998                                                                          ; P(1 0) points to the destination's line heap
27999                                                                          ;
28000                                                                          ; so we can move the heap data by simply copying the
28001                                                                          ; correct number of bytes from K(1 0) to P(1 0)
28002               KSL3:
28003 7EAE 7084  18        sb   rone,ry                    ; DEY               ; Decrement the counter
28004               
28005                      .ld_ind_y_idx @K,ra             ; LDA (K),Y         ; Copy the Y-th byte of the source heap at K(1 0) to
     **** ****     > LD_IND_Y_IDX
0001 7EB0 D820  42        movb @K,@rtmplb
     7EB2 003D     
     7EB4 830D     
0002 7EB6 D1A0  30        movb @K+1,rtmp
     7EB8 003E     
0003 7EBA A182  18        a    ry,rtmp
0004 7EBC D016  26        movb *rtmp,RA
                   < elite.a99
28006                      .st_ind_y_idx @P,ra             ; STA (P),Y         ; the destination heap at P(1 0)
     **** ****     > ST_IND_Y_IDX
0001 7EBE D820  42        movb @P,@rtmplb
     7EC0 001B     
     7EC2 830D     
0002 7EC4 D1A0  30        movb @P+1,rtmp
     7EC6 001C     
0003 7EC8 A182  18        a    ry,rtmp
0004 7ECA D580  30        movb RA,*rtmp
                   < elite.a99
28007               
28008 7ECC D002  18        movb ry,ra                      ; TYA               ; Loop back to KSL3 to copy the next byte, until we
28009 7ECE 16EF  14        jne  KSL3                       ; BNE KSL3          ; have done them all
28010               
28011 7ED0 1602  14        jne  FIX010                     ; BNE FIX010        ; We have now shuffled everything down one slot, so
28012 7ED2 0460  28        b    @KSL1                      ; JMP KSL1          ; jump back up to KSL1 to see if there is another slot
     7ED4 7D92     
28013                                                                          ; that needs shuffling down (this BEQ is effectively a
28014                                                                          ; JMP as A will always be zero)
28015               FIX010:
28016               * ******************************************************************************
28017               *
28018               * Name: SFX
28019               * Type: Variable
28020               * Category: Sound
28021               * Summary: Sound data
28022               *
28023               * ------------------------------------------------------------------------------
28024               *
28025               * Sound data. To make a sound, the NOS1 routine copies the four relevant sound
28026               * bytes to XX16, and NO3 then makes the sound. The sound numbers are shown in
28027               * the table, and are always multiples of 8. Generally, sounds are made by
28028               * calling the NOISE routine with the sound number in A.
28029               *
28030               * These bytes are passed to OSWORD 7, and are the equivalents to the parameters
28031               * passed to the SOUND keyword in BASIC. The parameters therefore have these
28032               * meanings:
28033               *
28034               * channel/flush, amplitude (or envelope number if 1-4), pitch, duration
28035               *
28036               * For the channel/flush parameter, the high nibble of the low byte is the flush
28037               * control (where a flush control of 0 queues the sound, and a flush control of
28038               * 1 makes the sound instantly), while the low nibble of the low byte is the
28039               * channel number. When written in hexadecimal, the first figure gives the flush
28040               * control, while the second is the channel (so &13 indicates flush control = 1
28041               * and channel = 3).
28042               *
28043               * So when we call NOISE with A = 40 to make a long, low beep, then this is
28044               * effectively what the NOISE routine does:
28045               *
28046               * SOUND &13, &F4, &0C, &08
28047               *
28048               * which makes a sound with flush control 1 on channel 3, and with amplitude &F4
28049               * (-12), pitch &0C (2) and duration &08 (8). Meanwhile, to make the hyperspace
28050               * sound, the NOISE routine does this:
28051               *
28052               * SOUND &10, &02, &60, &10
28053               *
28054               * which makes a sound with flush control 1 on channel 0, using envelope 2,
28055               * and with pitch &60 (96) and duration &10 (16). The four sound envelopes (1-4)
28056               * are set up by the loading process.
28057               *
28058               * ******************************************************************************
28059                      equ  $
28060               SFX:
28061 7ED6 1201            byte >12,>01,>00,>10                                ; 0  - Lasers fired by us
     7ED8 0010     
28062 7EDA 1202            byte >12,>02,>2c,>08                                ; 8  - We're being hit by lasers
     7EDC 2C08     
28063 7EDE 1103            byte >11,>03,>f0,>18                                ; 16 - We died 1 / We made a hit or kill 2
     7EE0 F018     
28064 7EE2 10F1            byte >10,>f1,>07,>1a                                ; 24 - We died 2 / We made a hit or kill 1
     7EE4 071A     
28065 7EE6 03F1            byte >03,>f1,>bc,>01                                ; 32 - Short, high beep
     7EE8 BC01     
28066 7EEA 13F4            byte >13,>f4,>0c,>08                                ; 40 - Long, low beep
     7EEC 0C08     
28067 7EEE 10F1            byte >10,>f1,>06,>0c                                ; 48 - Missile launched / Ship launched from station
     7EF0 060C     
28068 7EF2 1002            byte >10,>02,>60,>10                                ; 56 - Hyperspace drive engaged
     7EF4 6010     
28069 7EF6 1304            byte >13,>04,>c2,>ff                                ; 64 - E.C.M. on
     7EF8 C2FF     
28070 7EFA 1300            byte >13,>00,>00,>00                                ; 72 - E.C.M. off
     7EFC 0000     
28071               
28072               * ******************************************************************************
28073               *
28074               * Name: RESET
28075               * Type: Subroutine
28076               * Category: Start and end
28077               * Summary: Reset most variables
28078               *
28079               * ------------------------------------------------------------------------------
28080               *
28081               * Reset our ship and various controls, recharge shields and energy, and then
28082               * fall through into RES2 to reset the stardust and the ship workspace at INWK.
28083               *
28084               * In this subroutine, this means zero-filling the following locations:
28085               *
28086               * * Pages &9, &A, &B, &C and &D
28087               *
28088               * * BETA to BETA+6, which covers the following:
28089               *
28090               * * BETA, BET1 - Set pitch to 0
28091               *
28092               * * XC, YC - Set text cursor to (0, 0)
28093               *
28094               * * QQ22 - Set hyperspace counters to 0
28095               *
28096               * * ECMA - Turn E.C.M. off
28097               *
28098               * It also sets QQ12 to &FF, to indicate we are docked, recharges the shields and
28099               * energy banks, and then falls through into RES2.
28100               *
28101               * ------------------------------------------------------------------------------
28102               *
28103               * Other entry points:
28104               *
28105               * RES4                Reset the shields and energy banks, then fall through
28106               * into RES2 to reset the stardust and the ship workspace
28107               * at INWK
28108               *
28109               * ******************************************************************************
28110               
28111               RESET:
28112 7EFE 0206  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     7F00 87FE     
28113 7F02 06A0  28        bl   @jsr                       ;
     7F04 8002     
28114                                                                          ; the ship data blocks, the ship line heap, the ship
28115                                                                          ; slots for the local bubble of universe, and various
28116                                                                          ; flight and ship status variables
28117               
28118 7F06 0201  20        li   rx,>06*256                 ; LDX #6            ; Set up a counter for zeroing BETA through BETA+6
     7F08 0600     
28119               
28120               SAL3:
28121 7F0A D840  38        movb ra,@BETA(rx)               ; STA BETA,X        ; Zero the X-th byte after BETA
     7F0C 002A     
28122               
28123 7F0E 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
28124               
28125 7F10 15FC  14        jgt  SAL3                       ; BPL SAL3          ; Loop back for the next byte to zero
28126               
28127 7F12 D801  30        movb rx,@QQ12                   ; STX QQ12          ; X is now negative - i.e. &FF - so this sets QQ12 to
     7F14 009F     
28128                                                                          ; &FF to indicate we are docked
28129               
28130                                                                          ; We now fall through into RES4 to restore shields and
28131                                                                          ; energy, and reset the stardust and ship workspace at
28132                                                                          ; INWK
28133               
28134               RES4:
28135 7F16 0200  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to &FF so we can fill up the shields and energy
     7F18 FF00     
28136                                                                          ; bars with a full charge
28137               
28138 7F1A 0201  20        li   rx,>02*256                 ; LDX #2            ; We're now going to recharge both shields and the
     7F1C 0200     
28139                                                                          ; energy bank, which live in the three bytes at FSH,
28140                                                                          ; ASH (FSH+1) and ENERGY (FSH+2), so set a loop counter
28141                                                                          ; in X for 3 bytes
28142               
28143               REL5:
28144 7F1E D840  38        movb ra,@FSH(rx)                ; STA FSH,X         ; Set the X-th byte of FSH to &FF to charge up that
     7F20 0F11     
28145                                                                          ; shield/bank
28146               
28147 7F22 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
28148               
28149 7F24 15FC  14        jgt  REL5                       ; BPL REL5          ; Loop back to REL5 until we have recharged both shields
28150                                                                          ; and the energy bank
28151               
28152                                                                          ; Fall through into RES2 to reset the stardust and ship
28153                                                                          ; workspace at INWK
28154               
28155               * ******************************************************************************
28156               *
28157               * Name: RES2
28158               * Type: Subroutine
28159               * Category: Start and end
28160               * Summary: Reset a number of flight variables and workspaces
28161               *
28162               * ------------------------------------------------------------------------------
28163               *
28164               * This is called after we launch from a space station, arrive in a new system
28165               * after hyperspace, launch an escape pod, or die a cold, lonely death in the
28166               * depths of space.
28167               *
28168               * ------------------------------------------------------------------------------
28169               *
28170               * Returns:
28171               *
28172               * Y                   Y is set to &FF
28173               *
28174               * ******************************************************************************
28175               
28176               RES2:
28177 7F26 0200  20        li   ra,(NOST)*256              ; LDA #NOST         ; Reset NOSTM, the number of stardust particles, to the
     7F28 1200     
28178 7F2A D800  30        movb ra,@NOSTM                  ; STA NOSTM         ; maximum allowed (18)
     7F2C 0F33     
28179               
28180 7F2E 0201  20        li   rx,>ff*256                 ; LDX #&FF          ; Reset LSX2 and LSY2, the ball line heaps used by the
     7F30 FF00     
28181 7F32 D801  30        movb rx,@LSX2                   ; STX LSX2          ; BLINE routine for drawing circles, to &FF, to set the
     7F34 0E26     
28182 7F36 D801  30        movb rx,@LSY2                   ; STX LSY2          ; heap to empty
     7F38 0E74     
28183               
28184 7F3A D801  30        movb rx,@MSTG                   ; STX MSTG          ; Reset MSTG, the missile target, to &FF (no target)
     7F3C 0052     
28185               
28186 7F3E 0200  20        li   ra,>80*256                 ; LDA #128          ; Set the current pitch rate to the mid-point, 128
     7F40 8000     
28187 7F42 D800  30        movb ra,@JSTY                   ; STA JSTY
     7F44 009D     
28188               
28189 7F46 D800  30        movb ra,@ALP2                   ; STA ALP2          ; Reset ALP2 (roll sign) and BET2 (pitch sign)
     7F48 0088     
28190 7F4A D800  30        movb ra,@BET2                   ; STA BET2          ; to negative, i.e. pitch and roll negative
     7F4C 008A     
28191               
28192                      .asla                           ; ASL A             ; This sets A to 0
     **** ****     > ASLA
0001 7F4E 0240  22        andi ra,>ff00
     7F50 FF00     
0002 7F52 0A10  18        sla  ra,1
                   < elite.a99
28193               
28194 7F54 D800  30        movb ra,@ALP2+1                 ; STA ALP2+1        ; Reset ALP2+1 (flipped roll sign) and BET2+1 (flipped
     7F56 0089     
28195 7F58 D800  30        movb ra,@BET2+1                 ; STA BET2+1        ; pitch sign) to positive, i.e. pitch and roll negative
     7F5A 008B     
28196               
28197 7F5C D800  30        movb ra,@MCNT                   ; STA MCNT          ; Reset MCNT (the main loop counter) to 0
     7F5E 0099     
28198               
28199 7F60 0200  20        li   ra,>03*256                 ; LDA #3            ; Reset DELTA (speed) to 3
     7F62 0300     
28200 7F64 D800  30        movb ra,@DELTA                  ; STA DELTA
     7F66 008C     
28201               
28202 7F68 D800  30        movb ra,@ALPHA                  ; STA ALPHA         ; Reset ALPHA (roll angle alpha) to 3
     7F6A 009E     
28203               
28204 7F6C D800  30        movb ra,@ALP1                   ; STA ALP1          ; Reset ALP1 (magnitude of roll angle alpha) to 3
     7F6E 0087     
28205               
28206 7F70 D020  30        movb @SSPR,ra                   ; LDA SSPR          ; Fetch the "space station present" flag, and if we are
     7F72 0D55     
28207 7F74 1304  14        jeq  B86                        ; BEQ B86           ; not inside the safe zone, skip the next instruction
28208               
28209 7F76 0206  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Light up the space station bulb on the dashboard
     7F78 70D6     
28210 7F7A 06A0  28        bl   @jsr                       ;
     7F7C 8002     
28211               
28212               B86:
28213 7F7E D020  30        movb @ECMA,ra                   ; LDA ECMA          ; Fetch the E.C.M. status flag, and if E.C.M. is off,
     7F80 0030     
28214 7F82 1304  14        jeq  yu_                        ; BEQ yu            ; skip the next instruction
28215               
28216 7F84 0206  20        li   rtmp,ECMOF                 ; JSR ECMOF         ; Turn off the E.C.M. sound
     7F86 8B08     
28217 7F88 06A0  28        bl   @jsr                       ;
     7F8A 8002     
28218               
28219               yu_:
28220 7F8C 0206  20        li   rtmp,WPSHPS                ; JSR WPSHPS        ; Wipe all ships from the scanner
     7F8E 6C24     
28221 7F90 06A0  28        bl   @jsr                       ;
     7F92 8002     
28222               
28223 7F94 0206  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     7F96 87FE     
28224 7F98 06A0  28        bl   @jsr                       ;
     7F9A 8002     
28225                                                                          ; the ship data blocks, the ship line heap, the ship
28226                                                                          ; slots for the local bubble of universe, and various
28227                                                                          ; flight and ship status variables
28228               
28229 7F9C 0200  20        li   ra,((WP.-1)%256)*256       ; LDA #LO(WP%-1)    ; We have reset the ship line heap, so we now point
     7F9E 3F00     
28230 7FA0 D800  30        movb ra,@SLSP                   ; STA SLSP          ; SLSP to the byte before the WP workspace to indicate
     7FA2 0F1E     
28231 7FA4 0200  20        li   ra,((WP.-1)/256)*256       ; LDA #HI(WP%-1)    ; that the heap is empty
     7FA6 0D00     
28232 7FA8 D800  30        movb ra,@SLSP+1                 ; STA SLSP+1
     7FAA 0F1F     
28233               
28234 7FAC 0206  20        li   rtmp,DIALS                 ; JSR DIALS         ; Update the dashboard
     7FAE 3272     
28235 7FB0 06A0  28        bl   @jsr                       ;
     7FB2 8002     
28236               
28237                                                                          ; Finally, fall through into ZINF to reset the INWK
28238                                                                          ; ship workspace
28239               
28240               * ******************************************************************************
28241               *
28242               * Name: ZINF
28243               * Type: Subroutine
28244               * Category: Universe
28245               * Summary: Reset the INWK workspace and orientation vectors
28246               * Deep dive: Orientation vectors
28247               *
28248               * ------------------------------------------------------------------------------
28249               *
28250               * Zero-fill the INWK ship workspace and reset the orientation vectors, with
28251               * nosev pointing out of the screen, towards us.
28252               *
28253               * ------------------------------------------------------------------------------
28254               *
28255               * Returns:
28256               *
28257               * Y                   Y is set to &FF
28258               *
28259               * ******************************************************************************
28260               
28261               ZINF:
28262 7FB4 0202  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; There are NI% bytes in the INWK workspace, so set a
     7FB6 2300     
28263                                                                          ; counter in Y so we can loop through them
28264               
28265 7FB8 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can zero-fill the workspace
     7FBA 0000     
28266               
28267               ZI1:
28268 7FBC D880  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; Zero the Y-th byte of the INWK workspace
     7FBE 0053     
28269               
28270 7FC0 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
28271               
28272 7FC2 15FC  14        jgt  ZI1                        ; BPL ZI1           ; Loop back for the next byte, ending when we have
28273                                                                          ; zero-filled the last byte at INWK, which leaves Y
28274                                                                          ; with a value of &FF
28275               
28276                                                                          ; Finally, we reset the orientation vectors as follows:
28277                                                                          ;
28278                                                                          ; sidev = (1,  0,  0)
28279                                                                          ; roofv = (0,  1,  0)
28280                                                                          ; nosev = (0,  0, -1)
28281                                                                          ;
28282                                                                          ; 96 * 256 (&6000) represents 1 in the orientation
28283                                                                          ; vectors, while -96 * 256 (&E000) represents -1. We
28284                                                                          ; already set the vectors to zero above, so we just
28285                                                                          ; need to set up the high bytes of the diagonal values
28286                                                                          ; and we're done. The negative nosev makes the ship
28287                                                                          ; point towards us, as the z-axis points into the screen
28288               
28289 7FC4 0200  20        li   ra,>60*256                 ; LDA #96           ; Set A to represent a 1 (in vector terms)
     7FC6 6000     
28290               
28291 7FC8 D800  30        movb ra,@INWK+18                ; STA INWK+18       ; Set byte #18 = roofv_y_hi = 96 = 1
     7FCA 0065     
28292               
28293 7FCC D800  30        movb ra,@INWK+22                ; STA INWK+22       ; Set byte #22 = sidev_x_hi = 96 = 1
     7FCE 0069     
28294               
28295 7FD0 0260  22        ori  ra,>80*256                 ; ORA #%10000000    ; Flip the sign of A to represent a -1
     7FD2 8000     
28296               
28297 7FD4 D800  30        movb ra,@INWK+14                ; STA INWK+14       ; Set byte #14 = nosev_z_hi = -96 = -1
     7FD6 0061     
28298               
28299 7FD8 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7FDA 800E     
28300               
28301               * ******************************************************************************
28302               *
28303               * Name: msblob
28304               * Type: Subroutine
28305               * Category: Dashboard
28306               * Summary: Display the dashboard's missile indicators in green
28307               *
28308               * ------------------------------------------------------------------------------
28309               *
28310               * Display the dashboard's missile indicators, with all the missiles reset to
28311               * green/cyan (i.e. not armed or locked).
28312               *
28313               * ******************************************************************************
28314               
28315               msblob_:
28316 7FDC 0201  20        li   rx,>04*256                 ; LDX #4            ; Set up a loop counter in X to count through all four
     7FDE 0400     
28317                                                                          ; missile indicators
28318               
28319               ss_:
28320 7FE0 9060  30        cb   @NOMSL,rx                  ; CPX NOMSL         ; If the counter is equal to the number of missiles,
     7FE2 0333     
28321 7FE4 130A  14        jeq  SAL8                       ; BEQ SAL8          ; jump down to SAL8 to draw the remaining missiles, as
28322                                                                          ; the rest of them are present and should be drawn in
28323                                                                          ; green/cyan
28324               
28325 7FE6 0202  20        li   ry,>00*256                 ; LDY #0            ; Draw the missile indicator at position X in black
     7FE8 0000     
28326 7FEA 0206  20        li   rtmp,MSBAR                 ; JSR MSBAR
     7FEC 7102     
28327 7FEE 06A0  28        bl   @jsr                       ;
     7FF0 8002     
28328               
28329 7FF2 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter to point to the next missile
28330               
28331 7FF4 16F5  14        jne  ss_                        ; BNE ss            ; Loop back to ss if we still have missiles to draw
28332               
28333 7FF6 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     7FF8 800E     
28334               
28335               SAL8:
28336 7FFA 0202  20        li   ry,>ee*256                 ; LDY #&EE          ; Draw the missile indicator at position X in green/cyan
     7FFC EE00     
28337 7FFE 0206  20        li   rtmp,MSBAR                 ; JSR MSBAR
     8000 7102     
28338 8002 06A0  20        bl   @jsr                       ;
     8004 8002     
28339               
28340 8006 7044  14        sb   rone,rx                    ; DEX               ; Decrement the counter to point to the next missile
28341               
28342 8008 16F8  10        jne  SAL8                       ; BNE SAL8          ; Loop back to SAL8 if we still have missiles to draw
28343               
28344 800A 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     800C 800E     
28345               
28346               * ******************************************************************************
28347               *
28348               * Name: me2
28349               * Type: Subroutine
28350               * Category: Flight
28351               * Summary: Remove an in-flight message from the space view
28352               *
28353               * ******************************************************************************
28354               
28355               me2_:
28356 800E D020  22        movb @MCH,ra                    ; LDA MCH           ; Fetch the token number of the current message into A
     8010 0F10     
28357               
28358 8012 0206  12        li   rtmp,MESS                  ; JSR MESS          ; Call MESS to print the token, which will remove it
     8014 8E52     
28359 8016 06A0  20        bl   @jsr                       ;
     8018 8002     
28360                                                                          ; from the screen as printing uses EOR logic
28361               
28362 801A 0200  12        li   ra,>00*256                 ; LDA #0            ; Set the delay in DLY to 0, so any new in-flight
     801C 0000     
28363 801E D800  22        movb ra,@DLY                    ; STA DLY           ; messages will be shown instantly
     8020 0D64     
28364               
28365 8022 0460  16        b    @me3_                      ; JMP me3           ; Jump back into the main spawning loop at me3
     8024 80DE     
28366               
28367               * ******************************************************************************
28368               *
28369               * Name: Ze
28370               * Type: Subroutine
28371               * Category: Universe
28372               * Summary: Initialise the INWK workspace to a hostile ship
28373               * Deep dive: Fixing ship positions
28374               *
28375               * ------------------------------------------------------------------------------
28376               *
28377               * Specifically, this routine does the following:
28378               *
28379               * * Reset the INWK ship workspace
28380               *
28381               * * Set the ship to a fair distance away in all axes, in front of us but
28382               * randomly up or down, left or right
28383               *
28384               * * Give the ship a 4% chance of having E.C.M.
28385               *
28386               * * Set the ship to hostile, with AI enabled
28387               *
28388               * This routine also sets A, X, T1 and the C flag to random values.
28389               *
28390               * Note that because this routine uses the value of X returned by DORND, and X
28391               * contains the value of A returned by the previous call to DORND, this routine
28392               * does not necessarily set the new ship to a totally random location. See the
28393               * deep dive on "Fixing ship positions" for details.
28394               *
28395               * ******************************************************************************
28396               
28397               Ze:
28398 8026 0206  12        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     8028 7FB4     
28399 802A 06A0  20        bl   @jsr                       ;
     802C 8002     
28400               
28401 802E 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     8030 8070     
28402 8032 06A0  20        bl   @jsr                       ;
     8034 8002     
28403               
28404 8036 D800  22        movb ra,@T1                     ; STA T1            ; Store A in T1
     8038 0006     
28405               
28406 803A 0240  14        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign of A and store in x_sign
     803C 8000     
28407 803E D800  22        movb ra,@INWK+2                 ; STA INWK+2
     8040 0055     
28408               
28409 8042 D001  14        movb rx,ra                      ; TXA               ; Extract the sign of X and store in y_sign
28410 8044 0240  14        andi ra,>80*256                 ; AND #%10000000
     8046 8000     
28411 8048 D800  22        movb ra,@INWK+5                 ; STA INWK+5
     804A 0058     
28412               
28413 804C 0200  12        li   ra,>20*256                 ; LDA #32           ; Set x_hi = y_hi = z_hi = 32, a fair distance away
     804E 2000     
28414 8050 D800  22        movb ra,@INWK+1                 ; STA INWK+1
     8052 0054     
28415 8054 D800  22        movb ra,@INWK+4                 ; STA INWK+4
     8056 0057     
28416 8058 D800  22        movb ra,@INWK+7                 ; STA INWK+7
     805A 005A     
28417               
28418 805C D001  14        movb rx,ra                      ; TXA               ; Set the C flag if X >= 245 (4% chance)
28419 805E 0280  14        ci   ra,>f5*256                 ; CMP #245
     8060 F500     
28420               
28421 8062 06A0  20        bl   @rola                      ; ROL A             ; Set bit 0 of A to the C flag (i.e. there's a 4%
     8064 8018     
28422                                                                          ; chance of this ship having E.C.M.)
28423               
28424 8066 0260  14        ori  ra,>c0*256                 ; ORA #%11000000    ; Set bits 6 and 7 of A, so the ship is hostile (bit 6
     8068 C000     
28425                                                                          ; and has AI (bit 7)
28426               
28427 806A D800  22        movb ra,@INWK+32                ; STA INWK+32       ; Store A in the AI flag of this ship
     806C 0073     
28428               
28429                                                                          ; Fall through into DORND2 to set A, X and the C flag
28430                                                                          ; randomly
28431               
28432               * ******************************************************************************
28433               *
28434               * Name: DORND
28435               * Type: Subroutine
28436               * Category: Maths (Arithmetic)
28437               * Summary: Generate random numbers
28438               * Deep dive: Generating random numbers
28439               * Fixing ship positions
28440               *
28441               * ------------------------------------------------------------------------------
28442               *
28443               * Set A and X to random numbers (though note that X is set to the random number
28444               * that was returned in A the last time DORND was called).
28445               *
28446               * The C and V flags are also set randomly.
28447               *
28448               * If we want to generate a repeatable sequence of random numbers, when
28449               * generating explosion clouds, for example, then we call DORND2 to ensure that
28450               * the value of the C flag on entry doesn't affect the outcome, as otherwise we
28451               * might not get the same sequence of numbers if the C flag changes.
28452               *
28453               * ------------------------------------------------------------------------------
28454               *
28455               * Other entry points:
28456               *
28457               * DORND2              Make sure the C flag doesn't affect the outcome
28458               *
28459               * ******************************************************************************
28460               
28461               DORND2:
28462                      .clc                            ; CLC               ; Clear the C flag so the value of the C flag on entry
     **** ****     > CLC
0001 806E 0A13  14        sla  rzero,1
                   < elite.a99
28463                                                                          ; doesn't affect the outcome
28464               
28465               DORND:
28466 8070 D020  22        movb @RAND,ra                   ; LDA RAND          ; Calculate the next two values f2 and f3 in the feeder
     8072 0000     
28467 8074 06A0  20        bl   @rola                      ; ROL A             ; sequence:
     8076 8018     
28468 8078 D040  14        movb ra,rx                      ; TAX               ;
28469                      .adc @RAND+2,ra                 ; ADC RAND+2        ; * f2 = (f1 << 1) mod 256 + C flag on entry
     **** ****     > ADC
0001 807A 1701  10        jnc  !
0002 807C B004  14        ab   rone,ra
0003               !:
0004 807E B020  22        ab   @RAND+2,ra
     8080 0002     
                   < elite.a99
28470 8082 D800  22        movb ra,@RAND                   ; STA RAND          ; * f3 = f0 + f2 + (1 if bit 7 of f1 is set)
     8084 0000     
28471 8086 D801  22        movb rx,@RAND+2                 ; STX RAND+2        ; * C flag is set according to the f3 calculation
     8088 0002     
28472               
28473 808A D020  22        movb @RAND+1,ra                 ; LDA RAND+1        ; Calculate the next value m2 in the main sequence:
     808C 0001     
28474 808E D040  14        movb ra,rx                      ; TAX               ;
28475                      .adc @RAND+3,ra                 ; ADC RAND+3        ; * A = m2 = m0 + m1 + C flag from feeder calculation
     **** ****     > ADC
0001 8090 1701  10        jnc  !
0002 8092 B004  14        ab   rone,ra
0003               !:
0004 8094 B020  22        ab   @RAND+3,ra
     8096 0003     
                   < elite.a99
28476 8098 D800  22        movb ra,@RAND+1                 ; STA RAND+1        ; * X = m1
     809A 0001     
28477 809C D801  22        movb rx,@RAND+3                 ; STX RAND+3        ; * C and V flags set according to the m2 calculation
     809E 0003     
28478               
28479 80A0 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     80A2 800E     
28480               
28481               * ******************************************************************************
28482               *
28483               * Name: Main game loop (Part 1 of 6)
28484               * Type: Subroutine
28485               * Category: Main loop
28486               * Summary: Spawn a trader (a peaceful Cobra Mk III)
28487               * Deep dive: Program flow of the main game loop
28488               * Ship data blocks
28489               *
28490               * ------------------------------------------------------------------------------
28491               *
28492               * This is part of the main game loop. This is where the core loop of the game
28493               * lives, and it's in two parts. The shorter loop (just parts 5 and 6) is
28494               * iterated when we are docked, while the entire loop from part 1 to 6 iterates
28495               * if we are in space.
28496               *
28497               * This section covers the following:
28498               *
28499               * * Spawn a trader, i.e. a Cobra Mk III that isn't hostile, with a 50% chance
28500               * of it having a missile, a 50% chance of it having an E.C.M., a speed
28501               * between 16 and 31, and a gentle clockwise roll
28502               *
28503               * We call this from within the main loop, with A set to a random number.
28504               *
28505               * ******************************************************************************
28506               
28507               MTT4:
28508 80A4 0910  14        srl  ra,1                       ; LSR A             ; Clear bit 7 of our random number in A and set the C
28509                                                                          ; flag to bit 0 of A, which is random
28510               
28511 80A6 D800  22        movb ra,@INWK+32                ; STA INWK+32       ; Store this in the ship's AI flag, so this ship does
     80A8 0073     
28512                                                                          ; not have AI
28513               
28514 80AA D800  22        movb ra,@INWK+29                ; STA INWK+29       ; Store A in the ship's roll counter, giving it a
     80AC 0070     
28515                                                                          ; clockwise roll (as bit 7 is clear), and a 1 in 127
28516                                                                          ; chance of it having no damping
28517               
28518 80AE 0208  12        li   rarg1,INWK+31              ; ROL INWK+31       ; Set bit 0 of the ship's missile count randomly (as the
     80B0 0072     
28519 80B2 06A0  20        bl   @rol                       ;
     80B4 8028     
28520                                                                          ; C flag was set), giving the ship either no missiles or
28521                                                                          ; one missile
28522               
28523 80B6 0240  14        andi ra,>1f*256                 ; AND #31           ; Set the ship speed to our random number, set to a
     80B8 1F00     
28524 80BA 0260  14        ori  ra,>10*256                 ; ORA #16           ; minimum of 16 and a maximum of 31
     80BC 1000     
28525 80BE D800  22        movb ra,@INWK+27                ; STA INWK+27
     80C0 006E     
28526               
28527 80C2 0200  12        li   ra,(CYL)*256               ; LDA #CYL          ; Add a new Cobra Mk III to the local bubble and fall
     80C4 0700     
28528 80C6 0206  12        li   rtmp,NWSHP                 ; JSR NWSHP         ; through into the main game loop again
     80C8 6F6E     
28529 80CA 06A0  20        bl   @jsr                       ;
     80CC 8002     
28530               
28531               * ******************************************************************************
28532               *
28533               * Name: Main game loop (Part 2 of 6)
28534               * Type: Subroutine
28535               * Category: Main loop
28536               * Summary: Call the main flight loop, and potentially spawn a trader, an
28537               * asteroid, or a cargo canister
28538               * Deep dive: Program flow of the main game loop
28539               * Ship data blocks
28540               * Fixing ship positions
28541               *
28542               * ------------------------------------------------------------------------------
28543               *
28544               * This section covers the following:
28545               *
28546               * * Call M% to do the main flight loop
28547               *
28548               * * Potentially spawn a trader, asteroid or cargo canister
28549               *
28550               * ------------------------------------------------------------------------------
28551               *
28552               * Other entry points:
28553               *
28554               * TT100               The entry point for the start of the main game loop,
28555               * which calls the main flight loop and the moves into the
28556               * spawning routine
28557               *
28558               * me3                 Used by me2 to jump back into the main game loop after
28559               * printing an in-flight message
28560               *
28561               * ******************************************************************************
28562               
28563               TT100:
28564 80CE 0206  12        li   rtmp,M.                    ; JSR M%            ; Call M% to iterate through the main flight loop
     80D0 0F52     
28565 80D2 06A0  20        bl   @jsr                       ;
     80D4 8002     
28566               
28567 80D6 7004  14        sb   rone,ra                    ; DEC DLY           ; Decrement the delay counter in DLY, so any in-flight
28568                                                                          ; messages get removed once the counter reaches zero
28569               
28570 80D8 139A  10        jeq  me2_                       ; BEQ me2           ; If DLY is now 0, jump to me2 to remove any in-flight
28571                                                                          ; message from the space view, and once done, return to
28572                                                                          ; me3 below, skipping the following two instructions
28573               
28574 80DA 1501  10        jgt  me3_                       ; BPL me3           ; If DLY is positive, jump to me3 to skip the next
28575                                                                          ; instruction
28576               
28577 80DC B004  14        ab   rone,ra                    ; INC DLY           ; If we get here, DLY is negative, so we have gone too
28578                                                                          ; and need to increment DLY back to 0
28579               
28580               me3_:
28581 80DE 7004  14        sb   rone,ra                    ; DEC MCNT          ; Decrement the main loop counter in MCNT
28582               
28583 80E0 1302  10        jeq  B87                        ; BEQ B87           ; If the counter has reached zero, which it will do
28584                                                                          ; every 256 main loops, skip the next JMP instruction
28585                                                                          ; (or to put it another way, if the counter hasn't
28586                                                                          ; reached zero, jump down to MLOOP, skipping all the
28587                                                                          ; following checks)
28588               
28589               ytq_:
28590 80E2 0460  16        b    @MLOOP                     ; JMP MLOOP         ; Jump down to MLOOP to do some end-of-loop tidying and
     80E4 826A     
28591                                                                          ; restart the main loop
28592               
28593                                                                          ; We only get here once every 256 iterations of the
28594                                                                          ; main loop. If we aren't in witchspace and don't
28595                                                                          ; already have 3 or more asteroids in our local bubble,
28596                                                                          ; then this section has a 13% chance of spawning
28597                                                                          ; something benign (the other 87% of the time we jump
28598                                                                          ; down to consider spawning cops, pirates and bounty
28599                                                                          ; hunters)
28600                                                                          ;
28601                                                                          ; If we are in that 13%, then 50% of the time this will
28602                                                                          ; be a Cobra Mk III trader, and the other 50% of the
28603                                                                          ; time it will either be an asteroid (98.5% chance) or,
28604                                                                          ; very rarely, a cargo canister (1.5% chance)
28605               
28606               B87:
28607 80E6 D020  22        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace following a mis-jump, skip the
     80E8 0D5C     
28608 80EA 16FB  10        jne  ytq_                       ; BNE ytq           ; following by jumping down to MLOOP (via ytq above)
28609               
28610 80EC 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     80EE 8070     
28611 80F0 06A0  20        bl   @jsr                       ;
     80F2 8002     
28612               
28613 80F4 0280  14        ci   ra,>23*256                 ; CMP #35           ; If A >= 35 (87% chance), jump down to MTT1 to skip
     80F6 2300     
28614 80F8 184F  10        joc  MTT1                       ; BCS MTT1          ; the spawning of an asteroid or cargo canister and
28615                                                                          ; potentially spawn something else
28616               
28617 80FA D020  22        movb @MANY+AST,ra               ; LDA MANY+AST      ; If we already have 3 or more asteroids in the local
     80FC 0D57     
28618 80FE 0280  14        ci   ra,>03*256                 ; CMP #3            ; bubble, jump down to MTT1 to skip the following and
     8100 0300     
28619 8102 184A  10        joc  MTT1                       ; BCS MTT1          ; potentially spawn something else
28620               
28621 8104 0206  12        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     8106 7FB4     
28622 8108 06A0  20        bl   @jsr                       ;
     810A 8002     
28623               
28624 810C 0200  12        li   ra,>26*256                 ; LDA #38           ; Set z_hi = 38 (far away)
     810E 2600     
28625 8110 D800  22        movb ra,@INWK+7                 ; STA INWK+7
     8112 005A     
28626               
28627 8114 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Set A, X and C flag to random numbers
     8116 8070     
28628 8118 06A0  20        bl   @jsr                       ;
     811A 8002     
28629               
28630 811C D800  22        movb ra,@INWK                   ; STA INWK          ; Set x_lo = random
     811E 0053     
28631               
28632 8120 D801  22        movb rx,@INWK+3                 ; STX INWK+3        ; Set y_lo = random
     8122 0056     
28633                                                                          ;
28634                                                                          ; Note that because we use the value of X returned by
28635                                                                          ; DORND, and X contains the value of A returned by the
28636                                                                          ; previous call to DORND, this does not set the new ship
28637                                                                          ; to a totally random location. See the deep dive on
28638                                                                          ; "Fixing ship positions" for details
28639               
28640 8124 0240  14        andi ra,>80*256                 ; AND #%10000000    ; Set x_sign = bit 7 of x_lo
     8126 8000     
28641 8128 D800  22        movb ra,@INWK+2                 ; STA INWK+2
     812A 0055     
28642               
28643 812C D001  14        movb rx,ra                      ; TXA               ; Set y_sign = bit 7 of y_lo
28644 812E 0240  14        andi ra,>80*256                 ; AND #%10000000
     8130 8000     
28645 8132 D800  22        movb ra,@INWK+5                 ; STA INWK+5
     8134 0058     
28646               
28647 8136 0208  12        li   rarg1,INWK+1               ; ROL INWK+1        ; Set bit 1 of x_hi to the C flag, which is random, so
     8138 0054     
28648 813A 06A0  20        bl   @rol                       ;
     813C 8028     
28649 813E 0208  12        li   rarg1,INWK+1               ; ROL INWK+1        ; this randomly moves us off-centre by 512 (as if x_hi
     8140 0054     
28650 8142 06A0  20        bl   @rol                       ;
     8144 8028     
28651                                                                          ; is %00000010, then (x_hi x_lo) is 512 + x_lo)
28652               
28653 8146 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Set A, X and V flag to random numbers
     8148 8070     
28654 814A 06A0  20        bl   @jsr                       ;
     814C 8002     
28655               
28656                      .bvs MTT4                       ; BVS MTT4          ; If V flag is set (50% chance), jump up to MTT4 to
     **** ****     > BVS
0001 814E 1801  10        joc  !
0002 8150 10A9  10        jmp  MTT4
0003               !:
                   < elite.a99
28657                                                                          ; spawn a trader
28658               
28659 8152 0260  14        ori  ra,>6f*256                 ; ORA #%01101111    ; Take the random number in A and set bits 0-3 and 5-6,
     8154 6F00     
28660 8156 D800  22        movb ra,@INWK+29                ; STA INWK+29       ; so the result has a 50% chance of being positive or
     8158 0070     
28661                                                                          ; negative, and a 50% chance of bits 0-6 being 127.
28662                                                                          ; Storing this number in the roll counter therefore
28663                                                                          ; gives our new ship a fast roll speed with a 50%
28664                                                                          ; chance of having no damping, plus a 50% chance of
28665                                                                          ; rolling clockwise or anti-clockwise
28666               
28667 815A D020  22        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump
     815C 0D55     
28668 815E 161C  10        jne  MTT1                       ; BNE MTT1          ; down to MTT1 to skip the following and potentially
28669                                                                          ; spawn something else
28670               
28671 8160 D001  14        movb rx,ra                      ; TXA               ; Set A to the random X we set above, which we haven't
28672 8162 1807  10        joc  MTT2                       ; BCS MTT2          ; used yet, and if the C flag is set (50% chance) jump
28673                                                                          ; down to MTT2 to skip the following
28674               
28675 8164 0240  14        andi ra,>1f*256                 ; AND #31           ; Set the ship speed to our random number, set to a
     8166 1F00     
28676 8168 0260  14        ori  ra,>10*256                 ; ORA #16           ; minimum of 16 and a maximum of 31
     816A 1000     
28677 816C D800  22        movb ra,@INWK+27                ; STA INWK+27
     816E 006E     
28678               
28679 8170 1704  10        jnc  MTT3                       ; BCC MTT3          ; Jump down to MTT3, skipping the following (this BCC
28680                                                                          ; is effectively a JMP as we know the C flag is clear,
28681                                                                          ; having passed through the BCS above)
28682               
28683               MTT2:
28684 8172 0260  14        ori  ra,>7f*256                 ; ORA #%01111111    ; Set bits 0-6 of A to 127, leaving bit 7 as random, so
     8174 7F00     
28685 8176 D800  22        movb ra,@INWK+30                ; STA INWK+30       ; storing this number in the pitch counter means we have
     8178 0071     
28686                                                                          ; full pitch with no damping, with a 50% chance of
28687                                                                          ; pitching up or down
28688               
28689               MTT3:
28690 817A 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     817C 8070     
28691 817E 06A0  20        bl   @jsr                       ;
     8180 8002     
28692               
28693 8182 0280  14        ci   ra,>05*256                 ; CMP #5            ; Set A to the ship number of an asteroid, and keep
     8184 0500     
28694 8186 0200  12        li   ra,(AST)*256               ; LDA #AST          ; this value for 98.5% of the time (i.e. if random
     8188 0A00     
28695 818A 1802  10        joc  B88                        ; BCS B88           ; A >= 5 then skip the following instruction)
28696               
28697 818C 0200  12        li   ra,(OIL)*256               ; LDA #OIL          ; Set A to the ship number of a cargo canister
     818E 0B00     
28698               
28699               B88:
28700 8190 0206  12        li   rtmp,NWSHP                 ; JSR NWSHP         ; Add our new asteroid or canister to the universe
     8192 6F6E     
28701 8194 06A0  20        bl   @jsr                       ;
     8196 8002     
28702               
28703               * ******************************************************************************
28704               *
28705               * Name: Main game loop (Part 3 of 6)
28706               * Type: Subroutine
28707               * Category: Main loop
28708               * Summary: Potentially spawn a cop, particularly if we've been bad
28709               * Deep dive: Program flow of the main game loop
28710               * Ship data blocks
28711               * Fixing ship positions
28712               *
28713               * ------------------------------------------------------------------------------
28714               *
28715               * This section covers the following:
28716               *
28717               * * Potentially spawn a cop (in a Viper), very rarely if we have been good,
28718               * more often if have been naughty, and very often if we have been properly
28719               * bad
28720               *
28721               * ******************************************************************************
28722               
28723               MTT1:
28724 8198 D020  22        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station's safe zone, jump
     819A 0D55     
28725 819C 1666  10        jne  MLOOP                      ; BNE MLOOP         ; to MLOOP to skip the following
28726               
28727 819E 0206  12        li   rtmp,BAD                   ; JSR BAD           ; Call BAD to work out how much illegal contraband we
     81A0 842A     
28728 81A2 06A0  20        bl   @jsr                       ;
     81A4 8002     
28729                                                                          ; are carrying in our hold (A is up to 40 for a
28730                                                                          ; standard hold crammed with contraband, up to 70 for
28731                                                                          ; an extended cargo hold full of narcotics and slaves)
28732               
28733                      .asla                           ; ASL A             ; Double A to a maximum of 80 or 140
     **** ****     > ASLA
0001 81A6 0240  14        andi ra,>ff00
     81A8 FF00     
0002 81AA 0A10  14        sla  ra,1
                   < elite.a99
28734               
28735 81AC D060  22        movb @MANY+COPS,rx              ; LDX MANY+COPS     ; If there are no cops in the local bubble, skip the
     81AE 0D4F     
28736 81B0 1302  10        jeq  B89                        ; BEQ B89           ; next instruction
28737               
28738 81B2 F020  22        socb @FIST,ra                   ; ORA FIST          ; There are cops in the vicinity and we've got a hold
     81B4 0334     
28739                                                                          ; full of jail time, so OR the value in A with FIST to
28740                                                                          ; get a new value that is at least as high as both
28741                                                                          ; values, to reflect the fact that they have almost
28742                                                                          ; certainly scanned our ship
28743               
28744               B89:
28745 81B6 D800  22        movb ra,@T                      ; STA T             ; Store our badness level in T
     81B8 00D1     
28746               
28747 81BA 0206  12        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     81BC 8026     
28748 81BE 06A0  20        bl   @jsr                       ;
     81C0 8002     
28749                                                                          ; ship, and set A and X to random values
28750                                                                          ;
28751                                                                          ; Note that because Ze uses the value of X returned by
28752                                                                          ; DORND, and X contains the value of A returned by the
28753                                                                          ; previous call to DORND, this does not set the new ship
28754                                                                          ; to a totally random location. See the deep dive on
28755                                                                          ; "Fixing ship positions" for details
28756               
28757 81C2 9020  22        cb   @T,ra                      ; CMP T             ; If the random value in A >= our badness level, which
     81C4 00D1     
28758 81C6 1806  10        joc  B90                        ; BCS B90           ; will be the case unless we have been really, really
28759                                                                          ; bad, then skip the following two instructions (so
28760                                                                          ; if we are really bad, there's a higher chance of
28761                                                                          ; spawning a cop, otherwise we got away with it, for
28762                                                                          ; now)
28763               
28764 81C8 0200  12        li   ra,(COPS)*256              ; LDA #COPS         ; Add a new police ship to the local bubble
     81CA 0200     
28765 81CC 0206  12        li   rtmp,NWSHP                 ; JSR NWSHP
     81CE 6F6E     
28766 81D0 06A0  20        bl   @jsr                       ;
     81D2 8002     
28767               
28768               B90:
28769 81D4 D020  22        movb @MANY+COPS,ra              ; LDA MANY+COPS     ; If we now have at least one cop in the local bubble,
     81D6 0D4F     
28770 81D8 1648  10        jne  MLOOP                      ; BNE MLOOP         ; jump down to MLOOP, otherwise fall through into the
28771                                                                          ; next part to look at spawning something else
28772               
28773               * ******************************************************************************
28774               *
28775               * Name: Main game loop (Part 4 of 6)
28776               * Type: Subroutine
28777               * Category: Main loop
28778               * Summary: Potentially spawn a lone bounty hunter, a Thargoid, or up to four
28779               * pirates
28780               * Deep dive: Program flow of the main game loop
28781               * Ship data blocks
28782               * Fixing ship positions
28783               *
28784               * ------------------------------------------------------------------------------
28785               *
28786               * This section covers the following:
28787               *
28788               * * Potentially spawn (35% chance) either a lone bounty hunter (a Mamba,
28789               * Python or Cobra Mk III), a Thargoid, or a group of up to 4 pirates
28790               * (Sidewinders and/or Mambas)
28791               *
28792               * ******************************************************************************
28793               
28794 81DA 7004  14        sb   rone,ra                    ; DEC EV            ; Decrement EV, the extra vessels spawning delay, and
28795 81DC 1546  10        jgt  MLOOP                      ; BPL MLOOP         ; jump to MLOOP if it is still positive, so we only
28796                                                                          ; do the following when the EV counter runs down
28797               
28798 81DE B004  14        ab   rone,ra                    ; INC EV            ; EV is negative, so bump it up again, setting it back
28799                                                                          ; to 0
28800               
28801 81E0 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     81E2 8070     
28802 81E4 06A0  20        bl   @jsr                       ;
     81E6 8002     
28803               
28804 81E8 D0A0  22        movb @gov_,ry                   ; LDY gov           ; If the government of this system is 0 (anarchy), jump
     81EA 0F1C     
28805 81EC 1308  10        jeq  LABEL_2                    ; BEQ LABEL_2       ; straight to LABEL_2 to start spawning pirates or a
28806                                                                          ; lone bounty hunter
28807               
28808 81EE 0280  14        ci   ra,>5a*256                 ; CMP #90           ; If the random number in A >= 90 (65% chance), jump to
     81F0 5A00     
28809 81F2 183B  10        joc  MLOOP                      ; BCS MLOOP         ; MLOOP to stop spawning (so there's a 35% chance of
28810                                                                          ; spawning pirates or a lone bounty hunter)
28811               
28812 81F4 0240  14        andi ra,>07*256                 ; AND #7            ; Reduce the random number in A to the range 0-7, and
     81F6 0700     
28813 81F8 9020  22        cb   @gov_,ra                   ; CMP gov           ; if A is less than government of this system, jump
     81FA 0F1C     
28814 81FC 1736  10        jnc  MLOOP                      ; BCC MLOOP         ; to MLOOP to stop spawning (so safer governments with
28815                                                                          ; larger gov numbers have a greater chance of jumping
28816                                                                          ; out, which is another way of saying that more
28817                                                                          ; dangerous systems spawn pirates and bounty hunters
28818                                                                          ; more often)
28819               
28820               LABEL_2:
28821                                                                          ; Now to spawn a lone bounty hunter, a Thargoid or a
28822                                                                          ; group of pirates
28823 81FE 0206  12        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     8200 8026     
28824 8202 06A0  20        bl   @jsr                       ;
     8204 8002     
28825                                                                          ; ship, and set A and X to random values
28826                                                                          ;
28827                                                                          ; Note that because Ze uses the value of X returned by
28828                                                                          ; DORND, and X contains the value of A returned by the
28829                                                                          ; previous call to DORND, this does not set the new ship
28830                                                                          ; to a totally random location. See the deep dive on
28831                                                                          ; "Fixing ship positions" for details
28832               
28833 8206 0280  14        ci   ra,>c8*256                 ; CMP #200          ; If the random number in A >= 200 (13% chance), jump
     8208 C800     
28834 820A 181B  10        joc  mt1_                       ; BCS mt1           ; to mt1 to spawn pirates, otherwise keep going to
28835                                                                          ; spawn a lone bounty hunter or a Thargoid
28836               
28837 820C B004  14        ab   rone,ra                    ; INC EV            ; Increase the extra vessels spawning counter, to
28838                                                                          ; prevent the next attempt to spawn extra vessels
28839               
28840 820E 0240  14        andi ra,>03*256                 ; AND #3            ; Set A = Y = random number in the range 3-6, which
     8210 0300     
28841                      .adi (>03*256)                  ; ADC #3            ; we will use to determine the type of ship
     **** ****     > ADI
0001 8212 1701  10        jnc  !
0002 8214 B004  14        ab   rone,ra
0003               !:
0004 8216 0220  14        ai   ra,(>03*256)
     8218 0300     
                   < elite.a99
28842 821A D080  14        movb ra,ry                      ; TAY
28843               
28844                                                                          ; We now build the AI flag for this ship in A
28845               
28846 821C D001  14        movb rx,ra                      ; TXA               ; First, copy the random number in X to A
28847               
28848 821E 0280  14        ci   ra,>c8*256                 ; CMP #200          ; First, set the C flag if X >= 200 (22% chance)
     8220 C800     
28849               
28850 8222 06A0  20        bl   @rola                      ; ROL A             ; Set bit 0 of A to the C flag (i.e. there's a 22%
     8224 8018     
28851                                                                          ; chance of this ship having E.C.M.)
28852               
28853 8226 0260  14        ori  ra,>c0*256                 ; ORA #%11000000    ; Set bits 6 and 7 of A, so the ship is hostile (bit 6)
     8228 C000     
28854                                                                          ; and has AI (bit 7)
28855               
28856 822A 0282  14        ci   ry,>06*256                 ; CPY #6            ; If Y = 6 (i.e. a Thargoid), jump down to the tha
     822C 0600     
28857 822E 1347  10        jeq  tha_                       ; BEQ tha           ; routine in part 6 to decide whether or not to spawn it
28858                                                                          ; (where there's a 22% chance of this happening)
28859               
28860 8230 D800  22        movb ra,@INWK+32                ; STA INWK+32       ; Store A in the AI flag of this ship
     8232 0073     
28861               
28862 8234 D002  14        movb ry,ra                      ; TYA               ; Add a new ship of type Y to the local bubble, so
28863 8236 0206  12        li   rtmp,NWSHP                 ; JSR NWSHP         ; that's a Mamba, Cobra Mk III or Python
     8238 6F6E     
28864 823A 06A0  20        bl   @jsr                       ;
     823C 8002     
28865               
28866               mj1_:
28867 823E 0460  16        b    @MLOOP                     ; JMP MLOOP         ; Jump down to MLOOP, as we are done spawning ships
     8240 826A     
28868               
28869               mt1_:
28870 8242 0240  14        andi ra,>03*256                 ; AND #3            ; It's time to spawn a group of pirates, so set A to a
     8244 0300     
28871                                                                          ; random number in the range 0-3, which will be the
28872                                                                          ; loop counter for spawning pirates below (so we will
28873                                                                          ; spawn 1-4 pirates)
28874               
28875 8246 D800  22        movb ra,@EV                     ; STA EV            ; Delay further spawnings by this number
     8248 0D63     
28876               
28877 824A D800  22        movb ra,@XX13                   ; STA XX13          ; Store the number in XX13, the pirate counter
     824C 0098     
28878               
28879               mt3_:
28880 824E 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     8250 8070     
28881 8252 06A0  20        bl   @jsr                       ;
     8254 8002     
28882               
28883 8256 0240  14        andi ra,>03*256                 ; AND #3            ; Set A to a random number in the range 0-3
     8258 0300     
28884               
28885 825A 0260  14        ori  ra,>01*256                 ; ORA #1            ; Set A to %01 or %11 (Sidewinder or Mamba)
     825C 0100     
28886               
28887 825E 0206  12        li   rtmp,NWSHP                 ; JSR NWSHP         ; Try adding a new ship of type A to the local bubble
     8260 6F6E     
28888 8262 06A0  20        bl   @jsr                       ;
     8264 8002     
28889               
28890 8266 7004  14        sb   rone,ra                    ; DEC XX13          ; Decrement the pirate counter
28891               
28892 8268 15F2  10        jgt  mt3_                       ; BPL mt3           ; If we need more pirates, loop back up to mt3,
28893                                                                          ; otherwise we are done spawning, so fall through into
28894                                                                          ; the end of the main loop at MLOOP
28895               
28896               * ******************************************************************************
28897               *
28898               * Name: Main game loop (Part 5 of 6)
28899               * Type: Subroutine
28900               * Category: Main loop
28901               * Summary: Cool down lasers, make calls to update the dashboard
28902               * Deep dive: Program flow of the main game loop
28903               * The dashboard indicators
28904               *
28905               * ------------------------------------------------------------------------------
28906               *
28907               * This is the first half of the minimal game loop, which we iterate when we are
28908               * docked. This section covers the following:
28909               *
28910               * * Cool down lasers
28911               *
28912               * * Make calls to update the dashboard
28913               *
28914               * ------------------------------------------------------------------------------
28915               *
28916               * Other entry points:
28917               *
28918               * MLOOP               The entry point for the main game loop. This entry point
28919               * comes after the call to the main flight loop and
28920               * spawning routines, so it marks the start of the main
28921               * game loop for when we are docked (as we don't need to
28922               * call the main flight loop or spawning routines if we
28923               * aren't in space)
28924               *
28925               * ******************************************************************************
28926               
28927               MLOOP:
28928 826A 0200  12        li   ra,>01*256                 ; LDA #%00000001    ; Set 6522 System VIA interrupt enable register IER
     826C 0100     
28929 826E D800  30        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. disable the CA2 interrupt,
     8270 FE4E     
28930                                                                          ; which comes from the keyboard)
28931               
28932 8272 0201  12        li   rx,>ff*256                 ; LDX #&FF          ; Set the stack pointer to &01FF, which is the standard
     8274 FF00     
28933 8276 D801  22        movb rx,@rsplb                  ; TXS               ; location for the 6502 stack, so this instruction
     8278 8315     
28934                                                                          ; effectively resets the stack
28935               
28936 827A D060  22        movb @GNTMP,rx                  ; LDX GNTMP         ; If the laser temperature in GNTMP is non-zero,
     827C 0D61     
28937 827E 1301  10        jeq  EE20                       ; BEQ EE20          ; decrement it (i.e. cool it down a bit)
28938 8280 7004  14        sb   rone,ra                    ; DEC GNTMP
28939               
28940               EE20:
28941 8282 0206  12        li   rtmp,DIALS                 ; JSR DIALS         ; Call DIALS to update the dashboard
     8284 3272     
28942 8286 06A0  20        bl   @jsr                       ;
     8288 8002     
28943               
28944 828A D020  22        movb @QQ11,ra                   ; LDA QQ11          ; If this is a space view, skip the following four
     828C 0096     
28945 828E 130A  10        jeq  B91                        ; BEQ B91           ; instructions (i.e. jump to JSR TT17 below)
28946               
28947                      .and @PATG                      ; AND PATG          ; If PATG = &FF (author names are shown on start-up)
     **** ****     > AND
0001 8290 D1A0  22        movb @PATG,rtmp
     8292 0F4C     
0002 8294 0546  10        inv  rtmp
0003 8296 5006  14        szcb rtmp,ra
                   < elite.a99
28948 8298 0910  14        srl  ra,1                       ; LSR A             ; and bit 0 of QQ11 is 1 (the current view is type 1),
28949 829A 1804  10        joc  B91                        ; BCS B91           ; then skip the following instruction
28950               
28951 829C 0206  12        li   rtmp,DELAY-5               ; JSR DELAY-5       ; Delay for 8 vertical syncs (8/50 = 0.16 seconds), to
     829E 4BFB     
28952 82A0 06A0  20        bl   @jsr                       ;
     82A2 8002     
28953                                                                          ; slow the main loop down a bit
28954               
28955               B91:
28956 82A4 0206  12        li   rtmp,TT17                  ; JSR TT17          ; Scan the keyboard for the cursor keys or joystick,
     82A6 7B88     
28957 82A8 06A0  20        bl   @jsr                       ;
     82AA 8002     
28958                                                                          ; returning the cursor's delta values in X and Y and
28959                                                                          ; the key pressed in A
28960               
28961               * ******************************************************************************
28962               *
28963               * Name: Main game loop (Part 6 of 6)
28964               * Type: Subroutine
28965               * Category: Main loop
28966               * Summary: Process non-flight key presses (red function keys, docked keys)
28967               * Deep dive: Program flow of the main game loop
28968               *
28969               * ------------------------------------------------------------------------------
28970               *
28971               * This is the second half of the minimal game loop, which we iterate when we are
28972               * docked. This section covers the following:
28973               *
28974               * * Process more key presses (red function keys, docked keys etc.)
28975               *
28976               * It also supports joining the main loop with a key already "pressed", so we can
28977               * jump into the main game loop to perform a specific action. In practice, this
28978               * is used when we enter the docking bay in BAY to display Status Mode (red key
28979               * f8), and when we finish buying or selling cargo in BAY2 to jump to the
28980               * Inventory (red key f9).
28981               *
28982               * ------------------------------------------------------------------------------
28983               *
28984               * Other entry points:
28985               *
28986               * FRCE                The entry point for the main game loop if we want to
28987               * jump straight to a specific screen, by pretending to
28988               * "press" a key, in which case A contains the internal key
28989               * number of the key we want to "press"
28990               *
28991               * tha                 Consider spawning a Thargoid (22% chance)
28992               *
28993               * ******************************************************************************
28994               
28995               FRCE:
28996 82AC 0206  12        li   rtmp,TT102                 ; JSR TT102         ; Call TT102 to process the key pressed in A
     82AE 82D8     
28997 82B0 06A0  20        bl   @jsr                       ;
     82B2 8002     
28998               
28999 82B4 D020  22        movb @QQ12,ra                   ; LDA QQ12          ; Fetch the docked flag from QQ12 into A
     82B6 009F     
29000               
29001 82B8 16D8  10        jne  MLOOP                      ; BNE MLOOP         ; If we are docked, loop back up to MLOOP just above
29002                                                                          ; to restart the main loop, but skipping all the flight
29003                                                                          ; and spawning code in the top part of the main loop
29004               
29005 82BA 0460  16        b    @TT100                     ; JMP TT100         ; Otherwise jump to TT100 to restart the main loop from
     82BC 80CE     
29006                                                                          ; the start
29007               
29008               tha_:
29009 82BE 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     82C0 8070     
29010 82C2 06A0  20        bl   @jsr                       ;
     82C4 8002     
29011               
29012 82C6 0280  14        ci   ra,>c8*256                 ; CMP #200          ; If A < 200 (78% chance), skip the next instruction
     82C8 C800     
29013 82CA 1704  10        jnc  B92                        ; BCC B92
29014               
29015 82CC 0206  12        li   rtmp,GTHG                  ; JSR GTHG          ; Call GTHG to spawn a Thargoid ship and a Thargon
     82CE 5FF4     
29016 82D0 06A0  20        bl   @jsr                       ;
     82D2 8002     
29017                                                                          ; companion
29018               
29019               B92:
29020 82D4 0460  16        b    @MLOOP                     ; JMP MLOOP         ; Jump back into the main loop at MLOOP, which is just
     82D6 826A     
29021                                                                          ; after the ship-spawning section
29022               
29023               * ******************************************************************************
29024               *
29025               * Name: TT102
29026               * Type: Subroutine
29027               * Category: Keyboard
29028               * Summary: Process function key, save key, hyperspace and chart key presses
29029               * and update the hyperspace counter
29030               *
29031               * ------------------------------------------------------------------------------
29032               *
29033               * Process function key presses, plus "@" (save commander), "H" (hyperspace),
29034               * "D" (show distance to system) and "O" (move chart cursor back to current
29035               * system). We can also pass cursor position deltas in X and Y to indicate that
29036               * the cursor keys or joystick have been used (i.e. the values that are returned
29037               * by routine TT17).
29038               *
29039               * ------------------------------------------------------------------------------
29040               *
29041               * Arguments:
29042               *
29043               * A                   The internal key number of the key pressed (see p.142 of
29044               * the Advanced User Guide for a list of internal key
29045               * numbers)
29046               *
29047               * X                   The amount to move the crosshairs in the x-axis
29048               *
29049               * Y                   The amount to move the crosshairs in the y-axis
29050               *
29051               * ------------------------------------------------------------------------------
29052               *
29053               * Other entry points:
29054               *
29055               * T95                 Print the distance to the selected system
29056               *
29057               * ******************************************************************************
29058               
29059               TT102:
29060 82D8 0280  14        ci   ra,(f8_)*256               ; CMP #f8           ; If red key f8 was pressed, jump to STATUS to show the
     82DA 7600     
29061 82DC 1602  10        jne  B93                        ; BNE B93           ; Status Mode screen, returning from the subroutine
29062 82DE 0460  20        b    @STATUS                    ; JMP STATUS        ; using a tail call
     82E0 2E26     
29063               
29064               B93:
29065 82E2 0280  14        ci   ra,(f4_)*256               ; CMP #f4           ; If red key f4 was pressed, jump to TT22 to show the
     82E4 1400     
29066 82E6 1602  10        jne  B94                        ; BNE B94           ; Long-range Chart, returning from the subroutine using
29067 82E8 0460  20        b    @TT22                      ; JMP TT22          ; a tail call
     82EA 5272     
29068               
29069               B94:
29070 82EC 0280  14        ci   ra,(f5_)*256               ; CMP #f5           ; If red key f5 was pressed, jump to TT23 to show the
     82EE 7400     
29071 82F0 1602  10        jne  B95                        ; BNE B95           ; Short-range Chart, returning from the subroutine using
29072 82F2 0460  20        b    @TT23                      ; JMP TT23          ; a tail call
     82F4 592A     
29073               
29074               B95:
29075 82F6 0280  14        ci   ra,(f6_)*256               ; CMP #f6           ; If red key f6 was pressed, call TT111 to select the
     82F8 7500     
29076 82FA 1606  10        jne  TT92                       ; BNE TT92          ; system nearest to galactic coordinates (QQ9, QQ10)
29077 82FC 0206  12        li   rtmp,TT111                 ; JSR TT111         ; (the location of the chart crosshairs) and jump to
     82FE 5AB8     
29078 8300 06A0  20        bl   @jsr                       ;
     8302 8002     
29079 8304 0460  20        b    @TT25                      ; JMP TT25          ; TT25 to show the Data on System screen, returning
     8306 4F0A     
29080                                                                          ; from the subroutine using a tail call
29081               
29082               TT92:
29083 8308 0280  14        ci   ra,(f9_)*256               ; CMP #f9           ; If red key f9 was pressed, jump to TT213 to show the
     830A 7700     
29084 830C 1602  10        jne  B96                        ; BNE B96           ; Inventory screen, returning from the subroutine
29085 830E 0460  20        b    @TT213                     ; JMP TT213         ; using a tail call
     8310 5778     
29086               
29087               B96:
29088 8312 0280  14        ci   ra,(f7_)*256               ; CMP #f7           ; If red key f7 was pressed, jump to TT167 to show the
     8314 1600     
29089 8316 1602  10        jne  B97                        ; BNE B97           ; Market Price screen, returning from the subroutine
29090 8318 0460  20        b    @TT167                     ; JMP TT167         ; using a tail call
     831A 5E9C     
29091               
29092               B97:
29093 831C 0280  14        ci   ra,(f0_)*256               ; CMP #f0           ; If red key f0 was pressed, jump to TT110 to launch our
     831E 2000     
29094 8320 1602  10        jne  fvw_                       ; BNE fvw           ; ship (if docked), returning from the subroutine using
29095 8322 0460  20        b    @TT110                     ; JMP TT110         ; a tail call
     8324 60FE     
29096               
29097               fvw_:
29098                      .bit @QQ12                      ; BIT QQ12          ; If bit 7 of QQ12 is clear (i.e. we are not docked, but
     **** ****     > BIT
0001 8326 D1A0  22        movb @QQ12,rtmp
     8328 009F     
0002 832A 0546  10        inv  rtmp
0003 832C D1C4  14        movb rone,rtmp2
0004 832E 5187  14        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
29099 8330 1514  10        jgt  INSP                       ; BPL INSP          ; in space), jump to INSP to skip the following checks
29100                                                                          ; for f1-f3 and "@" (save commander file) key presses
29101               
29102 8332 0280  14        ci   ra,(f3_)*256               ; CMP #f3           ; If red key f3 was pressed, jump to EQSHP to show the
     8334 7300     
29103 8336 1602  10        jne  B98                        ; BNE B98           ; Equip Ship screen, returning from the subroutine using
29104 8338 0460  20        b    @EQSHP                     ; JMP EQSHP         ; a tail call
     833A 6230     
29105               
29106               B98:
29107 833C 0280  14        ci   ra,(f1_)*256               ; CMP #f1           ; If red key f1 was pressed, jump to TT219 to show the
     833E 7100     
29108 8340 1602  10        jne  B99                        ; BNE B99           ; Buy Cargo screen, returning from the subroutine using
29109 8342 0460  20        b    @TT219                     ; JMP TT219         ; a tail call
     8344 5476     
29110               
29111               B99:
29112 8346 0280  14        ci   ra,>47*256                 ; CMP #&47          ; If "@" was pressed, jump to SVE to save the commander
     8348 4700     
29113 834A 1602  10        jne  B100                       ; BNE B100          ; file, returning from the subroutine using a tail call
29114 834C 0460  16        b    @SVE                       ; JMP SVE
     834E 8838     
29115               
29116               B100:
29117 8350 0280  14        ci   ra,(f2_)*256               ; CMP #f2           ; If red key f2 was pressed, jump to TT208 to show the
     8352 7200     
29118 8354 160D  10        jne  LABEL_3                    ; BNE LABEL_3       ; Sell Cargo screen, returning from the subroutine using
29119 8356 0460  20        b    @TT208                     ; JMP TT208         ; a tail call
     8358 5654     
29120               
29121               INSP:
29122 835A 0280  14        ci   ra,(f1_)*256               ; CMP #f1           ; If the key pressed is < red key f1 or > red key f3,
     835C 7100     
29123 835E 1708  10        jnc  LABEL_3                    ; BCC LABEL_3       ; jump to LABEL_3 (so only do the following if the key
29124 8360 0280  14        ci   ra,(f3_+1)*256             ; CMP #f3+1         ; pressed is f1, f2 or f3)
     8362 7400     
29125 8364 1805  10        joc  LABEL_3                    ; BCS LABEL_3
29126               
29127 8366 0240  14        andi ra,>03*256                 ; AND #3            ; If we get here then we are either in space, or we are
     8368 0300     
29128 836A D040  14        movb ra,rx                      ; TAX               ; docked and none of f1-f3 were pressed, so we can now
29129 836C 0460  20        b    @LOOK1                     ; JMP LOOK1         ; process f1-f3 with their in-flight functions, i.e.
     836E 4AC4     
29130                                                                          ; switching space views
29131                                                                          ;
29132                                                                          ; A will contain &71, &72 or &73 (for f1, f2 or f3), so
29133                                                                          ; set X to the last digit (1, 2 or 3) and jump to LOOK1
29134                                                                          ; to switch to view X (rear, left or right), returning
29135                                                                          ; from the subroutine using a tail call
29136               
29137               LABEL_3:
29138 8370 0280  14        ci   ra,>54*256                 ; CMP #&54          ; If "H" was pressed, jump to hyp to do a hyperspace
     8372 5400     
29139 8374 1602  10        jne  B101                       ; BNE B101          ; jump (if we are in space), returning from the
29140 8376 0460  20        b    @hyp_                      ; JMP hyp           ; subroutine using a tail call
     8378 5C2C     
29141               
29142               B101:
29143 837A 0280  14        ci   ra,>32*256                 ; CMP #&32          ; If "D" was pressed, jump to T95 to print the distance
     837C 3200     
29144 837E 133B  10        jeq  T95                        ; BEQ T95           ; to a system (if we are in one of the chart screens)
29145               
29146 8380 D800  22        movb ra,@T1                     ; STA T1            ; Store A (the key that's been pressed) in T1
     8382 0006     
29147               
29148 8384 D020  22        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is a chart (QQ11 = 64 or 128),
     8386 0096     
29149 8388 0240  14        andi ra,>c0*256                 ; AND #%11000000    ; keep going, otherwise jump down to TT107 to skip the
     838A C000     
29150 838C 1318  10        jeq  TT107                      ; BEQ TT107         ; following
29151               
29152 838E D020  22        movb @QQ22+1,ra                 ; LDA QQ22+1        ; If the on-screen hyperspace counter is non-zero,
     8390 002F     
29153 8392 1615  10        jne  TT107                      ; BNE TT107         ; then we are already counting down, so jump to TT107
29154                                                                          ; to skip the following
29155               
29156 8394 D020  22        movb @T1,ra                     ; LDA T1            ; Restore the original value of A (the key that's been
     8396 0006     
29157                                                                          ; pressed) from T1
29158               
29159 8398 0280  14        ci   ra,>36*256                 ; CMP #&36          ; If "O" was pressed, do the following three jumps,
     839A 3600     
29160 839C 160C  10        jne  ee2_                       ; BNE ee2           ; otherwise skip to ee2 to continue
29161               
29162 839E 0206  12        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     83A0 5872     
29163 83A2 06A0  20        bl   @jsr                       ;
     83A4 8002     
29164                                                                          ; which will erase the crosshairs currently there
29165               
29166 83A6 0206  12        li   rtmp,ping_                 ; JSR ping          ; Set the target system to the current system (which
     83A8 7C20     
29167 83AA 06A0  20        bl   @jsr                       ;
     83AC 8002     
29168                                                                          ; will move the location in (QQ9, QQ10) to the current
29169                                                                          ; home system
29170               
29171 83AE 0206  12        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     83B0 5872     
29172 83B2 06A0  20        bl   @jsr                       ;
     83B4 8002     
29173                                                                          ; which will draw the crosshairs at our current home
29174                                                                          ; system
29175               
29176               ee2_:
29177 83B6 0206  12        li   rtmp,TT16                  ; JSR TT16          ; Call TT16 to move the crosshairs by the amount in X
     83B8 580E     
29178 83BA 06A0  20        bl   @jsr                       ;
     83BC 8002     
29179                                                                          ; and Y, which were passed to this subroutine as
29180                                                                          ; arguments
29181               
29182               TT107:
29183 83BE D020  22        movb @QQ22+1,ra                 ; LDA QQ22+1        ; If the on-screen hyperspace counter is zero, return
     83C0 002F     
29184 83C2 1317  10        jeq  t95_                       ; BEQ t95           ; from the subroutine (as t95 contains an RTS), as we
29185                                                                          ; are not currently counting down to a hyperspace jump
29186               
29187 83C4 7004  14        sb   rone,ra                    ; DEC QQ22          ; Decrement the internal hyperspace counter
29188               
29189 83C6 1615  10        jne  t95_                       ; BNE t95           ; If the internal hyperspace counter is still non-zero,
29190                                                                          ; then we are still counting down, so return from the
29191                                                                          ; subroutine (as t95 contains an RTS)
29192               
29193                                                                          ; If we get here then the internal hyperspace counter
29194                                                                          ; has just reached zero and it wasn't zero before, so
29195                                                                          ; we need to reduce the on-screen counter and update
29196                                                                          ; the screen. We do this by first printing the next
29197                                                                          ; number in the countdown sequence, and then printing
29198                                                                          ; the old number, which will erase the old number
29199                                                                          ; and display the new one because printing uses EOR
29200                                                                          ; logic
29201               
29202 83C8 D060  22        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Set X = the on-screen hyperspace counter - 1
     83CA 002F     
29203 83CC 7044  14        sb   rone,rx                    ; DEX               ; (i.e. the next number in the sequence)
29204               
29205 83CE 0206  12        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1)
     83D0 5D36     
29206 83D2 06A0  20        bl   @jsr                       ;
     83D4 8002     
29207               
29208 83D6 0200  12        li   ra,>05*256                 ; LDA #5            ; Reset the internal hyperspace counter to 5
     83D8 0500     
29209 83DA D800  22        movb ra,@QQ22                   ; STA QQ22
     83DC 002E     
29210               
29211 83DE D060  22        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Set X = the on-screen hyperspace counter (i.e. the
     83E0 002F     
29212                                                                          ; current number in the sequence, which is already
29213                                                                          ; shown on-screen)
29214               
29215 83E2 0206  12        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1),
     83E4 5D36     
29216 83E6 06A0  20        bl   @jsr                       ;
     83E8 8002     
29217                                                                          ; i.e. print the hyperspace countdown in the top-left
29218                                                                          ; corner
29219               
29220 83EA 7004  14        sb   rone,ra                    ; DEC QQ22+1        ; Decrement the on-screen hyperspace countdown
29221               
29222 83EC 1602  10        jne  t95_                       ; BNE t95           ; If the countdown is not yet at zero, return from the
29223                                                                          ; subroutine (as t95 contains an RTS)
29224               
29225 83EE 0460  20        b    @TT18                      ; JMP TT18          ; Otherwise the countdown has finished, so jump to TT18
     83F0 607C     
29226                                                                          ; to do a hyperspace jump, returning from the subroutine
29227                                                                          ; using a tail call
29228               
29229               t95_:
29230 83F2 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     83F4 800E     
29231               
29232               T95:
29233                                                                          ; If we get here, "D" was pressed, so we need to show
29234                                                                          ; the distance to the selected system (if we are in a
29235                                                                          ; chart view)
29236 83F6 D020  22        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is a chart (QQ11 = 64 or 128),
     83F8 0096     
29237 83FA 0240  14        andi ra,>c0*256                 ; AND #%11000000    ; keep going, otherwise return from the subroutine (as
     83FC C000     
29238 83FE 13F9  10        jeq  t95_                       ; BEQ t95           ; t95 contains an RTS)
29239               
29240 8400 0206  12        li   rtmp,hm_                   ; JSR hm            ; Call hm to move the crosshairs to the target system
     8402 4C10     
29241 8404 06A0  20        bl   @jsr                       ;
     8406 8002     
29242                                                                          ; in (QQ9, QQ10), returning with A = 0
29243               
29244 8408 D800  22        movb ra,@QQ17                   ; STA QQ17          ; Set QQ17 = 0 to switch to ALL CAPS
     840A 007E     
29245               
29246 840C 0206  12        li   rtmp,cpl_                  ; JSR cpl           ; Print control code 3 (the selected system name)
     840E 65B8     
29247 8410 06A0  20        bl   @jsr                       ;
     8412 8002     
29248               
29249 8414 0200  12        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     8416 8000     
29250 8418 D800  22        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     841A 007E     
29251               
29252 841C 0200  12        li   ra,>01*256                 ; LDA #1            ; Move the text cursor to column 1 and down one line
     841E 0100     
29253 8420 D800  22        movb ra,@XC                     ; STA XC            ; (in other words, to the start of the next line)
     8422 002C     
29254 8424 B004  14        ab   rone,ra                    ; INC YC
29255               
29256 8426 0460  20        b    @TT146                     ; JMP TT146         ; Print the distance to the selected system and return
     8428 4EA2     
29257                                                                          ; from the subroutine using a tail call
29258               
29259               * ******************************************************************************
29260               *
29261               * Name: BAD
29262               * Type: Subroutine
29263               * Category: Status
29264               * Summary: Calculate how bad we have been
29265               *
29266               * ------------------------------------------------------------------------------
29267               *
29268               * Work out how bad we are from the amount of contraband in our hold. The
29269               * formula is:
29270               *
29271               * (slaves + narcotics) * 2 + firearms
29272               *
29273               * so slaves and narcotics are twice as illegal as firearms. The value in FIST
29274               * (our legal status) is set to at least this value whenever we launch from a
29275               * space station, and a FIST of 50 or more gives us fugitive status, so leaving a
29276               * station carrying 25 tonnes of slaves/narcotics, or 50 tonnes of firearms
29277               * across multiple trips, is enough to make us a fugitive.
29278               *
29279               * ------------------------------------------------------------------------------
29280               *
29281               * Returns:
29282               *
29283               * A                   A value that determines how bad we are from the amount
29284               * of contraband in our hold
29285               *
29286               * ******************************************************************************
29287               
29288               BAD:
29289 842A D020  22        movb @QQ20+3,ra                 ; LDA QQ20+3        ; Set A to the number of tonnes of slaves in the hold
     842C 031A     
29290               
29291                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 842E 0A13  14        sla  rzero,1
                   < elite.a99
29292                                                                          ; C flag affecting the result
29293               
29294                      .adc @QQ20+6,ra                 ; ADC QQ20+6        ; Add the number of tonnes of narcotics in the hold
     **** ****     > ADC
0001 8430 1701  10        jnc  !
0002 8432 B004  14        ab   rone,ra
0003               !:
0004 8434 B020  22        ab   @QQ20+6,ra
     8436 031D     
                   < elite.a99
29295               
29296                      .asla                           ; ASL A             ; Double the result and add the number of tonnes of
     **** ****     > ASLA
0001 8438 0240  14        andi ra,>ff00
     843A FF00     
0002 843C 0A10  14        sla  ra,1
                   < elite.a99
29297                      .adc @QQ20+10,ra                ; ADC QQ20+10       ; firearms in the hold
     **** ****     > ADC
0001 843E 1701  10        jnc  !
0002 8440 B004  14        ab   rone,ra
0003               !:
0004 8442 B020  22        ab   @QQ20+10,ra
     8444 0321     
                   < elite.a99
29298               
29299 8446 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8448 800E     
29300               
29301               * ******************************************************************************
29302               *
29303               * Name: FAROF
29304               * Type: Subroutine
29305               * Category: Maths (Geometry)
29306               * Summary: Compare x_hi, y_hi and z_hi with 224
29307               *
29308               * ------------------------------------------------------------------------------
29309               *
29310               * Compare x_hi, y_hi and z_hi with 224, and set the C flag if all three <= 224,
29311               * otherwise clear the C flag.
29312               *
29313               * ------------------------------------------------------------------------------
29314               *
29315               * Returns:
29316               *
29317               * C flag              Set if x_hi <= 224 and y_hi <= 224 and z_hi <= 224
29318               *
29319               * Clear otherwise (i.e. if any one of them are bigger than
29320               * 224)
29321               *
29322               * ******************************************************************************
29323               
29324               FAROF:
29325 844A 0200  12        li   ra,>e0*256                 ; LDA #224          ; Set A = 224 and fall through into FAROF2 to do the
     844C E000     
29326                                                                          ; comparison
29327               
29328               * ******************************************************************************
29329               *
29330               * Name: FAROF2
29331               * Type: Subroutine
29332               * Category: Maths (Geometry)
29333               * Summary: Compare x_hi, y_hi and z_hi with A
29334               *
29335               * ------------------------------------------------------------------------------
29336               *
29337               * Compare x_hi, y_hi and z_hi with A, and set the C flag if all three <= A,
29338               * otherwise clear the C flag.
29339               *
29340               * ------------------------------------------------------------------------------
29341               *
29342               * Returns:
29343               *
29344               * C flag              Set if x_hi <= A and y_hi <= A and z_hi <= A
29345               *
29346               * Clear otherwise (i.e. if any one of them are bigger than
29347               * A)
29348               *
29349               * ******************************************************************************
29350               
29351               FAROF2:
29352 844E 9020  22        cb   @INWK+1,ra                 ; CMP INWK+1        ; If A < x_hi, C will be clear so jump to MA34 to
     8450 0054     
29353 8452 1705  10        jnc  MA34                       ; BCC MA34          ; return from the subroutine with C clear, otherwise
29354                                                                          ; C will be set so move on to the next one
29355               
29356 8454 9020  22        cb   @INWK+4,ra                 ; CMP INWK+4        ; If A < y_hi, C will be clear so jump to MA34 to
     8456 0057     
29357 8458 1702  10        jnc  MA34                       ; BCC MA34          ; return from the subroutine with C clear, otherwise
29358                                                                          ; C will be set so move on to the next one
29359               
29360 845A 9020  22        cb   @INWK+7,ra                 ; CMP INWK+7        ; If A < z_hi, C will be clear, otherwise C will be set
     845C 005A     
29361               
29362               MA34:
29363 845E 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8460 800E     
29364               
29365               * ******************************************************************************
29366               *
29367               * Name: MAS4
29368               * Type: Subroutine
29369               * Category: Maths (Geometry)
29370               * Summary: Calculate a cap on the maximum distance to a ship
29371               *
29372               * ------------------------------------------------------------------------------
29373               *
29374               * Logical OR the value in A with the high bytes of the ship's position (x_hi,
29375               * y_hi and z_hi).
29376               *
29377               * ------------------------------------------------------------------------------
29378               *
29379               * Returns:
29380               *
29381               * A                   A OR x_hi OR y_hi OR z_hi
29382               *
29383               * ******************************************************************************
29384               
29385               MAS4:
29386 8462 F020  22        socb @INWK+1,ra                 ; ORA INWK+1        ; OR A with x_hi, y_hi and z_hi
     8464 0054     
29387 8466 F020  22        socb @INWK+4,ra                 ; ORA INWK+4
     8468 0057     
29388 846A F020  22        socb @INWK+7,ra                 ; ORA INWK+7
     846C 005A     
29389               
29390 846E 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8470 800E     
29391               
29392               * ******************************************************************************
29393               *
29394               * Name: DEATH
29395               * Type: Subroutine
29396               * Category: Start and end
29397               * Summary: Display the death screen
29398               *
29399               * ------------------------------------------------------------------------------
29400               *
29401               * We have been killed, so display the chaos of our destruction above a "GAME
29402               * OVER" sign, and clean up the mess ready for the next attempt.
29403               *
29404               * ******************************************************************************
29405               
29406               DEATH:
29407 8472 0206  12        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of us dying
     8474 8B22     
29408 8476 06A0  20        bl   @jsr                       ;
     8478 8002     
29409               
29410 847A 0206  12        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     847C 7F26     
29411 847E 06A0  20        bl   @jsr                       ;
     8480 8002     
29412               
29413                      .asl @DELTA                     ; ASL DELTA         ; Divide our speed in DELTA by 4
     **** ****     > ASL
0001 8482 D1A0  22        movb @DELTA,rtmp
     8484 008C     
0002 8486 0246  14        andi rtmp,>ff00
     8488 FF00     
0003 848A 0A16  14        sla  rtmp,1
0004 848C D806  22        movb rtmp,@DELTA
     848E 008C     
                   < elite.a99
29414                      .asl @DELTA                     ; ASL DELTA
     **** ****     > ASL
0001 8490 D1A0  22        movb @DELTA,rtmp
     8492 008C     
0002 8494 0246  14        andi rtmp,>ff00
     8496 FF00     
0003 8498 0A16  14        sla  rtmp,1
0004 849A D806  22        movb rtmp,@DELTA
     849C 008C     
                   < elite.a99
29415               
29416 849E 0201  12        li   rx,>18*256                 ; LDX #24           ; Set the screen to only show 24 text rows, which hides
     84A0 1800     
29417 84A2 0206  12        li   rtmp,DET1                  ; JSR DET1          ; the dashboard, setting A to 6 in the process
     84A4 6CB4     
29418 84A6 06A0  20        bl   @jsr                       ;
     84A8 8002     
29419               
29420 84AA 0206  12        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     84AC 4B2A     
29421 84AE 06A0  20        bl   @jsr                       ;
     84B0 8002     
29422                                                                          ; and set the current view type in QQ11 to 6 (death
29423                                                                          ; screen)
29424               
29425 84B2 0206  12        li   rtmp,BOX                   ; JSR BOX           ; Call BOX to redraw the same white border (BOX is part
     84B4 4B6A     
29426 84B6 06A0  20        bl   @jsr                       ;
     84B8 8002     
29427                                                                          ; of TT66), which removes the border as it is drawn
29428                                                                          ; using EOR logic
29429               
29430 84BA 0206  12        li   rtmp,nWq                   ; JSR nWq           ; Create a cloud of stardust containing the correct
     84BC 6BE0     
29431 84BE 06A0  20        bl   @jsr                       ;
     84C0 8002     
29432                                                                          ; number of dust particles (i.e. NOSTM of them)
29433               
29434 84C2 0200  12        li   ra,>0c*256                 ; LDA #12           ; Move the text cursor to column 12 on row 12
     84C4 0C00     
29435 84C6 D800  22        movb ra,@YC                     ; STA YC
     84C8 002D     
29436 84CA D800  22        movb ra,@XC                     ; STA XC
     84CC 002C     
29437               
29438 84CE 0200  12        li   ra,>92*256                 ; LDA #146          ; Print recursive token 146 ("{all caps}GAME OVER")
     84D0 9200     
29439 84D2 0206  12        li   rtmp,ex_                   ; JSR ex
     84D4 67F6     
29440 84D6 06A0  20        bl   @jsr                       ;
     84D8 8002     
29441               
29442               D1:
29443 84DA 0206  12        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     84DC 8026     
29444 84DE 06A0  20        bl   @jsr                       ;
     84E0 8002     
29445                                                                          ; ship, and set A and X to random values
29446               
29447 84E2 0910  14        srl  ra,1                       ; LSR A             ; Set A = A / 4, so A is now between 0 and 63, and
29448 84E4 0910  14        srl  ra,1                       ; LSR A             ; store in byte #0 (x_lo)
29449 84E6 D800  22        movb ra,@INWK                   ; STA INWK
     84E8 0053     
29450               
29451 84EA 0202  12        li   ry,>00*256                 ; LDY #0            ; Set the following to 0: the current view in QQ11
     84EC 0000     
29452 84EE D802  22        movb ry,@QQ11                   ; STY QQ11          ; (space view), x_hi, y_hi, z_hi and the AI flag (no AI
     84F0 0096     
29453 84F2 D802  22        movb ry,@INWK+1                 ; STY INWK+1        ; or E.C.M. and not hostile)
     84F4 0054     
29454 84F6 D802  22        movb ry,@INWK+4                 ; STY INWK+4
     84F8 0057     
29455 84FA D802  22        movb ry,@INWK+7                 ; STY INWK+7
     84FC 005A     
29456 84FE D802  22        movb ry,@INWK+32                ; STY INWK+32
     8500 0073     
29457               
29458 8502 7084  14        sb   rone,ry                    ; DEY               ; Set Y = 255
29459               
29460 8504 D802  22        movb ry,@MCNT                   ; STY MCNT          ; Reset the main loop counter to 255, so all timer-based
     8506 0099     
29461                                                                          ; calls will be stopped
29462               
29463 8508 D802  22        movb ry,@LASCT                  ; STY LASCT         ; Set the laser count to 255 to act as a counter in the
     850A 0D60     
29464                                                                          ; D2 loop below, so this setting determines how long the
29465                                                                          ; death animation lasts (it's 5.1 seconds, as LASCT is
29466                                                                          ; decremented every vertical sync, or 50 times a second,
29467                                                                          ; and 255 / 50 = 5.1)
29468               
29469                      .eoi (>2a*256)                  ; EOR #%00101010    ; Flip bits 1, 3 and 5 in A (x_lo) to get another number
     **** ****     > EOI
0001 850C 0206  12        li   rtmp,(>2A*256)
     850E 2A00     
0002 8510 2806  14        xor  rtmp,ra
                   < elite.a99
29470 8512 D800  22        movb ra,@INWK+3                 ; STA INWK+3        ; between 48 and 63, and store in byte #3 (y_lo)
     8514 0056     
29471               
29472 8516 0260  14        ori  ra,>50*256                 ; ORA #%01010000    ; Set bits 4 and 6 of A to bump it up to between 112 and
     8518 5000     
29473 851A D800  22        movb ra,@INWK+6                 ; STA INWK+6        ; 127, and store in byte #6 (z_lo)
     851C 0059     
29474               
29475 851E D001  14        movb rx,ra                      ; TXA               ; Set A to the random number in X and keep bits 0-3 and
29476 8520 0240  14        andi ra,>8f*256                 ; AND #%10001111    ; the sign in bit 7 to get a number between -15 and +15,
     8522 8F00     
29477 8524 D800  22        movb ra,@INWK+29                ; STA INWK+29       ; and store in byte #29 (roll counter) to give our ship
     8526 0070     
29478                                                                          ; a gentle roll with damping
29479               
29480 8528 06A0  20        bl   @rora                      ; ROR A             ; The C flag is randomly set from the above call to Ze,
     852A 803C     
29481 852C 0240  14        andi ra,>87*256                 ; AND #%10000111    ; so this sets A to a number between -7 and +7, which
     852E 8700     
29482 8530 D800  22        movb ra,@INWK+30                ; STA INWK+30       ; we store in byte #30 (the pitch counter) to give our
     8532 0071     
29483                                                                          ; ship a very gentle pitch with damping
29484               
29485                      .php                            ; PHP               ; Store the processor flags
     **** ****     > PHP
0001 8534 02C6   8        stst rtmp
0002 8536 D686  26        movb rtmp,*rsp
0003 8538 060A  10        dec  rsp
                   < elite.a99
29486               
29487 853A 0201  12        li   rx,(OIL)*256               ; LDX #OIL          ; Call fq1 with X set to #OIL, which adds a new cargo
     853C 0B00     
29488 853E 0206  12        li   rtmp,fq1_                  ; JSR fq1           ; canister to our local bubble of universe and points it
     8540 3C08     
29489 8542 06A0  20        bl   @jsr                       ;
     8544 8002     
29490                                                                          ; away from us with double DELTA speed (i.e. 6, as DELTA
29491                                                                          ; was set to 3 by the call to RES2 above). INF is set to
29492                                                                          ; point to the canister's ship data block in K%
29493               
29494                      .plp                            ; PLP               ; Restore the processor flags, including our random C
     **** ****     > PLP
0001 8546 058A  10        INC  rsp
0002 8548 D19A  22        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
29495                                                                          ; flag from before
29496               
29497 854A 0200  12        li   ra,>00*256                 ; LDA #0            ; Set bit 7 of A to our random C flag and store in byte
     854C 0000     
29498 854E 06A0  20        bl   @rora                      ; ROR A             ; #31 of the ship's data block, so this has a 50% chance
     8550 803C     
29499 8552 0202  12        li   ry,>1f*256                 ; LDY #31           ; of marking our new canister as being killed (so it
     8554 1F00     
29500                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; will explode)
     **** ****     > ST_IND_Y_IDX
0001 8556 D820  30        movb @INF,@rtmplb
     8558 0020     
     855A 830D     
0002 855C D1A0  22        movb @INF+1,rtmp
     855E 0021     
0003 8560 A182  14        a    ry,rtmp
0004 8562 D580  26        movb RA,*rtmp
                   < elite.a99
29501               
29502 8564 D020  22        movb @FRIN+3,ra                 ; LDA FRIN+3        ; The call we made to RES2 before we entered the loop at
     8566 0D43     
29503 8568 13B8  10        jeq  D1                         ; BEQ D1            ; D1 will have reset all the ship slots at FRIN, so this
29504                                                                          ; checks to see if the fourth slot is empty, and if it
29505                                                                          ; is we loop back to D1 to add another canister, until
29506                                                                          ; we have added four of them
29507               
29508 856A 0206  12        li   rtmp,U.                    ; JSR U%            ; Clear the key logger, which also sets A = 0
     856C 8CEA     
29509 856E 06A0  20        bl   @jsr                       ;
     8570 8002     
29510               
29511 8572 D800  22        movb ra,@DELTA                  ; STA DELTA         ; Set our speed in DELTA to 0, as we aren't going
     8574 008C     
29512                                                                          ; anywhere any more
29513               
29514               D2:
29515 8576 0206  12        li   rtmp,M.                    ; JSR M%            ; Call the M% routine to do the main flight loop once,
     8578 0F52     
29516 857A 06A0  20        bl   @jsr                       ;
     857C 8002     
29517                                                                          ; which will display our exploding canister scene and
29518                                                                          ; move everything about
29519               
29520 857E D020  22        movb @LASCT,ra                  ; LDA LASCT         ; Loop back to D2 to run the main flight loop until
     8580 0D60     
29521 8582 16F9  10        jne  D2                         ; BNE D2            ; LASCT reaches zero (which will take 5.1 seconds, as
29522                                                                          ; explained above)
29523               
29524 8584 0201  12        li   rx,>1f*256                 ; LDX #31           ; Set the screen to show all 31 text rows, which shows
     8586 1F00     
29525 8588 0206  12        li   rtmp,DET1                  ; JSR DET1          ; the dashboard
     858A 6CB4     
29526 858C 06A0  20        bl   @jsr                       ;
     858E 8002     
29527               
29528                                                                          ; Fall through into DEATH2 to reset and restart the game
29529               
29530               * ******************************************************************************
29531               *
29532               * Name: DEATH2
29533               * Type: Subroutine
29534               * Category: Start and end
29535               * Summary: Reset most of the game and restart from the title screen
29536               *
29537               * ------------------------------------------------------------------------------
29538               *
29539               * This routine is called following death, and when the game is quit by pressing
29540               * ESCAPE when paused.
29541               *
29542               * ******************************************************************************
29543               
29544               DEATH2:
29545 8590 0206  12        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     8592 7F26     
29546 8594 06A0  20        bl   @jsr                       ;
     8596 8002     
29547                                                                          ; and fall through into the entry code for the game
29548                                                                          ; to restart from the title screen
29549               
29550               * ******************************************************************************
29551               *
29552               * Name: TT170
29553               * Type: Subroutine
29554               * Category: Start and end
29555               * Summary: Main entry point for the Elite game code
29556               * Deep dive: Program flow of the main game loop
29557               *
29558               * ------------------------------------------------------------------------------
29559               *
29560               * This is the main entry point for the main game code.
29561               *
29562               * ******************************************************************************
29563               
29564               TT170:
29565 8598 0201  12        li   rx,>ff*256                 ; LDX #&FF          ; Set the stack pointer to &01FF, which is the standard
     859A FF00     
29566 859C D801  22        movb rx,@rsplb                  ; TXS               ; location for the 6502 stack, so this instruction
     859E 8315     
29567                                                                          ; effectively resets the stack. We need to do this
29568                                                                          ; because the loader code in elite-loader.asm pushes
29569                                                                          ; code onto the stack, and this effectively removes that
29570                                                                          ; code so we start afresh
29571               
29572                                                                          ; Fall through into BR1 to start the game
29573               
29574               * ******************************************************************************
29575               *
29576               * Name: BR1 (Part 1 of 2)
29577               * Type: Subroutine
29578               * Category: Start and end
29579               * Summary: Show the "Load New Commander (Y/N)?" screen and start the game
29580               *
29581               * ------------------------------------------------------------------------------
29582               *
29583               * BRKV is set to point to BR1 by the loading process.
29584               *
29585               * ******************************************************************************
29586               
29587               BR1:
29588 85A0 0201  12        li   rx,>03*256                 ; LDX #3            ; Set XC = 3 (set text cursor to column 3)
     85A2 0300     
29589 85A4 D801  22        movb rx,@XC                     ; STX XC
     85A6 002C     
29590               
29591 85A8 0206  12        li   rtmp,FX200                 ; JSR FX200         ; Disable the ESCAPE key and clear memory if the BREAK
     85AA 895E     
29592 85AC 06A0  20        bl   @jsr                       ;
     85AE 8002     
29593                                                                          ; key is pressed (*FX 200,3)
29594               
29595 85B0 0201  12        li   rx,(CYL)*256               ; LDX #CYL          ; Call TITLE to show a rotating Cobra Mk III (#CYL) and
     85B2 0700     
29596 85B4 0200  12        li   ra,>80*256                 ; LDA #128          ; token 128 ("  LOAD NEW COMMANDER (Y/N)?{crlf}{crlf}"),
     85B6 8000     
29597 85B8 0206  12        li   rtmp,TITLE                 ; JSR TITLE         ; returning with the internal number of the key pressed
     85BA 8660     
29598 85BC 06A0  20        bl   @jsr                       ;
     85BE 8002     
29599                                                                          ; in A
29600               
29601 85C0 0280  14        ci   ra,>44*256                 ; CMP #&44          ; Did we press "Y"? If not, jump to QU5, otherwise
     85C2 4400     
29602 85C4 1610  10        jne  QU5                        ; BNE QU5           ; continue on to load a new commander
29603               
29604               * BR1                    \ These instructions are commented out in the original
29605               * LDX #3                 \ source. This block starts with the same *FX call as
29606               * STX XC                 \ above, then clears the screen, calls a routine to
29607               * JSR FX200              \ flush the keyboard buffer (FLKB) that isn't present
29608               * LDA #1                 \ in the cassette version but is in other versions,
29609               * JSR TT66               \ and then it displays "LOAD NEW COMMANDER (Y/N)?" and
29610               * JSR FLKB               \ lists the current cargo, before falling straight into
29611               * LDA #14                \ the load routine below, whether or not we have
29612               * JSR TT214              \ pressed "Y". This may be a bit of testing code, as the
29613               * BCC QU5                \ first line is a commented label, BR1, which is where
29614                                                                          ; BRKV points, so when this is uncommented, pressing
29615                                                                          ; the BREAK key should jump straight to the load screen
29616               
29617 85C6 0206  12        li   rtmp,GTNME                 ; JSR GTNME         ; We want to load a new commander, so we need to get
     85C8 87A4     
29618 85CA 06A0  20        bl   @jsr                       ;
     85CC 8002     
29619                                                                          ; the commander name to load
29620               
29621 85CE 0206  12        li   rtmp,LOD                   ; JSR LOD           ; We then call the LOD subroutine to load the commander
     85D0 8918     
29622 85D2 06A0  20        bl   @jsr                       ;
     85D4 8002     
29623                                                                          ; file to address NA%+8, which is where we store the
29624                                                                          ; commander save file
29625               
29626 85D6 0206  12        li   rtmp,TRNME                 ; JSR TRNME         ; Once loaded, we copy the commander name to NA%
     85D8 8780     
29627 85DA 06A0  20        bl   @jsr                       ;
     85DC 8002     
29628               
29629 85DE 0206  12        li   rtmp,TTX66                 ; JSR TTX66         ; And we clear the top part of the screen and draw a
     85E0 4B2E     
29630 85E2 06A0  20        bl   @jsr                       ;
     85E4 8002     
29631                                                                          ; white border
29632               
29633               * ******************************************************************************
29634               *
29635               * Name: QU5
29636               * Type: Subroutine
29637               * Category: Start and end
29638               * Summary: Reset the current commander data block to the last saved commander
29639               *
29640               * ******************************************************************************
29641               
29642               QU5:
29643                                                                          ; By the time we get here, the correct commander name
29644                                                                          ; is at NA% and the correct commander data is at NA%+8.
29645                                                                          ; Specifically:
29646                                                                          ;
29647                                                                          ; * If we loaded a commander file, then the name and
29648                                                                          ; data from that file will be at NA% and NA%+8
29649                                                                          ;
29650                                                                          ; * If this is a brand new game, then NA% will contain
29651                                                                          ; the default starting commander name ("JAMESON")
29652                                                                          ; and NA%+8 will contain the default commander data
29653                                                                          ;
29654                                                                          ; * If this is not a new game (because they died or
29655                                                                          ; quit) and we didn't want to load a commander file,
29656                                                                          ; then NA% will contain the last saved commander
29657                                                                          ; name, and NA%+8 the last saved commander data. If
29658                                                                          ; the game has never been saved, this will still be
29659                                                                          ; the default commander
29660               * JSR TTX66              \ This instruction is commented out in the original
29661                                                                          ; source; it clears the screen and draws a border
29662 85E6 0201  12        li   rx,(NT.)*256               ; LDX #NT%          ; The size of the commander data block is NT% bytes,
     85E8 4B00     
29663                                                                          ; and it starts at NA%+8, so we need to copy the data
29664                                                                          ; from the "last saved" buffer at NA%+8 to the current
29665                                                                          ; commander workspace at TP. So we set up a counter in X
29666                                                                          ; for the NT% bytes that we want to copy
29667               
29668               QUL1:
29669 85EA D021  26        movb @NA.+7(rx),ra              ; LDA NA%+7,X       ; Copy the X-th byte of NA%+7 to the X-th byte of TP-1,
     85EC 21CF     
29670 85EE D840  30        movb ra,@TP-1(rx)               ; STA TP-1,X        ; (the -1 is because X is counting down from NT% to 1)
     85F0 02FF     
29671               
29672 85F2 7044  14        sb   rone,rx                    ; DEX               ; Decrement the loop counter
29673               
29674 85F4 16FA  10        jne  QUL1                       ; BNE QUL1          ; Loop back for the next byte of the commander data
29675                                                                          ; block
29676               
29677 85F6 D801  22        movb rx,@QQ11                   ; STX QQ11          ; X is 0 by the end of the above loop, so this sets QQ11
     85F8 0096     
29678                                                                          ; to 0, which means we will be showing a view without a
29679                                                                          ; boxed title at the top (i.e. we're going to use the
29680                                                                          ; screen layout of a space view in the following)
29681               
29682                                                                          ; If the commander check below fails, we keep jumping
29683                                                                          ; back to here to crash the game with an infinite loop
29684               
29685               B102:
29686 85FA 0206  12        li   rtmp,CHECK                 ; JSR CHECK         ; Call the CHECK subroutine to calculate the checksum
     85FC 8762     
29687 85FE 06A0  20        bl   @jsr                       ;
     8600 8002     
29688                                                                          ; for the current commander block at NA%+8 and put it
29689                                                                          ; in A
29690               
29691 8602 9020  26        cb   @CHK,ra                    ; CMP CHK           ; Test the calculated checksum against CHK
     8604 221E     
29692               
29694               
29695 8606 1000  10        nop                             ; NOP               ; If we have disabled checksums, then ignore the result
29696 8608 1000  10        nop                             ; NOP               ; of the comparison and fall through into the next part
29697               
29706               
29707                                                                          ; The checksum CHK is correct, so now we check whether
29708                                                                          ; CHK2 = CHK EOR A9, and if this check fails, bit 7 of
29709                                                                          ; the competition flags at COK gets set, to indicate
29710                                                                          ; to Acornsoft via the competition code that there has
29711                                                                          ; been some hacking going on with this competition entry
29712               
29713                      .eoi (>a9*256)                  ; EOR #&A9          ; X = checksum EOR &A9
     **** ****     > EOI
0001 860A 0206  12        li   rtmp,(>A9*256)
     860C A900     
0002 860E 2806  14        xor  rtmp,ra
                   < elite.a99
29714 8610 D040  14        movb ra,rx                      ; TAX
29715               
29716 8612 D020  22        movb @COK,ra                    ; LDA COK           ; Set A to the competition flags in COK
     8614 030E     
29717               
29718 8616 9060  26        cb   @CHK2,rx                   ; CPX CHK2          ; If X = CHK2, then skip the next instruction
     8618 221D     
29719 861A 1302  10        jeq  tZ                         ; BEQ tZ
29720               
29721 861C 0260  14        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 of A to indicate this commander file has
     861E 8000     
29722                                                                          ; been tampered with
29723               
29724               tZ:
29725 8620 0260  14        ori  ra,>02*256                 ; ORA #%00000010    ; Set bit 1 of A to denote that this is the cassette
     8622 0200     
29726                                                                          ; version
29727               
29728 8624 D800  22        movb ra,@COK                    ; STA COK           ; Store the updated competition flags in COK
     8626 030E     
29729               
29730               * ******************************************************************************
29731               *
29732               * Name: BR1 (Part 2 of 2)
29733               * Type: Subroutine
29734               * Category: Start and end
29735               * Summary: Show the "Press Fire or Space, Commander" screen and start the
29736               * game
29737               *
29738               * ------------------------------------------------------------------------------
29739               *
29740               * BRKV is set to point to BR1 by the loading process.
29741               *
29742               * ******************************************************************************
29743               
29744 8628 0206  12        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     862A 7FDC     
29745 862C 06A0  20        bl   @jsr                       ;
     862E 8002     
29746                                                                          ; them are targeted
29747               
29748 8630 0200  12        li   ra,>93*256                 ; LDA #147          ; Call TITLE to show a rotating Mamba (#3) and token
     8632 9300     
29749 8634 0201  12        li   rx,>03*256                 ; LDX #3            ; 147 ("PRESS FIRE OR SPACE,COMMANDER.{crlf}{crlf}"),
     8636 0300     
29750 8638 0206  12        li   rtmp,TITLE                 ; JSR TITLE         ; returning with the internal number of the key pressed
     863A 8660     
29751 863C 06A0  20        bl   @jsr                       ;
     863E 8002     
29752                                                                          ; in A
29753               
29754 8640 0206  12        li   rtmp,ping_                 ; JSR ping          ; Set the target system coordinates (QQ9, QQ10) to the
     8642 7C20     
29755 8644 06A0  20        bl   @jsr                       ;
     8646 8002     
29756                                                                          ; current system coordinates (QQ0, QQ1) we just loaded
29757               
29758 8648 0206  12        li   rtmp,hyp1_                 ; JSR hyp1          ; Arrive in the system closest to (QQ9, QQ10)
     864A 5F28     
29759 864C 06A0  20        bl   @jsr                       ;
     864E 8002     
29760               
29761                                                                          ; Fall through into the docking bay routine below
29762               
29763               * ******************************************************************************
29764               *
29765               * Name: BAY
29766               * Type: Subroutine
29767               * Category: Status
29768               * Summary: Go to the docking bay (i.e. show the Status Mode screen)
29769               *
29770               * ------------------------------------------------------------------------------
29771               *
29772               * We end up here after the start-up process (load commander etc.), as well as
29773               * after a successful save, an escape pod launch, a successful docking, the end
29774               * of a cargo sell, and various errors (such as not having enough cash, entering
29775               * too many items when buying, trying to fit an item to your ship when you
29776               * already have it, running out of cargo space, and so on).
29777               *
29778               * ******************************************************************************
29779               
29780               BAY:
29781 8650 0200  12        li   ra,>ff*256                 ; LDA #&FF          ; Set QQ12 = &FF (the docked flag) to indicate that we
     8652 FF00     
29782 8654 D800  22        movb ra,@QQ12                   ; STA QQ12          ; are docked
     8656 009F     
29783               
29784 8658 0200  12        li   ra,(f8_)*256               ; LDA #f8           ; Jump into the main loop at FRCE, setting the key
     865A 7600     
29785 865C 0460  16        b    @FRCE                      ; JMP FRCE          ; that's "pressed" to red key f8 (so we show the Status
     865E 82AC     
29786                                                                          ; Mode screen)
29787               
29788               * ******************************************************************************
29789               *
29790               * Name: TITLE
29791               * Type: Subroutine
29792               * Category: Start and end
29793               * Summary: Display a title screen with a rotating ship and prompt
29794               *
29795               * ------------------------------------------------------------------------------
29796               *
29797               * Display the title screen, with a rotating ship and a text token at the bottom
29798               * of the screen.
29799               *
29800               * ------------------------------------------------------------------------------
29801               *
29802               * Arguments:
29803               *
29804               * A                   The number of the recursive token to show below the
29805               * rotating ship (see variable QQ18 for details of
29806               * recursive tokens)
29807               *
29808               * X                   The type of the ship to show (see variable XX21 for a
29809               * list of ship types)
29810               *
29811               * ------------------------------------------------------------------------------
29812               *
29813               * Returns:
29814               *
29815               * X                   If a key is being pressed, X contains the internal key
29816               * number, otherwise it contains 0
29817               *
29818               * ******************************************************************************
29819               
29820               TITLE:
29821                      .pha                            ; PHA               ; Store the token number on the stack for later
     **** ****     > PHA
0001 8660 D680  26        movb ra,*rsp
0002 8662 060A  10        dec  rsp
                   < elite.a99
29822               
29823 8664 D801  22        movb rx,@TYPE                   ; STX TYPE          ; Store the ship type in location TYPE
     8666 009B     
29824               
29825 8668 0206  12        li   rtmp,RESET                 ; JSR RESET         ; Reset our ship so we can use it for the rotating
     866A 7EFE     
29826 866C 06A0  20        bl   @jsr                       ;
     866E 8002     
29827                                                                          ; title ship
29828               
29829 8670 0200  12        li   ra,>01*256                 ; LDA #1            ; Clear the top part of the screen, draw a white border,
     8672 0100     
29830 8674 0206  12        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 1
     8676 4B2A     
29831 8678 06A0  20        bl   @jsr                       ;
     867A 8002     
29832               
29833 867C 7004  14        sb   rone,ra                    ; DEC QQ11          ; Decrement QQ11 to 0, so from here on we are using a
29834                                                                          ; space view
29835               
29836 867E 0200  12        li   ra,>60*256                 ; LDA #96           ; Set nosev_z hi = 96 (96 is the value of unity in the
     8680 6000     
29837 8682 D800  22        movb ra,@INWK+14                ; STA INWK+14       ; rotation vector)
     8684 0061     
29838               
29839               * LSR A                  \ This instruction is commented out in the original
29840                                                                          ; source. It would halve the value of z_hi to 48, so the
29841                                                                          ; ship would start off closer to the viewer
29842               
29843 8686 D800  22        movb ra,@INWK+7                 ; STA INWK+7        ; Set z_hi, the high byte of the ship's z-coordinate,
     8688 005A     
29844                                                                          ; to 96, which is the distance at which the rotating
29845                                                                          ; ship starts out before coming towards us
29846               
29847 868A 0201  12        li   rx,>7f*256                 ; LDX #127          ; Set roll counter = 127, so don't dampen the roll and
     868C 7F00     
29848 868E D801  22        movb rx,@INWK+29                ; STX INWK+29       ; make the roll direction clockwise
     8690 0070     
29849               
29850 8692 D801  22        movb rx,@INWK+30                ; STX INWK+30       ; Set pitch counter = 127, so don't dampen the pitch and
     8694 0071     
29851                                                                          ; set the pitch direction to dive
29852               
29853 8696 B044  14        ab   rone,rx                    ; INX               ; Set QQ17 to 128 (so bit 7 is set) to switch to
29854 8698 D801  22        movb rx,@QQ17                   ; STX QQ17          ; Sentence Case, with the next letter printing in upper
     869A 007E     
29855                                                                          ; case
29856               
29857 869C D020  22        movb @TYPE,ra                   ; LDA TYPE          ; Set up a new ship, using the ship type in TYPE
     869E 009B     
29858 86A0 0206  12        li   rtmp,NWSHP                 ; JSR NWSHP
     86A2 6F6E     
29859 86A4 06A0  20        bl   @jsr                       ;
     86A6 8002     
29860               
29861 86A8 0202  12        li   ry,>06*256                 ; LDY #6            ; Move the text cursor to column 6
     86AA 0600     
29862 86AC D802  22        movb ry,@XC                     ; STY XC
     86AE 002C     
29863               
29864 86B0 0206  12        li   rtmp,DELAY                 ; JSR DELAY         ; Delay for 6 vertical syncs (6/50 = 0.12 seconds)
     86B2 4C00     
29865 86B4 06A0  20        bl   @jsr                       ;
     86B6 8002     
29866               
29867 86B8 0200  12        li   ra,>1e*256                 ; LDA #30           ; Print recursive token 144 ("---- E L I T E ----")
     86BA 1E00     
29868 86BC 0206  12        li   rtmp,plf_                  ; JSR plf           ; followed by a newline
     86BE 66C4     
29869 86C0 06A0  20        bl   @jsr                       ;
     86C2 8002     
29870               
29871 86C4 0202  12        li   ry,>06*256                 ; LDY #6            ; Move the text cursor to column 6 again
     86C6 0600     
29872 86C8 D802  22        movb ry,@XC                     ; STY XC
     86CA 002C     
29873               
29874 86CC B004  14        ab   rone,ra                    ; INC YC            ; Move the text cursor down a row
29875               
29876 86CE D020  22        movb @PATG,ra                   ; LDA PATG          ; If PATG = 0, skip the following two lines, which
     86D0 0F4C     
29877 86D2 1306  10        jeq  awe_                       ; BEQ awe           ; print the author credits (PATG can be toggled by
29878                                                                          ; pausing the game and pressing "X")
29879               
29880 86D4 0200  12        li   ra,>fe*256                 ; LDA #254          ; Print recursive token 94 ("BY D.BRABEN & I.BELL")
     86D6 FE00     
29881 86D8 0206  12        li   rtmp,TT27                  ; JSR TT27
     86DA 66DC     
29882 86DC 06A0  20        bl   @jsr                       ;
     86DE 8002     
29883               
29884               awe_:
29885 86E0 0206  12        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     86E2 4C2E     
29886 86E4 06A0  20        bl   @jsr                       ;
     86E6 8002     
29887                                                                          ; and move the text cursor to column 1 on row 21, i.e.
29888                                                                          ; the start of the top row of the three bottom rows.
29889                                                                          ; It also returns with Y = 0
29890               
29891 86E8 D802  22        movb ry,@DELTA                  ; STY DELTA         ; Set DELTA = 0 (i.e. ship speed = 0)
     86EA 008C     
29892               
29893 86EC D802  22        movb ry,@JSTK                   ; STY JSTK          ; Set JSTK = 0 (i.e. keyboard, not joystick)
     86EE 0F50     
29894               
29895                      .pla                            ; PLA               ; Restore the recursive token number we stored on the
     **** ****     > PLA
0001 86F0 058A  10        inc  rsp
0002 86F2 D01A  22        movb *rsp,ra
                   < elite.a99
29896 86F4 0206  12        li   rtmp,ex_                   ; JSR ex            ; stack at the start of this subroutine, and print that
     86F6 67F6     
29897 86F8 06A0  20        bl   @jsr                       ;
     86FA 8002     
29898                                                                          ; token
29899               
29900 86FC 0200  12        li   ra,>94*256                 ; LDA #148          ; Set A to recursive token 148
     86FE 9400     
29901               
29902 8700 0201  12        li   rx,>07*256                 ; LDX #7            ; Move the text cursor to column 7
     8702 0700     
29903 8704 D801  22        movb rx,@XC                     ; STX XC
     8706 002C     
29904               
29905 8708 0206  12        li   rtmp,ex_                   ; JSR ex            ; Print recursive token 148 ("(C) ACORNSOFT 1984")
     870A 67F6     
29906 870C 06A0  20        bl   @jsr                       ;
     870E 8002     
29907               
29908               TLL2:
29909 8710 D020  22        movb @INWK+7,ra                 ; LDA INWK+7        ; If z_hi (the ship's distance) is 1, jump to TL1 to
     8712 005A     
29910 8714 0280  14        ci   ra,>01*256                 ; CMP #1            ; skip the following decrement
     8716 0100     
29911 8718 1301  10        jeq  TL1                        ; BEQ TL1
29912               
29913 871A 7004  14        sb   rone,ra                    ; DEC INWK+7        ; Decrement the ship's distance, to bring the ship
29914                                                                          ; a bit closer to us
29915               
29916               TL1:
29917 871C 0206  12        li   rtmp,MVEIT                 ; JSR MVEIT         ; Move the ship in space according to the orientation
     871E 17E2     
29918 8720 06A0  20        bl   @jsr                       ;
     8722 8002     
29919                                                                          ; vectors and the new value in z_hi
29920               
29921 8724 0200  12        li   ra,>80*256                 ; LDA #128          ; Set z_lo = 128, so the closest the ship gets to us is
     8726 8000     
29922 8728 D800  22        movb ra,@INWK+6                 ; STA INWK+6        ; z_hi = 1, z_lo = 128, or 256 + 128 = 384
     872A 0059     
29923               
29924                      .asla                           ; ASL A             ; Set A = 0
     **** ****     > ASLA
0001 872C 0240  14        andi ra,>ff00
     872E FF00     
0002 8730 0A10  14        sla  ra,1
                   < elite.a99
29925               
29926 8732 D800  22        movb ra,@INWK                   ; STA INWK          ; Set x_lo = 0, so the ship remains in the screen centre
     8734 0053     
29927               
29928 8736 D800  22        movb ra,@INWK+3                 ; STA INWK+3        ; Set y_lo = 0, so the ship remains in the screen centre
     8738 0056     
29929               
29930 873A 0206  12        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to display the ship
     873C 94A8     
29931 873E 06A0  20        bl   @jsr                       ;
     8740 8002     
29932               
29933 8742 7004  14        sb   rone,ra                    ; DEC MCNT          ; Decrement the main loop counter
29934               
29935 8744 D020  26        movb @VIA+>40,ra                ; LDA VIA+&40       ; Read 6522 System VIA input register IRB (SHEILA &40)
     8746 FE40     
29936               
29937 8748 0240  14        andi ra,>10*256                 ; AND #%00010000    ; Bit 4 of IRB (PB4) is clear if joystick 1's fire
     874A 1000     
29938                                                                          ; button is pressed, otherwise it is set, so AND'ing
29939                                                                          ; the value of IRB with %10000 extracts this bit
29940               
29941               * TAX                    \ This instruction is commented out in the original
29942                                                                          ; source; it would have no effect, as the comparison
29943                                                                          ; flags are already set by the AND, and the value of X
29944                                                                          ; is not used anywhere
29945               
29946 874C 1307  10        jeq  TL2                        ; BEQ TL2           ; If the joystick fire button is pressed, jump to TL2
29947               
29948 874E 0206  12        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press
     8750 8AE8     
29949 8752 06A0  20        bl   @jsr                       ;
     8754 8002     
29950               
29951 8756 13DC  10        jeq  TLL2                       ; BEQ TLL2          ; If no key was pressed, loop back up to move/rotate
29952                                                                          ; the ship and check again for a key press
29953               
29954 8758 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     875A 800E     
29955               
29956               TL2:
29957 875C 7004  14        sb   rone,ra                    ; DEC JSTK          ; Joystick fire button was pressed, so set JSTK to &FF
29958                                                                          ; (it was set to 0 above), to disable keyboard and
29959                                                                          ; enable joysticks
29960               
29961 875E 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8760 800E     
29962               
29963               * ******************************************************************************
29964               *
29965               * Name: CHECK
29966               * Type: Subroutine
29967               * Category: Save and load
29968               * Summary: Calculate the checksum for the last saved commander data block
29969               * Deep dive: Commander save files
29970               *
29971               * ------------------------------------------------------------------------------
29972               *
29973               * The checksum for the last saved commander data block is saved as part of the
29974               * commander file, in two places (CHK AND CHK2), to protect against file
29975               * tampering. This routine calculates the checksum and returns it in A.
29976               *
29977               * This algorithm is also implemented in elite-checksum.py.
29978               *
29979               * ------------------------------------------------------------------------------
29980               *
29981               * Returns:
29982               *
29983               * A                   The checksum for the last saved commander data block
29984               *
29985               * ******************************************************************************
29986               
29987               CHECK:
29988 8762 0201  12        li   rx,(NT.-2)*256             ; LDX #NT%-2        ; Set X to the size of the commander data block, less
     8764 4900     
29989                                                                          ; 2 (to omit the checksum bytes and the save count)
29990               
29991                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 8766 0A13  14        sla  rzero,1
                   < elite.a99
29992                                                                          ; C flag affecting the result
29993               
29994 8768 D001  14        movb rx,ra                      ; TXA               ; Seed the checksum calculation by setting A to the
29995                                                                          ; size of the commander data block, less 2
29996               
29997                                                                          ; We now loop through the commander data block,
29998                                                                          ; starting at the end and looping down to the start
29999                                                                          ; (so at the start of this loop, the X-th byte is the
30000                                                                          ; last byte of the commander data block, i.e. the save
30001                                                                          ; count)
30002               
30003               QUL2:
30004                      .adc @NA.+7(rx),ra              ; ADC NA%+7,X       ; Add the X-1-th byte of the data block to A, plus the
     **** ****     > ADC
0001 876A 1701  10        jnc  !
0002 876C B004  14        ab   rone,ra
0003               !:
0004 876E B021  26        ab   @NA.+7(RX),ra
     8770 21CF     
                   < elite.a99
30005                                                                          ; C flag
30006               
30007                      .eor @NA.+8(rx)                 ; EOR NA%+8,X       ; EOR A with the X-th byte of the data block
     **** ****     > EOR
0001 8772 D1A1  26        movb @NA.+8(RX),rtmp
     8774 21D0     
0002 8776 2806  14        xor  rtmp,ra
                   < elite.a99
30008               
30009 8778 7044  14        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30010               
30011 877A 16F7  10        jne  QUL2                       ; BNE QUL2          ; Loop back for the next byte in the calculation, until
30012                                                                          ; we have added byte #0 and EOR'd with byte #1 of the
30013                                                                          ; data block
30014               
30015 877C 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     877E 800E     
30016               
30017               * ******************************************************************************
30018               *
30019               * Name: TRNME
30020               * Type: Subroutine
30021               * Category: Save and load
30022               * Summary: Copy the last saved commander's name from INWK to NA%
30023               *
30024               * ******************************************************************************
30025               
30026               TRNME:
30027 8780 0201  12        li   rx,>07*256                 ; LDX #7            ; The commander's name can contain a maximum of 7
     8782 0700     
30028                                                                          ; characters, and is terminated by a carriage return,
30029                                                                          ; so set up a counter in X to copy 8 characters
30030               
30031               GTL1:
30032 8784 D021  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Copy the X-th byte of INWK to the X-th byte of NA%
     8786 0053     
30033 8788 D840  30        movb ra,@NA.(rx)                ; STA NA%,X
     878A 21C8     
30034               
30035 878C 7044  14        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30036               
30037 878E 15FA  10        jgt  GTL1                       ; BPL GTL1          ; Loop back until we have copied all 8 bytes
30038               
30039                                                                          ; Fall through into TR1 to copy the name back from NA%
30040                                                                          ; to INWK. This isn't necessary as the name is already
30041                                                                          ; there, but it does save one byte, as we don't need an
30042                                                                          ; RTS here
30043               
30044               * ******************************************************************************
30045               *
30046               * Name: TR1
30047               * Type: Subroutine
30048               * Category: Save and load
30049               * Summary: Copy the last saved commander's name from NA% to INWK
30050               *
30051               * ******************************************************************************
30052               
30053               TR1:
30054 8790 0201  12        li   rx,>07*256                 ; LDX #7            ; The commander's name can contain a maximum of 7
     8792 0700     
30055                                                                          ; characters, and is terminated by a carriage return,
30056                                                                          ; so set up a counter in X to copy 8 characters
30057               
30058               GTL2:
30059 8794 D021  26        movb @NA.(rx),ra                ; LDA NA%,X         ; Copy the X-th byte of NA% to the X-th byte of INWK
     8796 21C8     
30060 8798 D840  30        movb ra,@INWK(rx)               ; STA INWK,X
     879A 0053     
30061               
30062 879C 7044  14        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30063               
30064 879E 15FA  10        jgt  GTL2                       ; BPL GTL2          ; Loop back until we have copied all 8 bytes
30065               
30066 87A0 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     87A2 800E     
30067               
30068               * ******************************************************************************
30069               *
30070               * Name: GTNME
30071               * Type: Subroutine
30072               * Category: Save and load
30073               * Summary: Fetch the name of a commander file to save or load
30074               *
30075               * ------------------------------------------------------------------------------
30076               *
30077               * Get the commander's name for loading or saving a commander file. The name is
30078               * stored in the INWK workspace and is terminated by a return character (13).
30079               *
30080               * If ESCAPE is pressed or a blank name is entered, then the name stored is set
30081               * to the name from the last saved commander block.
30082               *
30083               * ------------------------------------------------------------------------------
30084               *
30085               * Returns:
30086               *
30087               * INWK                The commander name entered, terminated by a return
30088               * character (13)
30089               *
30090               * ******************************************************************************
30091               
30092               GTNME:
30093 87A4 0200  12        li   ra,>01*256                 ; LDA #1            ; Clear the top part of the screen, draw a white border,
     87A6 0100     
30094 87A8 0206  12        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 1
     87AA 4B2A     
30095 87AC 06A0  20        bl   @jsr                       ;
     87AE 8002     
30096               
30097 87B0 0200  12        li   ra,>7b*256                 ; LDA #123          ; Print recursive token 123 ("{crlf}COMMANDER'S NAME? ")
     87B2 7B00     
30098 87B4 0206  12        li   rtmp,TT27                  ; JSR TT27
     87B6 66DC     
30099 87B8 06A0  20        bl   @jsr                       ;
     87BA 8002     
30100               
30101 87BC 0206  12        li   rtmp,DEL8                  ; JSR DEL8          ; Wait for 8/50 of a second (0.16 seconds)
     87BE 4BFC     
30102 87C0 06A0  20        bl   @jsr                       ;
     87C2 8002     
30103               
30104 87C4 0200  12        li   ra,>81*256                 ; LDA #%10000001    ; Clear 6522 System VIA interrupt enable register IER
     87C6 8100     
30105 87C8 D800  30        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
     87CA FE4E     
30106                                                                          ; which comes from the keyboard)
30107               
30108 87CC 0200  12        li   ra,>0f*256                 ; LDA #15           ; Call OSBYTE with A = 15 (flush all buffers)
     87CE 0F00     
30109 87D0 D040  14        movb ra,rx                      ; TAX
30110 87D2 0206  12        li   rtmp,OSBYTE                ; JSR OSBYTE
     87D4 FFF4     
30111 87D6 06A0  20        bl   @jsr                       ;
     87D8 8002     
30112               
30113 87DA 0201  12        li   rx,((RLINE)%256)*256       ; LDX #LO(RLINE)    ; Set (Y X) to point to the RLINE parameter block
     87DC 0800     
30114 87DE 0202  12        li   ry,((RLINE)/256)*256       ; LDY #HI(RLINE)    ; configuration block below
     87E0 8800     
30115               
30116 87E2 0200  12        li   ra,>00*256                 ; LDA #0            ; Call OSWORD with A = 0 to read a line from the current
     87E4 0000     
30117 87E6 0206  12        li   rtmp,OSWORD                ; JSR OSWORD        ; input stream (i.e. the keyboard)
     87E8 FFF1     
30118 87EA 06A0  20        bl   @jsr                       ;
     87EC 8002     
30119               
30120               * LDA #%00000001         \ These instructions are commented out in the original
30121               * STA VIA+&4E            \ source, but they would set 6522 System VIA interrupt
30122                                                                          ; enable register IER (SHEILA &4E) bit 1 (i.e. disable
30123                                                                          ; the CA2 interrupt, which comes from the keyboard)
30124               
30125 87EE 18D0  10        joc  TR1                        ; BCS TR1           ; The C flag will be set if we pressed ESCAPE when
30126                                                                          ; entering the name, in which case jump to TR1 to copy
30127                                                                          ; the last saved commander's name from NA% to INWK
30128                                                                          ; and return from the subroutine there
30129               
30130 87F0 D002  14        movb ry,ra                      ; TYA               ; The OSWORD call returns the length of the commander's
30131                                                                          ; name in Y, so transfer this to A
30132               
30133 87F2 13CE  10        jeq  TR1                        ; BEQ TR1           ; If A = 0, no name was entered, so jump to TR1 to copy
30134                                                                          ; the last saved commander's name from NA% to INWK
30135                                                                          ; and return from the subroutine there
30136               
30137 87F4 0460  20        b    @TT67                      ; JMP TT67          ; We have a name, so jump to TT67 to print a newline
     87F6 4EE6     
30138                                                                          ; and return from the subroutine using a tail call
30139               
30140               * ******************************************************************************
30141               *
30142               * Name: RLINE
30143               * Type: Variable
30144               * Category: Text
30145               * Summary: The OSWORD configuration block used to fetch a line of text from
30146               * the keyboard
30147               *
30148               * ******************************************************************************
30149               
30150               RLINE:
30151 87F8 0053            data INWK                                           ; The address to store the input, so the commander's
30152                                                                          ; name will be stored in INWK as it is typed
30153               
30154 87FA 07              byte >07                                            ; Maximum line length = 7, as that's the maximum size
30155                                                                          ; for a commander's name
30156               
30157 87FB   21            byte '!'                                            ; Allow ASCII characters from "!" through to "z" in
30158 87FC 7A              byte 'z'                                            ; the name
30159               
30160               * ******************************************************************************
30161               *
30162               * Name: ZERO
30163               * Type: Subroutine
30164               * Category: Utility routines
30165               * Summary: Zero-fill pages &9, &A, &B, &C and &D
30166               *
30167               * ------------------------------------------------------------------------------
30168               *
30169               * This resets the following workspaces to zero:
30170               *
30171               * * The ship data blocks ascending from K% at &0900
30172               *
30173               * * The ship line heap descending from WP at &0D40
30174               *
30175               * * WP workspace variables from FRIN to de, which include the ship slots for
30176               * the local bubble of universe, and various flight and ship status variables
30177               * (only a portion of the LSX/LSO sun line heap is cleared)
30178               *
30179               * ******************************************************************************
30180               
30181               ZERO:
30182 87FE 0201  12        li   rx,>0d*256                 ; LDX #&D           ; Point X to page &D
     8800 0D00     
30183               
30184               ZEL:
30185 8802 0206  12        li   rtmp,ZES1                  ; JSR ZES1          ; Call ZES1 to zero-fill the page in X
     8804 8812     
30186 8806 06A0  20        bl   @jsr                       ;
     8808 8002     
30187               
30188 880A 7044  14        sb   rone,rx                    ; DEX               ; Decrement X to point to the next page
30189               
30190 880C 0281  14        ci   rx,>09*256                 ; CPX #9            ; If X is > 9 (i.e. is &A, &B or &C), then loop back
     880E 0900     
30191 8810 16F8  10        jne  ZEL                        ; BNE ZEL           ; up to clear the next page
30192               
30193                                                                          ; Then fall through into ZES1 with X set to 9, so we
30194                                                                          ; clear page &9 too
30195               
30196               * ******************************************************************************
30197               *
30198               * Name: ZES1
30199               * Type: Subroutine
30200               * Category: Utility routines
30201               * Summary: Zero-fill the page whose number is in X
30202               *
30203               * ------------------------------------------------------------------------------
30204               *
30205               * Arguments:
30206               *
30207               * X                   The page we want to zero-fill
30208               *
30209               * ******************************************************************************
30210               
30211               ZES1:
30212 8812 0202  12        li   ry,>00*256                 ; LDY #0            ; If we set Y = SC = 0 and fall through into ZES2
     8814 0000     
30213 8816 D802  22        movb ry,@SC                     ; STY SC            ; below, then we will zero-fill 255 bytes starting from
     8818 0007     
30214                                                                          ; SC - in other words, we will zero-fill the whole of
30215                                                                          ; page X
30216               
30217               * ******************************************************************************
30218               *
30219               * Name: ZES2
30220               * Type: Subroutine
30221               * Category: Utility routines
30222               * Summary: Zero-fill a specific page
30223               *
30224               * ------------------------------------------------------------------------------
30225               *
30226               * Zero-fill from address (X SC) + Y to (X SC) + &FF.
30227               *
30228               * ------------------------------------------------------------------------------
30229               *
30230               * Arguments:
30231               *
30232               * X                   The high byte (i.e. the page) of the starting point of
30233               * the zero-fill
30234               *
30235               * Y                   The offset from (X SC) where we start zeroing, counting
30236               * up to &FF
30237               *
30238               * SC                  The low byte (i.e. the offset into the page) of the
30239               * starting point of the zero-fill
30240               *
30241               * ------------------------------------------------------------------------------
30242               *
30243               * Returns:
30244               *
30245               * Z flag              Z flag is set
30246               *
30247               * ******************************************************************************
30248               
30249               ZES2:
30250 881A 0200  12        li   ra,>00*256                 ; LDA #0            ; Load A with the byte we want to fill the memory block
     881C 0000     
30251                                                                          ; with - i.e. zero
30252               
30253 881E D801  22        movb rx,@SC+1                   ; STX SC+1          ; We want to zero-fill page X, so store this in the
     8820 0008     
30254                                                                          ; high byte of SC, so the 16-bit address in SC and
30255                                                                          ; SC+1 is now pointing to the SC-th byte of page X
30256               
30257               ZEL1:
30258                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Zero the Y-th byte of the block pointed to by SC,
     **** ****     > ST_IND_Y_IDX
0001 8822 D820  30        movb @SC,@rtmplb
     8824 0007     
     8826 830D     
0002 8828 D1A0  22        movb @SC+1,rtmp
     882A 0008     
0003 882C A182  14        a    ry,rtmp
0004 882E D580  26        movb RA,*rtmp
                   < elite.a99
30259                                                                          ; so that's effectively the Y-th byte before SC
30260               
30261 8830 B084  14        ab   rone,ry                    ; INY               ; Increment the loop counter
30262               
30263 8832 16F7  10        jne  ZEL1                       ; BNE ZEL1          ; Loop back to zero the next byte
30264               
30265 8834 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8836 800E     
30266               
30267               * ******************************************************************************
30268               *
30269               * Name: SVE
30270               * Type: Subroutine
30271               * Category: Save and load
30272               * Summary: Save the commander file
30273               * Deep dive: Commander save files
30274               * The competition code
30275               *
30276               * ******************************************************************************
30277               
30278               SVE:
30279 8838 0206  12        li   rtmp,GTNME                 ; JSR GTNME         ; Clear the screen and ask for the commander filename
     883A 87A4     
30280 883C 06A0  20        bl   @jsr                       ;
     883E 8002     
30281                                                                          ; to save, storing the name at INWK
30282               
30283 8840 0206  12        li   rtmp,TRNME                 ; JSR TRNME         ; Transfer the commander filename from INWK to NA%
     8842 8780     
30284 8844 06A0  20        bl   @jsr                       ;
     8846 8002     
30285               
30286 8848 0206  12        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     884A 87FE     
30287 884C 06A0  20        bl   @jsr                       ;
     884E 8002     
30288                                                                          ; the ship data blocks, the ship line heap, the ship
30289                                                                          ; slots for the local bubble of universe, and various
30290                                                                          ; flight and ship status variables
30291               
30292                      .lsr @SVC                       ; LSR SVC           ; Halve the save count value in SVC
     **** ****     > LSR
0001 8850 D1A0  22        movb @SVC,rtmp
     8852 0349     
0002 8854 0916  14        srl  rtmp,1
0003 8856 D806  22        movb rtmp,@SVC
     8858 0349     
                   < elite.a99
30293               
30294 885A 0201  12        li   rx,(NT.)*256               ; LDX #NT%          ; We now want to copy the current commander data block
     885C 4B00     
30295                                                                          ; from location TP to the last saved commander block at
30296                                                                          ; NA%+8, so set a counter in X to copy the NT% bytes in
30297                                                                          ; the commander data block
30298                                                                          ;
30299                                                                          ; We also want to copy the data block to another
30300                                                                          ; location &0B00, which is normally used for the ship
30301                                                                          ; lines heap
30302               
30303               SVL1:
30304 885E D021  26        movb @TP(rx),ra                 ; LDA TP,X          ; Copy the X-th byte of TP to the X-th byte of &0B00
     8860 0300     
30305 8862 D840  30        movb ra,@>0B00(rx)              ; STA &0B00,X       ; and NA%+8
     8864 0B00     
30306 8866 D840  30        movb ra,@NA.+8(rx)              ; STA NA%+8,X
     8868 21D0     
30307               
30308 886A 7044  14        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30309               
30310 886C 15F8  10        jgt  SVL1                       ; BPL SVL1          ; Loop back until we have copied all the bytes in the
30311                                                                          ; commander data block
30312               
30313 886E 0206  12        li   rtmp,CHECK                 ; JSR CHECK         ; Call CHECK to calculate the checksum for the last
     8870 8762     
30314 8872 06A0  20        bl   @jsr                       ;
     8874 8002     
30315                                                                          ; saved commander and return it in A
30316               
30317 8876 D800  30        movb ra,@CHK                    ; STA CHK           ; Store the checksum in CHK, which is at the end of the
     8878 221E     
30318                                                                          ; last saved commander block
30319               
30320                      .pha                            ; PHA               ; Store the checksum on the stack
     **** ****     > PHA
0001 887A D680  26        movb ra,*rsp
0002 887C 060A  10        dec  rsp
                   < elite.a99
30321               
30322 887E 0260  14        ori  ra,>80*256                 ; ORA #%10000000    ; Set K = checksum with bit 7 set
     8880 8000     
30323 8882 D800  22        movb ra,@K                      ; STA K
     8884 003D     
30324               
30325                      .eor @COK                       ; EOR COK           ; Set K+2 = K EOR COK (the competition flags)
     **** ****     > EOR
0001 8886 D1A0  22        movb @COK,rtmp
     8888 030E     
0002 888A 2806  14        xor  rtmp,ra
                   < elite.a99
30326 888C D800  22        movb ra,@K+2                    ; STA K+2
     888E 003F     
30327               
30328                      .eor @CASH+2                    ; EOR CASH+2        ; Set K+1 = K+2 EOR CASH+2 (the third cash byte)
     **** ****     > EOR
0001 8890 D1A0  22        movb @CASH+2,rtmp
     8892 030B     
0002 8894 2806  14        xor  rtmp,ra
                   < elite.a99
30329 8896 D800  22        movb ra,@K+1                    ; STA K+1
     8898 003E     
30330               
30331                      .eoi (>5a*256)                  ; EOR #&5A          ; Set K+3 = K+1 EOR &5A EOR TALLY+1 (the high byte of
     **** ****     > EOI
0001 889A 0206  12        li   rtmp,(>5A*256)
     889C 5A00     
0002 889E 2806  14        xor  rtmp,ra
                   < elite.a99
30332                      .eor @TALLY+1                   ; EOR TALLY+1       ; the kill tally)
     **** ****     > EOR
0001 88A0 D1A0  22        movb @TALLY+1,rtmp
     88A2 0348     
0002 88A4 2806  14        xor  rtmp,ra
                   < elite.a99
30333 88A6 D800  22        movb ra,@K+3                    ; STA K+3
     88A8 0040     
30334               
30335 88AA 0206  12        li   rtmp,BPRNT                 ; JSR BPRNT         ; Print the competition number stored in K to K+3. The
     88AC 2FCC     
30336 88AE 06A0  20        bl   @jsr                       ;
     88B0 8002     
30337                                                                          ; value of U might affect how this is printed, and as
30338                                                                          ; it's a temporary variable in zero page that isn't
30339                                                                          ; reset by ZERO, it might have any value, but as the
30340                                                                          ; competition code is a 10-digit number, this just means
30341                                                                          ; it may or may not have an extra space of padding
30342               
30343 88B2 0206  12        li   rtmp,TT67                  ; JSR TT67          ; Call TT67 twice to print two newlines
     88B4 4EE6     
30344 88B6 06A0  20        bl   @jsr                       ;
     88B8 8002     
30345 88BA 0206  12        li   rtmp,TT67                  ; JSR TT67
     88BC 4EE6     
30346 88BE 06A0  20        bl   @jsr                       ;
     88C0 8002     
30347               
30348                      .pla                            ; PLA               ; Restore the checksum from the stack
     **** ****     > PLA
0001 88C2 058A  10        inc  rsp
0002 88C4 D01A  22        movb *rsp,ra
                   < elite.a99
30349               
30350 88C6 D800  22        movb ra,@>0B00+NT.              ; STA &0B00+NT%     ; Store the checksum in the last byte of the save file
     88C8 0B4B     
30351                                                                          ; at &0B00 (the equivalent of CHK in the last saved
30352                                                                          ; block)
30353               
30354                      .eoi (>a9*256)                  ; EOR #&A9          ; Store the checksum EOR &A9 in CHK2, the penultimate
     **** ****     > EOI
0001 88CA 0206  12        li   rtmp,(>A9*256)
     88CC A900     
0002 88CE 2806  14        xor  rtmp,ra
                   < elite.a99
30355 88D0 D800  30        movb ra,@CHK2                   ; STA CHK2          ; byte of the last saved commander block
     88D2 221D     
30356               
30357 88D4 D800  22        movb ra,@>0AFF+NT.              ; STA &0AFF+NT%     ; Store the checksum EOR &A9 in the penultimate byte of
     88D6 0B4A     
30358                                                                          ; the save file at &0B00 (the equivalent of CHK2 in the
30359                                                                          ; last saved block)
30360               
30361 88D8 0202  12        li   ry,>0b*256                 ; LDY #&B           ; Set up an OSFILE block at &0C00, containing:
     88DA 0B00     
30362 88DC D802  22        movb ry,@>0C0B                  ; STY &0C0B         ;
     88DE 0C0B     
30363 88E0 B084  14        ab   rone,ry                    ; INY               ; Start address for save = &00000B00 in &0C0A to &0C0D
30364 88E2 D802  22        movb ry,@>0C0F                  ; STY &0C0F         ;
     88E4 0C0F     
30365                                                                          ; End address for save = &00000C00 in &0C0E to &0C11
30366                                                                          ;
30367                                                                          ; Y is left containing &C which we use below
30368               
30369 88E6 0200  12        li   ra,>81*256                 ; LDA #%10000001    ; Clear 6522 System VIA interrupt enable register IER
     88E8 8100     
30370 88EA D800  30        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
     88EC FE4E     
30371                                                                          ; which comes from the keyboard)
30372               
30373 88EE B004  14        ab   rone,ra                    ; INC SVN           ; Increment SVN to indicate we are about to start saving
30374               
30375 88F0 0200  12        li   ra,>00*256                 ; LDA #0            ; Call QUS1 with A = 0, Y = &C to save the commander
     88F2 0000     
30376 88F4 0206  12        li   rtmp,QUS1                  ; JSR QUS1          ; file with the filename we copied to INWK at the start
     88F6 8908     
30377 88F8 06A0  20        bl   @jsr                       ;
     88FA 8002     
30378                                                                          ; of this routine
30379               
30380 88FC 0201  12        li   rx,>00*256                 ; LDX #0            ; Set X = 0 for storing in SVN below
     88FE 0000     
30381               
30382               * STX VIA+&4E            \ This instruction is commented out in the original
30383                                                                          ; source. It would affect the 6522 System VIA interrupt
30384                                                                          ; enable register IER (SHEILA &4E) if any of bits 0-6
30385                                                                          ; of X were set, but they aren't, so this instruction
30386                                                                          ; would have no effect anyway
30387               
30388               * DEX                    \ This instruction is commented out in the original
30389                                                                          ; source. It would end up setting SVN to &FF, which
30390                                                                          ; affects the logic in the IRQ1 handler
30391               
30392 8900 D801  30        movb rx,@SVN                    ; STX SVN           ; Set SVN to 0 to indicate we are done saving
     8902 7FFF     
30393               
30394 8904 0460  16        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show Status Mode)
     8906 8650     
30395               
30396               * ******************************************************************************
30397               *
30398               * Name: QUS1
30399               * Type: Subroutine
30400               * Category: Save and load
30401               * Summary: Save or load the commander file
30402               * Deep dive: Commander save files
30403               *
30404               * ------------------------------------------------------------------------------
30405               *
30406               * The filename should be stored at INWK, terminated with a carriage return (13).
30407               * The routine should be called with Y set to &C.
30408               *
30409               * ------------------------------------------------------------------------------
30410               *
30411               * Arguments:
30412               *
30413               * A                   File operation to be performed. Can be one of the
30414               * following:
30415               *
30416               * * 0 (save file)
30417               *
30418               * * &FF (load file)
30419               *
30420               * Y                   Points to the page number containing the OSFILE block,
30421               * which must be &C because that's where the pointer to the
30422               * filename in INWK is stored below (by the STX &0C00
30423               * instruction)
30424               *
30425               * ******************************************************************************
30426               
30427               QUS1:
30428 8908 0201  12        li   rx,(INWK)*256              ; LDX #INWK         ; Store a pointer to INWK at the start of the block at
     890A 5300     
30429 890C D801  22        movb rx,@>0C00                  ; STX &0C00         ; &0C00, storing #INWK in the low byte because INWK is
     890E 0C00     
30430                                                                          ; in zero page
30431               
30432 8910 0201  12        li   rx,>00*256                 ; LDX #0            ; Set X to 0 so (Y X) = &0C00
     8912 0000     
30433               
30434 8914 0460  20        b    @OSFILE                    ; JMP OSFILE        ; Jump to OSFILE to do the file operation specified in
     8916 FFDD     
30435                                                                          ; &0C00 (i.e. save or load a file depending on the value
30436                                                                          ; of A), returning from the subroutine using a tail call
30437               
30438               * ******************************************************************************
30439               *
30440               * Name: LOD
30441               * Type: Subroutine
30442               * Category: Save and load
30443               * Summary: Load a commander file
30444               *
30445               * ------------------------------------------------------------------------------
30446               *
30447               * The filename should be stored at INWK, terminated with a carriage return (13).
30448               *
30449               * ******************************************************************************
30450               
30451               LOD:
30452 8918 0201  12        li   rx,>02*256                 ; LDX #2            ; Enable the ESCAPE key and clear memory if the BREAK
     891A 0200     
30453 891C 0206  12        li   rtmp,FX200                 ; JSR FX200         ; key is pressed (*FX 200,2)
     891E 895E     
30454 8920 06A0  20        bl   @jsr                       ;
     8922 8002     
30455               
30456 8924 0206  12        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     8926 87FE     
30457 8928 06A0  20        bl   @jsr                       ;
     892A 8002     
30458                                                                          ; the ship data blocks, the ship line heap, the ship
30459                                                                          ; slots for the local bubble of universe, and various
30460                                                                          ; flight and ship status variables
30461               
30462 892C 0202  12        li   ry,>0b*256                 ; LDY #&B           ; Set up an OSFILE block at &0C00, containing:
     892E 0B00     
30463 8930 D802  22        movb ry,@>0C03                  ; STY &0C03         ;
     8932 0C03     
30464 8934 B004  14        ab   rone,ra                    ; INC &0C0B         ; Load address = &00000B00 in &0C02 to &0C05
30465                                                                          ;
30466                                                                          ; Length of file = &00000100 in &0C0A to &0C0D
30467               
30468 8936 B084  14        ab   rone,ry                    ; INY               ; Increment Y to &C, which we use next
30469               
30470 8938 0200  12        li   ra,>ff*256                 ; LDA #&FF          ; Call QUS1 with A = &FF, Y = &C to load the commander
     893A FF00     
30471 893C 0206  12        li   rtmp,QUS1                  ; JSR QUS1          ; file to address &0B00
     893E 8908     
30472 8940 06A0  20        bl   @jsr                       ;
     8942 8002     
30473               
30474 8944 D020  22        movb @>0B00,ra                  ; LDA &0B00         ; If the first byte of the loaded file has bit 7 set,
     8946 0B00     
30475 8948 1112  10        jlt  SPS1+1                     ; BMI SPS1+1        ; jump to SPS+1, which is the second byte of an LDA #0
30476                                                                          ; instruction, i.e. a BRK instruction, which will force
30477                                                                          ; an interrupt to call the address in BRKV, which is set
30478                                                                          ; to BR1... so this instruction restarts the game from
30479                                                                          ; the title screen. Valid commander files for the
30480                                                                          ; cassette version of Elite only have 0 for the first
30481                                                                          ; byte, as there are no missions in this version, so
30482                                                                          ; having bit 7 set is invalid anyway
30483               
30484 894A 0201  12        li   rx,(NT.)*256               ; LDX #NT%          ; We have successfully loaded the commander file at
     894C 4B00     
30485                                                                          ; &0B00, so now we want to copy it to the last saved
30486                                                                          ; commander data block at NA%+8, so we set up a counter
30487                                                                          ; in X to copy NT% bytes
30488               
30489               LOL1:
30490 894E D021  26        movb @>0B00(rx),ra              ; LDA &0B00,X       ; Copy the X-th byte of &0B00 to the X-th byte of NA%+8
     8950 0B00     
30491 8952 D840  30        movb ra,@NA.+8(rx)              ; STA NA%+8,X
     8954 21D0     
30492               
30493 8956 7044  14        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30494               
30495 8958 15FA  10        jgt  LOL1                       ; BPL LOL1          ; Loop back until we have copied all NT% bytes
30496               
30497 895A 0201  12        li   rx,>03*256                 ; LDX #3            ; Fall through into FX200 to disable the ESCAPE key and
     895C 0300     
30498                                                                          ; clear memory if the BREAK key is pressed (*FX 200,3)
30499                                                                          ; and return from the subroutine there
30500               
30501               * ******************************************************************************
30502               *
30503               * Name: FX200
30504               * Type: Subroutine
30505               * Category: Utility routines
30506               * Summary: Set the behaviour of the ESCAPE and BREAK keys
30507               *
30508               * ------------------------------------------------------------------------------
30509               *
30510               * This is the equivalent of a *FX 200 command, which controls the behaviour of
30511               * the ESCAPE and BREAK keys.
30512               *
30513               * ------------------------------------------------------------------------------
30514               *
30515               * Arguments:
30516               *
30517               * X                   Controls the behaviour as follows:
30518               *
30519               * * 0 = Enable ESCAPE key
30520               * Normal BREAK key action
30521               *
30522               * * 1 = Disable ESCAPE key
30523               * Normal BREAK key action
30524               *
30525               * * 2 = Enable ESCAPE key
30526               * Clear memory if the BREAK key is pressed
30527               *
30528               * * 3 = Disable ESCAPE key
30529               * Clear memory if the BREAK key is pressed
30530               *
30531               * ******************************************************************************
30532               
30533               FX200:
30534 895E 0202  12        li   ry,>00*256                 ; LDY #0            ; Call OSBYTE 200 with Y = 0, so the new value is set to
     8960 0000     
30535 8962 0200  12        li   ra,>c8*256                 ; LDA #200          ; X, and return from the subroutine using a tail call
     8964 C800     
30536 8966 0460  20        b    @OSBYTE                    ; JMP OSBYTE
     8968 FFF4     
30537               
30538 896A 0460  16        b    @rts                       ; RTS               ; This instruction has no effect, as we already returned
     896C 800E     
30539                                                                          ; from the subroutine
30540               
30541               * ******************************************************************************
30542               *
30543               * Name: SPS1
30544               * Type: Subroutine
30545               * Category: Maths (Geometry)
30546               * Summary: Calculate the vector to the planet and store it in XX15
30547               *
30548               * ------------------------------------------------------------------------------
30549               *
30550               * Other entry points:
30551               *
30552               * SPS1+1              A BRK instruction
30553               *
30554               * ******************************************************************************
30555               
30556               SPS1:
30557 896E 0201  12        li   rx,>00*256                 ; LDX #0            ; Copy the two high bytes of the planet's x-coordinate
     8970 0000     
30558 8972 0206  12        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(2 1 0), separating out the sign bit into K3+2
     8974 6EDC     
30559 8976 06A0  20        bl   @jsr                       ;
     8978 8002     
30560               
30561 897A 0201  12        li   rx,>03*256                 ; LDX #3            ; Copy the two high bytes of the planet's y-coordinate
     897C 0300     
30562 897E 0206  12        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(5 4 3), separating out the sign bit into K3+5
     8980 6EDC     
30563 8982 06A0  20        bl   @jsr                       ;
     8984 8002     
30564               
30565 8986 0201  12        li   rx,>06*256                 ; LDX #6            ; Copy the two high bytes of the planet's z-coordinate
     8988 0600     
30566 898A 0206  12        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(8 7 6), separating out the sign bit into K3+8
     898C 6EDC     
30567 898E 06A0  20        bl   @jsr                       ;
     8990 8002     
30568               
30569                                                                          ; Fall through into TAS2 to build XX15 from K3
30570               
30571               * ******************************************************************************
30572               *
30573               * Name: TAS2
30574               * Type: Subroutine
30575               * Category: Maths (Geometry)
30576               * Summary: Normalise the three-coordinate vector in K3
30577               *
30578               * ------------------------------------------------------------------------------
30579               *
30580               * Normalise the vector in K3, which has 16-bit values and separate sign bits,
30581               * and store the normalised version in XX15 as a signed 8-bit vector.
30582               *
30583               * A normalised vector (also known as a unit vector) has length 1, so this
30584               * routine takes an existing vector in K3 and scales it so the length of the
30585               * new vector is 1. This is used in two places: when drawing the compass, and
30586               * when applying AI tactics to ships.
30587               *
30588               * We do this in two stages. This stage shifts the 16-bit vector coordinates in
30589               * K3 to the left as far as they will go without losing any bits off the end, so
30590               * we can then take the high bytes and use them as the most accurate 8-bit vector
30591               * to normalise. Then the next stage (in routine NORM) does the normalisation.
30592               *
30593               * ------------------------------------------------------------------------------
30594               *
30595               * Arguments:
30596               *
30597               * K3(2 1 0)           The 16-bit x-coordinate as (x_sign x_hi x_lo), where
30598               * x_sign is just bit 7
30599               *
30600               * K3(5 4 3)           The 16-bit y-coordinate as (y_sign y_hi y_lo), where
30601               * y_sign is just bit 7
30602               *
30603               * K3(8 7 6)           The 16-bit z-coordinate as (z_sign z_hi z_lo), where
30604               * z_sign is just bit 7
30605               *
30606               * ------------------------------------------------------------------------------
30607               *
30608               * Returns:
30609               *
30610               * XX15                The normalised vector, with:
30611               *
30612               * * The x-coordinate in XX15
30613               *
30614               * * The y-coordinate in XX15+1
30615               *
30616               * * The z-coordinate in XX15+2
30617               *
30618               * ------------------------------------------------------------------------------
30619               *
30620               * Other entry points:
30621               *
30622               * TA2                 Calculate the length of the vector in XX15 (ignoring the
30623               * low coordinates), returning it in Q
30624               *
30625               * ******************************************************************************
30626               
30627               TAS2:
30628 8992 D020  22        movb @K3,ra                     ; LDA K3            ; OR the three low bytes and 1 to get a byte that has
     8994 00D2     
30629 8996 F020  22        socb @K3+3,ra                   ; ORA K3+3          ; a 1 wherever any of the three low bytes has a 1
     8998 00D5     
30630 899A F020  22        socb @K3+6,ra                   ; ORA K3+6          ; (as well as always having bit 0 set), and store in
     899C 00D8     
30631 899E 0260  14        ori  ra,>01*256                 ; ORA #1            ; K3+9
     89A0 0100     
30632 89A2 D800  22        movb ra,@K3+9                   ; STA K3+9
     89A4 00DB     
30633               
30634 89A6 D020  22        movb @K3+1,ra                   ; LDA K3+1          ; OR the three high bytes to get a byte in A that has a
     89A8 00D3     
30635 89AA F020  22        socb @K3+4,ra                   ; ORA K3+4          ; 1 wherever any of the three high bytes has a 1
     89AC 00D6     
30636 89AE F020  22        socb @K3+7,ra                   ; ORA K3+7
     89B0 00D9     
30637               
30638                                                                          ; (A K3+9) now has a 1 wherever any of the 16-bit
30639                                                                          ; values in K3 has a 1
30640               TAL2:
30641                      .asl @K3+9                      ; ASL K3+9          ; Shift (A K3+9) to the left, so bit 7 of the high byte
     **** ****     > ASL
0001 89B2 D1A0  22        movb @K3+9,rtmp
     89B4 00DB     
0002 89B6 0246  14        andi rtmp,>ff00
     89B8 FF00     
0003 89BA 0A16  14        sla  rtmp,1
0004 89BC D806  22        movb rtmp,@K3+9
     89BE 00DB     
                   < elite.a99
30642 89C0 06A0  20        bl   @rola                      ; ROL A             ; goes into the C flag
     89C2 8018     
30643               
30644 89C4 1822  10        joc  TA2                        ; BCS TA2           ; If the left shift pushed a 1 out of the end, then we
30645                                                                          ; know that at least one of the coordinates has a 1 in
30646                                                                          ; this position, so jump to TA2 as we can't shift the
30647                                                                          ; values in K3 any further to the left
30648               
30649                      .asl @K3                        ; ASL K3            ; Shift K3(1 0), the x-coordinate, to the left
     **** ****     > ASL
0001 89C6 D1A0  22        movb @K3,rtmp
     89C8 00D2     
0002 89CA 0246  14        andi rtmp,>ff00
     89CC FF00     
0003 89CE 0A16  14        sla  rtmp,1
0004 89D0 D806  22        movb rtmp,@K3
     89D2 00D2     
                   < elite.a99
30650 89D4 0208  12        li   rarg1,K3+1                 ; ROL K3+1
     89D6 00D3     
30651 89D8 06A0  20        bl   @rol                       ;
     89DA 8028     
30652               
30653                      .asl @K3+3                      ; ASL K3+3          ; Shift K3(4 3), the y-coordinate, to the left
     **** ****     > ASL
0001 89DC D1A0  22        movb @K3+3,rtmp
     89DE 00D5     
0002 89E0 0246  14        andi rtmp,>ff00
     89E2 FF00     
0003 89E4 0A16  14        sla  rtmp,1
0004 89E6 D806  22        movb rtmp,@K3+3
     89E8 00D5     
                   < elite.a99
30654 89EA 0208  12        li   rarg1,K3+4                 ; ROL K3+4
     89EC 00D6     
30655 89EE 06A0  20        bl   @rol                       ;
     89F0 8028     
30656               
30657                      .asl @K3+6                      ; ASL K3+6          ; Shift K3(6 7), the z-coordinate, to the left
     **** ****     > ASL
0001 89F2 D1A0  22        movb @K3+6,rtmp
     89F4 00D8     
0002 89F6 0246  14        andi rtmp,>ff00
     89F8 FF00     
0003 89FA 0A16  14        sla  rtmp,1
0004 89FC D806  22        movb rtmp,@K3+6
     89FE 00D8     
                   < elite.a99
30658 8A00 0208  12        li   rarg1,K3+7                 ; ROL K3+7
     8A02 00D9     
30659 8A04 06A0  20        bl   @rol                       ;
     8A06 8028     
30660               
30661 8A08 17D4  10        jnc  TAL2                       ; BCC TAL2          ; Jump back to TAL2 to do another shift left (this BCC
30662                                                                          ; is effectively a JMP as we know bit 7 of K3+7 is not a
30663                                                                          ; 1, as otherwise bit 7 of A would have been a 1 and we
30664                                                                          ; would have taken the BCS above)
30665               
30666               TA2:
30667 8A0A D020  22        movb @K3+1,ra                   ; LDA K3+1          ; Fetch the high byte of the x-coordinate from our left-
     8A0C 00D3     
30668 8A0E 0910  14        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
30669 8A10 F020  22        socb @K3+2,ra                   ; ORA K3+2          ; sign bit in there from the x_sign part of K3, and
     8A12 00D4     
30670 8A14 D800  22        movb ra,@XX15                   ; STA XX15          ; store the resulting signed 8-bit x-coordinate in XX15
     8A16 0031     
30671               
30672 8A18 D020  22        movb @K3+4,ra                   ; LDA K3+4          ; Fetch the high byte of the y-coordinate from our left-
     8A1A 00D6     
30673 8A1C 0910  14        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
30674 8A1E F020  22        socb @K3+5,ra                   ; ORA K3+5          ; sign bit in there from the y_sign part of K3, and
     8A20 00D7     
30675 8A22 D800  22        movb ra,@XX15+1                 ; STA XX15+1        ; store the resulting signed 8-bit y-coordinate in
     8A24 0032     
30676                                                                          ; XX15+1
30677               
30678 8A26 D020  22        movb @K3+7,ra                   ; LDA K3+7          ; Fetch the high byte of the z-coordinate from our left-
     8A28 00D9     
30679 8A2A 0910  14        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
30680 8A2C F020  22        socb @K3+8,ra                   ; ORA K3+8          ; sign bit in there from the z_sign part of K3, and
     8A2E 00DA     
30681 8A30 D800  22        movb ra,@XX15+2                 ; STA XX15+2        ; store the resulting signed 8-bit  z-coordinate in
     8A32 0033     
30682                                                                          ; XX15+2
30683               
30684                                                                          ; Now we have a signed 8-bit version of the vector K3 in
30685                                                                          ; XX15, so fall through into NORM to normalise it
30686               
30687               * ******************************************************************************
30688               *
30689               * Name: NORM
30690               * Type: Subroutine
30691               * Category: Maths (Geometry)
30692               * Summary: Normalise the three-coordinate vector in XX15
30693               * Deep dive: Tidying orthonormal vectors
30694               * Orientation vectors
30695               *
30696               * ------------------------------------------------------------------------------
30697               *
30698               * We do this by dividing each of the three coordinates by the length of the
30699               * vector, which we can calculate using Pythagoras. Once normalised, 96 (&60) is
30700               * used to represent a value of 1, and 96 with bit 7 set (&E0) is used to
30701               * represent -1. This enables us to represent fractional values of less than 1
30702               * using integers.
30703               *
30704               * ------------------------------------------------------------------------------
30705               *
30706               * Arguments:
30707               *
30708               * XX15                The vector to normalise, with:
30709               *
30710               * * The x-coordinate in XX15
30711               *
30712               * * The y-coordinate in XX15+1
30713               *
30714               * * The z-coordinate in XX15+2
30715               *
30716               * ------------------------------------------------------------------------------
30717               *
30718               * Returns:
30719               *
30720               * XX15                The normalised vector
30721               *
30722               * Q                   The length of the original XX15 vector
30723               *
30724               * ------------------------------------------------------------------------------
30725               *
30726               * Other entry points:
30727               *
30728               * NO1                 Contains an RTS
30729               *
30730               * ******************************************************************************
30731               
30732               NORM:
30733 8A34 D020  22        movb @XX15,ra                   ; LDA XX15          ; Fetch the x-coordinate into A
     8A36 0031     
30734               
30735 8A38 0206  12        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = x^2
     8A3A 42B6     
30736 8A3C 06A0  20        bl   @jsr                       ;
     8A3E 8002     
30737               
30738 8A40 D800  22        movb ra,@R                      ; STA R             ; Set (R Q) = (A P) = x^2
     8A42 0091     
30739 8A44 D020  22        movb @P,ra                      ; LDA P
     8A46 001B     
30740 8A48 D800  22        movb ra,@Q                      ; STA Q
     8A4A 0090     
30741               
30742 8A4C D020  22        movb @XX15+1,ra                 ; LDA XX15+1        ; Fetch the y-coordinate into A
     8A4E 0032     
30743               
30744 8A50 0206  12        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = y^2
     8A52 42B6     
30745 8A54 06A0  20        bl   @jsr                       ;
     8A56 8002     
30746               
30747 8A58 D800  22        movb ra,@T                      ; STA T             ; Set (T P) = (A P) = y^2
     8A5A 00D1     
30748               
30749 8A5C D020  22        movb @P,ra                      ; LDA P             ; Set (R Q) = (R Q) + (T P) = x^2 + y^2
     8A5E 001B     
30750                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 8A60 1701  10        jnc  !
0002 8A62 B004  14        ab   rone,ra
0003               !:
0004 8A64 B020  22        ab   @Q,ra
     8A66 0090     
                   < elite.a99
30751 8A68 D800  22        movb ra,@Q                      ; STA Q             ; First, doing the low bytes, Q = Q + P
     8A6A 0090     
30752               
30753 8A6C D020  22        movb @T,ra                      ; LDA T             ; And then the high bytes, R = R + T
     8A6E 00D1     
30754                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 8A70 1701  10        jnc  !
0002 8A72 B004  14        ab   rone,ra
0003               !:
0004 8A74 B020  22        ab   @R,ra
     8A76 0091     
                   < elite.a99
30755 8A78 D800  22        movb ra,@R                      ; STA R
     8A7A 0091     
30756               
30757 8A7C D020  22        movb @XX15+2,ra                 ; LDA XX15+2        ; Fetch the z-coordinate into A
     8A7E 0033     
30758               
30759 8A80 0206  12        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = z^2
     8A82 42B6     
30760 8A84 06A0  20        bl   @jsr                       ;
     8A86 8002     
30761               
30762 8A88 D800  22        movb ra,@T                      ; STA T             ; Set (T P) = (A P) = z^2
     8A8A 00D1     
30763               
30764 8A8C D020  22        movb @P,ra                      ; LDA P             ; Set (R Q) = (R Q) + (T P) = x^2 + y^2 + z^2
     8A8E 001B     
30765                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 8A90 1701  10        jnc  !
0002 8A92 B004  14        ab   rone,ra
0003               !:
0004 8A94 B020  22        ab   @Q,ra
     8A96 0090     
                   < elite.a99
30766 8A98 D800  22        movb ra,@Q                      ; STA Q             ; First, doing the low bytes, Q = Q + P
     8A9A 0090     
30767               
30768 8A9C D020  22        movb @T,ra                      ; LDA T             ; And then the high bytes, R = R + T
     8A9E 00D1     
30769                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 8AA0 1701  10        jnc  !
0002 8AA2 B004  14        ab   rone,ra
0003               !:
0004 8AA4 B020  22        ab   @R,ra
     8AA6 0091     
                   < elite.a99
30770 8AA8 D800  22        movb ra,@R                      ; STA R
     8AAA 0091     
30771               
30772 8AAC 0206  12        li   rtmp,LL5                   ; JSR LL5           ; We now have the following:
     8AAE 92AA     
30773 8AB0 06A0  20        bl   @jsr                       ;
     8AB2 8002     
30774                                                                          ;
30775                                                                          ; (R Q) = x^2 + y^2 + z^2
30776                                                                          ;
30777                                                                          ; so we can call LL5 to use Pythagoras to get:
30778                                                                          ;
30779                                                                          ; Q = SQRT(R Q)
30780                                                                          ; = SQRT(x^2 + y^2 + z^2)
30781                                                                          ;
30782                                                                          ; So Q now contains the length of the vector (x, y, z),
30783                                                                          ; and we can normalise the vector by dividing each of
30784                                                                          ; the coordinates by this value, which we do by calling
30785                                                                          ; routine TIS2. TIS2 returns the divided figure, using
30786                                                                          ; 96 to represent 1 and 96 with bit 7 set for -1
30787               
30788 8AB4 D020  22        movb @XX15,ra                   ; LDA XX15          ; Call TIS2 to divide the x-coordinate in XX15 by Q,
     8AB6 0031     
30789 8AB8 0206  12        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     8ABA 90BE     
30790 8ABC 06A0  20        bl   @jsr                       ;
     8ABE 8002     
30791 8AC0 D800  22        movb ra,@XX15                   ; STA XX15
     8AC2 0031     
30792               
30793 8AC4 D020  22        movb @XX15+1,ra                 ; LDA XX15+1        ; Call TIS2 to divide the y-coordinate in XX15+1 by Q,
     8AC6 0032     
30794 8AC8 0206  12        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     8ACA 90BE     
30795 8ACC 06A0  20        bl   @jsr                       ;
     8ACE 8002     
30796 8AD0 D800  22        movb ra,@XX15+1                 ; STA XX15+1
     8AD2 0032     
30797               
30798 8AD4 D020  22        movb @XX15+2,ra                 ; LDA XX15+2        ; Call TIS2 to divide the z-coordinate in XX15+2 by Q,
     8AD6 0033     
30799 8AD8 0206  12        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     8ADA 90BE     
30800 8ADC 06A0  20        bl   @jsr                       ;
     8ADE 8002     
30801 8AE0 D800  22        movb ra,@XX15+2                 ; STA XX15+2
     8AE2 0033     
30802               
30803               NO1:
30804 8AE4 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8AE6 800E     
30805               
30806               * ******************************************************************************
30807               *
30808               * Name: RDKEY
30809               * Type: Subroutine
30810               * Category: Keyboard
30811               * Summary: Scan the keyboard for key presses
30812               *
30813               * ------------------------------------------------------------------------------
30814               *
30815               * Scan the keyboard, starting with internal key number 16 ("Q") and working
30816               * through the set of internal key numbers (see p.142 of the Advanced User Guide
30817               * for a list of internal key numbers).
30818               *
30819               * This routine is effectively the same as OSBYTE 122, though the OSBYTE call
30820               * preserves A, unlike this routine.
30821               *
30822               * ------------------------------------------------------------------------------
30823               *
30824               * Returns:
30825               *
30826               * X                   If a key is being pressed, X contains the internal key
30827               * number, otherwise it contains 0
30828               *
30829               * A                   Contains the same as X
30830               *
30831               * ******************************************************************************
30832               
30833               RDKEY:
30834 8AE8 0201  12        li   rx,>10*256                 ; LDX #16           ; Start the scan with internal key number 16 ("Q")
     8AEA 1000     
30835               
30836               Rd1:
30837 8AEC 0206  12        li   rtmp,DKS4                  ; JSR DKS4          ; Scan the keyboard to see if the key in X is currently
     8AEE 8C1C     
30838 8AF0 06A0  20        bl   @jsr                       ;
     8AF2 8002     
30839                                                                          ; being pressed, returning the result in A and X
30840               
30841 8AF4 1103  10        jlt  Rd2                        ; BMI Rd2           ; Jump to Rd2 if this key is being pressed (in which
30842                                                                          ; case DKS4 will have returned the key number with bit
30843                                                                          ; 7 set, which is negative)
30844               
30845 8AF6 B044  14        ab   rone,rx                    ; INX               ; Increment the key number, which was unchanged by the
30846                                                                          ; above call to DKS4
30847               
30848 8AF8 15F9  10        jgt  Rd1                        ; BPL Rd1           ; Loop back to test the next key, ending the loop when
30849                                                                          ; X is negative (i.e. 128)
30850               
30851 8AFA D001  14        movb rx,ra                      ; TXA               ; If we get here, nothing is being pressed, so copy X
30852                                                                          ; into A so that X = A = 128 = %10000000
30853               
30854               Rd2:
30855                      .eoi (>80*256)                  ; EOR #%10000000    ; EOR A with #%10000000 to flip bit 7, so A now contains
     **** ****     > EOI
0001 8AFC 0206  12        li   rtmp,(>80*256)
     8AFE 8000     
0002 8B00 2806  14        xor  rtmp,ra
                   < elite.a99
30856                                                                          ; 0 if no key has been pressed, or the internal key
30857                                                                          ; number if a key has been pressed
30858               
30859 8B02 D040  14        movb ra,rx                      ; TAX               ; Copy A into X
30860               
30861 8B04 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8B06 800E     
30862               
30863               * ******************************************************************************
30864               *
30865               * Name: ECMOF
30866               * Type: Subroutine
30867               * Category: Sound
30868               * Summary: Switch off the E.C.M.
30869               *
30870               * ------------------------------------------------------------------------------
30871               *
30872               * Switch the E.C.M. off, turn off the dashboard bulb and make the sound of the
30873               * E.C.M. switching off).
30874               *
30875               * ******************************************************************************
30876               
30877               ECMOF:
30878 8B08 0200  12        li   ra,>00*256                 ; LDA #0            ; Set ECMA and ECMP to 0 to indicate that no E.C.M. is
     8B0A 0000     
30879 8B0C D800  22        movb ra,@ECMA                   ; STA ECMA          ; currently running
     8B0E 0030     
30880 8B10 D800  22        movb ra,@ECMP                   ; STA ECMP
     8B12 0D5B     
30881               
30882 8B14 0206  12        li   rtmp,ECBLB                 ; JSR ECBLB         ; Update the E.C.M. indicator bulb on the dashboard
     8B16 70C8     
30883 8B18 06A0  20        bl   @jsr                       ;
     8B1A 8002     
30884               
30885 8B1C 0200  12        li   ra,>48*256                 ; LDA #72           ; Call the NOISE routine with A = 72 to make the sound
     8B1E 4800     
30886 8B20 1641  10        jne  NOISE                      ; BNE NOISE         ; of the E.C.M. being turned off and return from the
30887                                                                          ; subroutine using a tail call (this BNE is effectively
30888                                                                          ; a JMP as A will never be zero)
30889               
30890               * ******************************************************************************
30891               *
30892               * Name: EXNO3
30893               * Type: Subroutine
30894               * Category: Sound
30895               * Summary: Make an explosion sound
30896               *
30897               * ------------------------------------------------------------------------------
30898               *
30899               * Make the sound of death in the cold, hard vacuum of space. Apparently, in
30900               * Elite space, everyone can hear you scream.
30901               *
30902               * This routine also makes the sound of a destroyed cargo canister if we don't
30903               * get scooping right, the sound of us colliding with another ship, and the sound
30904               * of us being hit with depleted shields. It is not a good sound to hear.
30905               *
30906               * ******************************************************************************
30907               
30908               EXNO3:
30909 8B22 0200  12        li   ra,>10*256                 ; LDA #16           ; Call the NOISE routine with A = 16 to make the first
     8B24 1000     
30910 8B26 0206  12        li   rtmp,NOISE                 ; JSR NOISE         ; death sound
     8B28 8BA4     
30911 8B2A 06A0  20        bl   @jsr                       ;
     8B2C 8002     
30912               
30913 8B2E 0200  12        li   ra,>18*256                 ; LDA #24           ; Call the NOISE routine with A = 24 to make the second
     8B30 1800     
30914 8B32 1638  10        jne  NOISE                      ; BNE NOISE         ; death sound and return from the subroutine using a
30915                                                                          ; tail call (this BNE is effectively a JMP as A will
30916                                                                          ; never be zero)
30917               
30918               * ******************************************************************************
30919               *
30920               * Name: SFRMIS
30921               * Type: Subroutine
30922               * Category: Tactics
30923               * Summary: Add an enemy missile to our local bubble of universe
30924               *
30925               * ------------------------------------------------------------------------------
30926               *
30927               * An enemy has fired a missile, so add the missile to our universe if there is
30928               * room, and if there is, make the appropriate warnings and noises.
30929               *
30930               * ******************************************************************************
30931               
30932               SFRMIS:
30933 8B34 0201  12        li   rx,(MSL)*256               ; LDX #MSL          ; Set X to the ship type of a missile, and call SFS1-2
     8B36 0900     
30934 8B38 0206  12        li   rtmp,SFS1-2                ; JSR SFS1-2        ; to add the missile to our universe with an AI flag
     8B3A 3D00     
30935 8B3C 06A0  20        bl   @jsr                       ;
     8B3E 8002     
30936                                                                          ; of %11111110 (AI enabled, hostile, no E.C.M.)
30937               
30938 8B40 17D1  10        jnc  NO1                        ; BCC NO1           ; The C flag will be set if the call to SFS1-2 was a
30939                                                                          ; success, so if it's clear, jump to NO1 to return from
30940                                                                          ; the subroutine (as NO1 contains an RTS)
30941               
30942 8B42 0200  12        li   ra,>78*256                 ; LDA #120          ; Print recursive token 120 ("INCOMING MISSILE") as an
     8B44 7800     
30943 8B46 0206  12        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     8B48 8E52     
30944 8B4A 06A0  20        bl   @jsr                       ;
     8B4C 8002     
30945               
30946 8B4E 0200  12        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     8B50 3000     
30947 8B52 1628  10        jne  NOISE                      ; BNE NOISE         ; of the missile being launched and return from the
30948                                                                          ; subroutine using a tail call (this BNE is effectively
30949                                                                          ; a JMP as A will never be zero)
30950               
30951               * ******************************************************************************
30952               *
30953               * Name: EXNO2
30954               * Type: Subroutine
30955               * Category: Status
30956               * Summary: Process us making a kill
30957               * Deep dive: Combat rank
30958               *
30959               * ------------------------------------------------------------------------------
30960               *
30961               * We have killed a ship, so increase the kill tally, displaying an iconic
30962               * message of encouragement if the kill total is a multiple of 256, and then
30963               * make a nearby explosion sound.
30964               *
30965               * ******************************************************************************
30966               
30967               EXNO2:
30968 8B54 B004  14        ab   rone,ra                    ; INC TALLY         ; Increment the low byte of the kill count in TALLY
30969               
30970 8B56 1608  10        jne  EXNO-2                     ; BNE EXNO-2        ; If there is no carry, jump to the LDX #7 below (at
30971                                                                          ; EXNO-2)
30972               
30973 8B58 B004  14        ab   rone,ra                    ; INC TALLY+1       ; Increment the high byte of the kill count in TALLY
30974               
30975 8B5A 0200  12        li   ra,>65*256                 ; LDA #101          ; The kill total is a multiple of 256, so it's time
     8B5C 6500     
30976 8B5E 0206  12        li   rtmp,MESS                  ; JSR MESS          ; for a pat on the back, so print recursive token 101
     8B60 8E52     
30977 8B62 06A0  20        bl   @jsr                       ;
     8B64 8002     
30978                                                                          ; ("RIGHT ON COMMANDER!") as an in-flight message
30979               
30980 8B66 0201  12        li   rx,>07*256                 ; LDX #7            ; Set X = 7 and fall through into EXNO to make the
     8B68 0700     
30981                                                                          ; sound of a ship exploding
30982               
30983               * ******************************************************************************
30984               *
30985               * Name: EXNO
30986               * Type: Subroutine
30987               * Category: Sound
30988               * Summary: Make the sound of a laser strike or ship explosion
30989               *
30990               * ------------------------------------------------------------------------------
30991               *
30992               * Make the two-part explosion sound of us making a laser strike, or of another
30993               * ship exploding.
30994               *
30995               * The volume of the first explosion is affected by the distance of the ship
30996               * being hit, with more distant ships being quieter. The value in X also affects
30997               * the volume of the first explosion, with a higher X giving a quieter sound
30998               * (so X can be used to differentiate a laser strike from an explosion).
30999               *
31000               * ------------------------------------------------------------------------------
31001               *
31002               * Arguments:
31003               *
31004               * X                   The larger the value of X, the fainter the explosion.
31005               * Allowed values are:
31006               *
31007               * * 7  = explosion is louder (i.e. the ship has just
31008               * exploded)
31009               *
31010               * * 15 = explosion is quieter (i.e. this is just a laser
31011               * strike)
31012               *
31013               * ------------------------------------------------------------------------------
31014               *
31015               * Other entry points:
31016               *
31017               * EXNO-2              Set X = 7 and fall through into EXNO to make the sound
31018               * of a ship exploding
31019               *
31020               * ******************************************************************************
31021               
31022               EXNO:
31023 8B6A D801  22        movb rx,@T                      ; STX T             ; Store the distance in T
     8B6C 00D1     
31024               
31025 8B6E 0200  12        li   ra,>18*256                 ; LDA #24           ; Set A = 24 to denote the sound of us making a hit or
     8B70 1800     
31026 8B72 0206  12        li   rtmp,NOS1                  ; JSR NOS1          ; kill (part 1 of the explosion), and call NOS1 to set
     8B74 8BC2     
31027 8B76 06A0  20        bl   @jsr                       ;
     8B78 8002     
31028                                                                          ; up the sound block in XX16
31029               
31030 8B7A D020  22        movb @INWK+7,ra                 ; LDA INWK+7        ; Fetch z_hi, the distance of the ship being hit in
     8B7C 005A     
31031 8B7E 0910  14        srl  ra,1                       ; LSR A             ; terms of the z-axis (in and out of the screen), and
31032 8B80 0910  14        srl  ra,1                       ; LSR A             ; divide by 4. If z_hi has either bit 6 or 7 set then
31033                                                                          ; that ship is too far away to be shown on the scanner
31034                                                                          ; (as per the SCAN routine), so we know the maximum
31035                                                                          ; z_hi at this point is %00111111, and shifting z_hi
31036                                                                          ; to the right twice gives us a maximum value of
31037                                                                          ; %00001111
31038               
31039                      .and @T                         ; AND T             ; This reduces A to a maximum of X; X can be either
     **** ****     > AND
0001 8B82 D1A0  22        movb @T,rtmp
     8B84 00D1     
0002 8B86 0546  10        inv  rtmp
0003 8B88 5006  14        szcb rtmp,ra
                   < elite.a99
31040                                                                          ; 7 = %0111 or 15 = %1111, so AND'ing with 15 will
31041                                                                          ; not affect A, while AND'ing with 7 will clear bit
31042                                                                          ; 3, reducing the maximum value in A to 7
31043               
31044 8B8A 0260  14        ori  ra,>f1*256                 ; ORA #%11110001    ; The SOUND statement's amplitude ranges from 0 (for no
     8B8C F100     
31045                                                                          ; sound) to -15 (full volume), so we can set bits 0 and
31046                                                                          ; 4-7 in A, and keep bits 1-3 from the above to get
31047                                                                          ; a value between -15 (%11110001) and -1 (%11111111),
31048                                                                          ; with lower values of z_hi and argument X leading
31049                                                                          ; to a more negative, or quieter number (so the closer
31050                                                                          ; the ship, i.e. the smaller the value of X, the louder
31051                                                                          ; the sound)
31052               
31053 8B8E D800  22        movb ra,@XX16+2                 ; STA XX16+2        ; The amplitude byte of the sound block in XX16 is in
     8B90 000B     
31054                                                                          ; byte #3 (where it's the low byte of the amplitude), so
31055                                                                          ; this sets the amplitude to the value in A
31056               
31057 8B92 0206  12        li   rtmp,NO3                   ; JSR NO3           ; Make the sound from our updated sound block in XX16
     8B94 8BAC     
31058 8B96 06A0  20        bl   @jsr                       ;
     8B98 8002     
31059               
31060 8B9A 0200  12        li   ra,>10*256                 ; LDA #16           ; Set A = 16 to denote we have made a hit or kill
     8B9C 1000     
31061                                                                          ; (part 2 of the explosion), and fall through into NOISE
31062                                                                          ; to make the sound
31063               
31064 8B9E 2C              byte >2c                                            ; Skip the next instruction by turning it into
31065                                                                          ; &2C &A9 &20, or BIT &20A9, which does nothing apart
31066                                                                          ; from affect the flags
31067               
31068               * ******************************************************************************
31069               *
31070               * Name: BEEP
31071               * Type: Subroutine
31072               * Category: Sound
31073               * Summary: Make a short, high beep
31074               *
31075               * ******************************************************************************
31076               
31077               BEEP:
31078 8BA0 0200  12        li   ra,>20*256                 ; LDA #32           ; Set A = 32 to denote a short, high beep, and fall
     8BA2 2000     
31079                                                                          ; through into the NOISE routine to make the sound
31080               
31081               * ******************************************************************************
31082               *
31083               * Name: NOISE
31084               * Type: Subroutine
31085               * Category: Sound
31086               * Summary: Make the sound whose number is in A
31087               *
31088               * ------------------------------------------------------------------------------
31089               *
31090               * Arguments:
31091               *
31092               * A                   The number of the sound to be made. See the
31093               * documentation for variable SFX for a list of sound
31094               * numbers
31095               *
31096               * ******************************************************************************
31097               
31098               NOISE:
31099 8BA4 0206  12        li   rtmp,NOS1                  ; JSR NOS1          ; Set up the sound block in XX16 for the sound in A and
     8BA6 8BC2     
31100 8BA8 06A0  20        bl   @jsr                       ;
     8BAA 8002     
31101                                                                          ; fall through into NO3 to make the sound
31102               
31103               * ******************************************************************************
31104               *
31105               * Name: NO3
31106               * Type: Subroutine
31107               * Category: Sound
31108               * Summary: Make a sound from a prepared sound block
31109               *
31110               * ------------------------------------------------------------------------------
31111               *
31112               * Make a sound from a prepared sound block in XX16 (if sound is enabled). See
31113               * routine NOS1 for details of preparing the XX16 sound block.
31114               *
31115               * ******************************************************************************
31116               
31117               NO3:
31118 8BAC D060  22        movb @DNOIZ,rx                  ; LDX DNOIZ         ; Set X to the DNOIZ configuration setting
     8BAE 0F49     
31119               
31120 8BB0 1699  10        jne  NO1                        ; BNE NO1           ; If DNOIZ is non-zero, then sound is disabled, so
31121                                                                          ; return from the subroutine (as NO1 contains an RTS)
31122               
31123 8BB2 0201  12        li   rx,((XX16)%256)*256        ; LDX #LO(XX16)     ; Otherwise set (Y X) to point to the sound block in
     8BB4 0900     
31124 8BB6 0202  12        li   ry,((XX16)/256)*256        ; LDY #HI(XX16)     ; XX16
     8BB8 0000     
31125               
31126 8BBA 0200  12        li   ra,>07*256                 ; LDA #7            ; Call OSWORD 7 to makes the sound, as described in the
     8BBC 0700     
31127 8BBE 0460  20        b    @OSWORD                    ; JMP OSWORD        ; documentation for variable SFX, and return from the
     8BC0 FFF1     
31128                                                                          ; subroutine using a tail call
31129               
31130               * ******************************************************************************
31131               *
31132               * Name: NOS1
31133               * Type: Subroutine
31134               * Category: Sound
31135               * Summary: Prepare a sound block
31136               *
31137               * ------------------------------------------------------------------------------
31138               *
31139               * Copy four sound bytes from SFX into XX16, interspersing them with null bytes,
31140               * with Y indicating the sound number to copy (from the values in the sound
31141               * table at SFX). So, for example, if we call this routine with A = 40 (long,
31142               * low beep), the following bytes will be set in XX16 to XX16+7:
31143               *
31144               * &13 &00 &F4 &00 &0C &00 &08 &00
31145               *
31146               * This block will be passed to OSWORD 7 to make the sound, which expects the
31147               * four sound attributes as 16-bit big-endian values - in other words, with the
31148               * low byte first. So the above block would pass the values &0013, &00F4, &000C
31149               * and &0008 to the SOUND statement when used with OSWORD 7, or:
31150               *
31151               * SOUND &13, &F4, &0C, &08
31152               *
31153               * as the high bytes are always zero.
31154               *
31155               * ------------------------------------------------------------------------------
31156               *
31157               * Arguments:
31158               *
31159               * A                   The sound number to copy from SFX to XX16, which is
31160               * always a multiple of 8
31161               *
31162               * ******************************************************************************
31163               
31164               NOS1:
31165 8BC2 0910  14        srl  ra,1                       ; LSR A             ; Divide A by 2, and also clear the C flag, as bit 0 of
31166                                                                          ; A is always zero (as A is a multiple of 8)
31167               
31168                      .adi (>03*256)                  ; ADC #3            ; Set Y = A + 3, so Y now points to the last byte of
     **** ****     > ADI
0001 8BC4 1701  10        jnc  !
0002 8BC6 B004  14        ab   rone,ra
0003               !:
0004 8BC8 0220  14        ai   ra,(>03*256)
     8BCA 0300     
                   < elite.a99
31169 8BCC D080  14        movb ra,ry                      ; TAY               ; four within the block of four-byte values
31170               
31171 8BCE 0201  12        li   rx,>07*256                 ; LDX #7            ; We want to copy four bytes, spread out into an 8-byte
     8BD0 0700     
31172                                                                          ; block, so set a counter in Y to cover 8 bytes
31173               
31174               NOL1:
31175 8BD2 0200  12        li   ra,>00*256                 ; LDA #0            ; Set the X-th byte of XX16 to 0
     8BD4 0000     
31176 8BD6 D840  30        movb ra,@XX16(rx)               ; STA XX16,X
     8BD8 0009     
31177               
31178 8BDA 7044  14        sb   rone,rx                    ; DEX               ; Decrement the destination byte pointer
31179               
31180 8BDC D022  26        movb @SFX(ry),ra                ; LDA SFX,Y         ; Set the X-th byte of XX16 to the value from SFX+Y
     8BDE 7ED6     
31181 8BE0 D840  30        movb ra,@XX16(rx)               ; STA XX16,X
     8BE2 0009     
31182               
31183 8BE4 7084  14        sb   rone,ry                    ; DEY               ; Decrement the source byte pointer again
31184               
31185 8BE6 7044  14        sb   rone,rx                    ; DEX               ; Decrement the destination byte pointer again
31186               
31187 8BE8 15F4  10        jgt  NOL1                       ; BPL NOL1          ; Loop back for the next source byte
31188               
31189 8BEA 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8BEC 800E     
31190               
31191               * ******************************************************************************
31192               *
31193               * Name: KYTB
31194               * Type: Variable
31195               * Category: Keyboard
31196               * Summary: Lookup table for in-flight keyboard controls
31197               * Deep dive: The key logger
31198               *
31199               * ------------------------------------------------------------------------------
31200               *
31201               * Keyboard table for in-flight controls. This table contains the internal key
31202               * codes for the flight keys (see p.142 of the Advanced User Guide for a list of
31203               * internal key numbers).
31204               *
31205               * The pitch, roll, speed and laser keys (i.e. the seven primary flight
31206               * control keys) have bit 7 set, so they have 128 added to their internal
31207               * values. This doesn't appear to be used anywhere.
31208               *
31209               * ******************************************************************************
31210               
31211               KYTB:                                                      ; Point KYTB to the byte before the start of the table
31212                      equ $ - 1
31213               
31214                                                                          ; These are the primary flight controls (pitch, roll,
31215                                                                          ; speed and lasers):
31216               
31217 8BEE E8              byte >68 + 128                                      ; ?         KYTB+1      Slow down
31218 8BEF   E2            byte >62 + 128                                      ; Space     KYTB+2      Speed up
31219 8BF0 E6              byte >66 + 128                                      ; <         KYTB+3      Roll left
31220 8BF1   E7            byte >67 + 128                                      ; >         KYTB+4      Roll right
31221 8BF2 C2              byte >42 + 128                                      ; X         KYTB+5      Pitch up
31222 8BF3   D1            byte >51 + 128                                      ; S         KYTB+6      Pitch down
31223 8BF4 C1              byte >41 + 128                                      ; A         KYTB+7      Fire lasers
31224               
31225                                                                          ; These are the secondary flight controls:
31226               
31227 8BF5   60            byte >60                                            ; TAB       KYTB+8      Energy bomb
31228 8BF6 70              byte >70                                            ; ESCAPE    KYTB+9      Launch escape pod
31229 8BF7   23            byte >23                                            ; T         KYTB+10     Arm missile
31230 8BF8 35              byte >35                                            ; U         KYTB+11     Unarm missile
31231 8BF9   65            byte >65                                            ; M         KYTB+12     Fire missile
31232 8BFA 22              byte >22                                            ; E         KYTB+13     E.C.M.
31233 8BFB   45            byte >45                                            ; J         KYTB+14     In-system jump
31234 8BFC 52              byte >52                                            ; C         KYTB+15     Docking computer
31235               
31236               * ******************************************************************************
31237               *
31238               * Name: DKS1
31239               * Type: Subroutine
31240               * Category: Keyboard
31241               * Summary: Scan the keyboard for a flight key
31242               * Deep dive: The key logger
31243               *
31244               * ------------------------------------------------------------------------------
31245               *
31246               * Scan the keyboard for the flight key given in register Y, where Y is the
31247               * offset into the KYTB table above (so we can scan for Space by setting Y to
31248               * 2, for example). If the key is pressed, set the corresponding byte in the
31249               * key logger at KL to &FF.
31250               *
31251               * ------------------------------------------------------------------------------
31252               *
31253               * Arguments:
31254               *
31255               * Y                   The offset into the KYTB table above of the key that we
31256               * want to scan on the keyboard
31257               *
31258               * ******************************************************************************
31259               
31260               DKS1:
31261 8BFE D062  26        movb @KYTB(ry),rx               ; LDX KYTB,Y        ; Get the internal key number from the Y-th byte of the
     8C00 8BED     
31262                                                                          ; KYTB table above
31263               
31264 8C02 0206  12        li   rtmp,DKS4                  ; JSR DKS4          ; Call DKS4, which will set A and X to a negative value
     8C04 8C1C     
31265 8C06 06A0  20        bl   @jsr                       ;
     8C08 8002     
31266                                                                          ; if the key is being pressed
31267               
31268 8C0A 151E  10        jgt  DKS2-1                     ; BPL DKS2-1        ; The key is not being pressed, so return from the
31269                                                                          ; subroutine (as DKS2-1 contains an RTS)
31270               
31271 8C0C 0201  12        li   rx,>ff*256                 ; LDX #&FF          ; Store &FF in the Y-th byte of the key logger at KL
     8C0E FF00     
31272 8C10 D881  30        movb rx,@KL(ry)                 ; STX KL,Y
     8C12 0041     
31273               
31274 8C14 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8C16 800E     
31275               
31276               * ******************************************************************************
31277               *
31278               * Name: CTRL
31279               * Type: Subroutine
31280               * Category: Keyboard
31281               * Summary: Scan the keyboard to see if CTRL is currently pressed
31282               *
31283               * ------------------------------------------------------------------------------
31284               *
31285               * Returns:
31286               *
31287               * X                   X = %10000001 (i.e. 129 or -127) if CTRL is being
31288               * pressed
31289               *
31290               * X = 1 if CTRL is not being pressed
31291               *
31292               * A                   Contains the same as X
31293               *
31294               * ******************************************************************************
31295               
31296               CTRL:
31297 8C18 0201  12        li   rx,>01*256                 ; LDX #1            ; Set X to the internal key number for CTRL and fall
     8C1A 0100     
31298                                                                          ; through to DKS4 to scan the keyboard
31299               
31300               * ******************************************************************************
31301               *
31302               * Name: DKS4
31303               * Type: Subroutine
31304               * Category: Keyboard
31305               * Summary: Scan the keyboard to see if a specific key is being pressed
31306               * Deep dive: The key logger
31307               *
31308               * ------------------------------------------------------------------------------
31309               *
31310               * Arguments:
31311               *
31312               * X                   The internal number of the key to check (see p.142 of
31313               * the Advanced User Guide for a list of internal key
31314               * numbers)
31315               *
31316               * ------------------------------------------------------------------------------
31317               *
31318               * Returns:
31319               *
31320               * A                   If the key in A is being pressed, A contains the
31321               * original argument A, but with bit 7 set (i.e. A + 128).
31322               * If the key in A is not being pressed, the value in A is
31323               * unchanged
31324               *
31325               * X                   Contains the same as A
31326               *
31327               * ******************************************************************************
31328               
31329               DKS4:
31330 8C1C 0200  12        li   ra,>03*256                 ; LDA #%00000011    ; Set A to %00000011, so it's ready to send to SHEILA
     8C1E 0300     
31331                                                                          ; once interrupts have been disabled
31332               
31333 8C20 0300  14        limi 0                          ; SEI               ; Disable interrupts so we can scan the keyboard
     8C22 0000     
31334                                                                          ; without being hijacked
31335               
31336 8C24 D800  30        movb ra,@VIA+>40                ; STA VIA+&40       ; Set 6522 System VIA output register ORB (SHEILA &40)
     8C26 FE40     
31337                                                                          ; to %00000011 to stop auto scan of keyboard
31338               
31339 8C28 0200  12        li   ra,>7f*256                 ; LDA #%01111111    ; Set 6522 System VIA data direction register DDRA
     8C2A 7F00     
31340 8C2C D800  30        movb ra,@VIA+>43                ; STA VIA+&43       ; (SHEILA &43) to %01111111. This sets the A registers
     8C2E FE43     
31341                                                                          ; (IRA and ORA) so that:
31342                                                                          ;
31343                                                                          ; * Bits 0-6 of ORA will be sent to the keyboard
31344                                                                          ;
31345                                                                          ; * Bit 7 of IRA will be read from the keyboard
31346               
31347 8C30 D801  30        movb rx,@VIA+>4F                ; STX VIA+&4F       ; Set 6522 System VIA output register ORA (SHEILA &4F)
     8C32 FE4F     
31348                                                                          ; to X, the key we want to scan for; bits 0-6 will be
31349                                                                          ; sent to the keyboard, of which bits 0-3 determine the
31350                                                                          ; keyboard column, and bits 4-6 the keyboard row
31351               
31352 8C34 D060  26        movb @VIA+>4F,rx                ; LDX VIA+&4F       ; Read 6522 System VIA output register IRA (SHEILA &4F)
     8C36 FE4F     
31353                                                                          ; into X; bit 7 is the only bit that will have changed.
31354                                                                          ; If the key is pressed, then bit 7 will be set,
31355                                                                          ; otherwise it will be clear
31356               
31357 8C38 0200  12        li   ra,>0b*256                 ; LDA #%00001011    ; Set 6522 System VIA output register ORB (SHEILA &40)
     8C3A 0B00     
31358 8C3C D800  30        movb ra,@VIA+>40                ; STA VIA+&40       ; to %00001011 to restart auto scan of keyboard
     8C3E FE40     
31359               
31360 8C40 0300  14        limi 2                          ; CLI               ; Allow interrupts again
     8C42 0002     
31361               
31362 8C44 D001  14        movb rx,ra                      ; TXA               ; Transfer X into A
31363               
31364 8C46 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8C48 800E     
31365               
31366               * ******************************************************************************
31367               *
31368               * Name: DKS2
31369               * Type: Subroutine
31370               * Category: Keyboard
31371               * Summary: Read the joystick position
31372               *
31373               * ------------------------------------------------------------------------------
31374               *
31375               * Return the value of ADC channel in X (used to read the joystick). The value
31376               * will be inverted if the game has been configured to reverse both joystick
31377               * channels (which can be done by pausing the game and pressing J).
31378               *
31379               * ------------------------------------------------------------------------------
31380               *
31381               * Arguments:
31382               *
31383               * X                   The ADC channel to read:
31384               *
31385               * * 1 = joystick X
31386               *
31387               * * 2 = joystick Y
31388               *
31389               * ------------------------------------------------------------------------------
31390               *
31391               * Returns:
31392               *
31393               * (A X)               The 16-bit value read from channel X, with the value
31394               * inverted if the game has been configured to reverse the
31395               * joystick
31396               *
31397               * ------------------------------------------------------------------------------
31398               *
31399               * Other entry points:
31400               *
31401               * DKS2-1              Contains an RTS
31402               *
31403               * ******************************************************************************
31404               
31405               DKS2:
31406 8C4A 0200  12        li   ra,>80*256                 ; LDA #128          ; Call OSBYTE with A = 128 to fetch the 16-bit value
     8C4C 8000     
31407 8C4E 0206  12        li   rtmp,OSBYTE                ; JSR OSBYTE        ; from ADC channel X, returning (Y X), i.e. the high
     8C50 FFF4     
31408 8C52 06A0  20        bl   @jsr                       ;
     8C54 8002     
31409                                                                          ; byte in Y and the low byte in X
31410                                                                          ;
31411                                                                          ; * Channel 1 is the x-axis: 0 = right, 65520 = left
31412                                                                          ;
31413                                                                          ; * Channel 2 is the y-axis: 0 = down,  65520 = up
31414               
31415 8C56 D002  14        movb ry,ra                      ; TYA               ; Copy Y to A, so the result is now in (A X)
31416               
31417                      .eor @JSTE                      ; EOR JSTE          ; The high byte A is now EOR'd with the value in
     **** ****     > EOR
0001 8C58 D1A0  22        movb @JSTE,rtmp
     8C5A 0F4F     
0002 8C5C 2806  14        xor  rtmp,ra
                   < elite.a99
31418                                                                          ; location JSTE, which contains &FF if both joystick
31419                                                                          ; channels are reversed and 0 otherwise (so A now
31420                                                                          ; contains the high byte but inverted, if that's what
31421                                                                          ; the current settings say)
31422               
31423 8C5E 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8C60 800E     
31424               
31425               * ******************************************************************************
31426               *
31427               * Name: DKS3
31428               * Type: Subroutine
31429               * Category: Keyboard
31430               * Summary: Toggle a configuration setting and emit a beep
31431               *
31432               * ------------------------------------------------------------------------------
31433               *
31434               * This is called when the game is paused and a key is pressed that changes the
31435               * game's configuration.
31436               *
31437               * Specifically, this routine toggles the configuration settings for the
31438               * following keys:
31439               *
31440               * * CAPS LOCK toggles keyboard flight damping (&40)
31441               * * A toggles keyboard auto-recentre (&41)
31442               * * X toggles author names on start-up screen (&42)
31443               * * F toggles flashing console bars (&43)
31444               * * Y toggles reverse joystick Y channel (&44)
31445               * * J toggles reverse both joystick channels (&45)
31446               * * K toggles keyboard and joystick (&46)
31447               *
31448               * The numbers in brackets are the internal key numbers (see p.142 of the
31449               * Advanced User Guide for a list of internal key numbers). We pass the key that
31450               * has been pressed in X, and the configuration option to check it against in Y,
31451               * so this routine is typically called in a loop that loops through the various
31452               * configuration options.
31453               *
31454               * ------------------------------------------------------------------------------
31455               *
31456               * Arguments:
31457               *
31458               * X                   The internal number of the key that's been pressed
31459               *
31460               * Y                   The internal number of the configuration key to check
31461               * against, from the list above (i.e. Y must be from &40 to
31462               * &46)
31463               *
31464               * ******************************************************************************
31465               
31466               DKS3:
31467 8C62 D802  22        movb ry,@T                      ; STY T             ; Store the configuration key argument in T
     8C64 00D1     
31468               
31469 8C66 9060  22        cb   @T,rx                      ; CPX T             ; If X <> Y, jump to Dk3 to return from the subroutine
     8C68 00D1     
31470 8C6A 1611  10        jne  Dk3                        ; BNE Dk3
31471               
31472                                                                          ; We have a match between X and Y, so now to toggle
31473                                                                          ; the relevant configuration byte. CAPS LOCK has a key
31474                                                                          ; value of &40 and has its configuration byte at
31475                                                                          ; location DAMP, A has a value of &41 and has its byte
31476                                                                          ; at location DJD, which is DAMP+1, and so on. So we
31477                                                                          ; can toggle the configuration byte by changing the
31478                                                                          ; byte at DAMP + (X - &40), or to put it in indexing
31479                                                                          ; terms, DAMP-&40,X. It's no coincidence that the
31480                                                                          ; game's configuration bytes are set up in this order
31481                                                                          ; and with these keys (and this is also why the sound
31482                                                                          ; on/off keys are dealt with elsewhere, as the internal
31483                                                                          ; key for S and Q are &51 and &10, which don't fit
31484                                                                          ; nicely into this approach)
31485               
31486 8C6C D021  26        movb @DAMP->40(rx),ra           ; LDA DAMP-&40,X    ; Fetch the byte from DAMP + (X - &40), invert it and
     8C6E 0F0A     
31487                      .eoi (>ff*256)                  ; EOR #&FF          ; put it back (0 means no and &FF means yes in the
     **** ****     > EOI
0001 8C70 0206  12        li   rtmp,(>FF*256)
     8C72 FF00     
0002 8C74 2806  14        xor  rtmp,ra
                   < elite.a99
31488 8C76 D840  30        movb ra,@DAMP->40(rx)           ; STA DAMP-&40,X    ; configuration bytes, so this toggles the setting)
     8C78 0F0A     
31489               
31490 8C7A 0206  12        li   rtmp,BELL                  ; JSR BELL          ; Make a beep sound so we know something has happened
     8C7C 316E     
31491 8C7E 06A0  20        bl   @jsr                       ;
     8C80 8002     
31492               
31493 8C82 0206  12        li   rtmp,DELAY                 ; JSR DELAY         ; Wait for Y vertical syncs (Y is between 64 and 70, so
     8C84 4C00     
31494 8C86 06A0  20        bl   @jsr                       ;
     8C88 8002     
31495                                                                          ; this is always a bit longer than a second)
31496               
31497 8C8A D0A0  22        movb @T,ry                      ; LDY T             ; Restore the configuration key argument into Y
     8C8C 00D1     
31498               
31499               Dk3:
31500 8C8E 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8C90 800E     
31501               
31502               * ******************************************************************************
31503               *
31504               * Name: DKJ1
31505               * Type: Subroutine
31506               * Category: Keyboard
31507               * Summary: Read joystick and flight controls
31508               *
31509               * ------------------------------------------------------------------------------
31510               *
31511               * Specifically, scan the keyboard for the speed up and slow down keys, and read
31512               * the joystick's fire button and X and Y axes, storing the results in the key
31513               * logger and the joystick position variables.
31514               *
31515               * This routine is only called if joysticks are enabled (JSTK = non-zero).
31516               *
31517               * ******************************************************************************
31518               
31519               DKJ1:
31520 8C92 0202  12        li   ry,>01*256                 ; LDY #1            ; Update the key logger for key 1 in the KYTB table, so
     8C94 0100     
31521 8C96 0206  12        li   rtmp,DKS1                  ; JSR DKS1          ; KY1 will be &FF if "?" (slow down) is being pressed
     8C98 8BFE     
31522 8C9A 06A0  20        bl   @jsr                       ;
     8C9C 8002     
31523               
31524 8C9E B084  14        ab   rone,ry                    ; INY               ; Update the key logger for key 2 in the KYTB table, so
31525 8CA0 0206  12        li   rtmp,DKS1                  ; JSR DKS1          ; KY2 will be &FF if Space (speed up) is being pressed
     8CA2 8BFE     
31526 8CA4 06A0  20        bl   @jsr                       ;
     8CA6 8002     
31527               
31528 8CA8 D020  26        movb @VIA+>40,ra                ; LDA VIA+&40       ; Read 6522 System VIA input register IRB (SHEILA &40)
     8CAA FE40     
31529               
31530 8CAC D040  14        movb ra,rx                      ; TAX               ; This instruction doesn't seem to have any effect, as
31531                                                                          ; X is overwritten in a few instructions. When the
31532                                                                          ; joystick is checked in a similar way in the TITLE
31533                                                                          ; subroutine for the "Press Fire Or Space,Commander."
31534                                                                          ; stage of the start-up screen, there's another
31535                                                                          ; unnecessary TAX instruction present, but there it's
31536                                                                          ; commented out
31537               
31538 8CAE 0240  14        andi ra,>10*256                 ; AND #%00010000    ; Bit 4 of IRB (PB4) is clear if joystick 1's fire
     8CB0 1000     
31539                                                                          ; button is pressed, otherwise it is set, so AND'ing
31540                                                                          ; the value of IRB with %10000 extracts this bit
31541               
31542                      .eoi (>10*256)                  ; EOR #%00010000    ; Flip bit 4 so that it's set if the fire button has
     **** ****     > EOI
0001 8CB2 0206  12        li   rtmp,(>10*256)
     8CB4 1000     
0002 8CB6 2806  14        xor  rtmp,ra
                   < elite.a99
31543 8CB8 D800  22        movb ra,@KY7                    ; STA KY7           ; been pressed, and store the result in the keyboard
     8CBA 0048     
31544                                                                          ; logger at location KY7, which is also where the A key
31545                                                                          ; (fire lasers) key is logged
31546               
31547 8CBC 0201  12        li   rx,>01*256                 ; LDX #1            ; Call DKS2 to fetch the value of ADC channel 1 (the
     8CBE 0100     
31548 8CC0 0206  12        li   rtmp,DKS2                  ; JSR DKS2          ; joystick X value) into (A X), and OR A with 1. This
     8CC2 8C4A     
31549 8CC4 06A0  20        bl   @jsr                       ;
     8CC6 8002     
31550 8CC8 0260  14        ori  ra,>01*256                 ; ORA #1            ; ensures that the high byte is at least 1, and then we
     8CCA 0100     
31551 8CCC D800  22        movb ra,@JSTX                   ; STA JSTX          ; store the result in JSTX
     8CCE 009C     
31552               
31553 8CD0 0201  12        li   rx,>02*256                 ; LDX #2            ; Call DKS2 to fetch the value of ADC channel 2 (the
     8CD2 0200     
31554 8CD4 0206  12        li   rtmp,DKS2                  ; JSR DKS2          ; joystick Y value) into (A X), and EOR A with JSTGY.
     8CD6 8C4A     
31555 8CD8 06A0  20        bl   @jsr                       ;
     8CDA 8002     
31556                      .eor @JSTGY                     ; EOR JSTGY         ; JSTGY will be &FF if the game is configured to
     **** ****     > EOR
0001 8CDC D1A0  22        movb @JSTGY,rtmp
     8CDE 0F4E     
0002 8CE0 2806  14        xor  rtmp,ra
                   < elite.a99
31557 8CE2 D800  22        movb ra,@JSTY                   ; STA JSTY          ; reverse the joystick Y channel, so this EOR does
     8CE4 009D     
31558                                                                          ; exactly that, and then we store the result in JSTY
31559               
31560 8CE6 0460  16        b    @DK4                       ; JMP DK4           ; We are done scanning the joystick flight controls,
     8CE8 8D6E     
31561                                                                          ; so jump to DK4 to scan for other keys, using a tail
31562                                                                          ; call so we can return from the subroutine there
31563               
31564               * ******************************************************************************
31565               *
31566               * Name: U%
31567               * Type: Subroutine
31568               * Category: Keyboard
31569               * Summary: Clear the key logger
31570               *
31571               * ------------------------------------------------------------------------------
31572               *
31573               * Returns:
31574               *
31575               * A                   A is set to 0
31576               *
31577               * Y                   Y is set to 0
31578               *
31579               * ******************************************************************************
31580               
31581               U.:
31582 8CEA 0200  12        li   ra,>00*256                 ; LDA #0            ; Set A to 0, as this means "key not pressed" in the
     8CEC 0000     
31583                                                                          ; key logger at KL
31584               
31585 8CEE 0202  12        li   ry,>0f*256                 ; LDY #15           ; We want to clear the 15 key logger locations from
     8CF0 0F00     
31586                                                                          ; KY1 to KY19, so set a counter in Y
31587               
31588               DKL3:
31589 8CF2 D880  30        movb ra,@KL(ry)                 ; STA KL,Y          ; Store 0 in the Y-th byte of the key logger
     8CF4 0041     
31590               
31591 8CF6 7084  14        sb   rone,ry                    ; DEY               ; Decrement the counter
31592               
31593 8CF8 16FC  10        jne  DKL3                       ; BNE DKL3          ; And loop back for the next key, until we have just
31594                                                                          ; KL+1. We don't want to clear the first key logger
31595                                                                          ; location at KL, as the keyboard table at KYTB starts
31596                                                                          ; with offset 1, not 0, so KL is not technically part of
31597                                                                          ; the key logger (it's actually used for logging keys
31598                                                                          ; that don't appear in the keyboard table, and which
31599                                                                          ; therefore don't use the key logger)
31600               
31601 8CFA 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8CFC 800E     
31602               
31603               * ******************************************************************************
31604               *
31605               * Name: DOKEY
31606               * Type: Subroutine
31607               * Category: Keyboard
31608               * Summary: Scan for the seven primary flight controls
31609               * Deep dive: The key logger
31610               * The docking computer
31611               *
31612               * ------------------------------------------------------------------------------
31613               *
31614               * Scan for the seven primary flight controls (or the equivalent on joystick),
31615               * pause and configuration keys, and secondary flight controls, and update the
31616               * key logger accordingly. Specifically:
31617               *
31618               * * If we are on keyboard configuration, clear the key logger and update it
31619               * for the seven primary flight controls, and update the pitch and roll
31620               * rates accordingly.
31621               *
31622               * * If we are on joystick configuration, clear the key logger and jump to
31623               * DKJ1, which reads the joystick equivalents of the primary flight
31624               * controls.
31625               *
31626               * Both options end up at DK4 to scan for other keys, beyond the seven primary
31627               * flight controls.
31628               *
31629               * ******************************************************************************
31630               
31631               DOKEY:
31632 8CFE 0206  12        li   rtmp,U.                    ; JSR U%            ; Call U% to clear the key logger
     8D00 8CEA     
31633 8D02 06A0  20        bl   @jsr                       ;
     8D04 8002     
31634               
31635 8D06 D020  22        movb @JSTK,ra                   ; LDA JSTK          ; If JSTK is non-zero, then we are configured to use
     8D08 0F50     
31636 8D0A 16C3  10        jne  DKJ1                       ; BNE DKJ1          ; the joystick rather than keyboard, so jump to DKJ1
31637                                                                          ; to read the joystick flight controls, before jumping
31638                                                                          ; to DK4 to scan for pause, configuration and secondary
31639                                                                          ; flight keys
31640               
31641 8D0C 0202  12        li   ry,>07*256                 ; LDY #7            ; We're going to work our way through the primary flight
     8D0E 0700     
31642                                                                          ; control keys (pitch, roll, speed and laser), so set a
31643                                                                          ; counter in Y so we can loop through all 7
31644               
31645               DKL2:
31646 8D10 0206  12        li   rtmp,DKS1                  ; JSR DKS1          ; Call DKS1 to see if the KYTB key at offset Y is being
     8D12 8BFE     
31647 8D14 06A0  20        bl   @jsr                       ;
     8D16 8002     
31648                                                                          ; pressed, and set the key logger accordingly
31649               
31650 8D18 7084  14        sb   rone,ry                    ; DEY               ; Decrement the loop counter
31651               
31652 8D1A 16FA  10        jne  DKL2                       ; BNE DKL2          ; Loop back for the next key, working our way from A at
31653                                                                          ; KYTB+7 down to ? at KYTB+1
31654               
31655 8D1C D060  22        movb @JSTX,rx                   ; LDX JSTX          ; Set X = JSTX, the current roll rate (as shown in the
     8D1E 009C     
31656                                                                          ; RL indicator on the dashboard)
31657               
31658 8D20 0200  12        li   ra,>07*256                 ; LDA #7            ; Set A to 7, which is the amount we want to alter the
     8D22 0700     
31659                                                                          ; roll rate by if the roll keys are being pressed
31660               
31661 8D24 D0A0  22        movb @KL+3,ry                   ; LDY KL+3          ; If the "<" key is being pressed, then call the BUMP2
     8D26 0044     
31662 8D28 1304  10        jeq  B103                       ; BEQ B103          ; routine to increase the roll rate in X by A
31663 8D2A 0206  12        li   rtmp,BUMP2                 ; JSR BUMP2
     8D2C 472E     
31664 8D2E 06A0  20        bl   @jsr                       ;
     8D30 8002     
31665               
31666               B103:
31667 8D32 D0A0  22        movb @KL+4,ry                   ; LDY KL+4          ; If the ">" key is being pressed, then call the REDU2
     8D34 0045     
31668 8D36 1304  10        jeq  B104                       ; BEQ B104          ; routine to decrease the roll rate in X by A, taking
31669 8D38 0206  12        li   rtmp,REDU2                 ; JSR REDU2         ; the keyboard auto re-centre setting into account
     8D3A 4750     
31670 8D3C 06A0  20        bl   @jsr                       ;
     8D3E 8002     
31671               
31672               B104:
31673 8D40 D801  22        movb rx,@JSTX                   ; STX JSTX          ; Store the updated roll rate in JSTX
     8D42 009C     
31674               
31675                      .asla                           ; ASL A             ; Double the value of A, to 14
     **** ****     > ASLA
0001 8D44 0240  14        andi ra,>ff00
     8D46 FF00     
0002 8D48 0A10  14        sla  ra,1
                   < elite.a99
31676               
31677 8D4A D060  22        movb @JSTY,rx                   ; LDX JSTY          ; Set X = JSTY, the current pitch rate (as shown in the
     8D4C 009D     
31678                                                                          ; DC indicator on the dashboard)
31679               
31680 8D4E D0A0  22        movb @KL+5,ry                   ; LDY KL+5          ; If the "X" key is being pressed, then call the REDU2
     8D50 0046     
31681 8D52 1304  10        jeq  B105                       ; BEQ B105          ; routine to decrease the pitch rate in X by A, taking
31682 8D54 0206  12        li   rtmp,REDU2                 ; JSR REDU2         ; the keyboard auto re-centre setting into account
     8D56 4750     
31683 8D58 06A0  20        bl   @jsr                       ;
     8D5A 8002     
31684               
31685               B105:
31686 8D5C D0A0  22        movb @KL+6,ry                   ; LDY KL+6          ; If the "S" key is being pressed, then call the BUMP2
     8D5E 0047     
31687 8D60 1304  10        jeq  B106                       ; BEQ B106          ; routine to increase the pitch rate in X by A
31688 8D62 0206  12        li   rtmp,BUMP2                 ; JSR BUMP2
     8D64 472E     
31689 8D66 06A0  20        bl   @jsr                       ;
     8D68 8002     
31690               
31691               B106:
31692 8D6A D801  22        movb rx,@JSTY                   ; STX JSTY          ; Store the updated roll rate in JSTY
     8D6C 009D     
31693               
31694                                                                          ; Fall through into DK4 to scan for other keys
31695               
31696               * ******************************************************************************
31697               *
31698               * Name: DK4
31699               * Type: Subroutine
31700               * Category: Keyboard
31701               * Summary: Scan for pause, configuration and secondary flight keys
31702               * Deep dive: The key logger
31703               *
31704               * ------------------------------------------------------------------------------
31705               *
31706               * Scan for pause and configuration keys, and if this is a space view, also scan
31707               * for secondary flight controls.
31708               *
31709               * Specifically:
31710               *
31711               * * Scan for the pause button (COPY) and if it's pressed, pause the game and
31712               * process any configuration key presses until the game is unpaused (DELETE)
31713               *
31714               * * If this is a space view, scan for secondary flight keys and update the
31715               * relevant bytes in the key logger
31716               *
31717               * ******************************************************************************
31718               
31719               DK4:
31720 8D6E 0206  12        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     8D70 8AE8     
31721 8D72 06A0  20        bl   @jsr                       ;
     8D74 8002     
31722                                                                          ; internal key number in X (or 0 for no key press)
31723               
31724 8D76 D801  22        movb rx,@KL                     ; STX KL            ; Store X in KL, byte #0 of the key logger
     8D78 0041     
31725               
31726 8D7A 0281  14        ci   rx,>69*256                 ; CPX #&69          ; If COPY is not being pressed, jump to DK2 below,
     8D7C 6900     
31727 8D7E 1626  10        jne  DK2                        ; BNE DK2           ; otherwise let's process the configuration keys
31728               
31729               FREEZE:
31730                                                                          ; COPY is being pressed, so we enter a loop that
31731                                                                          ; listens for configuration keys, and we keep looping
31732                                                                          ; until we detect a DELETE key press. This effectively
31733                                                                          ; pauses the game when COPY is pressed, and unpauses
31734                                                                          ; it when DELETE is pressed
31735 8D80 0206  12        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     8D82 4DE2     
31736 8D84 06A0  20        bl   @jsr                       ;
     8D86 8002     
31737                                                                          ; screen gets drawn
31738               
31739 8D88 0206  12        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     8D8A 8AE8     
31740 8D8C 06A0  20        bl   @jsr                       ;
     8D8E 8002     
31741                                                                          ; internal key number in X (or 0 for no key press)
31742               
31743 8D90 0281  14        ci   rx,>51*256                 ; CPX #&51          ; If "S" is not being pressed, skip to DK6
     8D92 5100     
31744 8D94 1604  10        jne  DK6                        ; BNE DK6
31745               
31746 8D96 0200  12        li   ra,>00*256                 ; LDA #0            ; "S" is being pressed, so set DNOIZ to 0 to turn the
     8D98 0000     
31747 8D9A D800  22        movb ra,@DNOIZ                  ; STA DNOIZ         ; sound on
     8D9C 0F49     
31748               
31749               DK6:
31750 8D9E 0202  12        li   ry,>40*256                 ; LDY #&40          ; We now want to loop through the keys that toggle
     8DA0 4000     
31751                                                                          ; various settings. These have internal key numbers
31752                                                                          ; between &40 (CAPS LOCK) and &46 ("K"), so we set up
31753                                                                          ; the first key number in Y to act as a loop counter.
31754                                                                          ; See subroutine DKS3 for more details on this
31755               
31756               DKL4:
31757 8DA2 0206  12        li   rtmp,DKS3                  ; JSR DKS3          ; Call DKS3 to scan for the key given in Y, and toggle
     8DA4 8C62     
31758 8DA6 06A0  20        bl   @jsr                       ;
     8DA8 8002     
31759                                                                          ; the relevant setting if it is pressed
31760               
31761 8DAA B084  14        ab   rone,ry                    ; INY               ; Increment Y to point to the next toggle key
31762               
31763 8DAC 0282  14        ci   ry,>47*256                 ; CPY #&47          ; The last toggle key is &46 (K), so check whether we
     8DAE 4700     
31764                                                                          ; have just done that one
31765               
31766 8DB0 16F8  10        jne  DKL4                       ; BNE DKL4          ; If not, loop back to check for the next toggle key
31767               
31768               DK55:
31769 8DB2 0281  14        ci   rx,>10*256                 ; CPX #&10          ; If "Q" is not being pressed, skip to DK7
     8DB4 1000     
31770 8DB6 1602  10        jne  DK7                        ; BNE DK7
31771               
31772 8DB8 D801  22        movb rx,@DNOIZ                  ; STX DNOIZ         ; "Q" is being pressed, so set DNOIZ to X, which is
     8DBA 0F49     
31773                                                                          ; non-zero (&10), so this will turn the sound off
31774               
31775               DK7:
31776 8DBC 0281  14        ci   rx,>70*256                 ; CPX #&70          ; If ESCAPE is not being pressed, skip over the next
     8DBE 7000     
31777 8DC0 1602  10        jne  B107                       ; BNE B107          ; instruction
31778               
31779 8DC2 0460  16        b    @DEATH2                    ; JMP DEATH2        ; ESCAPE is being pressed, so jump to DEATH2 to end
     8DC4 8590     
31780                                                                          ; the game
31781               
31782               B107:
31783 8DC6 0281  14        ci   rx,>59*256                 ; CPX #&59          ; If DELETE is not being pressed, we are still paused,
     8DC8 5900     
31784 8DCA 16DA  10        jne  FREEZE                     ; BNE FREEZE        ; so loop back up to keep listening for configuration
31785                                                                          ; keys, otherwise fall through into the rest of the
31786                                                                          ; key detection code, which unpauses the game
31787               
31788               DK2:
31789 8DCC D020  22        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is non-zero (i.e. not a space
     8DCE 0096     
31790 8DD0 160F  10        jne  DK5                        ; BNE DK5           ; view), return from the subroutine (as DK5 contains
31791                                                                          ; an RTS)
31792               
31793 8DD2 0202  12        li   ry,>0f*256                 ; LDY #15           ; This is a space view, so now we want to check for all
     8DD4 0F00     
31794                                                                          ; the secondary flight keys. The internal key numbers
31795                                                                          ; are in the keyboard table KYTB from KYTB+8 to
31796                                                                          ; KYTB+15, and their key logger locations are from KL+8
31797                                                                          ; to KL+15. So set a decreasing counter in Y for the
31798                                                                          ; index, starting at 15, so we can loop through them
31799               
31800 8DD6 0200  12        li   ra,>ff*256                 ; LDA #&FF          ; Set A to &FF so we can store this in the keyboard
     8DD8 FF00     
31801                                                                          ; logger for keys that are being pressed
31802               
31803               DKL1:
31804 8DDA D062  26        movb @KYTB(ry),rx               ; LDX KYTB,Y        ; Get the internal key number of the Y-th flight key
     8DDC 8BED     
31805                                                                          ; the KYTB keyboard table
31806               
31807 8DDE 9060  22        cb   @KL,rx                     ; CPX KL            ; We stored the key that's being pressed in KL above,
     8DE0 0041     
31808                                                                          ; so check to see if the Y-th flight key is being
31809                                                                          ; pressed
31810               
31811 8DE2 1602  10        jne  DK1                        ; BNE DK1           ; If it is not being pressed, skip to DK1 below
31812               
31813 8DE4 D880  30        movb ra,@KL(ry)                 ; STA KL,Y          ; The Y-th flight key is being pressed, so set that
     8DE6 0041     
31814                                                                          ; key's location in the key logger to &FF
31815               
31816               DK1:
31817 8DE8 7084  14        sb   rone,ry                    ; DEY               ; Decrement the loop counter
31818               
31819 8DEA 0282  14        ci   ry,>07*256                 ; CPY #7            ; Have we just done the last key?
     8DEC 0700     
31820               
31821 8DEE 16F5  10        jne  DKL1                       ; BNE DKL1          ; If not, loop back to process the next key
31822               
31823               DK5:
31824 8DF0 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8DF2 800E     
31825               
31826               * ******************************************************************************
31827               *
31828               * Name: TT217
31829               * Type: Subroutine
31830               * Category: Keyboard
31831               * Summary: Scan the keyboard until a key is pressed
31832               *
31833               * ------------------------------------------------------------------------------
31834               *
31835               * Scan the keyboard until a key is pressed, and return the key's ASCII code.
31836               * If, on entry, a key is already being held down, then wait until that key is
31837               * released first (so this routine detects the first key down event following
31838               * the subroutine call).
31839               *
31840               * ------------------------------------------------------------------------------
31841               *
31842               * Returns:
31843               *
31844               * X                   The ASCII code of the key that was pressed
31845               *
31846               * A                   Contains the same as X
31847               *
31848               * Y                   Y is preserved
31849               *
31850               * ------------------------------------------------------------------------------
31851               *
31852               * Other entry points:
31853               *
31854               * out                 Contains an RTS
31855               *
31856               * ******************************************************************************
31857               
31858               TT217:
31859 8DF4 D802  22        movb ry,@YSAV                   ; STY YSAV          ; Store Y in temporary storage, so we can restore it
     8DF6 0094     
31860                                                                          ; later
31861               
31862               t_:
31863 8DF8 0206  12        li   rtmp,DELAY-5               ; JSR DELAY-5       ; Delay for 8 vertical syncs (8/50 = 0.16 seconds) so we
     8DFA 4BFB     
31864 8DFC 06A0  20        bl   @jsr                       ;
     8DFE 8002     
31865                                                                          ; don't take up too much CPU time while looping round
31866               
31867 8E00 0206  12        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     8E02 8AE8     
31868 8E04 06A0  20        bl   @jsr                       ;
     8E06 8002     
31869                                                                          ; internal key number in X (or 0 for no key press)
31870               
31871 8E08 16F7  10        jne  t_                         ; BNE t             ; If a key was already being held down when we entered
31872                                                                          ; this routine, keep looping back up to t, until the
31873                                                                          ; key is released
31874               
31875               t2_:
31876 8E0A 0206  12        li   rtmp,RDKEY                 ; JSR RDKEY         ; Any pre-existing key press is now gone, so we can
     8E0C 8AE8     
31877 8E0E 06A0  20        bl   @jsr                       ;
     8E10 8002     
31878                                                                          ; start scanning the keyboard again, returning the
31879                                                                          ; internal key number in X (or 0 for no key press)
31880               
31881 8E12 13FB  10        jeq  t2_                        ; BEQ t2            ; Keep looping up to t2 until a key is pressed
31882               
31883 8E14 D080  14        movb ra,ry                      ; TAY               ; Copy A to Y, so Y contains the internal key number
31884                                                                          ; of the key pressed
31885               
31886                      .ld_ind_y_idx @TRTB.,ra         ; LDA (TRTB%),Y     ; The address in TRTB% points to the MOS key
     **** ****     > LD_IND_Y_IDX
0001 8E16 D820  30        movb @TRTB.,@rtmplb
     8E18 0004     
     8E1A 830D     
0002 8E1C D1A0  22        movb @TRTB.+1,rtmp
     8E1E 0005     
0003 8E20 A182  14        a    ry,rtmp
0004 8E22 D016  22        movb *rtmp,RA
                   < elite.a99
31887                                                                          ; translation table, which is used to translate
31888                                                                          ; internal key numbers to ASCII, so this fetches the
31889                                                                          ; key's ASCII code into A
31890               
31891 8E24 D0A0  22        movb @YSAV,ry                   ; LDY YSAV          ; Restore the original value of Y we stored above
     8E26 0094     
31892               
31893 8E28 D040  14        movb ra,rx                      ; TAX               ; Copy A into X
31894               
31895               out_:
31896 8E2A 0460  16        b    @rts                       ; RTS               ; Return from the subroutine
     8E2C 800E     
31897               
31898               * ******************************************************************************
31899               *
31900               * Name: me1
31901               * Type: Subroutine
31902               * Category: Flight
31903               * Summary: Erase an old in-flight message and display a new one
31904               *
31905               * ------------------------------------------------------------------------------
31906               *
31907               * Arguments:
31908               *
31909               * A                   The text token to be printed
31910               *
31911               * X                   Must be set to 0
31912               *
31913               * ******************************************************************************
31914               
31915               me1_:
31916 8E2E D801  22        movb rx,@DLY                    ; STX DLY           ; Set the message delay in DLY to 0, so any new
     8E30 0D64     
31917                                                                          ; in-flight messages will be shown instantly
31918               
31919                      .pha                            ; PHA               ; Store the new message token we want to print
     **** ****     > PHA
0001 8E32 D680  26        movb ra,*rsp
0002 8E34 060A  10        dec  rsp
                   < elite.a99
31920               
31921 8E36 D020  22        movb @MCH,ra                    ; LDA MCH           ; Set A to the token number of the message that is
     8E38 0F10     
31922 8E3A 0206  12        li   rtmp,mes9_                 ; JSR mes9          ; currently on-screen, and call mes9 to print it (which
     8E3C 8E78     
31923 8E3E 06A0  20        bl   @jsr                       ;
     8E40 8002     
31924                                                                          ; will remove it from the screen, as printing is done
31925                                                                          ; using EOR logic)
31926               
31927                      .pla                            ; PLA               ; Restore the new message token
     **** ****     > PLA
0001 8E42 058A  10        inc  rsp
0002 8E44 D01A  22        movb *rsp,ra
                   < elite.a99
31928               
31929 8E46 2C              byte >2c                                            ; Fall through into ou2 to print the new message, but
31930                                                                          ; skip the first instruction by turning it into
31931                                                                          ; &2C &A9 &6C, or BIT &6CA9, which does nothing apart
31932                                                                          ; from affect the flags
31933               
31934               * ******************************************************************************
31935               *
31936               * Name: ou2
31937               * Type: Subroutine
31938               * Category: Flight
31939               * Summary: Display "E.C.M.SYSTEM DESTROYED" as an in-flight message
31940               *
31941               * ******************************************************************************
31942               
31943               ou2_:
31944 8E48 0200  12        li   ra,>6c*256                 ; LDA #108          ; Set A to recursive token 108 ("E.C.M.SYSTEM")
     8E4A 6C00     
31945               
31946 8E4C 2C              byte >2c                                            ; Fall through into ou3 to print the new message, but
31947                                                                          ; skip the first instruction by turning it into
31948                                                                          ; &2C &A9 &6F, or BIT &6FA9, which does nothing apart
31949                                                                          ; from affect the flags
31950               
31951               * ******************************************************************************
31952               *
31953               * Name: ou3
31954               * Type: Subroutine
31955               * Category: Flight
31956               * Summary: Display "FUEL SCOOPS DESTROYED" as an in-flight message
31957               *
31958               * ******************************************************************************
31959               
31960               ou3_:
31961 8E4E 0200  12        li   ra,>6f*256                 ; LDA #111          ; Set A to recursive token 111 ("FUEL SCOOPS")
     8E50 6F00     
31962               
31963               * ******************************************************************************
31964               *
31965               * Name: MESS
31966               * Type: Subroutine
31967               * Category: Flight
31968               * Summary: Display an in-flight message
31969               *
31970               * ------------------------------------------------------------------------------
31971               *
31972               * Display an in-flight message in capitals at the bottom of the space view,
31973               * erasing any existing in-flight message first.
31974               *
31975               * ------------------------------------------------------------------------------
31976               *
31977               * Arguments:
31978               *
31979               * A                   The text token to be printed
31980               *
31981               * ******************************************************************************
31982               
31983               MESS:
31984 8E52 0201  12        li   rx,>00*256                 ; LDX #0            ; Set QQ17 = 0 to switch to ALL CAPS
     8E54 0000     
31985 8E56 D801  22        movb rx,@QQ17                   ; STX QQ17
     8E58 007E     
31986               
31987 8E5A 0202  12        li   ry,>09*256                 ; LDY #9            ; Move the text cursor to column 9, row 22, at the
     8E5C 0900     
31988 8E5E D802  22        movb ry,@XC                     ; STY XC            ; bottom middle of the screen, and set Y = 22
     8E60 002C     
31989 8E62 0202  12        li   ry,>16*256                 ; LDY #22
     8E64 1600     
31990 8E66 D802  22        movb ry,@YC                     ; STY YC
     8E68 002D     
31991               
31992 8E6A 9060  22        cb   @DLY,rx                    ; CPX DLY           ; If the message delay in DLY is not zero, jump up to
     8E6C 0D64     
31993 8E6E 16DF  10        jne  me1_                       ; BNE me1           ; me1 to erase the current message first (whose token
31994                                                                          ; number will be in MCH)
31995               
31996 8E70 D802  22        movb ry,@DLY                    ; STY DLY           ; Set the message delay in DLY to 22
     8E72 0D64     
31997               
31998 8E74 D800  22        movb ra,@MCH                    ; STA MCH           ; Set MCH to the token we are about to display
     8E76 0F10     
31999               
32000                                                                          ; Fall through into mes9 to print the token in A
32001               
32002               * ******************************************************************************
32003               *
32004               * Name: mes9
32005               * Type: Subroutine
32006               * Category: Flight
32007               * Summary: Print a text token, possibly followed by " DESTROYED"
32008               *
32009               * ------------------------------------------------------------------------------
32010               *
32011               * Print a text token, followed by " DESTROYED" if the destruction flag is set
32012               * (for when a piece of equipment is destroyed).
32013               *
32014               * ******************************************************************************
32015               
32016               mes9_:
32017 8E78 0206  12        li   rtmp,TT27                  ; JSR TT27          ; Call TT27 to print the text token in A
     8E7A 66DC     
32018 8E7C 06A0  20        bl   @jsr                       ;
     8E7E 8002     
32019               
32020                      .lsr @de_                       ; LSR de            ; If bit 0 of variable de is clear, return from the
     **** ****     > LSR
0001 8E80 D1A0  22        movb @DE_,rtmp
     8E82 0D65     
0002 8E84 0916  14        srl  rtmp,1
0003 8E86 D806  22        movb rtmp,@DE_
     8E88 0D65     
                   < elite.a99
32021 8E8A 17CF  10        jnc  out_                       ; BCC out           ; subroutine (as out contains an RTS)
32022               
32023 8E8C 0200  12        li   ra,>fd*256                 ; LDA #253          ; Print recursive token 93 (" DESTROYED") and return
     8E8E FD00     
32024 8E90 0460  20        b    @TT27                      ; JMP TT27          ; from the subroutine using a tail call
     8E92 66DC     
32025               
32026               * ******************************************************************************
32027               *
32028               * Name: OUCH
32029               * Type: Subroutine
32030               * Category: Flight
32031               * Summary: Potentially lose cargo or equipment following damage
32032               *
32033               * ------------------------------------------------------------------------------
32034               *
32035               * Our shields are dead and we are taking damage, so there is a small chance of
32036               * losing cargo or equipment.
32037               *
32038               * ******************************************************************************
32039               
32040               OUCH:
32041 8E94 0206  12        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     8E96 8070     
32042 8E98 06A0  20        bl   @jsr                       ;
     8E9A 8002     
32043               
32044 8E9C 11C6  10        jlt  out_                       ; BMI out           ; If A < 0 (50% chance), return from the subroutine
32045                                                                          ; (as out contains an RTS)
32046               
32047 8E9E 0281  14        ci   rx,>16*256                 ; CPX #22           ; If X >= 22 (91% chance), return from the subroutine
     8EA0 1600     
32048 8EA2 18C3  10        joc  out_                       ; BCS out           ; (as out contains an RTS)
32049               
32050 8EA4 D021  26        movb @QQ20(rx),ra               ; LDA QQ20,X        ; If we do not have any of item QQ20+X, return from the
     8EA6 0317     
32051 8EA8 13C0  10        jeq  out_                       ; BEQ out           ; subroutine (as out contains an RTS). X is in the range
32052                                                                          ; 0-21, so this not only checks for cargo, but also for
32053                                                                          ; E.C.M., fuel scoops, energy bomb, energy unit and
32054                                                                          ; docking computer, all of which can be destroyed
32055               
32056 8EAA D020  22        movb @DLY,ra                    ; LDA DLY           ; If there is already an in-flight message on-screen,
     8EAC 0D64     
32057 8EAE 16BD  10        jne  out_                       ; BNE out           ; return from the subroutine (as out contains an RTS)
32058               
32059 8EB0 0202  12        li   ry,>03*256                 ; LDY #3            ; Set bit 1 of de, the equipment destruction flag, so
     8EB2 0300     
32060 8EB4 D802  22        movb ry,@de_                    ; STY de            ; that when we call MESS below, " DESTROYED" is appended
     8EB6 0D65     
32061                                                                          ; to the in-flight message
32062               
32063 8EB8 D840  30        movb ra,@QQ20(rx)               ; STA QQ20,X        ; A is 0 (as we didn't branch with the BNE above), so
     8EBA 0317     
32064                                                                          ; this sets QQ20+X to 0, which destroys any cargo or
32065                                                                          ; equipment we have of that type
32066               
32067 8EBC 0281  14        ci   rx,>11*256                 ; CPX #17           ; If X >= 17 then we just lost a piece of equipment, so
     8EBE 1100     
32068 8EC0 1806  10        joc  ou1_                       ; BCS ou1           ; jump to ou1 to print the relevant message
32069               
32070 8EC2 D001  14        movb rx,ra                      ; TXA               ; Print recursive token 48 + A as an in-flight token,
32071                      .adi (>d0*256)                  ; ADC #208          ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
     **** ****     > ADI
0001 8EC4 1701  10        jnc  !
0002 8EC6 B004  14        ab   rone,ra
0003               !:
0004 8EC8 0220  14        ai   ra,(>D0*256)
     8ECA D000     
                   < elite.a99
32072 8ECC 16C2  10        jne  MESS                       ; BNE MESS          ; ITEMS") as the C flag is clear, so this prints the
32073                                                                          ; destroyed item's name, followed by " DESTROYED" (as we
32074                                                                          ; set bit 1 of the de flag above), and returns from the
32075                                                                          ; subroutine using a tail call
32076               
32077               ou1_:
32078 8ECE 13BC  10        jeq  ou2_                       ; BEQ ou2           ; If X = 17, jump to ou2 to print "E.C.M.SYSTEM
32079                                                                          ; DESTROYED" and return from the subroutine using a tail
32080                                                                          ; call
32081               
32082 8ED0 0281  14        ci   rx,>12*256                 ; CPX #18           ; If X = 18, jump to ou3 to print "FUEL SCOOPS
     8ED2 1200     
32083 8ED4 13BC  10        jeq  ou3_                       ; BEQ ou3           ; DESTROYED" and return from the subroutine using a tail
32084                                                                          ; call
32085               
32086 8ED6 D001  14        movb rx,ra                      ; TXA               ; Otherwise X is in the range 19 to 21 and the C flag is
32087                      .adi ((113-20)*256)             ; ADC #113-20       ; set (as we got here via a BCS to ou1), so we set A as
     **** ****     > ADI
0001 8ED8 1701  10        jnc  !
0002 8EDA B004  14        ab   rone,ra
0003               !:
0004 8EDC 0220  14        ai   ra,((113-20)*256)
     8EDE 5D00     
                   < elite.a99
32088                                                                          ; follows:
32089                                                                          ;
32090                                                                          ; A = 113 - 20 + X + C
32091                                                                          ; = 113 - 19 + X
32092                                                                          ; = 113 to 115
32093               
32094 8EE0 16B8  10        jne  MESS                       ; BNE MESS          ; Print recursive token A ("ENERGY BOMB", "ENERGY UNIT"
32095                                                                          ; or "DOCKING COMPUTERS") as an in-flight message,
32096                                                                          ; followed by " DESTROYED", and return from the
32097                                                                          ; subroutine using a tail call
32098               
32099               * ******************************************************************************
32100               *
32101               * Name: QQ16
32102               * Type: Variable
32103               * Category: Text
32104               * Summary: The two-letter token lookup table
32105               * Deep dive: Printing text tokens
32106               *
32107               * ------------------------------------------------------------------------------
32108               *
32109               * Two-letter token lookup table for tokens 128-159. See the deep dive on
32110               * "Printing text tokens" for details of how the two-letter token system works.
32111               *
32112               * ******************************************************************************
32113               
32114               QQ16:
32115 8EE2 414C            text 'AL'                                           ; Token 128
32116 8EE4 4C45            text 'LE'                                           ; Token 129
32117 8EE6 5845            text 'XE'                                           ; Token 130
32118 8EE8 4745            text 'GE'                                           ; Token 131
32119 8EEA 5A41            text 'ZA'                                           ; Token 132
32120 8EEC 4345            text 'CE'                                           ; Token 133
32121 8EEE 4249            text 'BI'                                           ; Token 134
32122 8EF0 534F            text 'SO'                                           ; Token 135
32123 8EF2 5553            text 'US'                                           ; Token 136
32124 8EF4 4553            text 'ES'                                           ; Token 137
32125 8EF6 4152            text 'AR'                                           ; Token 138
32126 8EF8 4D41            text 'MA'                                           ; Token 139
32127 8EFA 494E            text 'IN'                                           ; Token 140
32128 8EFC 4449            text 'DI'                                           ; Token 141
32129 8EFE 5245            text 'RE'                                           ; Token 142
32130 8F00 413F            text 'A?'                                           ; Token 143
32131 8F02 4552            text 'ER'                                           ; Token 144
32132 8F04 4154            text 'AT'                                           ; Token 145
32133 8F06 454E            text 'EN'                                           ; Token 146
32134 8F08 4245            text 'BE'                                           ; Token 147
32135 8F0A 5241            text 'RA'                                           ; Token 148
32136 8F0C 4C41            text 'LA'                                           ; Token 149
32137 8F0E 5645            text 'VE'                                           ; Token 150
32138 8F10 5449            text 'TI'                                           ; Token 151
32139 8F12 4544            text 'ED'                                           ; Token 152
32140 8F14 4F52            text 'OR'                                           ; Token 153
32141 8F16 5155            text 'QU'                                           ; Token 154
32142 8F18 414E            text 'AN'                                           ; Token 155
32143 8F1A 5445            text 'TE'                                           ; Token 156
32144 8F1C 4953            text 'IS'                                           ; Token 157
32145 8F1E 5249            text 'RI'                                           ; Token 158
32146 8F20 4F4E            text 'ON'                                           ; Token 159
32147               
32148               * ******************************************************************************
32149               *
32150               * Name: ITEM
32151               * Type: Macro
32152               * Category: Market
32153               * Summary: Macro definition for the market prices table
32154               * Deep dive: Market item prices and availability
32155               *
32156               * ------------------------------------------------------------------------------
32157               *
32158               * The following macro is used to build the market prices table:
32159               *
32160               * ITEM price, factor, units, quantity, mask
32161               *
32162               * It inserts an item into the market prices table at QQ23. See the deep dive on
32163               * "Market item prices and availability" for more information on how the market
32164               * system works.
32165               *
32166               * ------------------------------------------------------------------------------
32167               *
32168               * Arguments:
32169               *
32170               * price               Base price
32171               *
32172               * factor              Economic factor
32173               *
32174               * units               Units: "t", "g" or "k"
32175               *
32176               * quantity            Base quantity
32177               *
32178               * mask                Fluctuations mask
32179               *
32180               * ******************************************************************************
32181               
32182                      ; MACRO ITEM price, factor, units, quantity, mask
32183               
32184                      ; IF factor < 0                 ;
32185                      ; s = 1 << 7                    ;
32186                      ; ELSE                          ;
32187                      ; s = 0                         ;
32188                      ; ENDIF                         ;
32189               
32190                      ; IF units = 't'                ;
32191                      ; u = 0                         ;
32192                      ; ELIF units = 'k'              ;
32193                      ; u = 1 << 5                    ;
32194                      ; ELSE                          ;
32195                      ; u = 1 << 6                    ;
32196                      ; ENDIF                         ;
32197               
32198                      ; e = ABS(factor)               ;
32199               
32200                      ; EQUB price                    ;
32201                      ; EQUB s + u + e                ;
32202                      ; EQUB quantity                 ;
32203                      ; EQUB mask                     ;
32204               
32205                      ; ENDMACRO
32206               
32207               * ******************************************************************************
32208               *
32209               * Name: QQ23
32210               * Type: Variable
32211               * Category: Market
32212               * Summary: Market prices table
32213               *
32214               * ------------------------------------------------------------------------------
32215               *
32216               * Each item has four bytes of data, like this:
32217               *
32218               * Byte #0 = Base price
32219               * Byte #1 = Economic factor in bits 0-4, with the sign in bit 7
32220               * Unit in bits 5-6
32221               * Byte #2 = Base quantity
32222               * Byte #3 = Mask to control price fluctuations
32223               *
32224               * To make it easier for humans to follow, we've defined a macro called ITEM
32225               * that takes the following arguments and builds the four bytes for us:
32226               *
32227               * ITEM base price, economic factor, units, base quantity, mask
32228               *
32229               * So for food, we have the following:
32230               *
32231               * * Base price = 19
32232               * * Economic factor = -2
32233               * * Unit = tonnes
32234               * * Base quantity = 6
32235               * * Mask = %00000001
32236               *
32237               * ******************************************************************************
32238               
32239               QQ23:
32240 8F22 1382            byte >13, >82, >06, >01                             ; 0 = Food
     8F24 0601     
32241 8F26 1481            byte >14, >81, >0a, >03                             ; 1 = Textiles
     8F28 0A03     
32242 8F2A 4183            byte >41, >83, >02, >07                             ; 2 = Radioactives
     8F2C 0207     
32243 8F2E 2885            byte >28, >85, >e2, >1f                             ; 3 = Slaves
     8F30 E21F     
32244 8F32 5385            byte >53, >85, >fb, >0f                             ; 4 = Liquor/Wines
     8F34 FB0F     
32245 8F36 C408            byte >c4, >08, >36, >03                             ; 5 = Luxuries
     8F38 3603     
32246 8F3A EB1D            byte >eb, >1d, >08, >78                             ; 6 = Narcotics
     8F3C 0878     
32247 8F3E 9A0E            byte >9a, >0e, >38, >03                             ; 7 = Computers
     8F40 3803     
32248 8F42 7506            byte >75, >06, >28, >07                             ; 8 = Machinery
     8F44 2807     
32249 8F46 4E01            byte >4e, >01, >11, >1f                             ; 9 = Alloys
     8F48 111F     
32250 8F4A 7C0D            byte >7c, >0d, >1d, >07                             ; 10 = Firearms
     8F4C 1D07     
32251 8F4E B089            byte >b0, >89, >dc, >3f                             ; 11 = Furs
     8F50 DC3F     
32252 8F52 2081            byte >20, >81, >35, >03                             ; 12 = Minerals
     8F54 3503     
32253 8F56 61A1            byte >61, >a1, >42, >07                             ; 13 = Gold
     8F58 4207     
32254 8F5A ABA2            byte >ab, >a2, >37, >1f                             ; 14 = Platinum
     8F5C 371F     
32255 8F5E 2DC1            byte >2d, >c1, >fa, >0f                             ; 15 = Gem-Stones
     8F60 FA0F     
32256 8F62 350F            byte >35, >0f, >c0, >07                             ; 16 = Alien items
     8F64 C007     
32257               
32258               * ******************************************************************************
32259               *
32260               * Name: TIDY
32261               * Type: Subroutine
32262               * Category: Maths (Geometry)
32263               * Summary: Orthonormalise the orientation vectors for a ship
32264               * Deep dive: Tidying orthonormal vectors
32265               * Orientation vectors
32266               *
32267               * ------------------------------------------------------------------------------
32268               *
32269               * This routine orthonormalises the orientation vectors for a ship. This means
32270               * making the three orientation vectors orthogonal (perpendicular to each other),
32271               * and normal (so each of the vectors has length 1).
32272               *
32273               * We do this because we use the small angle approximation to rotate these
32274               * vectors in space. It is not completely accurate, so the three vectors tend
32275               * to get stretched over time, so periodically we tidy the vectors with this
32276               * routine to ensure they remain as orthonormal as possible.
32277               *
32278               * ******************************************************************************
32279               
32280               TI2:
32281                                                                          ; Called from below with A = 0, X = 0, Y = 4 when
32282                                                                          ; nosev_x and nosev_y are small, so we assume that
32283                                                                          ; nosev_z is big
32284 8F66 D002  14        movb ry,ra                      ; TYA               ; A = Y = 4
32285 8F68 0202  12        li   ry,>02*256                 ; LDY #2
     8F6A 0200     
32286 8F6C 0206  12        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 0, Y = 2, A = 4, to set roofv_z =
     8F6E 9126     
32287 8F70 06A0  20        bl   @jsr                       ;
     8F72 8002     
32288 8F74 D800  22        movb ra,@INWK+20                ; STA INWK+20       ; -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
     8F76 0067     
32289               
32290 8F78 0460  16        b    @TI3                       ; JMP TI3           ; Jump to TI3 to keep tidying
     8F7A 8FF6     
32291               
32292               TI1:
32293                                                                          ; Called from below with A = 0, Y = 4 when nosev_x is
32294                                                                          ; small
32295 8F7C D040  14        movb ra,rx                      ; TAX               ; Set X = A = 0
32296               
32297 8F7E D020  22        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A = nosev_y, and if the top two magnitude bits
     8F80 0032     
32298 8F82 0240  14        andi ra,>60*256                 ; AND #%01100000    ; are both clear, jump to TI2 with A = 0, X = 0, Y = 4
     8F84 6000     
32299 8F86 13EF  10        jeq  TI2                        ; BEQ TI2
32300               
32301 8F88 0200  12        li   ra,>02*256                 ; LDA #2            ; Otherwise nosev_y is big, so set up the index values
     8F8A 0200     
32302                                                                          ; to pass to TIS3
32303               
32304 8F8C 0206  12        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 0, Y = 4, A = 2, to set roofv_y =
     8F8E 9126     
32305 8F90 06A0  20        bl   @jsr                       ;
     8F92 8002     
32306 8F94 D800  22        movb ra,@INWK+18                ; STA INWK+18       ; -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
     8F96 0065     
32307               
32308 8F98 0460  16        b    @TI3                       ; JMP TI3           ; Jump to TI3 to keep tidying
     8F9A 8FF6     
32309               
32310               TIDY:
32311 8F9C D020  22        movb @INWK+10,ra                ; LDA INWK+10       ; Set (XX15, XX15+1, XX15+2) = nosev
     8F9E 005D     
32312 8FA0 D800  22        movb ra,@XX15                   ; STA XX15
     8FA2 0031     
32313 8FA4 D020  22        movb @INWK+12,ra                ; LDA INWK+12
     8FA6 005F     
32314 8FA8 D800  22        movb ra,@XX15+1                 ; STA XX15+1
     8FAA 0032     
32315 8FAC D020  22        movb @INWK+14,ra                ; LDA INWK+14
     8FAE 0061     
32316 8FB0 D800  22        movb ra,@XX15+2                 ; STA XX15+2
     8FB2 0033     
32317               
32318 8FB4 0206  12        li   rtmp,NORM                  ; JSR NORM          ; Call NORM to normalise the vector in XX15, i.e. nosev
     8FB6 8A34     
32319 8FB8 06A0  20        bl   @jsr                       ;
     8FBA 8002     
32320               
32321 8FBC D020  22        movb @XX15,ra                   ; LDA XX15          ; Set nosev = (XX15, XX15+1, XX15+2)
     8FBE 0031     
32322 8FC0 D800  22        movb ra,@INWK+10                ; STA INWK+10
     8FC2 005D     
32323 8FC4 D020  22        movb @XX15+1,ra                 ; LDA XX15+1
     8FC6 0032     
32324 8FC8 D800  22        movb ra,@INWK+12                ; STA INWK+12
     8FCA 005F     
32325 8FCC D020  22        movb @XX15+2,ra                 ; LDA XX15+2
     8FCE 0033     
32326 8FD0 D800  22        movb ra,@INWK+14                ; STA INWK+14
     8FD2 0061     
32327               
32328 8FD4 0202  12        li   ry,>04*256                 ; LDY #4            ; Set Y = 4
     8FD6 0400     
32329               
32330 8FD8 D020  22        movb @XX15,ra                   ; LDA XX15          ; Set A = nosev_x, and if the top two magnitude bits
     8FDA 0031     
32331 8FDC 0240  14        andi ra,>60*256                 ; AND #%01100000    ; are both clear, jump to TI1 with A = 0, Y = 4
     8FDE 6000     
32332 8FE0 13CD  10        jeq  TI1                        ; BEQ TI1
32333               
32334 8FE2 0201  12        li   rx,>02*256                 ; LDX #2            ; Otherwise nosev_x is big, so set up the index values
     8FE4 0200     
32335 8FE6 0200  12        li   ra,>00*256                 ; LDA #0            ; to pass to TIS3
     8FE8 0000     
32336               
32337 8FEA 0206  12        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 2, Y = 4, A = 0, to set roofv_x =
     8FEC 9126     
32338 8FEE 06A0  20        bl   @jsr                       ;
     8FF0 8002     
32339 8FF2 D800  22        movb ra,@INWK+16                ; STA INWK+16       ; -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
     8FF4 0063     
32340               
32341               TI3:
32342 8FF6 D020  22        movb @INWK+16,ra                ; LDA INWK+16       ; Set (XX15, XX15+1, XX15+2) = roofv
     8FF8 0063     
32343 8FFA D800  22        movb ra,@XX15                   ; STA XX15
     8FFC 0031     
32344 8FFE D020  22        movb @INWK+18,ra                ; LDA INWK+18
     9000 0065     
32345 9002 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     9004 0032     
32346 9006 D020  30        movb @INWK+20,ra                ; LDA INWK+20
     9008 0067     
32347 900A D800  30        movb ra,@XX15+2                 ; STA XX15+2
     900C 0033     
32348               
32349 900E 0206  20        li   rtmp,NORM                  ; JSR NORM          ; Call NORM to normalise the vector in XX15, i.e. roofv
     9010 8A34     
32350 9012 06A0  28        bl   @jsr                       ;
     9014 8002     
32351               
32352 9016 D020  30        movb @XX15,ra                   ; LDA XX15          ; Set roofv = (XX15, XX15+1, XX15+2)
     9018 0031     
32353 901A D800  30        movb ra,@INWK+16                ; STA INWK+16
     901C 0063     
32354 901E D020  30        movb @XX15+1,ra                 ; LDA XX15+1
     9020 0032     
32355 9022 D800  30        movb ra,@INWK+18                ; STA INWK+18
     9024 0065     
32356 9026 D020  30        movb @XX15+2,ra                 ; LDA XX15+2
     9028 0033     
32357 902A D800  30        movb ra,@INWK+20                ; STA INWK+20
     902C 0067     
32358               
32359 902E D020  30        movb @INWK+12,ra                ; LDA INWK+12       ; Set Q = nosev_y
     9030 005F     
32360 9032 D800  30        movb ra,@Q                      ; STA Q
     9034 0090     
32361               
32362 9036 D020  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z
     9038 0067     
32363               
32364 903A 0206  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_y * roofv_z
     903C 445E     
32365 903E 06A0  28        bl   @jsr                       ;
     9040 8002     
32366               
32367 9042 D060  30        movb @INWK+14,rx                ; LDX INWK+14       ; Set X = nosev_z
     9044 0061     
32368               
32369 9046 D020  30        movb @INWK+18,ra                ; LDA INWK+18       ; Set A = roofv_y
     9048 0065     
32370               
32371 904A 0206  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     904C 4550     
32372 904E 06A0  28        bl   @jsr                       ;
     9050 8002     
32373                                                                          ; = (-nosev_z * roofv_y + nosev_y * roofv_z) / 96
32374                                                                          ;
32375                                                                          ; This also sets Q = nosev_z
32376               
32377                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_x = -A
     **** ****     > EOI
0001 9052 0206  20        li   rtmp,(>80*256)
     9054 8000     
0002 9056 2806  18        xor  rtmp,ra
                   < elite.a99
32378 9058 D800  30        movb ra,@INWK+22                ; STA INWK+22       ; = (nosev_z * roofv_y - nosev_y * roofv_z) / 96
     905A 0069     
32379               
32380 905C D020  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set A = roofv_x
     905E 0063     
32381               
32382 9060 0206  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_z * roofv_x
     9062 445E     
32383 9064 06A0  28        bl   @jsr                       ;
     9066 8002     
32384               
32385 9068 D060  30        movb @INWK+10,rx                ; LDX INWK+10       ; Set X = nosev_x
     906A 005D     
32386               
32387 906C D020  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z
     906E 0067     
32388               
32389 9070 0206  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     9072 4550     
32390 9074 06A0  28        bl   @jsr                       ;
     9076 8002     
32391                                                                          ; = (-nosev_x * roofv_z + nosev_z * roofv_x) / 96
32392                                                                          ;
32393                                                                          ; This also sets Q = nosev_x
32394               
32395                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_y = -A
     **** ****     > EOI
0001 9078 0206  20        li   rtmp,(>80*256)
     907A 8000     
0002 907C 2806  18        xor  rtmp,ra
                   < elite.a99
32396 907E D800  30        movb ra,@INWK+24                ; STA INWK+24       ; = (nosev_x * roofv_z - nosev_z * roofv_x) / 96
     9080 006B     
32397               
32398 9082 D020  30        movb @INWK+18,ra                ; LDA INWK+18       ; Set A = roofv_y
     9084 0065     
32399               
32400 9086 0206  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_x * roofv_y
     9088 445E     
32401 908A 06A0  28        bl   @jsr                       ;
     908C 8002     
32402               
32403 908E D060  30        movb @INWK+12,rx                ; LDX INWK+12       ; Set X = nosev_y
     9090 005F     
32404               
32405 9092 D020  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set A = roofv_x
     9094 0063     
32406               
32407 9096 0206  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     9098 4550     
32408 909A 06A0  28        bl   @jsr                       ;
     909C 8002     
32409                                                                          ; = (-nosev_y * roofv_x + nosev_x * roofv_y) / 96
32410               
32411                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_z = -A
     **** ****     > EOI
0001 909E 0206  20        li   rtmp,(>80*256)
     90A0 8000     
0002 90A2 2806  18        xor  rtmp,ra
                   < elite.a99
32412 90A4 D800  30        movb ra,@INWK+26                ; STA INWK+26       ; = (nosev_y * roofv_x - nosev_x * roofv_y) / 96
     90A6 006D     
32413               
32414 90A8 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can clear the low bytes of the
     90AA 0000     
32415                                                                          ; orientation vectors
32416               
32417 90AC 0201  20        li   rx,>0e*256                 ; LDX #14           ; We want to clear the low bytes, so start from sidev_y
     90AE 0E00     
32418                                                                          ; at byte #9+14 (we clear all except sidev_z_lo, though
32419                                                                          ; I suspect this is in error and that X should be 16)
32420               
32421               TIL1:
32422 90B0 D840  38        movb ra,@INWK+9(rx)             ; STA INWK+9,X      ; Set the low byte in byte #9+X to zero
     90B2 005C     
32423               
32424 90B4 7044  18        sb   rone,rx                    ; DEX               ; Set X = X - 2 to jump down to the next low byte
32425 90B6 7044  18        sb   rone,rx                    ; DEX
32426               
32427 90B8 15FB  14        jgt  TIL1                       ; BPL TIL1          ; Loop back until we have zeroed all the low bytes
32428               
32429 90BA 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     90BC 800E     
32430               
32431               * ******************************************************************************
32432               *
32433               * Name: TIS2
32434               * Type: Subroutine
32435               * Category: Maths (Arithmetic)
32436               * Summary: Calculate A = A / Q
32437               * Deep dive: Shift-and-subtract division
32438               *
32439               * ------------------------------------------------------------------------------
32440               *
32441               * Calculate the following division, where A is a sign-magnitude number and Q is
32442               * a positive integer:
32443               *
32444               * A = A / Q
32445               *
32446               * The value of A is returned as a sign-magnitude number with 96 representing 1,
32447               * and the maximum value returned is 1 (i.e. 96). This routine is used when
32448               * normalising vectors, where we represent fractions using integers, so this
32449               * gives us an approximation to two decimal places.
32450               *
32451               * ******************************************************************************
32452               
32453               TIS2:
32454 90BE D080  18        movb ra,ry                      ; TAY               ; Store the argument A in Y
32455               
32456 90C0 0240  22        andi ra,>7f*256                 ; AND #%01111111    ; Strip the sign bit from the argument, so A = |A|
     90C2 7F00     
32457               
32458 90C4 9020  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q then jump to TI4 to return a 1 with the
     90C6 0090     
32459 90C8 1827  14        joc  TI4                        ; BCS TI4           ; correct sign
32460               
32461 90CA 0201  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set T to have bits 1-7 set, so we can rotate through 7
     90CC FE00     
32462 90CE D801  30        movb rx,@T                      ; STX T             ; loop iterations, getting a 1 each time, and then
     90D0 00D1     
32463                                                                          ; getting a 0 on the 8th iteration... and we can also
32464                                                                          ; use T to catch our result bits into bit 0 each time
32465               
32466               TIL2:
32467                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 90D2 0240  22        andi ra,>ff00
     90D4 FF00     
0002 90D6 0A10  18        sla  ra,1
                   < elite.a99
32468               
32469 90D8 9020  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     90DA 0090     
32470 90DC 1704  14        jnc  B108                       ; BCC B108
32471               
32472                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 90DE 1801  14        joc  !
0002 90E0 7004  18        sb   rone,ra
0003               !:
0004 90E2 7020  30        sb   @Q,ra
     90E4 0090     
                   < elite.a99
32473                                                                          ;
32474                                                                          ; Going into this subtraction we know the C flag is
32475                                                                          ; set as we passed through the BCC above, and we also
32476                                                                          ; know that A >= Q, so the C flag will still be set once
32477                                                                          ; we are done
32478               
32479               B108:
32480 90E6 0208  20        li   rarg1,T                    ; ROL T             ; Rotate the counter in T to the left, and catch the
     90E8 00D1     
32481 90EA 06A0  28        bl   @rol                       ;
     90EC 8028     
32482                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
32483                                                                          ; do the subtraction, or 1 if we did)
32484               
32485 90EE 18F1  14        joc  TIL2                       ; BCS TIL2          ; If we still have set bits in T, loop back to TIL2 to
32486                                                                          ; do the next iteration of 7
32487               
32488                                                                          ; We've done the division and now have a result in the
32489                                                                          ; range 0-255 here, which we need to reduce to the range
32490                                                                          ; 0-96. We can do that by multiplying the result by 3/8,
32491                                                                          ; as 256 * 3/8 = 96
32492               
32493 90F0 D020  30        movb @T,ra                      ; LDA T             ; Set T = T / 4
     90F2 00D1     
32494 90F4 0910  18        srl  ra,1                       ; LSR A
32495 90F6 0910  18        srl  ra,1                       ; LSR A
32496 90F8 D800  30        movb ra,@T                      ; STA T
     90FA 00D1     
32497               
32498 90FC 0910  18        srl  ra,1                       ; LSR A             ; Set T = T / 8 + T / 4
32499                      .adc @T,ra                      ; ADC T             ; = 3T / 8
     **** ****     > ADC
0001 90FE 1701  14        jnc  !
0002 9100 B004  18        ab   rone,ra
0003               !:
0004 9102 B020  30        ab   @T,ra
     9104 00D1     
                   < elite.a99
32500 9106 D800  30        movb ra,@T                      ; STA T
     9108 00D1     
32501               
32502 910A D002  18        movb ry,ra                      ; TYA               ; Fetch the sign bit of the original argument A
32503 910C 0240  22        andi ra,>80*256                 ; AND #%10000000
     910E 8000     
32504               
32505 9110 F020  30        socb @T,ra                      ; ORA T             ; Apply the sign bit to T
     9112 00D1     
32506               
32507 9114 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     9116 800E     
32508               
32509               TI4:
32510 9118 D002  18        movb ry,ra                      ; TYA               ; Fetch the sign bit of the original argument A
32511 911A 0240  22        andi ra,>80*256                 ; AND #%10000000
     911C 8000     
32512               
32513 911E 0260  22        ori  ra,>60*256                 ; ORA #96           ; Apply the sign bit to 96 (which represents 1)
     9120 6000     
32514               
32515 9122 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     9124 800E     
32516               
32517               * ******************************************************************************
32518               *
32519               * Name: TIS3
32520               * Type: Subroutine
32521               * Category: Maths (Arithmetic)
32522               * Summary: Calculate -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
32523               *
32524               * ------------------------------------------------------------------------------
32525               *
32526               * Calculate the following expression:
32527               *
32528               * A = -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
32529               *
32530               * where 1, 2 and 3 are x, y, or z, depending on the values of X, Y and A. This
32531               * routine is called with the following values:
32532               *
32533               * X = 0, Y = 2, A = 4 ->
32534               * A = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
32535               *
32536               * X = 0, Y = 4, A = 2 ->
32537               * A = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
32538               *
32539               * X = 2, Y = 4, A = 0 ->
32540               * A = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
32541               *
32542               * ------------------------------------------------------------------------------
32543               *
32544               * Arguments:
32545               *
32546               * X                   Index 1 (0 = x, 2 = y, 4 = z)
32547               *
32548               * Y                   Index 2 (0 = x, 2 = y, 4 = z)
32549               *
32550               * A                   Index 3 (0 = x, 2 = y, 4 = z)
32551               *
32552               * ******************************************************************************
32553               
32554               TIS3:
32555 9126 D800  30        movb ra,@P+2                    ; STA P+2           ; Store P+2 in A for later
     9128 001D     
32556               
32557 912A D021  34        movb @INWK+10(rx),ra            ; LDA INWK+10,X     ; Set Q = nosev_x_hi (plus X)
     912C 005D     
32558 912E D800  30        movb ra,@Q                      ; STA Q
     9130 0090     
32559               
32560 9132 D021  34        movb @INWK+16(rx),ra            ; LDA INWK+16,X     ; Set A = roofv_x_hi (plus X)
     9134 0063     
32561               
32562 9136 0206  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A
     9138 445E     
32563 913A 06A0  28        bl   @jsr                       ;
     913C 8002     
32564                                                                          ; = nosev_x_hi * roofv_x_hi
32565               
32566 913E D062  34        movb @INWK+10(ry),rx            ; LDX INWK+10,Y     ; Set Q = nosev_x_hi (plus Y)
     9140 005D     
32567 9142 D801  30        movb rx,@Q                      ; STX Q
     9144 0090     
32568               
32569 9146 D022  34        movb @INWK+16(ry),ra            ; LDA INWK+16,Y     ; Set A = roofv_x_hi (plus Y)
     9148 0063     
32570               
32571 914A 0206  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     914C 44B2     
32572 914E 06A0  28        bl   @jsr                       ;
     9150 8002     
32573                                                                          ; = (nosev_x,X * roofv_x,X) +
32574                                                                          ; (nosev_x,Y * roofv_x,Y)
32575               
32576 9152 D801  30        movb rx,@P                      ; STX P             ; Store low byte of result in P, so result is now in
     9154 001B     
32577                                                                          ; (A P)
32578               
32579 9156 D0A0  30        movb @P+2,ry                    ; LDY P+2           ; Set Q = roofv_x_hi (plus argument A)
     9158 001D     
32580 915A D062  34        movb @INWK+10(ry),rx            ; LDX INWK+10,Y
     915C 005D     
32581 915E D801  30        movb rx,@Q                      ; STX Q
     9160 0090     
32582               
32583                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A
     **** ****     > EOI
0001 9162 0206  20        li   rtmp,(>80*256)
     9164 8000     
0002 9166 2806  18        xor  rtmp,ra
                   < elite.a99
32584               
32585                                                                          ; Fall through into DIVDT to do:
32586                                                                          ;
32587                                                                          ; (P+1 A) = (A P) / Q
32588                                                                          ;
32589                                                                          ; = -((nosev_x,X * roofv_x,X) +
32590                                                                          ; (nosev_x,Y * roofv_x,Y))
32591                                                                          ; / nosev_x,A
32592               
32593               * ******************************************************************************
32594               *
32595               * Name: DVIDT
32596               * Type: Subroutine
32597               * Category: Maths (Arithmetic)
32598               * Summary: Calculate (P+1 A) = (A P) / Q
32599               *
32600               * ------------------------------------------------------------------------------
32601               *
32602               * Calculate the following integer division between sign-magnitude numbers:
32603               *
32604               * (P+1 A) = (A P) / Q
32605               *
32606               * This uses the same shift-and-subtract algorithm as TIS2.
32607               *
32608               * ******************************************************************************
32609               
32610               DVIDT:
32611 9168 D800  30        movb ra,@P+1                    ; STA P+1           ; Set P+1 = A, so P(1 0) = (A P)
     916A 001C     
32612               
32613                      .eor @Q                         ; EOR Q             ; Set T = the sign bit of A EOR Q, so it's 1 if A and Q
     **** ****     > EOR
0001 916C D1A0  30        movb @Q,rtmp
     916E 0090     
0002 9170 2806  18        xor  rtmp,ra
                   < elite.a99
32614 9172 0240  22        andi ra,>80*256                 ; AND #%10000000    ; have different signs, i.e. it's the sign of the result
     9174 8000     
32615 9176 D800  30        movb ra,@T                      ; STA T             ; of A / Q
     9178 00D1     
32616               
32617 917A 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 for us to build a result
     917C 0000     
32618               
32619 917E 0201  20        li   rx,>10*256                 ; LDX #16           ; Set a counter in X to count the 16 bits in P(1 0)
     9180 1000     
32620               
32621                      .asl @P                         ; ASL P             ; Shift P(1 0) left
     **** ****     > ASL
0001 9182 D1A0  30        movb @P,rtmp
     9184 001B     
0002 9186 0246  22        andi rtmp,>ff00
     9188 FF00     
0003 918A 0A16  18        sla  rtmp,1
0004 918C D806  30        movb rtmp,@P
     918E 001B     
                   < elite.a99
32622 9190 0208  20        li   rarg1,P+1                  ; ROL P+1
     9192 001C     
32623 9194 06A0  28        bl   @rol                       ;
     9196 8028     
32624               
32625                      .asl @Q                         ; ASL Q             ; Clear the sign bit of Q the C flag at the same time
     **** ****     > ASL
0001 9198 D1A0  30        movb @Q,rtmp
     919A 0090     
0002 919C 0246  22        andi rtmp,>ff00
     919E FF00     
0003 91A0 0A16  18        sla  rtmp,1
0004 91A2 D806  30        movb rtmp,@Q
     91A4 0090     
                   < elite.a99
32626                      .lsr @Q                         ; LSR Q
     **** ****     > LSR
0001 91A6 D1A0  30        movb @Q,rtmp
     91A8 0090     
0002 91AA 0916  18        srl  rtmp,1
0003 91AC D806  30        movb rtmp,@Q
     91AE 0090     
                   < elite.a99
32627               
32628               DVL2:
32629 91B0 06A0  28        bl   @rola                      ; ROL A             ; Shift A to the left
     91B2 8018     
32630               
32631 91B4 9020  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     91B6 0090     
32632 91B8 1704  14        jnc  B109                       ; BCC B109
32633               
32634                      .sbc @Q,ra                      ; SBC Q             ; Set A = A - Q
     **** ****     > SBC
0001 91BA 1801  14        joc  !
0002 91BC 7004  18        sb   rone,ra
0003               !:
0004 91BE 7020  30        sb   @Q,ra
     91C0 0090     
                   < elite.a99
32635                                                                          ;
32636                                                                          ; Going into this subtraction we know the C flag is
32637                                                                          ; set as we passed through the BCC above, and we also
32638                                                                          ; know that A >= Q, so the C flag will still be set once
32639                                                                          ; we are done
32640               
32641               B109:
32642 91C2 0208  20        li   rarg1,P                    ; ROL P             ; Rotate P(1 0) to the left, and catch the result bit
     91C4 001B     
32643 91C6 06A0  28        bl   @rol                       ;
     91C8 8028     
32644 91CA 0208  20        li   rarg1,P+1                  ; ROL P+1           ; into the C flag (which will be a 0 if we didn't
     91CC 001C     
32645 91CE 06A0  28        bl   @rol                       ;
     91D0 8028     
32646                                                                          ; do the subtraction, or 1 if we did)
32647               
32648 91D2 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
32649               
32650 91D4 16ED  14        jne  DVL2                       ; BNE DVL2          ; Loop back for the next bit until we have done all 16
32651                                                                          ; bits of P(1 0)
32652               
32653 91D6 D020  30        movb @P,ra                      ; LDA P             ; Set A = P so the low byte is in the result in A
     91D8 001B     
32654               
32655 91DA F020  30        socb @T,ra                      ; ORA T             ; Set A to the correct sign bit that we set in T above
     91DC 00D1     
32656               
32657 91DE 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     91E0 800E     
32658               
32659               * ******************************************************************************
32660               *
32661               * Save ELTF.bin
32662               *
32663               * ******************************************************************************
32664               
32665                      ; PRINT "ELITE F"
32666                      ; PRINT "Assembled at ", ~CODE_F%
32667                      ; PRINT "Ends at ", ~P%
32668                      ; PRINT "Code size is ", ~(P% - CODE_F%)
32669                      ; PRINT "Execute at ", ~LOAD%
32670                      ; PRINT "Reload at ", ~LOAD_F%
32671               
32672                      ; PRINT "S.ELTF ", ~CODE_F%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_F%
32673                      ; SAVE "3-assembled-output/ELTF.bin", CODE_F%, P%, LOAD%
32674               
32675               * ******************************************************************************
32676               *
32677               * ELITE G FILE
32678               *
32679               * Produces the binary file ELTG.bin that gets loaded by elite-bcfs.asm.
32680               *
32681               * ******************************************************************************
32682               
32683               CODE_G.:
32684                      equ $
32685               
32686               LOAD_G.:
32687                      equ LOAD. + $ - CODE.
32688               
32689               * ******************************************************************************
32690               *
32691               * Name: SHPPT
32692               * Type: Subroutine
32693               * Category: Drawing ships
32694               * Summary: Draw a distant ship as a point rather than a full wireframe
32695               *
32696               * ******************************************************************************
32697               
32698               SHPPT:
32699 91E2 0206  20        li   rtmp,EE51                  ; JSR EE51          ; Call EE51 to remove the ship's wireframe from the
     91E4 957C     
32700 91E6 06A0  28        bl   @jsr                       ;
     91E8 8002     
32701                                                                          ; screen, if there is one
32702               
32703 91EA 0206  20        li   rtmp,PROJ                  ; JSR PROJ          ; Project the ship onto the screen, returning:
     91EC 714E     
32704 91EE 06A0  28        bl   @jsr                       ;
     91F0 8002     
32705                                                                          ;
32706                                                                          ; * K3(1 0) = the screen x-coordinate
32707                                                                          ; * K4(1 0) = the screen y-coordinate
32708                                                                          ; * A = K4+1
32709               
32710 91F2 F020  30        socb @K3+1,ra                   ; ORA K3+1          ; If either of the high bytes of the screen coordinates
     91F4 00D3     
32711 91F6 1625  14        jne  nono_                      ; BNE nono          ; are non-zero, jump to nono as the ship is off-screen
32712               
32713 91F8 D020  30        movb @K4,ra                     ; LDA K4            ; Set A = the y-coordinate of the dot
     91FA 00E0     
32714               
32715 91FC 0280  22        ci   ra,(Y*2-2)*256             ; CMP #Y*2-2        ; If the y-coordinate is bigger than the y-coordinate of
     91FE BE00     
32716 9200 1820  14        joc  nono_                      ; BCS nono          ; the bottom of the screen, jump to nono as the ship's
32717                                                                          ; dot is off the bottom of the space view
32718               
32719 9202 0202  20        li   ry,>02*256                 ; LDY #2            ; Call Shpt with Y = 2 to set up bytes 1-4 in the ship
     9204 0200     
32720 9206 0206  20        li   rtmp,Shpt                  ; JSR Shpt          ; lines space, aborting the call to LL9 if the dot is
     9208 9256     
32721 920A 06A0  28        bl   @jsr                       ;
     920C 8002     
32722                                                                          ; off the side of the screen. This call sets up the
32723                                                                          ; first row of the dot (i.e. a four-pixel dash)
32724               
32725 920E 0202  20        li   ry,>06*256                 ; LDY #6            ; Set Y to 6 for the next call to Shpt
     9210 0600     
32726               
32727 9212 D020  30        movb @K4,ra                     ; LDA K4            ; Set A = y-coordinate of dot + 1 (so this is the second
     9214 00E0     
32728                      .adi (>01*256)                  ; ADC #1            ; row of the two-pixel-high dot)
     **** ****     > ADI
0001 9216 1701  14        jnc  !
0002 9218 B004  18        ab   rone,ra
0003               !:
0004 921A 0220  22        ai   ra,(>01*256)
     921C 0100     
                   < elite.a99
32729                                                                          ;
32730                                                                          ; The addition works as the Shpt routine clears the C
32731                                                                          ; flag
32732               
32733 921E 0206  20        li   rtmp,Shpt                  ; JSR Shpt          ; Call Shpt with Y = 6 to set up bytes 5-8 in the ship
     9220 9256     
32734 9222 06A0  28        bl   @jsr                       ;
     9224 8002     
32735                                                                          ; lines space, aborting the call to LL9 if the dot is
32736                                                                          ; off the side of the screen. This call sets up the
32737                                                                          ; second row of the dot (i.e. another four-pixel dash,
32738                                                                          ; on the row below the first one)
32739               
32740 9226 0200  20        li   ra,>08*256                 ; LDA #%00001000    ; Set bit 3 of the ship's byte #31 to record that we
     9228 0800     
32741 922A F020  30        socb @XX1+31,ra                 ; ORA XX1+31        ; have now drawn something on-screen for this ship
     922C 0072     
32742 922E D800  30        movb ra,@XX1+31                 ; STA XX1+31
     9230 0072     
32743               
32744 9232 0200  20        li   ra,>08*256                 ; LDA #8            ; Set A = 8 so when we call LL18+2 next, byte #0 of the
     9234 0800     
32745                                                                          ; heap gets set to 8, for the 8 bytes we just stuck on
32746                                                                          ; the heap
32747               
32748 9236 0460  28        b    @LL81+2                    ; JMP LL81+2        ; Call LL81+2 to draw the ship's dot, returning from the
     9238 A23C     
32749                                                                          ; subroutine using a tail call
32750               
32751                      .pla                            ; PLA               ; Pull the return address from the stack, so the RTS
     **** ****     > PLA
0001 923A 058A  14        inc  rsp
0002 923C D01A  26        movb *rsp,ra
                   < elite.a99
32752                      .pla                            ; PLA               ; below actually returns from the subroutine that called
     **** ****     > PLA
0001 923E 058A  14        inc  rsp
0002 9240 D01A  26        movb *rsp,ra
                   < elite.a99
32753                                                                          ; LL9 (as we called SHPPT from LL9 with a JMP)
32754               
32755               nono_:
32756 9242 0200  20        li   ra,>f7*256                 ; LDA #%11110111    ; Clear bit 3 of the ship's byte #31 to record that
     9244 F700     
32757                      .and @XX1+31                    ; AND XX1+31        ; nothing is being drawn on-screen for this ship
     **** ****     > AND
0001 9246 D1A0  30        movb @XX1+31,rtmp
     9248 0072     
0002 924A 0546  14        inv  rtmp
0003 924C 5006  18        szcb rtmp,ra
                   < elite.a99
32758 924E D800  30        movb ra,@XX1+31                 ; STA XX1+31
     9250 0072     
32759               
32760 9252 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     9254 800E     
32761               
32762               Shpt:
32763                                                                          ; This routine sets up four bytes in the ship line heap,
32764                                                                          ; from byte Y-1 to byte Y+2. If the ship's screen point
32765                                                                          ; turns out to be off-screen, then this routine aborts
32766                                                                          ; the entire call to LL9, exiting via nono. The four
32767                                                                          ; bytes define a horizontal 4-pixel dash, for either the
32768                                                                          ; top or the bottom of the ship's dot
32769                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store A in byte Y of the ship line heap (i.e. Y1)
     **** ****     > ST_IND_Y_IDX
0001 9256 D820  42        movb @XX19,@rtmplb
     9258 0074     
     925A 830D     
0002 925C D1A0  30        movb @XX19+1,rtmp
     925E 0075     
0003 9260 A182  18        a    ry,rtmp
0004 9262 D580  30        movb RA,*rtmp
                   < elite.a99
32770               
32771 9264 B084  18        ab   rone,ry                    ; INY               ; Store A in byte Y+2 of the ship line heap (i.e. Y2)
32772 9266 B084  18        ab   rone,ry                    ; INY
32773                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 9268 D820  42        movb @XX19,@rtmplb
     926A 0074     
     926C 830D     
0002 926E D1A0  30        movb @XX19+1,rtmp
     9270 0075     
0003 9272 A182  18        a    ry,rtmp
0004 9274 D580  30        movb RA,*rtmp
                   < elite.a99
32774               
32775 9276 D020  30        movb @K3,ra                     ; LDA K3            ; Set A = screen x-coordinate of the ship dot
     9278 00D2     
32776               
32777 927A 7084  18        sb   rone,ry                    ; DEY               ; Store A in byte Y+1 of the ship line heap (i.e. X2)
32778                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 927C D820  42        movb @XX19,@rtmplb
     927E 0074     
     9280 830D     
0002 9282 D1A0  30        movb @XX19+1,rtmp
     9284 0075     
0003 9286 A182  18        a    ry,rtmp
0004 9288 D580  30        movb RA,*rtmp
                   < elite.a99
32779               
32780                      .adi (>03*256)                  ; ADC #3            ; Set A = screen x-coordinate of the ship dot + 3
     **** ****     > ADI
0001 928A 1701  14        jnc  !
0002 928C B004  18        ab   rone,ra
0003               !:
0004 928E 0220  22        ai   ra,(>03*256)
     9290 0300     
                   < elite.a99
32781               
32782 9292 18D6  14        joc  nono_-2                    ; BCS nono-2        ; If the addition pushed the dot off the right side of
32783                                                                          ; the screen, jump to nono-2 to return from the parent
32784                                                                          ; subroutine early (i.e. LL9). This works because we
32785                                                                          ; called Shpt from above with a JSR, so nono-2 removes
32786                                                                          ; that return address from the stack, leaving the next
32787                                                                          ; return address exposed. LL9 called SHPPT with a JMP,
32788                                                                          ; so the next return address is the one that was put on
32789                                                                          ; the stack by the original call to LL9. So the RTS in
32790                                                                          ; nono will actually return us from the original call
32791                                                                          ; to LL9, thus aborting the entire drawing process
32792               
32793 9294 7084  18        sb   rone,ry                    ; DEY               ; Store A in byte Y-1 of the ship line heap (i.e. X1)
32794 9296 7084  18        sb   rone,ry                    ; DEY
32795                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 9298 D820  42        movb @XX19,@rtmplb
     929A 0074     
     929C 830D     
0002 929E D1A0  30        movb @XX19+1,rtmp
     92A0 0075     
0003 92A2 A182  18        a    ry,rtmp
0004 92A4 D580  30        movb RA,*rtmp
                   < elite.a99
32796               
32797 92A6 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     92A8 800E     
32798               
32799               * ******************************************************************************
32800               *
32801               * Name: LL5
32802               * Type: Subroutine
32803               * Category: Maths (Arithmetic)
32804               * Summary: Calculate Q = SQRT(R Q)
32805               * Deep dive: Calculating square roots
32806               *
32807               * ------------------------------------------------------------------------------
32808               *
32809               * Calculate the following square root:
32810               *
32811               * Q = SQRT(R Q)
32812               *
32813               * ******************************************************************************
32814               
32815               LL5:
32816 92AA D0A0  30        movb @R,ry                      ; LDY R             ; Set (Y S) = (R Q)
     92AC 0091     
32817 92AE D020  30        movb @Q,ra                      ; LDA Q
     92B0 0090     
32818 92B2 D800  30        movb ra,@S                      ; STA S
     92B4 0092     
32819               
32820                                                                          ; So now to calculate Q = SQRT(Y S)
32821               
32822 92B6 0201  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0, to hold the remainder
     92B8 0000     
32823               
32824 92BA D801  30        movb rx,@Q                      ; STX Q             ; Set Q = 0, to hold the result
     92BC 0090     
32825               
32826 92BE 0200  20        li   ra,>08*256                 ; LDA #8            ; Set T = 8, to use as a loop counter
     92C0 0800     
32827 92C2 D800  30        movb ra,@T                      ; STA T
     92C4 00D1     
32828               
32829               LL6:
32830 92C6 9060  30        cb   @Q,rx                      ; CPX Q             ; If X < Q, jump to LL7
     92C8 0090     
32831 92CA 1710  14        jnc  LL7                        ; BCC LL7
32832               
32833 92CC 1603  14        jne  LL8                        ; BNE LL8           ; If X > Q, jump to LL8
32834               
32835 92CE 0282  22        ci   ry,>40*256                 ; CPY #64           ; If Y < 64, jump to LL7 with the C flag clear,
     92D0 4000     
32836 92D2 170C  14        jnc  LL7                        ; BCC LL7           ; otherwise fall through into LL8 with the C flag set
32837               
32838               LL8:
32839 92D4 D002  18        movb ry,ra                      ; TYA               ; Set Y = Y - 64
32840                      .sbi (>40*256)                  ; SBC #64           ;
     **** ****     > SBI
0001 92D6 1801  14        joc  !
0002 92D8 7004  18        sb   rone,ra
0003               !:
0004 92DA 0220  22        ai   ra,-(>40*256)
     92DC C000     
                   < elite.a99
32841 92DE D080  18        movb ra,ry                      ; TAY               ; This subtraction will work as we know C is set from
32842                                                                          ; the BCC above, and the result will not underflow as we
32843                                                                          ; already checked that Y >= 64, so the C flag is also
32844                                                                          ; set for the next subtraction
32845               
32846 92E0 D001  18        movb rx,ra                      ; TXA               ; Set X = X - Q
32847                      .sbc @Q,ra                      ; SBC Q
     **** ****     > SBC
0001 92E2 1801  14        joc  !
0002 92E4 7004  18        sb   rone,ra
0003               !:
0004 92E6 7020  30        sb   @Q,ra
     92E8 0090     
                   < elite.a99
32848 92EA D040  18        movb ra,rx                      ; TAX
32849               
32850               LL7:
32851 92EC 0208  20        li   rarg1,Q                    ; ROL Q             ; Shift the result in Q to the left, shifting the C flag
     92EE 0090     
32852 92F0 06A0  28        bl   @rol                       ;
     92F2 8028     
32853                                                                          ; into bit 0 and bit 7 into the C flag
32854               
32855                      .asl @S                         ; ASL S             ; Shift the dividend in (Y S) to the left, inserting
     **** ****     > ASL
0001 92F4 D1A0  30        movb @S,rtmp
     92F6 0092     
0002 92F8 0246  22        andi rtmp,>ff00
     92FA FF00     
0003 92FC 0A16  18        sla  rtmp,1
0004 92FE D806  30        movb rtmp,@S
     9300 0092     
                   < elite.a99
32856 9302 D002  18        movb ry,ra                      ; TYA               ; bit 7 from above into bit 0
32857 9304 06A0  28        bl   @rola                      ; ROL A
     9306 8018     
32858 9308 D080  18        movb ra,ry                      ; TAY
32859               
32860 930A D001  18        movb rx,ra                      ; TXA               ; Shift the remainder in X to the left
32861 930C 06A0  28        bl   @rola                      ; ROL A
     930E 8018     
32862 9310 D040  18        movb ra,rx                      ; TAX
32863               
32864                      .asl @S                         ; ASL S             ; Shift the dividend in (Y S) to the left
     **** ****     > ASL
0001 9312 D1A0  30        movb @S,rtmp
     9314 0092     
0002 9316 0246  22        andi rtmp,>ff00
     9318 FF00     
0003 931A 0A16  18        sla  rtmp,1
0004 931C D806  30        movb rtmp,@S
     931E 0092     
                   < elite.a99
32865 9320 D002  18        movb ry,ra                      ; TYA
32866 9322 06A0  28        bl   @rola                      ; ROL A
     9324 8018     
32867 9326 D080  18        movb ra,ry                      ; TAY
32868               
32869 9328 D001  18        movb rx,ra                      ; TXA               ; Shift the remainder in X to the left
32870 932A 06A0  28        bl   @rola                      ; ROL A
     932C 8018     
32871 932E D040  18        movb ra,rx                      ; TAX
32872               
32873 9330 7004  18        sb   rone,ra                    ; DEC T             ; Decrement the loop counter
32874               
32875 9332 16C9  14        jne  LL6                        ; BNE LL6           ; Loop back to LL6 until we have done 8 loops
32876               
32877 9334 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     9336 800E     
32878               
32879               * ******************************************************************************
32880               *
32881               * Name: LL28
32882               * Type: Subroutine
32883               * Category: Maths (Arithmetic)
32884               * Summary: Calculate R = 256 * A / Q
32885               * Deep dive: Shift-and-subtract division
32886               *
32887               * ------------------------------------------------------------------------------
32888               *
32889               * Calculate the following, where A < Q:
32890               *
32891               * R = 256 * A / Q
32892               *
32893               * This is a sister routine to LL61, which does the division when A >= Q.
32894               *
32895               * If A >= Q then 255 is returned and the C flag is set to indicate an overflow
32896               * (the C flag is clear if the division was a success).
32897               *
32898               * The result is returned in one byte as the result of the division multiplied
32899               * by 256, so we can return fractional results using integers.
32900               *
32901               * This routine uses the same shift-and-subtract algorithm that's documented in
32902               * TIS2, but it leaves the fractional result in the integer range 0-255.
32903               *
32904               * ------------------------------------------------------------------------------
32905               *
32906               * Returns:
32907               *
32908               * C flag              Set if the answer is too big for one byte, clear if the
32909               * division was a success
32910               *
32911               * ------------------------------------------------------------------------------
32912               *
32913               * Other entry points:
32914               *
32915               * LL28+4              Skips the A >= Q check and always returns with C flag
32916               * cleared, so this can be called if we know the division
32917               * will work
32918               *
32919               * LL31                Skips the A >= Q check and does not set the R counter,
32920               * so this can be used for jumping straight into the
32921               * division loop if R is already set to 254 and we know the
32922               * division will work
32923               *
32924               * ******************************************************************************
32925               
32926               LL28:
32927 9338 9020  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, then the answer will not fit in one byte,
     933A 0090     
32928 933C 1822  14        joc  LL2                        ; BCS LL2           ; so jump to LL2 to return 255
32929               
32930 933E 0201  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set R to have bits 1-7 set, so we can rotate through 7
     9340 FE00     
32931 9342 D801  30        movb rx,@R                      ; STX R             ; loop iterations, getting a 1 each time, and then
     9344 0091     
32932                                                                          ; getting a 0 on the 8th iteration... and we can also
32933                                                                          ; use R to catch our result bits into bit 0 each time
32934               
32935               LL31:
32936                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 9346 0240  22        andi ra,>ff00
     9348 FF00     
0002 934A 0A10  18        sla  ra,1
                   < elite.a99
32937               
32938 934C 180E  14        joc  LL29                       ; BCS LL29          ; If bit 7 of A was set, then jump straight to the
32939                                                                          ; subtraction
32940               
32941 934E 9020  30        cb   @Q,ra                      ; CMP Q             ; If A < Q, skip the following subtraction
     9350 0090     
32942 9352 1704  14        jnc  B110                       ; BCC B110
32943               
32944                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 9354 1801  14        joc  !
0002 9356 7004  18        sb   rone,ra
0003               !:
0004 9358 7020  30        sb   @Q,ra
     935A 0090     
                   < elite.a99
32945               
32946               B110:
32947 935C 0208  20        li   rarg1,R                    ; ROL R             ; Rotate the counter in R to the left, and catch the
     935E 0091     
32948 9360 06A0  28        bl   @rol                       ;
     9362 8028     
32949                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
32950                                                                          ; do the subtraction, or 1 if we did)
32951               
32952 9364 18F0  14        joc  LL31                       ; BCS LL31          ; If we still have set bits in R, loop back to LL31 to
32953                                                                          ; do the next iteration of 7
32954               
32955 9366 0460  24        b    @rts                       ; RTS               ; R left with remainder of division
     9368 800E     
32956               
32957               LL29:
32958                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 936A 1801  14        joc  !
0002 936C 7004  18        sb   rone,ra
0003               !:
0004 936E 7020  30        sb   @Q,ra
     9370 0090     
                   < elite.a99
32959               
32960                      .sec                            ; SEC               ; Set the C flag to rotate into the result in R
     **** ****     > SEC
0001 9372 0A15  18        sla  rmone,1
                   < elite.a99
32961               
32962 9374 0208  20        li   rarg1,R                    ; ROL R             ; Rotate the counter in R to the left, and catch the
     9376 0091     
32963 9378 06A0  28        bl   @rol                       ;
     937A 8028     
32964                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
32965                                                                          ; do the subtraction, or 1 if we did)
32966               
32967 937C 18E4  14        joc  LL31                       ; BCS LL31          ; If we still have set bits in R, loop back to LL31 to
32968                                                                          ; do the next iteration of 7
32969               
32970 937E 0460  24        b    @rts                       ; RTS               ; Return from the subroutine with R containing the
     9380 800E     
32971                                                                          ; remainder of the division
32972               
32973               LL2:
32974 9382 0200  20        li   ra,>ff*256                 ; LDA #255          ; The division is very close to 1, so return the closest
     9384 FF00     
32975 9386 D800  30        movb ra,@R                      ; STA R             ; possible answer to 256, i.e. R = 255
     9388 0091     
32976               
32977 938A 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     938C 800E     
32978               
32979               * ******************************************************************************
32980               *
32981               * Name: LL38
32982               * Type: Subroutine
32983               * Category: Maths (Arithmetic)
32984               * Summary: Calculate (S A) = (S R) + (A Q)
32985               *
32986               * ------------------------------------------------------------------------------
32987               *
32988               * Calculate the following between sign-magnitude numbers:
32989               *
32990               * (S A) = (S R) + (A Q)
32991               *
32992               * where the sign bytes only contain the sign bits, not magnitudes.
32993               *
32994               * ------------------------------------------------------------------------------
32995               *
32996               * Returns:
32997               *
32998               * C flag              Set if the addition overflowed, clear otherwise
32999               *
33000               * ******************************************************************************
33001               
33002               LL38:
33003                      .eor @S                         ; EOR S             ; If the sign of A * S is negative, skip to LL35, as
     **** ****     > EOR
0001 938E D1A0  30        movb @S,rtmp
     9390 0092     
0002 9392 2806  18        xor  rtmp,ra
                   < elite.a99
33004 9394 1109  14        jlt  LL39                       ; BMI LL39          ; A and S have different signs so we need to subtract
33005               
33006 9396 D020  30        movb @Q,ra                      ; LDA Q             ; Otherwise set A = R + Q, which is the result we need,
     9398 0090     
33007                      .clc                            ; CLC               ; as S already contains the correct sign
     **** ****     > CLC
0001 939A 0A13  18        sla  rzero,1
                   < elite.a99
33008                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 939C 1701  14        jnc  !
0002 939E B004  18        ab   rone,ra
0003               !:
0004 93A0 B020  30        ab   @R,ra
     93A2 0091     
                   < elite.a99
33009               
33010 93A4 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     93A6 800E     
33011               
33012               LL39:
33013 93A8 D020  30        movb @R,ra                      ; LDA R             ; Set A = R - Q
     93AA 0091     
33014                      .sec                            ; SEC
     **** ****     > SEC
0001 93AC 0A15  18        sla  rmone,1
                   < elite.a99
33015                      .sbc @Q,ra                      ; SBC Q
     **** ****     > SBC
0001 93AE 1801  14        joc  !
0002 93B0 7004  18        sb   rone,ra
0003               !:
0004 93B2 7020  30        sb   @Q,ra
     93B4 0090     
                   < elite.a99
33016               
33017 93B6 1701  14        jnc  B111                       ; BCC B111          ; If the subtraction underflowed, skip the next two
33018                                                                          ; instructions so we can negate the result
33019               
33020                      .clc                            ; CLC               ; Otherwise the result is correct, and S contains the
     **** ****     > CLC
0001 93B8 0A13  18        sla  rzero,1
                   < elite.a99
33021                                                                          ; correct sign of the result as R is the dominant side
33022                                                                          ; of the subtraction, so clear the C flag
33023               
33024               B111:
33025 93BA 0460  24        b    @rts                       ; RTS               ; And return from the subroutine
     93BC 800E     
33026               
33027                                                                          ; If we get here we need to negate both the result and
33028                                                                          ; the sign in S, as both are the wrong sign
33029               
33030                      .pha                            ; PHA               ; Store the result of the subtraction on the stack
     **** ****     > PHA
0001 93BE D680  30        movb ra,*rsp
0002 93C0 060A  14        dec  rsp
                   < elite.a99
33031               
33032 93C2 D020  30        movb @S,ra                      ; LDA S             ; Flip the sign of S
     93C4 0092     
33033                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 93C6 0206  20        li   rtmp,(>80*256)
     93C8 8000     
0002 93CA 2806  18        xor  rtmp,ra
                   < elite.a99
33034 93CC D800  30        movb ra,@S                      ; STA S
     93CE 0092     
33035               
33036                      .pla                            ; PLA               ; Restore the subtraction result into A
     **** ****     > PLA
0001 93D0 058A  14        inc  rsp
0002 93D2 D01A  26        movb *rsp,ra
                   < elite.a99
33037               
33038                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A using two's complement, i.e.
     **** ****     > EOI
0001 93D4 0206  20        li   rtmp,(>FF*256)
     93D6 FF00     
0002 93D8 2806  18        xor  rtmp,ra
                   < elite.a99
33039                      .adi (>01*256)                  ; ADC #1            ; set A = ~A + 1
     **** ****     > ADI
0001 93DA 1701  14        jnc  !
0002 93DC B004  18        ab   rone,ra
0003               !:
0004 93DE 0220  22        ai   ra,(>01*256)
     93E0 0100     
                   < elite.a99
33040               
33041 93E2 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     93E4 800E     
33042               
33043               * ******************************************************************************
33044               *
33045               * Name: LL51
33046               * Type: Subroutine
33047               * Category: Maths (Geometry)
33048               * Summary: Calculate the dot product of XX15 and XX16
33049               *
33050               * ------------------------------------------------------------------------------
33051               *
33052               * Calculate the following dot products:
33053               *
33054               * XX12(1 0) = XX15(5 0) . XX16(5 0)
33055               * XX12(3 2) = XX15(5 0) . XX16(11 6)
33056               * XX12(5 4) = XX15(5 0) . XX16(12 17)
33057               *
33058               * storing the results as sign-magnitude numbers in XX12 through XX12+5.
33059               *
33060               * When called from part 5 of LL9, XX12 contains the vector [x y z] to the ship
33061               * we're drawing, and XX16 contains the orientation vectors, so it returns:
33062               *
33063               * [ x ]   [ sidev_x ]         [ x ]   [ roofv_x ]         [ x ]   [ nosev_x ]
33064               * [ y ] . [ sidev_y ]         [ y ] . [ roofv_y ]         [ y ] . [ nosev_y ]
33065               * [ z ]   [ sidev_z ]         [ z ]   [ roofv_z ]         [ z ]   [ nosev_z ]
33066               *
33067               * When called from part 6 of LL9, XX12 contains the vector [x y z] of the vertex
33068               * we're analysing, and XX16 contains the transposed orientation vectors with
33069               * each of them containing the x, y and z elements of the original vectors, so it
33070               * ------------------------------------------------------------------------------
33071               *
33072               * Returns:
33073               *
33074               * [ x ]   [ sidev_x ]         [ x ]   [ sidev_y ]         [ x ]   [ sidev_z ]
33075               * [ y ] . [ roofv_x ]         [ y ] . [ roofv_y ]         [ y ] . [ roofv_z ]
33076               * [ z ]   [ nosev_x ]         [ z ]   [ nosev_y ]         [ z ]   [ nosev_z ]
33077               *
33078               * ------------------------------------------------------------------------------
33079               *
33080               * Arguments:
33081               *
33082               * XX15(1 0)           The ship (or vertex)'s x-coordinate as (x_sign x_lo)
33083               *
33084               * XX15(3 2)           The ship (or vertex)'s y-coordinate as (y_sign y_lo)
33085               *
33086               * XX15(5 4)           The ship (or vertex)'s z-coordinate as (z_sign z_lo)
33087               *
33088               * XX16 to XX16+5      The scaled sidev (or _x) vector, with:
33089               *
33090               * * x, y, z magnitudes in XX16, XX16+2, XX16+4
33091               *
33092               * * x, y, z signs in XX16+1, XX16+3, XX16+5
33093               *
33094               * XX16+6 to XX16+11   The scaled roofv (or _y) vector, with:
33095               *
33096               * * x, y, z magnitudes in XX16+6, XX16+8, XX16+10
33097               *
33098               * * x, y, z signs in XX16+7, XX16+9, XX16+11
33099               *
33100               * XX16+12 to XX16+17  The scaled nosev (or _z) vector, with:
33101               *
33102               * * x, y, z magnitudes in XX16+12, XX16+14, XX16+16
33103               *
33104               * * x, y, z signs in XX16+13, XX16+15, XX16+17
33105               *
33106               * ------------------------------------------------------------------------------
33107               *
33108               * Returns:
33109               *
33110               * XX12(1 0)           The dot product of [x y z] vector with the sidev (or _x)
33111               * vector, with the sign in XX12+1 and magnitude in XX12
33112               *
33113               * XX12(3 2)           The dot product of [x y z] vector with the roofv (or _y)
33114               * vector, with the sign in XX12+3 and magnitude in XX12+2
33115               *
33116               * XX12(5 4)           The dot product of [x y z] vector with the nosev (or _z)
33117               * vector, with the sign in XX12+5 and magnitude in XX12+4
33118               *
33119               * ******************************************************************************
33120               
33121               LL51:
33122 93E6 0201  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0, which will contain the offset of the vector
     93E8 0000     
33123                                                                          ; to use in the calculation, increasing by 6 for each
33124                                                                          ; new vector
33125               
33126 93EA 0202  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0, which will contain the offset of the
     93EC 0000     
33127                                                                          ; result bytes in XX12, increasing by 2 for each new
33128                                                                          ; result
33129               
33130               ll51_:
33131 93EE D020  30        movb @XX15,ra                   ; LDA XX15          ; Set Q = x_lo
     93F0 0031     
33132 93F2 D800  30        movb ra,@Q                      ; STA Q
     93F4 0090     
33133               
33134 93F6 D021  34        movb @XX16(rx),ra               ; LDA XX16,X        ; Set A = |sidev_x|
     93F8 0009     
33135               
33136 93FA 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     93FC 4338     
33137 93FE 06A0  28        bl   @jsr                       ;
     9400 8002     
33138 9402 D800  30        movb ra,@T                      ; STA T             ; = |sidev_x| * x_lo / 256
     9404 00D1     
33139               
33140 9406 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set S to the sign of x_sign * sidev_x
     9408 0032     
33141                      .eor @XX16+1(rx)                ; EOR XX16+1,X
     **** ****     > EOR
0001 940A D1A1  34        movb @XX16+1(RX),rtmp
     940C 000A     
0002 940E 2806  18        xor  rtmp,ra
                   < elite.a99
33142 9410 D800  30        movb ra,@S                      ; STA S
     9412 0092     
33143               
33144 9414 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set Q = y_lo
     9416 0033     
33145 9418 D800  30        movb ra,@Q                      ; STA Q
     941A 0090     
33146               
33147 941C D021  34        movb @XX16+2(rx),ra             ; LDA XX16+2,X      ; Set A = |sidev_y|
     941E 000B     
33148               
33149 9420 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q / 256
     9422 4338     
33150 9424 06A0  28        bl   @jsr                       ;
     9426 8002     
33151 9428 D800  30        movb ra,@Q                      ; STA Q             ; = |sidev_y| * y_lo / 256
     942A 0090     
33152               
33153 942C D020  30        movb @T,ra                      ; LDA T             ; Set R = T
     942E 00D1     
33154 9430 D800  30        movb ra,@R                      ; STA R             ; = |sidev_x| * x_lo / 256
     9432 0091     
33155               
33156 9434 D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set A to the sign of y_sign * sidev_y
     9436 0034     
33157                      .eor @XX16+3(rx)                ; EOR XX16+3,X
     **** ****     > EOR
0001 9438 D1A1  34        movb @XX16+3(RX),rtmp
     943A 000C     
0002 943C 2806  18        xor  rtmp,ra
                   < elite.a99
33158               
33159 943E 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S T) = (S R) + (A Q)
     9440 938E     
33160 9442 06A0  28        bl   @jsr                       ;
     9444 8002     
33161 9446 D800  30        movb ra,@T                      ; STA T             ; = |sidev_x| * x_lo + |sidev_y| * y_lo
     9448 00D1     
33162               
33163 944A D020  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set Q = z_lo
     944C 0035     
33164 944E D800  30        movb ra,@Q                      ; STA Q
     9450 0090     
33165               
33166 9452 D021  34        movb @XX16+4(rx),ra             ; LDA XX16+4,X      ; Set A = |sidev_z|
     9454 000D     
33167               
33168 9456 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q / 256
     9458 4338     
33169 945A 06A0  28        bl   @jsr                       ;
     945C 8002     
33170 945E D800  30        movb ra,@Q                      ; STA Q             ; = |sidev_z| * z_lo / 256
     9460 0090     
33171               
33172 9462 D020  30        movb @T,ra                      ; LDA T             ; Set R = T
     9464 00D1     
33173 9466 D800  30        movb ra,@R                      ; STA R             ; = |sidev_x| * x_lo + |sidev_y| * y_lo
     9468 0091     
33174               
33175 946A D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A to the sign of z_sign * sidev_z
     946C 0036     
33176                      .eor @XX16+5(rx)                ; EOR XX16+5,X
     **** ****     > EOR
0001 946E D1A1  34        movb @XX16+5(RX),rtmp
     9470 000E     
0002 9472 2806  18        xor  rtmp,ra
                   < elite.a99
33177               
33178 9474 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     9476 938E     
33179 9478 06A0  28        bl   @jsr                       ;
     947A 8002     
33180                                                                          ; = |sidev_x| * x_lo + |sidev_y| * y_lo
33181                                                                          ; + |sidev_z| * z_lo
33182               
33183 947C D880  38        movb ra,@XX12(ry)               ; STA XX12,Y        ; Store the result in XX12+Y(1 0)
     947E 0037     
33184 9480 D020  30        movb @S,ra                      ; LDA S
     9482 0092     
33185 9484 D880  38        movb ra,@XX12+1(ry)             ; STA XX12+1,Y
     9486 0038     
33186               
33187 9488 B084  18        ab   rone,ry                    ; INY               ; Set Y = Y + 2
33188 948A B084  18        ab   rone,ry                    ; INY
33189               
33190 948C D001  18        movb rx,ra                      ; TXA               ; Set X = X + 6
33191                      .clc                            ; CLC
     **** ****     > CLC
0001 948E 0A13  18        sla  rzero,1
                   < elite.a99
33192                      .adi (>06*256)                  ; ADC #6
     **** ****     > ADI
0001 9490 1701  14        jnc  !
0002 9492 B004  18        ab   rone,ra
0003               !:
0004 9494 0220  22        ai   ra,(>06*256)
     9496 0600     
                   < elite.a99
33193 9498 D040  18        movb ra,rx                      ; TAX
33194               
33195 949A 0280  22        ci   ra,>11*256                 ; CMP #17           ; If X < 17, loop back to ll51 for the next vector
     949C 1100     
33196 949E 17A7  14        jnc  ll51_                      ; BCC ll51
33197               
33198 94A0 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     94A2 800E     
33199               
33200               * ******************************************************************************
33201               *
33202               * Name: LL9 (Part 1 of 12)
33203               * Type: Subroutine
33204               * Category: Drawing ships
33205               * Summary: Draw ship: Check if ship is exploding, check if ship is in front
33206               * Deep dive: Drawing ships
33207               *
33208               * ------------------------------------------------------------------------------
33209               *
33210               * This routine draws the current ship on the screen. This part checks to see if
33211               * the ship is exploding, or if it should start exploding, and if it does it sets
33212               * things up accordingly.
33213               *
33214               * It also does some basic checks to see if we can see the ship, and if not it
33215               * removes it from the screen.
33216               *
33217               * In this code, XX1 is used to point to the current ship's data block at INWK
33218               * (the two labels are interchangeable).
33219               *
33220               * ------------------------------------------------------------------------------
33221               *
33222               * Arguments:
33223               *
33224               * XX1                 XX1 shares its location with INWK, which contains the
33225               * zero-page copy of the data block for this ship from the
33226               * K% workspace
33227               *
33228               * INF                 The address of the data block for this ship in workspace
33229               * K%
33230               *
33231               * XX19(1 0)           XX19(1 0) shares its location with INWK(34 33), which
33232               * contains the ship line heap address pointer
33233               *
33234               * XX0                 The address of the blueprint for this ship
33235               *
33236               * ------------------------------------------------------------------------------
33237               *
33238               * Other entry points:
33239               *
33240               * EE51                Remove the current ship from the screen, called from
33241               * SHPPT before drawing the ship as a point
33242               *
33243               * ******************************************************************************
33244               
33245               LL25:
33246 94A4 0460  28        b    @PLANET                    ; JMP PLANET        ; Jump to the PLANET routine, returning from the
     94A6 71E2     
33247                                                                          ; subroutine using a tail call
33248               
33249               LL9:
33250 94A8 D020  30        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is negative then this indicates a
     94AA 009B     
33251 94AC 11FB  14        jlt  LL25                       ; BMI LL25          ; planet or sun, so jump to PLANET via LL25 above
33252               
33253 94AE 0200  20        li   ra,>1f*256                 ; LDA #31           ; Set XX4 = 31 to store the ship's distance for later
     94B0 1F00     
33254 94B2 D800  30        movb ra,@XX4                    ; STA XX4           ; comparison with the visibility distance. We will
     94B4 00A7     
33255                                                                          ; update this value below with the actual ship's
33256                                                                          ; distance if it turns out to be visible on-screen
33257               
33258 94B6 0200  20        li   ra,>20*256                 ; LDA #%00100000    ; If bit 5 of the ship's byte #31 is set, then the ship
     94B8 2000     
33259                      .bit @XX1+31                    ; BIT XX1+31        ; is currently exploding, so jump down to EE28
     **** ****     > BIT
0001 94BA D1A0  30        movb @XX1+31,rtmp
     94BC 0072     
0002 94BE 0546  14        inv  rtmp
0003 94C0 D1C4  18        movb rone,rtmp2
0004 94C2 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
33260 94C4 164B  14        jne  EE28                       ; BNE EE28
33261               
33262 94C6 154A  14        jgt  EE28                       ; BPL EE28          ; If bit 7 of the ship's byte #31 is clear then the ship
33263                                                                          ; has not just been killed, so jump down to EE28
33264               
33265                                                                          ; Otherwise bit 5 is clear and bit 7 is set, so the ship
33266                                                                          ; is not yet exploding but it has been killed, so we
33267                                                                          ; need to start an explosion
33268               
33269 94C8 F020  30        socb @XX1+31,ra                 ; ORA XX1+31        ; Clear bits 6 and 7 of the ship's byte #31, to stop the
     94CA 0072     
33270 94CC 0240  22        andi ra,>3f*256                 ; AND #%00111111    ; ship from firing its laser and to mark it as no longer
     94CE 3F00     
33271 94D0 D800  30        movb ra,@XX1+31                 ; STA XX1+31        ; having just been killed
     94D2 0072     
33272               
33273 94D4 0200  20        li   ra,>00*256                 ; LDA #0            ; Set the ship's acceleration in byte #31 to 0, updating
     94D6 0000     
33274 94D8 0202  20        li   ry,>1c*256                 ; LDY #28           ; the byte in the workspace K% data block so we don't
     94DA 1C00     
33275                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; have to copy it back from INWK later
     **** ****     > ST_IND_Y_IDX
0001 94DC D820  42        movb @INF,@rtmplb
     94DE 0020     
     94E0 830D     
0002 94E2 D1A0  30        movb @INF+1,rtmp
     94E4 0021     
0003 94E6 A182  18        a    ry,rtmp
0004 94E8 D580  30        movb RA,*rtmp
                   < elite.a99
33276               
33277 94EA 0202  20        li   ry,>1e*256                 ; LDY #30           ; Set the ship's pitch counter in byte #30 to 0, to stop
     94EC 1E00     
33278                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; the ship from pitching
     **** ****     > ST_IND_Y_IDX
0001 94EE D820  42        movb @INF,@rtmplb
     94F0 0020     
     94F2 830D     
0002 94F4 D1A0  30        movb @INF+1,rtmp
     94F6 0021     
0003 94F8 A182  18        a    ry,rtmp
0004 94FA D580  30        movb RA,*rtmp
                   < elite.a99
33279               
33280 94FC 0206  20        li   rtmp,EE51                  ; JSR EE51          ; Call EE51 to remove the ship from the screen
     94FE 957C     
33281 9500 06A0  28        bl   @jsr                       ;
     9502 8002     
33282               
33283                                                                          ; We now need to set up a new explosion cloud. We
33284                                                                          ; initialise it with a size of 18 (which gets increased
33285                                                                          ; by 4 every time the cloud gets redrawn), and the
33286                                                                          ; explosion count (i.e. the number of particles in the
33287                                                                          ; explosion), which go into bytes 1 and 2 of the ship
33288                                                                          ; line heap. See DOEXP for more details of explosion
33289                                                                          ; clouds
33290               
33291 9504 0202  20        li   ry,>01*256                 ; LDY #1            ; Set byte #1 of the ship line heap to 18, the initial
     9506 0100     
33292 9508 0200  20        li   ra,>12*256                 ; LDA #18           ; size of the explosion cloud
     950A 1200     
33293                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 950C D820  42        movb @XX19,@rtmplb
     950E 0074     
     9510 830D     
0002 9512 D1A0  30        movb @XX19+1,rtmp
     9514 0075     
0003 9516 A182  18        a    ry,rtmp
0004 9518 D580  30        movb RA,*rtmp
                   < elite.a99
33294               
33295 951A 0202  20        li   ry,>07*256                 ; LDY #7            ; Fetch byte #7 from the ship's blueprint, which
     951C 0700     
33296                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; determines the explosion count (i.e. the number of
     **** ****     > LD_IND_Y_IDX
0001 951E D820  42        movb @XX0,@rtmplb
     9520 001E     
     9522 830D     
0002 9524 D1A0  30        movb @XX0+1,rtmp
     9526 001F     
0003 9528 A182  18        a    ry,rtmp
0004 952A D016  26        movb *rtmp,RA
                   < elite.a99
33297 952C 0202  20        li   ry,>02*256                 ; LDY #2            ; vertices used as origins for explosion clouds), and
     952E 0200     
33298                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; store it in byte #2 of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 9530 D820  42        movb @XX19,@rtmplb
     9532 0074     
     9534 830D     
0002 9536 D1A0  30        movb @XX19+1,rtmp
     9538 0075     
0003 953A A182  18        a    ry,rtmp
0004 953C D580  30        movb RA,*rtmp
                   < elite.a99
33299               
33300               * LDA XX1+32             \ These instructions are commented out in the original
33301               * AND #&7F               \ source
33302               
33303                                                                          ; The following loop sets bytes 3-6 of the of the ship
33304                                                                          ; line heap to random numbers
33305               
33306               EE55:
33307 953E B084  18        ab   rone,ry                    ; INY               ; Increment Y (so the loop starts at 3)
33308               
33309 9540 0206  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     9542 8070     
33310 9544 06A0  28        bl   @jsr                       ;
     9546 8002     
33311               
33312                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store A in the Y-th byte of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 9548 D820  42        movb @XX19,@rtmplb
     954A 0074     
     954C 830D     
0002 954E D1A0  30        movb @XX19+1,rtmp
     9550 0075     
0003 9552 A182  18        a    ry,rtmp
0004 9554 D580  30        movb RA,*rtmp
                   < elite.a99
33313               
33314 9556 0282  22        ci   ry,>06*256                 ; CPY #6            ; Loop back until we have randomised the 6th byte
     9558 0600     
33315 955A 16F1  14        jne  EE55                       ; BNE EE55
33316               
33317               EE28:
33318 955C D020  30        movb @XX1+8,ra                  ; LDA XX1+8         ; Set A = z_sign
     955E 005B     
33319               
33320               EE49:
33321 9560 151E  14        jgt  LL10                       ; BPL LL10          ; If A is positive, i.e. the ship is in front of us,
33322                                                                          ; jump down to LL10
33323               
33324               LL14:
33325                                                                          ; The following removes the ship from the screen by
33326                                                                          ; redrawing it (or, if it is exploding, by redrawing the
33327                                                                          ; explosion cloud). We call it when the ship is no
33328                                                                          ; longer on-screen, is too far away to be fully drawn,
33329                                                                          ; and so on
33330 9562 D020  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     9564 0072     
33331 9566 0240  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE51
     9568 2000     
33332 956A 1308  14        jeq  EE51                       ; BEQ EE51          ; to redraw its wireframe
33333               
33334 956C D020  30        movb @XX1+31,ra                 ; LDA XX1+31        ; The ship is exploding, so clear bit 3 of the ship's
     956E 0072     
33335 9570 0240  22        andi ra,>f7*256                 ; AND #%11110111    ; byte #31 to denote that the ship is no longer being
     9572 F700     
33336 9574 D800  30        movb ra,@XX1+31                 ; STA XX1+31        ; drawn on-screen
     9576 0072     
33337               
33338 9578 0460  28        b    @DOEXP                     ; JMP DOEXP         ; Jump to DOEXP to display the explosion cloud, which
     957A 6894     
33339                                                                          ; will remove it from the screen, returning from the
33340                                                                          ; subroutine using a tail call
33341               
33342               EE51:
33343 957C 0200  20        li   ra,>08*256                 ; LDA #%00001000    ; If bit 3 of the ship's byte #31 is clear, then there
     957E 0800     
33344                      .bit @XX1+31                    ; BIT XX1+31        ; is already nothing being shown for this ship, so
     **** ****     > BIT
0001 9580 D1A0  30        movb @XX1+31,rtmp
     9582 0072     
0002 9584 0546  14        inv  rtmp
0003 9586 D1C4  18        movb rone,rtmp2
0004 9588 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
33345 958A 1308  14        jeq  LL10-1                     ; BEQ LL10-1        ; return from the subroutine (as LL10-1 contains an RTS)
33346               
33347                      .eor @XX1+31                    ; EOR XX1+31        ; Otherwise flip bit 3 of byte #31 and store it (which
     **** ****     > EOR
0001 958C D1A0  30        movb @XX1+31,rtmp
     958E 0072     
0002 9590 2806  18        xor  rtmp,ra
                   < elite.a99
33348 9592 D800  30        movb ra,@XX1+31                 ; STA XX1+31        ; clears bit 3 as we know it was set before the EOR), so
     9594 0072     
33349                                                                          ; this sets this ship as no longer being drawn on-screen
33350               
33351 9596 0460  28        b    @LL155                     ; JMP LL155         ; Jump to LL155 to draw the ship, which removes it from
     9598 A250     
33352                                                                          ; the screen, returning from the subroutine using a
33353                                                                          ; tail call
33354               
33355               * .LL24                  \ This label is commented out in the original source,
33356                                                                          ; and was presumably used to label the RTS which is
33357                                                                          ; actually called by LL10-1 above, not LL24
33358               
33359 959A 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     959C 800E     
33360               
33361               * ******************************************************************************
33362               *
33363               * Name: LL9 (Part 2 of 12)
33364               * Type: Subroutine
33365               * Category: Drawing ships
33366               * Summary: Draw ship: Check if ship is in field of view, close enough to draw
33367               * Deep dive: Drawing ships
33368               *
33369               * ------------------------------------------------------------------------------
33370               *
33371               * This part checks whether the ship is in our field of view, and whether it is
33372               * close enough to be fully drawn (if not, we jump to SHPPT to draw it as a dot).
33373               *
33374               * ------------------------------------------------------------------------------
33375               *
33376               * Other entry points:
33377               *
33378               * LL10-1              Contains an RTS
33379               *
33380               * ******************************************************************************
33381               
33382               LL10:
33383 959E D020  30        movb @XX1+7,ra                  ; LDA XX1+7         ; Set A = z_hi
     95A0 005A     
33384               
33385 95A2 0280  22        ci   ra,>c0*256                 ; CMP #192          ; If A >= 192 then the ship is a long way away, so jump
     95A4 C000     
33386 95A6 18DD  14        joc  LL14                       ; BCS LL14          ; to LL14 to remove the ship from the screen
33387               
33388 95A8 D020  30        movb @XX1,ra                    ; LDA XX1           ; If x_lo >= z_lo, set the C flag, otherwise clear it
     95AA 0053     
33389 95AC 9020  30        cb   @XX1+6,ra                  ; CMP XX1+6
     95AE 0059     
33390               
33391 95B0 D020  30        movb @XX1+1,ra                  ; LDA XX1+1         ; Set A = x_hi - z_hi using the carry from the low
     95B2 0054     
33392                      .sbc @XX1+7,ra                  ; SBC XX1+7         ; bytes, which sets the C flag as if we had done a full
     **** ****     > SBC
0001 95B4 1801  14        joc  !
0002 95B6 7004  18        sb   rone,ra
0003               !:
0004 95B8 7020  30        sb   @XX1+7,ra
     95BA 005A     
                   < elite.a99
33393                                                                          ; two-byte subtraction (x_hi x_lo) - (z_hi z_lo)
33394               
33395 95BC 18D2  14        joc  LL14                       ; BCS LL14          ; If the C flag is set then x >= z, so the ship is
33396                                                                          ; further to the side than it is in front of us, so it's
33397                                                                          ; outside our viewing angle of 45 degrees, and we jump
33398                                                                          ; to LL14 to remove it from the screen
33399               
33400 95BE D020  30        movb @XX1+3,ra                  ; LDA XX1+3         ; If y_lo >= z_lo, set the C flag, otherwise clear it
     95C0 0056     
33401 95C2 9020  30        cb   @XX1+6,ra                  ; CMP XX1+6
     95C4 0059     
33402               
33403 95C6 D020  30        movb @XX1+4,ra                  ; LDA XX1+4         ; Set A = y_hi - z_hi using the carry from the low
     95C8 0057     
33404                      .sbc @XX1+7,ra                  ; SBC XX1+7         ; bytes, which sets the C flag as if we had done a full
     **** ****     > SBC
0001 95CA 1801  14        joc  !
0002 95CC 7004  18        sb   rone,ra
0003               !:
0004 95CE 7020  30        sb   @XX1+7,ra
     95D0 005A     
                   < elite.a99
33405                                                                          ; two-byte subtraction (y_hi y_lo) - (z_hi z_lo)
33406               
33407 95D2 18C7  14        joc  LL14                       ; BCS LL14          ; If the C flag is set then y >= z, so the ship is
33408                                                                          ; further above us than it is in front of us, so it's
33409                                                                          ; outside our viewing angle of 45 degrees, and we jump
33410                                                                          ; to LL14 to remove it from the screen
33411               
33412 95D4 0202  20        li   ry,>06*256                 ; LDY #6            ; Fetch byte #6 from the ship's blueprint into X, which
     95D6 0600     
33413                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; is the number * 4 of the vertex used for the ship's
     **** ****     > LD_IND_Y_IDX
0001 95D8 D820  42        movb @XX0,@rtmplb
     95DA 001E     
     95DC 830D     
0002 95DE D1A0  30        movb @XX0+1,rtmp
     95E0 001F     
0003 95E2 A182  18        a    ry,rtmp
0004 95E4 D016  26        movb *rtmp,RA
                   < elite.a99
33414 95E6 D040  18        movb ra,rx                      ; TAX               ; laser
33415               
33416 95E8 0200  20        li   ra,>ff*256                 ; LDA #255          ; Set bytes X and X+1 of the XX3 heap to 255. We're
     95EA FF00     
33417 95EC D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; going to use XX3 to store the screen coordinates of
     95EE 0100     
33418 95F0 D840  38        movb ra,@XX3+1(rx)              ; STA XX3+1,X       ; all the visible vertices of this ship, so setting the
     95F2 0101     
33419                                                                          ; laser vertex to 255 means that if we don't update this
33420                                                                          ; vertex with its screen coordinates in parts 6 and 7,
33421                                                                          ; this vertex's entry in the XX3 heap will still be 255,
33422                                                                          ; which we can check in part 9 to see if the laser
33423                                                                          ; vertex is visible (and therefore whether we should
33424                                                                          ; draw laser lines if the ship is firing on us)
33425               
33426 95F4 D020  30        movb @XX1+6,ra                  ; LDA XX1+6         ; Set (A T) = (z_hi z_lo)
     95F6 0059     
33427 95F8 D800  30        movb ra,@T                      ; STA T
     95FA 00D1     
33428 95FC D020  30        movb @XX1+7,ra                  ; LDA XX1+7
     95FE 005A     
33429               
33430 9600 0910  18        srl  ra,1                       ; LSR A             ; Set (A T) = (A T) / 8
33431 9602 0208  20        li   rarg1,T                    ; ROR T
     9604 00D1     
33432 9606 06A0  28        bl   @ror                       ;
     9608 8054     
33433 960A 0910  18        srl  ra,1                       ; LSR A
33434 960C 0208  20        li   rarg1,T                    ; ROR T
     960E 00D1     
33435 9610 06A0  28        bl   @ror                       ;
     9612 8054     
33436 9614 0910  18        srl  ra,1                       ; LSR A
33437 9616 0208  20        li   rarg1,T                    ; ROR T
     9618 00D1     
33438 961A 06A0  28        bl   @ror                       ;
     961C 8054     
33439               
33440 961E 0910  18        srl  ra,1                       ; LSR A             ; If A >> 4 is non-zero, i.e. z_hi >= 16, jump to LL13
33441 9620 160A  14        jne  LL13                       ; BNE LL13          ; as the ship is possibly far away enough to be shown as
33442                                                                          ; a dot
33443               
33444 9622 D020  30        movb @T,ra                      ; LDA T             ; Otherwise the C flag contains the previous bit 0 of A,
     9624 00D1     
33445 9626 06A0  28        bl   @rora                      ; ROR A             ; which could have been set, so rotate A right four
     9628 803C     
33446 962A 0910  18        srl  ra,1                       ; LSR A             ; times so it's in the form %000xxxxx, i.e. z_hi reduced
33447 962C 0910  18        srl  ra,1                       ; LSR A             ; to a maximum value of 31
33448 962E 0910  18        srl  ra,1                       ; LSR A
33449               
33450 9630 D800  30        movb ra,@XX4                    ; STA XX4           ; Store A in XX4, which is now the distance of the ship
     9632 00A7     
33451                                                                          ; we can use for visibility testing
33452               
33453 9634 1515  14        jgt  LL17                       ; BPL LL17          ; Jump down to LL17 (this BPL is effectively a JMP as we
33454                                                                          ; know bit 7 of A is definitely clear)
33455               
33456               LL13:
33457                                                                          ; If we get here then the ship is possibly far enough
33458                                                                          ; away to be shown as a dot
33459 9636 0202  20        li   ry,>0d*256                 ; LDY #13           ; Fetch byte #13 from the ship's blueprint, which gives
     9638 0D00     
33460                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the ship's visibility distance, beyond which we show
     **** ****     > LD_IND_Y_IDX
0001 963A D820  42        movb @XX0,@rtmplb
     963C 001E     
     963E 830D     
0002 9640 D1A0  30        movb @XX0+1,rtmp
     9642 001F     
0003 9644 A182  18        a    ry,rtmp
0004 9646 D016  26        movb *rtmp,RA
                   < elite.a99
33461                                                                          ; the ship as a dot
33462               
33463 9648 9020  30        cb   @XX1+7,ra                  ; CMP XX1+7         ; If z_hi <= the visibility distance, skip to LL17 to
     964A 005A     
33464 964C 1809  14        joc  LL17                       ; BCS LL17          ; draw the ship fully, rather than as a dot, as it is
33465                                                                          ; closer than the visibility distance
33466               
33467 964E 0200  20        li   ra,>20*256                 ; LDA #%00100000    ; If bit 5 of the ship's byte #31 is set, then the
     9650 2000     
33468                      .and @XX1+31                    ; AND XX1+31        ; ship is currently exploding, so skip to LL17 to draw
     **** ****     > AND
0001 9652 D1A0  30        movb @XX1+31,rtmp
     9654 0072     
0002 9656 0546  14        inv  rtmp
0003 9658 5006  18        szcb rtmp,ra
                   < elite.a99
33469 965A 1602  14        jne  LL17                       ; BNE LL17          ; the ship's explosion cloud
33470               
33471 965C 0460  28        b    @SHPPT                     ; JMP SHPPT         ; Otherwise jump to SHPPT to draw the ship as a dot,
     965E 91E2     
33472                                                                          ; returning from the subroutine using a tail call
33473               
33474               * ******************************************************************************
33475               *
33476               * Name: LL9 (Part 3 of 12)
33477               * Type: Subroutine
33478               * Category: Drawing ships
33479               * Summary: Draw ship: Set up orientation vector, ship coordinate variables
33480               * Deep dive: Drawing ships
33481               *
33482               * ------------------------------------------------------------------------------
33483               *
33484               * This part sets up the following variable blocks:
33485               *
33486               * * XX16 contains the orientation vectors, divided to normalise them
33487               *
33488               * * XX18 contains the ship's x, y and z coordinates in space
33489               *
33490               * ******************************************************************************
33491               
33492               LL17:
33493 9660 0201  20        li   rx,>05*256                 ; LDX #5            ; First we copy the three orientation vectors into XX16,
     9662 0500     
33494                                                                          ; so set up a counter in X for the 6 bytes in each
33495                                                                          ; vector
33496               
33497               LL15:
33498 9664 D021  34        movb @XX1+21(rx),ra             ; LDA XX1+21,X      ; Copy the X-th byte of sidev to the X-th byte of XX16
     9666 0068     
33499 9668 D840  38        movb ra,@XX16(rx)               ; STA XX16,X
     966A 0009     
33500               
33501 966C D021  34        movb @XX1+15(rx),ra             ; LDA XX1+15,X      ; Copy the X-th byte of roofv to XX16+6 to the X-th byte
     966E 0062     
33502 9670 D840  38        movb ra,@XX16+6(rx)             ; STA XX16+6,X      ; of XX16+6
     9672 000F     
33503               
33504 9674 D021  34        movb @XX1+9(rx),ra              ; LDA XX1+9,X       ; Copy the X-th byte of nosev to XX16+12 to the X-th
     9676 005C     
33505 9678 D840  38        movb ra,@XX16+12(rx)            ; STA XX16+12,X     ; byte of XX16+12
     967A 0015     
33506               
33507 967C 7044  18        sb   rone,rx                    ; DEX               ; Decrement the counter
33508               
33509 967E 15F2  14        jgt  LL15                       ; BPL LL15          ; Loop back to copy the next byte of each vector, until
33510                                                                          ; we have the following:
33511                                                                          ;
33512                                                                          ; * XX16(1 0) = sidev_x
33513                                                                          ; * XX16(3 2) = sidev_y
33514                                                                          ; * XX16(5 4) = sidev_z
33515                                                                          ;
33516                                                                          ; * XX16(7 6) = roofv_x
33517                                                                          ; * XX16(9 8) = roofv_y
33518                                                                          ; * XX16(11 10) = roofv_z
33519                                                                          ;
33520                                                                          ; * XX16(13 12) = nosev_x
33521                                                                          ; * XX16(15 14) = nosev_y
33522                                                                          ; * XX16(17 16) = nosev_z
33523               
33524 9680 0200  20        li   ra,>c5*256                 ; LDA #197          ; Set Q = 197
     9682 C500     
33525 9684 D800  30        movb ra,@Q                      ; STA Q
     9686 0090     
33526               
33527 9688 0202  20        li   ry,>10*256                 ; LDY #16           ; Set Y to be a counter that counts down by 2 each time,
     968A 1000     
33528                                                                          ; starting with 16, then 14, 12 and so on. We use this
33529                                                                          ; to work through each of the coordinates in each of the
33530                                                                          ; orientation vectors
33531               
33532               LL21:
33533 968C D022  34        movb @XX16(ry),ra               ; LDA XX16,Y        ; Set A = the low byte of the vector coordinate, e.g.
     968E 0009     
33534                                                                          ; nosev_z_lo when Y = 16
33535               
33536                      .asla                           ; ASL A             ; Shift bit 7 into the C flag
     **** ****     > ASLA
0001 9690 0240  22        andi ra,>ff00
     9692 FF00     
0002 9694 0A10  18        sla  ra,1
                   < elite.a99
33537               
33538 9696 D022  34        movb @XX16+1(ry),ra             ; LDA XX16+1,Y      ; Set A = the high byte of the vector coordinate, e.g.
     9698 000A     
33539                                                                          ; nosev_z_hi when Y = 16
33540               
33541 969A 06A0  28        bl   @rola                      ; ROL A             ; Rotate A left, incorporating the C flag, so A now
     969C 8018     
33542                                                                          ; contains the original high byte, doubled, and without
33543                                                                          ; a sign bit, e.g. A = |nosev_z_hi| * 2
33544               
33545 969E 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     96A0 9338     
33546 96A2 06A0  28        bl   @jsr                       ;
     96A4 8002     
33547                                                                          ;
33548                                                                          ; R = 256 * A / Q
33549                                                                          ;
33550                                                                          ; so, for nosev, this would be:
33551                                                                          ;
33552                                                                          ; R = 256 * |nosev_z_hi| * 2 / 197
33553                                                                          ; = 2.6 * |nosev_z_hi|
33554               
33555 96A6 D060  30        movb @R,rx                      ; LDX R             ; Store R in the low byte's location, so we can keep the
     96A8 0091     
33556 96AA D881  38        movb rx,@XX16(ry)               ; STX XX16,Y        ; old, unscaled high byte intact for the sign
     96AC 0009     
33557               
33558 96AE 7084  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter twice
33559 96B0 7084  18        sb   rone,ry                    ; DEY
33560               
33561 96B2 15EC  14        jgt  LL21                       ; BPL LL21          ; Loop back for the next vector coordinate until we have
33562                                                                          ; divided them all
33563               
33564                                                                          ; By this point, the vectors have been turned into
33565                                                                          ; scaled magnitudes, so we have the following:
33566                                                                          ;
33567                                                                          ; * XX16   = scaled |sidev_x|
33568                                                                          ; * XX16+2 = scaled |sidev_y|
33569                                                                          ; * XX16+4 = scaled |sidev_z|
33570                                                                          ;
33571                                                                          ; * XX16+6  = scaled |roofv_x|
33572                                                                          ; * XX16+8  = scaled |roofv_y|
33573                                                                          ; * XX16+10 = scaled |roofv_z|
33574                                                                          ;
33575                                                                          ; * XX16+12 = scaled |nosev_x|
33576                                                                          ; * XX16+14 = scaled |nosev_y|
33577                                                                          ; * XX16+16 = scaled |nosev_z|
33578               
33579 96B4 0201  20        li   rx,>08*256                 ; LDX #8            ; Next we copy the ship's coordinates into XX18, so set
     96B6 0800     
33580                                                                          ; up a counter in X for 9 bytes
33581               
33582               ll91_:
33583 96B8 D021  34        movb @XX1(rx),ra                ; LDA XX1,X         ; Copy the X-th byte from XX1 to XX18
     96BA 0053     
33584 96BC D840  38        movb ra,@XX18(rx)               ; STA XX18,X
     96BE 007E     
33585               
33586 96C0 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
33587               
33588 96C2 15FA  14        jgt  ll91_                      ; BPL ll91          ; Loop back for the next byte until we have copied all
33589                                                                          ; three coordinates
33590               
33591                                                                          ; So we now have the following:
33592                                                                          ;
33593                                                                          ; * XX18(2 1 0) = (x_sign x_hi x_lo)
33594                                                                          ;
33595                                                                          ; * XX18(5 4 3) = (y_sign y_hi y_lo)
33596                                                                          ;
33597                                                                          ; * XX18(8 7 6) = (z_sign z_hi z_lo)
33598               
33599 96C4 0200  20        li   ra,>ff*256                 ; LDA #255          ; Set the 15th byte of XX2 to 255, so that face 15 is
     96C6 FF00     
33600 96C8 D800  30        movb ra,@XX2+15                 ; STA XX2+15        ; always visible. No ship definitions actually have this
     96CA 00E1     
33601                                                                          ; number of faces, but this allows us to force a vertex
33602                                                                          ; to always be visible by associating it with face 15
33603                                                                          ; (see the ship blueprints for the Cobra Mk III at
33604                                                                          ; SHIP_COBRA_MK_3 and the asteroid at SHIP_ASTEROID for
33605                                                                          ; examples of vertices that are associated with face 15)
33606               
33607 96CC 0202  20        li   ry,>0c*256                 ; LDY #12           ; Set Y = 12 to point to the ship blueprint byte #12,
     96CE 0C00     
33608               
33609 96D0 D020  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     96D2 0072     
33610 96D4 0240  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE29
     96D6 2000     
33611 96D8 1315  14        jeq  EE29                       ; BEQ EE29          ; to skip the following
33612               
33613                                                                          ; Otherwise we fall through to set up the visibility
33614                                                                          ; block for an exploding ship
33615               
33616               * ******************************************************************************
33617               *
33618               * Name: LL9 (Part 4 of 12)
33619               * Type: Subroutine
33620               * Category: Drawing ships
33621               * Summary: Draw ship: Set visibility for exploding ship (all faces visible)
33622               * Deep dive: Drawing ships
33623               *
33624               * ------------------------------------------------------------------------------
33625               *
33626               * This part sets up the visibility block in XX2 for a ship that is exploding.
33627               *
33628               * The XX2 block consists of one byte for each face in the ship's blueprint,
33629               * which holds the visibility of that face. Because the ship is exploding, we
33630               * want to set all the faces to be visible. A value of 255 in the visibility
33631               * table means the face is visible, so the following code sets each face to 255
33632               * and then skips over the face visibility calculations that we would apply to a
33633               * non-exploding ship.
33634               *
33635               * ******************************************************************************
33636               
33637                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; Fetch byte #12 of the ship's blueprint, which contains
     **** ****     > LD_IND_Y_IDX
0001 96DA D820  42        movb @XX0,@rtmplb
     96DC 001E     
     96DE 830D     
0002 96E0 D1A0  30        movb @XX0+1,rtmp
     96E2 001F     
0003 96E4 A182  18        a    ry,rtmp
0004 96E6 D016  26        movb *rtmp,RA
                   < elite.a99
33638                                                                          ; the number of faces * 4
33639               
33640 96E8 0910  18        srl  ra,1                       ; LSR A             ; Set X = A / 4
33641 96EA 0910  18        srl  ra,1                       ; LSR A             ; = the number of faces
33642 96EC D040  18        movb ra,rx                      ; TAX
33643               
33644 96EE 0200  20        li   ra,>ff*256                 ; LDA #255          ; Set A = 255
     96F0 FF00     
33645               
33646               EE30:
33647 96F2 D840  38        movb ra,@XX2(rx)                ; STA XX2,X         ; Set the X-th byte of XX2 to 255
     96F4 00D2     
33648               
33649 96F6 7044  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
33650               
33651 96F8 15FC  14        jgt  EE30                       ; BPL EE30          ; Loop back for the next byte until there is one byte
33652                                                                          ; set to 255 for each face
33653               
33654 96FA B044  18        ab   rone,rx                    ; INX               ; Set XX4 = 0 for the distance value we use to test
33655 96FC D801  30        movb rx,@XX4                    ; STX XX4           ; for visibility, so we always shows everything
     96FE 00A7     
33656               
33657               LL41:
33658 9700 0460  28        b    @LL42                      ; JMP LL42          ; Jump to LL42 to skip the face visibility calculations
     9702 9A88     
33659                                                                          ; as we don't need to do them now we've set up the XX2
33660                                                                          ; block for the explosion
33661               
33662               * ******************************************************************************
33663               *
33664               * Name: LL9 (Part 5 of 12)
33665               * Type: Subroutine
33666               * Category: Drawing ships
33667               * Summary: Draw ship: Calculate the visibility of each of the ship's faces
33668               * Deep dive: Drawing ships
33669               * Back-face culling
33670               *
33671               * ******************************************************************************
33672               
33673               EE29:
33674                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; We set Y to 12 above before jumping down to EE29, so
     **** ****     > LD_IND_Y_IDX
0001 9704 D820  42        movb @XX0,@rtmplb
     9706 001E     
     9708 830D     
0002 970A D1A0  30        movb @XX0+1,rtmp
     970C 001F     
0003 970E A182  18        a    ry,rtmp
0004 9710 D016  26        movb *rtmp,RA
                   < elite.a99
33675                                                                          ; this fetches byte #12 of the ship's blueprint, which
33676                                                                          ; contains the number of faces * 4
33677               
33678 9712 13F6  14        jeq  LL41                       ; BEQ LL41          ; If there are no faces in this ship, jump to LL42 (via
33679                                                                          ; LL41) to skip the face visibility calculations
33680               
33681 9714 D800  30        movb ra,@XX20                   ; STA XX20          ; Set A = the number of faces * 4
     9716 00A8     
33682               
33683 9718 0202  20        li   ry,>12*256                 ; LDY #18           ; Fetch byte #18 of the ship's blueprint, which contains
     971A 1200     
33684                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the factor by which we scale the face normals, into X
     **** ****     > LD_IND_Y_IDX
0001 971C D820  42        movb @XX0,@rtmplb
     971E 001E     
     9720 830D     
0002 9722 D1A0  30        movb @XX0+1,rtmp
     9724 001F     
0003 9726 A182  18        a    ry,rtmp
0004 9728 D016  26        movb *rtmp,RA
                   < elite.a99
33685 972A D040  18        movb ra,rx                      ; TAX
33686               
33687 972C D020  30        movb @XX18+7,ra                 ; LDA XX18+7        ; Set A = z_hi
     972E 0085     
33688               
33689               LL90:
33690 9730 D080  18        movb ra,ry                      ; TAY               ; Set Y = z_hi
33691               
33692 9732 131A  14        jeq  LL91                       ; BEQ LL91          ; If z_hi = 0 then jump to LL91
33693               
33694                                                                          ; The following is a loop that jumps back to LL90+3,
33695                                                                          ; i.e. here. LL90 is only used for this loop, so it's a
33696                                                                          ; bit of a strange use of the label here
33697               
33698 9734 B044  18        ab   rone,rx                    ; INX               ; Increment the scale factor in X
33699               
33700                      .lsr @XX18+4                    ; LSR XX18+4        ; Divide (y_hi y_lo) by 2
     **** ****     > LSR
0001 9736 D1A0  30        movb @XX18+4,rtmp
     9738 0082     
0002 973A 0916  18        srl  rtmp,1
0003 973C D806  30        movb rtmp,@XX18+4
     973E 0082     
                   < elite.a99
33701 9740 0208  20        li   rarg1,XX18+3               ; ROR XX18+3
     9742 0081     
33702 9744 06A0  28        bl   @ror                       ;
     9746 8054     
33703               
33704                      .lsr @XX18+1                    ; LSR XX18+1        ; Divide (x_hi x_lo) by 2
     **** ****     > LSR
0001 9748 D1A0  30        movb @XX18+1,rtmp
     974A 007F     
0002 974C 0916  18        srl  rtmp,1
0003 974E D806  30        movb rtmp,@XX18+1
     9750 007F     
                   < elite.a99
33705 9752 0208  20        li   rarg1,XX18                 ; ROR XX18
     9754 007E     
33706 9756 06A0  28        bl   @ror                       ;
     9758 8054     
33707               
33708 975A 0910  18        srl  ra,1                       ; LSR A             ; Divide (z_hi z_lo) by 2 (as A contains z_hi)
33709 975C 0208  20        li   rarg1,XX18+6               ; ROR XX18+6
     975E 0084     
33710 9760 06A0  28        bl   @ror                       ;
     9762 8054     
33711               
33712 9764 D080  18        movb ra,ry                      ; TAY               ; Set Y = z_hi
33713               
33714 9766 16E5  14        jne  LL90+3                     ; BNE LL90+3        ; If Y is non-zero, loop back to LL90+3 to divide the
33715                                                                          ; three coordinates until z_hi is 0
33716               
33717               LL91:
33718                                                                          ; By this point z_hi is 0 and X contains the number of
33719                                                                          ; right shifts we had to do, plus the scale factor from
33720                                                                          ; the blueprint
33721 9768 D801  30        movb rx,@XX17                   ; STX XX17          ; Store the updated scale factor in XX17
     976A 0095     
33722               
33723 976C D020  30        movb @XX18+8,ra                 ; LDA XX18+8        ; Set XX15+5 = z_sign
     976E 0086     
33724 9770 D800  30        movb ra,@XX15+5                 ; STA XX15+5
     9772 0036     
33725               
33726 9774 D020  30        movb @XX18,ra                   ; LDA XX18          ; Set XX15(1 0) = (x_sign x_lo)
     9776 007E     
33727 9778 D800  30        movb ra,@XX15                   ; STA XX15
     977A 0031     
33728 977C D020  30        movb @XX18+2,ra                 ; LDA XX18+2
     977E 0080     
33729 9780 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     9782 0032     
33730               
33731 9784 D020  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set XX15(3 2) = (y_sign y_lo)
     9786 0081     
33732 9788 D800  30        movb ra,@XX15+2                 ; STA XX15+2
     978A 0033     
33733 978C D020  30        movb @XX18+5,ra                 ; LDA XX18+5
     978E 0083     
33734 9790 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     9792 0034     
33735               
33736 9794 D020  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set XX15+4 = z_lo, so now XX15(5 4) = (z_sign z_lo)
     9796 0084     
33737 9798 D800  30        movb ra,@XX15+4                 ; STA XX15+4
     979A 0035     
33738               
33739 979C 0206  20        li   rtmp,LL51                  ; JSR LL51          ; Call LL51 to set XX12 to the dot products of XX15 and
     979E 93E6     
33740 97A0 06A0  28        bl   @jsr                       ;
     97A2 8002     
33741                                                                          ; XX16, which we'll call dot_sidev, dot_roofv and
33742                                                                          ; dot_nosev:
33743                                                                          ;
33744                                                                          ; XX12(1 0) = [x y z] . sidev
33745                                                                          ; = (dot_sidev_sign dot_sidev_lo)
33746                                                                          ; = dot_sidev
33747                                                                          ;
33748                                                                          ; XX12(3 2) = [x y z] . roofv
33749                                                                          ; = (dot_roofv_sign dot_roofv_lo)
33750                                                                          ; = dot_roofv
33751                                                                          ;
33752                                                                          ; XX12(5 4) = [x y z] . nosev
33753                                                                          ; = (dot_nosev_sign dot_nosev_lo)
33754                                                                          ; = dot_nosev
33755               
33756 97A4 D020  30        movb @XX12,ra                   ; LDA XX12          ; Set XX18(2 0) = dot_sidev
     97A6 0037     
33757 97A8 D800  30        movb ra,@XX18                   ; STA XX18
     97AA 007E     
33758 97AC D020  30        movb @XX12+1,ra                 ; LDA XX12+1
     97AE 0038     
33759 97B0 D800  30        movb ra,@XX18+2                 ; STA XX18+2
     97B2 0080     
33760               
33761 97B4 D020  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set XX18(5 3) = dot_roofv
     97B6 0039     
33762 97B8 D800  30        movb ra,@XX18+3                 ; STA XX18+3
     97BA 0081     
33763 97BC D020  30        movb @XX12+3,ra                 ; LDA XX12+3
     97BE 003A     
33764 97C0 D800  30        movb ra,@XX18+5                 ; STA XX18+5
     97C2 0083     
33765               
33766 97C4 D020  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set XX18(8 6) = dot_nosev
     97C6 003B     
33767 97C8 D800  30        movb ra,@XX18+6                 ; STA XX18+6
     97CA 0084     
33768 97CC D020  30        movb @XX12+5,ra                 ; LDA XX12+5
     97CE 003C     
33769 97D0 D800  30        movb ra,@XX18+8                 ; STA XX18+8
     97D2 0086     
33770               
33771 97D4 0202  20        li   ry,>04*256                 ; LDY #4            ; Fetch byte #4 of the ship's blueprint, which contains
     97D6 0400     
33772                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the low byte of the offset to the faces data
     **** ****     > LD_IND_Y_IDX
0001 97D8 D820  42        movb @XX0,@rtmplb
     97DA 001E     
     97DC 830D     
0002 97DE D1A0  30        movb @XX0+1,rtmp
     97E0 001F     
0003 97E2 A182  18        a    ry,rtmp
0004 97E4 D016  26        movb *rtmp,RA
                   < elite.a99
33773               
33774                      .clc                            ; CLC               ; Set V = low byte faces offset + XX0
     **** ****     > CLC
0001 97E6 0A13  18        sla  rzero,1
                   < elite.a99
33775                      .adc @XX0,ra                    ; ADC XX0
     **** ****     > ADC
0001 97E8 1701  14        jnc  !
0002 97EA B004  18        ab   rone,ra
0003               !:
0004 97EC B020  30        ab   @XX0,ra
     97EE 001E     
                   < elite.a99
33776 97F0 D800  30        movb ra,@V                      ; STA V
     97F2 0022     
33777               
33778 97F4 0202  20        li   ry,>11*256                 ; LDY #17           ; Fetch byte #17 of the ship's blueprint, which contains
     97F6 1100     
33779                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the high byte of the offset to the faces data
     **** ****     > LD_IND_Y_IDX
0001 97F8 D820  42        movb @XX0,@rtmplb
     97FA 001E     
     97FC 830D     
0002 97FE D1A0  30        movb @XX0+1,rtmp
     9800 001F     
0003 9802 A182  18        a    ry,rtmp
0004 9804 D016  26        movb *rtmp,RA
                   < elite.a99
33780               
33781                      .adc @XX0+1,ra                  ; ADC XX0+1         ; Set V+1 = high byte faces offset + XX0+1
     **** ****     > ADC
0001 9806 1701  14        jnc  !
0002 9808 B004  18        ab   rone,ra
0003               !:
0004 980A B020  30        ab   @XX0+1,ra
     980C 001F     
                   < elite.a99
33782 980E D800  30        movb ra,@V+1                    ; STA V+1           ;
     9810 0023     
33783                                                                          ; So V(1 0) now points to the start of the faces data
33784                                                                          ; for this ship
33785               
33786 9812 0202  20        li   ry,>00*256                 ; LDY #0            ; We're now going to loop through all the faces for this
     9814 0000     
33787                                                                          ; ship, so set a counter in Y, starting from 0, which we
33788                                                                          ; will increment by 4 each loop to step through the
33789                                                                          ; four bytes of data for each face
33790               
33791               LL86:
33792                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this face into A, so:
     **** ****     > LD_IND_Y_IDX
0001 9816 D820  42        movb @V,@rtmplb
     9818 0022     
     981A 830D     
0002 981C D1A0  30        movb @V+1,rtmp
     981E 0023     
0003 9820 A182  18        a    ry,rtmp
0004 9822 D016  26        movb *rtmp,RA
                   < elite.a99
33793                                                                          ;
33794                                                                          ; A = %xyz vvvvv, where:
33795                                                                          ;
33796                                                                          ; * Bits 0-4 = visibility distance, beyond which the
33797                                                                          ; face is always shown
33798                                                                          ;
33799                                                                          ; * Bits 7-5 = the sign bits of normal_x, normal_y
33800                                                                          ; and normal_z
33801               
33802 9824 D800  30        movb ra,@XX12+1                 ; STA XX12+1        ; Store byte #0 in XX12+1, so XX12+1 now has the sign of
     9826 0038     
33803                                                                          ; normal_x
33804               
33805 9828 0240  22        andi ra,>1f*256                 ; AND #%00011111    ; Extract bits 0-4 to give the visibility distance
     982A 1F00     
33806               
33807 982C 9020  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 <= the visibility distance, where XX4 contains
     982E 00A7     
33808 9830 1810  14        joc  LL87                       ; BCS LL87          ; the ship's z-distance reduced to 0-31 (which we set in
33809                                                                          ; part 2), skip to LL87 as this face is close enough
33810                                                                          ; that we have to test its visibility using the face
33811                                                                          ; normals
33812               
33813                                                                          ; Otherwise this face is within range and is therefore
33814                                                                          ; always shown
33815               
33816 9832 D002  18        movb ry,ra                      ; TYA               ; Set X = Y / 4
33817 9834 0910  18        srl  ra,1                       ; LSR A             ; = the number of this face * 4 /4
33818 9836 0910  18        srl  ra,1                       ; LSR A             ; = the number of this face
33819 9838 D040  18        movb ra,rx                      ; TAX
33820               
33821 983A 0200  20        li   ra,>ff*256                 ; LDA #255          ; Set the X-th byte of XX2 to 255 to denote that this
     983C FF00     
33822 983E D840  38        movb ra,@XX2(rx)                ; STA XX2,X         ; face is visible
     9840 00D2     
33823               
33824 9842 D002  18        movb ry,ra                      ; TYA               ; Set Y = Y + 4 to point to the next face
33825                      .adi (>04*256)                  ; ADC #4
     **** ****     > ADI
0001 9844 1701  14        jnc  !
0002 9846 B004  18        ab   rone,ra
0003               !:
0004 9848 0220  22        ai   ra,(>04*256)
     984A 0400     
                   < elite.a99
33826 984C D080  18        movb ra,ry                      ; TAY
33827               
33828 984E 0460  28        b    @LL88                      ; JMP LL88          ; Jump down to LL88 to skip the following, as we don't
     9850 9A7E     
33829                                                                          ; need to test the face normals
33830               
33831               LL87:
33832 9852 D020  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Fetch byte #0 for this face into A
     9854 0038     
33833               
33834                      .asla                           ; ASL A             ; Shift A left and store it, so XX12+3 now has the sign
     **** ****     > ASLA
0001 9856 0240  22        andi ra,>ff00
     9858 FF00     
0002 985A 0A10  18        sla  ra,1
                   < elite.a99
33835 985C D800  30        movb ra,@XX12+3                 ; STA XX12+3        ; of normal_y
     985E 003A     
33836               
33837                      .asla                           ; ASL A             ; Shift A left and store it, so XX12+5 now has the sign
     **** ****     > ASLA
0001 9860 0240  22        andi ra,>ff00
     9862 FF00     
0002 9864 0A10  18        sla  ra,1
                   < elite.a99
33838 9866 D800  30        movb ra,@XX12+5                 ; STA XX12+5        ; of normal_z
     9868 003C     
33839               
33840 986A B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
33841               
33842                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this face and store in XX12, so
     **** ****     > LD_IND_Y_IDX
0001 986C D820  42        movb @V,@rtmplb
     986E 0022     
     9870 830D     
0002 9872 D1A0  30        movb @V+1,rtmp
     9874 0023     
0003 9876 A182  18        a    ry,rtmp
0004 9878 D016  26        movb *rtmp,RA
                   < elite.a99
33843 987A D800  30        movb ra,@XX12                   ; STA XX12          ; XX12 = normal_x
     987C 0037     
33844               
33845 987E B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
33846               
33847                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this face and store in XX12+2, so
     **** ****     > LD_IND_Y_IDX
0001 9880 D820  42        movb @V,@rtmplb
     9882 0022     
     9884 830D     
0002 9886 D1A0  30        movb @V+1,rtmp
     9888 0023     
0003 988A A182  18        a    ry,rtmp
0004 988C D016  26        movb *rtmp,RA
                   < elite.a99
33848 988E D800  30        movb ra,@XX12+2                 ; STA XX12+2        ; XX12+2 = normal_y
     9890 0039     
33849               
33850 9892 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
33851               
33852                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this face and store in XX12+4, so
     **** ****     > LD_IND_Y_IDX
0001 9894 D820  42        movb @V,@rtmplb
     9896 0022     
     9898 830D     
0002 989A D1A0  30        movb @V+1,rtmp
     989C 0023     
0003 989E A182  18        a    ry,rtmp
0004 98A0 D016  26        movb *rtmp,RA
                   < elite.a99
33853 98A2 D800  30        movb ra,@XX12+4                 ; STA XX12+4        ; XX12+4 = normal_z
     98A4 003B     
33854               
33855                                                                          ; So we now have:
33856                                                                          ;
33857                                                                          ; XX12(1 0) = (normal_x_sign normal_x)
33858                                                                          ;
33859                                                                          ; XX12(3 2) = (normal_y_sign normal_y)
33860                                                                          ;
33861                                                                          ; XX12(5 4) = (normal_z_sign normal_z)
33862               
33863 98A6 D060  30        movb @XX17,rx                   ; LDX XX17          ; If XX17 < 4 then jump to LL92, otherwise we stored a
     98A8 0095     
33864 98AA 0281  22        ci   rx,>04*256                 ; CPX #4            ; larger scale factor above
     98AC 0400     
33865 98AE 172B  14        jnc  LL92                       ; BCC LL92
33866               
33867               LL143:
33868 98B0 D020  30        movb @XX18,ra                   ; LDA XX18          ; Set XX15(1 0) = XX18(2 0)
     98B2 007E     
33869 98B4 D800  30        movb ra,@XX15                   ; STA XX15          ; = dot_sidev
     98B6 0031     
33870 98B8 D020  30        movb @XX18+2,ra                 ; LDA XX18+2
     98BA 0080     
33871 98BC D800  30        movb ra,@XX15+1                 ; STA XX15+1
     98BE 0032     
33872               
33873 98C0 D020  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set XX15(3 2) = XX18(5 3)
     98C2 0081     
33874 98C4 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; = dot_roofv
     98C6 0033     
33875 98C8 D020  30        movb @XX18+5,ra                 ; LDA XX18+5
     98CA 0083     
33876 98CC D800  30        movb ra,@XX15+3                 ; STA XX15+3
     98CE 0034     
33877               
33878 98D0 D020  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set XX15(5 4) = XX18(8 6)
     98D2 0084     
33879 98D4 D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; = dot_nosev
     98D6 0035     
33880 98D8 D020  30        movb @XX18+8,ra                 ; LDA XX18+8
     98DA 0086     
33881 98DC D800  30        movb ra,@XX15+5                 ; STA XX15+5
     98DE 0036     
33882               
33883 98E0 0460  28        b    @LL89                      ; JMP LL89          ; Jump down to LL89
     98E2 99CA     
33884               
33885               ovflw_:
33886                                                                          ; If we get here then the addition below overflowed, so
33887                                                                          ; we halve the dot products and normal vector
33888                      .lsr @XX18                      ; LSR XX18          ; Divide dot_sidev_lo by 2, so dot_sidev = dot_sidev / 2
     **** ****     > LSR
0001 98E4 D1A0  30        movb @XX18,rtmp
     98E6 007E     
0002 98E8 0916  18        srl  rtmp,1
0003 98EA D806  30        movb rtmp,@XX18
     98EC 007E     
                   < elite.a99
33889               
33890                      .lsr @XX18+6                    ; LSR XX18+6        ; Divide dot_nosev_lo by 2, so dot_nosev = dot_nosev / 2
     **** ****     > LSR
0001 98EE D1A0  30        movb @XX18+6,rtmp
     98F0 0084     
0002 98F2 0916  18        srl  rtmp,1
0003 98F4 D806  30        movb rtmp,@XX18+6
     98F6 0084     
                   < elite.a99
33891               
33892                      .lsr @XX18+3                    ; LSR XX18+3        ; Divide dot_roofv_lo by 2, so dot_roofv = dot_roofv / 2
     **** ****     > LSR
0001 98F8 D1A0  30        movb @XX18+3,rtmp
     98FA 0081     
0002 98FC 0916  18        srl  rtmp,1
0003 98FE D806  30        movb rtmp,@XX18+3
     9900 0081     
                   < elite.a99
33893               
33894 9902 0201  20        li   rx,>01*256                 ; LDX #1            ; Set X = 1 so when we fall through into LL92, we divide
     9904 0100     
33895                                                                          ; the normal vector by 2 as well
33896               
33897               LL92:
33898                                                                          ; We jump here from above with the scale factor in X,
33899                                                                          ; and now we apply it by scaling the normal vector down
33900                                                                          ; by a factor of 2^X (i.e. divide by 2^X)
33901 9906 D020  30        movb @XX12,ra                   ; LDA XX12          ; Set XX15 = normal_x
     9908 0037     
33902 990A D800  30        movb ra,@XX15                   ; STA XX15
     990C 0031     
33903               
33904 990E D020  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set XX15+2 = normal_y
     9910 0039     
33905 9912 D800  30        movb ra,@XX15+2                 ; STA XX15+2
     9914 0033     
33906               
33907 9916 D020  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set A = normal_z
     9918 003B     
33908               
33909               LL93:
33910 991A 7044  18        sb   rone,rx                    ; DEX               ; Decrement the scale factor in X
33911               
33912 991C 110D  14        jlt  LL94                       ; BMI LL94          ; If X was 0 before the decrement, there is no scaling
33913                                                                          ; to do, so jump to LL94 to exit the loop
33914               
33915                      .lsr @XX15                      ; LSR XX15          ; Set XX15 = XX15 / 2
     **** ****     > LSR
0001 991E D1A0  30        movb @XX15,rtmp
     9920 0031     
0002 9922 0916  18        srl  rtmp,1
0003 9924 D806  30        movb rtmp,@XX15
     9926 0031     
                   < elite.a99
33916                                                                          ; = normal_x / 2
33917               
33918                      .lsr @XX15+2                    ; LSR XX15+2        ; Set XX15+2 = XX15+2 / 2
     **** ****     > LSR
0001 9928 D1A0  30        movb @XX15+2,rtmp
     992A 0033     
0002 992C 0916  18        srl  rtmp,1
0003 992E D806  30        movb rtmp,@XX15+2
     9930 0033     
                   < elite.a99
33919                                                                          ; = normal_y / 2
33920               
33921 9932 0910  18        srl  ra,1                       ; LSR A             ; Set A = A / 2
33922                                                                          ; = normal_z / 2
33923               
33924 9934 7044  18        sb   rone,rx                    ; DEX               ; Decrement the scale factor in X
33925               
33926 9936 15F2  14        jgt  LL93+3                     ; BPL LL93+3        ; If we have more scaling to do, loop back up to the
33927                                                                          ; first LSR above until the normal vector is scaled down
33928               
33929               LL94:
33930 9938 D800  30        movb ra,@R                      ; STA R             ; Set R = normal_z
     993A 0091     
33931               
33932 993C D020  30        movb @XX12+5,ra                 ; LDA XX12+5        ; Set S = normal_z_sign
     993E 003C     
33933 9940 D800  30        movb ra,@S                      ; STA S
     9942 0092     
33934               
33935 9944 D020  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set Q = dot_nosev_lo
     9946 0084     
33936 9948 D800  30        movb ra,@Q                      ; STA Q
     994A 0090     
33937               
33938 994C D020  30        movb @XX18+8,ra                 ; LDA XX18+8        ; Set A = dot_nosev_sign
     994E 0086     
33939               
33940 9950 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     9952 938E     
33941 9954 06A0  28        bl   @jsr                       ;
     9956 8002     
33942                                                                          ; = normal_z + dot_nosev
33943                                                                          ;
33944                                                                          ; setting the sign of the result in S
33945               
33946 9958 18C5  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
33947                                                                          ; both the normal vector and dot products by 2 and try
33948                                                                          ; again
33949               
33950 995A D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; Set XX15(5 4) = (S A)
     995C 0035     
33951 995E D020  30        movb @S,ra                      ; LDA S             ; = normal_z + dot_nosev
     9960 0092     
33952 9962 D800  30        movb ra,@XX15+5                 ; STA XX15+5
     9964 0036     
33953               
33954 9966 D020  30        movb @XX15,ra                   ; LDA XX15          ; Set R = normal_x
     9968 0031     
33955 996A D800  30        movb ra,@R                      ; STA R
     996C 0091     
33956               
33957 996E D020  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set S = normal_x_sign
     9970 0038     
33958 9972 D800  30        movb ra,@S                      ; STA S
     9974 0092     
33959               
33960 9976 D020  30        movb @XX18,ra                   ; LDA XX18          ; Set Q = dot_sidev_lo
     9978 007E     
33961 997A D800  30        movb ra,@Q                      ; STA Q
     997C 0090     
33962               
33963 997E D020  30        movb @XX18+2,ra                 ; LDA XX18+2        ; Set A = dot_sidev_sign
     9980 0080     
33964               
33965 9982 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     9984 938E     
33966 9986 06A0  28        bl   @jsr                       ;
     9988 8002     
33967                                                                          ; = normal_x + dot_sidev
33968                                                                          ;
33969                                                                          ; setting the sign of the result in S
33970               
33971 998A 18AC  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
33972                                                                          ; both the normal vector and dot products by 2 and try
33973                                                                          ; again
33974               
33975 998C D800  30        movb ra,@XX15                   ; STA XX15          ; Set XX15(1 0) = (S A)
     998E 0031     
33976 9990 D020  30        movb @S,ra                      ; LDA S             ; = normal_x + dot_sidev
     9992 0092     
33977 9994 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     9996 0032     
33978               
33979 9998 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set R = normal_y
     999A 0033     
33980 999C D800  30        movb ra,@R                      ; STA R
     999E 0091     
33981               
33982 99A0 D020  30        movb @XX12+3,ra                 ; LDA XX12+3        ; Set S = normal_y_sign
     99A2 003A     
33983 99A4 D800  30        movb ra,@S                      ; STA S
     99A6 0092     
33984               
33985 99A8 D020  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set Q = dot_roofv_lo
     99AA 0081     
33986 99AC D800  30        movb ra,@Q                      ; STA Q
     99AE 0090     
33987               
33988 99B0 D020  30        movb @XX18+5,ra                 ; LDA XX18+5        ; Set A = dot_roofv_sign
     99B2 0083     
33989               
33990 99B4 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     99B6 938E     
33991 99B8 06A0  28        bl   @jsr                       ;
     99BA 8002     
33992                                                                          ; = normal_y + dot_roofv
33993               
33994 99BC 1893  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
33995                                                                          ; both the normal vector and dot products by 2 and try
33996                                                                          ; again
33997               
33998 99BE D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15(3 2) = (S A)
     99C0 0033     
33999 99C2 D020  30        movb @S,ra                      ; LDA S             ; = normal_y + dot_roofv
     99C4 0092     
34000 99C6 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     99C8 0034     
34001               
34002               LL89:
34003                                                                          ; When we get here, we have set up the following:
34004                                                                          ;
34005                                                                          ; XX15(1 0) = normal_x + dot_sidev
34006                                                                          ; = normal_x + [x y z] . sidev
34007                                                                          ;
34008                                                                          ; XX15(3 2) = normal_y + dot_roofv
34009                                                                          ; = normal_y + [x y z] . roofv
34010                                                                          ;
34011                                                                          ; XX15(5 4) = normal_z + dot_nosev
34012                                                                          ; = normal_z + [x y z] . nosev
34013                                                                          ;
34014                                                                          ; and:
34015                                                                          ;
34016                                                                          ; XX12(1 0) = (normal_x_sign normal_x)
34017                                                                          ;
34018                                                                          ; XX12(3 2) = (normal_y_sign normal_y)
34019                                                                          ;
34020                                                                          ; XX12(5 4) = (normal_z_sign normal_z)
34021                                                                          ;
34022                                                                          ; We now calculate the dot product XX12 . XX15 to tell
34023                                                                          ; us whether or not this face is visible
34024 99CA D020  30        movb @XX12,ra                   ; LDA XX12          ; Set Q = XX12
     99CC 0037     
34025 99CE D800  30        movb ra,@Q                      ; STA Q
     99D0 0090     
34026               
34027 99D2 D020  30        movb @XX15,ra                   ; LDA XX15          ; Set A = XX15
     99D4 0031     
34028               
34029 99D6 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     99D8 4338     
34030 99DA 06A0  28        bl   @jsr                       ;
     99DC 8002     
34031 99DE D800  30        movb ra,@T                      ; STA T             ; = XX15 * XX12 / 256
     99E0 00D1     
34032               
34033 99E2 D020  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set S = sign of XX15(1 0) * XX12(1 0), so:
     99E4 0038     
34034                      .eor @XX15+1                    ; EOR XX15+1        ;
     **** ****     > EOR
0001 99E6 D1A0  30        movb @XX15+1,rtmp
     99E8 0032     
0002 99EA 2806  18        xor  rtmp,ra
                   < elite.a99
34035 99EC D800  30        movb ra,@S                      ; STA S             ; (S T) = XX15(1 0) * XX12(1 0) / 256
     99EE 0092     
34036               
34037 99F0 D020  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set Q = XX12+2
     99F2 0039     
34038 99F4 D800  30        movb ra,@Q                      ; STA Q
     99F6 0090     
34039               
34040 99F8 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set A = XX15+2
     99FA 0033     
34041               
34042 99FC 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q
     99FE 4338     
34043 9A00 06A0  28        bl   @jsr                       ;
     9A02 8002     
34044 9A04 D800  30        movb ra,@Q                      ; STA Q             ; = XX15+2 * XX12+2 / 256
     9A06 0090     
34045               
34046 9A08 D020  30        movb @T,ra                      ; LDA T             ; Set T = R, so now:
     9A0A 00D1     
34047 9A0C D800  30        movb ra,@R                      ; STA R             ;
     9A0E 0091     
34048                                                                          ; (S R) = XX15(1 0) * XX12(1 0) / 256
34049               
34050 9A10 D020  30        movb @XX12+3,ra                 ; LDA XX12+3        ; Set A = sign of XX15+3 * XX12+3, so:
     9A12 003A     
34051                      .eor @XX15+3                    ; EOR XX15+3        ;
     **** ****     > EOR
0001 9A14 D1A0  30        movb @XX15+3,rtmp
     9A16 0034     
0002 9A18 2806  18        xor  rtmp,ra
                   < elite.a99
34052                                                                          ; (A Q) = XX15(3 2) * XX12(3 2) / 256
34053               
34054 9A1A 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S T) = (S R) + (A Q)
     9A1C 938E     
34055 9A1E 06A0  28        bl   @jsr                       ;
     9A20 8002     
34056 9A22 D800  30        movb ra,@T                      ; STA T             ; =   XX15(1 0) * XX12(1 0) / 256
     9A24 00D1     
34057                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34058               
34059 9A26 D020  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set Q = XX12+4
     9A28 003B     
34060 9A2A D800  30        movb ra,@Q                      ; STA Q
     9A2C 0090     
34061               
34062 9A2E D020  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set A = XX15+4
     9A30 0035     
34063               
34064 9A32 0206  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q
     9A34 4338     
34065 9A36 06A0  28        bl   @jsr                       ;
     9A38 8002     
34066 9A3A D800  30        movb ra,@Q                      ; STA Q             ; = XX15+4 * XX12+4 / 256
     9A3C 0090     
34067               
34068 9A3E D020  30        movb @T,ra                      ; LDA T             ; Set T = R, so now:
     9A40 00D1     
34069 9A42 D800  30        movb ra,@R                      ; STA R             ;
     9A44 0091     
34070                                                                          ; (S R) =   XX15(1 0) * XX12(1 0) / 256
34071                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34072               
34073 9A46 D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A = sign of XX15+5 * XX12+5, so:
     9A48 0036     
34074                      .eor @XX12+5                    ; EOR XX12+5        ;
     **** ****     > EOR
0001 9A4A D1A0  30        movb @XX12+5,rtmp
     9A4C 003C     
0002 9A4E 2806  18        xor  rtmp,ra
                   < elite.a99
34075                                                                          ; (A Q) = XX15(5 4) * XX12(5 4) / 256
34076               
34077 9A50 0206  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     9A52 938E     
34078 9A54 06A0  28        bl   @jsr                       ;
     9A56 8002     
34079                                                                          ; =   XX15(1 0) * XX12(1 0) / 256
34080                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34081                                                                          ; + XX15(5 4) * XX12(5 4) / 256
34082               
34083                      .pha                            ; PHA               ; Push the result A onto the stack, so the stack now
     **** ****     > PHA
0001 9A58 D680  30        movb ra,*rsp
0002 9A5A 060A  14        dec  rsp
                   < elite.a99
34084                                                                          ; contains the dot product XX12 . XX15
34085               
34086 9A5C D002  18        movb ry,ra                      ; TYA               ; Set X = Y / 4
34087 9A5E 0910  18        srl  ra,1                       ; LSR A             ; = the number of this face * 4 /4
34088 9A60 0910  18        srl  ra,1                       ; LSR A             ; = the number of this face
34089 9A62 D040  18        movb ra,rx                      ; TAX
34090               
34091                      .pla                            ; PLA               ; Pull the dot product off the stack into A
     **** ****     > PLA
0001 9A64 058A  14        inc  rsp
0002 9A66 D01A  26        movb *rsp,ra
                   < elite.a99
34092               
34093                      .bit @S                         ; BIT S             ; If bit 7 of S is set, i.e. the dot product is
     **** ****     > BIT
0001 9A68 D1A0  30        movb @S,rtmp
     9A6A 0092     
0002 9A6C 0546  14        inv  rtmp
0003 9A6E D1C4  18        movb rone,rtmp2
0004 9A70 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
34094 9A72 1102  14        jlt  B112                       ; BMI B112          ; negative, then this face is visible as its normal is
34095                                                                          ; pointing towards us, so skip the following instruction
34096               
34097 9A74 0200  20        li   ra,>00*256                 ; LDA #0            ; Otherwise the face is not visible, so set A = 0 so we
     9A76 0000     
34098                                                                          ; can store this to mean "not visible"
34099               
34100               B112:
34101 9A78 D840  38        movb ra,@XX2(rx)                ; STA XX2,X         ; Store the face's visibility in the X-th byte of XX2
     9A7A 00D2     
34102               
34103 9A7C B084  18        ab   rone,ry                    ; INY               ; Above we incremented Y to point to byte #3, so this
34104                                                                          ; increments Y to point to byte #4, i.e. byte #0 of the
34105                                                                          ; next face
34106               
34107               LL88:
34108 9A7E 90A0  30        cb   @XX20,ry                   ; CPY XX20          ; If Y >= XX20, the number of faces * 4, jump down to
     9A80 00A8     
34109 9A82 1802  14        joc  LL42                       ; BCS LL42          ; LL42 to move on to the
34110               
34111 9A84 0460  28        b    @LL86                      ; JMP LL86          ; Otherwise loop back to LL86 to work out the visibility
     9A86 9816     
34112                                                                          ; of the next face
34113               
34114               * ******************************************************************************
34115               *
34116               * Name: LL9 (Part 6 of 12)
34117               * Type: Subroutine
34118               * Category: Drawing ships
34119               * Summary: Draw ship: Calculate the visibility of each of the ship's vertices
34120               * Deep dive: Drawing ships
34121               * Calculating vertex coordinates
34122               *
34123               * ------------------------------------------------------------------------------
34124               *
34125               * This section calculates the visibility of each of the ship's vertices, and for
34126               * those that are visible, it starts the process of calculating the screen
34127               * coordinates of each vertex
34128               *
34129               * ******************************************************************************
34130               
34131               LL42:
34132                                                                          ; The first task is to set up the inverse matrix, ready
34133                                                                          ; for us to send to the dot product routine at LL51.
34134                                                                          ; Back up in part 3, we set up the following variables:
34135                                                                          ;
34136                                                                          ; * XX16(1 0) = sidev_x
34137                                                                          ; * XX16(3 2) = sidev_y
34138                                                                          ; * XX16(5 4) = sidev_z
34139                                                                          ;
34140                                                                          ; * XX16(7 6) = roofv_x
34141                                                                          ; * XX16(9 8) = roofv_y
34142                                                                          ; * XX16(11 10) = roofv_z
34143                                                                          ;
34144                                                                          ; * XX16(13 12) = nosev_x
34145                                                                          ; * XX16(15 14) = nosev_y
34146                                                                          ; * XX16(17 16) = nosev_z
34147                                                                          ;
34148                                                                          ; and we then scaled the vectors to give the following:
34149                                                                          ;
34150                                                                          ; * XX16   = scaled |sidev_x|
34151                                                                          ; * XX16+2 = scaled |sidev_y|
34152                                                                          ; * XX16+4 = scaled |sidev_z|
34153                                                                          ;
34154                                                                          ; * XX16+6  = scaled |roofv_x|
34155                                                                          ; * XX16+8  = scaled |roofv_y|
34156                                                                          ; * XX16+10 = scaled |roofv_z|
34157                                                                          ;
34158                                                                          ; * XX16+12 = scaled |nosev_x|
34159                                                                          ; * XX16+14 = scaled |nosev_y|
34160                                                                          ; * XX16+16 = scaled |nosev_z|
34161                                                                          ;
34162                                                                          ; We now need to rearrange these locations so they
34163                                                                          ; effectively transpose the matrix into its inverse
34164 9A88 D0A0  30        movb @XX16+2,ry                 ; LDY XX16+2        ; Set XX16+2 = XX16+6 = scaled |roofv_x|
     9A8A 000B     
34165 9A8C D060  30        movb @XX16+3,rx                 ; LDX XX16+3        ; Set XX16+3 = XX16+7 = roofv_x_hi
     9A8E 000C     
34166 9A90 D020  30        movb @XX16+6,ra                 ; LDA XX16+6        ; Set XX16+6 = XX16+2 = scaled |sidev_y|
     9A92 000F     
34167 9A94 D800  30        movb ra,@XX16+2                 ; STA XX16+2        ; Set XX16+7 = XX16+3 = sidev_y_hi
     9A96 000B     
34168 9A98 D020  30        movb @XX16+7,ra                 ; LDA XX16+7
     9A9A 0010     
34169 9A9C D800  30        movb ra,@XX16+3                 ; STA XX16+3
     9A9E 000C     
34170 9AA0 D802  30        movb ry,@XX16+6                 ; STY XX16+6
     9AA2 000F     
34171 9AA4 D801  30        movb rx,@XX16+7                 ; STX XX16+7
     9AA6 0010     
34172               
34173 9AA8 D0A0  30        movb @XX16+4,ry                 ; LDY XX16+4        ; Set XX16+4 = XX16+12 = scaled |nosev_x|
     9AAA 000D     
34174 9AAC D060  30        movb @XX16+5,rx                 ; LDX XX16+5        ; Set XX16+5 = XX16+13 = nosev_x_hi
     9AAE 000E     
34175 9AB0 D020  30        movb @XX16+12,ra                ; LDA XX16+12       ; Set XX16+12 = XX16+4 = scaled |sidev_z|
     9AB2 0015     
34176 9AB4 D800  30        movb ra,@XX16+4                 ; STA XX16+4        ; Set XX16+13 = XX16+5 = sidev_z_hi
     9AB6 000D     
34177 9AB8 D020  30        movb @XX16+13,ra                ; LDA XX16+13
     9ABA 0016     
34178 9ABC D800  30        movb ra,@XX16+5                 ; STA XX16+5
     9ABE 000E     
34179 9AC0 D802  30        movb ry,@XX16+12                ; STY XX16+12
     9AC2 0015     
34180 9AC4 D801  30        movb rx,@XX16+13                ; STX XX16+13
     9AC6 0016     
34181               
34182 9AC8 D0A0  30        movb @XX16+10,ry                ; LDY XX16+10       ; Set XX16+10 = XX16+14 = scaled |nosev_y|
     9ACA 0013     
34183 9ACC D060  30        movb @XX16+11,rx                ; LDX XX16+11       ; Set XX16+11 = XX16+15 = nosev_y_hi
     9ACE 0014     
34184 9AD0 D020  30        movb @XX16+14,ra                ; LDA XX16+14       ; Set XX16+14 = XX16+10 = scaled |roofv_z|
     9AD2 0017     
34185 9AD4 D800  30        movb ra,@XX16+10                ; STA XX16+10       ; Set XX16+15 = XX16+11 = roofv_z
     9AD6 0013     
34186 9AD8 D020  30        movb @XX16+15,ra                ; LDA XX16+15
     9ADA 0018     
34187 9ADC D800  30        movb ra,@XX16+11                ; STA XX16+11
     9ADE 0014     
34188 9AE0 D802  30        movb ry,@XX16+14                ; STY XX16+14
     9AE2 0017     
34189 9AE4 D801  30        movb rx,@XX16+15                ; STX XX16+15
     9AE6 0018     
34190               
34191                                                                          ; So now we have the following sign-magnitude variables
34192                                                                          ; containing parts of the scaled orientation vectors:
34193                                                                          ;
34194                                                                          ; XX16(1 0)   = scaled sidev_x
34195                                                                          ; XX16(3 2)   = scaled roofv_x
34196                                                                          ; XX16(5 4)   = scaled nosev_x
34197                                                                          ;
34198                                                                          ; XX16(7 6)   = scaled sidev_y
34199                                                                          ; XX16(9 8)   = scaled roofv_y
34200                                                                          ; XX16(11 10) = scaled nosev_y
34201                                                                          ;
34202                                                                          ; XX16(13 12) = scaled sidev_z
34203                                                                          ; XX16(15 14) = scaled roofv_z
34204                                                                          ; XX16(17 16) = scaled nosev_z
34205                                                                          ;
34206                                                                          ; which is what we want, as the various vectors are now
34207                                                                          ; arranged so we can use LL51 to multiply by the
34208                                                                          ; transpose (i.e. the inverse of the matrix)
34209               
34210 9AE8 0202  20        li   ry,>08*256                 ; LDY #8            ; Fetch byte #8 of the ship's blueprint, which is the
     9AEA 0800     
34211                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of vertices * 8, and store it in XX20
     **** ****     > LD_IND_Y_IDX
0001 9AEC D820  42        movb @XX0,@rtmplb
     9AEE 001E     
     9AF0 830D     
0002 9AF2 D1A0  30        movb @XX0+1,rtmp
     9AF4 001F     
0003 9AF6 A182  18        a    ry,rtmp
0004 9AF8 D016  26        movb *rtmp,RA
                   < elite.a99
34212 9AFA D800  30        movb ra,@XX20                   ; STA XX20
     9AFC 00A8     
34213               
34214                                                                          ; We now set V(1 0) = XX0(1 0) + 20, so V(1 0) points
34215                                                                          ; to byte #20 of the ship's blueprint, which is always
34216                                                                          ; where the vertex data starts (i.e. just after the 20
34217                                                                          ; byte block that define the ship's characteristics)
34218               
34219 9AFE D020  30        movb @XX0,ra                    ; LDA XX0           ; We start with the low bytes
     9B00 001E     
34220                      .clc                            ; CLC
     **** ****     > CLC
0001 9B02 0A13  18        sla  rzero,1
                   < elite.a99
34221                      .adi (>14*256)                  ; ADC #20
     **** ****     > ADI
0001 9B04 1701  14        jnc  !
0002 9B06 B004  18        ab   rone,ra
0003               !:
0004 9B08 0220  22        ai   ra,(>14*256)
     9B0A 1400     
                   < elite.a99
34222 9B0C D800  30        movb ra,@V                      ; STA V
     9B0E 0022     
34223               
34224 9B10 D020  30        movb @XX0+1,ra                  ; LDA XX0+1         ; And then do the high bytes
     9B12 001F     
34225                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 9B14 1701  14        jnc  !
0002 9B16 B004  18        ab   rone,ra
0003               !:
0004 9B18 0220  22        ai   ra,(>00*256)
     9B1A 0000     
                   < elite.a99
34226 9B1C D800  30        movb ra,@V+1                    ; STA V+1
     9B1E 0023     
34227               
34228 9B20 0202  20        li   ry,>00*256                 ; LDY #0            ; We are about to step through all the vertices, using
     9B22 0000     
34229                                                                          ; Y as a counter. There are six data bytes for each
34230                                                                          ; vertex, so we will increment Y by 6 for each iteration
34231                                                                          ; so it can act as an offset from V(1 0) to the current
34232                                                                          ; vertex's data
34233               
34234 9B24 D802  30        movb ry,@CNT                    ; STY CNT           ; Set CNT = 0, which we will use as a pointer to the
     9B26 00A4     
34235                                                                          ; heap at XX3, starting it at zero so the heap starts
34236                                                                          ; out empty
34237               
34238               LL48:
34239 9B28 D802  30        movb ry,@XX17                   ; STY XX17          ; Set XX17 = Y, so XX17 now contains the offset of the
     9B2A 0095     
34240                                                                          ; current vertex's data
34241               
34242                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this vertex into XX15, so:
     **** ****     > LD_IND_Y_IDX
0001 9B2C D820  42        movb @V,@rtmplb
     9B2E 0022     
     9B30 830D     
0002 9B32 D1A0  30        movb @V+1,rtmp
     9B34 0023     
0003 9B36 A182  18        a    ry,rtmp
0004 9B38 D016  26        movb *rtmp,RA
                   < elite.a99
34243 9B3A D800  30        movb ra,@XX15                   ; STA XX15          ;
     9B3C 0031     
34244                                                                          ; XX15 = magnitude of the vertex's x-coordinate
34245               
34246 9B3E B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
34247               
34248                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this vertex into XX15+2, so:
     **** ****     > LD_IND_Y_IDX
0001 9B40 D820  42        movb @V,@rtmplb
     9B42 0022     
     9B44 830D     
0002 9B46 D1A0  30        movb @V+1,rtmp
     9B48 0023     
0003 9B4A A182  18        a    ry,rtmp
0004 9B4C D016  26        movb *rtmp,RA
                   < elite.a99
34249 9B4E D800  30        movb ra,@XX15+2                 ; STA XX15+2        ;
     9B50 0033     
34250                                                                          ; XX15+2 = magnitude of the vertex's y-coordinate
34251               
34252 9B52 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
34253               
34254                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this vertex into XX15+4, so:
     **** ****     > LD_IND_Y_IDX
0001 9B54 D820  42        movb @V,@rtmplb
     9B56 0022     
     9B58 830D     
0002 9B5A D1A0  30        movb @V+1,rtmp
     9B5C 0023     
0003 9B5E A182  18        a    ry,rtmp
0004 9B60 D016  26        movb *rtmp,RA
                   < elite.a99
34255 9B62 D800  30        movb ra,@XX15+4                 ; STA XX15+4        ;
     9B64 0035     
34256                                                                          ; XX15+4 = magnitude of the vertex's z-coordinate
34257               
34258 9B66 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
34259               
34260                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this vertex into T, so:
     **** ****     > LD_IND_Y_IDX
0001 9B68 D820  42        movb @V,@rtmplb
     9B6A 0022     
     9B6C 830D     
0002 9B6E D1A0  30        movb @V+1,rtmp
     9B70 0023     
0003 9B72 A182  18        a    ry,rtmp
0004 9B74 D016  26        movb *rtmp,RA
                   < elite.a99
34261 9B76 D800  30        movb ra,@T                      ; STA T             ;
     9B78 00D1     
34262                                                                          ; T = %xyz vvvvv, where:
34263                                                                          ;
34264                                                                          ; * Bits 0-4 = visibility distance, beyond which the
34265                                                                          ; vertex is not shown
34266                                                                          ;
34267                                                                          ; * Bits 7-5 = the sign bits of x, y and z
34268               
34269 9B7A 0240  22        andi ra,>1f*256                 ; AND #%00011111    ; Extract bits 0-4 to get the visibility distance
     9B7C 1F00     
34270               
34271 9B7E 9020  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 > the visibility distance, where XX4 contains
     9B80 00A7     
34272 9B82 1734  14        jnc  LL49-3                     ; BCC LL49-3        ; the ship's z-distance reduced to 0-31 (which we set in
34273                                                                          ; part 2), then this vertex is too far away to be
34274                                                                          ; visible, so jump down to LL50 (via the JMP instruction
34275                                                                          ; in LL49-3) to move on to the next vertex
34276               
34277 9B84 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #4
34278               
34279                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #4 for this vertex into P, so:
     **** ****     > LD_IND_Y_IDX
0001 9B86 D820  42        movb @V,@rtmplb
     9B88 0022     
     9B8A 830D     
0002 9B8C D1A0  30        movb @V+1,rtmp
     9B8E 0023     
0003 9B90 A182  18        a    ry,rtmp
0004 9B92 D016  26        movb *rtmp,RA
                   < elite.a99
34280 9B94 D800  30        movb ra,@P                      ; STA P             ;
     9B96 001B     
34281                                                                          ; P = %ffff ffff, where:
34282                                                                          ;
34283                                                                          ; * Bits 0-3 = the number of face 1
34284                                                                          ;
34285                                                                          ; * Bits 4-7 = the number of face 2
34286               
34287 9B98 0240  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     9B9A 0F00     
34288 9B9C D040  18        movb ra,rx                      ; TAX
34289               
34290 9B9E D021  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     9BA0 00D2     
34291 9BA2 1626  14        jne  LL49                       ; BNE LL49          ; face 1 is visible, so jump to LL49
34292               
34293 9BA4 D020  30        movb @P,ra                      ; LDA P             ; Fetch byte #4 for this vertex into A
     9BA6 001B     
34294               
34295 9BA8 0910  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 2
34296 9BAA 0910  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
34297 9BAC 0910  18        srl  ra,1                       ; LSR A
34298 9BAE 0910  18        srl  ra,1                       ; LSR A
34299 9BB0 D040  18        movb ra,rx                      ; TAX
34300               
34301 9BB2 D021  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     9BB4 00D2     
34302 9BB6 161C  14        jne  LL49                       ; BNE LL49          ; face 2 is visible, so jump to LL49
34303               
34304 9BB8 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #5
34305               
34306                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #5 for this vertex into P, so:
     **** ****     > LD_IND_Y_IDX
0001 9BBA D820  42        movb @V,@rtmplb
     9BBC 0022     
     9BBE 830D     
0002 9BC0 D1A0  30        movb @V+1,rtmp
     9BC2 0023     
0003 9BC4 A182  18        a    ry,rtmp
0004 9BC6 D016  26        movb *rtmp,RA
                   < elite.a99
34307 9BC8 D800  30        movb ra,@P                      ; STA P             ;
     9BCA 001B     
34308                                                                          ; P = %ffff ffff, where:
34309                                                                          ;
34310                                                                          ; * Bits 0-3 = the number of face 3
34311                                                                          ;
34312                                                                          ; * Bits 4-7 = the number of face 4
34313               
34314 9BCC 0240  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     9BCE 0F00     
34315 9BD0 D040  18        movb ra,rx                      ; TAX
34316               
34317 9BD2 D021  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     9BD4 00D2     
34318 9BD6 160C  14        jne  LL49                       ; BNE LL49          ; face 3 is visible, so jump to LL49
34319               
34320 9BD8 D020  30        movb @P,ra                      ; LDA P             ; Fetch byte #5 for this vertex into A
     9BDA 001B     
34321               
34322 9BDC 0910  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 4
34323 9BDE 0910  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
34324 9BE0 0910  18        srl  ra,1                       ; LSR A
34325 9BE2 0910  18        srl  ra,1                       ; LSR A
34326 9BE4 D040  18        movb ra,rx                      ; TAX
34327               
34328 9BE6 D021  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     9BE8 00D2     
34329 9BEA 1602  14        jne  LL49                       ; BNE LL49          ; face 4 is visible, so jump to LL49
34330               
34331 9BEC 0460  28        b    @LL50                      ; JMP LL50          ; If we get here then none of the four faces associated
     9BEE 9F38     
34332                                                                          ; with this vertex are visible, so this vertex is also
34333                                                                          ; not visible, so jump to LL50 to move on to the next
34334                                                                          ; vertex
34335               
34336               LL49:
34337 9BF0 D020  30        movb @T,ra                      ; LDA T             ; Fetch byte #5 for this vertex into A and store it, so
     9BF2 00D1     
34338 9BF4 D800  30        movb ra,@XX15+1                 ; STA XX15+1        ; XX15+1 now has the sign of the vertex's x-coordinate
     9BF6 0032     
34339               
34340                      .asla                           ; ASL A             ; Shift A left and store it, so XX15+3 now has the sign
     **** ****     > ASLA
0001 9BF8 0240  22        andi ra,>ff00
     9BFA FF00     
0002 9BFC 0A10  18        sla  ra,1
                   < elite.a99
34341 9BFE D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; of the vertex's y-coordinate
     9C00 0034     
34342               
34343                      .asla                           ; ASL A             ; Shift A left and store it, so XX15+5 now has the sign
     **** ****     > ASLA
0001 9C02 0240  22        andi ra,>ff00
     9C04 FF00     
0002 9C06 0A10  18        sla  ra,1
                   < elite.a99
34344 9C08 D800  30        movb ra,@XX15+5                 ; STA XX15+5        ; of the vertex's z-coordinate
     9C0A 0036     
34345               
34346                                                                          ; By this point we have the following:
34347                                                                          ;
34348                                                                          ; XX15(1 0) = vertex x-coordinate
34349                                                                          ; XX15(3 2) = vertex y-coordinate
34350                                                                          ; XX15(5 4) = vertex z-coordinate
34351                                                                          ;
34352                                                                          ; XX16(1 0)   = scaled sidev_x
34353                                                                          ; XX16(3 2)   = scaled roofv_x
34354                                                                          ; XX16(5 4)   = scaled nosev_x
34355                                                                          ;
34356                                                                          ; XX16(7 6)   = scaled sidev_y
34357                                                                          ; XX16(9 8)   = scaled roofv_y
34358                                                                          ; XX16(11 10) = scaled nosev_y
34359                                                                          ;
34360                                                                          ; XX16(13 12) = scaled sidev_z
34361                                                                          ; XX16(15 14) = scaled roofv_z
34362                                                                          ; XX16(17 16) = scaled nosev_z
34363               
34364 9C0C 0206  20        li   rtmp,LL51                  ; JSR LL51          ; Call LL51 to set XX12 to the dot products of XX15 and
     9C0E 93E6     
34365 9C10 06A0  28        bl   @jsr                       ;
     9C12 8002     
34366                                                                          ; XX16, as follows:
34367                                                                          ;
34368                                                                          ; XX12(1 0) = [ x y z ] . [ sidev_x roofv_x nosev_x ]
34369                                                                          ;
34370                                                                          ; XX12(3 2) = [ x y z ] . [ sidev_y roofv_y nosev_y ]
34371                                                                          ;
34372                                                                          ; XX12(5 4) = [ x y z ] . [ sidev_z roofv_z nosev_z ]
34373                                                                          ;
34374                                                                          ; XX12 contains the vector from the ship's centre to
34375                                                                          ; the vertex, transformed from the orientation vector
34376                                                                          ; space to the universe orientated around our ship. So
34377                                                                          ; we can refer to this vector below, let's call it
34378                                                                          ; vertv, so:
34379                                                                          ;
34380                                                                          ; vertv_x = [ x y z ] . [ sidev_x roofv_x nosev_x ]
34381                                                                          ;
34382                                                                          ; vertv_y = [ x y z ] . [ sidev_y roofv_y nosev_y ]
34383                                                                          ;
34384                                                                          ; vertv_z = [ x y z ] . [ sidev_z roofv_z nosev_z ]
34385                                                                          ;
34386                                                                          ; To finish the calculation, we now want to calculate:
34387                                                                          ;
34388                                                                          ; vertv + [ x y z ]
34389                                                                          ;
34390                                                                          ; So let's start with the vertv_x + x
34391               
34392 9C14 D020  30        movb @XX1+2,ra                  ; LDA XX1+2         ; Set A = x_sign of the ship's location
     9C16 0055     
34393               
34394 9C18 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 = x_sign
     9C1A 0033     
34395               
34396                      .eor @XX12+1                    ; EOR XX12+1        ; If the sign of x_sign * the sign of vertv_x is
     **** ****     > EOR
0001 9C1C D1A0  30        movb @XX12+1,rtmp
     9C1E 0038     
0002 9C20 2806  18        xor  rtmp,ra
                   < elite.a99
34397 9C22 1113  14        jlt  LL52                       ; BMI LL52          ; negative (i.e. they have different signs), skip to
34398                                                                          ; LL52
34399               
34400                      .clc                            ; CLC               ; Set XX15(2 1 0) = XX1(2 1 0) + XX12(1 0)
     **** ****     > CLC
0001 9C24 0A13  18        sla  rzero,1
                   < elite.a99
34401 9C26 D020  30        movb @XX12,ra                   ; LDA XX12          ; = (x_sign x_hi x_lo) + vertv_x
     9C28 0037     
34402                      .adc @XX1,ra                    ; ADC XX1           ;
     **** ****     > ADC
0001 9C2A 1701  14        jnc  !
0002 9C2C B004  18        ab   rone,ra
0003               !:
0004 9C2E B020  30        ab   @XX1,ra
     9C30 0053     
                   < elite.a99
34403 9C32 D800  30        movb ra,@XX15                   ; STA XX15          ; Starting with the low bytes
     9C34 0031     
34404               
34405 9C36 D020  30        movb @XX1+1,ra                  ; LDA XX1+1         ; And then doing the high bytes (we can add 0 here as
     9C38 0054     
34406                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_x is 0)
     **** ****     > ADI
0001 9C3A 1701  14        jnc  !
0002 9C3C B004  18        ab   rone,ra
0003               !:
0004 9C3E 0220  22        ai   ra,(>00*256)
     9C40 0000     
                   < elite.a99
34407 9C42 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     9C44 0032     
34408               
34409 9C46 0460  28        b    @LL53                      ; JMP LL53          ; We've added the x-coordinates, so jump to LL53 to do
     9C48 9C9A     
34410                                                                          ; the y-coordinates
34411               
34412               LL52:
34413                                                                          ; If we get here then x_sign and vertv_x have different
34414                                                                          ; signs, so we need to subtract them to get the result
34415 9C4A D020  30        movb @XX1,ra                    ; LDA XX1           ; Set XX15(2 1 0) = XX1(2 1 0) - XX12(1 0)
     9C4C 0053     
34416                      .sec                            ; SEC               ; = (x_sign x_hi x_lo) - vertv_x
     **** ****     > SEC
0001 9C4E 0A15  18        sla  rmone,1
                   < elite.a99
34417                      .sbc @XX12,ra                   ; SBC XX12          ;
     **** ****     > SBC
0001 9C50 1801  14        joc  !
0002 9C52 7004  18        sb   rone,ra
0003               !:
0004 9C54 7020  30        sb   @XX12,ra
     9C56 0037     
                   < elite.a99
34418 9C58 D800  30        movb ra,@XX15                   ; STA XX15          ; Starting with the low bytes
     9C5A 0031     
34419               
34420 9C5C D020  30        movb @XX1+1,ra                  ; LDA XX1+1         ; And then doing the high bytes (we can subtract 0 here
     9C5E 0054     
34421                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_x is 0)
     **** ****     > SBI
0001 9C60 1801  14        joc  !
0002 9C62 7004  18        sb   rone,ra
0003               !:
0004 9C64 0220  22        ai   ra,-(>00*256)
     9C66 0000     
                   < elite.a99
34422 9C68 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     9C6A 0032     
34423               
34424 9C6C 1816  14        joc  LL53                       ; BCS LL53          ; If the subtraction didn't underflow, then the sign of
34425                                                                          ; the result is the same sign as x_sign, and that's what
34426                                                                          ; we want, so we can jump down to LL53 to do the
34427                                                                          ; y-coordinates
34428               
34429                      .eoi (>ff*256)                  ; EOR #%11111111    ; Otherwise we need to negate the result using two's
     **** ****     > EOI
0001 9C6E 0206  20        li   rtmp,(>FF*256)
     9C70 FF00     
0002 9C72 2806  18        xor  rtmp,ra
                   < elite.a99
34430 9C74 D800  30        movb ra,@XX15+1                 ; STA XX15+1        ; complement, so first we flip the bits of the high byte
     9C76 0032     
34431               
34432 9C78 0200  20        li   ra,>01*256                 ; LDA #1            ; And then subtract the low byte from 1
     9C7A 0100     
34433                      .sbc @XX15,ra                   ; SBC XX15
     **** ****     > SBC
0001 9C7C 1801  14        joc  !
0002 9C7E 7004  18        sb   rone,ra
0003               !:
0004 9C80 7020  30        sb   @XX15,ra
     9C82 0031     
                   < elite.a99
34434 9C84 D800  30        movb ra,@XX15                   ; STA XX15
     9C86 0031     
34435               
34436 9C88 1701  14        jnc  B113                       ; BCC B113          ; If the above subtraction underflowed then we need to
34437 9C8A B004  18        ab   rone,ra                    ; INC XX15+1        ; bump the high byte of the result up by 1
34438               
34439               B113:
34440 9C8C D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; And now we flip the sign of the result to get the
     9C8E 0033     
34441                      .eoi (>80*256)                  ; EOR #%10000000    ; correct result
     **** ****     > EOI
0001 9C90 0206  20        li   rtmp,(>80*256)
     9C92 8000     
0002 9C94 2806  18        xor  rtmp,ra
                   < elite.a99
34442 9C96 D800  30        movb ra,@XX15+2                 ; STA XX15+2
     9C98 0033     
34443               
34444               LL53:
34445                                                                          ; Now for the y-coordinates, vertv_y + y
34446 9C9A D020  30        movb @XX1+5,ra                  ; LDA XX1+5         ; Set A = y_sign of the ship's location
     9C9C 0058     
34447               
34448 9C9E D800  30        movb ra,@XX15+5                 ; STA XX15+5        ; Set XX15+5 = y_sign
     9CA0 0036     
34449               
34450                      .eor @XX12+3                    ; EOR XX12+3        ; If the sign of y_sign * the sign of vertv_y is
     **** ****     > EOR
0001 9CA2 D1A0  30        movb @XX12+3,rtmp
     9CA4 003A     
0002 9CA6 2806  18        xor  rtmp,ra
                   < elite.a99
34451 9CA8 1113  14        jlt  LL54                       ; BMI LL54          ; negative (i.e. they have different signs), skip to
34452                                                                          ; LL54
34453               
34454                      .clc                            ; CLC               ; Set XX15(5 4 3) = XX1(5 4 3) + XX12(3 2)
     **** ****     > CLC
0001 9CAA 0A13  18        sla  rzero,1
                   < elite.a99
34455 9CAC D020  30        movb @XX12+2,ra                 ; LDA XX12+2        ; = (y_sign y_hi y_lo) + vertv_y
     9CAE 0039     
34456                      .adc @XX1+3,ra                  ; ADC XX1+3         ;
     **** ****     > ADC
0001 9CB0 1701  14        jnc  !
0002 9CB2 B004  18        ab   rone,ra
0003               !:
0004 9CB4 B020  30        ab   @XX1+3,ra
     9CB6 0056     
                   < elite.a99
34457 9CB8 D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; Starting with the low bytes
     9CBA 0034     
34458               
34459 9CBC D020  30        movb @XX1+4,ra                  ; LDA XX1+4         ; And then doing the high bytes (we can add 0 here as
     9CBE 0057     
34460                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_y is 0)
     **** ****     > ADI
0001 9CC0 1701  14        jnc  !
0002 9CC2 B004  18        ab   rone,ra
0003               !:
0004 9CC4 0220  22        ai   ra,(>00*256)
     9CC6 0000     
                   < elite.a99
34461 9CC8 D800  30        movb ra,@XX15+4                 ; STA XX15+4
     9CCA 0035     
34462               
34463 9CCC 0460  28        b    @LL55                      ; JMP LL55          ; We've added the y-coordinates, so jump to LL55 to do
     9CCE 9D26     
34464                                                                          ; the z-coordinates
34465               
34466               LL54:
34467                                                                          ; If we get here then y_sign and vertv_y have different
34468                                                                          ; signs, so we need to subtract them to get the result
34469 9CD0 D020  30        movb @XX1+3,ra                  ; LDA XX1+3         ; Set XX15(5 4 3) = XX1(5 4 3) - XX12(3 2)
     9CD2 0056     
34470                      .sec                            ; SEC               ; = (y_sign y_hi y_lo) - vertv_y
     **** ****     > SEC
0001 9CD4 0A15  18        sla  rmone,1
                   < elite.a99
34471                      .sbc @XX12+2,ra                 ; SBC XX12+2        ;
     **** ****     > SBC
0001 9CD6 1801  14        joc  !
0002 9CD8 7004  18        sb   rone,ra
0003               !:
0004 9CDA 7020  30        sb   @XX12+2,ra
     9CDC 0039     
                   < elite.a99
34472 9CDE D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; Starting with the low bytes
     9CE0 0034     
34473               
34474 9CE2 D020  30        movb @XX1+4,ra                  ; LDA XX1+4         ; And then doing the high bytes (we can subtract 0 here
     9CE4 0057     
34475                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_z is 0)
     **** ****     > SBI
0001 9CE6 1801  14        joc  !
0002 9CE8 7004  18        sb   rone,ra
0003               !:
0004 9CEA 0220  22        ai   ra,-(>00*256)
     9CEC 0000     
                   < elite.a99
34476 9CEE D800  30        movb ra,@XX15+4                 ; STA XX15+4
     9CF0 0035     
34477               
34478 9CF2 1819  14        joc  LL55                       ; BCS LL55          ; If the subtraction didn't underflow, then the sign of
34479                                                                          ; the result is the same sign as y_sign, and that's what
34480                                                                          ; we want, so we can jump down to LL55 to do the
34481                                                                          ; z-coordinates
34482               
34483                      .eoi (>ff*256)                  ; EOR #%11111111    ; Otherwise we need to negate the result using two's
     **** ****     > EOI
0001 9CF4 0206  20        li   rtmp,(>FF*256)
     9CF6 FF00     
0002 9CF8 2806  18        xor  rtmp,ra
                   < elite.a99
34484 9CFA D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; complement, so first we flip the bits of the high byte
     9CFC 0035     
34485               
34486 9CFE D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; And then flip the bits of the low byte and add 1
     9D00 0034     
34487                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 9D02 0206  20        li   rtmp,(>FF*256)
     9D04 FF00     
0002 9D06 2806  18        xor  rtmp,ra
                   < elite.a99
34488                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 9D08 1701  14        jnc  !
0002 9D0A B004  18        ab   rone,ra
0003               !:
0004 9D0C 0220  22        ai   ra,(>01*256)
     9D0E 0100     
                   < elite.a99
34489 9D10 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     9D12 0034     
34490               
34491 9D14 D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; And now we flip the sign of the result to get the
     9D16 0036     
34492                      .eoi (>80*256)                  ; EOR #%10000000    ; correct result
     **** ****     > EOI
0001 9D18 0206  20        li   rtmp,(>80*256)
     9D1A 8000     
0002 9D1C 2806  18        xor  rtmp,ra
                   < elite.a99
34493 9D1E D800  30        movb ra,@XX15+5                 ; STA XX15+5
     9D20 0036     
34494               
34495 9D22 1701  14        jnc  LL55                       ; BCC LL55          ; If the above subtraction underflowed then we need to
34496 9D24 B004  18        ab   rone,ra                    ; INC XX15+4        ; bump the high byte of the result up by 1
34497               
34498               LL55:
34499                                                                          ; Now for the z-coordinates, vertv_z + z
34500 9D26 D020  30        movb @XX12+5,ra                 ; LDA XX12+5        ; If vertv_z_hi is negative, jump down to LL56
     9D28 003C     
34501 9D2A 1151  14        jlt  LL56                       ; BMI LL56
34502               
34503 9D2C D020  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set (U T) = XX1(7 6) + XX12(5 4)
     9D2E 003B     
34504                      .clc                            ; CLC               ; = (z_hi z_lo) + vertv_z
     **** ****     > CLC
0001 9D30 0A13  18        sla  rzero,1
                   < elite.a99
34505                      .adc @XX1+6,ra                  ; ADC XX1+6         ;
     **** ****     > ADC
0001 9D32 1701  14        jnc  !
0002 9D34 B004  18        ab   rone,ra
0003               !:
0004 9D36 B020  30        ab   @XX1+6,ra
     9D38 0059     
                   < elite.a99
34506 9D3A D800  30        movb ra,@T                      ; STA T             ; Starting with the low bytes
     9D3C 00D1     
34507               
34508 9D3E D020  30        movb @XX1+7,ra                  ; LDA XX1+7         ; And then doing the high bytes (we can add 0 here as
     9D40 005A     
34509                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_y is 0)
     **** ****     > ADI
0001 9D42 1701  14        jnc  !
0002 9D44 B004  18        ab   rone,ra
0003               !:
0004 9D46 0220  22        ai   ra,(>00*256)
     9D48 0000     
                   < elite.a99
34510 9D4A D800  30        movb ra,@U                      ; STA U
     9D4C 008F     
34511               
34512 9D4E 0460  28        b    @LL57                      ; JMP LL57          ; We've added the z-coordinates, so jump to LL57
     9D50 9E0E     
34513               
34514                                                                          ; The adding process is continued in part 7, after a
34515                                                                          ; couple of subroutines that we don't need quite yet
34516               
34517               * ******************************************************************************
34518               *
34519               * Name: LL61
34520               * Type: Subroutine
34521               * Category: Maths (Arithmetic)
34522               * Summary: Calculate (U R) = 256 * A / Q
34523               *
34524               * ------------------------------------------------------------------------------
34525               *
34526               * Calculate the following, where A >= Q:
34527               *
34528               * (U R) = 256 * A / Q
34529               *
34530               * This is a sister routine to LL28, which does the division when A < Q.
34531               *
34532               * ******************************************************************************
34533               
34534               LL61:
34535 9D52 D060  30        movb @Q,rx                      ; LDX Q             ; If Q = 0, jump down to LL84 to return a division
     9D54 0090     
34536 9D56 131F  14        jeq  LL84                       ; BEQ LL84          ; error
34537               
34538                                                                          ; The LL28 routine returns A / Q, but only if A < Q. In
34539                                                                          ; our case A >= Q, but we still want to use the LL28
34540                                                                          ; routine, so we halve A until it's less than Q, call
34541                                                                          ; the division routine, and then double A by the same
34542                                                                          ; number of times
34543               
34544 9D58 0201  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0 to count the number of times we halve A
     9D5A 0000     
34545               
34546               LL63:
34547 9D5C 0910  18        srl  ra,1                       ; LSR A             ; Halve A by shifting right
34548               
34549 9D5E B044  18        ab   rone,rx                    ; INX               ; Increment X
34550               
34551 9D60 9020  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, loop back to LL63 to halve it again
     9D62 0090     
34552 9D64 18FB  14        joc  LL63                       ; BCS LL63
34553               
34554 9D66 D801  30        movb rx,@S                      ; STX S             ; Otherwise store the number of times we halved A in S
     9D68 0092     
34555               
34556 9D6A 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     9D6C 9338     
34557 9D6E 06A0  28        bl   @jsr                       ;
     9D70 8002     
34558                                                                          ;
34559                                                                          ; R = 256 * A / Q
34560                                                                          ;
34561                                                                          ; which we can do now as A < Q
34562               
34563 9D72 D060  30        movb @S,rx                      ; LDX S             ; Otherwise restore the number of times we halved A
     9D74 0092     
34564                                                                          ; above into X
34565               
34566 9D76 D020  30        movb @R,ra                      ; LDA R             ; Set A = our division result
     9D78 0091     
34567               
34568               LL64:
34569                      .asla                           ; ASL A             ; Double (U A) by shifting left
     **** ****     > ASLA
0001 9D7A 0240  22        andi ra,>ff00
     9D7C FF00     
0002 9D7E 0A10  18        sla  ra,1
                   < elite.a99
34570 9D80 0208  20        li   rarg1,U                    ; ROL U
     9D82 008F     
34571 9D84 06A0  28        bl   @rol                       ;
     9D86 8028     
34572               
34573 9D88 1106  14        jlt  LL84                       ; BMI LL84          ; If bit 7 of U is set, the doubling has overflowed, so
34574                                                                          ; jump to LL84 to return a division error
34575               
34576 9D8A 7044  18        sb   rone,rx                    ; DEX               ; Decrement X
34577               
34578 9D8C 16F6  14        jne  LL64                       ; BNE LL64          ; If X is not yet zero then we haven't done as many
34579                                                                          ; doublings as we did halvings earlier, so loop back for
34580                                                                          ; another doubling
34581               
34582 9D8E D800  30        movb ra,@R                      ; STA R             ; Store the low byte of the division result in R
     9D90 0091     
34583               
34584 9D92 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     9D94 800E     
34585               
34586               LL84:
34587 9D96 0200  20        li   ra,>32*256                 ; LDA #50           ; If we get here then either we tried to divide by 0, or
     9D98 3200     
34588 9D9A D800  30        movb ra,@R                      ; STA R             ; the result overflowed, so we set U and R to 50
     9D9C 0091     
34589 9D9E D800  30        movb ra,@U                      ; STA U
     9DA0 008F     
34590               
34591 9DA2 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     9DA4 800E     
34592               
34593               * ******************************************************************************
34594               *
34595               * Name: LL62
34596               * Type: Subroutine
34597               * Category: Maths (Arithmetic)
34598               * Summary: Calculate 128 - (U R)
34599               *
34600               * ------------------------------------------------------------------------------
34601               *
34602               * Calculate the following for a positive sign-magnitude number (U R):
34603               *
34604               * 128 - (U R)
34605               *
34606               * and then store the result, low byte then high byte, on the end of the heap at
34607               * XX3, where X points to the first free byte on the heap. Return by jumping down
34608               * to LL66.
34609               *
34610               * ------------------------------------------------------------------------------
34611               *
34612               * Returns:
34613               *
34614               * X                   X is incremented by 1
34615               *
34616               * ******************************************************************************
34617               
34618               LL62:
34619 9DA6 0200  20        li   ra,>80*256                 ; LDA #128          ; Calculate 128 - (U R), starting with the low bytes
     9DA8 8000     
34620                      .sec                            ; SEC
     **** ****     > SEC
0001 9DAA 0A15  18        sla  rmone,1
                   < elite.a99
34621                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 9DAC 1801  14        joc  !
0002 9DAE 7004  18        sb   rone,ra
0003               !:
0004 9DB0 7020  30        sb   @R,ra
     9DB2 0091     
                   < elite.a99
34622               
34623 9DB4 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     9DB6 0100     
34624                                                                          ; the heap at XX3
34625               
34626 9DB8 B044  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34627                                                                          ; byte
34628               
34629 9DBA 0200  20        li   ra,>00*256                 ; LDA #0            ; And then subtract the high bytes
     9DBC 0000     
34630                      .sbc @U,ra                      ; SBC U
     **** ****     > SBC
0001 9DBE 1801  14        joc  !
0002 9DC0 7004  18        sb   rone,ra
0003               !:
0004 9DC2 7020  30        sb   @U,ra
     9DC4 008F     
                   < elite.a99
34631               
34632 9DC6 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     9DC8 0100     
34633                                                                          ; the heap at XX3
34634               
34635 9DCA 0460  28        b    @LL66                      ; JMP LL66          ; Jump down to LL66
     9DCC 9EAA     
34636               
34637               * ******************************************************************************
34638               *
34639               * Name: LL9 (Part 7 of 12)
34640               * Type: Subroutine
34641               * Category: Drawing ships
34642               * Summary: Draw ship: Calculate the visibility of each of the ship's vertices
34643               * Deep dive: Drawing ships
34644               * Calculating vertex coordinates
34645               *
34646               * ------------------------------------------------------------------------------
34647               *
34648               * This section continues the coordinate adding from part 6 by finishing off the
34649               * calculation that we started above:
34650               *
34651               * [ sidev_x roofv_x nosev_x ]   [ x ]   [ x ]
34652               * vector to vertex = [ sidev_y roofv_y nosev_y ] . [ y ] + [ y ]
34653               * [ sidev_z roofv_z nosev_z ]   [ z ]   [ z ]
34654               *
34655               * The gets stored as follows, in sign-magnitude values with the magnitudes
34656               * fitting into the low bytes:
34657               *
34658               * XX15(2 0)           [ x y z ] . [ sidev_x roofv_x nosev_x ] + [ x y z ]
34659               *
34660               * XX15(5 3)           [ x y z ] . [ sidev_y roofv_y nosev_y ] + [ x y z ]
34661               *
34662               * (U T)               [ x y z ] . [ sidev_z roofv_z nosev_z ] + [ x y z ]
34663               *
34664               * Finally, because this vector is from our ship to the vertex, and we are at the
34665               * origin, this vector is the same as the coordinates of the vertex. In other
34666               * words, we have just worked out:
34667               *
34668               * XX15(2 0)           x-coordinate of the current vertex
34669               *
34670               * XX15(5 3)           y-coordinate of the current vertex
34671               *
34672               * (U T)               z-coordinate of the current vertex
34673               *
34674               * ******************************************************************************
34675               
34676               LL56:
34677 9DCE D020  30        movb @XX1+6,ra                  ; LDA XX1+6         ; Set (U T) = XX1(7 6) - XX12(5 4)
     9DD0 0059     
34678                      .sec                            ; SEC               ; = (z_hi z_lo) - vertv_z
     **** ****     > SEC
0001 9DD2 0A15  18        sla  rmone,1
                   < elite.a99
34679                      .sbc @XX12+4,ra                 ; SBC XX12+4        ;
     **** ****     > SBC
0001 9DD4 1801  14        joc  !
0002 9DD6 7004  18        sb   rone,ra
0003               !:
0004 9DD8 7020  30        sb   @XX12+4,ra
     9DDA 003B     
                   < elite.a99
34680 9DDC D800  30        movb ra,@T                      ; STA T             ; Starting with the low bytes
     9DDE 00D1     
34681               
34682 9DE0 D020  30        movb @XX1+7,ra                  ; LDA XX1+7         ; And then doing the high bytes (we can subtract 0 here
     9DE2 005A     
34683                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_z is 0)
     **** ****     > SBI
0001 9DE4 1801  14        joc  !
0002 9DE6 7004  18        sb   rone,ra
0003               !:
0004 9DE8 0220  22        ai   ra,-(>00*256)
     9DEA 0000     
                   < elite.a99
34684 9DEC D800  30        movb ra,@U                      ; STA U
     9DEE 008F     
34685               
34686 9DF0 1706  14        jnc  LL140                      ; BCC LL140         ; If the subtraction just underflowed, skip to LL140 to
34687                                                                          ; set (U T) to the minimum value of 4
34688               
34689 9DF2 160D  14        jne  LL57                       ; BNE LL57          ; If U is non-zero, jump down to LL57
34690               
34691 9DF4 D020  30        movb @T,ra                      ; LDA T             ; If T >= 4, jump down to LL57
     9DF6 00D1     
34692 9DF8 0280  22        ci   ra,>04*256                 ; CMP #4
     9DFA 0400     
34693 9DFC 1808  14        joc  LL57                       ; BCS LL57
34694               
34695               LL140:
34696 9DFE 0200  20        li   ra,>00*256                 ; LDA #0            ; If we get here then either (U T) < 4 or the
     9E00 0000     
34697 9E02 D800  30        movb ra,@U                      ; STA U             ; subtraction underflowed, so set (U T) = 4
     9E04 008F     
34698 9E06 0200  20        li   ra,>04*256                 ; LDA #4
     9E08 0400     
34699 9E0A D800  30        movb ra,@T                      ; STA T
     9E0C 00D1     
34700               
34701               LL57:
34702                                                                          ; By this point we have our results, so now to scale
34703                                                                          ; the 16-bit results down into 8-bit values
34704 9E0E D020  30        movb @U,ra                      ; LDA U             ; If the high bytes of the result are all zero, we are
     9E10 008F     
34705 9E12 F020  30        socb @XX15+1,ra                 ; ORA XX15+1        ; done, so jump down to LL60 for the next stage
     9E14 0032     
34706 9E16 F020  30        socb @XX15+4,ra                 ; ORA XX15+4
     9E18 0035     
34707 9E1A 131D  14        jeq  LL60                       ; BEQ LL60
34708               
34709                      .lsr @XX15+1                    ; LSR XX15+1        ; Shift XX15(1 0) to the right
     **** ****     > LSR
0001 9E1C D1A0  30        movb @XX15+1,rtmp
     9E1E 0032     
0002 9E20 0916  18        srl  rtmp,1
0003 9E22 D806  30        movb rtmp,@XX15+1
     9E24 0032     
                   < elite.a99
34710 9E26 0208  20        li   rarg1,XX15                 ; ROR XX15
     9E28 0031     
34711 9E2A 06A0  28        bl   @ror                       ;
     9E2C 8054     
34712               
34713                      .lsr @XX15+4                    ; LSR XX15+4        ; Shift XX15(4 3) to the right
     **** ****     > LSR
0001 9E2E D1A0  30        movb @XX15+4,rtmp
     9E30 0035     
0002 9E32 0916  18        srl  rtmp,1
0003 9E34 D806  30        movb rtmp,@XX15+4
     9E36 0035     
                   < elite.a99
34714 9E38 0208  20        li   rarg1,XX15+3               ; ROR XX15+3
     9E3A 0034     
34715 9E3C 06A0  28        bl   @ror                       ;
     9E3E 8054     
34716               
34717                      .lsr @U                         ; LSR U             ; Shift (U T) to the right
     **** ****     > LSR
0001 9E40 D1A0  30        movb @U,rtmp
     9E42 008F     
0002 9E44 0916  18        srl  rtmp,1
0003 9E46 D806  30        movb rtmp,@U
     9E48 008F     
                   < elite.a99
34718 9E4A 0208  20        li   rarg1,T                    ; ROR T
     9E4C 00D1     
34719 9E4E 06A0  28        bl   @ror                       ;
     9E50 8054     
34720               
34721 9E52 0460  28        b    @LL57                      ; JMP LL57          ; Jump back to LL57 to see if we can shift the result
     9E54 9E0E     
34722                                                                          ; any more
34723               
34724               * ******************************************************************************
34725               *
34726               * Name: LL9 (Part 8 of 12)
34727               * Type: Subroutine
34728               * Category: Drawing ships
34729               * Summary: Draw ship: Calculate the screen coordinates of visible vertices
34730               * Deep dive: Drawing ships
34731               *
34732               * ------------------------------------------------------------------------------
34733               *
34734               * This section projects the coordinate of the vertex into screen coordinates and
34735               * stores them on the XX3 heap. By the end of this part, the XX3 heap contains
34736               * four bytes containing the 16-bit screen coordinates of the current vertex, in
34737               * the order: x_lo, x_hi, y_lo, y_hi.
34738               *
34739               * When we reach here, we are looping through the vertices, and we've just worked
34740               * out the coordinates of the vertex in our normal coordinate system, as follows
34741               *
34742               * XX15(2 0)           (x_sign x_lo) = x-coordinate of the current vertex
34743               *
34744               * XX15(5 3)           (y_sign y_lo) = y-coordinate of the current vertex
34745               *
34746               * (U T)               (z_sign z_lo) = z-coordinate of the current vertex
34747               *
34748               * Note that U is always zero when we get to this point, as the vertex is always
34749               * in front of us (so it has a positive z-coordinate, into the screen).
34750               *
34751               * ------------------------------------------------------------------------------
34752               *
34753               * Other entry points:
34754               *
34755               * LL70+1              Contains an RTS (as the first byte of an LDA
34756               * instruction)
34757               *
34758               * LL66                A re-entry point into the ship-drawing routine, used by
34759               * the LL62 routine to store 128 - (U R) on the XX3 heap
34760               *
34761               * ******************************************************************************
34762               
34763               LL60:
34764 9E56 D020  30        movb @T,ra                      ; LDA T             ; Set Q = z_lo
     9E58 00D1     
34765 9E5A D800  30        movb ra,@Q                      ; STA Q
     9E5C 0090     
34766               
34767 9E5E D020  30        movb @XX15,ra                   ; LDA XX15          ; Set A = x_lo
     9E60 0031     
34768               
34769 9E62 9020  30        cb   @Q,ra                      ; CMP Q             ; If x_lo < z_lo jump to LL69
     9E64 0090     
34770 9E66 1706  14        jnc  LL69                       ; BCC LL69
34771               
34772 9E68 0206  20        li   rtmp,LL61                  ; JSR LL61          ; Call LL61 to calculate:
     9E6A 9D52     
34773 9E6C 06A0  28        bl   @jsr                       ;
     9E6E 8002     
34774                                                                          ;
34775                                                                          ; (U R) = 256 * A / Q
34776                                                                          ; = 256 * x / z
34777                                                                          ;
34778                                                                          ; which we can do as x >= z
34779               
34780 9E70 0460  28        b    @LL65                      ; JMP LL65          ; Jump to LL65 to skip the division for x_lo < z_lo
     9E72 9E7C     
34781               
34782               LL69:
34783 9E74 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     9E76 9338     
34784 9E78 06A0  28        bl   @jsr                       ;
     9E7A 8002     
34785                                                                          ;
34786                                                                          ; R = 256 * A / Q
34787                                                                          ; = 256 * x / z
34788                                                                          ;
34789                                                                          ; Because x < z, the result fits into one byte, and we
34790                                                                          ; also know that U = 0, so (U R) also contains the
34791                                                                          ; result
34792               
34793               LL65:
34794                                                                          ; At this point we have:
34795                                                                          ;
34796                                                                          ; (U R) = x / z
34797                                                                          ;
34798                                                                          ; so (U R) contains the vertex's x-coordinate projected
34799                                                                          ; on screen
34800                                                                          ;
34801                                                                          ; The next task is to convert (U R) to a pixel screen
34802                                                                          ; coordinate and stick it on the XX3 heap.
34803                                                                          ;
34804                                                                          ; We start with the x-coordinate. To convert the
34805                                                                          ; x-coordinate to a screen pixel we add 128, the
34806                                                                          ; x-coordinate of the centre of the screen, because the
34807                                                                          ; projected value is relative to an origin at the centre
34808                                                                          ; of the screen, but the origin of the screen pixels is
34809                                                                          ; at the top-left of the screen
34810 9E7C D060  30        movb @CNT,rx                    ; LDX CNT           ; Fetch the pointer to the end of the XX3 heap from CNT
     9E7E 00A4     
34811                                                                          ; into X
34812               
34813 9E80 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If x_sign is negative, jump up to LL62, which will
     9E82 0033     
34814 9E84 1190  14        jlt  LL62                       ; BMI LL62          ; store 128 - (U R) on the XX3 heap and return by
34815                                                                          ; jumping down to LL66 below
34816               
34817 9E86 D020  30        movb @R,ra                      ; LDA R             ; Calculate 128 + (U R), starting with the low bytes
     9E88 0091     
34818                      .clc                            ; CLC
     **** ****     > CLC
0001 9E8A 0A13  18        sla  rzero,1
                   < elite.a99
34819                      .adi (>80*256)                  ; ADC #128
     **** ****     > ADI
0001 9E8C 1701  14        jnc  !
0002 9E8E B004  18        ab   rone,ra
0003               !:
0004 9E90 0220  22        ai   ra,(>80*256)
     9E92 8000     
                   < elite.a99
34820               
34821 9E94 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     9E96 0100     
34822                                                                          ; the heap at XX3
34823               
34824 9E98 B044  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34825                                                                          ; byte
34826               
34827 9E9A D020  30        movb @U,ra                      ; LDA U             ; And then add the high bytes
     9E9C 008F     
34828                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 9E9E 1701  14        jnc  !
0002 9EA0 B004  18        ab   rone,ra
0003               !:
0004 9EA2 0220  22        ai   ra,(>00*256)
     9EA4 0000     
                   < elite.a99
34829               
34830 9EA6 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     9EA8 0100     
34831                                                                          ; the heap at XX3
34832               
34833               LL66:
34834                                                                          ; We've just stored the screen x-coordinate of the
34835                                                                          ; vertex on the XX3 heap, so now for the y-coordinate
34836 9EAA D001  18        movb rx,ra                      ; TXA               ; Store the heap pointer in X on the stack (at this
34837                      .pha                            ; PHA               ; it points to the last entry on the heap, not the first
     **** ****     > PHA
0001 9EAC D680  30        movb ra,*rsp
0002 9EAE 060A  14        dec  rsp
                   < elite.a99
34838                                                                          ; free byte)
34839               
34840 9EB0 0200  20        li   ra,>00*256                 ; LDA #0            ; Set U = 0
     9EB2 0000     
34841 9EB4 D800  30        movb ra,@U                      ; STA U
     9EB6 008F     
34842               
34843 9EB8 D020  30        movb @T,ra                      ; LDA T             ; Set Q = z_lo
     9EBA 00D1     
34844 9EBC D800  30        movb ra,@Q                      ; STA Q
     9EBE 0090     
34845               
34846 9EC0 D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set A = y_lo
     9EC2 0034     
34847               
34848 9EC4 9020  30        cb   @Q,ra                      ; CMP Q             ; If y_lo < z_lo jump to LL67
     9EC6 0090     
34849 9EC8 171A  14        jnc  LL67                       ; BCC LL67
34850               
34851 9ECA 0206  20        li   rtmp,LL61                  ; JSR LL61          ; Call LL61 to calculate:
     9ECC 9D52     
34852 9ECE 06A0  28        bl   @jsr                       ;
     9ED0 8002     
34853                                                                          ;
34854                                                                          ; (U R) = 256 * A / Q
34855                                                                          ; = 256 * y / z
34856                                                                          ;
34857                                                                          ; which we can do as y >= z
34858               
34859 9ED2 0460  28        b    @LL68                      ; JMP LL68          ; Jump to LL68 to skip the division for y_lo < z_lo
     9ED4 9F06     
34860               
34861               LL70:
34862                                                                          ; This gets called from below when y_sign is negative
34863 9ED6 0200  20        li   ra,(Y)*256                 ; LDA #Y            ; Calculate #Y + (U R), starting with the low bytes
     9ED8 6000     
34864                      .clc                            ; CLC
     **** ****     > CLC
0001 9EDA 0A13  18        sla  rzero,1
                   < elite.a99
34865                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 9EDC 1701  14        jnc  !
0002 9EDE B004  18        ab   rone,ra
0003               !:
0004 9EE0 B020  30        ab   @R,ra
     9EE2 0091     
                   < elite.a99
34866               
34867 9EE4 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     9EE6 0100     
34868                                                                          ; the heap at XX3
34869               
34870 9EE8 B044  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34871                                                                          ; byte
34872               
34873 9EEA 0200  20        li   ra,>00*256                 ; LDA #0            ; And then add the high bytes
     9EEC 0000     
34874                      .adc @U,ra                      ; ADC U
     **** ****     > ADC
0001 9EEE 1701  14        jnc  !
0002 9EF0 B004  18        ab   rone,ra
0003               !:
0004 9EF2 B020  30        ab   @U,ra
     9EF4 008F     
                   < elite.a99
34875               
34876 9EF6 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     9EF8 0100     
34877                                                                          ; the heap at XX3
34878               
34879 9EFA 0460  28        b    @LL50                      ; JMP LL50          ; Jump to LL50 to move on to the next vertex
     9EFC 9F38     
34880               
34881               LL67:
34882 9EFE 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     9F00 9338     
34883 9F02 06A0  28        bl   @jsr                       ;
     9F04 8002     
34884                                                                          ;
34885                                                                          ; R = 256 * A / Q
34886                                                                          ; = 256 * y / z
34887                                                                          ;
34888                                                                          ; Because y < z, the result fits into one byte, and we
34889                                                                          ; also know that U = 0, so (U R) also contains the
34890                                                                          ; result
34891               
34892               LL68:
34893                                                                          ; At this point we have:
34894                                                                          ;
34895                                                                          ; (U R) = y / z
34896                                                                          ;
34897                                                                          ; so (U R) contains the vertex's y-coordinate projected
34898                                                                          ; on screen
34899                                                                          ;
34900                                                                          ; We now want to convert this to a screen y-coordinate
34901                                                                          ; and stick it on the XX3 heap, much like we did with
34902                                                                          ; the x-coordinate above. Again, we convert the
34903                                                                          ; coordinate by adding or subtracting the y-coordinate
34904                                                                          ; of the centre of the screen, which is in the constant
34905                                                                          ; #Y, but this time we do the opposite, as a positive
34906                                                                          ; projected y-coordinate, i.e. up the space y-axis and
34907                                                                          ; up the screen, converts to a low y-coordinate, which
34908                                                                          ; is the opposite way round to the x-coordinates
34909                      .pla                            ; PLA               ; Restore the heap pointer from the stack into X
     **** ****     > PLA
0001 9F06 058A  14        inc  rsp
0002 9F08 D01A  26        movb *rsp,ra
                   < elite.a99
34910 9F0A D040  18        movb ra,rx                      ; TAX
34911               
34912 9F0C B044  18        ab   rone,rx                    ; INX               ; When we stored the heap pointer, it pointed to the
34913                                                                          ; last entry on the heap, not the first free byte, so we
34914                                                                          ; increment it so it does point to the next free byte
34915               
34916 9F0E D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; If y_sign is negative, jump up to LL70, which will
     9F10 0036     
34917 9F12 11E1  14        jlt  LL70                       ; BMI LL70          ; store #Y + (U R) on the XX3 heap and return by jumping
34918                                                                          ; down to LL50 below
34919               
34920 9F14 0200  20        li   ra,(Y)*256                 ; LDA #Y            ; Calculate #Y - (U R), starting with the low bytes
     9F16 6000     
34921                      .sec                            ; SEC
     **** ****     > SEC
0001 9F18 0A15  18        sla  rmone,1
                   < elite.a99
34922                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 9F1A 1801  14        joc  !
0002 9F1C 7004  18        sb   rone,ra
0003               !:
0004 9F1E 7020  30        sb   @R,ra
     9F20 0091     
                   < elite.a99
34923               
34924 9F22 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     9F24 0100     
34925                                                                          ; the heap at XX3
34926               
34927 9F26 B044  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34928                                                                          ; byte
34929               
34930 9F28 0200  20        li   ra,>00*256                 ; LDA #0            ; And then subtract the high bytes
     9F2A 0000     
34931                      .sbc @U,ra                      ; SBC U
     **** ****     > SBC
0001 9F2C 1801  14        joc  !
0002 9F2E 7004  18        sb   rone,ra
0003               !:
0004 9F30 7020  30        sb   @U,ra
     9F32 008F     
                   < elite.a99
34932               
34933 9F34 D840  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     9F36 0100     
34934                                                                          ; the heap at XX3
34935               
34936               LL50:
34937                                                                          ; By the time we get here, the XX3 heap contains four
34938                                                                          ; bytes containing the screen coordinates of the current
34939                                                                          ; vertex, in the order: x_lo, x_hi, y_lo, y_hi
34940                      .clc                            ; CLC               ; Set CNT = CNT + 4, so the heap pointer points to the
     **** ****     > CLC
0001 9F38 0A13  18        sla  rzero,1
                   < elite.a99
34941 9F3A D020  30        movb @CNT,ra                    ; LDA CNT           ; next free byte on the heap
     9F3C 00A4     
34942                      .adi (>04*256)                  ; ADC #4
     **** ****     > ADI
0001 9F3E 1701  14        jnc  !
0002 9F40 B004  18        ab   rone,ra
0003               !:
0004 9F42 0220  22        ai   ra,(>04*256)
     9F44 0400     
                   < elite.a99
34943 9F46 D800  30        movb ra,@CNT                    ; STA CNT
     9F48 00A4     
34944               
34945 9F4A D020  30        movb @XX17,ra                   ; LDA XX17          ; Set A to the offset of the current vertex's data,
     9F4C 0095     
34946                                                                          ; which we set in part 6
34947               
34948                      .adi (>06*256)                  ; ADC #6            ; Set Y = A + 6, so Y now points to the data for the
     **** ****     > ADI
0001 9F4E 1701  14        jnc  !
0002 9F50 B004  18        ab   rone,ra
0003               !:
0004 9F52 0220  22        ai   ra,(>06*256)
     9F54 0600     
                   < elite.a99
34949 9F56 D080  18        movb ra,ry                      ; TAY               ; next vertex
34950               
34951 9F58 1805  14        joc  LL72                       ; BCS LL72          ; If the addition just overflowed, meaning we just tried
34952                                                                          ; to access vertex #43, jump to LL72, as the maximum
34953                                                                          ; number of vertices allowed is 42
34954               
34955 9F5A 9020  30        cb   @XX20,ra                   ; CMP XX20          ; If Y >= number of vertices * 6 (which we stored in
     9F5C 00A8     
34956 9F5E 1802  14        joc  LL72                       ; BCS LL72          ; XX20 in part 6), jump to LL72, as we have processed
34957                                                                          ; all the vertices for this ship
34958               
34959 9F60 0460  28        b    @LL48                      ; JMP LL48          ; Loop back to LL48 in part 6 to calculate visibility
     9F62 9B28     
34960                                                                          ; and screen coordinates for the next vertex
34961               
34962               * ******************************************************************************
34963               *
34964               * Name: LL9 (Part 9 of 12)
34965               * Type: Subroutine
34966               * Category: Drawing ships
34967               * Summary: Draw ship: Draw laser beams if the ship is firing its laser at us
34968               * Deep dive: Drawing ships
34969               *
34970               * ------------------------------------------------------------------------------
34971               *
34972               * This part sets things up so we can loop through the edges in the next part. It
34973               * also adds a line to the ship line heap, if the ship is firing at us.
34974               *
34975               * When we get here, the heap at XX3 contains all the visible vertex screen
34976               * coordinates.
34977               *
34978               * ******************************************************************************
34979               
34980               LL72:
34981 9F64 D020  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     9F66 0072     
34982 9F68 0240  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE31
     9F6A 2000     
34983 9F6C 1308  14        jeq  EE31                       ; BEQ EE31
34984               
34985 9F6E D020  30        movb @XX1+31,ra                 ; LDA XX1+31        ; The ship is exploding, so set bit 3 of the ship's byte
     9F70 0072     
34986 9F72 0260  22        ori  ra,>08*256                 ; ORA #%00001000    ; #31 to denote that we are drawing something on-screen
     9F74 0800     
34987 9F76 D800  30        movb ra,@XX1+31                 ; STA XX1+31        ; for this ship
     9F78 0072     
34988               
34989 9F7A 0460  28        b    @DOEXP                     ; JMP DOEXP         ; Jump to DOEXP to display the explosion cloud,
     9F7C 6894     
34990                                                                          ; returning from the subroutine using a tail call
34991               
34992               EE31:
34993 9F7E 0200  20        li   ra,>08*256                 ; LDA #%00001000    ; If bit 3 of the ship's byte #31 is clear, then there
     9F80 0800     
34994                      .bit @XX1+31                    ; BIT XX1+31        ; is nothing already being shown for this ship, so skip
     **** ****     > BIT
0001 9F82 D1A0  30        movb @XX1+31,rtmp
     9F84 0072     
0002 9F86 0546  14        inv  rtmp
0003 9F88 D1C4  18        movb rone,rtmp2
0004 9F8A 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
34995 9F8C 1306  14        jeq  LL74                       ; BEQ LL74          ; to LL74 as we don't need to erase anything from the
34996                                                                          ; screen
34997               
34998 9F8E 0206  20        li   rtmp,LL155                 ; JSR LL155         ; Otherwise call LL155 to draw the existing ship, which
     9F90 A250     
34999 9F92 06A0  28        bl   @jsr                       ;
     9F94 8002     
35000                                                                          ; removes it from the screen
35001               
35002 9F96 0200  20        li   ra,>08*256                 ; LDA #%00001000    ; Set bit 3 of A so the next instruction sets bit 3 of
     9F98 0800     
35003                                                                          ; the ship's byte #31 to denote that we are drawing
35004                                                                          ; something on-screen for this ship
35005               
35006               LL74:
35007 9F9A F020  30        socb @XX1+31,ra                 ; ORA XX1+31        ; Apply bit 3 of A to the ship's byte #31, so if there
     9F9C 0072     
35008 9F9E D800  30        movb ra,@XX1+31                 ; STA XX1+31        ; was no ship already on screen, the bit is clear,
     9FA0 0072     
35009                                                                          ; otherwise it is set
35010               
35011 9FA2 0202  20        li   ry,>09*256                 ; LDY #9            ; Fetch byte #9 of the ship's blueprint, which is the
     9FA4 0900     
35012                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of edges, and store it in XX20
     **** ****     > LD_IND_Y_IDX
0001 9FA6 D820  42        movb @XX0,@rtmplb
     9FA8 001E     
     9FAA 830D     
0002 9FAC D1A0  30        movb @XX0+1,rtmp
     9FAE 001F     
0003 9FB0 A182  18        a    ry,rtmp
0004 9FB2 D016  26        movb *rtmp,RA
                   < elite.a99
35013 9FB4 D800  30        movb ra,@XX20                   ; STA XX20
     9FB6 00A8     
35014               
35015 9FB8 0202  20        li   ry,>00*256                 ; LDY #0            ; We are about to step through all the edges, using Y
     9FBA 0000     
35016                                                                          ; as a counter
35017               
35018 9FBC D802  30        movb ry,@U                      ; STY U             ; Set U = 0 (though we increment it to 1 below)
     9FBE 008F     
35019               
35020 9FC0 D802  30        movb ry,@XX17                   ; STY XX17          ; Set XX17 = 0, which we are going to use as a counter
     9FC2 0095     
35021                                                                          ; for stepping through the ship's edges
35022               
35023 9FC4 B004  18        ab   rone,ra                    ; INC U             ; We are going to start calculating the lines we need to
35024                                                                          ; draw for this ship, and will store them in the ship
35025                                                                          ; line heap, using U to point to the end of the heap, so
35026                                                                          ; we start by setting U = 1
35027               
35028                      .bit @XX1+31                    ; BIT XX1+31        ; If bit 6 of the ship's byte #31 is clear, then the
     **** ****     > BIT
0001 9FC6 D1A0  30        movb @XX1+31,rtmp
     9FC8 0072     
0002 9FCA 0546  14        inv  rtmp
0003 9FCC D1C4  18        movb rone,rtmp2
0004 9FCE 5187  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
35029 9FD0 1965  14        jno  LL170                      ; BVC LL170         ; ship is not firing its lasers, so jump to LL170 to
35030                                                                          ; skip the drawing of laser lines
35031               
35032                                                                          ; The ship is firing its laser at us, so we need to draw
35033                                                                          ; the laser lines
35034               
35035 9FD2 D020  30        movb @XX1+31,ra                 ; LDA XX1+31        ; Clear bit 6 of the ship's byte #31 so the ship doesn't
     9FD4 0072     
35036 9FD6 0240  22        andi ra,>bf*256                 ; AND #%10111111    ; keep firing endlessly
     9FD8 BF00     
35037 9FDA D800  30        movb ra,@XX1+31                 ; STA XX1+31
     9FDC 0072     
35038               
35039 9FDE 0202  20        li   ry,>06*256                 ; LDY #6            ; Fetch byte #6 of the ship's blueprint, which is the
     9FE0 0600     
35040                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number * 4 of the vertex where the ship has its lasers
     **** ****     > LD_IND_Y_IDX
0001 9FE2 D820  42        movb @XX0,@rtmplb
     9FE4 001E     
     9FE6 830D     
0002 9FE8 D1A0  30        movb @XX0+1,rtmp
     9FEA 001F     
0003 9FEC A182  18        a    ry,rtmp
0004 9FEE D016  26        movb *rtmp,RA
                   < elite.a99
35041               
35042 9FF0 D080  18        movb ra,ry                      ; TAY               ; Put the vertex number into Y, where it can act as an
35043                                                                          ; index into list of vertex screen coordinates we added
35044                                                                          ; to the XX3 heap
35045               
35046 9FF2 D062  34        movb @XX3(ry),rx                ; LDX XX3,Y         ; Fetch the x_lo coordinate of the laser vertex from the
     9FF4 0100     
35047 9FF6 D801  30        movb rx,@XX15                   ; STX XX15          ; XX3 heap into XX15
     9FF8 0031     
35048               
35049 9FFA B044  18        ab   rone,rx                    ; INX               ; If X = 255 then the laser vertex is not visible, as
35050 9FFC 134F  14        jeq  LL170                      ; BEQ LL170         ; the value we stored in part 2 wasn't overwritten by
35051                                                                          ; the vertex calculation in part 6 and 7, so jump to
35052                                                                          ; LL170 to skip drawing the laser lines
35053               
35054                                                                          ; We now build a laser beam from the ship's laser vertex
35055                                                                          ; towards our ship, as follows:
35056                                                                          ;
35057                                                                          ; XX15(1 0) = laser vertex x-coordinate
35058                                                                          ;
35059                                                                          ; XX15(3 2) = laser vertex y-coordinate
35060                                                                          ;
35061                                                                          ; XX15(5 4) = x-coordinate of the end of the beam
35062                                                                          ;
35063                                                                          ; XX12(1 0) = y-coordinate of the end of the beam
35064                                                                          ;
35065                                                                          ; The end of the laser beam will be positioned to look
35066                                                                          ; good, rather than being directly aimed at us, as
35067                                                                          ; otherwise we would only see a flashing point of light
35068                                                                          ; as they unleashed their attack
35069               
35070 9FFE D062  34        movb @XX3+1(ry),rx              ; LDX XX3+1,Y       ; Fetch the x_hi coordinate of the laser vertex from the
     A000 0101     
35071 A002 D801  30        movb rx,@XX15+1                 ; STX XX15+1        ; XX3 heap into XX15+1
     A004 0032     
35072               
35073 A006 B044  18        ab   rone,rx                    ; INX               ; If X = 255 then the laser vertex is not visible, as
35074 A008 1349  14        jeq  LL170                      ; BEQ LL170         ; the value we stored in part 2 wasn't overwritten by
35075                                                                          ; a vertex calculation in part 6 and 7, so jump to LL170
35076                                                                          ; to skip drawing the laser beam
35077               
35078 A00A D062  34        movb @XX3+2(ry),rx              ; LDX XX3+2,Y       ; Fetch the y_lo coordinate of the laser vertex from the
     A00C 0102     
35079 A00E D801  30        movb rx,@XX15+2                 ; STX XX15+2        ; XX3 heap into XX15+2
     A010 0033     
35080               
35081 A012 D062  34        movb @XX3+3(ry),rx              ; LDX XX3+3,Y       ; Fetch the y_hi coordinate of the laser vertex from the
     A014 0103     
35082 A016 D801  30        movb rx,@XX15+3                 ; STX XX15+3        ; XX3 heap into XX15+3
     A018 0034     
35083               
35084 A01A 0200  20        li   ra,>00*256                 ; LDA #0            ; Set XX15(5 4) = 0, so their laser beam fires to the
     A01C 0000     
35085 A01E D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; left edge of the screen
     A020 0035     
35086 A022 D800  30        movb ra,@XX15+5                 ; STA XX15+5
     A024 0036     
35087               
35088 A026 D800  30        movb ra,@XX12+1                 ; STA XX12+1        ; Set XX12(1 0) = the ship's z_lo coordinate, which will
     A028 0038     
35089 A02A D020  30        movb @XX1+6,ra                  ; LDA XX1+6         ; effectively make the vertical position of the end of
     A02C 0059     
35090 A02E D800  30        movb ra,@XX12                   ; STA XX12          ; the laser beam move around as the ship moves in space
     A030 0037     
35091               
35092 A032 D020  30        movb @XX1+2,ra                  ; LDA XX1+2         ; If the ship's x_sign is positive, skip the next
     A034 0055     
35093 A036 1501  14        jgt  B114                       ; BPL B114          ; instruction
35094               
35095 A038 7004  18        sb   rone,ra                    ; DEC XX15+4        ; The ship's x_sign is negative (i.e. it's on the left
35096                                                                          ; side of the screen), so switch the laser beam so it
35097                                                                          ; goes to the right edge of the screen by decrementing
35098                                                                          ; XX15(5 4) to 255
35099               
35100               B114:
35101 A03A 0206  20        li   rtmp,LL145                 ; JSR LL145         ; Call LL145 to see if the laser beam needs to be
     A03C A560     
35102 A03E 06A0  28        bl   @jsr                       ;
     A040 8002     
35103                                                                          ; clipped to fit on-screen, returning the clipped line's
35104                                                                          ; end-points in (X1, Y1) and (X2, Y2)
35105               
35106 A042 182C  14        joc  LL170                      ; BCS LL170         ; If the C flag is set then the line is not visible on
35107                                                                          ; screen, so jump to LL170 so we don't store this line
35108                                                                          ; in the ship line heap
35109               
35110 A044 D0A0  30        movb @U,ry                      ; LDY U             ; Fetch the ship line heap pointer, which points to the
     A046 008F     
35111                                                                          ; next free byte on the heap, into Y
35112               
35113 A048 D020  30        movb @XX15,ra                   ; LDA XX15          ; Add X1 to the end of the heap
     A04A 0031     
35114                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 A04C D820  42        movb @XX19,@rtmplb
     A04E 0074     
     A050 830D     
0002 A052 D1A0  30        movb @XX19+1,rtmp
     A054 0075     
0003 A056 A182  18        a    ry,rtmp
0004 A058 D580  30        movb RA,*rtmp
                   < elite.a99
35115               
35116 A05A B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35117               
35118 A05C D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Add Y1 to the end of the heap
     A05E 0032     
35119                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 A060 D820  42        movb @XX19,@rtmplb
     A062 0074     
     A064 830D     
0002 A066 D1A0  30        movb @XX19+1,rtmp
     A068 0075     
0003 A06A A182  18        a    ry,rtmp
0004 A06C D580  30        movb RA,*rtmp
                   < elite.a99
35120               
35121 A06E B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35122               
35123 A070 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Add X2 to the end of the heap
     A072 0033     
35124                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 A074 D820  42        movb @XX19,@rtmplb
     A076 0074     
     A078 830D     
0002 A07A D1A0  30        movb @XX19+1,rtmp
     A07C 0075     
0003 A07E A182  18        a    ry,rtmp
0004 A080 D580  30        movb RA,*rtmp
                   < elite.a99
35125               
35126 A082 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35127               
35128 A084 D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Add Y2 to the end of the heap
     A086 0034     
35129                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 A088 D820  42        movb @XX19,@rtmplb
     A08A 0074     
     A08C 830D     
0002 A08E D1A0  30        movb @XX19+1,rtmp
     A090 0075     
0003 A092 A182  18        a    ry,rtmp
0004 A094 D580  30        movb RA,*rtmp
                   < elite.a99
35130               
35131 A096 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35132               
35133 A098 D802  30        movb ry,@U                      ; STY U             ; Store the updated ship line heap pointer in U
     A09A 008F     
35134               
35135               * ******************************************************************************
35136               *
35137               * Name: LL9 (Part 10 of 12)
35138               * Type: Subroutine
35139               * Category: Drawing ships
35140               * Summary: Draw ship: Calculate the visibility of each of the ship's edges
35141               * Deep dive: Drawing ships
35142               *
35143               * ------------------------------------------------------------------------------
35144               *
35145               * This part calculates which edges are visible - in other words, which lines we
35146               * should draw - and clips them to fit on the screen.
35147               *
35148               * When we get here, the heap at XX3 contains all the visible vertex screen
35149               * coordinates.
35150               *
35151               * ******************************************************************************
35152               
35153               LL170:
35154 A09C 0202  20        li   ry,>03*256                 ; LDY #3            ; Fetch byte #3 of the ship's blueprint, which contains
     A09E 0300     
35155                      .clc                            ; CLC               ; the low byte of the offset to the edges data
     **** ****     > CLC
0001 A0A0 0A13  18        sla  rzero,1
                   < elite.a99
35156                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y
     **** ****     > LD_IND_Y_IDX
0001 A0A2 D820  42        movb @XX0,@rtmplb
     A0A4 001E     
     A0A6 830D     
0002 A0A8 D1A0  30        movb @XX0+1,rtmp
     A0AA 001F     
0003 A0AC A182  18        a    ry,rtmp
0004 A0AE D016  26        movb *rtmp,RA
                   < elite.a99
35157               
35158                      .adc @XX0,ra                    ; ADC XX0           ; Set V = low byte edges offset + XX0
     **** ****     > ADC
0001 A0B0 1701  14        jnc  !
0002 A0B2 B004  18        ab   rone,ra
0003               !:
0004 A0B4 B020  30        ab   @XX0,ra
     A0B6 001E     
                   < elite.a99
35159 A0B8 D800  30        movb ra,@V                      ; STA V
     A0BA 0022     
35160               
35161 A0BC 0202  20        li   ry,>10*256                 ; LDY #16           ; Fetch byte #16 of the ship's blueprint, which contains
     A0BE 1000     
35162                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the high byte of the offset to the edges data
     **** ****     > LD_IND_Y_IDX
0001 A0C0 D820  42        movb @XX0,@rtmplb
     A0C2 001E     
     A0C4 830D     
0002 A0C6 D1A0  30        movb @XX0+1,rtmp
     A0C8 001F     
0003 A0CA A182  18        a    ry,rtmp
0004 A0CC D016  26        movb *rtmp,RA
                   < elite.a99
35163               
35164                      .adc @XX0+1,ra                  ; ADC XX0+1         ; Set V+1 = high byte edges offset + XX0+1
     **** ****     > ADC
0001 A0CE 1701  14        jnc  !
0002 A0D0 B004  18        ab   rone,ra
0003               !:
0004 A0D2 B020  30        ab   @XX0+1,ra
     A0D4 001F     
                   < elite.a99
35165 A0D6 D800  30        movb ra,@V+1                    ; STA V+1           ;
     A0D8 0023     
35166                                                                          ; So V(1 0) now points to the start of the edges data
35167                                                                          ; for this ship
35168               
35169 A0DA 0202  20        li   ry,>05*256                 ; LDY #5            ; Fetch byte #5 of the ship's blueprint, which contains
     A0DC 0500     
35170                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the maximum heap size for plotting the ship (which is
     **** ****     > LD_IND_Y_IDX
0001 A0DE D820  42        movb @XX0,@rtmplb
     A0E0 001E     
     A0E2 830D     
0002 A0E4 D1A0  30        movb @XX0+1,rtmp
     A0E6 001F     
0003 A0E8 A182  18        a    ry,rtmp
0004 A0EA D016  26        movb *rtmp,RA
                   < elite.a99
35171 A0EC D800  30        movb ra,@T1                     ; STA T1            ; 1 + 4 * the maximum number of visible edges) and store
     A0EE 0006     
35172                                                                          ; it in T1
35173               
35174 A0F0 D0A0  30        movb @XX17,ry                   ; LDY XX17          ; Set Y to the edge counter in XX17
     A0F2 0095     
35175               
35176               LL75:
35177                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this edge, which contains the
     **** ****     > LD_IND_Y_IDX
0001 A0F4 D820  42        movb @V,@rtmplb
     A0F6 0022     
     A0F8 830D     
0002 A0FA D1A0  30        movb @V+1,rtmp
     A0FC 0023     
0003 A0FE A182  18        a    ry,rtmp
0004 A100 D016  26        movb *rtmp,RA
                   < elite.a99
35178                                                                          ; visibility distance for this edge, beyond which the
35179                                                                          ; edge is not shown
35180               
35181 A102 9020  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 > the visibility distance, where XX4 contains
     A104 00A7     
35182 A106 1802  14        joc  FIX011                     ; BCS FIX011        ; the ship's z-distance reduced to 0-31 (which we set in
35183 A108 0460  28        b    @LL78                      ; JMP LL78          ; part 2), then this edge is too far away to be visible,
     A10A A212     
35184                                                                          ; so jump down to LL78 to move on to the next edge
35185               FIX011:
35186 A10C B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
35187               
35188                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this edge into A, so:
     **** ****     > LD_IND_Y_IDX
0001 A10E D820  42        movb @V,@rtmplb
     A110 0022     
     A112 830D     
0002 A114 D1A0  30        movb @V+1,rtmp
     A116 0023     
0003 A118 A182  18        a    ry,rtmp
0004 A11A D016  26        movb *rtmp,RA
                   < elite.a99
35189                                                                          ;
35190                                                                          ; A = %ffff ffff, where:
35191                                                                          ;
35192                                                                          ; * Bits 0-3 = the number of face 1
35193                                                                          ;
35194                                                                          ; * Bits 4-7 = the number of face 2
35195               
35196 A11C B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
35197               
35198 A11E D800  30        movb ra,@P                      ; STA P             ; Store byte #1 into P
     A120 001B     
35199               
35200 A122 0240  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     A124 0F00     
35201 A126 D040  18        movb ra,rx                      ; TAX
35202               
35203 A128 D021  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     A12A 00D2     
35204 A12C 160A  14        jne  LL79                       ; BNE LL79          ; face 1 is visible, so jump to LL79
35205               
35206 A12E D020  30        movb @P,ra                      ; LDA P             ; Fetch byte #1 for this edge into A
     A130 001B     
35207               
35208 A132 0910  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 2
35209 A134 0910  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
35210 A136 0910  18        srl  ra,1                       ; LSR A
35211 A138 0910  18        srl  ra,1                       ; LSR A
35212 A13A D040  18        movb ra,rx                      ; TAX
35213               
35214 A13C D021  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is zero then we decided in part 5 that
     A13E 00D2     
35215 A140 1368  14        jeq  LL78                       ; BEQ LL78          ; face 2 is hidden, so jump to LL78
35216               
35217               LL79:
35218                                                                          ; We now build the screen line for this edge, as
35219                                                                          ; follows:
35220                                                                          ;
35221                                                                          ; XX15(1 0) = start x-coordinate
35222                                                                          ;
35223                                                                          ; XX15(3 2) = start y-coordinate
35224                                                                          ;
35225                                                                          ; XX15(5 4) = end x-coordinate
35226                                                                          ;
35227                                                                          ; XX12(1 0) = end y-coordinate
35228                                                                          ;
35229                                                                          ; We can then pass this to the line clipping routine
35230                                                                          ; before storing the resulting line in the ship line
35231                                                                          ; heap
35232                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this edge into X, which contains
     **** ****     > LD_IND_Y_IDX
0001 A142 D820  42        movb @V,@rtmplb
     A144 0022     
     A146 830D     
0002 A148 D1A0  30        movb @V+1,rtmp
     A14A 0023     
0003 A14C A182  18        a    ry,rtmp
0004 A14E D016  26        movb *rtmp,RA
                   < elite.a99
35233 A150 D040  18        movb ra,rx                      ; TAX               ; the number of the vertex at the start of the edge
35234               
35235 A152 B084  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
35236               
35237                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this edge into Q, which contains
     **** ****     > LD_IND_Y_IDX
0001 A154 D820  42        movb @V,@rtmplb
     A156 0022     
     A158 830D     
0002 A15A D1A0  30        movb @V+1,rtmp
     A15C 0023     
0003 A15E A182  18        a    ry,rtmp
0004 A160 D016  26        movb *rtmp,RA
                   < elite.a99
35238 A162 D800  30        movb ra,@Q                      ; STA Q             ; the number of the vertex at the end of the edge
     A164 0090     
35239               
35240 A166 D021  34        movb @XX3+1(rx),ra              ; LDA XX3+1,X       ; Fetch the x_hi coordinate of the edge's start vertex
     A168 0101     
35241 A16A D800  30        movb ra,@XX15+1                 ; STA XX15+1        ; from the XX3 heap into XX15+1
     A16C 0032     
35242               
35243 A16E D021  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Fetch the x_lo coordinate of the edge's start vertex
     A170 0100     
35244 A172 D800  30        movb ra,@XX15                   ; STA XX15          ; from the XX3 heap into XX15
     A174 0031     
35245               
35246 A176 D021  34        movb @XX3+2(rx),ra              ; LDA XX3+2,X       ; Fetch the y_lo coordinate of the edge's start vertex
     A178 0102     
35247 A17A D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; from the XX3 heap into XX15+2
     A17C 0033     
35248               
35249 A17E D021  34        movb @XX3+3(rx),ra              ; LDA XX3+3,X       ; Fetch the y_hi coordinate of the edge's start vertex
     A180 0103     
35250 A182 D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; from the XX3 heap into XX15+3
     A184 0034     
35251               
35252 A186 D060  30        movb @Q,rx                      ; LDX Q             ; Set X to the number of the vertex at the end of the
     A188 0090     
35253                                                                          ; edge, which we stored in Q
35254               
35255 A18A D021  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Fetch the x_lo coordinate of the edge's end vertex
     A18C 0100     
35256 A18E D800  30        movb ra,@XX15+4                 ; STA XX15+4        ; from the XX3 heap into XX15+4
     A190 0035     
35257               
35258 A192 D021  34        movb @XX3+3(rx),ra              ; LDA XX3+3,X       ; Fetch the y_hi coordinate of the edge's end vertex
     A194 0103     
35259 A196 D800  30        movb ra,@XX12+1                 ; STA XX12+1        ; from the XX3 heap into XX12+1
     A198 0038     
35260               
35261 A19A D021  34        movb @XX3+2(rx),ra              ; LDA XX3+2,X       ; Fetch the y_lo coordinate of the edge's end vertex
     A19C 0102     
35262 A19E D800  30        movb ra,@XX12                   ; STA XX12          ; from the XX3 heap into XX12
     A1A0 0037     
35263               
35264 A1A2 D021  34        movb @XX3+1(rx),ra              ; LDA XX3+1,X       ; Fetch the x_hi coordinate of the edge's end vertex
     A1A4 0101     
35265 A1A6 D800  30        movb ra,@XX15+5                 ; STA XX15+5        ; from the XX3 heap into XX15+5
     A1A8 0036     
35266               
35267 A1AA 0206  20        li   rtmp,LL147                 ; JSR LL147         ; Call LL147 to see if the new line segment needs to be
     A1AC A56C     
35268 A1AE 06A0  28        bl   @jsr                       ;
     A1B0 8002     
35269                                                                          ; clipped to fit on-screen, returning the clipped line's
35270                                                                          ; end-points in (X1, Y1) and (X2, Y2)
35271               
35272 A1B2 182F  14        joc  LL78                       ; BCS LL78          ; If the C flag is set then the line is not visible on
35273                                                                          ; screen, so jump to LL78 so we don't store this line
35274                                                                          ; in the ship line heap
35275               
35276               * ******************************************************************************
35277               *
35278               * Name: LL9 (Part 11 of 12)
35279               * Type: Subroutine
35280               * Category: Drawing ships
35281               * Summary: Draw ship: Add all visible edges to the ship line heap
35282               * Deep dive: Drawing ships
35283               *
35284               * ------------------------------------------------------------------------------
35285               *
35286               * This part adds all the visible edges to the ship line heap, so we can draw
35287               * them in part 12.
35288               *
35289               * Other entry points:
35290               *
35291               * LL81+2              Draw the contents of the ship line heap, used to draw
35292               * the ship as a dot from SHPPT
35293               *
35294               * ******************************************************************************
35295               
35296               LL80:
35297 A1B4 D0A0  30        movb @U,ry                      ; LDY U             ; Fetch the ship line heap pointer, which points to the
     A1B6 008F     
35298                                                                          ; next free byte on the heap, into Y
35299               
35300 A1B8 D020  30        movb @XX15,ra                   ; LDA XX15          ; Add X1 to the end of the heap
     A1BA 0031     
35301                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 A1BC D820  42        movb @XX19,@rtmplb
     A1BE 0074     
     A1C0 830D     
0002 A1C2 D1A0  30        movb @XX19+1,rtmp
     A1C4 0075     
0003 A1C6 A182  18        a    ry,rtmp
0004 A1C8 D580  30        movb RA,*rtmp
                   < elite.a99
35302               
35303 A1CA B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35304               
35305 A1CC D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Add Y1 to the end of the heap
     A1CE 0032     
35306                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 A1D0 D820  42        movb @XX19,@rtmplb
     A1D2 0074     
     A1D4 830D     
0002 A1D6 D1A0  30        movb @XX19+1,rtmp
     A1D8 0075     
0003 A1DA A182  18        a    ry,rtmp
0004 A1DC D580  30        movb RA,*rtmp
                   < elite.a99
35307               
35308 A1DE B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35309               
35310 A1E0 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Add X2 to the end of the heap
     A1E2 0033     
35311                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 A1E4 D820  42        movb @XX19,@rtmplb
     A1E6 0074     
     A1E8 830D     
0002 A1EA D1A0  30        movb @XX19+1,rtmp
     A1EC 0075     
0003 A1EE A182  18        a    ry,rtmp
0004 A1F0 D580  30        movb RA,*rtmp
                   < elite.a99
35312               
35313 A1F2 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35314               
35315 A1F4 D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Add Y2 to the end of the heap
     A1F6 0034     
35316                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 A1F8 D820  42        movb @XX19,@rtmplb
     A1FA 0074     
     A1FC 830D     
0002 A1FE D1A0  30        movb @XX19+1,rtmp
     A200 0075     
0003 A202 A182  18        a    ry,rtmp
0004 A204 D580  30        movb RA,*rtmp
                   < elite.a99
35317               
35318 A206 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35319               
35320 A208 D802  30        movb ry,@U                      ; STY U             ; Store the updated ship line heap pointer in U
     A20A 008F     
35321               
35322 A20C 90A0  30        cb   @T1,ry                     ; CPY T1            ; If Y >= T1 then we have reached the maximum number of
     A20E 0006     
35323 A210 1814  14        joc  LL81                       ; BCS LL81          ; edge lines that we can store in the ship line heap, so
35324                                                                          ; skip to LL81 so we don't loop back for the next edge
35325               
35326               LL78:
35327 A212 B004  18        ab   rone,ra                    ; INC XX17          ; Increment the edge counter to point to the next edge
35328               
35329 A214 D0A0  30        movb @XX17,ry                   ; LDY XX17          ; If Y >= XX20, which contains the number of edges in
     A216 0095     
35330 A218 90A0  30        cb   @XX20,ry                   ; CPY XX20          ; the blueprint, jump to LL81 as we have processed all
     A21A 00A8     
35331 A21C 180E  14        joc  LL81                       ; BCS LL81          ; the edges and don't need to loop back for the next one
35332               
35333 A21E 0202  20        li   ry,>00*256                 ; LDY #0            ; Set Y to point to byte #0 again, ready for the next
     A220 0000     
35334                                                                          ; edge
35335               
35336 A222 D020  30        movb @V,ra                      ; LDA V             ; Increment V by 4 so V(1 0) points to the data for the
     A224 0022     
35337                      .adi (>04*256)                  ; ADC #4            ; next edge
     **** ****     > ADI
0001 A226 1701  14        jnc  !
0002 A228 B004  18        ab   rone,ra
0003               !:
0004 A22A 0220  22        ai   ra,(>04*256)
     A22C 0400     
                   < elite.a99
35338 A22E D800  30        movb ra,@V                      ; STA V
     A230 0022     
35339               
35340 A232 1701  14        jnc  ll81_                      ; BCC ll81          ; If the above addition didn't overflow, jump to ll81 to
35341                                                                          ; skip the following instruction
35342               
35343 A234 B004  18        ab   rone,ra                    ; INC V+1           ; Otherwise increment the high byte of V(1 0), as we
35344                                                                          ; just moved the V(1 0) pointer past a page boundary
35345               
35346               ll81_:
35347 A236 0460  28        b    @LL75                      ; JMP LL75          ; Loop back to LL75 to process the next edge
     A238 A0F4     
35348               
35349               LL81:
35350                                                                          ; We have finished adding lines to the ship line heap,
35351                                                                          ; so now we need to set the first byte of the heap to
35352                                                                          ; the number of bytes stored there
35353 A23A D020  30        movb @U,ra                      ; LDA U             ; Fetch the ship line heap pointer from U into A, which
     A23C 008F     
35354                                                                          ; points to the end of the heap, and therefore contains
35355                                                                          ; the heap size
35356               
35357 A23E 0202  20        li   ry,>00*256                 ; LDY #0            ; Store A as the first byte of the ship line heap, so
     A240 0000     
35358                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; the heap is now correctly set up
     **** ****     > ST_IND_Y_IDX
0001 A242 D820  42        movb @XX19,@rtmplb
     A244 0074     
     A246 830D     
0002 A248 D1A0  30        movb @XX19+1,rtmp
     A24A 0075     
0003 A24C A182  18        a    ry,rtmp
0004 A24E D580  30        movb RA,*rtmp
                   < elite.a99
35359               
35360               * ******************************************************************************
35361               *
35362               * Name: LL9 (Part 12 of 12)
35363               * Type: Subroutine
35364               * Category: Drawing ships
35365               * Summary: Draw ship: Draw all the visible edges from the ship line heap
35366               * Deep dive: Drawing ships
35367               *
35368               * ------------------------------------------------------------------------------
35369               *
35370               * This part draws the lines in the ship line heap, which is used both to draw
35371               * the ship, and to remove it from the screen.
35372               *
35373               * ******************************************************************************
35374               
35375               LL155:
35376 A250 0202  20        li   ry,>00*256                 ; LDY #0            ; Fetch the first byte from the ship line heap into A,
     A252 0000     
35377                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; which contains the number of bytes in the heap
     **** ****     > LD_IND_Y_IDX
0001 A254 D820  42        movb @XX19,@rtmplb
     A256 0074     
     A258 830D     
0002 A25A D1A0  30        movb @XX19+1,rtmp
     A25C 0075     
0003 A25E A182  18        a    ry,rtmp
0004 A260 D016  26        movb *rtmp,RA
                   < elite.a99
35378               
35379 A262 D800  30        movb ra,@XX20                   ; STA XX20          ; Store the heap size in XX20
     A264 00A8     
35380               
35381 A266 0280  22        ci   ra,>04*256                 ; CMP #4            ; If the heap size is less than 4, there is nothing to
     A268 0400     
35382 A26A 1731  14        jnc  LL118-1                    ; BCC LL118-1       ; draw, so return from the subroutine (as LL118-1
35383                                                                          ; contains an RTS)
35384               
35385 A26C B084  18        ab   rone,ry                    ; INY               ; Set Y = 1, which we will use as an index into the ship
35386                                                                          ; line heap, starting at byte #1 (as byte #0 contains
35387                                                                          ; the heap size)
35388               
35389               LL27:
35390                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the X1 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 A26E D820  42        movb @XX19,@rtmplb
     A270 0074     
     A272 830D     
0002 A274 D1A0  30        movb @XX19+1,rtmp
     A276 0075     
0003 A278 A182  18        a    ry,rtmp
0004 A27A D016  26        movb *rtmp,RA
                   < elite.a99
35391 A27C D800  30        movb ra,@XX15                   ; STA XX15          ; it in XX15
     A27E 0031     
35392               
35393 A280 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35394               
35395                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y1 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 A282 D820  42        movb @XX19,@rtmplb
     A284 0074     
     A286 830D     
0002 A288 D1A0  30        movb @XX19+1,rtmp
     A28A 0075     
0003 A28C A182  18        a    ry,rtmp
0004 A28E D016  26        movb *rtmp,RA
                   < elite.a99
35396 A290 D800  30        movb ra,@XX15+1                 ; STA XX15+1        ; it in XX15+1
     A292 0032     
35397               
35398 A294 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35399               
35400                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the X2 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 A296 D820  42        movb @XX19,@rtmplb
     A298 0074     
     A29A 830D     
0002 A29C D1A0  30        movb @XX19+1,rtmp
     A29E 0075     
0003 A2A0 A182  18        a    ry,rtmp
0004 A2A2 D016  26        movb *rtmp,RA
                   < elite.a99
35401 A2A4 D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; it in XX15+2
     A2A6 0033     
35402               
35403 A2A8 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35404               
35405                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y2 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 A2AA D820  42        movb @XX19,@rtmplb
     A2AC 0074     
     A2AE 830D     
0002 A2B0 D1A0  30        movb @XX19+1,rtmp
     A2B2 0075     
0003 A2B4 A182  18        a    ry,rtmp
0004 A2B6 D016  26        movb *rtmp,RA
                   < elite.a99
35406 A2B8 D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; it in XX15+3
     A2BA 0034     
35407               
35408 A2BC 0206  20        li   rtmp,LL30                  ; JSR LL30          ; Draw a line from (X1, Y1) to (X2, Y2)
     A2BE 224E     
35409 A2C0 06A0  28        bl   @jsr                       ;
     A2C2 8002     
35410               
35411 A2C4 B084  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35412               
35413 A2C6 90A0  30        cb   @XX20,ry                   ; CPY XX20          ; If the heap counter is less than the size of the heap,
     A2C8 00A8     
35414 A2CA 17D1  14        jnc  LL27                       ; BCC LL27          ; loop back to LL27 to draw the next line from the heap
35415               
35416               * .LL82                  \ This label is commented out in the original source
35417               
35418 A2CC 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     A2CE 800E     
35419               
35420               * ******************************************************************************
35421               *
35422               * Name: LL118
35423               * Type: Subroutine
35424               * Category: Drawing lines
35425               * Summary: Move a point along a line until it is on-screen
35426               * Deep dive: Line-clipping
35427               *
35428               * ------------------------------------------------------------------------------
35429               *
35430               * Given a point (x1, y1), a gradient and a direction of slope, move the point
35431               * along the line until it is on-screen, so this effectively clips the (x1, y1)
35432               * end of a line to be on the screen.
35433               *
35434               * See the deep dive on "Line-clipping" for more details.
35435               *
35436               * ------------------------------------------------------------------------------
35437               *
35438               * Arguments:
35439               *
35440               * XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
35441               *
35442               * XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
35443               *
35444               * XX12+2              The line's gradient * 256 (so 1.0 = 256)
35445               *
35446               * XX12+3              The direction of slope:
35447               *
35448               * * Positive (bit 7 clear) = top left to bottom right
35449               *
35450               * * Negative (bit 7 set) = top right to bottom left
35451               *
35452               * T                   The gradient of slope:
35453               *
35454               * * 0 if it's a shallow slope
35455               *
35456               * * &FF if it's a steep slope
35457               *
35458               * ------------------------------------------------------------------------------
35459               *
35460               * Returns:
35461               *
35462               * XX15                x1 as an 8-bit coordinate
35463               *
35464               * XX15+2              y1 as an 8-bit coordinate
35465               *
35466               * ------------------------------------------------------------------------------
35467               *
35468               * Other entry points:
35469               *
35470               * LL118-1             Contains an RTS
35471               *
35472               * ******************************************************************************
35473               
35474               LL118:
35475 A2D0 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If x1_hi is positive, jump down to LL119 to skip the
     A2D2 0032     
35476 A2D4 151C  14        jgt  LL119                      ; BPL LL119         ; following
35477               
35478 A2D6 D800  30        movb ra,@S                      ; STA S             ; Otherwise x1_hi is negative, i.e. off the left of the
     A2D8 0092     
35479                                                                          ; screen, so set S = x1_hi
35480               
35481 A2DA 0206  20        li   rtmp,LL120                 ; JSR LL120         ; Call LL120 to calculate:
     A2DC A3EC     
35482 A2DE 06A0  28        bl   @jsr                       ;
     A2E0 8002     
35483                                                                          ;
35484                                                                          ; (Y X) = (S x1_lo) * XX12+2      if T = 0
35485                                                                          ; = x1 * gradient
35486                                                                          ;
35487                                                                          ; (Y X) = (S x1_lo) / XX12+2      if T <> 0
35488                                                                          ; = x1 / gradient
35489                                                                          ;
35490                                                                          ; with the sign of (Y X) set to the opposite of the
35491                                                                          ; line's direction of slope
35492               
35493 A2E2 D001  18        movb rx,ra                      ; TXA               ; Set y1 = y1 + (Y X)
35494                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 A2E4 0A13  18        sla  rzero,1
                   < elite.a99
35495                      .adc @XX15+2,ra                 ; ADC XX15+2        ; starting with the low bytes
     **** ****     > ADC
0001 A2E6 1701  14        jnc  !
0002 A2E8 B004  18        ab   rone,ra
0003               !:
0004 A2EA B020  30        ab   @XX15+2,ra
     A2EC 0033     
                   < elite.a99
35496 A2EE D800  30        movb ra,@XX15+2                 ; STA XX15+2
     A2F0 0033     
35497               
35498 A2F2 D002  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35499                      .adc @XX15+3,ra                 ; ADC XX15+3
     **** ****     > ADC
0001 A2F4 1701  14        jnc  !
0002 A2F6 B004  18        ab   rone,ra
0003               !:
0004 A2F8 B020  30        ab   @XX15+3,ra
     A2FA 0034     
                   < elite.a99
35500 A2FC D800  30        movb ra,@XX15+3                 ; STA XX15+3
     A2FE 0034     
35501               
35502 A300 0200  20        li   ra,>00*256                 ; LDA #0            ; Set x1 = 0
     A302 0000     
35503 A304 D800  30        movb ra,@XX15                   ; STA XX15
     A306 0031     
35504 A308 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     A30A 0032     
35505               
35506 A30C D040  18        movb ra,rx                      ; TAX               ; Set X = 0 so the next instruction becomes a JMP
35507               
35508               LL119:
35509 A30E 131D  14        jeq  LL134                      ; BEQ LL134         ; If x1_hi = 0 then jump down to LL134 to skip the
35510                                                                          ; following, as the x-coordinate is already on-screen
35511                                                                          ; (as 0 <= (x_hi x_lo) <= 255)
35512               
35513 A310 D800  30        movb ra,@S                      ; STA S             ; Otherwise x1_hi is positive, i.e. x1 >= 256 and off
     A312 0092     
35514 A314 7004  18        sb   rone,ra                    ; DEC S             ; the right side of the screen, so set S = x1_hi - 1
35515               
35516 A316 0206  20        li   rtmp,LL120                 ; JSR LL120         ; Call LL120 to calculate:
     A318 A3EC     
35517 A31A 06A0  28        bl   @jsr                       ;
     A31C 8002     
35518                                                                          ;
35519                                                                          ; (Y X) = (S x1_lo) * XX12+2      if T = 0
35520                                                                          ; = (x1 - 256) * gradient
35521                                                                          ;
35522                                                                          ; (Y X) = (S x1_lo) / XX12+2      if T <> 0
35523                                                                          ; = (x1 - 256) / gradient
35524                                                                          ;
35525                                                                          ; with the sign of (Y X) set to the opposite of the
35526                                                                          ; line's direction of slope
35527               
35528 A31E D001  18        movb rx,ra                      ; TXA               ; Set y1 = y1 + (Y X)
35529                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 A320 0A13  18        sla  rzero,1
                   < elite.a99
35530                      .adc @XX15+2,ra                 ; ADC XX15+2        ; starting with the low bytes
     **** ****     > ADC
0001 A322 1701  14        jnc  !
0002 A324 B004  18        ab   rone,ra
0003               !:
0004 A326 B020  30        ab   @XX15+2,ra
     A328 0033     
                   < elite.a99
35531 A32A D800  30        movb ra,@XX15+2                 ; STA XX15+2
     A32C 0033     
35532               
35533 A32E D002  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35534                      .adc @XX15+3,ra                 ; ADC XX15+3
     **** ****     > ADC
0001 A330 1701  14        jnc  !
0002 A332 B004  18        ab   rone,ra
0003               !:
0004 A334 B020  30        ab   @XX15+3,ra
     A336 0034     
                   < elite.a99
35535 A338 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     A33A 0034     
35536               
35537 A33C 0201  20        li   rx,>ff*256                 ; LDX #255          ; Set x1 = 255
     A33E FF00     
35538 A340 D801  30        movb rx,@XX15                   ; STX XX15
     A342 0031     
35539 A344 B044  18        ab   rone,rx                    ; INX
35540 A346 D801  30        movb rx,@XX15+1                 ; STX XX15+1
     A348 0032     
35541               
35542               LL134:
35543                                                                          ; We have moved the point so the x-coordinate is on
35544                                                                          ; screen (i.e. in the range 0-255), so now for the
35545                                                                          ; y-coordinate
35546 A34A D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; If y1_hi is positive, jump down to LL119 to skip
     A34C 0034     
35547 A34E 151F  14        jgt  LL135                      ; BPL LL135         ; the following
35548               
35549 A350 D800  30        movb ra,@S                      ; STA S             ; Otherwise y1_hi is negative, i.e. off the top of the
     A352 0092     
35550                                                                          ; screen, so set S = y1_hi
35551               
35552 A354 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set R = y1_lo
     A356 0033     
35553 A358 D800  30        movb ra,@R                      ; STA R
     A35A 0091     
35554               
35555 A35C 0206  20        li   rtmp,LL123                 ; JSR LL123         ; Call LL123 to calculate:
     A35E A478     
35556 A360 06A0  28        bl   @jsr                       ;
     A362 8002     
35557                                                                          ;
35558                                                                          ; (Y X) = (S R) / XX12+2      if T = 0
35559                                                                          ; = y1 / gradient
35560                                                                          ;
35561                                                                          ; (Y X) = (S R) * XX12+2      if T <> 0
35562                                                                          ; = y1 * gradient
35563                                                                          ;
35564                                                                          ; with the sign of (Y X) set to the opposite of the
35565                                                                          ; line's direction of slope
35566               
35567 A364 D001  18        movb rx,ra                      ; TXA               ; Set x1 = x1 + (Y X)
35568                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 A366 0A13  18        sla  rzero,1
                   < elite.a99
35569                      .adc @XX15,ra                   ; ADC XX15          ; starting with the low bytes
     **** ****     > ADC
0001 A368 1701  14        jnc  !
0002 A36A B004  18        ab   rone,ra
0003               !:
0004 A36C B020  30        ab   @XX15,ra
     A36E 0031     
                   < elite.a99
35570 A370 D800  30        movb ra,@XX15                   ; STA XX15
     A372 0031     
35571               
35572 A374 D002  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35573                      .adc @XX15+1,ra                 ; ADC XX15+1
     **** ****     > ADC
0001 A376 1701  14        jnc  !
0002 A378 B004  18        ab   rone,ra
0003               !:
0004 A37A B020  30        ab   @XX15+1,ra
     A37C 0032     
                   < elite.a99
35574 A37E D800  30        movb ra,@XX15+1                 ; STA XX15+1
     A380 0032     
35575               
35576 A382 0200  20        li   ra,>00*256                 ; LDA #0            ; Set y1 = 0
     A384 0000     
35577 A386 D800  30        movb ra,@XX15+2                 ; STA XX15+2
     A388 0033     
35578 A38A D800  30        movb ra,@XX15+3                 ; STA XX15+3
     A38C 0034     
35579               
35580               LL135:
35581               * BNE LL139              \ This instruction is commented out in the original
35582                                                                          ; source
35583 A38E D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set (S R) = (y1_hi y1_lo) - screen height
     A390 0033     
35584                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 A392 0A15  18        sla  rmone,1
                   < elite.a99
35585                      .sbi ((Y*2)*256)                ; SBC #Y*2          ; starting with the low bytes
     **** ****     > SBI
0001 A394 1801  14        joc  !
0002 A396 7004  18        sb   rone,ra
0003               !:
0004 A398 0220  22        ai   ra,-((Y*2)*256)
     A39A 4000     
                   < elite.a99
35586 A39C D800  30        movb ra,@R                      ; STA R
     A39E 0091     
35587               
35588 A3A0 D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; And then subtracting the high bytes
     A3A2 0034     
35589                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 A3A4 1801  14        joc  !
0002 A3A6 7004  18        sb   rone,ra
0003               !:
0004 A3A8 0220  22        ai   ra,-(>00*256)
     A3AA 0000     
                   < elite.a99
35590 A3AC D800  30        movb ra,@S                      ; STA S
     A3AE 0092     
35591               
35592 A3B0 171B  14        jnc  LL136                      ; BCC LL136         ; If the subtraction underflowed, i.e. if y1 < screen
35593                                                                          ; height, then y1 is already on-screen, so jump to LL136
35594                                                                          ; to return from the subroutine, as we are done
35595               
35596               LL139:
35597                                                                          ; If we get here then y1 >= screen height, i.e. off the
35598                                                                          ; bottom of the screen
35599 A3B2 0206  20        li   rtmp,LL123                 ; JSR LL123         ; Call LL123 to calculate:
     A3B4 A478     
35600 A3B6 06A0  28        bl   @jsr                       ;
     A3B8 8002     
35601                                                                          ;
35602                                                                          ; (Y X) = (S R) / XX12+2      if T = 0
35603                                                                          ; = (y1 - screen height) / gradient
35604                                                                          ;
35605                                                                          ; (Y X) = (S R) * XX12+2      if T <> 0
35606                                                                          ; = (y1 - screen height) * gradient
35607                                                                          ;
35608                                                                          ; with the sign of (Y X) set to the opposite of the
35609                                                                          ; line's direction of slope
35610               
35611 A3BA D001  18        movb rx,ra                      ; TXA               ; Set x1 = x1 + (Y X)
35612                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 A3BC 0A13  18        sla  rzero,1
                   < elite.a99
35613                      .adc @XX15,ra                   ; ADC XX15          ; starting with the low bytes
     **** ****     > ADC
0001 A3BE 1701  14        jnc  !
0002 A3C0 B004  18        ab   rone,ra
0003               !:
0004 A3C2 B020  30        ab   @XX15,ra
     A3C4 0031     
                   < elite.a99
35614 A3C6 D800  30        movb ra,@XX15                   ; STA XX15
     A3C8 0031     
35615               
35616 A3CA D002  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35617                      .adc @XX15+1,ra                 ; ADC XX15+1
     **** ****     > ADC
0001 A3CC 1701  14        jnc  !
0002 A3CE B004  18        ab   rone,ra
0003               !:
0004 A3D0 B020  30        ab   @XX15+1,ra
     A3D2 0032     
                   < elite.a99
35618 A3D4 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     A3D6 0032     
35619               
35620 A3D8 0200  20        li   ra,(Y*2-1)*256             ; LDA #Y*2-1        ; Set y1 = 2 * #Y - 1. The constant #Y is 96, the
     A3DA BF00     
35621 A3DC D800  30        movb ra,@XX15+2                 ; STA XX15+2        ; y-coordinate of the mid-point of the space view, so
     A3DE 0033     
35622 A3E0 0200  20        li   ra,>00*256                 ; LDA #0            ; this sets Y2 to 191, the y-coordinate of the bottom
     A3E2 0000     
35623 A3E4 D800  30        movb ra,@XX15+3                 ; STA XX15+3        ; pixel row of the space view
     A3E6 0034     
35624               
35625               LL136:
35626 A3E8 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     A3EA 800E     
35627               
35628               * ******************************************************************************
35629               *
35630               * Name: LL120
35631               * Type: Subroutine
35632               * Category: Maths (Arithmetic)
35633               * Summary: Calculate (Y X) = (S x1_lo) * XX12+2 or (S x1_lo) / XX12+2
35634               *
35635               * ------------------------------------------------------------------------------
35636               *
35637               * Calculate the following:
35638               *
35639               * * If T = 0, this is a shallow slope, so calculate (Y X) = (S x1_lo) * XX12+2
35640               *
35641               * * If T <> 0, this is a steep slope, so calculate (Y X) = (S x1_lo) / XX12+2
35642               *
35643               * giving (Y X) the opposite sign to the slope direction in XX12+3.
35644               *
35645               * ------------------------------------------------------------------------------
35646               *
35647               * Arguments:
35648               *
35649               * T                   The gradient of slope:
35650               *
35651               * * 0 if it's a shallow slope
35652               *
35653               * * &FF if it's a steep slope
35654               *
35655               * ------------------------------------------------------------------------------
35656               *
35657               * Other entry points:
35658               *
35659               * LL122               Calculate (Y X) = (S R) * Q and set the sign to the
35660               * opposite of the top byte on the stack
35661               *
35662               * ******************************************************************************
35663               
35664               LL120:
35665 A3EC D020  30        movb @XX15,ra                   ; LDA XX15          ; Set R = x1_lo
     A3EE 0031     
35666 A3F0 D800  30        movb ra,@R                      ; STA R
     A3F2 0091     
35667               
35668               * .LL120                 \ This label is commented out in the original source
35669               
35670 A3F4 0206  20        li   rtmp,LL129                 ; JSR LL129         ; Call LL129 to do the following:
     A3F6 A518     
35671 A3F8 06A0  28        bl   @jsr                       ;
     A3FA 8002     
35672                                                                          ;
35673                                                                          ; Q = XX12+2
35674                                                                          ; = line gradient
35675                                                                          ;
35676                                                                          ; A = S EOR XX12+3
35677                                                                          ; = S EOR slope direction
35678                                                                          ;
35679                                                                          ; (S R) = |S R|
35680                                                                          ;
35681                                                                          ; So A contains the sign of S * slope direction
35682               
35683                      .pha                            ; PHA               ; Store A on the stack so we can use it later
     **** ****     > PHA
0001 A3FC D680  30        movb ra,*rsp
0002 A3FE 060A  14        dec  rsp
                   < elite.a99
35684               
35685 A400 D060  30        movb @T,rx                      ; LDX T             ; If T is non-zero, then it's a steep slope, so jump
     A402 00D1     
35686 A404 1642  14        jne  LL121                      ; BNE LL121         ; down to LL121 to calculate this instead:
35687                                                                          ;
35688                                                                          ; (Y X) = (S R) / Q
35689               
35690               LL122:
35691                                                                          ; The following calculates:
35692                                                                          ;
35693                                                                          ; (Y X) = (S R) * Q
35694                                                                          ;
35695                                                                          ; using the same shift-and-add algorithm that's
35696                                                                          ; documented in MULT1
35697 A406 0200  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     A408 0000     
35698               
35699 A40A D040  18        movb ra,rx                      ; TAX               ; Set (Y X) = 0 so we can start building the answer here
35700 A40C D080  18        movb ra,ry                      ; TAY
35701               
35702                      .lsr @S                         ; LSR S             ; Shift (S R) to the right, so we extract bit 0 of (S R)
     **** ****     > LSR
0001 A40E D1A0  30        movb @S,rtmp
     A410 0092     
0002 A412 0916  18        srl  rtmp,1
0003 A414 D806  30        movb rtmp,@S
     A416 0092     
                   < elite.a99
35703 A418 0208  20        li   rarg1,R                    ; ROR R             ; into the C flag
     A41A 0091     
35704 A41C 06A0  28        bl   @ror                       ;
     A41E 8054     
35705               
35706                      .asl @Q                         ; ASL Q             ; Shift Q to the left, catching bit 7 in the C flag
     **** ****     > ASL
0001 A420 D1A0  30        movb @Q,rtmp
     A422 0090     
0002 A424 0246  22        andi rtmp,>ff00
     A426 FF00     
0003 A428 0A16  18        sla  rtmp,1
0004 A42A D806  30        movb rtmp,@Q
     A42C 0090     
                   < elite.a99
35707               
35708 A42E 170D  14        jnc  LL126                      ; BCC LL126         ; If C (i.e. the next bit from Q) is clear, do not do
35709                                                                          ; the addition for this bit of Q, and instead skip to
35710                                                                          ; LL126 to just do the shifts
35711               
35712               LL125:
35713 A430 D001  18        movb rx,ra                      ; TXA               ; Set (Y X) = (Y X) + (S R)
35714                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 A432 0A13  18        sla  rzero,1
                   < elite.a99
35715                      .adc @R,ra                      ; ADC R             ; starting with the low bytes
     **** ****     > ADC
0001 A434 1701  14        jnc  !
0002 A436 B004  18        ab   rone,ra
0003               !:
0004 A438 B020  30        ab   @R,ra
     A43A 0091     
                   < elite.a99
35716 A43C D040  18        movb ra,rx                      ; TAX
35717               
35718 A43E D002  18        movb ry,ra                      ; TYA               ; And then doing the high bytes
35719                      .adc @S,ra                      ; ADC S
     **** ****     > ADC
0001 A440 1701  14        jnc  !
0002 A442 B004  18        ab   rone,ra
0003               !:
0004 A444 B020  30        ab   @S,ra
     A446 0092     
                   < elite.a99
35720 A448 D080  18        movb ra,ry                      ; TAY
35721               
35722               LL126:
35723                      .lsr @S                         ; LSR S             ; Shift (S R) to the right
     **** ****     > LSR
0001 A44A D1A0  30        movb @S,rtmp
     A44C 0092     
0002 A44E 0916  18        srl  rtmp,1
0003 A450 D806  30        movb rtmp,@S
     A452 0092     
                   < elite.a99
35724 A454 0208  20        li   rarg1,R                    ; ROR R
     A456 0091     
35725 A458 06A0  28        bl   @ror                       ;
     A45A 8054     
35726               
35727                      .asl @Q                         ; ASL Q             ; Shift Q to the left, catching bit 7 in the C flag
     **** ****     > ASL
0001 A45C D1A0  30        movb @Q,rtmp
     A45E 0090     
0002 A460 0246  22        andi rtmp,>ff00
     A462 FF00     
0003 A464 0A16  18        sla  rtmp,1
0004 A466 D806  30        movb rtmp,@Q
     A468 0090     
                   < elite.a99
35728               
35729 A46A 18E2  14        joc  LL125                      ; BCS LL125         ; If C (i.e. the next bit from Q) is set, loop back to
35730                                                                          ; LL125 to do the addition for this bit of Q
35731               
35732 A46C 16EE  14        jne  LL126                      ; BNE LL126         ; If Q has not yet run out of set bits, loop back to
35733                                                                          ; LL126 to do the "shift" part of shift-and-add until
35734                                                                          ; we have done additions for all the set bits in Q, to
35735                                                                          ; give us our multiplication result
35736               
35737                      .pla                            ; PLA               ; Restore A, which we calculated above, from the stack
     **** ****     > PLA
0001 A46E 058A  14        inc  rsp
0002 A470 D01A  26        movb *rsp,ra
                   < elite.a99
35738               
35739 A472 153E  14        jgt  LL133                      ; BPL LL133         ; If A is positive jump to LL133 to negate (Y X) and
35740                                                                          ; return from the subroutine using a tail call
35741               
35742 A474 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     A476 800E     
35743               
35744               * ******************************************************************************
35745               *
35746               * Name: LL123
35747               * Type: Subroutine
35748               * Category: Maths (Arithmetic)
35749               * Summary: Calculate (Y X) = (S R) / XX12+2 or (S R) * XX12+2
35750               *
35751               * ------------------------------------------------------------------------------
35752               *
35753               * Calculate the following:
35754               *
35755               * * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2
35756               *
35757               * * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2
35758               *
35759               * giving (Y X) the opposite sign to the slope direction in XX12+3.
35760               *
35761               * ------------------------------------------------------------------------------
35762               *
35763               * Arguments:
35764               *
35765               * XX12+2              The line's gradient * 256 (so 1.0 = 256)
35766               *
35767               * XX12+3              The direction of slope:
35768               *
35769               * * Bit 7 clear means top left to bottom right
35770               *
35771               * * Bit 7 set means top right to bottom left
35772               *
35773               * T                   The gradient of slope:
35774               *
35775               * * 0 if it's a shallow slope
35776               *
35777               * * &FF if it's a steep slope
35778               *
35779               * ------------------------------------------------------------------------------
35780               *
35781               * Other entry points:
35782               *
35783               * LL121               Calculate (Y X) = (S R) / Q and set the sign to the
35784               * opposite of the top byte on the stack
35785               *
35786               * LL133               Negate (Y X) and return from the subroutine
35787               *
35788               * LL128               Contains an RTS
35789               *
35790               * ******************************************************************************
35791               
35792               LL123:
35793 A478 0206  20        li   rtmp,LL129                 ; JSR LL129         ; Call LL129 to do the following:
     A47A A518     
35794 A47C 06A0  28        bl   @jsr                       ;
     A47E 8002     
35795                                                                          ;
35796                                                                          ; Q = XX12+2
35797                                                                          ; = line gradient
35798                                                                          ;
35799                                                                          ; A = S EOR XX12+3
35800                                                                          ; = S EOR slope direction
35801                                                                          ;
35802                                                                          ; (S R) = |S R|
35803                                                                          ;
35804                                                                          ; So A contains the sign of S * slope direction
35805               
35806                      .pha                            ; PHA               ; Store A on the stack so we can use it later
     **** ****     > PHA
0001 A480 D680  30        movb ra,*rsp
0002 A482 060A  14        dec  rsp
                   < elite.a99
35807               
35808 A484 D060  30        movb @T,rx                      ; LDX T             ; If T is non-zero, then it's a steep slope, so jump up
     A486 00D1     
35809 A488 16BE  14        jne  LL122                      ; BNE LL122         ; to LL122 to calculate this instead:
35810                                                                          ;
35811                                                                          ; (Y X) = (S R) * Q
35812               
35813               LL121:
35814                                                                          ; The following calculates:
35815                                                                          ;
35816                                                                          ; (Y X) = (S R) / Q
35817                                                                          ;
35818                                                                          ; using the same shift-and-subtract algorithm that's
35819                                                                          ; documented in TIS2
35820 A48A 0200  20        li   ra,>ff*256                 ; LDA #%11111111    ; Set Y = %11111111
     A48C FF00     
35821 A48E D080  18        movb ra,ry                      ; TAY
35822               
35823                      .asla                           ; ASL A             ; Set X = %11111110
     **** ****     > ASLA
0001 A490 0240  22        andi ra,>ff00
     A492 FF00     
0002 A494 0A10  18        sla  ra,1
                   < elite.a99
35824 A496 D040  18        movb ra,rx                      ; TAX
35825               
35826                                                                          ; This sets (Y X) = %1111111111111110, so we can rotate
35827                                                                          ; through 15 loop iterations, getting a 1 each time, and
35828                                                                          ; then getting a 0 on the 16th iteration... and we can
35829                                                                          ; also use it to catch our result bits into bit 0 each
35830                                                                          ; time
35831               
35832               LL130:
35833                      .asl @R                         ; ASL R             ; Shift (S R) to the left
     **** ****     > ASL
0001 A498 D1A0  30        movb @R,rtmp
     A49A 0091     
0002 A49C 0246  22        andi rtmp,>ff00
     A49E FF00     
0003 A4A0 0A16  18        sla  rtmp,1
0004 A4A2 D806  30        movb rtmp,@R
     A4A4 0091     
                   < elite.a99
35834 A4A6 0208  20        li   rarg1,S                    ; ROL S
     A4A8 0092     
35835 A4AA 06A0  28        bl   @rol                       ;
     A4AC 8028     
35836               
35837 A4AE D020  30        movb @S,ra                      ; LDA S             ; Set A = S
     A4B0 0092     
35838               
35839 A4B2 1803  14        joc  LL131                      ; BCS LL131         ; If bit 7 of S was set, then jump straight to the
35840                                                                          ; subtraction
35841               
35842 A4B4 9020  30        cb   @Q,ra                      ; CMP Q             ; If A < Q (i.e. S < Q), skip the following subtractions
     A4B6 0090     
35843 A4B8 170F  14        jnc  LL132                      ; BCC LL132
35844               
35845               LL131:
35846                      .sbc @Q,ra                      ; SBC Q             ; A >= Q (i.e. S >= Q) so set:
     **** ****     > SBC
0001 A4BA 1801  14        joc  !
0002 A4BC 7004  18        sb   rone,ra
0003               !:
0004 A4BE 7020  30        sb   @Q,ra
     A4C0 0090     
                   < elite.a99
35847 A4C2 D800  30        movb ra,@S                      ; STA S             ;
     A4C4 0092     
35848                                                                          ; S = (A R) - Q
35849                                                                          ; = (S R) - Q
35850                                                                          ;
35851                                                                          ; starting with the low bytes (we know the C flag is
35852                                                                          ; set so the subtraction will be correct)
35853               
35854 A4C6 D020  30        movb @R,ra                      ; LDA R             ; And then doing the high bytes
     A4C8 0091     
35855                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 A4CA 1801  14        joc  !
0002 A4CC 7004  18        sb   rone,ra
0003               !:
0004 A4CE 0220  22        ai   ra,-(>00*256)
     A4D0 0000     
                   < elite.a99
35856 A4D2 D800  30        movb ra,@R                      ; STA R
     A4D4 0091     
35857               
35858                      .sec                            ; SEC               ; Set the C flag to rotate into the result in (Y X)
     **** ****     > SEC
0001 A4D6 0A15  18        sla  rmone,1
                   < elite.a99
35859               
35860               LL132:
35861 A4D8 D001  18        movb rx,ra                      ; TXA               ; Rotate the counter in (Y X) to the left, and catch the
35862 A4DA 06A0  28        bl   @rola                      ; ROL A             ; result bit into bit 0 (which will be a 0 if we didn't
     A4DC 8018     
35863 A4DE D040  18        movb ra,rx                      ; TAX               ; do the subtraction, or 1 if we did)
35864 A4E0 D002  18        movb ry,ra                      ; TYA
35865 A4E2 06A0  28        bl   @rola                      ; ROL A
     A4E4 8018     
35866 A4E6 D080  18        movb ra,ry                      ; TAY
35867               
35868 A4E8 18D7  14        joc  LL130                      ; BCS LL130         ; If we still have set bits in (Y X), loop back to LL130
35869                                                                          ; to do the next iteration of 15, until we have done the
35870                                                                          ; whole division
35871               
35872                      .pla                            ; PLA               ; Restore A, which we calculated above, from the stack
     **** ****     > PLA
0001 A4EA 058A  14        inc  rsp
0002 A4EC D01A  26        movb *rsp,ra
                   < elite.a99
35873               
35874 A4EE 1112  14        jlt  LL128                      ; BMI LL128         ; If A is negative jump to LL128 to return from the
35875                                                                          ; subroutine with (Y X) as is
35876               
35877               LL133:
35878 A4F0 D001  18        movb rx,ra                      ; TXA               ; Otherwise negate (Y X) using two's complement by first
35879                      .eoi (>ff*256)                  ; EOR #%11111111    ; setting the low byte to ~X + 1
     **** ****     > EOI
0001 A4F2 0206  20        li   rtmp,(>FF*256)
     A4F4 FF00     
0002 A4F6 2806  18        xor  rtmp,ra
                   < elite.a99
35880               * CLC                    \
35881                      .adi (>01*256)                  ; ADC #1            ; The CLC instruction is commented out in the original
     **** ****     > ADI
0001 A4F8 1701  14        jnc  !
0002 A4FA B004  18        ab   rone,ra
0003               !:
0004 A4FC 0220  22        ai   ra,(>01*256)
     A4FE 0100     
                   < elite.a99
35882 A500 D040  18        movb ra,rx                      ; TAX               ; source. It would have no effect as we know the C flag
35883                                                                          ; is clear from when we passed through the BCS above
35884               
35885 A502 D002  18        movb ry,ra                      ; TYA               ; Then set the high byte to ~Y + C
35886                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 A504 0206  20        li   rtmp,(>FF*256)
     A506 FF00     
0002 A508 2806  18        xor  rtmp,ra
                   < elite.a99
35887                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 A50A 1701  14        jnc  !
0002 A50C B004  18        ab   rone,ra
0003               !:
0004 A50E 0220  22        ai   ra,(>00*256)
     A510 0000     
                   < elite.a99
35888 A512 D080  18        movb ra,ry                      ; TAY
35889               
35890               LL128:
35891 A514 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     A516 800E     
35892               
35893               * ******************************************************************************
35894               *
35895               * Name: LL129
35896               * Type: Subroutine
35897               * Category: Maths (Arithmetic)
35898               * Summary: Calculate Q = XX12+2, A = S EOR XX12+3 and (S R) = |S R|
35899               *
35900               * ------------------------------------------------------------------------------
35901               *
35902               * Do the following, in this order:
35903               *
35904               * Q = XX12+2
35905               *
35906               * A = S EOR XX12+3
35907               *
35908               * (S R) = |S R|
35909               *
35910               * This sets up the variables required above to calculate (S R) / XX12+2 and give
35911               * the result the opposite sign to XX13+3.
35912               *
35913               * ******************************************************************************
35914               
35915               LL129:
35916 A518 D060  30        movb @XX12+2,rx                 ; LDX XX12+2        ; Set Q = XX12+2
     A51A 0039     
35917 A51C D801  30        movb rx,@Q                      ; STX Q
     A51E 0090     
35918               
35919 A520 D020  30        movb @S,ra                      ; LDA S             ; If S is positive, jump to LL127
     A522 0092     
35920 A524 1518  14        jgt  LL127                      ; BPL LL127
35921               
35922 A526 0200  20        li   ra,>00*256                 ; LDA #0            ; Otherwise set R = -R
     A528 0000     
35923                      .sec                            ; SEC
     **** ****     > SEC
0001 A52A 0A15  18        sla  rmone,1
                   < elite.a99
35924                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 A52C 1801  14        joc  !
0002 A52E 7004  18        sb   rone,ra
0003               !:
0004 A530 7020  30        sb   @R,ra
     A532 0091     
                   < elite.a99
35925 A534 D800  30        movb ra,@R                      ; STA R
     A536 0091     
35926               
35927 A538 D020  30        movb @S,ra                      ; LDA S             ; Push S onto the stack
     A53A 0092     
35928                      .pha                            ; PHA
     **** ****     > PHA
0001 A53C D680  30        movb ra,*rsp
0002 A53E 060A  14        dec  rsp
                   < elite.a99
35929               
35930                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set S = ~S + 1 + C
     **** ****     > EOI
0001 A540 0206  20        li   rtmp,(>FF*256)
     A542 FF00     
0002 A544 2806  18        xor  rtmp,ra
                   < elite.a99
35931                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 A546 1701  14        jnc  !
0002 A548 B004  18        ab   rone,ra
0003               !:
0004 A54A 0220  22        ai   ra,(>00*256)
     A54C 0000     
                   < elite.a99
35932 A54E D800  30        movb ra,@S                      ; STA S
     A550 0092     
35933               
35934                      .pla                            ; PLA               ; Pull the original, negative S from the stack into A
     **** ****     > PLA
0001 A552 058A  14        inc  rsp
0002 A554 D01A  26        movb *rsp,ra
                   < elite.a99
35935               
35936               LL127:
35937                      .eor @XX12+3                    ; EOR XX12+3        ; Set A = original argument S EOR'd with XX12+3
     **** ****     > EOR
0001 A556 D1A0  30        movb @XX12+3,rtmp
     A558 003A     
0002 A55A 2806  18        xor  rtmp,ra
                   < elite.a99
35938               
35939 A55C 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     A55E 800E     
35940               
35941               * ******************************************************************************
35942               *
35943               * Name: LL145 (Part 1 of 4)
35944               * Type: Subroutine
35945               * Category: Drawing lines
35946               * Summary: Clip line: Work out which end-points are on-screen, if any
35947               * Deep dive: Line-clipping
35948               * Extended screen coordinates
35949               *
35950               * ------------------------------------------------------------------------------
35951               *
35952               * This routine clips the line from (x1, y1) to (x2, y2) so it fits on-screen, or
35953               * returns an error if it can't be clipped to fit. The arguments are 16-bit
35954               * coordinates, and the clipped line is returned using 8-bit screen coordinates.
35955               *
35956               * This part sets XX13 to reflect which of the two points are on-screen and
35957               * off-screen.
35958               *
35959               * ------------------------------------------------------------------------------
35960               *
35961               * Arguments:
35962               *
35963               * XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
35964               *
35965               * XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
35966               *
35967               * XX15(5 4)           x2 as a 16-bit coordinate (x2_hi x2_lo)
35968               *
35969               * XX12(1 0)           y2 as a 16-bit coordinate (y2_hi y2_lo)
35970               *
35971               * ------------------------------------------------------------------------------
35972               *
35973               * Returns:
35974               *
35975               * (X1, Y1)            Screen coordinate of the start of the clipped line
35976               *
35977               * (X2, Y2)            Screen coordinate of the end of the clipped line
35978               *
35979               * C flag              Clear if the clipped line fits on-screen, set if it
35980               * doesn't
35981               *
35982               * XX13                The state of the original coordinates on-screen:
35983               *
35984               * * 0   = (x2, y2) on-screen
35985               *
35986               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
35987               *
35988               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
35989               *
35990               * So XX13 is non-zero if the end of the line was clipped,
35991               * meaning the next line sent to BLINE can't join onto the
35992               * end but has to start a new segment
35993               *
35994               * SWAP                The swap status of the returned coordinates:
35995               *
35996               * * &FF if we swapped the values of (x1, y1) and
35997               * (x2, y2) as part of the clipping process
35998               *
35999               * * 0 if the coordinates are still in the same order
36000               *
36001               * Y                   Y is preserved
36002               *
36003               * ------------------------------------------------------------------------------
36004               *
36005               * Other entry points:
36006               *
36007               * LL147               Don't initialise the values in SWAP or A
36008               *
36009               * ******************************************************************************
36010               
36011               LL145:
36012 A560 0200  20        li   ra,>00*256                 ; LDA #0            ; Set SWAP = 0
     A562 0000     
36013 A564 D800  30        movb ra,@SWAP                   ; STA SWAP
     A566 00A1     
36014               
36015 A568 D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A = x2_hi
     A56A 0036     
36016               
36017               LL147:
36018 A56C 0201  20        li   rx,(Y*2-1)*256             ; LDX #Y*2-1        ; Set X = #Y * 2 - 1. The constant #Y is 96, the
     A56E BF00     
36019                                                                          ; y-coordinate of the mid-point of the space view, so
36020                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
36021                                                                          ; pixel row of the space view
36022               
36023 A570 F020  30        socb @XX12+1,ra                 ; ORA XX12+1        ; If one or both of x2_hi and y2_hi are non-zero, jump
     A572 0038     
36024 A574 1605  14        jne  LL107                      ; BNE LL107         ; to LL107 to skip the following, leaving X at 191
36025               
36026 A576 9060  30        cb   @XX12,rx                   ; CPX XX12          ; If y2_lo > the y-coordinate of the bottom of screen
     A578 0037     
36027 A57A 1702  14        jnc  LL107                      ; BCC LL107         ; then (x2, y2) is off the bottom of the screen, so skip
36028                                                                          ; the following instruction, leaving X at 191
36029               
36030 A57C 0201  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0
     A57E 0000     
36031               
36032               LL107:
36033 A580 D801  30        movb rx,@XX13                   ; STX XX13          ; Set XX13 = X, so we have:
     A582 0098     
36034                                                                          ;
36035                                                                          ; * XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen
36036                                                                          ;
36037                                                                          ; * XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo
36038                                                                          ; is off the bottom of the screen
36039                                                                          ;
36040                                                                          ; In other words, XX13 is 191 if (x2, y2) is off-screen,
36041                                                                          ; otherwise it is 0
36042               
36043 A584 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If one or both of x1_hi and y1_hi are non-zero, jump
     A586 0032     
36044 A588 F020  30        socb @XX15+3,ra                 ; ORA XX15+3        ; to LL83
     A58A 0034     
36045 A58C 161F  14        jne  LL83                       ; BNE LL83
36046               
36047 A58E 0200  20        li   ra,(Y*2-1)*256             ; LDA #Y*2-1        ; If y1_lo > the y-coordinate of the bottom of screen
     A590 BF00     
36048 A592 9020  30        cb   @XX15+2,ra                 ; CMP XX15+2        ; then (x1, y1) is off the bottom of the screen, so jump
     A594 0033     
36049 A596 171A  14        jnc  LL83                       ; BCC LL83          ; to LL83
36050               
36051                                                                          ; If we get here, (x1, y1) is on-screen
36052               
36053 A598 D020  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 is non-zero, i.e. (x2, y2) is off-screen, jump
     A59A 0098     
36054 A59C 1612  14        jne  LL108                      ; BNE LL108         ; to LL108 to halve it before continuing at LL83
36055               
36056                                                                          ; If we get here, the high bytes are all zero, which
36057                                                                          ; means the x-coordinates are < 256 and therefore fit on
36058                                                                          ; screen, and neither coordinate is off the bottom of
36059                                                                          ; the screen. That means both coordinates are already on
36060                                                                          ; screen, so we don't need to do any clipping, all we
36061                                                                          ; need to do is move the low bytes into (X1, Y1) and
36062                                                                          ; X2, Y2) and return
36063               
36064               LL146:
36065                                                                          ; If we get here then we have clipped our line to the
36066                                                                          ; screen edge (if we had to clip it at all), so we move
36067                                                                          ; the low bytes from (x1, y1) and (x2, y2) into (X1, Y1)
36068                                                                          ; and (X2, Y2), remembering that they share locations
36069                                                                          ; with XX15:
36070                                                                          ;
36071                                                                          ; X1 = XX15
36072                                                                          ; Y1 = XX15+1
36073                                                                          ; X2 = XX15+2
36074                                                                          ; Y2 = XX15+3
36075                                                                          ;
36076                                                                          ; X1 already contains x1_lo, so now we do the rest
36077 A59E D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set Y1 (aka XX15+1) = y1_lo
     A5A0 0033     
36078 A5A2 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     A5A4 0032     
36079               
36080 A5A6 D020  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set X2 (aka XX15+2) = x2_lo
     A5A8 0035     
36081 A5AA D800  30        movb ra,@XX15+2                 ; STA XX15+2
     A5AC 0033     
36082               
36083 A5AE D020  30        movb @XX12,ra                   ; LDA XX12          ; Set Y2 (aka XX15+3) = y2_lo
     A5B0 0037     
36084 A5B2 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     A5B4 0034     
36085               
36086                      .clc                            ; CLC               ; Clear the C flag as the clipped line fits on-screen
     **** ****     > CLC
0001 A5B6 0A13  18        sla  rzero,1
                   < elite.a99
36087               
36088 A5B8 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     A5BA 800E     
36089               
36090               LL109:
36091                      .sec                            ; SEC               ; Set the C flag to indicate the clipped line does not
     **** ****     > SEC
0001 A5BC 0A15  18        sla  rmone,1
                   < elite.a99
36092                                                                          ; fit on-screen
36093               
36094 A5BE 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     A5C0 800E     
36095               
36096               LL108:
36097                      .lsr @XX13                      ; LSR XX13          ; If we get here then (x2, y2) is off-screen and XX13 is
     **** ****     > LSR
0001 A5C2 D1A0  30        movb @XX13,rtmp
     A5C4 0098     
0002 A5C6 0916  18        srl  rtmp,1
0003 A5C8 D806  30        movb rtmp,@XX13
     A5CA 0098     
                   < elite.a99
36098                                                                          ; 191, so shift XX13 right to halve it to 95
36099               
36100               * ******************************************************************************
36101               *
36102               * Name: LL145 (Part 2 of 4)
36103               * Type: Subroutine
36104               * Category: Drawing lines
36105               * Summary: Clip line: Work out if any part of the line is on-screen
36106               * Deep dive: Line-clipping
36107               * Extended screen coordinates
36108               *
36109               * ------------------------------------------------------------------------------
36110               *
36111               * This part does a number of tests to see if the line is on or off the screen.
36112               *
36113               * If we get here then at least one of (x1, y1) and (x2, y2) is off-screen, with
36114               * XX13 set as follows:
36115               *
36116               * * 0   = (x1, y1) off-screen, (x2, y2) on-screen
36117               *
36118               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
36119               *
36120               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
36121               *
36122               * where "off-screen" is defined as having a non-zero high byte in one of the
36123               * coordinates, or in the case of y-coordinates, having a low byte > 191, the
36124               * y-coordinate of the bottom of the space view.
36125               *
36126               * ******************************************************************************
36127               
36128               LL83:
36129 A5CC D020  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 < 128 then only one of the points is on-screen
     A5CE 0098     
36130 A5D0 1533  14        jgt  LL115                      ; BPL LL115         ; so jump down to LL115 to skip the checks of whether
36131                                                                          ; both points are in the strips to the right or bottom
36132                                                                          ; of the screen
36133               
36134                                                                          ; If we get here, both points are off-screen
36135               
36136 A5D2 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If both x1_hi and x2_hi have bit 7 set, jump to LL109
     A5D4 0032     
36137                      .and @XX15+5                    ; AND XX15+5        ; to return from the subroutine with the C flag set, as
     **** ****     > AND
0001 A5D6 D1A0  30        movb @XX15+5,rtmp
     A5D8 0036     
0002 A5DA 0546  14        inv  rtmp
0003 A5DC 5006  18        szcb rtmp,ra
                   < elite.a99
36138 A5DE 11EE  14        jlt  LL109                      ; BMI LL109         ; the entire line is above the top of the screen
36139               
36140 A5E0 D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; If both y1_hi and y2_hi have bit 7 set, jump to LL109
     A5E2 0034     
36141                      .and @XX12+1                    ; AND XX12+1        ; to return from the subroutine with the C flag set, as
     **** ****     > AND
0001 A5E4 D1A0  30        movb @XX12+1,rtmp
     A5E6 0038     
0002 A5E8 0546  14        inv  rtmp
0003 A5EA 5006  18        szcb rtmp,ra
                   < elite.a99
36142 A5EC 11E7  14        jlt  LL109                      ; BMI LL109         ; the entire line is to the left of the screen
36143               
36144 A5EE D060  30        movb @XX15+1,rx                 ; LDX XX15+1        ; Set A = X = x1_hi - 1
     A5F0 0032     
36145 A5F2 7044  18        sb   rone,rx                    ; DEX
36146 A5F4 D001  18        movb rx,ra                      ; TXA
36147               
36148 A5F6 D060  30        movb @XX15+5,rx                 ; LDX XX15+5        ; Set XX12+2 = x2_hi - 1
     A5F8 0036     
36149 A5FA 7044  18        sb   rone,rx                    ; DEX
36150 A5FC D801  30        movb rx,@XX12+2                 ; STX XX12+2
     A5FE 0039     
36151               
36152 A600 F020  30        socb @XX12+2,ra                 ; ORA XX12+2        ; If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set,
     A602 0039     
36153 A604 15DB  14        jgt  LL109                      ; BPL LL109         ; jump to LL109 to return from the subroutine with the C
36154                                                                          ; flag set, as the line doesn't fit on-screen
36155               
36156 A606 D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If y1_lo < y-coordinate of screen bottom, clear the C
     A608 0033     
36157 A60A 0280  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; flag, otherwise set it
     A60C C000     
36158               
36159 A60E D020  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set XX12+2 = y1_hi - (1 - C), so:
     A610 0034     
36160                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 A612 1801  14        joc  !
0002 A614 7004  18        sb   rone,ra
0003               !:
0004 A616 0220  22        ai   ra,-(>00*256)
     A618 0000     
                   < elite.a99
36161 A61A D800  30        movb ra,@XX12+2                 ; STA XX12+2        ; * Set XX12+2 = y1_hi - 1 if y1_lo is on-screen
     A61C 0039     
36162                                                                          ; * Set XX12+2 = y1_hi     otherwise
36163                                                                          ;
36164                                                                          ; We do this subtraction because we are only interested
36165                                                                          ; in trying to move the points up by a screen if that
36166                                                                          ; might move the point into the space view portion of
36167                                                                          ; the screen, i.e. if y1_lo is on-screen
36168               
36169 A61E D020  30        movb @XX12,ra                   ; LDA XX12          ; If y2_lo < y-coordinate of screen bottom, clear the C
     A620 0037     
36170 A622 0280  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; flag, otherwise set it
     A624 C000     
36171               
36172 A626 D020  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set XX12+2 = y2_hi - (1 - C), so:
     A628 0038     
36173                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 A62A 1801  14        joc  !
0002 A62C 7004  18        sb   rone,ra
0003               !:
0004 A62E 0220  22        ai   ra,-(>00*256)
     A630 0000     
                   < elite.a99
36174                                                                          ; * Set XX12+1 = y2_hi - 1 if y2_lo is on-screen
36175                                                                          ; * Set XX12+1 = y2_hi     otherwise
36176                                                                          ;
36177                                                                          ; We do this subtraction because we are only interested
36178                                                                          ; in trying to move the points up by a screen if that
36179                                                                          ; might move the point into the space view portion of
36180                                                                          ; the screen, i.e. if y1_lo is on-screen
36181               
36182 A632 F020  30        socb @XX12+2,ra                 ; ORA XX12+2        ; If neither XX12+1 or XX12+2 have bit 7 set, jump to
     A634 0039     
36183 A636 15C2  14        jgt  LL109                      ; BPL LL109         ; LL109 to return from the subroutine with the C flag
36184                                                                          ; set, as the line doesn't fit on-screen
36185               
36186               * ******************************************************************************
36187               *
36188               * Name: LL145 (Part 3 of 4)
36189               * Type: Subroutine
36190               * Category: Drawing lines
36191               * Summary: Clip line: Calculate the line's gradient
36192               * Deep dive: Line-clipping
36193               * Extended screen coordinates
36194               *
36195               * ******************************************************************************
36196               
36197               LL115:
36198 A638 D002  18        movb ry,ra                      ; TYA               ; Store Y on the stack so we can preserve it through the
36199                      .pha                            ; PHA               ; call to this subroutine
     **** ****     > PHA
0001 A63A D680  30        movb ra,*rsp
0002 A63C 060A  14        dec  rsp
                   < elite.a99
36200               
36201 A63E D020  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set XX12+2 = x2_lo - x1_lo
     A640 0035     
36202                      .sec                            ; SEC
     **** ****     > SEC
0001 A642 0A15  18        sla  rmone,1
                   < elite.a99
36203                      .sbc @XX15,ra                   ; SBC XX15
     **** ****     > SBC
0001 A644 1801  14        joc  !
0002 A646 7004  18        sb   rone,ra
0003               !:
0004 A648 7020  30        sb   @XX15,ra
     A64A 0031     
                   < elite.a99
36204 A64C D800  30        movb ra,@XX12+2                 ; STA XX12+2
     A64E 0039     
36205               
36206 A650 D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set XX12+3 = x2_hi - x1_hi
     A652 0036     
36207                      .sbc @XX15+1,ra                 ; SBC XX15+1
     **** ****     > SBC
0001 A654 1801  14        joc  !
0002 A656 7004  18        sb   rone,ra
0003               !:
0004 A658 7020  30        sb   @XX15+1,ra
     A65A 0032     
                   < elite.a99
36208 A65C D800  30        movb ra,@XX12+3                 ; STA XX12+3
     A65E 003A     
36209               
36210 A660 D020  30        movb @XX12,ra                   ; LDA XX12          ; Set XX12+4 = y2_lo - y1_lo
     A662 0037     
36211                      .sec                            ; SEC
     **** ****     > SEC
0001 A664 0A15  18        sla  rmone,1
                   < elite.a99
36212                      .sbc @XX15+2,ra                 ; SBC XX15+2
     **** ****     > SBC
0001 A666 1801  14        joc  !
0002 A668 7004  18        sb   rone,ra
0003               !:
0004 A66A 7020  30        sb   @XX15+2,ra
     A66C 0033     
                   < elite.a99
36213 A66E D800  30        movb ra,@XX12+4                 ; STA XX12+4
     A670 003B     
36214               
36215 A672 D020  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set XX12+5 = y2_hi - y1_hi
     A674 0038     
36216                      .sbc @XX15+3,ra                 ; SBC XX15+3
     **** ****     > SBC
0001 A676 1801  14        joc  !
0002 A678 7004  18        sb   rone,ra
0003               !:
0004 A67A 7020  30        sb   @XX15+3,ra
     A67C 0034     
                   < elite.a99
36217 A67E D800  30        movb ra,@XX12+5                 ; STA XX12+5
     A680 003C     
36218               
36219                                                                          ; So we now have:
36220                                                                          ;
36221                                                                          ; delta_x in XX12(3 2)
36222                                                                          ; delta_y in XX12(5 4)
36223                                                                          ;
36224                                                                          ; where the delta is (x1, y1) - (x2, y2))
36225               
36226                      .eor @XX12+3                    ; EOR XX12+3        ; Set S = the sign of delta_x * the sign of delta_y, so
     **** ****     > EOR
0001 A682 D1A0  30        movb @XX12+3,rtmp
     A684 003A     
0002 A686 2806  18        xor  rtmp,ra
                   < elite.a99
36227 A688 D800  30        movb ra,@S                      ; STA S             ; if bit 7 of S is set, the deltas have different signs
     A68A 0092     
36228               
36229 A68C D020  30        movb @XX12+5,ra                 ; LDA XX12+5        ; If delta_y_hi is positive, jump down to LL110 to skip
     A68E 003C     
36230 A690 1511  14        jgt  LL110                      ; BPL LL110         ; the following
36231               
36232 A692 0200  20        li   ra,>00*256                 ; LDA #0            ; Otherwise flip the sign of delta_y to make it
     A694 0000     
36233                      .sec                            ; SEC               ; positive, starting with the low bytes
     **** ****     > SEC
0001 A696 0A15  18        sla  rmone,1
                   < elite.a99
36234                      .sbc @XX12+4,ra                 ; SBC XX12+4
     **** ****     > SBC
0001 A698 1801  14        joc  !
0002 A69A 7004  18        sb   rone,ra
0003               !:
0004 A69C 7020  30        sb   @XX12+4,ra
     A69E 003B     
                   < elite.a99
36235 A6A0 D800  30        movb ra,@XX12+4                 ; STA XX12+4
     A6A2 003B     
36236               
36237 A6A4 0200  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so now:
     A6A6 0000     
36238                      .sbc @XX12+5,ra                 ; SBC XX12+5        ;
     **** ****     > SBC
0001 A6A8 1801  14        joc  !
0002 A6AA 7004  18        sb   rone,ra
0003               !:
0004 A6AC 7020  30        sb   @XX12+5,ra
     A6AE 003C     
                   < elite.a99
36239 A6B0 D800  30        movb ra,@XX12+5                 ; STA XX12+5        ; XX12(5 4) = |delta_y|
     A6B2 003C     
36240               
36241               LL110:
36242 A6B4 D020  30        movb @XX12+3,ra                 ; LDA XX12+3        ; If delta_x_hi is positive, jump down to LL111 to skip
     A6B6 003A     
36243 A6B8 150F  14        jgt  LL111                      ; BPL LL111         ; the following
36244               
36245                      .sec                            ; SEC               ; Otherwise flip the sign of delta_x to make it
     **** ****     > SEC
0001 A6BA 0A15  18        sla  rmone,1
                   < elite.a99
36246 A6BC 0200  20        li   ra,>00*256                 ; LDA #0            ; positive, starting with the low bytes
     A6BE 0000     
36247                      .sbc @XX12+2,ra                 ; SBC XX12+2
     **** ****     > SBC
0001 A6C0 1801  14        joc  !
0002 A6C2 7004  18        sb   rone,ra
0003               !:
0004 A6C4 7020  30        sb   @XX12+2,ra
     A6C6 0039     
                   < elite.a99
36248 A6C8 D800  30        movb ra,@XX12+2                 ; STA XX12+2
     A6CA 0039     
36249               
36250 A6CC 0200  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so now:
     A6CE 0000     
36251                      .sbc @XX12+3,ra                 ; SBC XX12+3        ;
     **** ****     > SBC
0001 A6D0 1801  14        joc  !
0002 A6D2 7004  18        sb   rone,ra
0003               !:
0004 A6D4 7020  30        sb   @XX12+3,ra
     A6D6 003A     
                   < elite.a99
36252                                                                          ; (A XX12+2) = |delta_x|
36253               
36254               LL111:
36255                                                                          ; We now keep halving |delta_x| and |delta_y| until
36256                                                                          ; both of them have zero in their high bytes
36257 A6D8 D040  18        movb ra,rx                      ; TAX               ; If |delta_x_hi| is non-zero, skip the following
36258 A6DA 1603  14        jne  LL112                      ; BNE LL112
36259               
36260 A6DC D060  30        movb @XX12+5,rx                 ; LDX XX12+5        ; If |delta_y_hi| = 0, jump down to LL113 (as both
     A6DE 003C     
36261 A6E0 1310  14        jeq  LL113                      ; BEQ LL113         ; |delta_x_hi| and |delta_y_hi| are 0)
36262               
36263               LL112:
36264 A6E2 0910  18        srl  ra,1                       ; LSR A             ; Halve the value of delta_x in (A XX12+2)
36265 A6E4 0208  20        li   rarg1,XX12+2               ; ROR XX12+2
     A6E6 0039     
36266 A6E8 06A0  28        bl   @ror                       ;
     A6EA 8054     
36267               
36268                      .lsr @XX12+5                    ; LSR XX12+5        ; Halve the value of delta_y XX12(5 4)
     **** ****     > LSR
0001 A6EC D1A0  30        movb @XX12+5,rtmp
     A6EE 003C     
0002 A6F0 0916  18        srl  rtmp,1
0003 A6F2 D806  30        movb rtmp,@XX12+5
     A6F4 003C     
                   < elite.a99
36269 A6F6 0208  20        li   rarg1,XX12+4               ; ROR XX12+4
     A6F8 003B     
36270 A6FA 06A0  28        bl   @ror                       ;
     A6FC 8054     
36271               
36272 A6FE 0460  28        b    @LL111                     ; JMP LL111         ; Loop back to LL111
     A700 A6D8     
36273               
36274               LL113:
36275                                                                          ; By now, the high bytes of both |delta_x| and |delta_y|
36276                                                                          ; are zero
36277 A702 D801  30        movb rx,@T                      ; STX T             ; We know that X = 0 as that's what we tested with a BEQ
     A704 00D1     
36278                                                                          ; above, so this sets T = 0
36279               
36280 A706 D020  30        movb @XX12+2,ra                 ; LDA XX12+2        ; If delta_x_lo < delta_y_lo, so our line is more
     A708 0039     
36281 A70A 9020  30        cb   @XX12+4,ra                 ; CMP XX12+4        ; vertical than horizontal, jump to LL114
     A70C 003B     
36282 A70E 170A  14        jnc  LL114                      ; BCC LL114
36283               
36284                                                                          ; If we get here then our line is more horizontal than
36285                                                                          ; vertical, so it is a shallow slope
36286               
36287 A710 D800  30        movb ra,@Q                      ; STA Q             ; Set Q = delta_x_lo
     A712 0090     
36288               
36289 A714 D020  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set A = delta_y_lo
     A716 003B     
36290               
36291 A718 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     A71A 9338     
36292 A71C 06A0  28        bl   @jsr                       ;
     A71E 8002     
36293                                                                          ;
36294                                                                          ; R = 256 * A / Q
36295                                                                          ; = 256 * delta_y_lo / delta_x_lo
36296               
36297 A720 0460  28        b    @LL116                     ; JMP LL116         ; Jump to LL116, as we now have the line's gradient in R
     A722 A73A     
36298               
36299               LL114:
36300                                                                          ; If we get here then our line is more vertical than
36301                                                                          ; horizontal, so it is a steep slope
36302 A724 D020  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set Q = delta_y_lo
     A726 003B     
36303 A728 D800  30        movb ra,@Q                      ; STA Q
     A72A 0090     
36304 A72C D020  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set A = delta_x_lo
     A72E 0039     
36305               
36306 A730 0206  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     A732 9338     
36307 A734 06A0  28        bl   @jsr                       ;
     A736 8002     
36308                                                                          ;
36309                                                                          ; R = 256 * A / Q
36310                                                                          ; = 256 * delta_x_lo / delta_y_lo
36311               
36312 A738 7004  18        sb   rone,ra                    ; DEC T             ; T was set to 0 above, so this sets T = &FF when our
36313                                                                          ; line is steep
36314               
36315               * ******************************************************************************
36316               *
36317               * Name: LL145 (Part 4 of 4)
36318               * Type: Subroutine
36319               * Category: Drawing lines
36320               * Summary: Clip line: Call the routine in LL188 to do the actual clipping
36321               * Deep dive: Line-clipping
36322               * Extended screen coordinates
36323               *
36324               * ------------------------------------------------------------------------------
36325               *
36326               * This part sets things up to call the routine in LL188, which does the actual
36327               * clipping.
36328               *
36329               * If we get here, then R has been set to the gradient of the line (x1, y1) to
36330               * (x2, y2), with T indicating the gradient of slope:
36331               *
36332               * * 0   = shallow slope (more horizontal than vertical)
36333               *
36334               * * &FF = steep slope (more vertical than horizontal)
36335               *
36336               * and XX13 has been set as follows:
36337               *
36338               * * 0   = (x1, y1) off-screen, (x2, y2) on-screen
36339               *
36340               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
36341               *
36342               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
36343               *
36344               * ******************************************************************************
36345               
36346               LL116:
36347 A73A D020  30        movb @R,ra                      ; LDA R             ; Store the gradient in XX12+2
     A73C 0091     
36348 A73E D800  30        movb ra,@XX12+2                 ; STA XX12+2
     A740 0039     
36349               
36350 A742 D020  30        movb @S,ra                      ; LDA S             ; Store the type of slope in XX12+3, bit 7 clear means
     A744 0092     
36351 A746 D800  30        movb ra,@XX12+3                 ; STA XX12+3        ; top left to bottom right, bit 7 set means top right to
     A748 003A     
36352                                                                          ; bottom left
36353               
36354 A74A D020  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 = 0, skip the following instruction
     A74C 0098     
36355 A74E 1301  14        jeq  LL138                      ; BEQ LL138
36356               
36357 A750 1511  14        jgt  LLX117                     ; BPL LLX117        ; If XX13 is positive, it must be 95. This means
36358                                                                          ; (x1, y1) is on-screen but (x2, y2) isn't, so we jump
36359                                                                          ; to LLX117 to swap the (x1, y1) and (x2, y2)
36360                                                                          ; coordinates around before doing the actual clipping,
36361                                                                          ; because we need to clip (x2, y2) but the clipping
36362                                                                          ; routine at LL118 only clips (x1, y1)
36363               
36364               LL138:
36365                                                                          ; If we get here, XX13 = 0 or 191, so (x1, y1) is
36366                                                                          ; off-screen and needs clipping
36367 A752 0206  20        li   rtmp,LL118                 ; JSR LL118         ; Call LL118 to move (x1, y1) along the line onto the
     A754 A2D0     
36368 A756 06A0  28        bl   @jsr                       ;
     A758 8002     
36369                                                                          ; screen, i.e. clip the line at the (x1, y1) end
36370               
36371 A75A D020  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to
     A75C 0098     
36372 A75E 152F  14        jgt  LL124                      ; BPL LL124         ; LL124 to return with a successfully clipped line
36373               
36374               LL117:
36375                                                                          ; If we get here, XX13 = 191 (both coordinates are
36376                                                                          ; off-screen)
36377 A760 D020  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If either of x1_hi or y1_hi are non-zero, jump to
     A762 0032     
36378 A764 F020  30        socb @XX15+3,ra                 ; ORA XX15+3        ; LL137 to return from the subroutine with the C flag
     A766 0034     
36379 A768 162F  14        jne  LL137                      ; BNE LL137         ; set, as the line doesn't fit on-screen
36380               
36381 A76A D020  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If y1_lo > y-coordinate of the bottom of the screen
     A76C 0033     
36382 A76E 0280  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; jump to LL137 to return from the subroutine with the
     A770 C000     
36383 A772 182A  14        joc  LL137                      ; BCS LL137         ; C flag set, as the line doesn't fit on-screen
36384               
36385               LLX117:
36386                                                                          ; If we get here, XX13 = 95 or 191, and in both cases
36387                                                                          ; (x2, y2) is off-screen, so we now need to swap the
36388                                                                          ; (x1, y1) and (x2, y2) coordinates around before doing
36389                                                                          ; the actual clipping, because we need to clip (x2, y2)
36390                                                                          ; but the clipping routine at LL118 only clips (x1, y1)
36391 A774 D060  30        movb @XX15,rx                   ; LDX XX15          ; Swap x1_lo = x2_lo
     A776 0031     
36392 A778 D020  30        movb @XX15+4,ra                 ; LDA XX15+4
     A77A 0035     
36393 A77C D800  30        movb ra,@XX15                   ; STA XX15
     A77E 0031     
36394 A780 D801  30        movb rx,@XX15+4                 ; STX XX15+4
     A782 0035     
36395               
36396 A784 D020  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Swap x2_lo = x1_lo
     A786 0036     
36397 A788 D060  30        movb @XX15+1,rx                 ; LDX XX15+1
     A78A 0032     
36398 A78C D801  30        movb rx,@XX15+5                 ; STX XX15+5
     A78E 0036     
36399 A790 D800  30        movb ra,@XX15+1                 ; STA XX15+1
     A792 0032     
36400               
36401 A794 D060  30        movb @XX15+2,rx                 ; LDX XX15+2        ; Swap y1_lo = y2_lo
     A796 0033     
36402 A798 D020  30        movb @XX12,ra                   ; LDA XX12
     A79A 0037     
36403 A79C D800  30        movb ra,@XX15+2                 ; STA XX15+2
     A79E 0033     
36404 A7A0 D801  30        movb rx,@XX12                   ; STX XX12
     A7A2 0037     
36405               
36406 A7A4 D020  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Swap y2_lo = y1_lo
     A7A6 0038     
36407 A7A8 D060  30        movb @XX15+3,rx                 ; LDX XX15+3
     A7AA 0034     
36408 A7AC D801  30        movb rx,@XX12+1                 ; STX XX12+1
     A7AE 0038     
36409 A7B0 D800  30        movb ra,@XX15+3                 ; STA XX15+3
     A7B2 0034     
36410               
36411 A7B4 0206  20        li   rtmp,LL118                 ; JSR LL118         ; Call LL118 to move (x1, y1) along the line onto the
     A7B6 A2D0     
36412 A7B8 06A0  28        bl   @jsr                       ;
     A7BA 8002     
36413                                                                          ; screen, i.e. clip the line at the (x1, y1) end
36414               
36415 A7BC 7004  18        sb   rone,ra                    ; DEC SWAP          ; Set SWAP = &FF to indicate that we just clipped the
36416                                                                          ; line at the (x2, y2) end by swapping the coordinates
36417                                                                          ; (the DEC does this as we set SWAP to 0 at the start of
36418                                                                          ; this subroutine)
36419               
36420               LL124:
36421                      .pla                            ; PLA               ; Restore Y from the stack so it gets preserved through
     **** ****     > PLA
0001 A7BE 058A  14        inc  rsp
0002 A7C0 D01A  26        movb *rsp,ra
                   < elite.a99
36422 A7C2 D080  18        movb ra,ry                      ; TAY               ; the call to this subroutine
36423               
36424 A7C4 0460  28        b    @LL146                     ; JMP LL146         ; Jump up to LL146 to move the low bytes of (x1, y1) and
     A7C6 A59E     
36425                                                                          ; (x2, y2) into (X1, Y1) and (X2, Y2), and return from
36426                                                                          ; the subroutine with a successfully clipped line
36427               
36428               LL137:
36429                      .pla                            ; PLA               ; Restore Y from the stack so it gets preserved through
     **** ****     > PLA
0001 A7C8 058A  14        inc  rsp
0002 A7CA D01A  26        movb *rsp,ra
                   < elite.a99
36430 A7CC D080  18        movb ra,ry                      ; TAY               ; the call to this subroutine
36431               
36432                      .sec                            ; SEC               ; Set the C flag to indicate the clipped line does not
     **** ****     > SEC
0001 A7CE 0A15  18        sla  rmone,1
                   < elite.a99
36433                                                                          ; fit on-screen
36434               
36435 A7D0 0460  24        b    @rts                       ; RTS               ; Return from the subroutine
     A7D2 800E     
36436               
36437               * ******************************************************************************
36438               *
36439               * Save ELTG.bin
36440               *
36441               * ******************************************************************************
36442               
36443                      ; PRINT "ELITE G"
36444                      ; PRINT "Assembled at ", ~CODE_G%
36445                      ; PRINT "Ends at ", ~P%
36446                      ; PRINT "Code size is ", ~(P% - CODE_G%)
36447                      ; PRINT "Execute at ", ~LOAD%
36448                      ; PRINT "Reload at ", ~LOAD_G%
36449               
36450                      ; PRINT "S.ELTG ", ~CODE_G%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_G%
36451                      ; SAVE "3-assembled-output/ELTG.bin", CODE_G%, P%, LOAD%
36452               
36453               * ******************************************************************************
36454               *
36455               * Name: checksum0
36456               * Type: Variable
36457               * Category: Copy protection
36458               * Summary: Checksum for the entire main game code
36459               *
36460               * ------------------------------------------------------------------------------
36461               *
36462               * This byte contains a checksum for the entire main game code. It is populated
36463               * by elite-checksum.py and is used by the encryption checks in elite-loader.asm
36464               * (see the CHK routine in the loader for more details).
36465               *
36466               * ******************************************************************************
36467               
36468               checksum0_:
36469 A7D4                 bss 1                                               ; This value is checked against the calculated checksum
36470                                                                          ; in part 6 of the loader in elite-loader.asm
36471               
36472               * ******************************************************************************
36473               *
36474               * ELITE SHIP BLUEPRINTS FILE
36475               *
36476               * Produces the binary file SHIPS.bin that gets loaded by elite-bcfs.asm.
36477               *
36478               * ******************************************************************************
36479               
36480               CODE_SHIPS.:
36481                      equ $
36482               
36483               LOAD_SHIPS.:
36484                      equ LOAD. + $ - CODE.
36485               
36486               * ******************************************************************************
36487               *
36488               * Name: XX21
36489               * Type: Variable
36490               * Category: Drawing ships
36491               * Summary: Ship blueprints lookup table
36492               * Deep dive: Ship blueprints
36493               *
36494               * ******************************************************************************
36495               
36496               XX21:
36497 A7D6 A7F0            data SHIP_SIDEWINDER                                ; 1 = Sidewinder
36498 A7D8 A89A            data SHIP_VIPER                                     ; COPS =  2 = Viper
36499 A7DA A976            data SHIP_MAMBA                                     ; 3 = Mamba
36500 A7DC 7F00            data SHIP_PYTHON                                    ; 4 = Python
36501 A7DE AAA6            data SHIP_COBRA_MK_3                                ; 5 = Cobra Mk III (bounty hunter)
36502 A7E0 AC30            data SHIP_THARGOID                                  ; THG  =  6 = Thargoid
36503 A7E2 AAA6            data SHIP_COBRA_MK_3                                ; CYL  =  7 = Cobra Mk III (trader)
36504 A7E4 AD4E            data SHIP_CORIOLIS                                  ; SST  =  8 = Coriolis space station
36505 A7E6 AE6C            data SHIP_MISSILE                                   ; MSL  =  9 = Missile
36506 A7E8 AF6C            data SHIP_ASTEROID                                  ; AST  = 10 = Asteroid
36507 A7EA B044            data SHIP_CANISTER                                  ; OIL  = 11 = Cargo canister
36508 A7EC B0EE            data SHIP_THARGON                                   ; TGL  = 12 = Thargon
36509 A7EE B15C            data SHIP_ESCAPE_POD                                ; ESC  = 13 = Escape pod
36510               
36511               * ******************************************************************************
36512               *
36513               * Name: VERTEX
36514               * Type: Macro
36515               * Category: Drawing ships
36516               * Summary: Macro definition for adding vertices to ship blueprints
36517               * Deep dive: Ship blueprints
36518               *
36519               * ------------------------------------------------------------------------------
36520               *
36521               * The following macro is used to build the ship blueprints:
36522               *
36523               * VERTEX x, y, z, face1, face2, face3, face4, visibility
36524               *
36525               * See the deep dive on "Ship blueprints" for details of how vertices are stored
36526               * in the ship blueprints, and the deep dive on "Drawing ships" for information
36527               * on how vertices are used to draw 3D wireframe ships.
36528               *
36529               * ------------------------------------------------------------------------------
36530               *
36531               * Arguments:
36532               *
36533               * x                   The vertex's x-coordinate
36534               *
36535               * y                   The vertex's y-coordinate
36536               *
36537               * z                   The vertex's z-coordinate
36538               *
36539               * face1               The number of face 1 associated with this vertex
36540               *
36541               * face2               The number of face 2 associated with this vertex
36542               *
36543               * face3               The number of face 3 associated with this vertex
36544               *
36545               * face4               The number of face 4 associated with this vertex
36546               *
36547               * visibility          The visibility distance, beyond which the vertex is not
36548               * shown
36549               *
36550               * ******************************************************************************
36551               
36552                      ; MACRO VERTEX x, y, z, face1, face2, face3, face4, visibility
36553               
36554                      ; IF x < 0                      ;
36555                      ; s_x = 1 << 7                  ;
36556                      ; ELSE                          ;
36557                      ; s_x = 0                       ;
36558                      ; ENDIF                         ;
36559               
36560                      ; IF y < 0                      ;
36561                      ; s_y = 1 << 6                  ;
36562                      ; ELSE                          ;
36563                      ; s_y = 0                       ;
36564                      ; ENDIF                         ;
36565               
36566                      ; IF z < 0                      ;
36567                      ; s_z = 1 << 5                  ;
36568                      ; ELSE                          ;
36569                      ; s_z = 0                       ;
36570                      ; ENDIF                         ;
36571               
36572                      ; s = s_x + s_y + s_z + visibility ;
36573                      ; f1 = face1 + (face2 << 4)     ;
36574                      ; f2 = face3 + (face4 << 4)     ;
36575                      ; ax = ABS(x)                   ;
36576                      ; ay = ABS(y)                   ;
36577                      ; az = ABS(z)                   ;
36578               
36579                      ; EQUB ax, ay, az, s, f1, f2    ;
36580               
36581                      ; ENDMACRO
36582               
36583               * ******************************************************************************
36584               *
36585               * Name: EDGE
36586               * Type: Macro
36587               * Category: Drawing ships
36588               * Summary: Macro definition for adding edges to ship blueprints
36589               * Deep dive: Ship blueprints
36590               *
36591               * ------------------------------------------------------------------------------
36592               *
36593               * The following macro is used to build the ship blueprints:
36594               *
36595               * EDGE vertex1, vertex2, face1, face2, visibility
36596               *
36597               * See the deep dive on "Ship blueprints" for details of how edges are stored
36598               * in the ship blueprints, and the deep dive on "Drawing ships" for information
36599               * on how edges are used to draw 3D wireframe ships.
36600               *
36601               * ------------------------------------------------------------------------------
36602               *
36603               * Arguments:
36604               *
36605               * vertex1             The number of the vertex at the start of the edge
36606               *
36607               * vertex1             The number of the vertex at the end of the edge
36608               *
36609               * face1               The number of face 1 associated with this edge
36610               *
36611               * face2               The number of face 2 associated with this edge
36612               *
36613               * visibility          The visibility distance, beyond which the edge is not
36614               * shown
36615               *
36616               * ******************************************************************************
36617               
36618                      ; MACRO EDGE vertex1, vertex2, face1, face2, visibility
36619               
36620                      ; f = face1 + (face2 << 4)      ;
36621                      ; EQUB visibility, f, vertex1 << 2, vertex2 << 2 ;
36622               
36623                      ; ENDMACRO
36624               
36625               * ******************************************************************************
36626               *
36627               * Name: FACE
36628               * Type: Macro
36629               * Category: Drawing ships
36630               * Summary: Macro definition for adding faces to ship blueprints
36631               * Deep dive: Ship blueprints
36632               *
36633               * ------------------------------------------------------------------------------
36634               *
36635               * The following macro is used to build the ship blueprints:
36636               *
36637               * FACE normal_x, normal_y, normal_z, visibility
36638               *
36639               * See the deep dive on "Ship blueprints" for details of how faces are stored
36640               * in the ship blueprints, and the deep dive on "Drawing ships" for information
36641               * on how faces are used to draw 3D wireframe ships.
36642               *
36643               * ------------------------------------------------------------------------------
36644               *
36645               * Arguments:
36646               *
36647               * normal_x            The face normal's x-coordinate
36648               *
36649               * normal_y            The face normal's y-coordinate
36650               *
36651               * normal_z            The face normal's z-coordinate
36652               *
36653               * visibility          The visibility distance, beyond which the edge is always
36654               * shown
36655               *
36656               * ******************************************************************************
36657               
36658                      ; MACRO FACE normal_x, normal_y, normal_z, visibility
36659               
36660                      ; IF normal_x < 0               ;
36661                      ; s_x = 1 << 7                  ;
36662                      ; ELSE                          ;
36663                      ; s_x = 0                       ;
36664                      ; ENDIF                         ;
36665               
36666                      ; IF normal_y < 0               ;
36667                      ; s_y = 1 << 6                  ;
36668                      ; ELSE                          ;
36669                      ; s_y = 0                       ;
36670                      ; ENDIF                         ;
36671               
36672                      ; IF normal_z < 0               ;
36673                      ; s_z = 1 << 5                  ;
36674                      ; ELSE                          ;
36675                      ; s_z = 0                       ;
36676                      ; ENDIF                         ;
36677               
36678                      ; s = s_x + s_y + s_z + visibility ;
36679                      ; ax = ABS(normal_x)            ;
36680                      ; ay = ABS(normal_y)            ;
36681                      ; az = ABS(normal_z)            ;
36682               
36683                      ; EQUB s, ax, ay, az            ;
36684               
36685                      ; ENDMACRO
36686               
36687               * ******************************************************************************
36688               *
36689               * Name: SHIP_SIDEWINDER
36690               * Type: Variable
36691               * Category: Drawing ships
36692               * Summary: Ship blueprint for a Sidewinder
36693               * Deep dive: Ship blueprints
36694               *
36695               * ******************************************************************************
36696               
36697               SHIP_SIDEWINDER:
36698 A7F0 00              byte >00                                            ; Max. canisters on demise = 0
36699 A7F2 1081            data 65 * 65                                        ; Targetable area          = 65 * 65
36700               
36701 A7F4 52              byte (SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)%256  ; Edges data offset (low)
36702 A7F5   8E            byte (SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)%256  ; Faces data offset (low)
36703               
36704 A7F6 3D              byte >3d                                            ; Max. edge count          = (61 - 1) / 4 = 15
36705 A7F7   00            byte >00                                            ; Gun vertex               = 0
36706 A7F8 1E              byte >1e                                            ; Explosion count          = 6, as (4 * n) + 6 = 30
36707 A7F9   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
36708 A7FA 0F              byte >0f                                            ; Number of edges          = 15
36709 A7FC 3200            data >3200                                          ; Bounty                   = 50
36710 A7FE 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
36711 A7FF   14            byte >14                                            ; Visibility distance      = 20
36712 A800 46              byte >46                                            ; Max. energy              = 70
36713 A801   25            byte >25                                            ; Max. speed               = 37
36714               
36715 A802 00              byte (SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)/256  ; Edges data offset (high)
36716 A803   00            byte (SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)/256  ; Faces data offset (high)
36717               
36718 A804 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
36719 A805   10            byte >10                                            ; Laser power              = 2
36720                                                                          ; Missiles                 = 0
36721               
36722               SHIP_SIDEWINDER_VERTICES:
36723                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36724 A806 2000            byte >20, >00, >24, >9f, >10, >54                   ; Vertex 0
     A808 249F     
     A80A 1054     
36725 A80C 2000            byte >20, >00, >24, >1f, >20, >65                   ; Vertex 1
     A80E 241F     
     A810 2065     
36726 A812 4000            byte >40, >00, >1c, >3f, >32, >66                   ; Vertex 2
     A814 1C3F     
     A816 3266     
36727 A818 4000            byte >40, >00, >1c, >bf, >31, >44                   ; Vertex 3
     A81A 1CBF     
     A81C 3144     
36728 A81E 0010            byte >00, >10, >1c, >3f, >10, >32                   ; Vertex 4
     A820 1C3F     
     A822 1032     
36729 A824 0010            byte >00, >10, >1c, >7f, >43, >65                   ; Vertex 5
     A826 1C7F     
     A828 4365     
36730 A82A 0C06            byte >0c, >06, >1c, >af, >33, >33                   ; Vertex 6
     A82C 1CAF     
     A82E 3333     
36731 A830 0C06            byte >0c, >06, >1c, >2f, >33, >33                   ; Vertex 7
     A832 1C2F     
     A834 3333     
36732 A836 0C06            byte >0c, >06, >1c, >6c, >33, >33                   ; Vertex 8
     A838 1C6C     
     A83A 3333     
36733 A83C 0C06            byte >0c, >06, >1c, >ec, >33, >33                   ; Vertex 9
     A83E 1CEC     
     A840 3333     
36734               
36735               SHIP_SIDEWINDER_EDGES:
36736                                                                          ; vertex1, vertex2, face1, face2, visibility
36737 A842 1F50            byte >1f, >50, >00, >04                             ; Edge 0
     A844 0004     
36738 A846 1F62            byte >1f, >62, >04, >08                             ; Edge 1
     A848 0408     
36739 A84A 1F20            byte >1f, >20, >04, >10                             ; Edge 2
     A84C 0410     
36740 A84E 1F10            byte >1f, >10, >00, >10                             ; Edge 3
     A850 0010     
36741 A852 1F41            byte >1f, >41, >00, >0c                             ; Edge 4
     A854 000C     
36742 A856 1F31            byte >1f, >31, >0c, >10                             ; Edge 5
     A858 0C10     
36743 A85A 1F32            byte >1f, >32, >08, >10                             ; Edge 6
     A85C 0810     
36744 A85E 1F43            byte >1f, >43, >0c, >14                             ; Edge 7
     A860 0C14     
36745 A862 1F63            byte >1f, >63, >08, >14                             ; Edge 8
     A864 0814     
36746 A866 1F65            byte >1f, >65, >04, >14                             ; Edge 9
     A868 0414     
36747 A86A 1F54            byte >1f, >54, >00, >14                             ; Edge 10
     A86C 0014     
36748 A86E 0F33            byte >0f, >33, >18, >1c                             ; Edge 11
     A870 181C     
36749 A872 0C33            byte >0c, >33, >1c, >20                             ; Edge 12
     A874 1C20     
36750 A876 0C33            byte >0c, >33, >18, >24                             ; Edge 13
     A878 1824     
36751 A87A 0C33            byte >0c, >33, >20, >24                             ; Edge 14
     A87C 2024     
36752               
36753               SHIP_SIDEWINDER_FACES:
36754                                                                          ; normal_x, normal_y, normal_z, visibility
36755 A87E 1F00            byte >1f, >00, >20, >08                             ; Face 0
     A880 2008     
36756 A882 9F0C            byte >9f, >0c, >2f, >06                             ; Face 1
     A884 2F06     
36757 A886 1F0C            byte >1f, >0c, >2f, >06                             ; Face 2
     A888 2F06     
36758 A88A 3F00            byte >3f, >00, >00, >70                             ; Face 3
     A88C 0070     
36759 A88E DF0C            byte >df, >0c, >2f, >06                             ; Face 4
     A890 2F06     
36760 A892 5F00            byte >5f, >00, >20, >08                             ; Face 5
     A894 2008     
36761 A896 5F0C            byte >5f, >0c, >2f, >06                             ; Face 6
     A898 2F06     
36762               
36763               * ******************************************************************************
36764               *
36765               * Name: SHIP_VIPER
36766               * Type: Variable
36767               * Category: Drawing ships
36768               * Summary: Ship blueprint for a Viper
36769               * Deep dive: Ship blueprints
36770               *
36771               * ******************************************************************************
36772               
36773               SHIP_VIPER:
36774 A89A 00              byte >00                                            ; Max. canisters on demise = 0
36775 A89C 15F9            data 75 * 75                                        ; Targetable area          = 75 * 75
36776               
36777 A89E 70              byte (SHIP_VIPER_EDGES - SHIP_VIPER)%256            ; Edges data offset (low)
36778 A89F   C0            byte (SHIP_VIPER_FACES - SHIP_VIPER)%256            ; Faces data offset (low)
36779               
36780 A8A0 4D              byte >4d                                            ; Max. edge count          = (77 - 1) / 4 = 19
36781 A8A1   00            byte >00                                            ; Gun vertex               = 0
36782 A8A2 2A              byte >2a                                            ; Explosion count          = 9, as (4 * n) + 6 = 42
36783 A8A3   5A            byte >5a                                            ; Number of vertices       = 90 / 6 = 15
36784 A8A4 14              byte >14                                            ; Number of edges          = 20
36785 A8A6 0000            data >0000                                          ; Bounty                   = 0
36786 A8A8 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
36787 A8A9   17            byte >17                                            ; Visibility distance      = 23
36788 A8AA 78              byte >78                                            ; Max. energy              = 120
36789 A8AB   20            byte >20                                            ; Max. speed               = 32
36790               
36791 A8AC 00              byte (SHIP_VIPER_EDGES - SHIP_VIPER)/256            ; Edges data offset (high)
36792 A8AD   00            byte (SHIP_VIPER_FACES - SHIP_VIPER)/256            ; Faces data offset (high)
36793               
36794 A8AE 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
36795 A8AF   11            byte >11                                            ; Laser power              = 2
36796                                                                          ; Missiles                 = 1
36797               
36798               SHIP_VIPER_VERTICES:
36799                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36800 A8B0 0000            byte >00, >00, >48, >1f, >21, >43                   ; Vertex 0
     A8B2 481F     
     A8B4 2143     
36801 A8B6 0010            byte >00, >10, >18, >1e, >10, >22                   ; Vertex 1
     A8B8 181E     
     A8BA 1022     
36802 A8BC 0010            byte >00, >10, >18, >5e, >43, >55                   ; Vertex 2
     A8BE 185E     
     A8C0 4355     
36803 A8C2 3000            byte >30, >00, >18, >3f, >42, >66                   ; Vertex 3
     A8C4 183F     
     A8C6 4266     
36804 A8C8 3000            byte >30, >00, >18, >bf, >31, >66                   ; Vertex 4
     A8CA 18BF     
     A8CC 3166     
36805 A8CE 1810            byte >18, >10, >18, >7e, >54, >66                   ; Vertex 5
     A8D0 187E     
     A8D2 5466     
36806 A8D4 1810            byte >18, >10, >18, >fe, >35, >66                   ; Vertex 6
     A8D6 18FE     
     A8D8 3566     
36807 A8DA 1810            byte >18, >10, >18, >3f, >20, >66                   ; Vertex 7
     A8DC 183F     
     A8DE 2066     
36808 A8E0 1810            byte >18, >10, >18, >bf, >10, >66                   ; Vertex 8
     A8E2 18BF     
     A8E4 1066     
36809 A8E6 2000            byte >20, >00, >18, >b3, >66, >66                   ; Vertex 9
     A8E8 18B3     
     A8EA 6666     
36810 A8EC 2000            byte >20, >00, >18, >33, >66, >66                   ; Vertex 10
     A8EE 1833     
     A8F0 6666     
36811 A8F2 0808            byte >08, >08, >18, >33, >66, >66                   ; Vertex 11
     A8F4 1833     
     A8F6 6666     
36812 A8F8 0808            byte >08, >08, >18, >b3, >66, >66                   ; Vertex 12
     A8FA 18B3     
     A8FC 6666     
36813 A8FE 0808            byte >08, >08, >18, >f2, >66, >66                   ; Vertex 13
     A900 18F2     
     A902 6666     
36814 A904 0808            byte >08, >08, >18, >72, >66, >66                   ; Vertex 14
     A906 1872     
     A908 6666     
36815               
36816               SHIP_VIPER_EDGES:
36817                                                                          ; vertex1, vertex2, face1, face2, visibility
36818 A90A 1F42            byte >1f, >42, >00, >0c                             ; Edge 0
     A90C 000C     
36819 A90E 1E21            byte >1e, >21, >00, >04                             ; Edge 1
     A910 0004     
36820 A912 1E43            byte >1e, >43, >00, >08                             ; Edge 2
     A914 0008     
36821 A916 1F31            byte >1f, >31, >00, >10                             ; Edge 3
     A918 0010     
36822 A91A 1E20            byte >1e, >20, >04, >1c                             ; Edge 4
     A91C 041C     
36823 A91E 1E10            byte >1e, >10, >04, >20                             ; Edge 5
     A920 0420     
36824 A922 1E54            byte >1e, >54, >08, >14                             ; Edge 6
     A924 0814     
36825 A926 1E53            byte >1e, >53, >08, >18                             ; Edge 7
     A928 0818     
36826 A92A 1F60            byte >1f, >60, >1c, >20                             ; Edge 8
     A92C 1C20     
36827 A92E 1E65            byte >1e, >65, >14, >18                             ; Edge 9
     A930 1418     
36828 A932 1F61            byte >1f, >61, >10, >20                             ; Edge 10
     A934 1020     
36829 A936 1E63            byte >1e, >63, >10, >18                             ; Edge 11
     A938 1018     
36830 A93A 1F62            byte >1f, >62, >0c, >1c                             ; Edge 12
     A93C 0C1C     
36831 A93E 1E46            byte >1e, >46, >0c, >14                             ; Edge 13
     A940 0C14     
36832 A942 1366            byte >13, >66, >24, >30                             ; Edge 14
     A944 2430     
36833 A946 1266            byte >12, >66, >24, >34                             ; Edge 15
     A948 2434     
36834 A94A 1366            byte >13, >66, >28, >2c                             ; Edge 16
     A94C 282C     
36835 A94E 1266            byte >12, >66, >28, >38                             ; Edge 17
     A950 2838     
36836 A952 1066            byte >10, >66, >2c, >38                             ; Edge 18
     A954 2C38     
36837 A956 1066            byte >10, >66, >30, >34                             ; Edge 19
     A958 3034     
36838               
36839               SHIP_VIPER_FACES:
36840                                                                          ; normal_x, normal_y, normal_z, visibility
36841 A95A 1F00            byte >1f, >00, >20, >00                             ; Face 0
     A95C 2000     
36842 A95E 9F16            byte >9f, >16, >21, >0b                             ; Face 1
     A960 210B     
36843 A962 1F16            byte >1f, >16, >21, >0b                             ; Face 2
     A964 210B     
36844 A966 DF16            byte >df, >16, >21, >0b                             ; Face 3
     A968 210B     
36845 A96A 5F16            byte >5f, >16, >21, >0b                             ; Face 4
     A96C 210B     
36846 A96E 5F00            byte >5f, >00, >20, >00                             ; Face 5
     A970 2000     
36847 A972 3F00            byte >3f, >00, >00, >30                             ; Face 6
     A974 0030     
36848               
36849               * ******************************************************************************
36850               *
36851               * Name: SHIP_MAMBA
36852               * Type: Variable
36853               * Category: Drawing ships
36854               * Summary: Ship blueprint for a Mamba
36855               * Deep dive: Ship blueprints
36856               *
36857               * ******************************************************************************
36858               
36859               SHIP_MAMBA:
36860 A976 01              byte >01                                            ; Max. canisters on demise = 1
36861 A978 1324            data 70 * 70                                        ; Targetable area          = 70 * 70
36862               
36863 A97A AC              byte (SHIP_MAMBA_EDGES - SHIP_MAMBA)%256            ; Edges data offset (low)
36864 A97B   1C            byte (SHIP_MAMBA_FACES - SHIP_MAMBA)%256            ; Faces data offset (low)
36865               
36866 A97C 5D              byte >5d                                            ; Max. edge count          = (93 - 1) / 4 = 23
36867 A97D   00            byte >00                                            ; Gun vertex               = 0
36868 A97E 22              byte >22                                            ; Explosion count          = 7, as (4 * n) + 6 = 34
36869 A97F   96            byte >96                                            ; Number of vertices       = 150 / 6 = 25
36870 A980 1C              byte >1c                                            ; Number of edges          = 28
36871 A982 9600            data >9600                                          ; Bounty                   = 150
36872 A984 14              byte >14                                            ; Number of faces          = 20 / 4 = 5
36873 A985   19            byte >19                                            ; Visibility distance      = 25
36874 A986 5A              byte >5a                                            ; Max. energy              = 90
36875 A987   1E            byte >1e                                            ; Max. speed               = 30
36876               
36877 A988 00              byte (SHIP_MAMBA_EDGES - SHIP_MAMBA)/256            ; Edges data offset (high)
36878 A989   01            byte (SHIP_MAMBA_FACES - SHIP_MAMBA)/256            ; Faces data offset (high)
36879               
36880 A98A 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
36881 A98B   12            byte >12                                            ; Laser power              = 2
36882                                                                          ; Missiles                 = 2
36883               
36884               SHIP_MAMBA_VERTICES:
36885                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36886 A98C 0000            byte >00, >00, >40, >1f, >10, >32                   ; Vertex 0
     A98E 401F     
     A990 1032     
36887 A992 4008            byte >40, >08, >20, >ff, >20, >44                   ; Vertex 1
     A994 20FF     
     A996 2044     
36888 A998 2008            byte >20, >08, >20, >be, >21, >44                   ; Vertex 2
     A99A 20BE     
     A99C 2144     
36889 A99E 2008            byte >20, >08, >20, >3e, >31, >44                   ; Vertex 3
     A9A0 203E     
     A9A2 3144     
36890 A9A4 4008            byte >40, >08, >20, >7f, >30, >44                   ; Vertex 4
     A9A6 207F     
     A9A8 3044     
36891 A9AA 0404            byte >04, >04, >10, >8e, >11, >11                   ; Vertex 5
     A9AC 108E     
     A9AE 1111     
36892 A9B0 0404            byte >04, >04, >10, >0e, >11, >11                   ; Vertex 6
     A9B2 100E     
     A9B4 1111     
36893 A9B6 0803            byte >08, >03, >1c, >0d, >11, >11                   ; Vertex 7
     A9B8 1C0D     
     A9BA 1111     
36894 A9BC 0803            byte >08, >03, >1c, >8d, >11, >11                   ; Vertex 8
     A9BE 1C8D     
     A9C0 1111     
36895 A9C2 1404            byte >14, >04, >10, >d4, >00, >00                   ; Vertex 9
     A9C4 10D4     
     A9C6 0000     
36896 A9C8 1404            byte >14, >04, >10, >54, >00, >00                   ; Vertex 10
     A9CA 1054     
     A9CC 0000     
36897 A9CE 1807            byte >18, >07, >14, >f4, >00, >00                   ; Vertex 11
     A9D0 14F4     
     A9D2 0000     
36898 A9D4 1007            byte >10, >07, >14, >f0, >00, >00                   ; Vertex 12
     A9D6 14F0     
     A9D8 0000     
36899 A9DA 1007            byte >10, >07, >14, >70, >00, >00                   ; Vertex 13
     A9DC 1470     
     A9DE 0000     
36900 A9E0 1807            byte >18, >07, >14, >74, >00, >00                   ; Vertex 14
     A9E2 1474     
     A9E4 0000     
36901 A9E6 0804            byte >08, >04, >20, >ad, >44, >44                   ; Vertex 15
     A9E8 20AD     
     A9EA 4444     
36902 A9EC 0804            byte >08, >04, >20, >2d, >44, >44                   ; Vertex 16
     A9EE 202D     
     A9F0 4444     
36903 A9F2 0804            byte >08, >04, >20, >6e, >44, >44                   ; Vertex 17
     A9F4 206E     
     A9F6 4444     
36904 A9F8 0804            byte >08, >04, >20, >ee, >44, >44                   ; Vertex 18
     A9FA 20EE     
     A9FC 4444     
36905 A9FE 2004            byte >20, >04, >20, >a7, >44, >44                   ; Vertex 19
     AA00 20A7     
     AA02 4444     
36906 AA04 2004            byte >20, >04, >20, >27, >44, >44                   ; Vertex 20
     AA06 2027     
     AA08 4444     
36907 AA0A 2404            byte >24, >04, >20, >67, >44, >44                   ; Vertex 21
     AA0C 2067     
     AA0E 4444     
36908 AA10 2404            byte >24, >04, >20, >e7, >44, >44                   ; Vertex 22
     AA12 20E7     
     AA14 4444     
36909 AA16 2600            byte >26, >00, >20, >a5, >44, >44                   ; Vertex 23
     AA18 20A5     
     AA1A 4444     
36910 AA1C 2600            byte >26, >00, >20, >25, >44, >44                   ; Vertex 24
     AA1E 2025     
     AA20 4444     
36911               
36912               SHIP_MAMBA_EDGES:
36913                                                                          ; vertex1, vertex2, face1, face2, visibility
36914 AA22 1F20            byte >1f, >20, >00, >04                             ; Edge 0
     AA24 0004     
36915 AA26 1F30            byte >1f, >30, >00, >10                             ; Edge 1
     AA28 0010     
36916 AA2A 1F40            byte >1f, >40, >04, >10                             ; Edge 2
     AA2C 0410     
36917 AA2E 1E42            byte >1e, >42, >04, >08                             ; Edge 3
     AA30 0408     
36918 AA32 1E41            byte >1e, >41, >08, >0c                             ; Edge 4
     AA34 080C     
36919 AA36 1E43            byte >1e, >43, >0c, >10                             ; Edge 5
     AA38 0C10     
36920 AA3A 0E11            byte >0e, >11, >14, >18                             ; Edge 6
     AA3C 1418     
36921 AA3E 0C11            byte >0c, >11, >18, >1c                             ; Edge 7
     AA40 181C     
36922 AA42 0D11            byte >0d, >11, >1c, >20                             ; Edge 8
     AA44 1C20     
36923 AA46 0C11            byte >0c, >11, >14, >20                             ; Edge 9
     AA48 1420     
36924 AA4A 1400            byte >14, >00, >24, >2c                             ; Edge 10
     AA4C 242C     
36925 AA4E 1000            byte >10, >00, >24, >30                             ; Edge 11
     AA50 2430     
36926 AA52 1000            byte >10, >00, >28, >34                             ; Edge 12
     AA54 2834     
36927 AA56 1400            byte >14, >00, >28, >38                             ; Edge 13
     AA58 2838     
36928 AA5A 0E00            byte >0e, >00, >34, >38                             ; Edge 14
     AA5C 3438     
36929 AA5E 0E00            byte >0e, >00, >2c, >30                             ; Edge 15
     AA60 2C30     
36930 AA62 0D44            byte >0d, >44, >3c, >40                             ; Edge 16
     AA64 3C40     
36931 AA66 0E44            byte >0e, >44, >44, >48                             ; Edge 17
     AA68 4448     
36932 AA6A 0C44            byte >0c, >44, >3c, >48                             ; Edge 18
     AA6C 3C48     
36933 AA6E 0C44            byte >0c, >44, >40, >44                             ; Edge 19
     AA70 4044     
36934 AA72 0744            byte >07, >44, >50, >54                             ; Edge 20
     AA74 5054     
36935 AA76 0544            byte >05, >44, >50, >60                             ; Edge 21
     AA78 5060     
36936 AA7A 0544            byte >05, >44, >54, >60                             ; Edge 22
     AA7C 5460     
36937 AA7E 0744            byte >07, >44, >4c, >58                             ; Edge 23
     AA80 4C58     
36938 AA82 0544            byte >05, >44, >4c, >5c                             ; Edge 24
     AA84 4C5C     
36939 AA86 0544            byte >05, >44, >58, >5c                             ; Edge 25
     AA88 585C     
36940 AA8A 1E21            byte >1e, >21, >00, >08                             ; Edge 26
     AA8C 0008     
36941 AA8E 1E31            byte >1e, >31, >00, >0c                             ; Edge 27
     AA90 000C     
36942               
36943               SHIP_MAMBA_FACES:
36944                                                                          ; normal_x, normal_y, normal_z, visibility
36945 AA92 5E00            byte >5e, >00, >18, >02                             ; Face 0
     AA94 1802     
36946 AA96 1E00            byte >1e, >00, >18, >02                             ; Face 1
     AA98 1802     
36947 AA9A 9E20            byte >9e, >20, >40, >10                             ; Face 2
     AA9C 4010     
36948 AA9E 1E20            byte >1e, >20, >40, >10                             ; Face 3
     AAA0 4010     
36949 AAA2 3E00            byte >3e, >00, >00, >7f                             ; Face 4
     AAA4 007F     
36950               
36951               * ******************************************************************************
36952               *
36953               * Name: SHIP_COBRA_MK_3
36954               * Type: Variable
36955               * Category: Drawing ships
36956               * Summary: Ship blueprint for a Cobra Mk III
36957               * Deep dive: Ship blueprints
36958               *
36959               * ******************************************************************************
36960               
36961               SHIP_COBRA_MK_3:
36962 AAA6 03              byte >03                                            ; Max. canisters on demise = 3
36963 AAA8 2341            data 95 * 95                                        ; Targetable area          = 95 * 95
36964               
36965 AAAA BE              byte (SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)%256  ; Edges data offset (low)
36966 AAAB   56            byte (SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)%256  ; Faces data offset (low)
36967               
36968 AAAC 99              byte >99                                            ; Max. edge count          = (153 - 1) / 4 = 38
36969 AAAD   54            byte >54                                            ; Gun vertex               = 84 / 4 = 21
36970 AAAE 2A              byte >2a                                            ; Explosion count          = 9, as (4 * n) + 6 = 42
36971 AAAF   A8            byte >a8                                            ; Number of vertices       = 168 / 6 = 28
36972 AAB0 26              byte >26                                            ; Number of edges          = 38
36973 AAB2 0000            data >0000                                          ; Bounty                   = 0
36974 AAB4 34              byte >34                                            ; Number of faces          = 52 / 4 = 13
36975 AAB5   32            byte >32                                            ; Visibility distance      = 50
36976 AAB6 96              byte >96                                            ; Max. energy              = 150
36977 AAB7   1C            byte >1c                                            ; Max. speed               = 28
36978               
36979 AAB8 00              byte (SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)/256  ; Edges data offset (low)
36980 AAB9   01            byte (SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)/256  ; Faces data offset (low)
36981               
36982 AABA 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
36983 AABB   13            byte >13                                            ; Laser power              = 2
36984                                                                          ; Missiles                 = 3
36985               
36986               SHIP_COBRA_MK_3_VERTICES:
36987                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36988 AABC 2000            byte >20, >00, >4c, >1f, >ff, >ff                   ; Vertex 0
     AABE 4C1F     
     AAC0 FFFF     
36989 AAC2 2000            byte >20, >00, >4c, >9f, >ff, >ff                   ; Vertex 1
     AAC4 4C9F     
     AAC6 FFFF     
36990 AAC8 001A            byte >00, >1a, >18, >1f, >ff, >ff                   ; Vertex 2
     AACA 181F     
     AACC FFFF     
36991 AACE 7803            byte >78, >03, >08, >ff, >73, >aa                   ; Vertex 3
     AAD0 08FF     
     AAD2 73AA     
36992 AAD4 7803            byte >78, >03, >08, >7f, >84, >cc                   ; Vertex 4
     AAD6 087F     
     AAD8 84CC     
36993 AADA 5810            byte >58, >10, >28, >bf, >ff, >ff                   ; Vertex 5
     AADC 28BF     
     AADE FFFF     
36994 AAE0 5810            byte >58, >10, >28, >3f, >ff, >ff                   ; Vertex 6
     AAE2 283F     
     AAE4 FFFF     
36995 AAE6 8008            byte >80, >08, >28, >7f, >98, >cc                   ; Vertex 7
     AAE8 287F     
     AAEA 98CC     
36996 AAEC 8008            byte >80, >08, >28, >ff, >97, >aa                   ; Vertex 8
     AAEE 28FF     
     AAF0 97AA     
36997 AAF2 001A            byte >00, >1a, >28, >3f, >65, >99                   ; Vertex 9
     AAF4 283F     
     AAF6 6599     
36998 AAF8 2018            byte >20, >18, >28, >ff, >a9, >bb                   ; Vertex 10
     AAFA 28FF     
     AAFC A9BB     
36999 AAFE 2018            byte >20, >18, >28, >7f, >b9, >cc                   ; Vertex 11
     AB00 287F     
     AB02 B9CC     
37000 AB04 2408            byte >24, >08, >28, >b4, >99, >99                   ; Vertex 12
     AB06 28B4     
     AB08 9999     
37001 AB0A 080C            byte >08, >0c, >28, >b4, >99, >99                   ; Vertex 13
     AB0C 28B4     
     AB0E 9999     
37002 AB10 080C            byte >08, >0c, >28, >34, >99, >99                   ; Vertex 14
     AB12 2834     
     AB14 9999     
37003 AB16 2408            byte >24, >08, >28, >34, >99, >99                   ; Vertex 15
     AB18 2834     
     AB1A 9999     
37004 AB1C 240C            byte >24, >0c, >28, >74, >99, >99                   ; Vertex 16
     AB1E 2874     
     AB20 9999     
37005 AB22 0810            byte >08, >10, >28, >74, >99, >99                   ; Vertex 17
     AB24 2874     
     AB26 9999     
37006 AB28 0810            byte >08, >10, >28, >f4, >99, >99                   ; Vertex 18
     AB2A 28F4     
     AB2C 9999     
37007 AB2E 240C            byte >24, >0c, >28, >f4, >99, >99                   ; Vertex 19
     AB30 28F4     
     AB32 9999     
37008 AB34 0000            byte >00, >00, >4c, >06, >b0, >bb                   ; Vertex 20
     AB36 4C06     
     AB38 B0BB     
37009 AB3A 0000            byte >00, >00, >5a, >1f, >b0, >bb                   ; Vertex 21
     AB3C 5A1F     
     AB3E B0BB     
37010 AB40 5006            byte >50, >06, >28, >e8, >99, >99                   ; Vertex 22
     AB42 28E8     
     AB44 9999     
37011 AB46 5006            byte >50, >06, >28, >a8, >99, >99                   ; Vertex 23
     AB48 28A8     
     AB4A 9999     
37012 AB4C 5800            byte >58, >00, >28, >a6, >99, >99                   ; Vertex 24
     AB4E 28A6     
     AB50 9999     
37013 AB52 5006            byte >50, >06, >28, >28, >99, >99                   ; Vertex 25
     AB54 2828     
     AB56 9999     
37014 AB58 5800            byte >58, >00, >28, >26, >99, >99                   ; Vertex 26
     AB5A 2826     
     AB5C 9999     
37015 AB5E 5006            byte >50, >06, >28, >68, >99, >99                   ; Vertex 27
     AB60 2868     
     AB62 9999     
37016               
37017               SHIP_COBRA_MK_3_EDGES:
37018                                                                          ; vertex1, vertex2, face1, face2, visibility
37019 AB64 1FB0            byte >1f, >b0, >00, >04                             ; Edge 0
     AB66 0004     
37020 AB68 1FC4            byte >1f, >c4, >00, >10                             ; Edge 1
     AB6A 0010     
37021 AB6C 1FA3            byte >1f, >a3, >04, >0c                             ; Edge 2
     AB6E 040C     
37022 AB70 1FA7            byte >1f, >a7, >0c, >20                             ; Edge 3
     AB72 0C20     
37023 AB74 1FC8            byte >1f, >c8, >10, >1c                             ; Edge 4
     AB76 101C     
37024 AB78 1F98            byte >1f, >98, >18, >1c                             ; Edge 5
     AB7A 181C     
37025 AB7C 1F96            byte >1f, >96, >18, >24                             ; Edge 6
     AB7E 1824     
37026 AB80 1F95            byte >1f, >95, >14, >24                             ; Edge 7
     AB82 1424     
37027 AB84 1F97            byte >1f, >97, >14, >20                             ; Edge 8
     AB86 1420     
37028 AB88 1F51            byte >1f, >51, >08, >14                             ; Edge 9
     AB8A 0814     
37029 AB8C 1F62            byte >1f, >62, >08, >18                             ; Edge 10
     AB8E 0818     
37030 AB90 1F73            byte >1f, >73, >0c, >14                             ; Edge 11
     AB92 0C14     
37031 AB94 1F84            byte >1f, >84, >10, >18                             ; Edge 12
     AB96 1018     
37032 AB98 1F10            byte >1f, >10, >04, >08                             ; Edge 13
     AB9A 0408     
37033 AB9C 1F20            byte >1f, >20, >00, >08                             ; Edge 14
     AB9E 0008     
37034 ABA0 1FA9            byte >1f, >a9, >20, >28                             ; Edge 15
     ABA2 2028     
37035 ABA4 1FB9            byte >1f, >b9, >28, >2c                             ; Edge 16
     ABA6 282C     
37036 ABA8 1FC9            byte >1f, >c9, >1c, >2c                             ; Edge 17
     ABAA 1C2C     
37037 ABAC 1FBA            byte >1f, >ba, >04, >28                             ; Edge 18
     ABAE 0428     
37038 ABB0 1FCB            byte >1f, >cb, >00, >2c                             ; Edge 19
     ABB2 002C     
37039 ABB4 1D31            byte >1d, >31, >04, >14                             ; Edge 20
     ABB6 0414     
37040 ABB8 1D42            byte >1d, >42, >00, >18                             ; Edge 21
     ABBA 0018     
37041 ABBC 06B0            byte >06, >b0, >50, >54                             ; Edge 22
     ABBE 5054     
37042 ABC0 1499            byte >14, >99, >30, >34                             ; Edge 23
     ABC2 3034     
37043 ABC4 1499            byte >14, >99, >48, >4c                             ; Edge 24
     ABC6 484C     
37044 ABC8 1499            byte >14, >99, >38, >3c                             ; Edge 25
     ABCA 383C     
37045 ABCC 1499            byte >14, >99, >40, >44                             ; Edge 26
     ABCE 4044     
37046 ABD0 1399            byte >13, >99, >3c, >40                             ; Edge 27
     ABD2 3C40     
37047 ABD4 1199            byte >11, >99, >38, >44                             ; Edge 28
     ABD6 3844     
37048 ABD8 1399            byte >13, >99, >34, >48                             ; Edge 29
     ABDA 3448     
37049 ABDC 1399            byte >13, >99, >30, >4c                             ; Edge 30
     ABDE 304C     
37050 ABE0 1E65            byte >1e, >65, >08, >24                             ; Edge 31
     ABE2 0824     
37051 ABE4 0699            byte >06, >99, >58, >60                             ; Edge 32
     ABE6 5860     
37052 ABE8 0699            byte >06, >99, >5c, >60                             ; Edge 33
     ABEA 5C60     
37053 ABEC 0899            byte >08, >99, >58, >5c                             ; Edge 34
     ABEE 585C     
37054 ABF0 0699            byte >06, >99, >64, >68                             ; Edge 35
     ABF2 6468     
37055 ABF4 0699            byte >06, >99, >68, >6c                             ; Edge 36
     ABF6 686C     
37056 ABF8 0899            byte >08, >99, >64, >6c                             ; Edge 37
     ABFA 646C     
37057               
37058               SHIP_COBRA_MK_3_FACES:
37059                                                                          ; normal_x, normal_y, normal_z, visibility
37060 ABFC 1F00            byte >1f, >00, >3e, >1f                             ; Face 0
     ABFE 3E1F     
37061 AC00 9F12            byte >9f, >12, >37, >10                             ; Face 1
     AC02 3710     
37062 AC04 1F12            byte >1f, >12, >37, >10                             ; Face 2
     AC06 3710     
37063 AC08 9F10            byte >9f, >10, >34, >0e                             ; Face 3
     AC0A 340E     
37064 AC0C 1F10            byte >1f, >10, >34, >0e                             ; Face 4
     AC0E 340E     
37065 AC10 9F0E            byte >9f, >0e, >2f, >00                             ; Face 5
     AC12 2F00     
37066 AC14 1F0E            byte >1f, >0e, >2f, >00                             ; Face 6
     AC16 2F00     
37067 AC18 9F3D            byte >9f, >3d, >66, >00                             ; Face 7
     AC1A 6600     
37068 AC1C 1F3D            byte >1f, >3d, >66, >00                             ; Face 8
     AC1E 6600     
37069 AC20 3F00            byte >3f, >00, >00, >50                             ; Face 9
     AC22 0050     
37070 AC24 DF07            byte >df, >07, >2a, >09                             ; Face 10
     AC26 2A09     
37071 AC28 5F00            byte >5f, >00, >1e, >06                             ; Face 11
     AC2A 1E06     
37072 AC2C 5F07            byte >5f, >07, >2a, >09                             ; Face 12
     AC2E 2A09     
37073               
37074               * ******************************************************************************
37075               *
37076               * Name: SHIP_THARGOID
37077               * Type: Variable
37078               * Category: Drawing ships
37079               * Summary: Ship blueprint for a Thargoid mothership
37080               * Deep dive: Ship blueprints
37081               *
37082               * ******************************************************************************
37083               
37084               SHIP_THARGOID:
37085 AC30 00              byte >00                                            ; Max. canisters on demise = 0
37086 AC32 2649            data 99 * 99                                        ; Targetable area          = 99 * 99
37087               
37088 AC34 8E              byte (SHIP_THARGOID_EDGES - SHIP_THARGOID)%256      ; Edges data offset (low)
37089 AC35   F6            byte (SHIP_THARGOID_FACES - SHIP_THARGOID)%256      ; Faces data offset (low)
37090               
37091 AC36 65              byte >65                                            ; Max. edge count          = (101 - 1) / 4 = 25
37092 AC37   3C            byte >3c                                            ; Gun vertex               = 60 / 4 = 15
37093 AC38 26              byte >26                                            ; Explosion count          = 8, as (4 * n) + 6 = 38
37094 AC39   78            byte >78                                            ; Number of vertices       = 120 / 6 = 20
37095 AC3A 1A              byte >1a                                            ; Number of edges          = 26
37096 AC3C F401            data >f401                                          ; Bounty                   = 500
37097 AC3E 28              byte >28                                            ; Number of faces          = 40 / 4 = 10
37098 AC3F   37            byte >37                                            ; Visibility distance      = 55
37099 AC40 F0              byte >f0                                            ; Max. energy              = 240
37100 AC41   27            byte >27                                            ; Max. speed               = 39
37101               
37102 AC42 00              byte (SHIP_THARGOID_EDGES - SHIP_THARGOID)/256      ; Edges data offset (high)
37103 AC43   00            byte (SHIP_THARGOID_FACES - SHIP_THARGOID)/256      ; Faces data offset (high)
37104               
37105 AC44 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37106 AC45   16            byte >16                                            ; Laser power              = 2
37107                                                                          ; Missiles                 = 6
37108               
37109               SHIP_THARGOID_VERTICES:
37110                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37111 AC46 2030            byte >20, >30, >30, >5f, >40, >88                   ; Vertex 0
     AC48 305F     
     AC4A 4088     
37112 AC4C 2044            byte >20, >44, >00, >5f, >10, >44                   ; Vertex 1
     AC4E 005F     
     AC50 1044     
37113 AC52 2030            byte >20, >30, >30, >7f, >21, >44                   ; Vertex 2
     AC54 307F     
     AC56 2144     
37114 AC58 2000            byte >20, >00, >44, >3f, >32, >44                   ; Vertex 3
     AC5A 443F     
     AC5C 3244     
37115 AC5E 2030            byte >20, >30, >30, >3f, >43, >55                   ; Vertex 4
     AC60 303F     
     AC62 4355     
37116 AC64 2044            byte >20, >44, >00, >1f, >54, >66                   ; Vertex 5
     AC66 001F     
     AC68 5466     
37117 AC6A 2030            byte >20, >30, >30, >1f, >64, >77                   ; Vertex 6
     AC6C 301F     
     AC6E 6477     
37118 AC70 2000            byte >20, >00, >44, >1f, >74, >88                   ; Vertex 7
     AC72 441F     
     AC74 7488     
37119 AC76 1874            byte >18, >74, >74, >df, >80, >99                   ; Vertex 8
     AC78 74DF     
     AC7A 8099     
37120 AC7C 18A4            byte >18, >a4, >00, >df, >10, >99                   ; Vertex 9
     AC7E 00DF     
     AC80 1099     
37121 AC82 1874            byte >18, >74, >74, >ff, >21, >99                   ; Vertex 10
     AC84 74FF     
     AC86 2199     
37122 AC88 1800            byte >18, >00, >a4, >bf, >32, >99                   ; Vertex 11
     AC8A A4BF     
     AC8C 3299     
37123 AC8E 1874            byte >18, >74, >74, >bf, >53, >99                   ; Vertex 12
     AC90 74BF     
     AC92 5399     
37124 AC94 18A4            byte >18, >a4, >00, >9f, >65, >99                   ; Vertex 13
     AC96 009F     
     AC98 6599     
37125 AC9A 1874            byte >18, >74, >74, >9f, >76, >99                   ; Vertex 14
     AC9C 749F     
     AC9E 7699     
37126 ACA0 1800            byte >18, >00, >a4, >9f, >87, >99                   ; Vertex 15
     ACA2 A49F     
     ACA4 8799     
37127 ACA6 1840            byte >18, >40, >50, >9e, >99, >99                   ; Vertex 16
     ACA8 509E     
     ACAA 9999     
37128 ACAC 1840            byte >18, >40, >50, >be, >99, >99                   ; Vertex 17
     ACAE 50BE     
     ACB0 9999     
37129 ACB2 1840            byte >18, >40, >50, >fe, >99, >99                   ; Vertex 18
     ACB4 50FE     
     ACB6 9999     
37130 ACB8 1840            byte >18, >40, >50, >de, >99, >99                   ; Vertex 19
     ACBA 50DE     
     ACBC 9999     
37131               
37132               SHIP_THARGOID_EDGES:
37133                                                                          ; vertex1, vertex2, face1, face2, visibility
37134 ACBE 1F84            byte >1f, >84, >00, >1c                             ; Edge 0
     ACC0 001C     
37135 ACC2 1F40            byte >1f, >40, >00, >04                             ; Edge 1
     ACC4 0004     
37136 ACC6 1F41            byte >1f, >41, >04, >08                             ; Edge 2
     ACC8 0408     
37137 ACCA 1F42            byte >1f, >42, >08, >0c                             ; Edge 3
     ACCC 080C     
37138 ACCE 1F43            byte >1f, >43, >0c, >10                             ; Edge 4
     ACD0 0C10     
37139 ACD2 1F54            byte >1f, >54, >10, >14                             ; Edge 5
     ACD4 1014     
37140 ACD6 1F64            byte >1f, >64, >14, >18                             ; Edge 6
     ACD8 1418     
37141 ACDA 1F74            byte >1f, >74, >18, >1c                             ; Edge 7
     ACDC 181C     
37142 ACDE 1F80            byte >1f, >80, >00, >20                             ; Edge 8
     ACE0 0020     
37143 ACE2 1F10            byte >1f, >10, >04, >24                             ; Edge 9
     ACE4 0424     
37144 ACE6 1F21            byte >1f, >21, >08, >28                             ; Edge 10
     ACE8 0828     
37145 ACEA 1F32            byte >1f, >32, >0c, >2c                             ; Edge 11
     ACEC 0C2C     
37146 ACEE 1F53            byte >1f, >53, >10, >30                             ; Edge 12
     ACF0 1030     
37147 ACF2 1F65            byte >1f, >65, >14, >34                             ; Edge 13
     ACF4 1434     
37148 ACF6 1F76            byte >1f, >76, >18, >38                             ; Edge 14
     ACF8 1838     
37149 ACFA 1F87            byte >1f, >87, >1c, >3c                             ; Edge 15
     ACFC 1C3C     
37150 ACFE 1F98            byte >1f, >98, >20, >3c                             ; Edge 16
     AD00 203C     
37151 AD02 1F90            byte >1f, >90, >20, >24                             ; Edge 17
     AD04 2024     
37152 AD06 1F91            byte >1f, >91, >24, >28                             ; Edge 18
     AD08 2428     
37153 AD0A 1F92            byte >1f, >92, >28, >2c                             ; Edge 19
     AD0C 282C     
37154 AD0E 1F93            byte >1f, >93, >2c, >30                             ; Edge 20
     AD10 2C30     
37155 AD12 1F95            byte >1f, >95, >30, >34                             ; Edge 21
     AD14 3034     
37156 AD16 1F96            byte >1f, >96, >34, >38                             ; Edge 22
     AD18 3438     
37157 AD1A 1F97            byte >1f, >97, >38, >3c                             ; Edge 23
     AD1C 383C     
37158 AD1E 1E99            byte >1e, >99, >40, >44                             ; Edge 24
     AD20 4044     
37159 AD22 1E99            byte >1e, >99, >48, >4c                             ; Edge 25
     AD24 484C     
37160               
37161               SHIP_THARGOID_FACES:
37162                                                                          ; normal_x, normal_y, normal_z, visibility
37163 AD26 5F67            byte >5f, >67, >3c, >19                             ; Face 0
     AD28 3C19     
37164 AD2A 7F67            byte >7f, >67, >3c, >19                             ; Face 1
     AD2C 3C19     
37165 AD2E 7F67            byte >7f, >67, >19, >3c                             ; Face 2
     AD30 193C     
37166 AD32 3F67            byte >3f, >67, >19, >3c                             ; Face 3
     AD34 193C     
37167 AD36 1F40            byte >1f, >40, >00, >00                             ; Face 4
     AD38 0000     
37168 AD3A 3F67            byte >3f, >67, >3c, >19                             ; Face 5
     AD3C 3C19     
37169 AD3E 1F67            byte >1f, >67, >3c, >19                             ; Face 6
     AD40 3C19     
37170 AD42 1F67            byte >1f, >67, >19, >3c                             ; Face 7
     AD44 193C     
37171 AD46 5F67            byte >5f, >67, >19, >3c                             ; Face 8
     AD48 193C     
37172 AD4A 9F30            byte >9f, >30, >00, >00                             ; Face 9
     AD4C 0000     
37173               
37174               * ******************************************************************************
37175               *
37176               * Name: SHIP_CORIOLIS
37177               * Type: Variable
37178               * Category: Drawing ships
37179               * Summary: Ship blueprint for a Coriolis space station
37180               * Deep dive: Ship blueprints
37181               *
37182               * ******************************************************************************
37183               
37184               SHIP_CORIOLIS:
37185 AD4E 00              byte >00                                            ; Max. canisters on demise = 0
37186 AD50 6400            data 160 * 160                                      ; Targetable area          = 160 * 160
37187               
37188 AD52 76              byte (SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)%256      ; Edges data offset (low)
37189 AD53   E6            byte (SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)%256      ; Faces data offset (low)
37190               
37191 AD54 55              byte >55                                            ; Max. edge count          = (85 - 1) / 4 = 21
37192 AD55   00            byte >00                                            ; Gun vertex               = 0
37193 AD56 36              byte >36                                            ; Explosion count          = 12, as (4 * n) + 6 = 54
37194 AD57   60            byte >60                                            ; Number of vertices       = 96 / 6 = 16
37195 AD58 1C              byte >1c                                            ; Number of edges          = 28
37196 AD5A 0000            data >0000                                          ; Bounty                   = 0
37197 AD5C 38              byte >38                                            ; Number of faces          = 56 / 4 = 14
37198 AD5D   78            byte >78                                            ; Visibility distance      = 120
37199 AD5E F0              byte >f0                                            ; Max. energy              = 240
37200 AD5F   00            byte >00                                            ; Max. speed               = 0
37201               
37202 AD60 00              byte (SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)/256      ; Edges data offset (high)
37203 AD61   00            byte (SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)/256      ; Faces data offset (high)
37204               
37205 AD62 00              byte >00                                            ; Normals are scaled by    = 2^0 = 1
37206 AD63   06            byte >06                                            ; Laser power              = 0
37207                                                                          ; Missiles                 = 6
37208               
37209               SHIP_CORIOLIS_VERTICES:
37210                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37211 AD64 A000            byte >a0, >00, >a0, >1f, >10, >62                   ; Vertex 0
     AD66 A01F     
     AD68 1062     
37212 AD6A 00A0            byte >00, >a0, >a0, >1f, >20, >83                   ; Vertex 1
     AD6C A01F     
     AD6E 2083     
37213 AD70 A000            byte >a0, >00, >a0, >9f, >30, >74                   ; Vertex 2
     AD72 A09F     
     AD74 3074     
37214 AD76 00A0            byte >00, >a0, >a0, >5f, >10, >54                   ; Vertex 3
     AD78 A05F     
     AD7A 1054     
37215 AD7C A0A0            byte >a0, >a0, >00, >5f, >51, >a6                   ; Vertex 4
     AD7E 005F     
     AD80 51A6     
37216 AD82 A0A0            byte >a0, >a0, >00, >1f, >62, >b8                   ; Vertex 5
     AD84 001F     
     AD86 62B8     
37217 AD88 A0A0            byte >a0, >a0, >00, >9f, >73, >c8                   ; Vertex 6
     AD8A 009F     
     AD8C 73C8     
37218 AD8E A0A0            byte >a0, >a0, >00, >df, >54, >97                   ; Vertex 7
     AD90 00DF     
     AD92 5497     
37219 AD94 A000            byte >a0, >00, >a0, >3f, >a6, >db                   ; Vertex 8
     AD96 A03F     
     AD98 A6DB     
37220 AD9A 00A0            byte >00, >a0, >a0, >3f, >b8, >dc                   ; Vertex 9
     AD9C A03F     
     AD9E B8DC     
37221 ADA0 A000            byte >a0, >00, >a0, >bf, >97, >dc                   ; Vertex 10
     ADA2 A0BF     
     ADA4 97DC     
37222 ADA6 00A0            byte >00, >a0, >a0, >7f, >95, >da                   ; Vertex 11
     ADA8 A07F     
     ADAA 95DA     
37223 ADAC 0A1E            byte >0a, >1e, >a0, >5e, >00, >00                   ; Vertex 12
     ADAE A05E     
     ADB0 0000     
37224 ADB2 0A1E            byte >0a, >1e, >a0, >1e, >00, >00                   ; Vertex 13
     ADB4 A01E     
     ADB6 0000     
37225 ADB8 0A1E            byte >0a, >1e, >a0, >9e, >00, >00                   ; Vertex 14
     ADBA A09E     
     ADBC 0000     
37226 ADBE 0A1E            byte >0a, >1e, >a0, >de, >00, >00                   ; Vertex 15
     ADC0 A0DE     
     ADC2 0000     
37227               
37228               SHIP_CORIOLIS_EDGES:
37229                                                                          ; vertex1, vertex2, face1, face2, visibility
37230 ADC4 1F10            byte >1f, >10, >00, >0c                             ; Edge 0
     ADC6 000C     
37231 ADC8 1F20            byte >1f, >20, >00, >04                             ; Edge 1
     ADCA 0004     
37232 ADCC 1F30            byte >1f, >30, >04, >08                             ; Edge 2
     ADCE 0408     
37233 ADD0 1F40            byte >1f, >40, >08, >0c                             ; Edge 3
     ADD2 080C     
37234 ADD4 1F51            byte >1f, >51, >0c, >10                             ; Edge 4
     ADD6 0C10     
37235 ADD8 1F61            byte >1f, >61, >00, >10                             ; Edge 5
     ADDA 0010     
37236 ADDC 1F62            byte >1f, >62, >00, >14                             ; Edge 6
     ADDE 0014     
37237 ADE0 1F82            byte >1f, >82, >14, >04                             ; Edge 7
     ADE2 1404     
37238 ADE4 1F83            byte >1f, >83, >04, >18                             ; Edge 8
     ADE6 0418     
37239 ADE8 1F73            byte >1f, >73, >08, >18                             ; Edge 9
     ADEA 0818     
37240 ADEC 1F74            byte >1f, >74, >08, >1c                             ; Edge 10
     ADEE 081C     
37241 ADF0 1F54            byte >1f, >54, >0c, >1c                             ; Edge 11
     ADF2 0C1C     
37242 ADF4 1FDA            byte >1f, >da, >20, >2c                             ; Edge 12
     ADF6 202C     
37243 ADF8 1FDB            byte >1f, >db, >20, >24                             ; Edge 13
     ADFA 2024     
37244 ADFC 1FDC            byte >1f, >dc, >24, >28                             ; Edge 14
     ADFE 2428     
37245 AE00 1FD9            byte >1f, >d9, >28, >2c                             ; Edge 15
     AE02 282C     
37246 AE04 1FA5            byte >1f, >a5, >10, >2c                             ; Edge 16
     AE06 102C     
37247 AE08 1FA6            byte >1f, >a6, >10, >20                             ; Edge 17
     AE0A 1020     
37248 AE0C 1FB6            byte >1f, >b6, >14, >20                             ; Edge 18
     AE0E 1420     
37249 AE10 1FB8            byte >1f, >b8, >14, >24                             ; Edge 19
     AE12 1424     
37250 AE14 1FC8            byte >1f, >c8, >18, >24                             ; Edge 20
     AE16 1824     
37251 AE18 1FC7            byte >1f, >c7, >18, >28                             ; Edge 21
     AE1A 1828     
37252 AE1C 1F97            byte >1f, >97, >1c, >28                             ; Edge 22
     AE1E 1C28     
37253 AE20 1F95            byte >1f, >95, >1c, >2c                             ; Edge 23
     AE22 1C2C     
37254 AE24 1E00            byte >1e, >00, >30, >34                             ; Edge 24
     AE26 3034     
37255 AE28 1E00            byte >1e, >00, >34, >38                             ; Edge 25
     AE2A 3438     
37256 AE2C 1E00            byte >1e, >00, >38, >3c                             ; Edge 26
     AE2E 383C     
37257 AE30 1E00            byte >1e, >00, >3c, >30                             ; Edge 27
     AE32 3C30     
37258               
37259               SHIP_CORIOLIS_FACES:
37260                                                                          ; normal_x, normal_y, normal_z, visibility
37261 AE34 1F00            byte >1f, >00, >00, >a0                             ; Face 0
     AE36 00A0     
37262 AE38 5F6B            byte >5f, >6b, >6b, >6b                             ; Face 1
     AE3A 6B6B     
37263 AE3C 1F6B            byte >1f, >6b, >6b, >6b                             ; Face 2
     AE3E 6B6B     
37264 AE40 9F6B            byte >9f, >6b, >6b, >6b                             ; Face 3
     AE42 6B6B     
37265 AE44 DF6B            byte >df, >6b, >6b, >6b                             ; Face 4
     AE46 6B6B     
37266 AE48 5F00            byte >5f, >00, >a0, >00                             ; Face 5
     AE4A A000     
37267 AE4C 1FA0            byte >1f, >a0, >00, >00                             ; Face 6
     AE4E 0000     
37268 AE50 9FA0            byte >9f, >a0, >00, >00                             ; Face 7
     AE52 0000     
37269 AE54 1F00            byte >1f, >00, >a0, >00                             ; Face 8
     AE56 A000     
37270 AE58 FF6B            byte >ff, >6b, >6b, >6b                             ; Face 9
     AE5A 6B6B     
37271 AE5C 7F6B            byte >7f, >6b, >6b, >6b                             ; Face 10
     AE5E 6B6B     
37272 AE60 3F6B            byte >3f, >6b, >6b, >6b                             ; Face 11
     AE62 6B6B     
37273 AE64 BF6B            byte >bf, >6b, >6b, >6b                             ; Face 12
     AE66 6B6B     
37274 AE68 3F00            byte >3f, >00, >00, >a0                             ; Face 13
     AE6A 00A0     
37275               
37276               * ******************************************************************************
37277               *
37278               * Name: SHIP_MISSILE
37279               * Type: Variable
37280               * Category: Drawing ships
37281               * Summary: Ship blueprint for a missile
37282               * Deep dive: Ship blueprints
37283               *
37284               * ******************************************************************************
37285               
37286               SHIP_MISSILE:
37287 AE6C 00              byte >00                                            ; Max. canisters on demise = 0
37288 AE6E 0640            data 40 * 40                                        ; Targetable area          = 40 * 40
37289               
37290 AE70 7C              byte (SHIP_MISSILE_EDGES - SHIP_MISSILE)%256        ; Edges data offset (low)
37291 AE71   DC            byte (SHIP_MISSILE_FACES - SHIP_MISSILE)%256        ; Faces data offset (low)
37292               
37293 AE72 51              byte >51                                            ; Max. edge count          = (81 - 1) / 4 = 20
37294 AE73   00            byte >00                                            ; Gun vertex               = 0
37295 AE74 0A              byte >0a                                            ; Explosion count          = 1, as (4 * n) + 6 = 10
37296 AE75   66            byte >66                                            ; Number of vertices       = 102 / 6 = 17
37297 AE76 18              byte >18                                            ; Number of edges          = 24
37298 AE78 0000            data >0000                                          ; Bounty                   = 0
37299 AE7A 24              byte >24                                            ; Number of faces          = 36 / 4 = 9
37300 AE7B   0E            byte >0e                                            ; Visibility distance      = 14
37301 AE7C 02              byte >02                                            ; Max. energy              = 2
37302 AE7D   2C            byte >2c                                            ; Max. speed               = 44
37303               
37304 AE7E 00              byte (SHIP_MISSILE_EDGES - SHIP_MISSILE)/256        ; Edges data offset (high)
37305 AE7F   00            byte (SHIP_MISSILE_FACES - SHIP_MISSILE)/256        ; Faces data offset (high)
37306               
37307 AE80 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37308 AE81   00            byte >00                                            ; Laser power              = 0
37309                                                                          ; Missiles                 = 0
37310               
37311               SHIP_MISSILE_VERTICES:
37312                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37313 AE82 0000            byte >00, >00, >44, >1f, >10, >32                   ; Vertex 0
     AE84 441F     
     AE86 1032     
37314 AE88 0808            byte >08, >08, >24, >5f, >21, >54                   ; Vertex 1
     AE8A 245F     
     AE8C 2154     
37315 AE8E 0808            byte >08, >08, >24, >1f, >32, >74                   ; Vertex 2
     AE90 241F     
     AE92 3274     
37316 AE94 0808            byte >08, >08, >24, >9f, >30, >76                   ; Vertex 3
     AE96 249F     
     AE98 3076     
37317 AE9A 0808            byte >08, >08, >24, >df, >10, >65                   ; Vertex 4
     AE9C 24DF     
     AE9E 1065     
37318 AEA0 0808            byte >08, >08, >2c, >3f, >74, >88                   ; Vertex 5
     AEA2 2C3F     
     AEA4 7488     
37319 AEA6 0808            byte >08, >08, >2c, >7f, >54, >88                   ; Vertex 6
     AEA8 2C7F     
     AEAA 5488     
37320 AEAC 0808            byte >08, >08, >2c, >ff, >65, >88                   ; Vertex 7
     AEAE 2CFF     
     AEB0 6588     
37321 AEB2 0808            byte >08, >08, >2c, >bf, >76, >88                   ; Vertex 8
     AEB4 2CBF     
     AEB6 7688     
37322 AEB8 0C0C            byte >0c, >0c, >2c, >28, >74, >88                   ; Vertex 9
     AEBA 2C28     
     AEBC 7488     
37323 AEBE 0C0C            byte >0c, >0c, >2c, >68, >54, >88                   ; Vertex 10
     AEC0 2C68     
     AEC2 5488     
37324 AEC4 0C0C            byte >0c, >0c, >2c, >e8, >65, >88                   ; Vertex 11
     AEC6 2CE8     
     AEC8 6588     
37325 AECA 0C0C            byte >0c, >0c, >2c, >a8, >76, >88                   ; Vertex 12
     AECC 2CA8     
     AECE 7688     
37326 AED0 0808            byte >08, >08, >0c, >a8, >76, >77                   ; Vertex 13
     AED2 0CA8     
     AED4 7677     
37327 AED6 0808            byte >08, >08, >0c, >e8, >65, >66                   ; Vertex 14
     AED8 0CE8     
     AEDA 6566     
37328 AEDC 0808            byte >08, >08, >0c, >28, >74, >77                   ; Vertex 15
     AEDE 0C28     
     AEE0 7477     
37329 AEE2 0808            byte >08, >08, >0c, >68, >54, >55                   ; Vertex 16
     AEE4 0C68     
     AEE6 5455     
37330               
37331               SHIP_MISSILE_EDGES:
37332                                                                          ; vertex1, vertex2, face1, face2, visibility
37333 AEE8 1F21            byte >1f, >21, >00, >04                             ; Edge 0
     AEEA 0004     
37334 AEEC 1F32            byte >1f, >32, >00, >08                             ; Edge 1
     AEEE 0008     
37335 AEF0 1F30            byte >1f, >30, >00, >0c                             ; Edge 2
     AEF2 000C     
37336 AEF4 1F10            byte >1f, >10, >00, >10                             ; Edge 3
     AEF6 0010     
37337 AEF8 1F24            byte >1f, >24, >04, >08                             ; Edge 4
     AEFA 0408     
37338 AEFC 1F51            byte >1f, >51, >04, >10                             ; Edge 5
     AEFE 0410     
37339 AF00 1F60            byte >1f, >60, >0c, >10                             ; Edge 6
     AF02 0C10     
37340 AF04 1F73            byte >1f, >73, >08, >0c                             ; Edge 7
     AF06 080C     
37341 AF08 1F74            byte >1f, >74, >08, >14                             ; Edge 8
     AF0A 0814     
37342 AF0C 1F54            byte >1f, >54, >04, >18                             ; Edge 9
     AF0E 0418     
37343 AF10 1F65            byte >1f, >65, >10, >1c                             ; Edge 10
     AF12 101C     
37344 AF14 1F76            byte >1f, >76, >0c, >20                             ; Edge 11
     AF16 0C20     
37345 AF18 1F86            byte >1f, >86, >1c, >20                             ; Edge 12
     AF1A 1C20     
37346 AF1C 1F87            byte >1f, >87, >14, >20                             ; Edge 13
     AF1E 1420     
37347 AF20 1F84            byte >1f, >84, >14, >18                             ; Edge 14
     AF22 1418     
37348 AF24 1F85            byte >1f, >85, >18, >1c                             ; Edge 15
     AF26 181C     
37349 AF28 0885            byte >08, >85, >18, >28                             ; Edge 16
     AF2A 1828     
37350 AF2C 0887            byte >08, >87, >14, >24                             ; Edge 17
     AF2E 1424     
37351 AF30 0887            byte >08, >87, >20, >30                             ; Edge 18
     AF32 2030     
37352 AF34 0885            byte >08, >85, >1c, >2c                             ; Edge 19
     AF36 1C2C     
37353 AF38 0874            byte >08, >74, >24, >3c                             ; Edge 20
     AF3A 243C     
37354 AF3C 0854            byte >08, >54, >28, >40                             ; Edge 21
     AF3E 2840     
37355 AF40 0876            byte >08, >76, >30, >34                             ; Edge 22
     AF42 3034     
37356 AF44 0865            byte >08, >65, >2c, >38                             ; Edge 23
     AF46 2C38     
37357               
37358               SHIP_MISSILE_FACES:
37359                                                                          ; normal_x, normal_y, normal_z, visibility
37360 AF48 9F40            byte >9f, >40, >00, >10                             ; Face 0
     AF4A 0010     
37361 AF4C 5F00            byte >5f, >00, >40, >10                             ; Face 1
     AF4E 4010     
37362 AF50 1F40            byte >1f, >40, >00, >10                             ; Face 2
     AF52 0010     
37363 AF54 1F00            byte >1f, >00, >40, >10                             ; Face 3
     AF56 4010     
37364 AF58 1F20            byte >1f, >20, >00, >00                             ; Face 4
     AF5A 0000     
37365 AF5C 5F00            byte >5f, >00, >20, >00                             ; Face 5
     AF5E 2000     
37366 AF60 9F20            byte >9f, >20, >00, >00                             ; Face 6
     AF62 0000     
37367 AF64 1F00            byte >1f, >00, >20, >00                             ; Face 7
     AF66 2000     
37368 AF68 3F00            byte >3f, >00, >00, >b0                             ; Face 8
     AF6A 00B0     
37369               
37370               * ******************************************************************************
37371               *
37372               * Name: SHIP_ASTEROID
37373               * Type: Variable
37374               * Category: Drawing ships
37375               * Summary: Ship blueprint for an asteroid
37376               * Deep dive: Ship blueprints
37377               *
37378               * ******************************************************************************
37379               
37380               SHIP_ASTEROID:
37381 AF6C 00              byte >00                                            ; Max. canisters on demise = 0
37382 AF6E 1900            data 80 * 80                                        ; Targetable area          = 80 * 80
37383               
37384 AF70 4C              byte (SHIP_ASTEROID_EDGES - SHIP_ASTEROID)%256      ; Edges data offset (low)
37385 AF71   A0            byte (SHIP_ASTEROID_FACES - SHIP_ASTEROID)%256      ; Faces data offset (low)
37386               
37387 AF72 41              byte >41                                            ; Max. edge count          = (65 - 1) / 4 = 16
37388 AF73   00            byte >00                                            ; Gun vertex               = 0
37389 AF74 22              byte >22                                            ; Explosion count          = 7, as (4 * n) + 6 = 34
37390 AF75   36            byte >36                                            ; Number of vertices       = 54 / 6 = 9
37391 AF76 15              byte >15                                            ; Number of edges          = 21
37392 AF78 0500            data >0500                                          ; Bounty                   = 5
37393 AF7A 38              byte >38                                            ; Number of faces          = 56 / 4 = 14
37394 AF7B   32            byte >32                                            ; Visibility distance      = 50
37395 AF7C 3C              byte >3c                                            ; Max. energy              = 60
37396 AF7D   1E            byte >1e                                            ; Max. speed               = 30
37397               
37398 AF7E 00              byte (SHIP_ASTEROID_EDGES - SHIP_ASTEROID)/256      ; Edges data offset (high)
37399 AF7F   00            byte (SHIP_ASTEROID_FACES - SHIP_ASTEROID)/256      ; Faces data offset (high)
37400               
37401 AF80 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
37402 AF81   00            byte >00                                            ; Laser power              = 0
37403                                                                          ; Missiles                 = 0
37404               
37405               SHIP_ASTEROID_VERTICES:
37406                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37407 AF82 0050            byte >00, >50, >00, >1f, >ff, >ff                   ; Vertex 0
     AF84 001F     
     AF86 FFFF     
37408 AF88 500A            byte >50, >0a, >00, >df, >ff, >ff                   ; Vertex 1
     AF8A 00DF     
     AF8C FFFF     
37409 AF8E 0050            byte >00, >50, >00, >5f, >ff, >ff                   ; Vertex 2
     AF90 005F     
     AF92 FFFF     
37410 AF94 4628            byte >46, >28, >00, >5f, >ff, >ff                   ; Vertex 3
     AF96 005F     
     AF98 FFFF     
37411 AF9A 3C32            byte >3c, >32, >00, >1f, >65, >dc                   ; Vertex 4
     AF9C 001F     
     AF9E 65DC     
37412 AFA0 3200            byte >32, >00, >3c, >1f, >ff, >ff                   ; Vertex 5
     AFA2 3C1F     
     AFA4 FFFF     
37413 AFA6 2800            byte >28, >00, >46, >9f, >10, >32                   ; Vertex 6
     AFA8 469F     
     AFAA 1032     
37414 AFAC 001E            byte >00, >1e, >4b, >3f, >ff, >ff                   ; Vertex 7
     AFAE 4B3F     
     AFB0 FFFF     
37415 AFB2 0032            byte >00, >32, >3c, >7f, >98, >ba                   ; Vertex 8
     AFB4 3C7F     
     AFB6 98BA     
37416               
37417               SHIP_ASTEROID_EDGES:
37418                                                                          ; vertex1, vertex2, face1, face2, visibility
37419 AFB8 1F72            byte >1f, >72, >00, >04                             ; Edge 0
     AFBA 0004     
37420 AFBC 1FD6            byte >1f, >d6, >00, >10                             ; Edge 1
     AFBE 0010     
37421 AFC0 1FC5            byte >1f, >c5, >0c, >10                             ; Edge 2
     AFC2 0C10     
37422 AFC4 1FB4            byte >1f, >b4, >08, >0c                             ; Edge 3
     AFC6 080C     
37423 AFC8 1FA3            byte >1f, >a3, >04, >08                             ; Edge 4
     AFCA 0408     
37424 AFCC 1F32            byte >1f, >32, >04, >18                             ; Edge 5
     AFCE 0418     
37425 AFD0 1F31            byte >1f, >31, >08, >18                             ; Edge 6
     AFD2 0818     
37426 AFD4 1F41            byte >1f, >41, >08, >14                             ; Edge 7
     AFD6 0814     
37427 AFD8 1F10            byte >1f, >10, >14, >18                             ; Edge 8
     AFDA 1418     
37428 AFDC 1F60            byte >1f, >60, >00, >14                             ; Edge 9
     AFDE 0014     
37429 AFE0 1F54            byte >1f, >54, >0c, >14                             ; Edge 10
     AFE2 0C14     
37430 AFE4 1F20            byte >1f, >20, >00, >18                             ; Edge 11
     AFE6 0018     
37431 AFE8 1F65            byte >1f, >65, >10, >14                             ; Edge 12
     AFEA 1014     
37432 AFEC 1FA8            byte >1f, >a8, >04, >20                             ; Edge 13
     AFEE 0420     
37433 AFF0 1F87            byte >1f, >87, >04, >1c                             ; Edge 14
     AFF2 041C     
37434 AFF4 1FD7            byte >1f, >d7, >00, >1c                             ; Edge 15
     AFF6 001C     
37435 AFF8 1FDC            byte >1f, >dc, >10, >1c                             ; Edge 16
     AFFA 101C     
37436 AFFC 1FC9            byte >1f, >c9, >0c, >1c                             ; Edge 17
     AFFE 0C1C     
37437 B000 1FB9            byte >1f, >b9, >0c, >20                             ; Edge 18
     B002 0C20     
37438 B004 1FBA            byte >1f, >ba, >08, >20                             ; Edge 19
     B006 0820     
37439 B008 1F98            byte >1f, >98, >1c, >20                             ; Edge 20
     B00A 1C20     
37440               
37441               SHIP_ASTEROID_FACES:
37442                                                                          ; normal_x, normal_y, normal_z, visibility
37443 B00C 1F09            byte >1f, >09, >42, >51                             ; Face 0
     B00E 4251     
37444 B010 5F09            byte >5f, >09, >42, >51                             ; Face 1
     B012 4251     
37445 B014 9F48            byte >9f, >48, >40, >1f                             ; Face 2
     B016 401F     
37446 B018 DF40            byte >df, >40, >49, >2f                             ; Face 3
     B01A 492F     
37447 B01C 5F2D            byte >5f, >2d, >4f, >41                             ; Face 4
     B01E 4F41     
37448 B020 1F87            byte >1f, >87, >0f, >23                             ; Face 5
     B022 0F23     
37449 B024 1F26            byte >1f, >26, >4c, >46                             ; Face 6
     B026 4C46     
37450 B028 BF42            byte >bf, >42, >3b, >27                             ; Face 7
     B02A 3B27     
37451 B02C FF43            byte >ff, >43, >0f, >50                             ; Face 8
     B02E 0F50     
37452 B030 7F42            byte >7f, >42, >0e, >4b                             ; Face 9
     B032 0E4B     
37453 B034 FF46            byte >ff, >46, >50, >28                             ; Face 10
     B036 5028     
37454 B038 7F3A            byte >7f, >3a, >66, >33                             ; Face 11
     B03A 6633     
37455 B03C 3F51            byte >3f, >51, >09, >43                             ; Face 12
     B03E 0943     
37456 B040 3F2F            byte >3f, >2f, >5e, >3f                             ; Face 13
     B042 5E3F     
37457               
37458               * ******************************************************************************
37459               *
37460               * Name: SHIP_CANISTER
37461               * Type: Variable
37462               * Category: Drawing ships
37463               * Summary: Ship blueprint for a cargo canister
37464               * Deep dive: Ship blueprints
37465               *
37466               * ******************************************************************************
37467               
37468               SHIP_CANISTER:
37469 B044 00              byte >00                                            ; Max. canisters on demise = 0
37470 B046 0190            data 20 * 20                                        ; Targetable area          = 20 * 20
37471               
37472 B048 52              byte (SHIP_CANISTER_EDGES - SHIP_CANISTER)%256      ; Edges data offset (low)
37473 B049   8E            byte (SHIP_CANISTER_FACES - SHIP_CANISTER)%256      ; Faces data offset (low)
37474               
37475 B04A 31              byte >31                                            ; Max. edge count          = (49 - 1) / 4 = 12
37476 B04B   00            byte >00                                            ; Gun vertex               = 0
37477 B04C 12              byte >12                                            ; Explosion count          = 3, as (4 * n) + 6 = 18
37478 B04D   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
37479 B04E 0F              byte >0f                                            ; Number of edges          = 15
37480 B050 0000            data >0000                                          ; Bounty                   = 0
37481 B052 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
37482 B053   0C            byte >0c                                            ; Visibility distance      = 12
37483 B054 11              byte >11                                            ; Max. energy              = 17
37484 B055   0F            byte >0f                                            ; Max. speed               = 15
37485               
37486 B056 00              byte (SHIP_CANISTER_EDGES - SHIP_CANISTER)/256      ; Edges data offset (high)
37487 B057   00            byte (SHIP_CANISTER_FACES - SHIP_CANISTER)/256      ; Faces data offset (high)
37488               
37489 B058 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37490 B059   00            byte >00                                            ; Laser power              = 0
37491                                                                          ; Missiles                 = 0
37492               
37493               SHIP_CANISTER_VERTICES:
37494                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37495 B05A 1810            byte >18, >10, >00, >1f, >10, >55                   ; Vertex 0
     B05C 001F     
     B05E 1055     
37496 B060 1805            byte >18, >05, >0f, >1f, >10, >22                   ; Vertex 1
     B062 0F1F     
     B064 1022     
37497 B066 180D            byte >18, >0d, >09, >5f, >20, >33                   ; Vertex 2
     B068 095F     
     B06A 2033     
37498 B06C 180D            byte >18, >0d, >09, >7f, >30, >44                   ; Vertex 3
     B06E 097F     
     B070 3044     
37499 B072 1805            byte >18, >05, >0f, >3f, >40, >55                   ; Vertex 4
     B074 0F3F     
     B076 4055     
37500 B078 1810            byte >18, >10, >00, >9f, >51, >66                   ; Vertex 5
     B07A 009F     
     B07C 5166     
37501 B07E 1805            byte >18, >05, >0f, >9f, >21, >66                   ; Vertex 6
     B080 0F9F     
     B082 2166     
37502 B084 180D            byte >18, >0d, >09, >df, >32, >66                   ; Vertex 7
     B086 09DF     
     B088 3266     
37503 B08A 180D            byte >18, >0d, >09, >ff, >43, >66                   ; Vertex 8
     B08C 09FF     
     B08E 4366     
37504 B090 1805            byte >18, >05, >0f, >bf, >54, >66                   ; Vertex 9
     B092 0FBF     
     B094 5466     
37505               
37506               SHIP_CANISTER_EDGES:
37507                                                                          ; vertex1, vertex2, face1, face2, visibility
37508 B096 1F10            byte >1f, >10, >00, >04                             ; Edge 0
     B098 0004     
37509 B09A 1F20            byte >1f, >20, >04, >08                             ; Edge 1
     B09C 0408     
37510 B09E 1F30            byte >1f, >30, >08, >0c                             ; Edge 2
     B0A0 080C     
37511 B0A2 1F40            byte >1f, >40, >0c, >10                             ; Edge 3
     B0A4 0C10     
37512 B0A6 1F50            byte >1f, >50, >00, >10                             ; Edge 4
     B0A8 0010     
37513 B0AA 1F51            byte >1f, >51, >00, >14                             ; Edge 5
     B0AC 0014     
37514 B0AE 1F21            byte >1f, >21, >04, >18                             ; Edge 6
     B0B0 0418     
37515 B0B2 1F32            byte >1f, >32, >08, >1c                             ; Edge 7
     B0B4 081C     
37516 B0B6 1F43            byte >1f, >43, >0c, >20                             ; Edge 8
     B0B8 0C20     
37517 B0BA 1F54            byte >1f, >54, >10, >24                             ; Edge 9
     B0BC 1024     
37518 B0BE 1F61            byte >1f, >61, >14, >18                             ; Edge 10
     B0C0 1418     
37519 B0C2 1F62            byte >1f, >62, >18, >1c                             ; Edge 11
     B0C4 181C     
37520 B0C6 1F63            byte >1f, >63, >1c, >20                             ; Edge 12
     B0C8 1C20     
37521 B0CA 1F64            byte >1f, >64, >20, >24                             ; Edge 13
     B0CC 2024     
37522 B0CE 1F65            byte >1f, >65, >24, >14                             ; Edge 14
     B0D0 2414     
37523               
37524               SHIP_CANISTER_FACES:
37525                                                                          ; normal_x, normal_y, normal_z, visibility
37526 B0D2 1F60            byte >1f, >60, >00, >00                             ; Face 0
     B0D4 0000     
37527 B0D6 1F00            byte >1f, >00, >29, >1e                             ; Face 1
     B0D8 291E     
37528 B0DA 5F00            byte >5f, >00, >12, >30                             ; Face 2
     B0DC 1230     
37529 B0DE 5F00            byte >5f, >00, >33, >00                             ; Face 3
     B0E0 3300     
37530 B0E2 7F00            byte >7f, >00, >12, >30                             ; Face 4
     B0E4 1230     
37531 B0E6 3F00            byte >3f, >00, >29, >1e                             ; Face 5
     B0E8 291E     
37532 B0EA 9F60            byte >9f, >60, >00, >00                             ; Face 6
     B0EC 0000     
37533               
37534               * ******************************************************************************
37535               *
37536               * Name: SHIP_THARGON
37537               * Type: Variable
37538               * Category: Drawing ships
37539               * Summary: Ship blueprint for a Thargon
37540               * Deep dive: Ship blueprints
37541               *
37542               * ------------------------------------------------------------------------------
37543               *
37544               * The ship blueprint for the Thargon reuses the edges data from the cargo
37545               * canister, so the edges data offset is negative.
37546               *
37547               * ******************************************************************************
37548               
37549               SHIP_THARGON:
37550 B0EE 00              byte >00                                            ; Max. canisters on demise = 0
37551 B0F0 0640            data 40 * 40                                        ; Targetable area          = 40 * 40
37552               
37553 B0F2 58              byte (SHIP_CANISTER_EDGES - SHIP_THARGON)%256       ; Edges from canister
37554 B0F3   52            byte (SHIP_THARGON_FACES - SHIP_THARGON)%256        ; Faces data offset (low)
37555               
37556 B0F4 41              byte >41                                            ; Max. edge count          = (65 - 1) / 4 = 16
37557 B0F5   00            byte >00                                            ; Gun vertex               = 0
37558 B0F6 12              byte >12                                            ; Explosion count          = 3, as (4 * n) + 6 = 18
37559 B0F7   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
37560 B0F8 0F              byte >0f                                            ; Number of edges          = 15
37561 B0FA 3200            data >3200                                          ; Bounty                   = 50
37562 B0FC 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
37563 B0FD   14            byte >14                                            ; Visibility distance      = 20
37564 B0FE 14              byte >14                                            ; Max. energy              = 20
37565 B0FF   1E            byte >1e                                            ; Max. speed               = 30
37566               
37567 B100 00              byte (SHIP_CANISTER_EDGES - SHIP_THARGON)/256       ; Edges from canister
37568 B101   00            byte (SHIP_THARGON_FACES - SHIP_THARGON)/256        ; Faces data offset (high)
37569               
37570 B102 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37571 B103   10            byte >10                                            ; Laser power              = 2
37572                                                                          ; Missiles                 = 0
37573               
37574               SHIP_THARGON_VERTICES:
37575                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37576 B104 0900            byte >09, >00, >28, >9f, >01, >55                   ; Vertex 0
     B106 289F     
     B108 0155     
37577 B10A 0926            byte >09, >26, >0c, >df, >01, >22                   ; Vertex 1
     B10C 0CDF     
     B10E 0122     
37578 B110 0918            byte >09, >18, >20, >ff, >02, >33                   ; Vertex 2
     B112 20FF     
     B114 0233     
37579 B116 0918            byte >09, >18, >20, >bf, >03, >44                   ; Vertex 3
     B118 20BF     
     B11A 0344     
37580 B11C 0926            byte >09, >26, >0c, >9f, >04, >55                   ; Vertex 4
     B11E 0C9F     
     B120 0455     
37581 B122 0900            byte >09, >00, >08, >3f, >15, >66                   ; Vertex 5
     B124 083F     
     B126 1566     
37582 B128 090A            byte >09, >0a, >0f, >7f, >12, >66                   ; Vertex 6
     B12A 0F7F     
     B12C 1266     
37583 B12E 0906            byte >09, >06, >1a, >7f, >23, >66                   ; Vertex 7
     B130 1A7F     
     B132 2366     
37584 B134 0906            byte >09, >06, >1a, >3f, >34, >66                   ; Vertex 8
     B136 1A3F     
     B138 3466     
37585 B13A 090A            byte >09, >0a, >0f, >3f, >45, >66                   ; Vertex 9
     B13C 0F3F     
     B13E 4566     
37586               
37587               SHIP_THARGON_FACES:
37588                                                                          ; normal_x, normal_y, normal_z, visibility
37589 B140 9F24            byte >9f, >24, >00, >00                             ; Face 0
     B142 0000     
37590 B144 5F14            byte >5f, >14, >05, >07                             ; Face 1
     B146 0507     
37591 B148 7F2E            byte >7f, >2e, >2a, >0e                             ; Face 2
     B14A 2A0E     
37592 B14C 3F24            byte >3f, >24, >00, >68                             ; Face 3
     B14E 0068     
37593 B150 3F2E            byte >3f, >2e, >2a, >0e                             ; Face 4
     B152 2A0E     
37594 B154 1F14            byte >1f, >14, >05, >07                             ; Face 5
     B156 0507     
37595 B158 1F24            byte >1f, >24, >00, >00                             ; Face 6
     B15A 0000     
37596               
37597               * ******************************************************************************
37598               *
37599               * Name: SHIP_ESCAPE_POD
37600               * Type: Variable
37601               * Category: Drawing ships
37602               * Summary: Ship blueprint for an escape pod
37603               * Deep dive: Ship blueprints
37604               *
37605               * ******************************************************************************
37606               
37607               SHIP_ESCAPE_POD:
37608 B15C 00              byte >00                                            ; Max. canisters on demise = 0
37609 B15E 0100            data 16 * 16                                        ; Targetable area          = 16 * 16
37610               
37611 B160 2E              byte (SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)%256  ; Edges data offset (low)
37612 B161   46            byte (SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)%256  ; Faces data offset (low)
37613               
37614 B162 19              byte >19                                            ; Max. edge count          = (25 - 1) / 4 = 6
37615 B163   00            byte >00                                            ; Gun vertex               = 0
37616 B164 16              byte >16                                            ; Explosion count          = 4, as (4 * n) + 6 = 22
37617 B165   18            byte >18                                            ; Number of vertices       = 24 / 6 = 4
37618 B166 06              byte >06                                            ; Number of edges          = 6
37619 B168 0000            data >0000                                          ; Bounty                   = 0
37620 B16A 10              byte >10                                            ; Number of faces          = 16 / 4 = 4
37621 B16B   08            byte >08                                            ; Visibility distance      = 8
37622 B16C 11              byte >11                                            ; Max. energy              = 17
37623 B16D   08            byte >08                                            ; Max. speed               = 8
37624               
37625 B16E 00              byte (SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)/256  ; Edges data offset (high)
37626 B16F   00            byte (SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)/256  ; Faces data offset (high)
37627               
37628 B170 03              byte >03                                            ; Normals are scaled by    =  2^3 = 8
37629 B171   00            byte >00                                            ; Laser power              = 0
37630                                                                          ; Missiles                 = 0
37631               
37632               SHIP_ESCAPE_POD_VERTICES:
37633                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37634 B172 0700            byte >07, >00, >24, >9f, >12, >33                   ; Vertex 0
     B174 249F     
     B176 1233     
37635 B178 070E            byte >07, >0e, >0c, >ff, >02, >33                   ; Vertex 1
     B17A 0CFF     
     B17C 0233     
37636 B17E 070E            byte >07, >0e, >0c, >bf, >01, >33                   ; Vertex 2
     B180 0CBF     
     B182 0133     
37637 B184 1500            byte >15, >00, >00, >1f, >01, >22                   ; Vertex 3
     B186 001F     
     B188 0122     
37638               
37639               SHIP_ESCAPE_POD_EDGES:
37640                                                                          ; vertex1, vertex2, face1, face2, visibility
37641 B18A 1F23            byte >1f, >23, >00, >04                             ; Edge 0
     B18C 0004     
37642 B18E 1F03            byte >1f, >03, >04, >08                             ; Edge 1
     B190 0408     
37643 B192 1F01            byte >1f, >01, >08, >0c                             ; Edge 2
     B194 080C     
37644 B196 1F12            byte >1f, >12, >0c, >00                             ; Edge 3
     B198 0C00     
37645 B19A 1F13            byte >1f, >13, >00, >08                             ; Edge 4
     B19C 0008     
37646 B19E 1F02            byte >1f, >02, >0c, >04                             ; Edge 5
     B1A0 0C04     
37647               
37648               SHIP_ESCAPE_POD_FACES:
37649                                                                          ; normal_x, normal_y, normal_z, visibility
37650 B1A2 3F1A            byte >3f, >1a, >00, >3d                             ; Face 0
     B1A4 003D     
37651 B1A6 1F13            byte >1f, >13, >33, >0f                             ; Face 1
     B1A8 330F     
37652 B1AA 5F13            byte >5f, >13, >33, >0f                             ; Face 2
     B1AC 330F     
37653 B1AE 9F38            byte >9f, >38, >00, >00                             ; Face 3
     B1B0 0000     
37654               
37655               * ******************************************************************************
37656               *
37657               * Save SHIPS.bin
37658               *
37659               * ******************************************************************************
37660               
37661                      ; PRINT "SHIPS"
37662                      ; PRINT "Assembled at ", ~CODE_SHIPS%
37663                      ; PRINT "Ends at ", ~P%
37664                      ; PRINT "Code size is ", ~(P% - CODE_SHIPS%)
37665                      ; PRINT "Execute at ", ~LOAD%
37666                      ; PRINT "Reload at ", ~LOAD_SHIPS%
37667               
37668                      ; PRINT "S.SHIPS ", ~CODE_SHIPS%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_SHIPS%
37669                      ; SAVE "3-assembled-output/SHIPS.bin", CODE_SHIPS%, P%, LOAD%
37670               
37671               * ******************************************************************************
37672               *
37673               * ELITE PYTHON SHIP BLUEPRINT FILE
37674               *
37675               * Produces the binary file PYTHON.bin that gets loaded by elite-bcfs.asm.
37676               *
37677               * ******************************************************************************
37678               
37679                      ; CLEAR 0, &7F00                ; CLEAR 0, &7F00
37680               
37681               LOAD_PYTHON.:
37682                      equ >1B00
37683               
37684                      aorg CODE_PYTHON.
37685               
37686               * ******************************************************************************
37687               *
37688               * Name: SHIP_PYTHON
37689               * Type: Variable
37690               * Category: Drawing ships
37691               * Summary: Ship blueprint for a Python
37692               * Deep dive: Ship blueprints
37693               *
37694               * ******************************************************************************
37695               
37696               SHIP_PYTHON:
37697 7F00 03              byte >03                                            ; Max. canisters on demise = 3
37698 7F02 3840            data 120 * 120                                      ; Targetable area          = 120 * 120
37699               
37700 7F04 58              byte (SHIP_PYTHON_EDGES - SHIP_PYTHON)%256          ; Edges data offset (low)
37701 7F05   C0            byte (SHIP_PYTHON_FACES - SHIP_PYTHON)%256          ; Faces data offset (low)
37702               
37703 7F06 55              byte >55                                            ; Max. edge count          = (85 - 1) / 4 = 21
37704 7F07   00            byte >00                                            ; Gun vertex               = 0
37705 7F08 2E              byte >2e                                            ; Explosion count          = 10, as (4 * n) + 6 = 46
37706 7F09   42            byte >42                                            ; Number of vertices       = 66 / 6 = 11
37707 7F0A 1A              byte >1a                                            ; Number of edges          = 26
37708 7F0C C800            data >c800                                          ; Bounty                   = 200
37709 7F0E 34              byte >34                                            ; Number of faces          = 52 / 4 = 13
37710 7F0F   28            byte >28                                            ; Visibility distance      = 40
37711 7F10 FA              byte >fa                                            ; Max. energy              = 250
37712 7F11   14            byte >14                                            ; Max. speed               = 20
37713               
37714 7F12 00              byte (SHIP_PYTHON_EDGES - SHIP_PYTHON)/256          ; Edges data offset (high)
37715 7F13   00            byte (SHIP_PYTHON_FACES - SHIP_PYTHON)/256          ; Faces data offset (high)
37716               
37717 7F14 00              byte >00                                            ; Normals are scaled by    = 2^0 = 1
37718 7F15   1B            byte >1b                                            ; Laser power              = 3
37719                                                                          ; Missiles                 = 3
37720               
37721               SHIP_PYTHON_VERTICES:
37722                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37723 7F16 0000            byte >00, >00, >e0, >1f, >10, >32                   ; Vertex 0
     7F18 E01F     
     7F1A 1032     
37724 7F1C 0030            byte >00, >30, >30, >1e, >10, >54                   ; Vertex 1
     7F1E 301E     
     7F20 1054     
37725 7F22 6000            byte >60, >00, >10, >3f, >ff, >ff                   ; Vertex 2
     7F24 103F     
     7F26 FFFF     
37726 7F28 6000            byte >60, >00, >10, >bf, >ff, >ff                   ; Vertex 3
     7F2A 10BF     
     7F2C FFFF     
37727 7F2E 0030            byte >00, >30, >20, >3e, >54, >98                   ; Vertex 4
     7F30 203E     
     7F32 5498     
37728 7F34 0018            byte >00, >18, >70, >3f, >89, >cc                   ; Vertex 5
     7F36 703F     
     7F38 89CC     
37729 7F3A 3000            byte >30, >00, >70, >bf, >b8, >cc                   ; Vertex 6
     7F3C 70BF     
     7F3E B8CC     
37730 7F40 3000            byte >30, >00, >70, >3f, >a9, >cc                   ; Vertex 7
     7F42 703F     
     7F44 A9CC     
37731 7F46 0030            byte >00, >30, >30, >5e, >32, >76                   ; Vertex 8
     7F48 305E     
     7F4A 3276     
37732 7F4C 0030            byte >00, >30, >20, >7e, >76, >ba                   ; Vertex 9
     7F4E 207E     
     7F50 76BA     
37733 7F52 0018            byte >00, >18, >70, >7e, >ba, >cc                   ; Vertex 10
     7F54 707E     
     7F56 BACC     
37734               
37735               SHIP_PYTHON_EDGES:
37736                                                                          ; vertex1, vertex2, face1, face2, visibility
37737 7F58 1E32            byte >1e, >32, >00, >20                             ; Edge 0
     7F5A 0020     
37738 7F5C 1F20            byte >1f, >20, >00, >0c                             ; Edge 1
     7F5E 000C     
37739 7F60 1F31            byte >1f, >31, >00, >08                             ; Edge 2
     7F62 0008     
37740 7F64 1E10            byte >1e, >10, >00, >04                             ; Edge 3
     7F66 0004     
37741 7F68 1D59            byte >1d, >59, >08, >10                             ; Edge 4
     7F6A 0810     
37742 7F6C 1D51            byte >1d, >51, >04, >08                             ; Edge 5
     7F6E 0408     
37743 7F70 1D37            byte >1d, >37, >08, >20                             ; Edge 6
     7F72 0820     
37744 7F74 1D40            byte >1d, >40, >04, >0c                             ; Edge 7
     7F76 040C     
37745 7F78 1D62            byte >1d, >62, >0c, >20                             ; Edge 8
     7F7A 0C20     
37746 7F7C 1DA7            byte >1d, >a7, >08, >24                             ; Edge 9
     7F7E 0824     
37747 7F80 1D84            byte >1d, >84, >0c, >10                             ; Edge 10
     7F82 0C10     
37748 7F84 1DB6            byte >1d, >b6, >0c, >24                             ; Edge 11
     7F86 0C24     
37749 7F88 0588            byte >05, >88, >0c, >14                             ; Edge 12
     7F8A 0C14     
37750 7F8C 05BB            byte >05, >bb, >0c, >28                             ; Edge 13
     7F8E 0C28     
37751 7F90 0599            byte >05, >99, >08, >14                             ; Edge 14
     7F92 0814     
37752 7F94 05AA            byte >05, >aa, >08, >28                             ; Edge 15
     7F96 0828     
37753 7F98 1FA9            byte >1f, >a9, >08, >1c                             ; Edge 16
     7F9A 081C     
37754 7F9C 1FB8            byte >1f, >b8, >0c, >18                             ; Edge 17
     7F9E 0C18     
37755 7FA0 1FC8            byte >1f, >c8, >14, >18                             ; Edge 18
     7FA2 1418     
37756 7FA4 1FC9            byte >1f, >c9, >14, >1c                             ; Edge 19
     7FA6 141C     
37757 7FA8 1DAC            byte >1d, >ac, >1c, >28                             ; Edge 20
     7FAA 1C28     
37758 7FAC 1DCB            byte >1d, >cb, >18, >28                             ; Edge 21
     7FAE 1828     
37759 7FB0 1D98            byte >1d, >98, >10, >14                             ; Edge 22
     7FB2 1014     
37760 7FB4 1DBA            byte >1d, >ba, >24, >28                             ; Edge 23
     7FB6 2428     
37761 7FB8 1D54            byte >1d, >54, >04, >10                             ; Edge 24
     7FBA 0410     
37762 7FBC 1D76            byte >1d, >76, >20, >24                             ; Edge 25
     7FBE 2024     
37763               
37764               SHIP_PYTHON_FACES:
37765                                                                          ; normal_x, normal_y, normal_z, visibility
37766 7FC0 9E1B            byte >9e, >1b, >28, >0b                             ; Face 0
     7FC2 280B     
37767 7FC4 1E1B            byte >1e, >1b, >28, >0b                             ; Face 1
     7FC6 280B     
37768 7FC8 DE1B            byte >de, >1b, >28, >0b                             ; Face 2
     7FCA 280B     
37769 7FCC 5E1B            byte >5e, >1b, >28, >0b                             ; Face 3
     7FCE 280B     
37770 7FD0 9E13            byte >9e, >13, >26, >00                             ; Face 4
     7FD2 2600     
37771 7FD4 1E13            byte >1e, >13, >26, >00                             ; Face 5
     7FD6 2600     
37772 7FD8 DE13            byte >de, >13, >26, >00                             ; Face 6
     7FDA 2600     
37773 7FDC 5E13            byte >5e, >13, >26, >00                             ; Face 7
     7FDE 2600     
37774 7FE0 BE19            byte >be, >19, >25, >0b                             ; Face 8
     7FE2 250B     
37775 7FE4 3E19            byte >3e, >19, >25, >0b                             ; Face 9
     7FE6 250B     
37776 7FE8 7E19            byte >7e, >19, >25, >0b                             ; Face 10
     7FEA 250B     
37777 7FEC FE19            byte >fe, >19, >25, >0b                             ; Face 11
     7FEE 250B     
37778 7FF0 3E00            byte >3e, >00, >00, >70                             ; Face 12
     7FF2 0070     
37779               
37780 7FF4                 bss 11                                              ; This space appears to be unused
37781               
37782               * ******************************************************************************
37783               *
37784               * Name: SVN
37785               * Type: Variable
37786               * Category: Save and load
37787               * Summary: The "saving in progress" flag
37788               *
37789               * ******************************************************************************
37790               
37791               SVN:
37792 7FFF                 bss 1                                               ; "Saving in progress" flag
37793                                                                          ;
37794                                                                          ; * Non-zero while we are saving a commander
37795                                                                          ;
37796                                                                          ; * 0 otherwise
37797               
37798               * ******************************************************************************
37799               *
37800               * Name: VEC
37801               * Type: Variable
37802               * Category: Drawing the screen
37803               * Summary: The original value of the IRQ1 vector
37804               *
37805               * ******************************************************************************
37806               
37807               VEC:
37808 8000                 bss 2                                               ; VEC = &7FFE
37809                                                                          ;
37810                                                                          ; This gets set to the value of the original IRQ1 vector
37811                                                                          ; by the loading process
37812               
37813               * ******************************************************************************
37814               *
37815               * Save PYTHON.bin
37816               *
37817               * ******************************************************************************
37818               
37819                      ; PRINT "PYTHON"
37820                      ; PRINT "Assembled at ", ~CODE_PYTHON%
37821                      ; PRINT "Ends at ", ~P%
37822                      ; PRINT "Code size is ", ~(P% - CODE_PYTHON%)
37823                      ; PRINT "Execute at ", ~LOAD%
37824                      ; PRINT "Reload at ", ~LOAD_PYTHON%
37825               
37826                      ; PRINT "S.PYTHON ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_PYTHON%
37827                      ; SAVE "3-assembled-output/PYTHON.bin", CODE_PYTHON%, P%, LOAD%
37828               
37829               * ******************************************************************************
37830               *
37831               * Show free space
37832               *
37833               * ******************************************************************************
37834               
37835                      ; PRINT "ELITE game code ", ~(&6000-P%), " bytes free"
37836                      ; PRINT "Ends at ", ~P%
                   < main.a99
0004                      copy "subroutines.a99"
     **** ****     > subroutines.a99
0001               jsr:
0002 8002 D68B  26        movb r11,*rsp
0003 8004 060A  10        dec  rsp
0004 8006 06CB  10        swpb r11
0005 8008 D68B  26        movb r11,*rsp
0006 800A 060A  10        dec  rsp
0007 800C 0456  16        b    *rtmp
0008               
0009               rts:
0010 800E 058A  10        inc  rsp
0011 8010 D2FA  24        movb *rsp+,r11
0012 8012 06CB  10        swpb r11
0013 8014 D2DA  22        movb *rsp,r11
0014 8016 045B  16        b    *r11
0015               
0016               rola:
0017 8018 1702  10        jnc  !
0018 801A 0260  14        ori  ra,>0080
     801C 0080     
0019               !:
0020 801E 1002  10        jmp  !
0021 8020 0240  14        andi ra,>ff7f
     8022 FF7F     
0022               !:
0023 8024 0A10  14        sla  ra,1
0024 8026 045B  16        rt
0025               
0026               rol:
0027 8028 D198  22        movb *rarg1,rtmp
0028 802A 1702  10        jnc  !
0029 802C 0266  14        ori  rtmp,>0080
     802E 0080     
0030               !:
0031 8030 1002  10        jmp  !
0032 8032 0246  14        andi rtmp,>ff7f
     8034 FF7F     
0033               !:
0034 8036 0A16  14        sla  rtmp,1
0035 8038 C606  26        mov  rtmp,*rarg1
0036 803A 045B  16        rt
0037               
0038               rora:
0039 803C 1702  10        jnc  !
0040 803E 0260  14        ori  ra,>0001
     8040 0001     
0041               !:
0042 8042 1002  10        jmp  !
0043 8044 0240  14        andi ra,>fffe
     8046 FFFE     
0044               !:
0045 8048 0B10  14        src  ra,1
0046 804A 0240  14        andi ra,>0080
     804C 0080     
0047 804E C180  14        mov  ra,rtmp
0048 8050 0A96  30        sla  rtmp,9
0049 8052 045B  16        rt
0050               
0051               ror:
0052 8054 D198  22        movb *rarg1,rtmp
0053 8056 1702  10        jnc  !
0054 8058 0266  14        ori  rtmp,>0001
     805A 0001     
0055               !:
0056 805C 1002  10        jmp  !
0057 805E 0246  14        andi rtmp,>fffe
     8060 FFFE     
0058               !:
0059 8062 0B16  14        src  rtmp,1
0060 8064 D606  26        movb rtmp,*rarg1
0061 8066 0246  14        andi rtmp,>0080
     8068 0080     
0062 806A 0A96  30        sla  rtmp,9
0063 806C 045B  16        rt
                   < main.a99
